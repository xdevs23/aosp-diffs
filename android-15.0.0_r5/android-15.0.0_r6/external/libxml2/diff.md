```diff
diff --git a/.gitignore b/.gitignore
index 4b2f754d..c4881df9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,7 +13,6 @@
 /runtest
 /runxmlconf
 /testModule
-/testThreads
 /testapi
 /testchar
 /testdict
@@ -22,7 +21,6 @@
 /testrecurse
 
 # Tests
-/dba100000.xml
 /missing.lst
 /runsuite.log
 /runxmlconf.log
@@ -32,7 +30,6 @@
 # Generated by build system
 /config.h
 /include/libxml/xmlversion.h
-/libxml-2.0-uninstalled.pc
 /libxml-2.0.pc
 /libxml2-config.cmake
 /xml2-config
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 41ebdc54..9c0ccd95 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -30,7 +30,7 @@ gcc:medium:
   extends: .test
   variables:
     BASE_CONFIG: "--with-minimum"
-    CONFIG: "--with-threads --with-tree --with-xpath --with-output --with-html"
+    CONFIG: "--with-threads --with-tree --with-xpath --with-output --with-html --with-iso8859x"
     CFLAGS: "-O2"
 
 gcc:legacy:
@@ -298,3 +298,14 @@ pages:
       - public/devhelp/*.xsl
   only:
     - master@GNOME/libxml2
+
+downstream-nokogiri:
+  # owner: @flavorjones
+  image: ghcr.io/sparklemotion/nokogiri-test:upstream-libxml
+  script:
+    - .gitlab-ci/downstream-nokogiri.sh
+
+downstream-perl:
+  image: registry.gitlab.gnome.org/gnome/libxml2
+  script:
+    - sh .gitlab-ci/downstream-perl.sh
diff --git a/.gitlab-ci/Dockerfile b/.gitlab-ci/Dockerfile
index 0b1fa786..82e08c0e 100644
--- a/.gitlab-ci/Dockerfile
+++ b/.gitlab-ci/Dockerfile
@@ -1,7 +1,7 @@
 # The image is also used for libxslt, that's why we need git and
 # libgcrypt-dev.
 
-FROM ubuntu:23.10
+FROM ubuntu:24.04
 ENV DEBIAN_FRONTEND=noninteractive
 RUN apt-get update && \
     apt-get upgrade -y && \
@@ -14,3 +14,19 @@ RUN apt-get update && \
         cmake meson
 WORKDIR /tests
 RUN curl https://www.w3.org/XML/Test/xmlts20080827.tar.gz |tar xz
+
+# XML::LibXML uses Alien::Libxml2 which has a huge dependency chain.
+# We try to install most dependencies with apt. We also require
+# libxml2-dev to stop Alien::Libxml2 from downloading and building
+# libxml2 on its own.
+RUN apt-get install -y --no-install-recommends \
+        libperl-dev libxml2-dev cpanminus \
+        libalien-build-perl \
+        libio-socket-ssl-perl \
+        libsort-versions-perl \
+        liburi-perl \
+        libxml-namespacesupport-perl  \
+        libxml-sax-perl \
+        libyaml-perl
+RUN cpanm -n Alien::Libxml2
+RUN apt-get remove -y libxml2-dev
diff --git a/.gitlab-ci/downstream-nokogiri.sh b/.gitlab-ci/downstream-nokogiri.sh
new file mode 100755
index 00000000..8ac282db
--- /dev/null
+++ b/.gitlab-ci/downstream-nokogiri.sh
@@ -0,0 +1,14 @@
+#!/usr/bin/env bash
+
+set -e
+
+export LIBXML_DIR=$(pwd)
+export MAKEFLAGS=-j$(nproc)
+export NOCONFIGURE=1
+./autogen.sh
+
+git clone https://github.com/sparklemotion/nokogiri
+cd nokogiri
+bundle install
+bundle exec rake compile -- --with-xml2-source-dir=${LIBXML_DIR}
+bundle exec rake test
diff --git a/.gitlab-ci/downstream-perl.sh b/.gitlab-ci/downstream-perl.sh
new file mode 100644
index 00000000..0505ca30
--- /dev/null
+++ b/.gitlab-ci/downstream-perl.sh
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+set -e
+
+sh autogen.sh --without-python
+make -j$(nproc)
+
+srcdir=$(pwd)
+incdir=$srcdir/include
+libdir=$srcdir/.libs
+
+curl -L https://cpan.metacpan.org/authors/id/S/SH/SHLOMIF/XML-LibXML-2.0210.tar.gz |tar xz
+cd XML-LibXML-2.0210
+
+perl Makefile.PL INC="-I$incdir" LIBS="-L$libdir -lxml2"
+make
+# Known to fail
+LD_LIBRARY_PATH=$libdir make test || true
diff --git a/.gitlab-ci/test_meson.sh b/.gitlab-ci/test_meson.sh
index 3e815fd6..324680e1 100644
--- a/.gitlab-ci/test_meson.sh
+++ b/.gitlab-ci/test_meson.sh
@@ -11,6 +11,7 @@ meson  setup \
        --werror \
        --buildtype=debugoptimized \
        --default-library shared \
+       -Dlegacy=enabled \
        builddir
 
 ninja -C builddir test
diff --git a/Android.bp b/Android.bp
index 44a79659..69f9ca60 100644
--- a/Android.bp
+++ b/Android.bp
@@ -71,7 +71,6 @@ license {
 cc_defaults {
     name: "libxml2-defaults",
     srcs: [
-        "SAX.c",
         "entities.c",
         "encoding.c",
         "error.c",
@@ -176,7 +175,10 @@ cc_library_static {
 
 cc_binary_host {
     name: "xmllint",
-    srcs: ["xmllint.c"],
+    srcs: [
+        "shell.c",
+        "xmllint.c",
+    ],
     cflags: [
         "-Wall",
         "-Werror",
diff --git a/CMakeLists.txt b/CMakeLists.txt
index ef4e0e7b..e38e6b48 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,14 +1,12 @@
 cmake_minimum_required(VERSION 3.18)
 
-file(STRINGS "configure.ac" CONFIGURE_AC_LINES)
-foreach(line ${CONFIGURE_AC_LINES})
-    if(line MATCHES [[^m4_define\(\[(MAJOR_VERSION|MINOR_VERSION|MICRO_VERSION)\],[ \t]*([0-9]+)\)$]])
-        set(LIBXML_${CMAKE_MATCH_1} ${CMAKE_MATCH_2})
-    elseif(line MATCHES "^(LIBXML_MAJOR_VERSION|LIBXML_MINOR_VERSION|LIBXML_MICRO_VERSION)=([0-9]+)$")
-        set(${CMAKE_MATCH_1} ${CMAKE_MATCH_2})
-    endif()
-endforeach()
-set(VERSION "${LIBXML_MAJOR_VERSION}.${LIBXML_MINOR_VERSION}.${LIBXML_MICRO_VERSION}")
+file(READ "VERSION" VERSION)
+string(STRIP ${VERSION} VERSION)
+if(${VERSION} MATCHES [[([0-9]+)\.([0-9]+)\.([0-9]+)]])
+    set(LIBXML_MAJOR_VERSION ${CMAKE_MATCH_1})
+    set(LIBXML_MINOR_VERSION ${CMAKE_MATCH_2})
+    set(LIBXML_MICRO_VERSION ${CMAKE_MATCH_3})
+endif()
 
 project(libxml2 VERSION ${VERSION} LANGUAGES C)
 
@@ -19,13 +17,13 @@ include(CheckLibraryExists)
 include(CheckLinkerFlag)
 include(CheckStructHasMember)
 include(CheckSymbolExists)
+include(CMakeDependentOption)
 include(CMakePackageConfigHelpers)
 include(FindPkgConfig)
 include(GNUInstallDirs)
 
 option(BUILD_SHARED_LIBS "Build shared libraries" ON)
 set(LIBXML2_WITH_AUTOMATA ON)
-option(LIBXML2_WITH_C14N "Add the Canonicalization support" ON)
 option(LIBXML2_WITH_CATALOG "Add the Catalog support" ON)
 option(LIBXML2_WITH_DEBUG "Add the debugging module" ON)
 set(LIBXML2_WITH_EXPR ON)
@@ -42,35 +40,55 @@ option(LIBXML2_WITH_PATTERN "Add the xmlPattern selection interface" ON)
 option(LIBXML2_WITH_PROGRAMS "Build programs" ON)
 option(LIBXML2_WITH_PUSH "Add the PUSH parser interfaces" ON)
 option(LIBXML2_WITH_PYTHON "Build Python bindings" ON)
-option(LIBXML2_WITH_READER "Add the xmlReader parsing interface" ON)
+option(LIBXML2_WITH_READLINE "readline support for xmllint shell" OFF)
 option(LIBXML2_WITH_REGEXPS "Add Regular Expressions support" ON)
 option(LIBXML2_WITH_SAX1 "Add the older SAX1 interface" ON)
-option(LIBXML2_WITH_SCHEMAS "Add Relax-NG and Schemas support" ON)
-option(LIBXML2_WITH_SCHEMATRON "Add Schematron support" ON)
 option(LIBXML2_WITH_TESTS "Build tests" ON)
 option(LIBXML2_WITH_THREADS "Add multithread support" ON)
-option(LIBXML2_WITH_THREAD_ALLOC "Add per-thread memory" OFF)
 option(LIBXML2_WITH_TLS "Enable thread-local storage" OFF)
-option(LIBXML2_WITH_TREE "Add the DOM like tree manipulation APIs" ON)
 set(LIBXML2_WITH_UNICODE ON)
 option(LIBXML2_WITH_VALID "Add the DTD validation support" ON)
-option(LIBXML2_WITH_WRITER "Add the xmlWriter saving interface" ON)
-option(LIBXML2_WITH_XINCLUDE "Add the XInclude support" ON)
 option(LIBXML2_WITH_XPATH "Add the XPATH support" ON)
-option(LIBXML2_WITH_XPTR "Add the XPointer support" ON)
 option(LIBXML2_WITH_ZLIB "Use libz" OFF)
+
+cmake_dependent_option(
+    LIBXML2_WITH_C14N "Add the Canonicalization support" ON
+    "LIBXML2_WITH_OUTPUT;LIBXML2_WITH_XPATH" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_HISTORY "history support for xmllint shell" OFF
+    "LIBXML2_WITH_READLINE" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_READER "Add the xmlReader parsing interface" ON
+    "LIBXML2_WITH_PUSH" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_SCHEMAS "Add Relax-NG and Schemas support" ON
+    "LIBXML2_WITH_PATTERN;LIBXML2_WITH_REGEXPS" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_SCHEMATRON "Add Schematron support" ON
+    "LIBXML2_WITH_PATTERN;LIBXML2_WITH_XPATH" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_THREAD_ALLOC "Add per-thread malloc hooks" OFF
+    "LIBXML2_WITH_THREADS" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_WRITER "Add the xmlWriter saving interface" ON
+    "LIBXML2_WITH_OUTPUT;LIBXML2_WITH_PUSH" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_XINCLUDE "Add the XInclude support" ON
+    "LIBXML2_WITH_XPATH" OFF)
+cmake_dependent_option(
+    LIBXML2_WITH_XPTR "Add the XPointer support" ON
+    "LIBXML2_WITH_XPATH" OFF)
+
 set(LIBXML2_XMLCONF_WORKING_DIR ${CMAKE_CURRENT_BINARY_DIR} CACHE PATH "Working directory for XML Conformance Test Suite")
 
 if(LIBXML2_WITH_PYTHON)
-    check_include_files(unistd.h HAVE_UNISTD_H)
-    check_symbol_exists(F_GETFL fcntl.h HAVE_F_GETFL)
     find_package(Python COMPONENTS Interpreter Development REQUIRED)
     #set(LIBXML2_PYTHON_INSTALL_DIR ${Python_SITEARCH} CACHE PATH "Python bindings install directory")
     set(LIBXML2_PYTHON_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/python"
         CACHE PATH "Python bindings install directory")
 endif()
 
-foreach(VARIABLE IN ITEMS WITH_AUTOMATA WITH_C14N WITH_CATALOG WITH_DEBUG WITH_EXPR WITH_HTML WITH_HTTP WITH_ICONV WITH_ICU WITH_ISO8859X WITH_LEGACY WITH_LZMA WITH_MODULES WITH_OUTPUT WITH_PATTERN WITH_PUSH WITH_READER WITH_REGEXPS WITH_SAX1 WITH_SCHEMAS WITH_SCHEMATRON WITH_THREADS WITH_THREAD_ALLOC WITH_TREE WITH_UNICODE WITH_VALID WITH_WRITER WITH_XINCLUDE WITH_XPATH WITH_XPTR WITH_ZLIB)
+foreach(VARIABLE IN ITEMS WITH_AUTOMATA WITH_C14N WITH_CATALOG WITH_DEBUG WITH_EXPR WITH_HTML WITH_HTTP WITH_ICONV WITH_ICU WITH_ISO8859X WITH_LEGACY WITH_LZMA WITH_MODULES WITH_OUTPUT WITH_PATTERN WITH_PUSH WITH_READER WITH_REGEXPS WITH_SAX1 WITH_SCHEMAS WITH_SCHEMATRON WITH_THREADS WITH_THREAD_ALLOC WITH_UNICODE WITH_VALID WITH_WRITER WITH_XINCLUDE WITH_XPATH WITH_XPTR WITH_ZLIB)
     if(LIBXML2_${VARIABLE})
         set(${VARIABLE} 1)
     else()
@@ -117,69 +135,27 @@ if(LIBXML2_WITH_ZLIB)
     find_package(ZLIB REQUIRED)
 endif()
 
-if (NOT MSVC)
-    check_c_source_compiles("
-        void __attribute__((destructor))
-        f(void) {}
-        int main(void) { return 0; }
-    " HAVE_ATTRIBUTE_DESTRUCTOR)
-    if(HAVE_ATTRIBUTE_DESTRUCTOR)
-        set(ATTRIBUTE_DESTRUCTOR "__attribute__((destructor))")
-    endif()
-    check_include_files(arpa/inet.h HAVE_ARPA_INET_H)
-    check_function_exists(class HAVE_CLASS)
-    check_include_files(dlfcn.h HAVE_DLFCN_H)
-    check_library_exists(dl dlopen "" HAVE_DLOPEN)
-    check_include_files(dl.h HAVE_DL_H)
-    check_include_files(fcntl.h HAVE_FCNTL_H)
-    check_function_exists(fpclass HAVE_FPCLASS)
-    check_function_exists(ftime HAVE_FTIME)
-    check_function_exists(getentropy HAVE_GETENTROPY)
-    check_function_exists(gettimeofday HAVE_GETTIMEOFDAY)
-    check_library_exists(history append_history "" HAVE_LIBHISTORY)
+check_c_source_compiles("
+    void __attribute__((destructor))
+    f(void) {}
+    int main(void) { return 0; }
+" HAVE_FUNC_ATTRIBUTE_DESTRUCTOR)
+check_symbol_exists(getentropy "sys/random.h" HAVE_DECL_GETENTROPY)
+check_symbol_exists(glob "glob.h" HAVE_DECL_GLOB)
+check_symbol_exists(mmap "sys/mman.h" HAVE_DECL_MMAP)
+check_include_files(stdint.h HAVE_STDINT_H)
+
+if(LIBXML2_WITH_READLINE)
     check_library_exists(readline readline "" HAVE_LIBREADLINE)
-    check_function_exists(mmap HAVE_MMAP)
-    check_function_exists(munmap HAVE_MUNMAP)
-    check_include_files(netdb.h HAVE_NETDB_H)
-    check_include_files(netinet/in.h HAVE_NETINET_IN_H)
-    check_include_files(poll.h HAVE_POLL_H)
-    check_library_exists(dld shl_load "" HAVE_SHLLOAD)
-    check_function_exists(stat HAVE_STAT)
-    check_include_files(stdint.h HAVE_STDINT_H)
-    check_include_files(sys/mman.h HAVE_SYS_MMAN_H)
-    check_include_files(sys/random.h HAVE_SYS_RANDOM_H)
-    check_include_files(sys/select.h HAVE_SYS_SELECT_H)
-    check_include_files(sys/socket.h HAVE_SYS_SOCKET_H)
-    check_include_files(sys/stat.h HAVE_SYS_STAT_H)
-    check_include_files(sys/timeb.h HAVE_SYS_TIMEB_H)
-    check_include_files(sys/time.h HAVE_SYS_TIME_H)
-    check_include_files(unistd.h HAVE_UNISTD_H)
-    check_c_source_compiles("
-        #include <stddef.h>
-        #include <sys/socket.h>
-        int main() { (void) getsockopt(1, 1, 1, NULL, (socklen_t*) NULL); return 0; }
-    " XML_SOCKLEN_T_SOCKLEN_T)
-    if(XML_SOCKLEN_T_SOCKLEN_T)
-        set(XML_SOCKLEN_T socklen_t)
-    else()
-        check_c_source_compiles("
-            #include <stddef.h>
-            #include <sys/socket.h>
-            int main() { (void) getsockopt(1, 1, 1, NULL, (size_t*) NULL); return 0; }
-        " XML_SOCKLEN_T_SIZE_T)
-        if(XML_SOCKLEN_T_SIZE_T)
-            set(XML_SOCKLEN_T size_t)
-        else()
-            check_c_source_compiles("
-                #include <stddef.h>
-                #include <sys/socket.h>
-                int main() { (void) getsockopt (1, 1, 1, NULL, (int*) NULL); return 0; }
-            " XML_SOCKLEN_T_INT)
-            set(XML_SOCKLEN_T int)
-        endif()
+    if (LIBXML2_WITH_HISTORY)
+        check_library_exists(history append_history "" HAVE_LIBHISTORY)
     endif()
 endif()
 
+if(LIBXML2_WITH_HTTP)
+    check_include_files(poll.h HAVE_POLL_H)
+endif()
+
 if(LIBXML2_WITH_TLS)
     check_c_source_compiles(
         "_Thread_local int v; int main(){return 0;}"
@@ -277,7 +253,6 @@ set(
     parserInternals.c
     pattern.c
     relaxng.c
-    SAX.c
     SAX2.c
     schematron.c
     threads.c
@@ -319,12 +294,6 @@ add_library(LibXml2::LibXml2 ALIAS LibXml2)
 
 target_compile_definitions(LibXml2 PRIVATE SYSCONFDIR="${CMAKE_INSTALL_FULL_SYSCONFDIR}")
 
-if(LIBXML2_WITH_THREADS)
-    if(NOT WIN32)
-        check_include_files(pthread.h HAVE_PTHREAD_H)
-    endif()
-endif()
-
 target_include_directories(
     LibXml2
     PUBLIC
@@ -334,14 +303,16 @@ target_include_directories(
 )
 
 if(LIBXML2_WITH_MODULES)
+    check_library_exists(dl dlopen "" HAVE_DLOPEN)
     if(HAVE_DLOPEN)
         target_link_libraries(LibXml2 PRIVATE dl)
-        set(MODULE_PLATFORM_LIBS "-ldl")
-    endif()
-
-    if(HAVE_SHLLOAD)
-        target_link_libraries(LibXml2 PRIVATE dld)
-        set(MODULE_PLATFORM_LIBS "-ldld")
+        set(MODULE_LIBS "-ldl")
+    else()
+        check_library_exists(dld shl_load "" HAVE_SHLLOAD)
+        if(HAVE_SHLLOAD)
+            target_link_libraries(LibXml2 PRIVATE dld)
+            set(MODULE_LIBS "-ldld")
+        endif()
     endif()
 endif()
 
@@ -413,9 +384,9 @@ if(CMAKE_C_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID STREQUAL "GNU")
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pedantic -Wall -Wextra -Wshadow \
 -Wpointer-arith -Wcast-align -Wwrite-strings \
 -Wstrict-prototypes -Wmissing-prototypes \
--Wno-long-long -Wno-format-extra-args")
+-Wno-long-long -Wno-format-extra-args -Wno-array-bounds")
 
-    if(BUILD_SHARED_LIBS AND UNIX AND NOT APPLE)
+    if(LIBXML2_WITH_LEGACY AND BUILD_SHARED_LIBS AND UNIX AND NOT APPLE)
         check_linker_flag(C "LINKER:--undefined-version" FLAG_UNDEFINED_VERSION)
         if (FLAG_UNDEFINED_VERSION)
             target_link_options(LibXml2 PRIVATE "LINKER:--undefined-version")
@@ -424,6 +395,8 @@ if(CMAKE_C_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID STREQUAL "GNU")
     endif()
 endif()
 
+set(LIBXML_MINOR_COMPAT 0)
+math(EXPR LIBXML_SOVERSION "${LIBXML_MAJOR_VERSION} + ${LIBXML_MINOR_COMPAT}")
 set_target_properties(
     LibXml2
     PROPERTIES
@@ -432,7 +405,7 @@ set_target_properties(
     POSITION_INDEPENDENT_CODE ON
     PREFIX lib
     VERSION ${PROJECT_VERSION}
-    SOVERSION ${LIBXML_MAJOR_VERSION}
+    SOVERSION ${LIBXML_SOVERSION}
 )
 
 if(MSVC)
@@ -469,13 +442,14 @@ if(MSVC AND BUILD_SHARED_LIBS)
 endif()
 
 if(LIBXML2_WITH_PROGRAMS)
+    add_executable(xmllint xmllint.c shell.c)
+    add_executable(xmlcatalog xmlcatalog.c)
     set(
         PROGRAMS
         xmlcatalog
         xmllint
     )
     foreach(PROGRAM ${PROGRAMS})
-        add_executable(${PROGRAM} ${PROGRAM}.c)
         add_executable(LibXml2::${PROGRAM} ALIAS ${PROGRAM})
         target_compile_definitions(${PROGRAM} PRIVATE SYSCONFDIR="${CMAKE_INSTALL_FULL_SYSCONFDIR}")
         target_link_libraries(${PROGRAM} LibXml2)
@@ -503,7 +477,6 @@ if(LIBXML2_WITH_TESTS)
         testlimits
         testparser
         testrecurse
-        testThreads
     )
     foreach(TEST ${TESTS})
         add_executable(${TEST} ${TEST}.c)
@@ -511,7 +484,7 @@ if(LIBXML2_WITH_TESTS)
         target_link_libraries(${TEST} LibXml2)
     endforeach()
     if(Threads_FOUND)
-        foreach(TEST runtest testThreads)
+        foreach(TEST runtest)
             target_link_libraries(${TEST} Threads::Threads)
         endforeach()
     endif()
@@ -525,9 +498,8 @@ if(LIBXML2_WITH_TESTS)
     endif()
     add_test(NAME testchar COMMAND testchar)
     add_test(NAME testdict COMMAND testdict)
-    add_test(NAME testparser COMMAND testparser)
+    add_test(NAME testparser COMMAND testparser WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
     add_test(NAME testrecurse COMMAND testrecurse WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
-    add_test(NAME testThreads COMMAND testThreads WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
 endif()
 
 if(LIBXML2_WITH_PYTHON)
@@ -584,10 +556,13 @@ if(LIBXML2_WITH_PYTHON)
 endif()
 
 install(FILES doc/xml2-config.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
-install(FILES doc/xmlcatalog.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
-install(FILES doc/xmllint.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
+if(LIBXML2_WITH_PROGRAMS)
+    install(FILES doc/xmlcatalog.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
+    install(FILES doc/xmllint.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
+endif()
 install(DIRECTORY doc/ DESTINATION ${CMAKE_INSTALL_DOCDIR} COMPONENT documentation
     PATTERN "Makefile.*" EXCLUDE
+    PATTERN "meson.build" EXCLUDE
     PATTERN "*.1" EXCLUDE
     PATTERN "*.py" EXCLUDE
     PATTERN "*.res" EXCLUDE
@@ -625,11 +600,7 @@ install(
     COMPONENT development
 )
 
-if(MSVC)
-    configure_file(include/win32config.h config.h COPYONLY)
-else()
-    configure_file(config.h.cmake.in config.h)
-endif()
+configure_file(config.h.cmake.in config.h)
 configure_file(include/libxml/xmlversion.h.in libxml/xmlversion.h)
 install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml/xmlversion.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libxml2/libxml COMPONENT development)
 
@@ -638,7 +609,7 @@ if(LIBXML2_WITH_PYTHON)
     configure_file(python/setup.py.in setup.py @ONLY)
 endif()
 
-set(NON_PC_LIBS "${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${WINSOCK_LIBS} ${CRYPTO_LIBS}")
+set(NON_PC_LIBS "${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${WINSOCK_LIBS} ${CRYPTO_LIBS} ${MODULE_LIBS}")
 list(APPEND XML_PC_LIBS "${NON_PC_LIBS}")
 list(APPEND XML_PRIVATE_LIBS "${NON_PC_LIBS}")
 list(REMOVE_DUPLICATES XML_PC_LIBS)
@@ -657,11 +628,20 @@ if(BUILD_SHARED_LIBS)
     set(XML_PC_LIBS_PRIVATE "
 Libs.private:")
 else()
-    target_compile_definitions(LibXml2 PUBLIC LIBXML_STATIC)
-    set(XML_CFLAGS "-DLIBXML_STATIC")
     set(XML_PRIVATE_LIBS_NO_SHARED "${XML_PRIVATE_LIBS}")
 endif()
 
+if(WIN32)
+    set(XML_STATIC_CFLAGS "-DLIBXML_STATIC")
+    if (BUILD_SHARED_LIBS)
+        set(XML_PC_CFLAGS_PRIVATE "
+Cflags.private:")
+    else()
+        target_compile_definitions(LibXml2 PUBLIC LIBXML_STATIC)
+        set(XML_CFLAGS "${XML_STATIC_CFLAGS}")
+    endif()
+endif()
+
 file(RELATIVE_PATH PACKAGE_RELATIVE_PATH "${CMAKE_INSTALL_FULL_LIBDIR}/pkgconfig" "${CMAKE_INSTALL_PREFIX}")
 string(REGEX REPLACE "/$" "" PACKAGE_RELATIVE_PATH "${PACKAGE_RELATIVE_PATH}")
 
@@ -682,10 +662,6 @@ endif()
 configure_file(xml2-config.in xml2-config @ONLY)
 install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/xml2-config DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT development)
 
-if(UNIX)
-    install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/libxml.m4 DESTINATION ${CMAKE_INSTALL_DATADIR}/aclocal)
-endif()
-
 set(XML_INCLUDEDIR "-I${CMAKE_INSTALL_FULL_INCLUDEDIR}/libxml2")
 set(XML_LIBDIR "-L${CMAKE_INSTALL_FULL_LIBDIR}")
 
diff --git a/HTMLparser.c b/HTMLparser.c
index 4add6347..be6e14a2 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -40,8 +40,6 @@
 
 static int htmlOmittedDefaultValue = 1;
 
-xmlChar * htmlDecodeEntities(htmlParserCtxtPtr ctxt, int len,
-			     xmlChar end, xmlChar  end2, xmlChar end3);
 static void htmlParseComment(htmlParserCtxtPtr ctxt);
 
 /************************************************************************
@@ -291,9 +289,9 @@ htmlNodeInfoPop(htmlParserCtxtPtr ctxt)
 
 #define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)
 
-#define COPY_BUF(l,b,i,v)						\
-    if (l == 1) b[i++] = v;						\
-    else i += xmlCopyChar(l,&b[i],v)
+#define COPY_BUF(b, i, v)						\
+    if (v < 0x80) b[i++] = v;						\
+    else i += xmlCopyCharMultiByte(&b[i],v)
 
 /**
  * htmlFindEncoding:
@@ -2058,90 +2056,87 @@ htmlEntityValueLookup(unsigned int value) {
  */
 int
 UTF8ToHtml(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen) {
-    const unsigned char* processed = in;
-    const unsigned char* outend;
-    const unsigned char* outstart = out;
+           const unsigned char* in, int *inlen) {
     const unsigned char* instart = in;
     const unsigned char* inend;
-    unsigned int c, d;
-    int trailing;
+    unsigned char* outstart = out;
+    unsigned char* outend;
+    int ret = XML_ENC_ERR_SPACE;
+
+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
+        return(XML_ENC_ERR_INTERNAL);
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);
     if (in == NULL) {
         /*
 	 * initialization nothing to do
 	 */
 	*outlen = 0;
 	*inlen = 0;
-	return(0);
+	return(XML_ENC_ERR_SUCCESS);
     }
-    inend = in + (*inlen);
-    outend = out + (*outlen);
+
+    inend = in + *inlen;
+    outend = out + *outlen;
     while (in < inend) {
-	d = *in++;
-	if      (d < 0x80)  { c= d; trailing= 0; }
-	else if (d < 0xC0) {
-	    /* trailing byte in leading position */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(-2);
-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
-	else {
-	    /* no chance for this in Ascii */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(-2);
-	}
+        const htmlEntityDesc *ent;
+        const char *cp;
+        char nbuf[16];
+        unsigned c, d;
+        int seqlen, len, i;
+
+	d = *in;
+
+	if (d < 0x80) {
+            if (out >= outend)
+                goto done;
+            *out++ = d;
+            in += 1;
+            continue;
+        }
 
-	if (inend - in < trailing) {
+        if (d < 0xE0)      { c = d & 0x1F; seqlen = 2; }
+        else if (d < 0xF0) { c = d & 0x0F; seqlen = 3; }
+        else               { c = d & 0x07; seqlen = 4; }
+
+	if (inend - in < seqlen)
 	    break;
-	}
 
-	for ( ; trailing; trailing--) {
-	    if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))
-		break;
+	for (i = 1; i < seqlen; i++) {
+	    d = in[i];
 	    c <<= 6;
 	    c |= d & 0x3F;
 	}
 
-	/* assertion: c is a single UTF-4 value */
-	if (c < 0x80) {
-	    if (out + 1 >= outend)
-		break;
-	    *out++ = c;
-	} else {
-	    int len;
-	    const htmlEntityDesc * ent;
-	    const char *cp;
-	    char nbuf[16];
+        /*
+         * Try to lookup a predefined HTML entity for it
+         */
+        ent = htmlEntityValueLookup(c);
 
-	    /*
-	     * Try to lookup a predefined HTML entity for it
-	     */
+        if (ent == NULL) {
+          snprintf(nbuf, sizeof(nbuf), "#%u", c);
+          cp = nbuf;
+        } else {
+          cp = ent->name;
+        }
 
-	    ent = htmlEntityValueLookup(c);
-	    if (ent == NULL) {
-	      snprintf(nbuf, sizeof(nbuf), "#%u", c);
-	      cp = nbuf;
-	    }
-	    else
-	      cp = ent->name;
-	    len = strlen(cp);
-	    if (out + 2 + len >= outend)
-		break;
-	    *out++ = '&';
-	    memcpy(out, cp, len);
-	    out += len;
-	    *out++ = ';';
-	}
-	processed = in;
+        len = strlen(cp);
+        if (outend - out < len + 2)
+            goto done;
+
+        *out++ = '&';
+        memcpy(out, cp, len);
+        out += len;
+        *out++ = ';';
+
+        in += seqlen;
     }
+
+    ret = out - outstart;
+
+done:
     *outlen = out - outstart;
-    *inlen = processed - instart;
-    return(0);
+    *inlen = in - instart;
+    return(ret);
 }
 
 /**
@@ -2378,7 +2373,7 @@ htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID) {
             return(NULL);
         }
     }
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 }
@@ -2641,7 +2636,7 @@ htmlParseHTMLAttribute(htmlParserCtxtPtr ctxt, const xmlChar stop) {
      * allocate a translation buffer.
      */
     buffer_size = HTML_PARSER_BUFFER_SIZE;
-    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
 	htmlErrMemory(ctxt);
 	return(NULL);
@@ -3039,7 +3034,7 @@ htmlParseScript(htmlParserCtxtPtr ctxt) {
             }
 	}
         if (IS_CHAR(cur)) {
-	    COPY_BUF(l,buf,nbchar,cur);
+	    COPY_BUF(buf,nbchar,cur);
         } else {
             htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                             "Invalid char in CDATA 0x%X\n", cur);
@@ -3104,7 +3099,7 @@ htmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {
 	    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 	                "Invalid char in CDATA 0x%X\n", cur);
 	} else {
-	    COPY_BUF(l,buf,nbchar,cur);
+	    COPY_BUF(buf,nbchar,cur);
 	}
 	NEXTL(l);
 	if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
@@ -3277,7 +3272,7 @@ htmlParsePI(htmlParserCtxtPtr ctxt) {
 		                                     target, NULL);
                 goto done;
 	    }
-	    buf = (xmlChar *) xmlMallocAtomic(size);
+	    buf = xmlMalloc(size);
 	    if (buf == NULL) {
 		htmlErrMemory(ctxt);
 		return;
@@ -3303,7 +3298,7 @@ htmlParsePI(htmlParserCtxtPtr ctxt) {
 		    buf = tmp;
 		}
                 if (IS_CHAR(cur)) {
-		    COPY_BUF(l,buf,len,cur);
+		    COPY_BUF(buf,len,cur);
                 } else {
                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                                     "Invalid char in processing instruction "
@@ -3373,7 +3368,7 @@ htmlParseComment(htmlParserCtxtPtr ctxt) {
     state = ctxt->instate;
     ctxt->instate = XML_PARSER_COMMENT;
     SKIP(4);
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
         htmlErrMemory(ctxt);
 	return;
@@ -3425,7 +3420,7 @@ htmlParseComment(htmlParserCtxtPtr ctxt) {
 	    buf = tmp;
 	}
         if (IS_CHAR(q)) {
-	    COPY_BUF(ql,buf,len,q);
+	    COPY_BUF(buf,len,q);
         } else {
             htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                             "Invalid char in comment 0x%X\n", q);
@@ -4721,18 +4716,50 @@ htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
     if (currentNode != NULL) xmlFree(currentNode);
 }
 
-/**
- * htmlParseContent:
- * @ctxt:  an HTML parser context
- *
- * Parse a content: comment, sub-element, reference or text.
- * This is the entry point when called from parser.c
- */
+xmlNodePtr
+htmlCtxtParseContentInternal(htmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
+    xmlNodePtr root;
+    xmlNodePtr list = NULL;
+    xmlChar *rootName = BAD_CAST "#root";
 
-void
-__htmlParseContent(void *ctxt) {
-    if (ctxt != NULL)
-	htmlParseContentInternal((htmlParserCtxtPtr) ctxt);
+    root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);
+    if (root == NULL) {
+        htmlErrMemory(ctxt);
+        return(NULL);
+    }
+
+    if (xmlPushInput(ctxt, input) < 0) {
+        xmlFreeNode(root);
+        return(NULL);
+    }
+
+    htmlnamePush(ctxt, rootName);
+    nodePush(ctxt, root);
+
+    htmlParseContentInternal(ctxt);
+
+    /* TODO: Use xmlCtxtIsCatastrophicError */
+    if (ctxt->errNo != XML_ERR_NO_MEMORY) {
+        xmlNodePtr cur;
+
+        /*
+         * Unlink newly created node list.
+         */
+        list = root->children;
+        root->children = NULL;
+        root->last = NULL;
+        for (cur = list; cur != NULL; cur = cur->next)
+            cur->parent = NULL;
+    }
+
+    nodePop(ctxt);
+    htmlnamePop(ctxt);
+
+    /* xmlPopInput would free the stream */
+    inputPop(ctxt);
+
+    xmlFreeNode(root);
+    return(list);
 }
 
 /**
@@ -4753,12 +4780,9 @@ htmlParseDocument(htmlParserCtxtPtr ctxt) {
     if ((ctxt == NULL) || (ctxt->input == NULL))
 	return(-1);
 
-    /*
-     * Document locator is unused. Only for backward compatibility.
-     */
     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {
-        xmlSAXLocator copy = xmlDefaultSAXLocator;
-        ctxt->sax->setDocumentLocator(ctxt->userData, &copy);
+        ctxt->sax->setDocumentLocator(ctxt->userData,
+                (xmlSAXLocator *) &xmlDefaultSAXLocator);
     }
 
     xmlDetectEncoding(ctxt);
@@ -4972,9 +4996,6 @@ htmlFreeParserCtxt(htmlParserCtxtPtr ctxt)
  *
  * See xmlCtxtSetErrorHandler for advanced error handling.
  *
- * See xmlNewInputURL, xmlNewInputMemory, xmlNewInputIO and similar
- * functions for advanced input control.
- *
  * See htmlNewSAXParserCtxt for custom SAX parsers.
  *
  * Returns the htmlParserCtxtPtr or NULL in case of allocation error
@@ -5035,13 +5056,17 @@ htmlCreateMemoryParserCtxtInternal(const char *url,
     if (ctxt == NULL)
 	return(NULL);
 
-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding, 0);
+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
         return(NULL);
     }
 
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -5088,13 +5113,18 @@ htmlCreateDocParserCtxt(const xmlChar *str, const char *url,
     if (ctxt == NULL)
 	return(NULL);
 
-    input = xmlNewInputString(ctxt, url, (const char *) str, encoding, 0);
+    input = xmlCtxtNewInputFromString(ctxt, url, (const char *) str,
+                                      encoding, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
 
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -5297,8 +5327,8 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
                     avail = in->end - in->cur;
 		}
                 if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {
-                    xmlSAXLocator copy = xmlDefaultSAXLocator;
-                    ctxt->sax->setDocumentLocator(ctxt->userData, &copy);
+                    ctxt->sax->setDocumentLocator(ctxt->userData,
+                            (xmlSAXLocator *) &xmlDefaultSAXLocator);
                 }
 		if ((ctxt->sax) && (ctxt->sax->startDocument) &&
 	            (!ctxt->disableSAX))
@@ -5817,13 +5847,17 @@ htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void *user_data,
 	return(NULL);
 
     encoding = xmlGetCharEncodingName(enc);
-    input = xmlInputCreatePush(filename, chunk, size);
+    input = xmlNewPushInput(filename, chunk, size);
     if (input == NULL) {
 	htmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
 
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     if (encoding != NULL)
         xmlSwitchEncodingName(ctxt, encoding);
@@ -5924,12 +5958,16 @@ htmlCreateFileParserCtxt(const char *filename, const char *encoding)
 	return(NULL);
     }
 
-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);
+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -5986,8 +6024,6 @@ htmlSAXParseFile(const char *filename, const char *encoding, htmlSAXHandlerPtr s
  *
  * Parse an HTML file and build a tree.
  *
- * See xmlNewInputURL for details.
- *
  * Returns the resulting document tree
  */
 
@@ -6192,6 +6228,12 @@ htmlCtxtReset(htmlParserCtxtPtr ctxt)
     ctxt->extSubURI = NULL;
     DICT_FREE(ctxt->extSubSystem);
     ctxt->extSubSystem = NULL;
+
+    if (ctxt->directory != NULL) {
+        xmlFree(ctxt->directory);
+        ctxt->directory = NULL;
+    }
+
     if (ctxt->myDoc != NULL)
         xmlFreeDoc(ctxt->myDoc);
     ctxt->myDoc = NULL;
@@ -6380,8 +6422,8 @@ htmlReadDoc(const xmlChar *str, const char *url, const char *encoding,
 
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputString(ctxt, url, (const char *) str, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromString(ctxt, url, (const char *) str, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     doc = htmlCtxtParseDocument(ctxt, input);
 
@@ -6415,7 +6457,7 @@ htmlReadFile(const char *filename, const char *encoding, int options)
 
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);
+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);
 
     doc = htmlCtxtParseDocument(ctxt, input);
 
@@ -6455,8 +6497,8 @@ htmlReadMemory(const char *buffer, int size, const char *url,
 
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     doc = htmlCtxtParseDocument(ctxt, input);
 
@@ -6494,7 +6536,7 @@ htmlReadFd(int fd, const char *url, const char *encoding, int options)
 
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputFd(ctxt, url, fd, encoding, 0);
+    input = xmlCtxtNewInputFromFd(ctxt, url, fd, encoding, 0);
 
     doc = htmlCtxtParseDocument(ctxt, input);
 
@@ -6532,7 +6574,8 @@ htmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
 
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputIO(ctxt, url, ioread, ioclose, ioctx, encoding, 0);
+    input = xmlCtxtNewInputFromIO(ctxt, url, ioread, ioclose, ioctx,
+                                  encoding, 0);
 
     doc = htmlCtxtParseDocument(ctxt, input);
 
@@ -6566,7 +6609,8 @@ htmlCtxtReadDoc(htmlParserCtxtPtr ctxt, const xmlChar *str,
     htmlCtxtReset(ctxt);
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputString(ctxt, URL, (const char *) str, encoding, 0);
+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) str,
+                                      encoding, 0);
 
     return(htmlCtxtParseDocument(ctxt, input));
 }
@@ -6581,7 +6625,7 @@ htmlCtxtReadDoc(htmlParserCtxtPtr ctxt, const xmlChar *str,
  * Parse an HTML file from the filesystem, the network or a
  * user-defined resource loader.
  *
- * See xmlNewInputURL and htmlCtxtUseOptions for details.
+ * See htmlCtxtUseOptions for details.
  *
  * Returns the resulting document tree
  */
@@ -6597,7 +6641,7 @@ htmlCtxtReadFile(htmlParserCtxtPtr ctxt, const char *filename,
     htmlCtxtReset(ctxt);
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);
+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);
 
     return(htmlCtxtParseDocument(ctxt, input));
 }
@@ -6630,8 +6674,8 @@ htmlCtxtReadMemory(htmlParserCtxtPtr ctxt, const char *buffer, int size,
     htmlCtxtReset(ctxt);
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputMemory(ctxt, URL, buffer, size, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromMemory(ctxt, URL, buffer, size, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     return(htmlCtxtParseDocument(ctxt, input));
 }
@@ -6665,7 +6709,7 @@ htmlCtxtReadFd(htmlParserCtxtPtr ctxt, int fd,
     htmlCtxtReset(ctxt);
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputFd(ctxt, URL, fd, encoding, 0);
+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);
 
     return(htmlCtxtParseDocument(ctxt, input));
 }
@@ -6682,7 +6726,7 @@ htmlCtxtReadFd(htmlParserCtxtPtr ctxt, int fd,
  *
  * Parse an HTML document from I/O functions and source and build a tree.
  *
- * See xmlNewInputIO and htmlCtxtUseOptions for details.
+ * See htmlCtxtUseOptions for details.
  *
  * Returns the resulting document tree
  */
@@ -6700,7 +6744,8 @@ htmlCtxtReadIO(htmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
     htmlCtxtReset(ctxt);
     htmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);
+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,
+                                  encoding, 0);
 
     return(htmlCtxtParseDocument(ctxt, input));
 }
diff --git a/HTMLtree.c b/HTMLtree.c
index 6e8baf48..ab5c816a 100644
--- a/HTMLtree.c
+++ b/HTMLtree.c
@@ -366,10 +366,10 @@ htmlSaveErr(int code, xmlNodePtr node, const char *extra)
 	    msg = "unexpected error number\n";
     }
 
-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, node,
-                          XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,
-                          extra, NULL, NULL, 0, 0,
-                          msg, extra);
+    res = xmlRaiseError(NULL, NULL, NULL, NULL, node,
+                        XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,
+                        extra, NULL, NULL, 0, 0,
+                        msg, extra);
     if (res < 0)
         xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_OUTPUT, NULL);
 }
@@ -385,22 +385,17 @@ htmlFindOutputEncoder(const char *encoding) {
     xmlCharEncodingHandler *handler = NULL;
 
     if (encoding != NULL) {
-	xmlCharEncoding enc;
+        int res;
 
-	enc = xmlParseCharEncoding(encoding);
-	if (enc != XML_CHAR_ENCODING_UTF8) {
-	    xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
-	    if (handler == NULL)
-		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
-	}
+        res = xmlOpenCharEncodingHandler(encoding, /* output */ 1,
+                                         &handler);
+        if (res != XML_ERR_OK)
+            htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
     } else {
         /*
-         * Fallback to HTML or ASCII when the encoding is unspecified
+         * Fallback to HTML when the encoding is unspecified
          */
-        if (handler == NULL)
-            xmlOpenCharEncodingHandler("HTML", /* output */ 1, &handler);
-        if (handler == NULL)
-            xmlOpenCharEncodingHandler("ascii", /* output */ 1, &handler);
+        xmlOpenCharEncodingHandler("HTML", /* output */ 1, &handler);
     }
 
     return(handler);
@@ -465,7 +460,8 @@ htmlBufNodeDumpFormat(xmlBufPtr buf, xmlDocPtr doc, xmlNodePtr cur,
 int
 htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur) {
     xmlBufPtr buffer;
-    size_t ret;
+    size_t ret1;
+    int ret2;
 
     if ((buf == NULL) || (cur == NULL))
         return(-1);
@@ -475,14 +471,13 @@ htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur) {
     if (buffer == NULL)
         return(-1);
 
-    xmlBufSetAllocationScheme(buffer, XML_BUFFER_ALLOC_DOUBLEIT);
-    ret = htmlBufNodeDumpFormat(buffer, doc, cur, 1);
+    ret1 = htmlBufNodeDumpFormat(buffer, doc, cur, 1);
 
-    xmlBufBackToBuffer(buffer);
+    ret2 = xmlBufBackToBuffer(buffer, buf);
 
-    if (ret > INT_MAX)
+    if ((ret1 == (size_t) -1) || (ret2 < 0))
         return(-1);
-    return((int) ret);
+    return(ret1 > INT_MAX ? INT_MAX : ret1);
 }
 
 /**
@@ -513,10 +508,8 @@ htmlNodeDumpFileFormat(FILE *out, xmlDocPtr doc,
      */
     handler = htmlFindOutputEncoder(encoding);
     buf = xmlOutputBufferCreateFile(out, handler);
-    if (buf == NULL) {
-        xmlCharEncCloseFunc(handler);
+    if (buf == NULL)
         return(0);
-    }
 
     htmlNodeDumpFormatOutput(buf, doc, cur, NULL, format);
 
@@ -565,11 +558,9 @@ htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar**mem, int *size, int format) {
 
     encoding = (const char *) htmlGetMetaEncoding(cur);
     handler = htmlFindOutputEncoder(encoding);
-    buf = xmlAllocOutputBufferInternal(handler);
-    if (buf == NULL) {
-        xmlCharEncCloseFunc(handler);
+    buf = xmlAllocOutputBuffer(handler);
+    if (buf == NULL)
 	return;
-    }
 
     htmlDocContentDumpFormatOutput(buf, cur, NULL, format);
 
@@ -1034,10 +1025,8 @@ htmlDocDump(FILE *f, xmlDocPtr cur) {
     encoding = (const char *) htmlGetMetaEncoding(cur);
     handler = htmlFindOutputEncoder(encoding);
     buf = xmlOutputBufferCreateFile(f, handler);
-    if (buf == NULL) {
-        xmlCharEncCloseFunc(handler);
+    if (buf == NULL)
         return(-1);
-    }
     htmlDocContentDumpOutput(buf, cur, NULL);
 
     ret = xmlOutputBufferClose(buf);
@@ -1068,10 +1057,8 @@ htmlSaveFile(const char *filename, xmlDocPtr cur) {
     encoding = (const char *) htmlGetMetaEncoding(cur);
     handler = htmlFindOutputEncoder(encoding);
     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);
-    if (buf == NULL) {
-        xmlCharEncCloseFunc(handler);
+    if (buf == NULL)
         return(0);
-    }
 
     htmlDocContentDumpOutput(buf, cur, NULL);
 
@@ -1112,10 +1099,8 @@ htmlSaveFileFormat(const char *filename, xmlDocPtr cur,
      * save the content to a temp buffer.
      */
     buf = xmlOutputBufferCreateFilename(filename, handler, 0);
-    if (buf == NULL) {
-        xmlCharEncCloseFunc(handler);
+    if (buf == NULL)
         return(0);
-    }
 
     htmlDocContentDumpFormatOutput(buf, cur, encoding, format);
 
diff --git a/MAINTAINERS.md b/MAINTAINERS.md
index 76ba488c..b2806755 100644
--- a/MAINTAINERS.md
+++ b/MAINTAINERS.md
@@ -50,7 +50,7 @@ You can get started by running
 
 ### Bump the version number
 
-Edit the version number in `configure.ac` if you haven't done so already.
+Update the version number in `VERSION` if you haven't done so already.
 
 ### Build the tarball
 
diff --git a/METADATA b/METADATA
index eaa3d718..19c8cf60 100644
--- a/METADATA
+++ b/METADATA
@@ -4,7 +4,7 @@
 
 # This project was upgraded with external_updater.
 # Usage: tools/external_updater/updater.sh update external/libxml2
-# For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
 
 name: "libxml2"
 description: "Libxml2 is the XML C parser and toolkit developed for the Gnome project (but usable outside of the Gnome platform), it is free software available under the MIT License."
@@ -16,13 +16,13 @@ third_party {
   }
   last_upgrade_date {
     year: 2024
-    month: 6
-    day: 13
+    month: 9
+    day: 11
   }
   homepage: "http://www.xmlsoft.org/"
   identifier {
     type: "Git"
     value: "https://github.com/GNOME/libxml2/"
-    version: "3b4a84e4b71010012ac94eb32a04965af8ec93ef"
+    version: "5e7874015ef5ed8b2705eb2f7b0960f56f7760ea"
   }
 }
diff --git a/Makefile.am b/Makefile.am
index 8f49bf3d..5caba33e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -19,7 +19,6 @@ check_PROGRAMS = \
 	runtest \
 	runxmlconf \
 	testModule \
-	testThreads \
 	testapi \
 	testchar \
 	testdict \
@@ -36,8 +35,7 @@ libxml2_la_CFLAGS = $(AM_CFLAGS) $(XML_PRIVATE_CFLAGS)
 libxml2_la_LIBADD = $(XML_PRIVATE_LIBS)
 
 libxml2_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined \
-		     -version-info $(LIBXML_VERSION_INFO) \
-		     $(MODULE_PLATFORM_LIBS)
+		     -version-info $(LIBXML_VERSION_INFO)
 if USE_VERSION_SCRIPT
 libxml2_la_LDFLAGS += $(VERSION_SCRIPT_FLAGS)$(srcdir)/libxml2.syms
 endif
@@ -63,9 +61,6 @@ libxml2_la_SOURCES += nanohttp.c
 endif
 if WITH_LEGACY_SOURCES
 libxml2_la_SOURCES += legacy.c
-if WITH_SAX1_SOURCES
-libxml2_la_SOURCES += SAX.c
-endif
 endif
 if WITH_LZMA_SOURCES
 libxml2_la_SOURCES += xzlib.c
@@ -110,13 +105,9 @@ endif
 DEPS = libxml2.la
 LDADDS = libxml2.la
 
-
-m4datadir = $(datadir)/aclocal
-dist_m4data_DATA = libxml.m4
-
 runtest_SOURCES=runtest.c
 runtest_DEPENDENCIES = $(DEPS)
-runtest_LDADD= $(BASE_THREAD_LIBS) $(THREAD_LIBS) $(LDADDS)
+runtest_LDADD= $(THREAD_LIBS) $(LDADDS)
 
 testrecurse_SOURCES=testrecurse.c
 testrecurse_DEPENDENCIES = $(DEPS)
@@ -142,7 +133,7 @@ runsuite_SOURCES=runsuite.c
 runsuite_DEPENDENCIES = $(DEPS)
 runsuite_LDADD= $(LDADDS)
 
-xmllint_SOURCES=xmllint.c
+xmllint_SOURCES = xmllint.c shell.c
 xmllint_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)
 xmllint_DEPENDENCIES = $(DEPS)
 xmllint_LDADD=  $(RDL_LIBS) $(LDADDS)
@@ -152,10 +143,6 @@ xmlcatalog_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)
 xmlcatalog_DEPENDENCIES = $(DEPS)
 xmlcatalog_LDADD = $(RDL_LIBS) $(LDADDS)
 
-testThreads_SOURCES = testThreads.c
-testThreads_DEPENDENCIES = $(DEPS)
-testThreads_LDADD= $(BASE_THREAD_LIBS) $(THREAD_LIBS) $(LDADDS)
-
 testModule_SOURCES=testModule.c
 testModule_DEPENDENCIES = $(DEPS)
 testModule_LDADD= $(LDADDS)
@@ -168,7 +155,7 @@ testdso_la_LDFLAGS = $(AM_LDFLAGS) \
 # that one forces the rebuild when "make rebuild" is run on doc/
 rebuild_testapi:
 	-@(if [ "$(PYTHON)" != "" ] ; then \
-	    $(PYTHON) $(srcdir)/gentest.py $(srcdir) ; fi )
+	    $(PYTHON) $(srcdir)/tools/gentest.py $(srcdir) ; fi )
 
 testapi_SOURCES=testapi.c
 testapi_DEPENDENCIES = $(DEPS)
@@ -188,9 +175,14 @@ check-local:
 	$(CHECKER) ./testdict$(EXEEXT)
 	$(CHECKER) ./testparser$(EXEEXT)
 	$(CHECKER) ./testModule$(EXEEXT)
-	$(CHECKER) ./testThreads$(EXEEXT)
 	$(CHECKER) ./runxmlconf$(EXEEXT)
 	$(CHECKER) ./runsuite$(EXEEXT)
+if WITH_DEBUG_SOURCES
+	test/scripts/test.sh ./xmllint$(EXEEXT)
+endif
+if WITH_CATALOG_SOURCES
+	ASAN_OPTIONS=detect_leaks=0 test/catalogs/test.sh ./xmlcatalog$(EXEEXT)
+endif
 
 # Compatibility name of the check target
 runtests: check
@@ -204,163 +196,6 @@ asan:
 	@echo '## rebuilding for ASAN'
 	./configure CFLAGS="-fsanitize=address,undefined -Wformat -Werror=format-security -Werror=array-bounds -g" CXXFLAGS="-fsanitize=address,undefined -Wformat -Werror=format-security -Werror=array-bounds -g" LDFLAGS="-fsanitize=address,undefined" CC="clang" CXX="clang++" --disable-shared ; OptimOff  ; $(MAKE) clean ; $(MAKE)
 
-# Old test suite. This should be ported to C.
-
-OLD_TESTS = Timingtests
-if WITH_CATALOG_SOURCES
-OLD_TESTS += Catatests
-endif
-if WITH_DEBUG_SOURCES
-OLD_TESTS += Scripttests
-endif
-if WITH_SCHEMAS_SOURCES
-if WITH_PYTHON
-OLD_TESTS += RelaxNGPythonTests SchemasPythonTests
-endif
-endif
-if WITH_SCHEMATRON_SOURCES
-OLD_TESTS += Schematrontests
-endif
-if WITH_VALID_SOURCES
-OLD_TESTS += VTimingtests
-endif
-
-tests: $(OLD_TESTS)
-
-Scripttests : xmllint$(EXEEXT)
-	@echo "## Scripts regression tests"
-	@echo "## Some of the base computations may be different if srcdir != ."
-	-@(for i in $(srcdir)/test/scripts/*.script ; do \
-	  name=`basename $$i .script`; \
-	  xml=$(srcdir)/test/scripts/`basename $$i .script`.xml; \
-	  if [ -f $$xml ] ; then \
-	  if [ ! -f $(srcdir)/result/scripts/$$name ] ; then \
-	      echo New test file $$name ; \
-	      $(CHECKER) $(top_builddir)/xmllint --shell $$xml < $$i > $(srcdir)/result/scripts/$$name 2> $(srcdir)/result/scripts/$$name.err ; \
-	  else \
-	      log=`$(CHECKER) $(top_builddir)/xmllint --shell $$xml < $$i > result.$$name 2> result.$$name.err ; \
-	      diff $(srcdir)/result/scripts/$$name result.$$name ; \
-	      diff $(srcdir)/result/scripts/$$name.err result.$$name.err` ; \
-	      if [ -n "$$log" ] ; then echo $$name result ; echo "$$log" ; fi ; \
-	      rm result.$$name result.$$name.err ; \
-	  fi ; fi ; done)
-
-Catatests : xmlcatalog$(EXEEXT)
-	@echo "## Catalog regression tests"
-	-@(for i in $(srcdir)/test/catalogs/*.script ; do \
-	  name=`basename $$i .script`; \
-	  xml=$(srcdir)/test/catalogs/`basename $$i .script`.xml; \
-	  if [ -f $$xml ] ; then \
-	  if [ ! -f $(srcdir)/result/catalogs/$$name ] ; then \
-	      echo New test file $$name ; \
-	      $(CHECKER) $(top_builddir)/xmlcatalog --shell $$xml < $$i 2>&1 > $(srcdir)/result/catalogs/$$name ; \
-	  else \
-	      log=`$(CHECKER) $(top_builddir)/xmlcatalog --shell $$xml < $$i 2>&1 > result.$$name ; \
-	      diff $(srcdir)/result/catalogs/$$name result.$$name` ; \
-	      if [ -n "$$log" ] ; then echo $$name result ; echo "$$log" ; fi ; \
-	      rm result.$$name ; \
-	  fi ; fi ; done)
-	-@(for i in $(srcdir)/test/catalogs/*.script ; do \
-	  name=`basename $$i .script`; \
-	  sgml=$(srcdir)/test/catalogs/`basename $$i .script`.sgml; \
-	  if [ -f $$sgml ] ; then \
-	  if [ ! -f $(srcdir)/result/catalogs/$$name ] ; then \
-	      echo New test file $$name ; \
-	      $(CHECKER) $(top_builddir)/xmlcatalog --shell $$sgml < $$i > $(srcdir)/result/catalogs/$$name ; \
-	  else \
-	      log=`$(CHECKER) $(top_builddir)/xmlcatalog --shell $$sgml < $$i > result.$$name ; \
-	      diff $(srcdir)/result/catalogs/$$name result.$$name` ; \
-	      if [ -n "$$log" ] ; then echo $$name result ; echo "$$log" ; fi ; \
-	      rm result.$$name ; \
-	  fi ; fi ; done)
-	@echo "## Add and del operations on XML Catalogs"
-	-@($(CHECKER) $(top_builddir)/xmlcatalog --create --noout $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --add public Pubid sysid $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --add public Pubid2 sysid2 $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --add public Pubid3 sysid3 $(srcdir)/result/catalogs/mycatalog; \
-	diff result/catalogs/mycatalog.full $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --del sysid $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --del sysid3 $(srcdir)/result/catalogs/mycatalog; \
-	$(CHECKER) $(top_builddir)/xmlcatalog --noout --del sysid2 $(srcdir)/result/catalogs/mycatalog; \
-	diff result/catalogs/mycatalog.empty $(srcdir)/result/catalogs/mycatalog; \
-	rm -f $(srcdir)/result/catalogs/mycatalog)
-
-dba100000.xml: dbgenattr.pl
-	@echo "## generating dba100000.xml"
-	@($(PERL) $(top_srcdir)/dbgenattr.pl 100000 > dba100000.xml)
-
-Timingtests: xmllint$(EXEEXT) dba100000.xml
-	@echo "## Timing tests to try to detect performance"
-	@echo "## as well a memory usage breakage when streaming"
-	@echo "## 1/ using the file interface"
-	@echo "## 2/ using the memory interface"
-	@echo "## 3/ repeated DOM parsing"
-	@echo "## 4/ repeated DOM validation"
-	-@($(top_builddir)/xmllint --stream --timing dba100000.xml; \
-	   if [ "$$MEM" != "" ] ; then echo Using $$MEM bytes ; fi ; \
-	   exit 0)
-	-@($(top_builddir)/xmllint --stream --timing --memory dba100000.xml; \
-	   if [ "$$MEM" != "" ] ; then echo Using $$MEM bytes ; fi ; \
-	   exit 0)
-	-@($(top_builddir)/xmllint --noout --timing --repeat $(srcdir)/test/valid/REC-xml-19980210.xml; \
-	   if [ "$$MEM" != "" ] ; then echo Using $$MEM bytes ; fi ; \
-	   exit 0)
-
-VTimingtests: xmllint$(EXEEXT)
-	-@($(top_builddir)/xmllint --noout --timing --valid --repeat $(srcdir)/test/valid/REC-xml-19980210.xml; \
-	   if [ "$$MEM" != "" ] ; then echo Using $$MEM bytes ; fi ; \
-	   exit 0)
-
-Schematrontests: xmllint$(EXEEXT)
-	@echo "## Schematron regression tests"
-	-@(for i in $(srcdir)/test/schematron/*.sct ; do \
-	  name=`basename $$i | sed 's+\.sct++'`; \
-	  for j in $(srcdir)/test/schematron/"$$name"_*.xml ; do \
-	      if [ -f $$j ] ; then \
-	      xno=`basename $$j | sed 's+.*_\(.*\).xml+\1+'`; \
-	      if [ ! -f $(srcdir)/result/schematron/"$$name"_"$$xno" ]; \
-	      then \
-		  echo New test file "$$name"_"$$xno" ; \
-		  $(CHECKER) $(top_builddir)/xmllint$(EXEEXT) --schematron $$i $$j \
-		    > $(srcdir)/result/schematron/"$$name"_"$$xno" \
-		    2> $(srcdir)/result/schematron/"$$name"_"$$xno".err; \
-	      else \
-	          log=`$(CHECKER) $(top_builddir)/xmllint$(EXEEXT) --schematron $$i $$j \
-		    > res.$$name 2> err.$$name;\
-	          diff $(srcdir)/result/schematron/"$$name"_"$$xno" \
-		       res.$$name;\
-	          diff $(srcdir)/result/schematron/"$$name"_"$$xno".err \
-		       err.$$name | grep -v "error detected at";\
-		  grep Unimplemented err.$$name`; \
-		  if [ -n "$$log" ] ; then echo "$$name"_"$$xno" result ; echo "$$log" ; fi ; \
-	          rm res.$$name err.$$name ; \
-	       fi ; fi ; \
-	  done; done)
-
-RelaxNGPythonTests:
-	@(if [ -x $(PYTHON) ] ; then \
-	    PYTHONPATH=$(top_builddir)/python:$(top_builddir)/python/.libs:$$PYTHONPATH ; \
-	    export PYTHONPATH; \
-	    LD_LIBRARY_PATH="$(top_builddir)/.libs:$$LD_LIBRARY_PATH" ; \
-	    export LD_LIBRARY_PATH; \
-	    echo "## Relax-NG Python based test suite 1" ; \
-	    $(CHECKER) $(PYTHON) $(srcdir)/check-relaxng-test-suite.py ; \
-	    echo "## Relax-NG Python based test suite 2" ; \
-	    $(CHECKER) $(PYTHON) $(srcdir)/check-relaxng-test-suite2.py ; \
-	  fi)
-
-SchemasPythonTests:
-	@(if [ -x $(PYTHON) ] ; then \
-	    PYTHONPATH=$(top_builddir)/python:$(top_builddir)/python/.libs:$$PYTHONPATH; \
-	    export PYTHONPATH; \
-	    LD_LIBRARY_PATH="$(top_builddir)/.libs:$$LD_LIBRARY_PATH" ; \
-	    export LD_LIBRARY_PATH; \
-	    echo "## XML Schemas datatypes Python based test suite" ; \
-	    echo "## It is normal to see 11 errors reported" ; \
-	    $(CHECKER) $(PYTHON) $(srcdir)/check-xsddata-test-suite.py ; \
-	  fi)
-	@(if [ -x $(PYTHON) -a -d xstc ] ; then cd xstc ; $(MAKE) CHECKER="$(CHECKER)" pytests ; fi)
-
 cleanup:
 	-@(find . -name .\#\* -exec rm {} \;)
 	-@(find . -name \*.gcda -o -name \*.gcno -exec rm -f {} \;)
@@ -372,13 +207,10 @@ dist-hook: cleanup
 CLEANFILES = runsuite.log runxmlconf.log test.out *.gcda *.gcno *.res
 DISTCLEANFILES = COPYING missing.lst
 
-EXTRA_DIST = Copyright check-xml-test-suite.py gentest.py \
-	     check-relaxng-test-suite.py check-relaxng-test-suite2.py \
-	     check-xsddata-test-suite.py check-xinclude-test-suite.py \
-	     libxml2-config.cmake.in autogen.sh \
-	     libxml.h \
-	     genUnicode.py \
-	     dbgen.pl dbgenattr.pl \
+EXTRA_DIST = Copyright libxml2-config.cmake.in autogen.sh \
+	     libxml.h iso8859x.inc \
+	     tools/gentest.py \
+	     tools/genChRanges.py tools/genEscape.py tools/genUnicode.py \
 	     libxml2.syms timsort.h \
 	     README.zOS README.md \
 	     CMakeLists.txt config.h.cmake.in libxml2-config.cmake.cmake.in \
diff --git a/NEWS b/NEWS
index a76ffbb7..ff9658b1 100644
--- a/NEWS
+++ b/NEWS
@@ -1,5 +1,37 @@
 NEWS file for libxml2
 
+v2.14.0: not released yet
+
+Input callbacks can now be set on a parser context and an improved API
+to create parser input is available.
+
+A new API function xmlCtxtParseContent to parse XML content using an
+existing parser context was added.
+
+The xmlSave API now has additional options to replace global settings.
+
+Parser options XML_PARSE_NO_UNZIP, XML_PARSE_NO_SYS_CATALOG and
+XML_PARSE_NO_CATALOG_PI were added.
+
+The serialization API will now take a user-provided or default encodings
+into account when serializing attribute values, matching the
+serialization of text and avoiding unnecessary escaping.
+
+Access to many public struct members is now deprecated. Several accessor
+functions were added.
+
+The FTP module and related functions were removed.
+
+Support for the range and point extensions of the xpointer() scheme
+were removed. The rest of the XPointer implementation isn't affected.
+The xpointer() scheme now behaves like the xpath1() scheme.
+
+Several legacy functions were removed from the header files.
+
+The shell was moved from libxml2 to xmllint. Several related functions
+are no longer available.
+
+
 v2.13.0: Jun 12 2024
 
 ### Major changes
@@ -26,12 +58,16 @@ XML_PARSE_NOENT.
 Support for HTTP POST was removed.
 
 Support for zlib, liblzma and HTTP is now disabled by default and has
-to be enabled by passing --with-zlib, --with-lzma or --with-html to
+to be enabled by passing --with-zlib, --with-lzma or --with-http to
 configure. In legacy mode (--with-legacy) these options are enabled
 by default as before.
 
-Support for FTP and xpointer() XPath extensions will be removed in
-the next release.
+Support for FTP will be removed in the next release.
+
+Support for the range and point extensions of the xpointer() scheme
+will be removed in the next release. The rest of the XPointer
+implementation won't be affected. The xpointer() scheme will behave
+like the xpath1() scheme.
 
 Several more legacy symbols were deprecated. Users of the old "SAX1"
 API functions are encouraged to upgrade to the new "SAX2" API,
diff --git a/README.md b/README.md
index 58c9433f..8eec01f0 100644
--- a/README.md
+++ b/README.md
@@ -45,9 +45,9 @@ The following options disable or enable code modules and relevant symbols:
 
     --with-c14n             Canonical XML 1.0 support (on)
     --with-catalog          XML Catalogs support (on)
-    --with-debug            debugging module and shell (on)
-    --with-history          history support for shell (off)
-    --with-readline[=DIR]   use readline in DIR (for shell history)
+    --with-debug            debugging module (on)
+    --with-history          history support for xmllint shell (off)
+    --with-readline[=DIR]   use readline in DIR for shell (off)
     --with-html             HTML parser (on)
     --with-http             HTTP support (off)
     --with-iconv[=DIR]      iconv support (on)
@@ -123,20 +123,26 @@ directly in various IDEs such as CLion, QtCreator, or Visual Studio.
 
 Libxml can also be built with meson. Without option, simply call
 
-meson setup builddir
-ninja -C builddir
+    meson setup builddir
+    ninja -C builddir
 
 To add options, see the meson_options.txt file. For example:
 
-meson setup -Dprefix=$prefix -Dftp=true -Dhistory=true -Dicu=true -Dhttp=true builddir
+    meson setup \
+        -Dprefix=$prefix \
+        -Dhistory=enabled \
+        -Dhttp=enabled \
+        -Dschematron=disabled \
+        -Dzlib=enabled \
+        builddir
 
 To install libxml:
 
-ninja -C builddir install
+    ninja -C builddir install
 
 To launch tests:
 
-meson test -C builddir
+    meson test -C builddir
 
 ## Dependencies
 
diff --git a/SAX.c b/SAX.c
deleted file mode 100644
index 7f2f2974..00000000
--- a/SAX.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * SAX.c : Old SAX v1 handlers to build a tree.
- *         Deprecated except for compatibility
- *
- * See Copyright for the status of this software.
- *
- * Daniel Veillard <daniel@veillard.com>
- */
-
-
-#define IN_LIBXML
-#include "libxml.h"
-#include <stdlib.h>
-#include <string.h>
-#include <libxml/xmlmemory.h>
-#include <libxml/tree.h>
-#include <libxml/parser.h>
-#include <libxml/parserInternals.h>
-#include <libxml/valid.h>
-#include <libxml/entities.h>
-#include <libxml/xmlerror.h>
-#include <libxml/debugXML.h>
-#include <libxml/xmlIO.h>
-#include <libxml/SAX.h>
-#include <libxml/uri.h>
-#include <libxml/valid.h>
-#include <libxml/HTMLtree.h>
-#include <libxml/SAX2.h>
-
-#ifdef LIBXML_LEGACY_ENABLED
-#ifdef LIBXML_SAX1_ENABLED
-/**
- * initxmlDefaultSAXHandler:
- * @hdlr:  the SAX handler
- * @warning:  flag if non-zero sets the handler warning procedure
- *
- * Initialize the default XML SAX version 1 handler
- * DEPRECATED: use xmlSAX2InitDefaultSAXHandler() for the new SAX2 blocks
- */
-void
-initxmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr, int warning)
-{
-
-    if(hdlr->initialized == 1)
-	return;
-
-    hdlr->internalSubset = xmlSAX2InternalSubset;
-    hdlr->externalSubset = xmlSAX2ExternalSubset;
-    hdlr->isStandalone = xmlSAX2IsStandalone;
-    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
-    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
-    hdlr->resolveEntity = xmlSAX2ResolveEntity;
-    hdlr->getEntity = xmlSAX2GetEntity;
-    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
-    hdlr->entityDecl = xmlSAX2EntityDecl;
-    hdlr->attributeDecl = xmlSAX2AttributeDecl;
-    hdlr->elementDecl = xmlSAX2ElementDecl;
-    hdlr->notationDecl = xmlSAX2NotationDecl;
-    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
-    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
-    hdlr->startDocument = xmlSAX2StartDocument;
-    hdlr->endDocument = xmlSAX2EndDocument;
-    hdlr->startElement = xmlSAX2StartElement;
-    hdlr->endElement = xmlSAX2EndElement;
-    hdlr->reference = xmlSAX2Reference;
-    hdlr->characters = xmlSAX2Characters;
-    hdlr->cdataBlock = xmlSAX2CDataBlock;
-    hdlr->ignorableWhitespace = xmlSAX2Characters;
-    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
-    if (warning == 0)
-	hdlr->warning = NULL;
-    else
-	hdlr->warning = xmlParserWarning;
-    hdlr->error = xmlParserError;
-    hdlr->fatalError = xmlParserError;
-
-    hdlr->initialized = 1;
-}
-
-#ifdef LIBXML_HTML_ENABLED
-
-/**
- * inithtmlDefaultSAXHandler:
- * @hdlr:  the SAX handler
- *
- * Initialize the default HTML SAX version 1 handler
- * DEPRECATED: use xmlSAX2InitHtmlDefaultSAXHandler() for the new SAX2 blocks
- */
-void
-inithtmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)
-{
-    if(hdlr->initialized == 1)
-	return;
-
-    hdlr->internalSubset = xmlSAX2InternalSubset;
-    hdlr->externalSubset = NULL;
-    hdlr->isStandalone = NULL;
-    hdlr->hasInternalSubset = NULL;
-    hdlr->hasExternalSubset = NULL;
-    hdlr->resolveEntity = NULL;
-    hdlr->getEntity = xmlSAX2GetEntity;
-    hdlr->getParameterEntity = NULL;
-    hdlr->entityDecl = NULL;
-    hdlr->attributeDecl = NULL;
-    hdlr->elementDecl = NULL;
-    hdlr->notationDecl = NULL;
-    hdlr->unparsedEntityDecl = NULL;
-    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
-    hdlr->startDocument = xmlSAX2StartDocument;
-    hdlr->endDocument = xmlSAX2EndDocument;
-    hdlr->startElement = xmlSAX2StartElement;
-    hdlr->endElement = xmlSAX2EndElement;
-    hdlr->reference = NULL;
-    hdlr->characters = xmlSAX2Characters;
-    hdlr->cdataBlock = xmlSAX2CDataBlock;
-    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
-    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
-    hdlr->comment = xmlSAX2Comment;
-    hdlr->warning = xmlParserWarning;
-    hdlr->error = xmlParserError;
-    hdlr->fatalError = xmlParserError;
-
-    hdlr->initialized = 1;
-}
-
-#endif /* LIBXML_HTML_ENABLED */
-
-#endif /* LIBXML_SAX1_ENABLED */
-
-#endif /* LIBXML_LEGACY_ENABLED */
diff --git a/SAX2.c b/SAX2.c
index 3f5624d1..1a9310d5 100644
--- a/SAX2.c
+++ b/SAX2.c
@@ -31,8 +31,6 @@
 #include "private/parser.h"
 #include "private/tree.h"
 
-#define XML_MAX_URI_LENGTH 2000
-
 /*
  * xmlSAX2ErrMemory:
  * @ctxt:  an XML validation parser context
@@ -322,18 +320,13 @@ xmlSAX2ExternalSubset(void *ctx, const xmlChar *name,
 	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
 	if (ctxt->inputTab == NULL) {
 	    xmlSAX2ErrMemory(ctxt);
-            xmlFreeInputStream(input);
-	    ctxt->input = oldinput;
-	    ctxt->inputNr = oldinputNr;
-	    ctxt->inputMax = oldinputMax;
-	    ctxt->inputTab = oldinputTab;
-	    ctxt->encoding = oldencoding;
-	    return;
+            goto error;
 	}
 	ctxt->inputNr = 0;
 	ctxt->inputMax = 5;
 	ctxt->input = NULL;
-	xmlPushInput(ctxt, input);
+	if (xmlPushInput(ctxt, input) < 0)
+            goto error;
 
 	if (input->filename == NULL)
 	    input->filename = (char *) xmlCanonicPath(SystemID);
@@ -366,7 +359,8 @@ xmlSAX2ExternalSubset(void *ctx, const xmlChar *name,
         else
             ctxt->sizeentities += consumed;
 
-	xmlFreeInputStream(ctxt->input);
+error:
+	xmlFreeInputStream(input);
         xmlFree(ctxt->inputTab);
 
 	/*
@@ -410,6 +404,13 @@ xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId,
     if (ctxt->input != NULL)
 	base = BAD_CAST ctxt->input->filename;
 
+    /*
+     * We don't really need the 'directory' struct member, but some
+     * users set it manually to a base URI for memory streams.
+     */
+    if (base == NULL)
+        base = BAD_CAST ctxt->directory;
+
     if ((xmlStrlen(systemId) > XML_MAX_URI_LENGTH) ||
         (xmlStrlen(base) > XML_MAX_URI_LENGTH)) {
         xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT, "URI too long");
@@ -572,6 +573,13 @@ xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
             }
         }
 
+        /*
+         * We don't really need the 'directory' struct member, but some
+         * users set it manually to a base URI for memory streams.
+         */
+        if (base == NULL)
+            base = ctxt->directory;
+
         res = xmlBuildURISafe(systemId, (const xmlChar *) base, &URI);
 
         if (URI == NULL) {
@@ -609,7 +617,8 @@ xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
 {
     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
     xmlAttributePtr attr;
-    xmlChar *name = NULL, *prefix = NULL;
+    const xmlChar *name = NULL;
+    xmlChar *prefix = NULL;
 
     /* Avoid unused variable warning if features are disabled. */
     (void) attr;
@@ -627,8 +636,7 @@ xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
 	      "xml:id : attribute type should be ID\n", NULL, NULL);
 	ctxt->valid = tmp;
     }
-    /* TODO: optimize name/prefix allocation */
-    name = xmlSplitQName(ctxt, fullname, &prefix);
+    name = xmlSplitQName4(fullname, &prefix);
     if (name == NULL)
         xmlSAX2ErrMemory(ctxt);
     ctxt->vctxt.valid = 1;
@@ -644,7 +652,6 @@ xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
 	               name, NULL);
-	xmlFree(name);
 	xmlFree(prefix);
 	xmlFreeEnumeration(tree);
 	return;
@@ -659,8 +666,6 @@ xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
 #endif /* LIBXML_VALID_ENABLED */
     if (prefix != NULL)
 	xmlFree(prefix);
-    if (name != NULL)
-	xmlFree(name);
 }
 
 /**
@@ -905,7 +910,7 @@ xmlSAX2AppendChild(xmlParserCtxtPtr ctxt, xmlNodePtr node) {
     }
 }
 
-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
+#if defined(LIBXML_SAX1_ENABLED)
 /**
  * xmlNsErrMsg:
  * @ctxt:  an XML parser context
@@ -925,95 +930,37 @@ xmlNsErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 }
 
 /**
- * xmlSAX2AttributeInternal:
+ * xmlSAX1Attribute:
  * @ctx: the user data (XML parser context)
  * @fullname:  The attribute name, including namespace prefix
  * @value:  The attribute value
- * @prefix: the prefix on the element node
  *
  * Handle an attribute that has been read by the parser.
- * The default handling is to convert the attribute into an
- * DOM subtree and past it in a new xmlAttr element added to
- * the element.
+ *
+ * Deprecated SAX1 interface.
  */
 static void
-xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
-             const xmlChar *value, const xmlChar *prefix ATTRIBUTE_UNUSED)
+xmlSAX1Attribute(xmlParserCtxtPtr ctxt, const xmlChar *fullname,
+                 const xmlChar *value, const xmlChar *prefix)
 {
-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
     xmlAttrPtr ret;
-    xmlChar *name;
+    const xmlChar *name;
     xmlChar *ns;
-    xmlChar *nval;
     xmlNsPtr namespace;
 
-    if (ctxt->html) {
-	name = xmlStrdup(fullname);
-	ns = NULL;
-	namespace = NULL;
-    } else {
-	/*
-	 * Split the full name into a namespace prefix and the tag name
-	 */
-	name = xmlSplitQName(ctxt, fullname, &ns);
-	if ((name != NULL) && (name[0] == 0)) {
-	    if (xmlStrEqual(ns, BAD_CAST "xmlns")) {
-		xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,
-			    "invalid namespace declaration '%s'\n",
-			    fullname, NULL);
-	    } else {
-		xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,
-			     "Avoid attribute ending with ':' like '%s'\n",
-			     fullname, NULL);
-	    }
-	    if (ns != NULL)
-		xmlFree(ns);
-	    ns = NULL;
-	    xmlFree(name);
-	    name = xmlStrdup(fullname);
-	}
-    }
+    /*
+     * Split the full name into a namespace prefix and the tag name
+     */
+    name = xmlSplitQName4(fullname, &ns);
     if (name == NULL) {
         xmlSAX2ErrMemory(ctxt);
-	if (ns != NULL)
-	    xmlFree(ns);
-	return;
-    }
-
-#ifdef LIBXML_HTML_ENABLED
-    if ((ctxt->html) &&
-        (value == NULL) && (htmlIsBooleanAttr(fullname))) {
-            nval = xmlStrdup(fullname);
-            if (nval == NULL)
-                xmlSAX2ErrMemory(ctxt);
-            value = (const xmlChar *) nval;
-    } else
-#endif
-    {
-#ifdef LIBXML_VALID_ENABLED
-        /*
-         * Do the last stage of the attribute normalization
-         * Needed for HTML too:
-         *   http://www.w3.org/TR/html4/types.html#h-6.2
-         */
-        ctxt->vctxt.valid = 1;
-        nval = xmlValidCtxtNormalizeAttributeValue(&ctxt->vctxt,
-                                               ctxt->myDoc, ctxt->node,
-                                               fullname, value);
-        if (ctxt->vctxt.valid != 1) {
-            ctxt->valid = 0;
-        }
-        if (nval != NULL)
-            value = nval;
-#else
-        nval = NULL;
-#endif /* LIBXML_VALID_ENABLED */
+        return;
     }
 
     /*
      * Check whether it's a namespace definition
      */
-    if ((!ctxt->html) && (ns == NULL) &&
+    if ((ns == NULL) &&
         (name[0] == 'x') && (name[1] == 'm') && (name[2] == 'l') &&
         (name[3] == 'n') && (name[4] == 's') && (name[5] == 0)) {
 	xmlNsPtr nsret;
@@ -1027,10 +974,6 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
 	    val = xmlExpandEntitiesInAttValue(ctxt, value, /* normalize */ 0);
 	    if (val == NULL) {
 	        xmlSAX2ErrMemory(ctxt);
-		if (name != NULL)
-		    xmlFree(name);
-                if (nval != NULL)
-                    xmlFree(nval);
 		return;
 	    }
 	} else {
@@ -1071,16 +1014,11 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
 					   ctxt->node, prefix, nsret, val);
         }
 #endif /* LIBXML_VALID_ENABLED */
-	if (name != NULL)
-	    xmlFree(name);
-	if (nval != NULL)
-	    xmlFree(nval);
 	if (val != value)
 	    xmlFree(val);
 	return;
     }
-    if ((!ctxt->html) &&
-	(ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&
+    if ((ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&
         (ns[3] == 'n') && (ns[4] == 's') && (ns[5] == 0)) {
 	xmlNsPtr nsret;
 	xmlChar *val;
@@ -1094,10 +1032,6 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
 	    if (val == NULL) {
 	        xmlSAX2ErrMemory(ctxt);
 	        xmlFree(ns);
-		if (name != NULL)
-		    xmlFree(name);
-                if (nval != NULL)
-                    xmlFree(nval);
 		return;
 	    }
 	} else {
@@ -1143,10 +1077,6 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
 					   ctxt->node, prefix, nsret, value);
         }
 #endif /* LIBXML_VALID_ENABLED */
-	if (name != NULL)
-	    xmlFree(name);
-	if (nval != NULL)
-	    xmlFree(nval);
 	if (val != value)
 	    xmlFree(val);
 	return;
@@ -1177,8 +1107,6 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
                                    name, NULL, NULL, 0,
                                    "Attribute %s in %s redefined\n",
                                    name, namespace->href);
-                        if (name != NULL)
-                            xmlFree(name);
                         goto error;
                     }
                 }
@@ -1190,13 +1118,13 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
     }
 
     /* !!!!!! <a toto:arg="" xmlns:toto="http://toto.com"> */
-    ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL);
+    ret = xmlNewNsProp(ctxt->node, namespace, name, NULL);
     if (ret == NULL) {
         xmlSAX2ErrMemory(ctxt);
         goto error;
     }
 
-    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
+    if (ctxt->replaceEntities == 0) {
         if (xmlNodeParseContent((xmlNodePtr) ret, value, INT_MAX) < 0)
             xmlSAX2ErrMemory(ctxt);
     } else if (value != NULL) {
@@ -1210,7 +1138,7 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
     }
 
 #ifdef LIBXML_VALID_ENABLED
-    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
+    if (ctxt->validate && ctxt->wellFormed &&
         ctxt->myDoc && ctxt->myDoc->intSubset) {
 
 	/*
@@ -1253,6 +1181,7 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
     } else
 #endif /* LIBXML_VALID_ENABLED */
            if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
+               (ctxt->input->entity == NULL) &&
                /* Don't create IDs containing entity references */
                (ret->children != NULL) &&
                (ret->children->type == XML_TEXT_NODE) &&
@@ -1287,8 +1216,6 @@ xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
     }
 
 error:
-    if (nval != NULL)
-	xmlFree(nval);
     if (ns != NULL)
 	xmlFree(ns);
 }
@@ -1297,6 +1224,8 @@ error:
  * xmlCheckDefaultedAttributes:
  *
  * Check defaulted attributes from the DTD
+ *
+ * Deprecated SAX1 interface.
  */
 static void
 xmlCheckDefaultedAttributes(xmlParserCtxtPtr ctxt, const xmlChar *name,
@@ -1429,8 +1358,8 @@ process_external_subset:
 			    }
 			}
 			if (att == NULL) {
-			    xmlSAX2AttributeInternal(ctxt, fulln,
-						 attr->defaultValue, prefix);
+			    xmlSAX1Attribute(ctxt, fulln,
+					     attr->defaultValue, prefix);
 			}
 			if ((fulln != fn) && (fulln != attr->name))
 			    xmlFree(fulln);
@@ -1449,25 +1378,27 @@ process_external_subset:
 }
 
 /**
- * xmlSAX2StartElement:
+ * xmlSAX1StartElement:
  * @ctx: the user data (XML parser context)
  * @fullname:  The element name, including namespace prefix
  * @atts:  An array of name/value attributes pairs, NULL terminated
  *
  * called when an opening tag has been processed.
+ *
+ * Deprecated SAX1 interface.
  */
-void
-xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
+static void
+xmlSAX1StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
 {
     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
     xmlNodePtr ret;
     xmlNodePtr parent;
     xmlNsPtr ns;
-    xmlChar *name;
+    const xmlChar *name;
     xmlChar *prefix;
     const xmlChar *att;
     const xmlChar *value;
-    int i;
+    int i, res;
 
     if ((ctx == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL)) return;
 
@@ -1485,18 +1416,13 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
 	ctxt->validate = 0;
     }
 
-    if (ctxt->html) {
-        prefix = NULL;
-        name = xmlStrdup(fullname);
-    } else {
-        /*
-         * Split the full name into a namespace prefix and the tag name
-         */
-        name = xmlSplitQName(ctxt, fullname, &prefix);
-        if (name == NULL) {
-            xmlSAX2ErrMemory(ctxt);
-            return;
-        }
+    /*
+     * Split the full name into a namespace prefix and the tag name
+     */
+    name = xmlSplitQName4(fullname, &prefix);
+    if (name == NULL) {
+        xmlSAX2ErrMemory(ctxt);
+        return;
     }
 
     /*
@@ -1504,7 +1430,7 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
      *        attributes parsing, since local namespace can be defined as
      *        an attribute at this level.
      */
-    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, name, NULL);
+    ret = xmlNewDocNode(ctxt->myDoc, NULL, name, NULL);
     if (ret == NULL) {
 	xmlFree(prefix);
 	xmlSAX2ErrMemory(ctxt);
@@ -1533,65 +1459,61 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
         return;
     }
 
-    if (!ctxt->html) {
-        int res;
+    /*
+     * Insert all the defaulted attributes from the DTD especially
+     * namespaces
+     */
+    if ((ctxt->myDoc->intSubset != NULL) ||
+        (ctxt->myDoc->extSubset != NULL)) {
+        xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
+    }
 
-        /*
-         * Insert all the defaulted attributes from the DTD especially
-         * namespaces
-         */
-        if ((ctxt->myDoc->intSubset != NULL) ||
-            (ctxt->myDoc->extSubset != NULL)) {
-            xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
-        }
+    /*
+     * process all the attributes whose name start with "xmlns"
+     */
+    if (atts != NULL) {
+        i = 0;
+        att = atts[i++];
+        value = atts[i++];
+        while ((att != NULL) && (value != NULL)) {
+            if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
+                (att[3] == 'n') && (att[4] == 's'))
+                xmlSAX1Attribute(ctxt, att, value, prefix);
 
-        /*
-         * process all the attributes whose name start with "xmlns"
-         */
-        if (atts != NULL) {
-            i = 0;
             att = atts[i++];
             value = atts[i++];
-	    while ((att != NULL) && (value != NULL)) {
-		if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
-		    (att[3] == 'n') && (att[4] == 's'))
-		    xmlSAX2AttributeInternal(ctxt, att, value, prefix);
-
-		att = atts[i++];
-		value = atts[i++];
-	    }
         }
+    }
 
-        /*
-         * Search the namespace, note that since the attributes have been
-         * processed, the local namespaces are available.
-         */
-        res = xmlSearchNsSafe(ret, prefix, &ns);
+    /*
+     * Search the namespace, note that since the attributes have been
+     * processed, the local namespaces are available.
+     */
+    res = xmlSearchNsSafe(ret, prefix, &ns);
+    if (res < 0)
+        xmlSAX2ErrMemory(ctxt);
+    if ((ns == NULL) && (parent != NULL)) {
+        res = xmlSearchNsSafe(parent, prefix, &ns);
         if (res < 0)
             xmlSAX2ErrMemory(ctxt);
-        if ((ns == NULL) && (parent != NULL)) {
-            res = xmlSearchNsSafe(parent, prefix, &ns);
-            if (res < 0)
-                xmlSAX2ErrMemory(ctxt);
-        }
-        if ((prefix != NULL) && (ns == NULL)) {
-            xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
-                         "Namespace prefix %s is not defined\n",
-                         prefix, NULL);
-            ns = xmlNewNs(ret, NULL, prefix);
-            if (ns == NULL)
-                xmlSAX2ErrMemory(ctxt);
-        }
-
-        /*
-         * set the namespace node, making sure that if the default namespace
-         * is unbound on a parent we simply keep it NULL
-         */
-        if ((ns != NULL) && (ns->href != NULL) &&
-            ((ns->href[0] != 0) || (ns->prefix != NULL)))
-            xmlSetNs(ret, ns);
+    }
+    if ((prefix != NULL) && (ns == NULL)) {
+        xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
+                     "Namespace prefix %s is not defined\n",
+                     prefix, NULL);
+        ns = xmlNewNs(ret, NULL, prefix);
+        if (ns == NULL)
+            xmlSAX2ErrMemory(ctxt);
     }
 
+    /*
+     * set the namespace node, making sure that if the default namespace
+     * is unbound on a parent we simply keep it NULL
+     */
+    if ((ns != NULL) && (ns->href != NULL) &&
+        ((ns->href[0] != 0) || (ns->prefix != NULL)))
+        xmlSetNs(ret, ns);
+
     /*
      * process all the other attributes
      */
@@ -1599,25 +1521,17 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
         i = 0;
 	att = atts[i++];
 	value = atts[i++];
-	if (ctxt->html) {
-	    while (att != NULL) {
-		xmlSAX2AttributeInternal(ctxt, att, value, NULL);
-		att = atts[i++];
-		value = atts[i++];
-	    }
-	} else {
-	    while ((att != NULL) && (value != NULL)) {
-		if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||
-		    (att[3] != 'n') || (att[4] != 's'))
-		    xmlSAX2AttributeInternal(ctxt, att, value, NULL);
+        while ((att != NULL) && (value != NULL)) {
+            if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||
+                (att[3] != 'n') || (att[4] != 's'))
+                xmlSAX1Attribute(ctxt, att, value, NULL);
 
-		/*
-		 * Next ones
-		 */
-		att = atts[i++];
-		value = atts[i++];
-	    }
-	}
+            /*
+             * Next ones
+             */
+            att = atts[i++];
+            value = atts[i++];
+        }
     }
 
 #ifdef LIBXML_VALID_ENABLED
@@ -1643,37 +1557,187 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
 	xmlFree(prefix);
 
 }
+#endif /* LIBXML_SAX1_ENABLED */
+
+#ifdef LIBXML_HTML_ENABLED
+static void
+xmlSAX2HtmlAttribute(xmlParserCtxtPtr ctxt, const xmlChar *fullname,
+                     const xmlChar *value) {
+    xmlAttrPtr ret;
+    xmlChar *nval = NULL;
+
+    ret = xmlNewNsProp(ctxt->node, NULL, fullname, NULL);
+    if (ret == NULL) {
+        xmlSAX2ErrMemory(ctxt);
+        return;
+    }
+
+    if ((value == NULL) && (htmlIsBooleanAttr(fullname))) {
+        nval = xmlStrdup(fullname);
+        if (nval == NULL) {
+            xmlSAX2ErrMemory(ctxt);
+            return;
+        }
+        value = nval;
+    }
+
+    if (value != NULL) {
+        ret->children = xmlNewDocText(ctxt->myDoc, value);
+        if (ret->children == NULL) {
+            xmlSAX2ErrMemory(ctxt);
+        } else {
+            ret->last = ret->children;
+            ret->children->parent = (xmlNodePtr) ret;
+        }
+    }
+
+    if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
+        /*
+         * Don't create IDs containing entity references (should
+         * be always the case with HTML)
+         */
+        (ret->children != NULL) &&
+        (ret->children->type == XML_TEXT_NODE) &&
+        (ret->children->next == NULL)) {
+        int res = xmlIsID(ctxt->myDoc, ctxt->node, ret);
+
+        if (res < 0)
+            xmlCtxtErrMemory(ctxt);
+        else if (res > 0)
+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, ret->children->content, ret);
+    }
+
+    if (nval != NULL)
+        xmlFree(nval);
+}
+
+/**
+ * xmlSAX2StartHtmlElement:
+ * @ctxt:  parser context
+ * @fullname:  The element name, including namespace prefix
+ * @atts:  An array of name/value attributes pairs, NULL terminated
+ *
+ * Called when an opening tag has been processed.
+ */
+static void
+xmlSAX2StartHtmlElement(xmlParserCtxtPtr ctxt, const xmlChar *fullname,
+                        const xmlChar **atts) {
+    xmlNodePtr ret;
+    xmlNodePtr parent;
+    const xmlChar *att;
+    const xmlChar *value;
+    int i;
+
+    ret = xmlNewDocNode(ctxt->myDoc, NULL, fullname, NULL);
+    if (ret == NULL) {
+	xmlSAX2ErrMemory(ctxt);
+        return;
+    }
+    ctxt->nodemem = -1;
+
+    /* Initialize parent before pushing node */
+    parent = ctxt->node;
+    if (parent == NULL)
+        parent = (xmlNodePtr) ctxt->myDoc;
+
+    /*
+     * Link the child element
+     */
+    xmlSAX2AppendChild(ctxt, ret);
+
+    /*
+     * We are parsing a new node.
+     */
+    if (nodePush(ctxt, ret) < 0) {
+        xmlUnlinkNode(ret);
+        xmlFreeNode(ret);
+        return;
+    }
+
+    if (atts != NULL) {
+        i = 0;
+	att = atts[i++];
+	value = atts[i++];
+        while (att != NULL) {
+            xmlSAX2HtmlAttribute(ctxt, att, value);
+            att = atts[i++];
+            value = atts[i++];
+        }
+    }
+}
+#endif /* LIBXML_HTML_ENABLED */
+
+/**
+ * xmlSAX2StartElement:
+ * @ctx: the user data (XML parser context)
+ * @fullname:  The element name, including namespace prefix
+ * @atts:  An array of name/value attributes pairs, NULL terminated
+ *
+ * DEPRECATED: Don't call this function directly.
+ *
+ * Called when an opening tag has been processed.
+ *
+ * Used for HTML and SAX1.
+ */
+void
+xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts) {
+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
+
+    (void) atts;
+
+    if ((ctxt == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL))
+        return;
+
+#ifdef LIBXML_SAX1_ENABLED
+    if (!ctxt->html) {
+        xmlSAX1StartElement(ctxt, fullname, atts);
+        return;
+    }
+#endif
+
+#ifdef LIBXML_HTML_ENABLED
+    if (ctxt->html) {
+        xmlSAX2StartHtmlElement(ctxt, fullname, atts);
+        return;
+    }
+#endif
+}
 
 /**
  * xmlSAX2EndElement:
  * @ctx: the user data (XML parser context)
  * @name:  The element name
  *
+ * DEPRECATED: Don't call this function directly.
+ *
  * called when the end of an element has been detected.
+ *
+ * Used for HTML and SAX1.
  */
 void
 xmlSAX2EndElement(void *ctx, const xmlChar *name ATTRIBUTE_UNUSED)
 {
     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 
-    if (ctx == NULL) return;
-
-    ctxt->nodemem = -1;
+    if (ctxt == NULL)
+        return;
 
-#ifdef LIBXML_VALID_ENABLED
-    if (ctxt->validate && ctxt->wellFormed &&
+#if defined(LIBXML_SAX1_ENABLED) && defined(LIBXML_VALID_ENABLED)
+    if (!ctxt->html && ctxt->validate && ctxt->wellFormed &&
         ctxt->myDoc && ctxt->myDoc->intSubset)
         ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 					     ctxt->node);
 #endif /* LIBXML_VALID_ENABLED */
 
+#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED)
+    ctxt->nodemem = -1;
 
     /*
      * end of parsing of this node.
      */
     nodePop(ctxt);
+#endif
 }
-#endif /* LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLED || LIBXML_LEGACY_ENABLED */
 
 /*
  * xmlSAX2TextNode:
@@ -1756,7 +1820,7 @@ skip:
     } else
 	ret->content = (xmlChar *) intern;
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(ret);
     return(ret);
 }
@@ -1872,7 +1936,7 @@ xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt,
             xmlSAX2ErrMemory(ctxt);
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
         xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
 
     if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
@@ -1985,6 +2049,7 @@ xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt,
     } else
 #endif /* LIBXML_VALID_ENABLED */
            if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
+               (ctxt->input->entity == NULL) &&
                /* Don't create IDs containing entity references */
                (ret->children != NULL) &&
                (ret->children->type == XML_TEXT_NODE) &&
@@ -2120,7 +2185,7 @@ xmlSAX2StartElementNs(void *ctx,
 		return;
 	    }
 	}
-	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+	if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	    xmlRegisterNodeDefaultValue(ret);
     } else {
 	if (ctxt->dictNames)
@@ -2129,8 +2194,7 @@ xmlSAX2StartElementNs(void *ctx,
 	else if (lname == NULL)
 	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 	else
-	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
-	                               (xmlChar *) lname, NULL);
+	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, lname, NULL);
 	if (ret == NULL) {
 	    xmlSAX2ErrMemory(ctxt);
 	    return;
@@ -2407,7 +2471,7 @@ xmlSAX2Text(xmlParserCtxtPtr ctxt, const xmlChar *ch, int len,
     } else {
 	int coalesceText = (lastChild != NULL) &&
 	    (lastChild->type == type) &&
-	    ((type != XML_TEXT_NODE) ||
+	    (((ctxt->html) && (type != XML_TEXT_NODE)) ||
              (lastChild->name == xmlStringText));
 	if ((coalesceText) && (ctxt->nodemem != 0)) {
             int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
@@ -2591,32 +2655,23 @@ xmlSAX2CDataBlock(void *ctx, const xmlChar *value, int len)
     xmlSAX2Text((xmlParserCtxtPtr) ctx, value, len, XML_CDATA_SECTION_NODE);
 }
 
-static int xmlSAX2DefaultVersionValue = 2;
-
 #ifdef LIBXML_SAX1_ENABLED
 /**
  * xmlSAXDefaultVersion:
- * @version:  the version, 1 or 2
+ * @version:  the version, must be 2
  *
  * DEPRECATED: Use parser option XML_PARSE_SAX1.
  *
- * Set the default version of SAX used globally by the library.
- * By default, during initialization the default is set to 2.
- * Note that it is generally a better coding style to use
- * xmlSAXVersion() to set up the version explicitly for a given
- * parsing context.
+ * Has no effect.
  *
- * Returns the previous value in case of success and -1 in case of error.
+ * Returns 2 in case of success and -1 in case of error.
  */
 int
 xmlSAXDefaultVersion(int version)
 {
-    int ret = xmlSAX2DefaultVersionValue;
-
-    if ((version != 1) && (version != 2))
+    if (version != 2)
         return(-1);
-    xmlSAX2DefaultVersionValue = version;
-    return(ret);
+    return(2);
 }
 #endif /* LIBXML_SAX1_ENABLED */
 
@@ -2693,11 +2748,9 @@ xmlSAX2InitDefaultSAXHandler(xmlSAXHandler *hdlr, int warning)
     if ((hdlr == NULL) || (hdlr->initialized != 0))
 	return;
 
-    xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);
+    xmlSAXVersion(hdlr, 2);
     if (warning == 0)
 	hdlr->warning = NULL;
-    else
-	hdlr->warning = xmlParserWarning;
 }
 
 /**
diff --git a/VERSION b/VERSION
new file mode 100644
index 00000000..edcfe40d
--- /dev/null
+++ b/VERSION
@@ -0,0 +1 @@
+2.14.0
diff --git a/autogen.sh b/autogen.sh
index 4cd43fe7..98881a08 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -64,8 +64,7 @@ if [ ! -d $srcdir/m4 ]; then
         mkdir $srcdir/m4
 fi
 
-# Replaced by autoreconf below
-autoreconf -if -Wall || exit 1
+aclocal
 
 if ! grep -q pkg.m4 aclocal.m4; then
     cat <<EOF
@@ -76,6 +75,8 @@ EOF
     exit 1
 fi
 
+autoreconf -if -Wall || exit 1
+
 cd $THEDIR
 
 if test x$OBJ_DIR != x; then
diff --git a/buf.c b/buf.c
index f9f59b26..ebab442f 100644
--- a/buf.c
+++ b/buf.c
@@ -15,16 +15,13 @@
 #define IN_LIBXML
 #include "libxml.h"
 
-#include <string.h> /* for memset() only ! */
+#include <string.h>
 #include <limits.h>
-#include <ctype.h>
-#include <stdlib.h>
 
+#include <libxml/parser.h>
 #include <libxml/tree.h>
-#include <libxml/parserInternals.h> /* for XML_MAX_TEXT_LENGTH */
 
 #include "private/buf.h"
-#include "private/error.h"
 
 #ifndef SIZE_MAX
 #define SIZE_MAX ((size_t) -1)
@@ -32,6 +29,13 @@
 
 #define WITH_BUFFER_COMPAT
 
+#define BUF_FLAG_OOM        (1u << 0)
+#define BUF_FLAG_OVERFLOW   (1u << 1)
+#define BUF_FLAG_STATIC     (1u << 2)
+
+#define BUF_ERROR(buf) ((buf)->flags & (BUF_FLAG_OOM | BUF_FLAG_OVERFLOW))
+#define BUF_STATIC(buf) ((buf)->flags & BUF_FLAG_STATIC)
+
 /**
  * xmlBuf:
  *
@@ -42,14 +46,15 @@
 
 struct _xmlBuf {
     xmlChar *content;		/* The buffer content UTF8 */
+#ifdef WITH_BUFFER_COMPAT
     unsigned int compat_use;    /* for binary compatibility */
     unsigned int compat_size;   /* for binary compatibility */
-    xmlBufferAllocationScheme alloc; /* The realloc method */
-    xmlChar *contentIO;		/* in IO mode we may have a different base */
+#endif
+    xmlChar *mem;		/* Start of the allocation */
     size_t use;		        /* The buffer size used */
-    size_t size;		/* The buffer size */
-    xmlBufferPtr buffer;        /* wrapper for an old buffer */
-    int error;                  /* an error code if a failure occurred */
+    size_t size;		/* The buffer size, excluding terminating 0 */
+    size_t maxSize;             /* The maximum buffer size */
+    unsigned flags;             /* flags */
 };
 
 #ifdef WITH_BUFFER_COMPAT
@@ -91,8 +96,8 @@ struct _xmlBuf {
 static void
 xmlBufMemoryError(xmlBufPtr buf)
 {
-    if (buf->error == 0)
-        buf->error = XML_ERR_NO_MEMORY;
+    if (!BUF_ERROR(buf))
+        buf->flags |= BUF_FLAG_OOM;
 }
 
 /**
@@ -105,72 +110,96 @@ xmlBufMemoryError(xmlBufPtr buf)
 static void
 xmlBufOverflowError(xmlBufPtr buf)
 {
-    if (buf->error == 0)
-        buf->error = XML_BUF_OVERFLOW;
+    if (!BUF_ERROR(buf))
+        buf->flags |= BUF_FLAG_OVERFLOW;
 }
 
-
 /**
  * xmlBufCreate:
+ * @size: initial size of buffer
  *
  * routine to create an XML buffer.
  * returns the new structure.
  */
 xmlBufPtr
-xmlBufCreate(void) {
+xmlBufCreate(size_t size) {
     xmlBufPtr ret;
 
-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
+    if (size == SIZE_MAX)
+        return(NULL);
+
+    ret = xmlMalloc(sizeof(*ret));
     if (ret == NULL)
         return(NULL);
+
     ret->use = 0;
-    ret->error = 0;
-    ret->buffer = NULL;
-    ret->size = xmlDefaultBufferSize;
-    UPDATE_COMPAT(ret);
-    ret->alloc = xmlBufferAllocScheme;
-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
-    if (ret->content == NULL) {
-	xmlFree(ret);
+    ret->flags = 0;
+    ret->size = size;
+    ret->maxSize = SIZE_MAX - 1;
+
+    ret->mem = xmlMalloc(ret->size + 1);
+    if (ret->mem == NULL) {
+        xmlFree(ret);
         return(NULL);
     }
+    ret->content = ret->mem;
     ret->content[0] = 0;
-    ret->contentIO = NULL;
+
+    UPDATE_COMPAT(ret);
     return(ret);
 }
 
 /**
- * xmlBufCreateSize:
- * @size: initial size of buffer
+ * xmlBufCreateMem:
+ * @mem:  a memory area
+ * @size:  size of the buffer excluding terminator
+ * @isStatic:  whether the memory area is static
  *
- * routine to create an XML buffer.
- * returns the new structure.
+ * Create a buffer initialized with memory.
+ *
+ * If @isStatic is set, uses the memory area directly as backing store.
+ * The memory must be zero-terminated and not be modified for the
+ * lifetime of the buffer. A static buffer can't be grown, modified or
+ * detached, but it can be shrunk.
+ *
+ * Returns a new buffer.
  */
 xmlBufPtr
-xmlBufCreateSize(size_t size) {
+xmlBufCreateMem(const xmlChar *mem, size_t size, int isStatic) {
     xmlBufPtr ret;
 
-    if (size == SIZE_MAX)
+    if (mem == NULL)
         return(NULL);
-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
+
+    ret = xmlMalloc(sizeof(*ret));
     if (ret == NULL)
         return(NULL);
-    ret->use = 0;
-    ret->error = 0;
-    ret->buffer = NULL;
-    ret->alloc = xmlBufferAllocScheme;
-    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
-    UPDATE_COMPAT(ret);
-    if (ret->size){
-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
-        if (ret->content == NULL) {
+
+    if (isStatic) {
+        /* Check that memory is zero-terminated */
+        if (mem[size] != 0) {
             xmlFree(ret);
             return(NULL);
         }
-        ret->content[0] = 0;
-    } else
-	ret->content = NULL;
-    ret->contentIO = NULL;
+        ret->flags = BUF_FLAG_STATIC;
+        ret->mem = (xmlChar *) mem;
+    } else {
+        ret->flags = 0;
+        ret->mem = xmlMalloc(size + 1);
+        if (ret->mem == NULL) {
+            xmlFree(ret);
+            return(NULL);
+        }
+        memcpy(ret->mem, mem, size);
+        ret->mem[size] = 0;
+    }
+
+    ret->use = size;
+    ret->size = size;
+    ret->maxSize = SIZE_MAX - 1;
+    ret->content = ret->mem;
+
+    UPDATE_COMPAT(ret);
     return(ret);
 }
 
@@ -188,83 +217,25 @@ xmlChar *
 xmlBufDetach(xmlBufPtr buf) {
     xmlChar *ret;
 
-    if (buf == NULL)
-        return(NULL);
-    if (buf->buffer != NULL)
-        return(NULL);
-    if (buf->error)
+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))
         return(NULL);
 
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
-        (buf->content != buf->contentIO)) {
+    if (buf->content != buf->mem) {
         ret = xmlStrndup(buf->content, buf->use);
-        xmlFree(buf->contentIO);
+        xmlFree(buf->mem);
     } else {
-        ret = buf->content;
+        ret = buf->mem;
     }
 
     buf->content = NULL;
-    buf->contentIO = NULL;
+    buf->mem = NULL;
     buf->size = 0;
     buf->use = 0;
-    UPDATE_COMPAT(buf);
 
+    UPDATE_COMPAT(buf);
     return ret;
 }
 
-/**
- * xmlBufGetAllocationScheme:
- * @buf:  the buffer
- *
- * Get the buffer allocation scheme
- *
- * Returns the scheme or -1 in case of error
- */
-int
-xmlBufGetAllocationScheme(xmlBufPtr buf) {
-    if (buf == NULL) {
-        return(-1);
-    }
-    return(buf->alloc);
-}
-
-/**
- * xmlBufSetAllocationScheme:
- * @buf:  the buffer to tune
- * @scheme:  allocation scheme to use
- *
- * Sets the allocation scheme for this buffer
- *
- * returns 0 in case of success and -1 in case of failure
- */
-int
-xmlBufSetAllocationScheme(xmlBufPtr buf,
-                          xmlBufferAllocationScheme scheme) {
-    if ((buf == NULL) || (buf->error != 0)) {
-        return(-1);
-    }
-    if (buf->alloc == XML_BUFFER_ALLOC_IO)
-        return(-1);
-    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
-        (scheme == XML_BUFFER_ALLOC_EXACT) ||
-        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
-	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
-	buf->alloc = scheme;
-        if (buf->buffer)
-            buf->buffer->alloc = scheme;
-        return(0);
-    }
-    /*
-     * Switching a buffer ALLOC_IO has the side effect of initializing
-     * the contentIO field with the current content
-     */
-    if (scheme == XML_BUFFER_ALLOC_IO) {
-        buf->alloc = XML_BUFFER_ALLOC_IO;
-        buf->contentIO = buf->content;
-    }
-    return(-1);
-}
-
 /**
  * xmlBufFree:
  * @buf:  the buffer to free
@@ -274,16 +245,11 @@ xmlBufSetAllocationScheme(xmlBufPtr buf,
  */
 void
 xmlBufFree(xmlBufPtr buf) {
-    if (buf == NULL) {
+    if (buf == NULL)
 	return;
-    }
 
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
-        (buf->contentIO != NULL)) {
-        xmlFree(buf->contentIO);
-    } else if (buf->content != NULL) {
-        xmlFree(buf->content);
-    }
+    if (!BUF_STATIC(buf))
+        xmlFree(buf->mem);
     xmlFree(buf);
 }
 
@@ -295,20 +261,17 @@ xmlBufFree(xmlBufPtr buf) {
  */
 void
 xmlBufEmpty(xmlBufPtr buf) {
-    if ((buf == NULL) || (buf->error != 0)) return;
-    if (buf->content == NULL) return;
+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))
+        return;
+    if (buf->mem == NULL)
+        return;
     CHECK_COMPAT(buf)
+
     buf->use = 0;
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
-               (buf->contentIO != NULL)) {
-        size_t start_buf = buf->content - buf->contentIO;
+    buf->size += buf->content - buf->mem;
+    buf->content = buf->mem;
+    buf->content[0] = 0;
 
-	buf->size += start_buf;
-        buf->content = buf->contentIO;
-        buf->content[0] = 0;
-    } else {
-        buf->content[0] = 0;
-    }
     UPDATE_COMPAT(buf)
 }
 
@@ -317,6 +280,8 @@ xmlBufEmpty(xmlBufPtr buf) {
  * @buf:  the buffer to dump
  * @len:  the number of xmlChar to remove
  *
+ * DEPRECATED: Don't use.
+ *
  * Remove the beginning of an XML buffer.
  * NOTE that this routine behaviour differs from xmlBufferShrink()
  * as it will return 0 on error instead of -1 due to size_t being
@@ -326,37 +291,19 @@ xmlBufEmpty(xmlBufPtr buf) {
  */
 size_t
 xmlBufShrink(xmlBufPtr buf, size_t len) {
-    if ((buf == NULL) || (buf->error != 0)) return(0);
+    if ((buf == NULL) || (BUF_ERROR(buf)))
+        return(0);
+    if (len == 0)
+        return(0);
     CHECK_COMPAT(buf)
-    if (len == 0) return(0);
-    if (len > buf->use) return(0);
+
+    if (len > buf->use)
+        return(0);
 
     buf->use -= len;
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-	/*
-	 * we just move the content pointer, but also make sure
-	 * the perceived buffer size has shrunk accordingly
-	 */
-        buf->content += len;
-	buf->size -= len;
+    buf->content += len;
+    buf->size -= len;
 
-        /*
-	 * sometimes though it maybe be better to really shrink
-	 * on IO buffers
-	 */
-	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-	    size_t start_buf = buf->content - buf->contentIO;
-	    if (start_buf >= buf->size) {
-		memmove(buf->contentIO, &buf->content[0], buf->use);
-		buf->content = buf->contentIO;
-		buf->content[buf->use] = 0;
-		buf->size += start_buf;
-	    }
-	}
-    } else {
-	memmove(buf->content, &buf->content[len], buf->use);
-	buf->content[buf->use] = 0;
-    }
     UPDATE_COMPAT(buf)
     return(len);
 }
@@ -367,66 +314,65 @@ xmlBufShrink(xmlBufPtr buf, size_t len) {
  * @len:  the minimum free size to allocate
  *
  * Grow the available space of an XML buffer, @len is the target value
- * Error checking should be done on buf->error since using the return
- * value doesn't work that well
  *
- * Returns 0 in case of error or the length made available otherwise
+ * Returns 0 on success, -1 in case of error
  */
-static size_t
+static int
 xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
     size_t size;
+    size_t start;
     xmlChar *newbuf;
 
-    if ((buf == NULL) || (buf->error != 0)) return(0);
-    CHECK_COMPAT(buf)
-
-    if (len < buf->size - buf->use)
-        return(buf->size - buf->use - 1);
-    if (len >= SIZE_MAX - buf->use) {
-        xmlBufMemoryError(buf);
+    /*
+     * If there's enough space at the start of the buffer,
+     * move the contents.
+     */
+    start = buf->content - buf->mem;
+    if (len <= start + buf->size - buf->use) {
+        memmove(buf->mem, buf->content, buf->use + 1);
+        buf->size += start;
+        buf->content = buf->mem;
         return(0);
     }
 
+    if (len > buf->maxSize - buf->use) {
+        xmlBufOverflowError(buf);
+        return(-1);
+    }
+
     if (buf->size > (size_t) len) {
-        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
+        if (buf->size <= buf->maxSize / 2)
+            size = buf->size * 2;
+        else
+            size = buf->maxSize;
     } else {
         size = buf->use + len;
-        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
-    }
-
-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
-        /*
-	 * Used to provide parsing limits
-	 */
-        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
-	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
-	    xmlBufMemoryError(buf);
-	    return(0);
-	}
-	if (size >= XML_MAX_TEXT_LENGTH)
-	    size = XML_MAX_TEXT_LENGTH;
+        if (size <= buf->maxSize - 100)
+            size += 100;
     }
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        size_t start_buf = buf->content - buf->contentIO;
 
-	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
-	if (newbuf == NULL) {
-	    xmlBufMemoryError(buf);
-	    return(0);
-	}
-	buf->contentIO = newbuf;
-	buf->content = newbuf + start_buf;
+    if (buf->content == buf->mem) {
+        newbuf = xmlRealloc(buf->mem, size + 1);
+        if (newbuf == NULL) {
+            xmlBufMemoryError(buf);
+            return(-1);
+        }
     } else {
-	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
-	if (newbuf == NULL) {
-	    xmlBufMemoryError(buf);
-	    return(0);
-	}
-	buf->content = newbuf;
+        newbuf = xmlMalloc(size + 1);
+        if (newbuf == NULL) {
+            xmlBufMemoryError(buf);
+            return(-1);
+        }
+        if (buf->content != NULL)
+            memcpy(newbuf, buf->content, buf->use + 1);
+        xmlFree(buf->mem);
     }
+
+    buf->mem = newbuf;
+    buf->content = newbuf;
     buf->size = size;
-    UPDATE_COMPAT(buf)
-    return(buf->size - buf->use - 1);
+
+    return(0);
 }
 
 /**
@@ -437,44 +383,22 @@ xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  * Grow the available space of an XML buffer, @len is the target value
  * This is been kept compatible with xmlBufferGrow() as much as possible
  *
- * Returns -1 in case of error or the length made available otherwise
+ * Returns 0 on succes, -1 in case of error
  */
 int
-xmlBufGrow(xmlBufPtr buf, int len) {
-    size_t ret;
+xmlBufGrow(xmlBufPtr buf, size_t len) {
+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))
+        return(-1);
+    CHECK_COMPAT(buf)
 
-    if ((buf == NULL) || (len < 0)) return(-1);
-    if (len == 0)
+    if (len <= buf->size - buf->use)
         return(0);
-    ret = xmlBufGrowInternal(buf, len);
-    if (buf->error != 0)
-        return(-1);
-    return(ret > INT_MAX ? INT_MAX : ret);
-}
 
-/**
- * xmlBufDump:
- * @file:  the file output
- * @buf:  the buffer to dump
- *
- * Dumps an XML buffer to  a FILE *.
- * Returns the number of #xmlChar written
- */
-size_t
-xmlBufDump(FILE *file, xmlBufPtr buf) {
-    size_t ret;
+    if (xmlBufGrowInternal(buf, len) < 0)
+        return(-1);
 
-    if ((buf == NULL) || (buf->error != 0)) {
-	return(0);
-    }
-    if (buf->content == NULL) {
-	return(0);
-    }
-    CHECK_COMPAT(buf)
-    if (file == NULL)
-	file = stdout;
-    ret = fwrite(buf->content, 1, buf->use, file);
-    return(ret);
+    UPDATE_COMPAT(buf)
+    return(0);
 }
 
 /**
@@ -489,7 +413,7 @@ xmlBufDump(FILE *file, xmlBufPtr buf) {
 xmlChar *
 xmlBufContent(const xmlBuf *buf)
 {
-    if ((!buf) || (buf->error))
+    if ((!buf) || (BUF_ERROR(buf)))
         return NULL;
 
     return(buf->content);
@@ -507,7 +431,7 @@ xmlBufContent(const xmlBuf *buf)
 xmlChar *
 xmlBufEnd(xmlBufPtr buf)
 {
-    if ((!buf) || (buf->error))
+    if ((!buf) || (BUF_ERROR(buf)))
         return NULL;
     CHECK_COMPAT(buf)
 
@@ -527,10 +451,10 @@ xmlBufEnd(xmlBufPtr buf)
  */
 int
 xmlBufAddLen(xmlBufPtr buf, size_t len) {
-    if ((buf == NULL) || (buf->error))
+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))
         return(-1);
     CHECK_COMPAT(buf)
-    if (len >= (buf->size - buf->use))
+    if (len > buf->size - buf->use)
         return(-1);
     buf->use += len;
     buf->content[buf->use] = 0;
@@ -538,25 +462,6 @@ xmlBufAddLen(xmlBufPtr buf, size_t len) {
     return(0);
 }
 
-/**
- * xmlBufLength:
- * @buf:  the buffer
- *
- * Function to get the length of a buffer
- *
- * Returns the length of data in the internal content
- */
-
-size_t
-xmlBufLength(const xmlBufPtr buf)
-{
-    if ((!buf) || (buf->error))
-        return 0;
-    CHECK_COMPAT(buf)
-
-    return(buf->use);
-}
-
 /**
  * xmlBufUse:
  * @buf:  the buffer
@@ -569,7 +474,7 @@ xmlBufLength(const xmlBufPtr buf)
 size_t
 xmlBufUse(const xmlBufPtr buf)
 {
-    if ((!buf) || (buf->error))
+    if ((!buf) || (BUF_ERROR(buf)))
         return 0;
     CHECK_COMPAT(buf)
 
@@ -591,11 +496,11 @@ xmlBufUse(const xmlBufPtr buf)
 size_t
 xmlBufAvail(const xmlBufPtr buf)
 {
-    if ((!buf) || (buf->error))
+    if ((!buf) || (BUF_ERROR(buf)))
         return 0;
     CHECK_COMPAT(buf)
 
-    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
+    return(buf->size - buf->use);
 }
 
 /**
@@ -609,139 +514,13 @@ xmlBufAvail(const xmlBufPtr buf)
 int
 xmlBufIsEmpty(const xmlBufPtr buf)
 {
-    if ((!buf) || (buf->error))
+    if ((!buf) || (BUF_ERROR(buf)))
         return(-1);
     CHECK_COMPAT(buf)
 
     return(buf->use == 0);
 }
 
-/**
- * xmlBufResize:
- * @buf:  the buffer to resize
- * @size:  the desired size
- *
- * Resize a buffer to accommodate minimum size of @size.
- *
- * Returns  0 in case of problems, 1 otherwise
- */
-int
-xmlBufResize(xmlBufPtr buf, size_t size)
-{
-    size_t newSize;
-    xmlChar* rebuf = NULL;
-    size_t start_buf;
-
-    if ((buf == NULL) || (buf->error))
-        return(0);
-    CHECK_COMPAT(buf)
-
-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
-        /*
-	 * Used to provide parsing limits
-	 */
-        if (size >= XML_MAX_TEXT_LENGTH) {
-	    xmlBufMemoryError(buf);
-	    return(0);
-	}
-    }
-
-    /* Don't resize if we don't have to */
-    if (size < buf->size)
-        return 1;
-
-    /* figure out new size */
-    switch (buf->alloc){
-	case XML_BUFFER_ALLOC_IO:
-	case XML_BUFFER_ALLOC_DOUBLEIT:
-	    /*take care of empty case*/
-            if (buf->size == 0) {
-                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
-            } else {
-                newSize = buf->size;
-            }
-	    while (size > newSize) {
-	        if (newSize > SIZE_MAX / 2) {
-	            xmlBufMemoryError(buf);
-	            return 0;
-	        }
-	        newSize *= 2;
-	    }
-	    break;
-	case XML_BUFFER_ALLOC_EXACT:
-            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
-	    break;
-        case XML_BUFFER_ALLOC_HYBRID:
-            if (buf->use < BASE_BUFFER_SIZE)
-                newSize = size;
-            else {
-                newSize = buf->size;
-                while (size > newSize) {
-                    if (newSize > SIZE_MAX / 2) {
-                        xmlBufMemoryError(buf);
-                        return 0;
-                    }
-                    newSize *= 2;
-                }
-            }
-            break;
-
-	default:
-            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
-	    break;
-    }
-
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        start_buf = buf->content - buf->contentIO;
-
-        if (start_buf > newSize) {
-	    /* move data back to start */
-	    memmove(buf->contentIO, buf->content, buf->use);
-	    buf->content = buf->contentIO;
-	    buf->content[buf->use] = 0;
-	    buf->size += start_buf;
-	} else {
-	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
-	    if (rebuf == NULL) {
-		xmlBufMemoryError(buf);
-		return 0;
-	    }
-	    buf->contentIO = rebuf;
-	    buf->content = rebuf + start_buf;
-	}
-    } else {
-	if (buf->content == NULL) {
-	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
-	    buf->use = 0;
-            if (rebuf != NULL)
-	        rebuf[buf->use] = 0;
-	} else if (buf->size - buf->use < 100) {
-	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
-        } else {
-	    /*
-	     * if we are reallocating a buffer far from being full, it's
-	     * better to make a new allocation and copy only the used range
-	     * and free the old one.
-	     */
-	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
-	    if (rebuf != NULL) {
-		memcpy(rebuf, buf->content, buf->use);
-		xmlFree(buf->content);
-		rebuf[buf->use] = 0;
-	    }
-	}
-	if (rebuf == NULL) {
-	    xmlBufMemoryError(buf);
-	    return 0;
-	}
-	buf->content = rebuf;
-    }
-    buf->size = newSize;
-    UPDATE_COMPAT(buf)
-
-    return 1;
-}
-
 /**
  * xmlBufAdd:
  * @buf:  the buffer to dump
@@ -754,55 +533,32 @@ xmlBufResize(xmlBufPtr buf, size_t size)
  * Returns 0 if successful, -1 in case of error.
  */
 int
-xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
-    size_t needSize;
-
-    if ((str == NULL) || (buf == NULL) || (buf->error))
-	return -1;
+xmlBufAdd(xmlBufPtr buf, const xmlChar *str, size_t len) {
+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))
+        return(-1);
+    if (len == 0)
+        return(0);
+    if (str == NULL)
+	return(-1);
     CHECK_COMPAT(buf)
 
-    if (len < -1) {
-	return -1;
-    }
-    if (len == 0) return 0;
-
-    if (len < 0)
-        len = xmlStrlen(str);
-
-    if (len < 0) return -1;
-    if (len == 0) return 0;
-
-    /* Note that both buf->size and buf->use can be zero here. */
-    if ((size_t) len >= buf->size - buf->use) {
-        if ((size_t) len >= SIZE_MAX - buf->use) {
-            xmlBufMemoryError(buf);
-            return(-1);
-        }
-        needSize = buf->use + len + 1;
-	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
-	    /*
-	     * Used to provide parsing limits
-	     */
-	    if (needSize >= XML_MAX_TEXT_LENGTH) {
-		xmlBufMemoryError(buf);
-		return(-1);
-	    }
-	}
-        if (!xmlBufResize(buf, needSize))
+    if (len > buf->size - buf->use) {
+        if (xmlBufGrowInternal(buf, len) < 0)
             return(-1);
     }
 
     memmove(&buf->content[buf->use], str, len);
     buf->use += len;
     buf->content[buf->use] = 0;
+
     UPDATE_COMPAT(buf)
-    return 0;
+    return(0);
 }
 
 /**
  * xmlBufCat:
  * @buf:  the buffer to add to
- * @str:  the #xmlChar string
+ * @str:  the #xmlChar string (optional)
  *
  * Append a zero terminated string to an XML buffer.
  *
@@ -811,11 +567,9 @@ xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  */
 int
 xmlBufCat(xmlBufPtr buf, const xmlChar *str) {
-    if ((buf == NULL) || (buf->error))
-        return(-1);
-    CHECK_COMPAT(buf)
-    if (str == NULL) return -1;
-    return xmlBufAdd(buf, str, -1);
+    if (str == NULL)
+        return(0);
+    return(xmlBufAdd(buf, str, strlen((const char *) str)));
 }
 
 /**
@@ -836,19 +590,32 @@ xmlBufFromBuffer(xmlBufferPtr buffer) {
     if (buffer == NULL)
         return(NULL);
 
-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
-    if (ret == NULL) {
+    ret = xmlMalloc(sizeof(xmlBuf));
+    if (ret == NULL)
         return(NULL);
-    }
+
     ret->use = buffer->use;
-    ret->size = buffer->size;
-    UPDATE_COMPAT(ret);
-    ret->error = 0;
-    ret->buffer = buffer;
-    ret->alloc = buffer->alloc;
-    ret->content = buffer->content;
-    ret->contentIO = buffer->contentIO;
+    ret->flags = 0;
+    ret->maxSize = SIZE_MAX - 1;
+
+    if (buffer->content == NULL) {
+        ret->size = 50;
+        ret->mem = xmlMalloc(ret->size + 1);
+        ret->content = ret->mem;
+        if (ret->mem == NULL)
+            xmlBufMemoryError(ret);
+        else
+            ret->content[0] = 0;
+    } else {
+        ret->size = buffer->size - 1;
+        ret->content = buffer->content;
+        if (buffer->alloc == XML_BUFFER_ALLOC_IO)
+            ret->mem = buffer->contentIO;
+        else
+            ret->mem = buffer->content;
+    }
 
+    UPDATE_COMPAT(ret);
     return(ret);
 }
 
@@ -864,57 +631,33 @@ xmlBufFromBuffer(xmlBufferPtr buffer) {
  *
  * Returns the old xmlBufferPtr unless the call failed and NULL is returned
  */
-xmlBufferPtr
-xmlBufBackToBuffer(xmlBufPtr buf) {
-    xmlBufferPtr ret;
-
-    if (buf == NULL)
-        return(NULL);
-    CHECK_COMPAT(buf)
-    ret = buf->buffer;
+int
+xmlBufBackToBuffer(xmlBufPtr buf, xmlBufferPtr ret) {
+    if ((buf == NULL) || (ret == NULL))
+        return(-1);
 
-    if ((buf->error) || (ret == NULL)) {
+    if ((BUF_ERROR(buf)) || (BUF_STATIC(buf)) ||
+        (buf->use >= INT_MAX)) {
         xmlBufFree(buf);
-        if (ret != NULL) {
-            ret->content = NULL;
-            ret->contentIO = NULL;
-            ret->use = 0;
-            ret->size = 0;
-        }
-        return(NULL);
+        ret->content = NULL;
+        ret->contentIO = NULL;
+        ret->use = 0;
+        ret->size = 0;
+        return(-1);
     }
 
-    /*
-     * What to do in case of error in the buffer ???
-     */
-    if (buf->use > INT_MAX) {
-        /*
-         * Worse case, we really allocated and used more than the
-         * maximum allowed memory for an xmlBuffer on this architecture.
-         * Keep the buffer but provide a truncated size value.
-         */
-        xmlBufOverflowError(buf);
-        ret->use = INT_MAX;
-        ret->size = INT_MAX;
-    } else if (buf->size > INT_MAX) {
-        /*
-         * milder case, we allocated more than the maximum allowed memory
-         * for an xmlBuffer on this architecture, but used less than the
-         * limit.
-         * Keep the buffer but provide a truncated size value.
-         */
-        xmlBufOverflowError(buf);
-        ret->use = buf->use;
+    ret->use = buf->use;
+    if (buf->size >= INT_MAX) {
+        /* Keep the buffer but provide a truncated size value. */
         ret->size = INT_MAX;
     } else {
-        ret->use = buf->use;
-        ret->size = buf->size;
+        ret->size = buf->size + 1;
     }
-    ret->alloc = buf->alloc;
+    ret->alloc = XML_BUFFER_ALLOC_IO;
     ret->content = buf->content;
-    ret->contentIO = buf->contentIO;
+    ret->contentIO = buf->mem;
     xmlFree(buf);
-    return(ret);
+    return(0);
 }
 
 /**
@@ -953,3 +696,580 @@ xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
     return(0);
 }
 
+/************************************************************************
+ *									*
+ *			Old buffer implementation			*
+ *									*
+ ************************************************************************/
+
+/**
+ * xmlSetBufferAllocationScheme:
+ * @scheme:  allocation method to use
+ *
+ * DEPRECATED: Use xmlBufferSetAllocationScheme.
+ *
+ * Set the buffer allocation method.  Types are
+ * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
+ * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,
+ *                             improves performance
+ */
+void
+xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme ATTRIBUTE_UNUSED) {
+}
+
+/**
+ * xmlGetBufferAllocationScheme:
+ *
+ * DEPRECATED: Use xmlBufferSetAllocationScheme.
+ *
+ * Types are
+ * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
+ * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,
+ *                             improves performance
+ * XML_BUFFER_ALLOC_HYBRID - use exact sizes on small strings to keep memory usage tight
+ *                            in normal usage, and doubleit on large strings to avoid
+ *                            pathological performance.
+ *
+ * Returns the current allocation scheme
+ */
+xmlBufferAllocationScheme
+xmlGetBufferAllocationScheme(void) {
+    return(XML_BUFFER_ALLOC_EXACT);
+}
+
+/**
+ * xmlBufferCreate:
+ *
+ * routine to create an XML buffer.
+ * returns the new structure.
+ */
+xmlBufferPtr
+xmlBufferCreate(void) {
+    xmlBufferPtr ret;
+
+    ret = xmlMalloc(sizeof(*ret));
+    if (ret == NULL)
+        return(NULL);
+
+    ret->use = 0;
+    ret->size = 256;
+    ret->alloc = XML_BUFFER_ALLOC_IO;
+    ret->contentIO = xmlMalloc(ret->size);
+    if (ret->contentIO == NULL) {
+	xmlFree(ret);
+        return(NULL);
+    }
+    ret->content = ret->contentIO;
+    ret->content[0] = 0;
+
+    return(ret);
+}
+
+/**
+ * xmlBufferCreateSize:
+ * @size: initial size of buffer
+ *
+ * routine to create an XML buffer.
+ * returns the new structure.
+ */
+xmlBufferPtr
+xmlBufferCreateSize(size_t size) {
+    xmlBufferPtr ret;
+
+    if (size >= INT_MAX)
+        return(NULL);
+
+    ret = xmlMalloc(sizeof(*ret));
+    if (ret == NULL)
+        return(NULL);
+
+    ret->use = 0;
+    ret->alloc = XML_BUFFER_ALLOC_IO;
+    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
+
+    if (ret->size) {
+        ret->contentIO = xmlMalloc(ret->size);
+        if (ret->contentIO == NULL) {
+            xmlFree(ret);
+            return(NULL);
+        }
+        ret->content = ret->contentIO;
+        ret->content[0] = 0;
+    } else {
+        ret->contentIO = NULL;
+	ret->content = NULL;
+    }
+
+    return(ret);
+}
+
+/**
+ * xmlBufferDetach:
+ * @buf:  the buffer
+ *
+ * Remove the string contained in a buffer and gie it back to the
+ * caller. The buffer is reset to an empty content.
+ * This doesn't work with immutable buffers as they can't be reset.
+ *
+ * Returns the previous string contained by the buffer.
+ */
+xmlChar *
+xmlBufferDetach(xmlBufferPtr buf) {
+    xmlChar *ret;
+
+    if (buf == NULL)
+        return(NULL);
+
+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
+        (buf->content != buf->contentIO)) {
+        ret = xmlStrndup(buf->content, buf->use);
+        xmlFree(buf->contentIO);
+    } else {
+        ret = buf->content;
+    }
+
+    buf->contentIO = NULL;
+    buf->content = NULL;
+    buf->size = 0;
+    buf->use = 0;
+
+    return ret;
+}
+
+/**
+ * xmlBufferCreateStatic:
+ * @mem: the memory area
+ * @size:  the size in byte
+ *
+ * Returns an XML buffer initialized with bytes.
+ */
+xmlBufferPtr
+xmlBufferCreateStatic(void *mem, size_t size) {
+    xmlBufferPtr buf = xmlBufferCreateSize(size);
+
+    xmlBufferAdd(buf, mem, size);
+    return(buf);
+}
+
+/**
+ * xmlBufferSetAllocationScheme:
+ * @buf:  the buffer to tune
+ * @scheme:  allocation scheme to use
+ *
+ * Sets the allocation scheme for this buffer.
+ *
+ * For libxml2 before 2.14, it is recommended to set this to
+ * XML_BUFFER_ALLOC_DOUBLE_IT. Has no effect on 2.14 or later.
+ */
+void
+xmlBufferSetAllocationScheme(xmlBufferPtr buf ATTRIBUTE_UNUSED,
+                             xmlBufferAllocationScheme scheme ATTRIBUTE_UNUSED) {
+}
+
+/**
+ * xmlBufferFree:
+ * @buf:  the buffer to free
+ *
+ * Frees an XML buffer. It frees both the content and the structure which
+ * encapsulate it.
+ */
+void
+xmlBufferFree(xmlBufferPtr buf) {
+    if (buf == NULL)
+	return;
+
+    if (buf->alloc == XML_BUFFER_ALLOC_IO)
+        xmlFree(buf->contentIO);
+    else
+        xmlFree(buf->content);
+
+    xmlFree(buf);
+}
+
+/**
+ * xmlBufferEmpty:
+ * @buf:  the buffer
+ *
+ * empty a buffer.
+ */
+void
+xmlBufferEmpty(xmlBufferPtr buf) {
+    if (buf == NULL)
+        return;
+    if (buf->content == NULL)
+        return;
+
+    buf->use = 0;
+
+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {
+	buf->size += buf->content - buf->contentIO;
+        buf->content = buf->contentIO;
+        buf->content[0] = 0;
+    } else {
+        buf->content[0] = 0;
+    }
+}
+
+/**
+ * xmlBufferShrink:
+ * @buf:  the buffer to dump
+ * @len:  the number of xmlChar to remove
+ *
+ * DEPRECATED: Don't use.
+ *
+ * Remove the beginning of an XML buffer.
+ *
+ * Returns the number of #xmlChar removed, or -1 in case of failure.
+ */
+int
+xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {
+    if (buf == NULL)
+        return(-1);
+    if (len == 0)
+        return(0);
+    if (len > buf->use)
+        return(-1);
+
+    buf->use -= len;
+
+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {
+        buf->content += len;
+	buf->size -= len;
+    } else {
+	memmove(buf->content, &buf->content[len], buf->use + 1);
+    }
+
+    return(len);
+}
+
+/**
+ * xmlBufferGrow:
+ * @buf:  the buffer
+ * @len:  the minimum free size to allocate
+ *
+ * DEPRECATED: Don't use.
+ *
+ * Grow the available space of an XML buffer.
+ *
+ * Returns the new available space or -1 in case of error
+ */
+int
+xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {
+    unsigned int size;
+    xmlChar *newbuf;
+
+    if (buf == NULL)
+        return(-1);
+
+    if (len < buf->size - buf->use)
+        return(0);
+    if (len >= INT_MAX - buf->use)
+        return(-1);
+
+    if (buf->size > (size_t) len) {
+        if (buf->size <= INT_MAX / 2)
+            size = buf->size * 2;
+        else
+            size = INT_MAX;
+    } else {
+        size = buf->use + len + 1;
+        if (size <= INT_MAX - 100)
+            size += 100;
+    }
+
+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
+        (buf->content != buf->contentIO)) {
+        newbuf = xmlMalloc(size);
+        if (newbuf == NULL)
+            return(-1);
+        if (buf->content != NULL)
+            memcpy(newbuf, buf->content, buf->use + 1);
+        xmlFree(buf->contentIO);
+    } else {
+        newbuf = xmlRealloc(buf->content, size);
+        if (newbuf == NULL)
+            return(-1);
+    }
+
+    if (buf->alloc == XML_BUFFER_ALLOC_IO)
+        buf->contentIO = newbuf;
+    buf->content = newbuf;
+    buf->size = size;
+
+    return(buf->size - buf->use - 1);
+}
+
+/**
+ * xmlBufferDump:
+ * @file:  the file output
+ * @buf:  the buffer to dump
+ *
+ * Dumps an XML buffer to  a FILE *.
+ * Returns the number of #xmlChar written
+ */
+int
+xmlBufferDump(FILE *file, xmlBufferPtr buf) {
+    size_t ret;
+
+    if (buf == NULL)
+	return(0);
+    if (buf->content == NULL)
+	return(0);
+    if (file == NULL)
+	file = stdout;
+    ret = fwrite(buf->content, 1, buf->use, file);
+    return(ret > INT_MAX ? INT_MAX : ret);
+}
+
+/**
+ * xmlBufferContent:
+ * @buf:  the buffer
+ *
+ * Function to extract the content of a buffer
+ *
+ * Returns the internal content
+ */
+
+const xmlChar *
+xmlBufferContent(const xmlBuffer *buf)
+{
+    if(!buf)
+        return NULL;
+
+    return buf->content;
+}
+
+/**
+ * xmlBufferLength:
+ * @buf:  the buffer
+ *
+ * Function to get the length of a buffer
+ *
+ * Returns the length of data in the internal content
+ */
+
+int
+xmlBufferLength(const xmlBuffer *buf)
+{
+    if(!buf)
+        return 0;
+
+    return buf->use;
+}
+
+/**
+ * xmlBufferResize:
+ * @buf:  the buffer to resize
+ * @size:  the desired size
+ *
+ * DEPRECATED: Don't use.
+
+ * Resize a buffer to accommodate minimum size of @size.
+ *
+ * Returns  0 in case of problems, 1 otherwise
+ */
+int
+xmlBufferResize(xmlBufferPtr buf, unsigned int size)
+{
+    int res;
+
+    if (buf == NULL)
+        return(0);
+    if (size < buf->size)
+        return(1);
+    res = xmlBufferGrow(buf, size - buf->use);
+
+    return(res < 0 ? 0 : 1);
+}
+
+/**
+ * xmlBufferAdd:
+ * @buf:  the buffer to dump
+ * @str:  the #xmlChar string
+ * @len:  the number of #xmlChar to add
+ *
+ * Add a string range to an XML buffer. if len == -1, the length of
+ * str is recomputed.
+ *
+ * Returns a xmlParserError code.
+ */
+int
+xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {
+    if ((buf == NULL) || (str == NULL))
+	return(XML_ERR_ARGUMENT);
+    if (len < 0)
+        len = xmlStrlen(str);
+    if (len == 0)
+        return(XML_ERR_OK);
+
+    /* Note that both buf->size and buf->use can be zero here. */
+    if ((unsigned) len >= buf->size - buf->use) {
+        if (xmlBufferGrow(buf, len) < 0)
+            return(XML_ERR_NO_MEMORY);
+    }
+
+    memmove(&buf->content[buf->use], str, len);
+    buf->use += len;
+    buf->content[buf->use] = 0;
+    return(XML_ERR_OK);
+}
+
+/**
+ * xmlBufferAddHead:
+ * @buf:  the buffer
+ * @str:  the #xmlChar string
+ * @len:  the number of #xmlChar to add
+ *
+ * Add a string range to the beginning of an XML buffer.
+ * if len == -1, the length of @str is recomputed.
+ *
+ * Returns a xmlParserError code.
+ */
+int
+xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {
+    unsigned start = 0;
+
+    if ((buf == NULL) || (str == NULL))
+	return(XML_ERR_ARGUMENT);
+    if (len < 0)
+        len = xmlStrlen(str);
+    if (len == 0)
+        return(XML_ERR_OK);
+
+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {
+        start = buf->content - buf->contentIO;
+
+        /*
+         * We can add it in the space previously shrunk
+         */
+        if ((unsigned) len <= start) {
+            buf->content -= len;
+            memmove(&buf->content[0], str, len);
+            buf->use += len;
+            buf->size += len;
+            return(0);
+        }
+        if ((unsigned) len < buf->size + start - buf->use) {
+            memmove(&buf->contentIO[len], buf->content, buf->use + 1);
+            memmove(buf->contentIO, str, len);
+            buf->content = buf->contentIO;
+            buf->use += len;
+            buf->size += start;
+            return(0);
+        }
+    }
+
+    if ((unsigned) len >= buf->size - buf->use) {
+        if (xmlBufferGrow(buf, len) < 0)
+            return(-1);
+    }
+
+    memmove(&buf->content[len], buf->content, buf->use + 1);
+    memmove(buf->content, str, len);
+    buf->use += len;
+    return (0);
+}
+
+/**
+ * xmlBufferCat:
+ * @buf:  the buffer to add to
+ * @str:  the #xmlChar string
+ *
+ * Append a zero terminated string to an XML buffer.
+ *
+ * Returns 0 successful, a positive error code number otherwise
+ *         and -1 in case of internal or API error.
+ */
+int
+xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {
+    return(xmlBufferAdd(buf, str, -1));
+}
+
+/**
+ * xmlBufferCCat:
+ * @buf:  the buffer to dump
+ * @str:  the C char string
+ *
+ * Append a zero terminated C string to an XML buffer.
+ *
+ * Returns 0 successful, a positive error code number otherwise
+ *         and -1 in case of internal or API error.
+ */
+int
+xmlBufferCCat(xmlBufferPtr buf, const char *str) {
+    return(xmlBufferAdd(buf, (const xmlChar *) str, -1));
+}
+
+/**
+ * xmlBufferWriteCHAR:
+ * @buf:  the XML buffer
+ * @string:  the string to add
+ *
+ * routine which manages and grows an output buffer. This one adds
+ * xmlChars at the end of the buffer.
+ */
+void
+xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {
+    xmlBufferAdd(buf, string, -1);
+}
+
+/**
+ * xmlBufferWriteChar:
+ * @buf:  the XML buffer output
+ * @string:  the string to add
+ *
+ * routine which manage and grows an output buffer. This one add
+ * C chars at the end of the array.
+ */
+void
+xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {
+    xmlBufferAdd(buf, (const xmlChar *) string, -1);
+}
+
+
+/**
+ * xmlBufferWriteQuotedString:
+ * @buf:  the XML buffer output
+ * @string:  the string to add
+ *
+ * routine which manage and grows an output buffer. This one writes
+ * a quoted or double quoted #xmlChar string, checking first if it holds
+ * quote or double-quotes internally
+ */
+void
+xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {
+    const xmlChar *cur, *base;
+    if (buf == NULL)
+        return;
+    if (xmlStrchr(string, '\"')) {
+        if (xmlStrchr(string, '\'')) {
+	    xmlBufferCCat(buf, "\"");
+            base = cur = string;
+            while(*cur != 0){
+                if(*cur == '"'){
+                    if (base != cur)
+                        xmlBufferAdd(buf, base, cur - base);
+                    xmlBufferAdd(buf, BAD_CAST "&quot;", 6);
+                    cur++;
+                    base = cur;
+                }
+                else {
+                    cur++;
+                }
+            }
+            if (base != cur)
+                xmlBufferAdd(buf, base, cur - base);
+	    xmlBufferCCat(buf, "\"");
+	}
+        else{
+	    xmlBufferCCat(buf, "\'");
+            xmlBufferCat(buf, string);
+	    xmlBufferCCat(buf, "\'");
+        }
+    } else {
+        xmlBufferCCat(buf, "\"");
+        xmlBufferCat(buf, string);
+        xmlBufferCCat(buf, "\"");
+    }
+}
+
diff --git a/c14n.c b/c14n.c
index c73feb48..5e0eed3f 100644
--- a/c14n.c
+++ b/c14n.c
@@ -2133,7 +2133,7 @@ xmlC11NNormalizeString(const xmlChar * input,
      * allocate an translation buffer.
      */
     buffer_size = 1000;
-    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL)
         return (NULL);
     out = buffer;
diff --git a/catalog.c b/catalog.c
index ef0eef57..80621768 100644
--- a/catalog.c
+++ b/catalog.c
@@ -19,17 +19,16 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#elif defined (_WIN32)
-#include <io.h>
-#endif
-#ifdef HAVE_FCNTL_H
+
 #include <fcntl.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+  #include <io.h>
+#else
+  #include <unistd.h>
 #endif
+
 #include <libxml/xmlmemory.h>
 #include <libxml/hash.h>
 #include <libxml/uri.h>
@@ -38,8 +37,10 @@
 #include <libxml/xmlerror.h>
 #include <libxml/threads.h>
 
+#include "private/cata.h"
 #include "private/buf.h"
 #include "private/error.h"
+#include "private/threads.h"
 
 #define MAX_DELEGATE	50
 #define MAX_CATAL_DEPTH	50
@@ -59,6 +60,9 @@
 #define XML_SGML_DEFAULT_CATALOG "file://" SYSCONFDIR "/sgml/catalog"
 #endif
 
+static xmlChar *xmlCatalogNormalizePublic(const xmlChar *pubID);
+static int xmlExpandCatalog(xmlCatalogPtr catal, const char *filename);
+
 /************************************************************************
  *									*
  *			Types, all private				*
@@ -166,28 +170,13 @@ static xmlCatalogPtr xmlDefaultCatalog = NULL;
  * It also protects xmlCatalogXMLFiles
  * The core of this readers/writer scheme is in xmlFetchXMLCatalogFile()
  */
-static xmlRMutexPtr xmlCatalogMutex = NULL;
+static xmlRMutex xmlCatalogMutex;
 
 /*
- * Whether the catalog support was initialized.
+ * Whether the default system catalog was initialized.
  */
 static int xmlCatalogInitialized = 0;
 
-/************************************************************************
- *									*
- *			Forward declarations				*
- *									*
- ************************************************************************/
-
-static xmlChar *
-xmlCatalogNormalizePublic(const xmlChar *pubID);
-
-static int
-xmlExpandCatalog(xmlCatalogPtr catal, const char *filename);
-
-static int
-xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal);
-
 /************************************************************************
  *									*
  *			Catalog error handlers				*
@@ -222,15 +211,23 @@ xmlCatalogErr(xmlCatalogEntryPtr catal, xmlNodePtr node, int error,
 {
     int res;
 
-    res = __xmlRaiseError(NULL, NULL, NULL, catal, node,
-                          XML_FROM_CATALOG, error, XML_ERR_ERROR, NULL, 0,
-                          (const char *) str1, (const char *) str2,
-                          (const char *) str3, 0, 0,
-                          msg, str1, str2, str3);
+    res = xmlRaiseError(NULL, NULL, NULL, catal, node,
+                        XML_FROM_CATALOG, error, XML_ERR_ERROR, NULL, 0,
+                        (const char *) str1, (const char *) str2,
+                        (const char *) str3, 0, 0,
+                        msg, str1, str2, str3);
     if (res < 0)
         xmlCatalogErrMemory();
 }
 
+static void
+xmlCatalogPrintDebug(const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    xmlVPrintErrorMessage(fmt, ap);
+    va_end(ap);
+}
 
 /************************************************************************
  *									*
@@ -318,13 +315,13 @@ xmlFreeCatalogEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
 
     if (xmlDebugCatalogs) {
 	if (ret->name != NULL)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Free catalog entry %s\n", ret->name);
 	else if (ret->value != NULL)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Free catalog entry %s\n", ret->value);
 	else
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Free catalog entry\n");
     }
 
@@ -538,9 +535,6 @@ static void xmlDumpXMLCatalogNode(xmlCatalogEntryPtr catal, xmlNodePtr catalog,
 	        case XML_CATA_BROKEN_CATALOG:
 	        case XML_CATA_CATALOG:
 		    if (cur == catal) {
-                        if (cur->children == NULL) {
-                            xmlFetchXMLCatalogFile(cur);
-                        }
 			cur = cur->children;
 		        continue;
 		    }
@@ -785,7 +779,7 @@ xmlConvertSGMLCatalog(xmlCatalogPtr catal) {
 	return(-1);
 
     if (xmlDebugCatalogs) {
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Converting SGML catalog to XML\n");
     }
     xmlHashScan(catal->sgml, xmlCatalogConvertEntry, &catal);
@@ -903,7 +897,11 @@ xmlParseCatalogFile(const char *filename) {
     inputStream->buf = buf;
     xmlBufResetInput(buf->buffer, inputStream);
 
-    inputPush(ctxt, inputStream);
+    if (inputPush(ctxt, inputStream) < 0) {
+        xmlFreeInputStream(inputStream);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     ctxt->valid = 0;
     ctxt->validate = 0;
@@ -936,60 +934,33 @@ xmlParseCatalogFile(const char *filename) {
 static xmlChar *
 xmlLoadFileContent(const char *filename)
 {
-#ifdef HAVE_STAT
     int fd;
-#else
-    FILE *fd;
-#endif
     int len;
     long size;
 
-#ifdef HAVE_STAT
     struct stat info;
-#endif
     xmlChar *content;
 
     if (filename == NULL)
         return (NULL);
 
-#ifdef HAVE_STAT
     if (stat(filename, &info) < 0)
         return (NULL);
-#endif
 
-#ifdef HAVE_STAT
-    if ((fd = open(filename, O_RDONLY)) < 0)
-#else
-    if ((fd = fopen(filename, "rb")) == NULL)
-#endif
+    fd = open(filename, O_RDONLY);
+    if (fd  < 0)
     {
         return (NULL);
     }
-#ifdef HAVE_STAT
     size = info.st_size;
-#else
-    if (fseek(fd, 0, SEEK_END) || (size = ftell(fd)) == EOF || fseek(fd, 0, SEEK_SET)) {        /* File operations denied? ok, just close and return failure */
-        fclose(fd);
-        return (NULL);
-    }
-#endif
-    content = (xmlChar*)xmlMallocAtomic(size + 10);
+    content = xmlMalloc(size + 10);
     if (content == NULL) {
         xmlCatalogErrMemory();
-#ifdef HAVE_STAT
 	close(fd);
-#else
-	fclose(fd);
-#endif
         return (NULL);
     }
-#ifdef HAVE_STAT
     len = read(fd, content, size);
     close(fd);
-#else
-    len = fread(content, 1, size, fd);
-    fclose(fd);
-#endif
     if (len < 0) {
         xmlFree(content);
         return (NULL);
@@ -1160,10 +1131,10 @@ xmlParseXMLCatalogOneNode(xmlNodePtr cur, xmlCatalogEntryType type,
     if (URL != NULL) {
 	if (xmlDebugCatalogs > 1) {
 	    if (nameValue != NULL)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Found %s: '%s' '%s'\n", name, nameValue, URL);
 	    else
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Found %s: '%s'\n", name, URL);
 	}
 	ret = xmlNewCatalogEntry(type, nameValue, uriValue, URL, prefer, cgroup);
@@ -1332,13 +1303,13 @@ xmlParseXMLCatalogFile(xmlCatalogPrefer prefer, const xmlChar *filename) {
     doc = xmlParseCatalogFile((const char *) filename);
     if (doc == NULL) {
 	if (xmlDebugCatalogs)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Failed to parse catalog %s\n", filename);
 	return(NULL);
     }
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"%d Parsing catalog %s\n", xmlGetThreadId(), filename);
 
     cur = xmlDocGetRootElement(doc);
@@ -1399,10 +1370,10 @@ xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {
     /*
      * lock the whole catalog for modification
      */
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
     if (catal->children != NULL) {
 	/* Okay someone else did it in the meantime */
-	xmlRMutexUnlock(xmlCatalogMutex);
+	xmlRMutexUnlock(&xmlCatalogMutex);
 	return(0);
     }
 
@@ -1411,7 +1382,7 @@ xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {
 	    xmlHashLookup(xmlCatalogXMLFiles, catal->URL);
 	if (doc != NULL) {
 	    if (xmlDebugCatalogs)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 		    "Found %s in file hash\n", catal->URL);
 
 	    if (catal->type == XML_CATA_CATALOG)
@@ -1419,11 +1390,11 @@ xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {
 	    else
 		catal->children = doc;
 	    catal->dealloc = 0;
-	    xmlRMutexUnlock(xmlCatalogMutex);
+	    xmlRMutexUnlock(&xmlCatalogMutex);
 	    return(0);
 	}
 	if (xmlDebugCatalogs)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		"%s not found in file hash\n", catal->URL);
     }
 
@@ -1435,7 +1406,7 @@ xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {
     doc = xmlParseXMLCatalogFile(catal->prefer, catal->URL);
     if (doc == NULL) {
 	catal->type = XML_CATA_BROKEN_CATALOG;
-	xmlRMutexUnlock(xmlCatalogMutex);
+	xmlRMutexUnlock(&xmlCatalogMutex);
 	return(-1);
     }
 
@@ -1450,11 +1421,11 @@ xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {
 	xmlCatalogXMLFiles = xmlHashCreate(10);
     if (xmlCatalogXMLFiles != NULL) {
 	if (xmlDebugCatalogs)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		"%s added to file hash\n", catal->URL);
 	xmlHashAddEntry(xmlCatalogXMLFiles, catal->URL, doc);
     }
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
     return(0);
 }
 
@@ -1496,7 +1467,7 @@ xmlAddXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *type,
     typ = xmlGetXMLCatalogEntryType(type);
     if (typ == XML_CATA_NONE) {
 	if (xmlDebugCatalogs)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Failed to add unknown element %s to catalog\n", type);
 	return(-1);
     }
@@ -1510,7 +1481,7 @@ xmlAddXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *type,
 	    if ((orig != NULL) && (cur->type == typ) &&
 		(xmlStrEqual(orig, cur->name))) {
 		if (xmlDebugCatalogs)
-		    fprintf(stderr,
+		    xmlCatalogPrintDebug(
 			    "Updating element %s to catalog\n", type);
 		if (cur->value != NULL)
 		    xmlFree(cur->value);
@@ -1526,7 +1497,7 @@ xmlAddXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *type,
 	}
     }
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Adding element %s to catalog\n", type);
     if (cur == NULL)
 	catal->children = xmlNewCatalogEntry(typ, orig, replace,
@@ -1578,10 +1549,10 @@ xmlDelXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *value) {
 	    (xmlStrEqual(value, cur->value))) {
 	    if (xmlDebugCatalogs) {
 		if (cur->name != NULL)
-		    fprintf(stderr,
+		    xmlCatalogPrintDebug(
 			    "Removing element %s from catalog\n", cur->name);
 		else
-		    fprintf(stderr,
+		    xmlCatalogPrintDebug(
 			    "Removing element %s from catalog\n", cur->value);
 	    }
 	    cur->type = XML_CATA_REMOVED;
@@ -1637,7 +1608,7 @@ xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 		case XML_CATA_SYSTEM:
 		    if (xmlStrEqual(sysID, cur->name)) {
 			if (xmlDebugCatalogs)
-			    fprintf(stderr,
+			    xmlCatalogPrintDebug(
 				    "Found system match %s, using %s\n",
 				            cur->name, cur->URL);
 			catal->depth--;
@@ -1666,7 +1637,7 @@ xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 	}
 	if (rewrite != NULL) {
 	    if (xmlDebugCatalogs)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Using rewriting rule %s\n", rewrite->name);
 	    ret = xmlStrdup(rewrite->URL);
 	    if (ret != NULL)
@@ -1701,7 +1672,7 @@ xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 		    }
 		    if (cur->children != NULL) {
 			if (xmlDebugCatalogs)
-			    fprintf(stderr,
+			    xmlCatalogPrintDebug(
 				    "Trying system delegate %s\n", cur->URL);
 			ret = xmlCatalogListXMLResolve(
 				cur->children, NULL, sysID);
@@ -1731,7 +1702,7 @@ xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 		case XML_CATA_PUBLIC:
 		    if (xmlStrEqual(pubID, cur->name)) {
 			if (xmlDebugCatalogs)
-			    fprintf(stderr,
+			    xmlCatalogPrintDebug(
 				    "Found public match %s\n", cur->name);
 			catal->depth--;
 			return(xmlStrdup(cur->URL));
@@ -1780,7 +1751,7 @@ xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 		    }
 		    if (cur->children != NULL) {
 			if (xmlDebugCatalogs)
-			    fprintf(stderr,
+			    xmlCatalogPrintDebug(
 				    "Trying public delegate %s\n", cur->URL);
 			ret = xmlCatalogListXMLResolve(
 				cur->children, pubID, NULL);
@@ -1870,7 +1841,7 @@ xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {
 	    case XML_CATA_URI:
 		if (xmlStrEqual(URI, cur->name)) {
 		    if (xmlDebugCatalogs)
-			fprintf(stderr,
+			xmlCatalogPrintDebug(
 				"Found URI match %s\n", cur->name);
 		    return(xmlStrdup(cur->URL));
 		}
@@ -1897,7 +1868,7 @@ xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {
     }
     if (rewrite != NULL) {
 	if (xmlDebugCatalogs)
-	    fprintf(stderr,
+	    xmlCatalogPrintDebug(
 		    "Using rewriting rule %s\n", rewrite->name);
 	ret = xmlStrdup(rewrite->URL);
 	if (ret != NULL)
@@ -1932,7 +1903,7 @@ xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {
 		}
 		if (cur->children != NULL) {
 		    if (xmlDebugCatalogs)
-			fprintf(stderr,
+			xmlCatalogPrintDebug(
 				"Trying URI delegate %s\n", cur->URL);
 		    ret = xmlCatalogListXMLResolveURI(
 			    cur->children, URI);
@@ -2001,10 +1972,10 @@ xmlCatalogListXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 	urnID = xmlCatalogUnWrapURN(pubID);
 	if (xmlDebugCatalogs) {
 	    if (urnID == NULL)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Public URN ID %s expanded to NULL\n", pubID);
 	    else
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Public URN ID expanded to %s\n", urnID);
 	}
 	ret = xmlCatalogListXMLResolve(catal, urnID, sysID);
@@ -2018,10 +1989,10 @@ xmlCatalogListXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 	urnID = xmlCatalogUnWrapURN(sysID);
 	if (xmlDebugCatalogs) {
 	    if (urnID == NULL)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"System URN ID %s expanded to NULL\n", sysID);
 	    else
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"System URN ID expanded to %s\n", urnID);
 	}
 	if (pubID == NULL)
@@ -2085,10 +2056,10 @@ xmlCatalogListXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {
 	urnID = xmlCatalogUnWrapURN(URI);
 	if (xmlDebugCatalogs) {
 	    if (urnID == NULL)
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"URN ID %s expanded to NULL\n", URI);
 	    else
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"URN ID expanded to %s\n", urnID);
 	}
 	ret = xmlCatalogListXMLResolve(catal, urnID, NULL);
@@ -2173,7 +2144,7 @@ xmlParseSGMLCatalogPubid(const xmlChar *cur, xmlChar **id) {
     } else {
 	stop = ' ';
     }
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
         xmlCatalogErrMemory();
 	return(NULL);
@@ -2767,7 +2738,7 @@ xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID) {
 	return(NULL);
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Resolve sysID %s\n", sysID);
 
     if (catal->type == XML_XML_CATALOG_TYPE) {
@@ -2802,7 +2773,7 @@ xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID) {
 	return(NULL);
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Resolve pubID %s\n", pubID);
 
     if (catal->type == XML_XML_CATALOG_TYPE) {
@@ -2841,13 +2812,13 @@ xmlACatalogResolve(xmlCatalogPtr catal, const xmlChar * pubID,
 
     if (xmlDebugCatalogs) {
          if ((pubID != NULL) && (sysID != NULL)) {
-             fprintf(stderr,
+             xmlCatalogPrintDebug(
                              "Resolve: pubID %s sysID %s\n", pubID, sysID);
          } else if (pubID != NULL) {
-             fprintf(stderr,
+             xmlCatalogPrintDebug(
                              "Resolve: pubID %s\n", pubID);
          } else {
-             fprintf(stderr,
+             xmlCatalogPrintDebug(
                              "Resolve: sysID %s\n", sysID);
          }
     }
@@ -2884,7 +2855,7 @@ xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI) {
 	return(NULL);
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Resolve URI %s\n", URI);
 
     if (catal->type == XML_XML_CATALOG_TYPE) {
@@ -3056,41 +3027,31 @@ xmlCatalogIsEmpty(xmlCatalogPtr catal) {
  ************************************************************************/
 
 /**
- * xmlInitializeCatalogData:
+ * xmlInitCatalogInternal:
  *
  * Do the catalog initialization only of global data, doesn't try to load
  * any catalog actually.
- * this function is not thread safe, catalog initialization should
- * preferably be done once at startup
  */
-static void
-xmlInitializeCatalogData(void) {
-    if (xmlCatalogInitialized != 0)
-	return;
-
+void
+xmlInitCatalogInternal(void) {
     if (getenv("XML_DEBUG_CATALOG"))
 	xmlDebugCatalogs = 1;
-    xmlCatalogMutex = xmlNewRMutex();
-
-    xmlCatalogInitialized = 1;
+    xmlInitRMutex(&xmlCatalogMutex);
 }
+
 /**
  * xmlInitializeCatalog:
  *
- * Do the catalog initialization.
- * this function is not thread safe, catalog initialization should
- * preferably be done once at startup
+ * Load the default system catalog.
  */
 void
 xmlInitializeCatalog(void) {
     if (xmlCatalogInitialized != 0)
 	return;
 
-    xmlInitializeCatalogData();
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlInitParser();
 
-    if (getenv("XML_DEBUG_CATALOG"))
-	xmlDebugCatalogs = 1;
+    xmlRMutexLock(&xmlCatalogMutex);
 
     if (xmlDefaultCatalog == NULL) {
 	const char *catalogs;
@@ -3131,7 +3092,9 @@ xmlInitializeCatalog(void) {
 	}
     }
 
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
+
+    xmlCatalogInitialized = 1;
 }
 
 
@@ -3152,25 +3115,25 @@ xmlLoadCatalog(const char *filename)
     int ret;
     xmlCatalogPtr catal;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalogData();
+    xmlInitParser();
 
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
 
     if (xmlDefaultCatalog == NULL) {
 	catal = xmlLoadACatalog(filename);
 	if (catal == NULL) {
-	    xmlRMutexUnlock(xmlCatalogMutex);
+	    xmlRMutexUnlock(&xmlCatalogMutex);
 	    return(-1);
 	}
 
 	xmlDefaultCatalog = catal;
-	xmlRMutexUnlock(xmlCatalogMutex);
+	xmlRMutexUnlock(&xmlCatalogMutex);
+        xmlCatalogInitialized = 1;
 	return(0);
     }
 
     ret = xmlExpandCatalog(xmlDefaultCatalog, filename);
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
     return(ret);
 }
 
@@ -3228,12 +3191,9 @@ xmlLoadCatalogs(const char *pathss) {
  */
 void
 xmlCatalogCleanup(void) {
-    if (xmlCatalogInitialized == 0)
-        return;
-
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Catalogs cleanup\n");
     if (xmlCatalogXMLFiles != NULL)
 	xmlHashFree(xmlCatalogXMLFiles, xmlFreeCatalogHashEntryList);
@@ -3243,8 +3203,17 @@ xmlCatalogCleanup(void) {
     xmlDefaultCatalog = NULL;
     xmlDebugCatalogs = 0;
     xmlCatalogInitialized = 0;
-    xmlRMutexUnlock(xmlCatalogMutex);
-    xmlFreeRMutex(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
+}
+
+/**
+ * xmlCleanupCatalogInternal:
+ *
+ * Free global data.
+ */
+void
+xmlCleanupCatalogInternal(void) {
+    xmlCleanupRMutex(&xmlCatalogMutex);
 }
 
 /**
@@ -3364,10 +3333,9 @@ int
 xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace) {
     int res = -1;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalogData();
+    xmlInitParser();
 
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
     /*
      * Specific case where one want to override the default catalog
      * put in place by xmlInitializeCatalog();
@@ -3380,12 +3348,13 @@ xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
 	   xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 				    orig, NULL,  xmlCatalogDefaultPrefer, NULL);
 	}
-	xmlRMutexUnlock(xmlCatalogMutex);
+	xmlRMutexUnlock(&xmlCatalogMutex);
+        xmlCatalogInitialized = 1;
 	return(0);
     }
 
     res = xmlACatalogAdd(xmlDefaultCatalog, type, orig, replace);
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
     return(res);
 }
 
@@ -3404,9 +3373,9 @@ xmlCatalogRemove(const xmlChar *value) {
     if (!xmlCatalogInitialized)
 	xmlInitializeCatalog();
 
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
     res = xmlACatalogRemove(xmlDefaultCatalog, value);
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
     return(res);
 }
 
@@ -3424,9 +3393,9 @@ xmlCatalogConvert(void) {
     if (!xmlCatalogInitialized)
 	xmlInitializeCatalog();
 
-    xmlRMutexLock(xmlCatalogMutex);
+    xmlRMutexLock(&xmlCatalogMutex);
     res = xmlConvertSGMLCatalog(xmlDefaultCatalog);
-    xmlRMutexUnlock(xmlCatalogMutex);
+    xmlRMutexUnlock(&xmlCatalogMutex);
     return(res);
 }
 
@@ -3439,6 +3408,9 @@ xmlCatalogConvert(void) {
 /**
  * xmlCatalogGetDefaults:
  *
+ * DEPRECATED: Use XML_PARSE_NO_SYS_CATALOG and
+ * XML_PARSE_NO_CATALOG_PI.
+ *
  * Used to get the user preference w.r.t. to what catalogs should
  * be accepted
  *
@@ -3453,6 +3425,9 @@ xmlCatalogGetDefaults(void) {
  * xmlCatalogSetDefaults:
  * @allow:  what catalogs should be accepted
  *
+ * DEPRECATED: Use XML_PARSE_NO_SYS_CATALOG and
+ * XML_PARSE_NO_CATALOG_PI.
+ *
  * Used to set the user preference w.r.t. to what catalogs should
  * be accepted
  */
@@ -3461,19 +3436,19 @@ xmlCatalogSetDefaults(xmlCatalogAllow allow) {
     if (xmlDebugCatalogs) {
 	switch (allow) {
 	    case XML_CATA_ALLOW_NONE:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Disabling catalog usage\n");
 		break;
 	    case XML_CATA_ALLOW_GLOBAL:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Allowing only global catalogs\n");
 		break;
 	    case XML_CATA_ALLOW_DOCUMENT:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Allowing only catalogs from the document\n");
 		break;
 	    case XML_CATA_ALLOW_ALL:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Allowing all catalogs\n");
 		break;
 	}
@@ -3485,6 +3460,8 @@ xmlCatalogSetDefaults(xmlCatalogAllow allow) {
  * xmlCatalogSetDefaultPrefer:
  * @prefer:  the default preference for delegation
  *
+ * DEPRECATED: This setting is global and not thread-safe.
+ *
  * Allows to set the preference between public and system for deletion
  * in XML Catalog resolution. C.f. section 4.1.1 of the spec
  * Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM
@@ -3501,11 +3478,11 @@ xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer) {
     if (xmlDebugCatalogs) {
 	switch (prefer) {
 	    case XML_CATA_PREFER_PUBLIC:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Setting catalog preference to PUBLIC\n");
 		break;
 	    case XML_CATA_PREFER_SYSTEM:
-		fprintf(stderr,
+		xmlCatalogPrintDebug(
 			"Setting catalog preference to SYSTEM\n");
 		break;
 	    default:
@@ -3552,9 +3529,6 @@ void
 xmlCatalogFreeLocal(void *catalogs) {
     xmlCatalogEntryPtr catal;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalog();
-
     catal = (xmlCatalogEntryPtr) catalogs;
     if (catal != NULL)
 	xmlFreeCatalogEntryList(catal);
@@ -3574,14 +3548,13 @@ void *
 xmlCatalogAddLocal(void *catalogs, const xmlChar *URL) {
     xmlCatalogEntryPtr catal, add;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalog();
+    xmlInitParser();
 
     if (URL == NULL)
 	return(catalogs);
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Adding document catalog %s\n", URL);
 
     add = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL, URL, NULL,
@@ -3617,21 +3590,18 @@ xmlCatalogLocalResolve(void *catalogs, const xmlChar *pubID,
     xmlCatalogEntryPtr catal;
     xmlChar *ret;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalog();
-
     if ((pubID == NULL) && (sysID == NULL))
 	return(NULL);
 
     if (xmlDebugCatalogs) {
         if ((pubID != NULL) && (sysID != NULL)) {
-            fprintf(stderr,
+            xmlCatalogPrintDebug(
                             "Local Resolve: pubID %s sysID %s\n", pubID, sysID);
         } else if (pubID != NULL) {
-            fprintf(stderr,
+            xmlCatalogPrintDebug(
                             "Local Resolve: pubID %s\n", pubID);
         } else {
-            fprintf(stderr,
+            xmlCatalogPrintDebug(
                             "Local Resolve: sysID %s\n", sysID);
         }
     }
@@ -3661,14 +3631,11 @@ xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI) {
     xmlCatalogEntryPtr catal;
     xmlChar *ret;
 
-    if (!xmlCatalogInitialized)
-	xmlInitializeCatalog();
-
     if (URI == NULL)
 	return(NULL);
 
     if (xmlDebugCatalogs)
-	fprintf(stderr,
+	xmlCatalogPrintDebug(
 		"Resolve URI %s\n", URI);
 
     catal = (xmlCatalogEntryPtr) catalogs;
@@ -3704,7 +3671,7 @@ xmlCatalogGetSystem(const xmlChar *sysID) {
 	xmlInitializeCatalog();
 
     if (msg == 0) {
-	fprintf(stderr,
+	xmlPrintErrorMessage(
 		"Use of deprecated xmlCatalogGetSystem() call\n");
 	msg++;
     }
@@ -3748,7 +3715,7 @@ xmlCatalogGetPublic(const xmlChar *pubID) {
 	xmlInitializeCatalog();
 
     if (msg == 0) {
-	fprintf(stderr,
+	xmlPrintErrorMessage(
 		"Use of deprecated xmlCatalogGetPublic() call\n");
 	msg++;
     }
diff --git a/check-relaxng-test-suite.py b/check-relaxng-test-suite.py
deleted file mode 100755
index 3e152123..00000000
--- a/check-relaxng-test-suite.py
+++ /dev/null
@@ -1,397 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import time
-import os
-try:
-    # Python 2
-    from StringIO import StringIO
-except ImportError:
-    # Python 3
-    from io import StringIO
-sys.path.insert(0, "python")
-import libxml2
-
-# Memory debug specific
-libxml2.debugMemory(1)
-debug = 0
-verbose = 0
-quiet = 1
-
-#
-# the testsuite description
-#
-CONF=os.path.join(os.path.dirname(__file__), "test/relaxng/OASIS/spectest.xml")
-LOG="check-relaxng-test-suite.log"
-RES="relaxng-test-results.xml"
-
-log = open(LOG, "w")
-nb_schemas_tests = 0
-nb_schemas_success = 0
-nb_schemas_failed = 0
-nb_instances_tests = 0
-nb_instances_success = 0
-nb_instances_failed = 0
-
-libxml2.lineNumbersDefault(1)
-#
-# Error and warnng callbacks
-#
-def callback(ctx, str):
-    global log
-    log.write("%s%s" % (ctx, str))
-
-libxml2.registerErrorHandler(callback, "")
-
-#
-# Resolver callback
-#
-resources = {}
-def resolver(URL, ID, ctxt):
-    global resources
-
-    if URL.find('#') != -1:
-        URL = URL[0:URL.find('#')]
-    if URL in resources:
-        return(StringIO(resources[URL]))
-    log.write("Resolver failure: asked %s\n" % (URL))
-    log.write("resources: %s\n" % (resources))
-    return None
-
-#
-# Load the previous results
-#
-#results = {}
-#previous = {}
-#
-#try:
-#    res = libxml2.parseFile(RES)
-#except:
-#    log.write("Could not parse %s" % (RES))
-
-#
-# handle a valid instance
-#
-def handle_valid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nFailed to parse correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-        return
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-    except:
-        ret = -1
-    if ret != 0:
-        log.write("\nFailed to validate correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-    doc.freeDoc()
-
-#
-# handle an invalid instance
-#
-def handle_invalid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nStrange: failed to parse incorrect instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        return
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-    except:
-        ret = -1
-    if ret == 0:
-        log.write("\nFailed to detect validation problem in instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-    doc.freeDoc()
-
-#
-# handle an incorrect test
-#
-def handle_correct(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs is None:
-        log.write("\nFailed to compile correct schema:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-        nb_schemas_success = nb_schemas_success + 1
-    return rngs
-
-def handle_incorrect(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs != None:
-        log.write("\nFailed to detect schema error in:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-#        log.write("\nSuccess detecting schema error in:\n-----\n")
-#        log.write(schema)
-#        log.write("\n-----\n")
-        nb_schemas_success = nb_schemas_success + 1
-    return None
-
-#
-# resource handling: keep a dictionary of URL->string mappings
-#
-def handle_resource(node, dir):
-    global resources
-
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    res = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            res = res + child.serialize()
-        child = child.next
-    resources[name] = res
-
-#
-# dir handling: pseudo directory resources
-#
-def handle_dir(node, dir):
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, name)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, name)
-
-#
-# handle a testCase element
-#
-def handle_testCase(node):
-    global nb_schemas_tests
-    global nb_instances_tests
-    global resources
-
-    sections = node.xpathEval('string(section)')
-    log.write("\n    ======== test %d line %d section %s ==========\n" % (
-
-              nb_schemas_tests, node.lineNo(), sections))
-    resources = {}
-    if debug:
-        print("test %d line %d" % (nb_schemas_tests, node.lineNo()))
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, None)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, None)
-
-    tsts = node.xpathEval('incorrect')
-    if tsts != []:
-        if len(tsts) != 1:
-            print("warning test line %d has more than one <incorrect> example" %(node.lineNo()))
-        schema = handle_incorrect(tsts[0])
-    else:
-        tsts = node.xpathEval('correct')
-        if tsts != []:
-            if len(tsts) != 1:
-                print("warning test line %d has more than one <correct> example"% (node.lineNo()))
-            schema = handle_correct(tsts[0])
-        else:
-            print("warning <testCase> line %d has no <correct> nor <incorrect> child" % (node.lineNo()))
-
-    nb_schemas_tests = nb_schemas_tests + 1;
-
-    valids = node.xpathEval('valid')
-    invalids = node.xpathEval('invalid')
-    nb_instances_tests = nb_instances_tests + len(valids) + len(invalids)
-    if schema != None:
-        for valid in valids:
-            handle_valid(valid, schema)
-        for invalid in invalids:
-            handle_invalid(invalid, schema)
-
-
-#
-# handle a testSuite element
-#
-def handle_testSuite(node, level = 0):
-    global nb_schemas_tests, nb_schemas_success, nb_schemas_failed
-    global nb_instances_tests, nb_instances_success, nb_instances_failed
-    global quiet
-    if level >= 1:
-        old_schemas_tests = nb_schemas_tests
-        old_schemas_success = nb_schemas_success
-        old_schemas_failed = nb_schemas_failed
-        old_instances_tests = nb_instances_tests
-        old_instances_success = nb_instances_success
-        old_instances_failed = nb_instances_failed
-
-    docs = node.xpathEval('documentation')
-    authors = node.xpathEval('author')
-    if docs != []:
-        msg = ""
-        for doc in docs:
-            msg = msg + doc.content + " "
-        if authors != []:
-            msg = msg + "written by "
-            for author in authors:
-                msg = msg + author.content + " "
-        if quiet == 0:
-            print(msg)
-    sections = node.xpathEval('section')
-    if sections != [] and level <= 0:
-        msg = ""
-        for section in sections:
-            msg = msg + section.content + " "
-        if quiet == 0:
-            print("Tests for section %s" % (msg))
-    for test in node.xpathEval('testCase'):
-        handle_testCase(test)
-    for test in node.xpathEval('testSuite'):
-        handle_testSuite(test, level + 1)
-
-
-    if verbose and level >= 1 and sections != []:
-        msg = ""
-        for section in sections:
-            msg = msg + section.content + " "
-        print("Result of tests for section %s" % (msg))
-        if nb_schemas_tests != old_schemas_tests:
-            print("found %d test schemas: %d success %d failures" % (
-                  nb_schemas_tests - old_schemas_tests,
-                  nb_schemas_success - old_schemas_success,
-                  nb_schemas_failed - old_schemas_failed))
-        if nb_instances_tests != old_instances_tests:
-            print("found %d test instances: %d success %d failures" % (
-                  nb_instances_tests - old_instances_tests,
-                  nb_instances_success - old_instances_success,
-                  nb_instances_failed - old_instances_failed))
-#
-# Parse the conf file
-#
-libxml2.substituteEntitiesDefault(1);
-testsuite = libxml2.parseFile(CONF)
-libxml2.setEntityLoader(resolver)
-root = testsuite.getRootElement()
-if root.name != 'testSuite':
-    print("%s doesn't start with a testSuite element, aborting" % (CONF))
-    sys.exit(1)
-if quiet == 0:
-    print("Running Relax NG testsuite")
-handle_testSuite(root)
-
-if quiet == 0:
-    print("\nTOTAL:\n")
-if quiet == 0 or nb_schemas_failed != 0:
-    print("found %d test schemas: %d success %d failures" % (
-      nb_schemas_tests, nb_schemas_success, nb_schemas_failed))
-if quiet == 0 or nb_instances_failed != 0:
-    print("found %d test instances: %d success %d failures" % (
-      nb_instances_tests, nb_instances_success, nb_instances_failed))
-
-testsuite.freeDoc()
-
-# Memory debug specific
-libxml2.relaxNGCleanupTypes()
-libxml2.cleanupParser()
-if libxml2.debugMemory(1) == 0:
-    if quiet == 0:
-        print("OK")
-else:
-    print("Memory leak %d bytes" % (libxml2.debugMemory(1)))
diff --git a/check-relaxng-test-suite2.py b/check-relaxng-test-suite2.py
deleted file mode 100755
index 779cefae..00000000
--- a/check-relaxng-test-suite2.py
+++ /dev/null
@@ -1,421 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import time
-import os
-try:
-    # Python 2
-    from StringIO import StringIO
-except ImportError:
-    # Python 3
-    from io import StringIO
-sys.path.insert(0, "python")
-import libxml2
-
-# Memory debug specific
-libxml2.debugMemory(1)
-debug = 0
-quiet = 1
-
-#
-# the testsuite description
-#
-CONF=os.path.join(os.path.dirname(__file__), "test/relaxng/testsuite.xml")
-LOG="check-relaxng-test-suite2.log"
-
-log = open(LOG, "w")
-nb_schemas_tests = 0
-nb_schemas_success = 0
-nb_schemas_failed = 0
-nb_instances_tests = 0
-nb_instances_success = 0
-nb_instances_failed = 0
-
-libxml2.lineNumbersDefault(1)
-#
-# Resolver callback
-#
-resources = {}
-def resolver(URL, ID, ctxt):
-    global resources
-
-    if URL in resources:
-        return(StringIO(resources[URL]))
-    log.write("Resolver failure: asked %s\n" % (URL))
-    log.write("resources: %s\n" % (resources))
-    return None
-
-#
-# Load the previous results
-#
-#results = {}
-#previous = {}
-#
-#try:
-#    res = libxml2.parseFile(RES)
-#except:
-#    log.write("Could not parse %s" % (RES))
-
-#
-# handle a valid instance
-#
-def handle_valid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = node.prop("dtd")
-    if instance is None:
-        instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-#    mem = libxml2.debugMemory(1);
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nFailed to parse correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-        return
-
-    if debug:
-        print("instance line %d" % (node.lineNo()))
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-        del ctxt
-    except:
-        ret = -1
-
-    doc.freeDoc()
-#    if mem != libxml2.debugMemory(1):
-#        print("validating instance %d line %d leaks" % (
-#                  nb_instances_tests, node.lineNo()))
-
-    if ret != 0:
-        log.write("\nFailed to validate correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-
-#
-# handle an invalid instance
-#
-def handle_invalid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = node.prop("dtd")
-    if instance is None:
-        instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-#    mem = libxml2.debugMemory(1);
-
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nStrange: failed to parse incorrect instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        return
-
-    if debug:
-        print("instance line %d" % (node.lineNo()))
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-        del ctxt
-
-    except:
-        ret = -1
-
-    doc.freeDoc()
-#    mem2 = libxml2.debugMemory(1)
-#    if mem != mem2:
-#        print("validating instance %d line %d leaks %d bytes" % (
-#                  nb_instances_tests, node.lineNo(), mem2 - mem))
-
-    if ret == 0:
-        log.write("\nFailed to detect validation problem in instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-
-#
-# handle an incorrect test
-#
-def handle_correct(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs is None:
-        log.write("\nFailed to compile correct schema:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-        nb_schemas_success = nb_schemas_success + 1
-    return rngs
-
-def handle_incorrect(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs != None:
-        log.write("\nFailed to detect schema error in:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-#        log.write("\nSuccess detecting schema error in:\n-----\n")
-#        log.write(schema)
-#        log.write("\n-----\n")
-        nb_schemas_success = nb_schemas_success + 1
-    return None
-
-#
-# resource handling: keep a dictionary of URL->string mappings
-#
-def handle_resource(node, dir):
-    global resources
-
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    res = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            res = res + child.serialize()
-        child = child.next
-    resources[name] = res
-
-#
-# dir handling: pseudo directory resources
-#
-def handle_dir(node, dir):
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, name)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, name)
-
-#
-# handle a testCase element
-#
-def handle_testCase(node):
-    global nb_schemas_tests
-    global nb_instances_tests
-    global resources
-
-    sections = node.xpathEval('string(section)')
-    log.write("\n    ======== test %d line %d section %s ==========\n" % (
-
-              nb_schemas_tests, node.lineNo(), sections))
-    resources = {}
-    if debug:
-        print("test %d line %d" % (nb_schemas_tests, node.lineNo()))
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, None)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, None)
-
-    tsts = node.xpathEval('incorrect')
-    if tsts != []:
-        if len(tsts) != 1:
-            print("warning test line %d has more than one <incorrect> example" %(node.lineNo()))
-        schema = handle_incorrect(tsts[0])
-    else:
-        tsts = node.xpathEval('correct')
-        if tsts != []:
-            if len(tsts) != 1:
-                print("warning test line %d has more than one <correct> example"% (node.lineNo()))
-            schema = handle_correct(tsts[0])
-        else:
-            print("warning <testCase> line %d has no <correct> nor <incorrect> child" % (node.lineNo()))
-
-    nb_schemas_tests = nb_schemas_tests + 1;
-
-    valids = node.xpathEval('valid')
-    invalids = node.xpathEval('invalid')
-    nb_instances_tests = nb_instances_tests + len(valids) + len(invalids)
-    if schema != None:
-        for valid in valids:
-            handle_valid(valid, schema)
-        for invalid in invalids:
-            handle_invalid(invalid, schema)
-
-
-#
-# handle a testSuite element
-#
-def handle_testSuite(node, level = 0):
-    global nb_schemas_tests, nb_schemas_success, nb_schemas_failed
-    global nb_instances_tests, nb_instances_success, nb_instances_failed
-    if level >= 1:
-        old_schemas_tests = nb_schemas_tests
-        old_schemas_success = nb_schemas_success
-        old_schemas_failed = nb_schemas_failed
-        old_instances_tests = nb_instances_tests
-        old_instances_success = nb_instances_success
-        old_instances_failed = nb_instances_failed
-
-    docs = node.xpathEval('documentation')
-    authors = node.xpathEval('author')
-    if docs != []:
-        msg = ""
-        for doc in docs:
-            msg = msg + doc.content + " "
-        if authors != []:
-            msg = msg + "written by "
-            for author in authors:
-                msg = msg + author.content + " "
-        if quiet == 0:
-            print(msg)
-    sections = node.xpathEval('section')
-    if sections != [] and level <= 0:
-        msg = ""
-        for section in sections:
-            msg = msg + section.content + " "
-        if quiet == 0:
-            print("Tests for section %s" % (msg))
-    for test in node.xpathEval('testCase'):
-        handle_testCase(test)
-    for test in node.xpathEval('testSuite'):
-        handle_testSuite(test, level + 1)
-
-
-    if level >= 1 and sections != []:
-        msg = ""
-        for section in sections:
-            msg = msg + section.content + " "
-        print("Result of tests for section %s" % (msg))
-        if nb_schemas_tests != old_schemas_tests:
-            print("found %d test schemas: %d success %d failures" % (
-                  nb_schemas_tests - old_schemas_tests,
-                  nb_schemas_success - old_schemas_success,
-                  nb_schemas_failed - old_schemas_failed))
-        if nb_instances_tests != old_instances_tests:
-            print("found %d test instances: %d success %d failures" % (
-                  nb_instances_tests - old_instances_tests,
-                  nb_instances_success - old_instances_success,
-                  nb_instances_failed - old_instances_failed))
-#
-# Parse the conf file
-#
-libxml2.substituteEntitiesDefault(1);
-testsuite = libxml2.parseFile(CONF)
-
-#
-# Error and warnng callbacks
-#
-def callback(ctx, str):
-    global log
-    log.write("%s%s" % (ctx, str))
-
-libxml2.registerErrorHandler(callback, "")
-
-libxml2.setEntityLoader(resolver)
-root = testsuite.getRootElement()
-if root.name != 'testSuite':
-    print("%s doesn't start with a testSuite element, aborting" % (CONF))
-    sys.exit(1)
-if quiet == 0:
-    print("Running Relax NG testsuite")
-handle_testSuite(root)
-
-if quiet == 0:
-    print("\nTOTAL:\n")
-if quiet == 0 or nb_schemas_failed != 0:
-    print("found %d test schemas: %d success %d failures" % (
-      nb_schemas_tests, nb_schemas_success, nb_schemas_failed))
-if quiet == 0 or nb_instances_failed != 0:
-    print("found %d test instances: %d success %d failures" % (
-      nb_instances_tests, nb_instances_success, nb_instances_failed))
-
-log.close()
-testsuite.freeDoc()
-
-# Memory debug specific
-libxml2.relaxNGCleanupTypes()
-libxml2.cleanupParser()
-if libxml2.debugMemory(1) == 0:
-    if quiet == 0:
-        print("OK")
-else:
-    print("Memory leak %d bytes" % (libxml2.debugMemory(1)))
diff --git a/check-xinclude-test-suite.py b/check-xinclude-test-suite.py
deleted file mode 100755
index a0ee028b..00000000
--- a/check-xinclude-test-suite.py
+++ /dev/null
@@ -1,220 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import time
-import os
-sys.path.insert(0, "python")
-import libxml2
-
-#
-# the testsuite description
-#
-DIR="xinclude-test-suite"
-CONF="testdescr.xml"
-LOG="check-xinclude-test-suite.log"
-
-log = open(LOG, "w")
-
-os.chdir(DIR)
-
-test_nr = 0
-test_succeed = 0
-test_failed = 0
-test_error = 0
-#
-# Error and warning handlers
-#
-error_nr = 0
-error_msg = ''
-
-def errorHandler(ctx, str):
-    global error_nr
-    global error_msg
-
-    if str.find("error:") >= 0:
-        error_nr = error_nr + 1
-    if len(error_msg) < 300:
-        if len(error_msg) == 0 or error_msg[-1] == '\n':
-            error_msg = error_msg + "   >>" + str
-        else:
-            error_msg = error_msg + str
-
-libxml2.registerErrorHandler(errorHandler, None)
-
-def testXInclude(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    print("testXInclude(%s, %s)" % (filename, id))
-    return 1
-
-def runTest(test, basedir):
-    global test_nr
-    global test_failed
-    global test_error
-    global test_succeed
-    global error_msg
-    global log
-
-    fatal_error = 0
-    uri = test.prop('href')
-    id = test.prop('id')
-    type = test.prop('type')
-    if uri is None:
-        print("Test without ID:", uri)
-        return -1
-    if id is None:
-        print("Test without URI:", id)
-        return -1
-    if type is None:
-        print("Test without URI:", id)
-        return -1
-    if basedir != None:
-        URI = basedir + "/" + uri
-    else:
-        URI = uri
-    if os.access(URI, os.R_OK) == 0:
-        print("Test %s missing: base %s uri %s" % (URI, basedir, uri))
-        return -1
-
-    expected = None
-    outputfile = None
-    diff = None
-    if type != 'error':
-        output = test.xpathEval('string(output)')
-        if output == 'No output file.':
-            output = None
-        if output == '':
-            output = None
-        if output != None:
-            if basedir != None:
-                output = basedir + "/" + output
-            if os.access(output, os.R_OK) == 0:
-                print("Result for %s missing: %s" % (id, output))
-                output = None
-            else:
-                try:
-                    f = open(output)
-                    expected = f.read()
-                    outputfile = output
-                except:
-                    print("Result for %s unreadable: %s" % (id, output))
-
-    try:
-        # print("testing %s" % (URI))
-        doc = libxml2.parseFile(URI)
-    except:
-        doc = None
-    if doc != None:
-        res = doc.xincludeProcess()
-        if res >= 0 and expected != None:
-            result = doc.serialize()
-            if result != expected:
-                print("Result for %s differs" % (id))
-                open("xinclude.res", "w").write(result)
-                diff = os.popen("diff %s xinclude.res" % outputfile).read()
-
-        doc.freeDoc()
-    else:
-        print("Failed to parse %s" % (URI))
-        res = -1
-
-
-
-    test_nr = test_nr + 1
-    if type == 'success':
-        if res > 0:
-            test_succeed = test_succeed + 1
-        elif res == 0:
-            test_failed = test_failed + 1
-            print("Test %s: no substitution done ???" % (id))
-        elif res < 0:
-            test_error = test_error + 1
-            print("Test %s: failed valid XInclude processing" % (id))
-    elif type == 'error':
-        if res > 0:
-            test_error = test_error + 1
-            print("Test %s: failed to detect invalid XInclude processing" % (id))
-        elif res == 0:
-            test_failed = test_failed + 1
-            print("Test %s: Invalid but no substitution done" % (id))
-        elif res < 0:
-            test_succeed = test_succeed + 1
-    elif type == 'optional':
-        if res > 0:
-            test_succeed = test_succeed + 1
-        else:
-            print("Test %s: failed optional test" % (id))
-
-    # Log the ontext
-    if res != 1:
-        log.write("Test ID %s\n" % (id))
-        log.write("   File: %s\n" % (URI))
-        content = test.content.strip()
-        while content[-1] == '\n':
-            content = content[0:-1]
-        log.write("   %s:%s\n\n" % (type, content))
-        if error_msg != '':
-            log.write("   ----\n%s   ----\n" % (error_msg))
-            error_msg = ''
-        log.write("\n")
-    if diff != None:
-        log.write("diff from test %s:\n" %(id))
-        log.write("   -----------\n%s\n   -----------\n" % (diff));
-
-    return 0
-
-
-def runTestCases(case):
-    creator = case.prop('creator')
-    if creator != None:
-        print("=>", creator)
-    base = case.getBase(None)
-    basedir = case.prop('basedir')
-    if basedir != None:
-        base = libxml2.buildURI(basedir, base)
-    test = case.children
-    while test != None:
-        if test.name == 'testcase':
-            runTest(test, base)
-        if test.name == 'testcases':
-            runTestCases(test)
-        test = test.next
-
-conf = libxml2.parseFile(CONF)
-if conf is None:
-    print("Unable to load %s" % CONF)
-    sys.exit(1)
-
-testsuite = conf.getRootElement()
-if testsuite.name != 'testsuite':
-    print("Expecting TESTSUITE root element: aborting")
-    sys.exit(1)
-
-profile = testsuite.prop('PROFILE')
-if profile != None:
-    print(profile)
-
-start = time.time()
-
-case = testsuite.children
-while case != None:
-    if case.name == 'testcases':
-        old_test_nr = test_nr
-        old_test_succeed = test_succeed
-        old_test_failed = test_failed
-        old_test_error = test_error
-        runTestCases(case)
-        print("   Ran %d tests: %d succeeded, %d failed and %d generated an error" % (
-               test_nr - old_test_nr, test_succeed - old_test_succeed,
-               test_failed - old_test_failed, test_error - old_test_error))
-    case = case.next
-
-conf.freeDoc()
-log.close()
-
-print("Ran %d tests: %d succeeded, %d failed and %d generated an error in %.2f s." % (
-      test_nr, test_succeed, test_failed, test_error, time.time() - start))
diff --git a/check-xml-test-suite.py b/check-xml-test-suite.py
deleted file mode 100755
index 284f7f0f..00000000
--- a/check-xml-test-suite.py
+++ /dev/null
@@ -1,408 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import time
-import os
-sys.path.insert(0, "python")
-import libxml2
-
-test_nr = 0
-test_succeed = 0
-test_failed = 0
-test_error = 0
-
-#
-# the testsuite description
-#
-CONF="xml-test-suite/xmlconf/xmlconf.xml"
-LOG="check-xml-test-suite.log"
-
-log = open(LOG, "w")
-
-#
-# Error and warning handlers
-#
-error_nr = 0
-error_msg = ''
-def errorHandler(ctx, str):
-    global error_nr
-    global error_msg
-
-    error_nr = error_nr + 1
-    if len(error_msg) < 300:
-        if len(error_msg) == 0 or error_msg[-1] == '\n':
-            error_msg = error_msg + "   >>" + str
-        else:
-            error_msg = error_msg + str
-
-libxml2.registerErrorHandler(errorHandler, None)
-
-#warning_nr = 0
-#warning = ''
-#def warningHandler(ctx, str):
-#    global warning_nr
-#    global warning
-#
-#    warning_nr = warning_nr + 1
-#    warning = warning + str
-#
-#libxml2.registerWarningHandler(warningHandler, None)
-
-#
-# Used to load the XML testsuite description
-#
-def loadNoentDoc(filename):
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return None
-    ctxt.replaceEntities(1)
-    ctxt.parseDocument()
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if ctxt.wellFormed() != 1:
-        doc.freeDoc()
-        return None
-    return doc
-
-#
-# The conformance testing routines
-#
-
-def testNotWf(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if doc != None:
-        doc.freeDoc()
-    if ret == 0 or ctxt.wellFormed() != 0:
-        print("%s: error: Well Formedness error not detected" % (id))
-        log.write("%s: error: Well Formedness error not detected\n" % (id))
-        return 0
-    return 1
-
-def testNotWfEnt(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.replaceEntities(1)
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if doc != None:
-        doc.freeDoc()
-    if ret == 0 or ctxt.wellFormed() != 0:
-        print("%s: error: Well Formedness error not detected" % (id))
-        log.write("%s: error: Well Formedness error not detected\n" % (id))
-        return 0
-    return 1
-
-def testNotWfEntDtd(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.replaceEntities(1)
-    ctxt.loadSubset(1)
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if doc != None:
-        doc.freeDoc()
-    if ret == 0 or ctxt.wellFormed() != 0:
-        print("%s: error: Well Formedness error not detected" % (id))
-        log.write("%s: error: Well Formedness error not detected\n" % (id))
-        return 0
-    return 1
-
-def testWfEntDtd(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.replaceEntities(1)
-    ctxt.loadSubset(1)
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if doc is None or ret != 0 or ctxt.wellFormed() == 0:
-        print("%s: error: wrongly failed to parse the document" % (id))
-        log.write("%s: error: wrongly failed to parse the document\n" % (id))
-        if doc != None:
-            doc.freeDoc()
-        return 0
-    if error_nr != 0:
-        print("%s: warning: WF document generated an error msg" % (id))
-        log.write("%s: error: WF document generated an error msg\n" % (id))
-        doc.freeDoc()
-        return 2
-    doc.freeDoc()
-    return 1
-
-def testError(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.replaceEntities(1)
-    ctxt.loadSubset(1)
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    if doc != None:
-        doc.freeDoc()
-    if ctxt.wellFormed() == 0:
-        print("%s: warning: failed to parse the document but accepted" % (id))
-        log.write("%s: warning: failed to parse the document but accepte\n" % (id))
-        return 2
-    if error_nr != 0:
-        print("%s: warning: WF document generated an error msg" % (id))
-        log.write("%s: error: WF document generated an error msg\n" % (id))
-        return 2
-    return 1
-
-def testInvalid(filename, id):
-    global error_nr
-    global error_msg
-    global log
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.validate(1)
-    ret = ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    valid = ctxt.isValid()
-    if doc is None:
-        print("%s: error: wrongly failed to parse the document" % (id))
-        log.write("%s: error: wrongly failed to parse the document\n" % (id))
-        return 0
-    if valid == 1:
-        print("%s: error: Validity error not detected" % (id))
-        log.write("%s: error: Validity error not detected\n" % (id))
-        doc.freeDoc()
-        return 0
-    if error_nr == 0:
-        print("%s: warning: Validity error not reported" % (id))
-        log.write("%s: warning: Validity error not reported\n" % (id))
-        doc.freeDoc()
-        return 2
-
-    doc.freeDoc()
-    return 1
-
-def testValid(filename, id):
-    global error_nr
-    global error_msg
-
-    error_nr = 0
-    error_msg = ''
-
-    ctxt = libxml2.createFileParserCtxt(filename)
-    if ctxt is None:
-        return -1
-    ctxt.validate(1)
-    ctxt.parseDocument()
-
-    try:
-        doc = ctxt.doc()
-    except:
-        doc = None
-    valid = ctxt.isValid()
-    if doc is None:
-        print("%s: error: wrongly failed to parse the document" % (id))
-        log.write("%s: error: wrongly failed to parse the document\n" % (id))
-        return 0
-    if valid != 1:
-        print("%s: error: Validity check failed" % (id))
-        log.write("%s: error: Validity check failed\n" % (id))
-        doc.freeDoc()
-        return 0
-    if error_nr != 0 or valid != 1:
-        print("%s: warning: valid document reported an error" % (id))
-        log.write("%s: warning: valid document reported an error\n" % (id))
-        doc.freeDoc()
-        return 2
-    doc.freeDoc()
-    return 1
-
-def runTest(test):
-    global test_nr
-    global test_succeed
-    global test_failed
-    global error_msg
-    global log
-
-    uri = test.prop('URI')
-    id = test.prop('ID')
-    if uri is None:
-        print("Test without ID:", uri)
-        return -1
-    if id is None:
-        print("Test without URI:", id)
-        return -1
-    base = test.getBase(None)
-    URI = libxml2.buildURI(uri, base)
-    if os.access(URI, os.R_OK) == 0:
-        print("Test %s missing: base %s uri %s" % (URI, base, uri))
-        return -1
-    type = test.prop('TYPE')
-    if type is None:
-        print("Test %s missing TYPE" % (id))
-        return -1
-
-    extra = None
-    if type == "invalid":
-        res = testInvalid(URI, id)
-    elif type == "valid":
-        res = testValid(URI, id)
-    elif type == "not-wf":
-        extra =  test.prop('ENTITIES')
-        # print(URI)
-        #if extra is None:
-        #    res = testNotWfEntDtd(URI, id)
-         #elif extra == 'none':
-        #    res = testNotWf(URI, id)
-        #elif extra == 'general':
-        #    res = testNotWfEnt(URI, id)
-        #elif extra == 'both' or extra == 'parameter':
-        res = testNotWfEntDtd(URI, id)
-        #else:
-        #    print("Unknown value %s for an ENTITIES test value" % (extra))
-        #    return -1
-    elif type == "error":
-        res = testError(URI, id)
-    else:
-        # TODO skipped for now
-        return -1
-
-    test_nr = test_nr + 1
-    if res > 0:
-        test_succeed = test_succeed + 1
-    elif res == 0:
-        test_failed = test_failed + 1
-    elif res < 0:
-        test_error = test_error + 1
-
-    # Log the ontext
-    if res != 1:
-        log.write("   File: %s\n" % (URI))
-        content = test.content.strip()
-        while content[-1] == '\n':
-            content = content[0:-1]
-        if extra != None:
-            log.write("   %s:%s:%s\n" % (type, extra, content))
-        else:
-            log.write("   %s:%s\n\n" % (type, content))
-        if error_msg != '':
-            log.write("   ----\n%s   ----\n" % (error_msg))
-            error_msg = ''
-        log.write("\n")
-
-    return 0
-
-
-def runTestCases(case):
-    profile = case.prop('PROFILE')
-    if profile != None and \
-       profile.find("IBM XML Conformance Test Suite - Production") < 0:
-        print("=>", profile)
-    test = case.children
-    while test != None:
-        if test.name == 'TEST':
-            runTest(test)
-        if test.name == 'TESTCASES':
-            runTestCases(test)
-        test = test.next
-
-conf = loadNoentDoc(CONF)
-if conf is None:
-    print("Unable to load %s" % CONF)
-    sys.exit(1)
-
-testsuite = conf.getRootElement()
-if testsuite.name != 'TESTSUITE':
-    print("Expecting TESTSUITE root element: aborting")
-    sys.exit(1)
-
-profile = testsuite.prop('PROFILE')
-if profile != None:
-    print(profile)
-
-start = time.time()
-
-case = testsuite.children
-while case != None:
-    if case.name == 'TESTCASES':
-        old_test_nr = test_nr
-        old_test_succeed = test_succeed
-        old_test_failed = test_failed
-        old_test_error = test_error
-        runTestCases(case)
-        print("   Ran %d tests: %d succeeded, %d failed and %d generated an error" % (
-               test_nr - old_test_nr, test_succeed - old_test_succeed,
-               test_failed - old_test_failed, test_error - old_test_error))
-    case = case.next
-
-conf.freeDoc()
-log.close()
-
-print("Ran %d tests: %d succeeded, %d failed and %d generated an error in %.2f s." % (
-      test_nr, test_succeed, test_failed, test_error, time.time() - start))
diff --git a/check-xsddata-test-suite.py b/check-xsddata-test-suite.py
deleted file mode 100755
index a08e6af6..00000000
--- a/check-xsddata-test-suite.py
+++ /dev/null
@@ -1,423 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import time
-import os
-try:
-    # Python 2
-    from StringIO import StringIO
-except ImportError:
-    # Python 3
-    from io import StringIO
-sys.path.insert(0, "python")
-import libxml2
-
-# Memory debug specific
-libxml2.debugMemory(1)
-debug = 0
-verbose = 0
-quiet = 1
-
-#
-# the testsuite description
-#
-CONF=os.path.join(os.path.dirname(__file__), "test/xsdtest/xsdtestsuite.xml")
-LOG="check-xsddata-test-suite.log"
-
-log = open(LOG, "w")
-nb_schemas_tests = 0
-nb_schemas_success = 0
-nb_schemas_failed = 0
-nb_instances_tests = 0
-nb_instances_success = 0
-nb_instances_failed = 0
-
-libxml2.lineNumbersDefault(1)
-#
-# Error and warnng callbacks
-#
-def callback(ctx, str):
-    global log
-    log.write("%s%s" % (ctx, str))
-
-libxml2.registerErrorHandler(callback, "")
-
-#
-# Resolver callback
-#
-resources = {}
-def resolver(URL, ID, ctxt):
-    global resources
-
-    if URL in resources:
-        return(StringIO(resources[URL]))
-    log.write("Resolver failure: asked %s\n" % (URL))
-    log.write("resources: %s\n" % (resources))
-    return None
-
-#
-# handle a valid instance
-#
-def handle_valid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = node.prop("dtd")
-    if instance is None:
-        instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-    mem = libxml2.debugMemory(1);
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nFailed to parse correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-        return
-
-    if debug:
-        print("instance line %d" % (node.lineNo()))
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-        del ctxt
-    except:
-        ret = -1
-
-    doc.freeDoc()
-    if mem != libxml2.debugMemory(1):
-        print("validating instance %d line %d leaks" % (
-                  nb_instances_tests, node.lineNo()))
-
-    if ret != 0:
-        log.write("\nFailed to validate correct instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-
-#
-# handle an invalid instance
-#
-def handle_invalid(node, schema):
-    global log
-    global nb_instances_success
-    global nb_instances_failed
-
-    instance = node.prop("dtd")
-    if instance is None:
-        instance = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            instance = instance + child.serialize()
-        child = child.next
-
-#    mem = libxml2.debugMemory(1);
-
-    try:
-        doc = libxml2.parseDoc(instance)
-    except:
-        doc = None
-
-    if doc is None:
-        log.write("\nStrange: failed to parse incorrect instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        return
-
-    if debug:
-        print("instance line %d" % (node.lineNo()))
-
-    try:
-        ctxt = schema.relaxNGNewValidCtxt()
-        ret = doc.relaxNGValidateDoc(ctxt)
-        del ctxt
-
-    except:
-        ret = -1
-
-    doc.freeDoc()
-#    if mem != libxml2.debugMemory(1):
-#        print("validating instance %d line %d leaks" % (
-#                  nb_instances_tests, node.lineNo()))
-
-    if ret == 0:
-        log.write("\nFailed to detect validation problem in instance:\n-----\n")
-        log.write(instance)
-        log.write("\n-----\n")
-        nb_instances_failed = nb_instances_failed + 1
-    else:
-        nb_instances_success = nb_instances_success + 1
-
-#
-# handle an incorrect test
-#
-def handle_correct(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs is None:
-        log.write("\nFailed to compile correct schema:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-        nb_schemas_success = nb_schemas_success + 1
-    return rngs
-
-def handle_incorrect(node):
-    global log
-    global nb_schemas_success
-    global nb_schemas_failed
-
-    schema = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            schema = schema + child.serialize()
-        child = child.next
-
-    try:
-        rngp = libxml2.relaxNGNewMemParserCtxt(schema, len(schema))
-        rngs = rngp.relaxNGParse()
-    except:
-        rngs = None
-    if rngs != None:
-        log.write("\nFailed to detect schema error in:\n-----\n")
-        log.write(schema)
-        log.write("\n-----\n")
-        nb_schemas_failed = nb_schemas_failed + 1
-    else:
-#        log.write("\nSuccess detecting schema error in:\n-----\n")
-#        log.write(schema)
-#        log.write("\n-----\n")
-        nb_schemas_success = nb_schemas_success + 1
-    return None
-
-#
-# resource handling: keep a dictionary of URL->string mappings
-#
-def handle_resource(node, dir):
-    global resources
-
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    res = ""
-    child = node.children
-    while child != None:
-        if child.type != 'text':
-            res = res + child.serialize()
-        child = child.next
-    resources[name] = res
-
-#
-# dir handling: pseudo directory resources
-#
-def handle_dir(node, dir):
-    try:
-        name = node.prop('name')
-    except:
-        name = None
-
-    if name is None or name == '':
-        log.write("resource has no name")
-        return;
-
-    if dir != None:
-#        name = libxml2.buildURI(name, dir)
-        name = dir + '/' + name
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, name)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, name)
-
-#
-# handle a testCase element
-#
-def handle_testCase(node):
-    global nb_schemas_tests
-    global nb_instances_tests
-    global resources
-
-    sections = node.xpathEval('string(section)')
-    log.write("\n    ======== test %d line %d section %s ==========\n" % (
-
-              nb_schemas_tests, node.lineNo(), sections))
-    resources = {}
-    if debug:
-        print("test %d line %d" % (nb_schemas_tests, node.lineNo()))
-
-    dirs = node.xpathEval('dir')
-    for dir in dirs:
-        handle_dir(dir, None)
-    res = node.xpathEval('resource')
-    for r in res:
-        handle_resource(r, None)
-
-    tsts = node.xpathEval('incorrect')
-    if tsts != []:
-        if len(tsts) != 1:
-            print("warning test line %d has more than one <incorrect> example" %(node.lineNo()))
-        schema = handle_incorrect(tsts[0])
-    else:
-        tsts = node.xpathEval('correct')
-        if tsts != []:
-            if len(tsts) != 1:
-                print("warning test line %d has more than one <correct> example"% (node.lineNo()))
-            schema = handle_correct(tsts[0])
-        else:
-            print("warning <testCase> line %d has no <correct> nor <incorrect> child" % (node.lineNo()))
-
-    nb_schemas_tests = nb_schemas_tests + 1;
-
-    valids = node.xpathEval('valid')
-    invalids = node.xpathEval('invalid')
-    nb_instances_tests = nb_instances_tests + len(valids) + len(invalids)
-    if schema != None:
-        for valid in valids:
-            handle_valid(valid, schema)
-        for invalid in invalids:
-            handle_invalid(invalid, schema)
-
-
-#
-# handle a testSuite element
-#
-def handle_testSuite(node, level = 0):
-    global nb_schemas_tests, nb_schemas_success, nb_schemas_failed
-    global nb_instances_tests, nb_instances_success, nb_instances_failed
-    if verbose and level >= 0:
-        old_schemas_tests = nb_schemas_tests
-        old_schemas_success = nb_schemas_success
-        old_schemas_failed = nb_schemas_failed
-        old_instances_tests = nb_instances_tests
-        old_instances_success = nb_instances_success
-        old_instances_failed = nb_instances_failed
-
-    docs = node.xpathEval('documentation')
-    authors = node.xpathEval('author')
-    if docs != []:
-        msg = ""
-        for doc in docs:
-            msg = msg + doc.content + " "
-        if authors != []:
-            msg = msg + "written by "
-            for author in authors:
-                msg = msg + author.content + " "
-        if quiet == 0:
-            print(msg)
-    sections = node.xpathEval('section')
-    if verbose and sections != [] and level <= 0:
-        msg = ""
-        for section in sections:
-            msg = msg + section.content + " "
-        if quiet == 0:
-            print("Tests for section %s" % (msg))
-    for test in node.xpathEval('testCase'):
-        handle_testCase(test)
-    for test in node.xpathEval('testSuite'):
-        handle_testSuite(test, level + 1)
-
-
-    if verbose and level >= 0 :
-        if sections != []:
-            msg = ""
-            for section in sections:
-                msg = msg + section.content + " "
-            print("Result of tests for section %s" % (msg))
-        elif docs != []:
-            msg = ""
-            for doc in docs:
-                msg = msg + doc.content + " "
-            print("Result of tests for %s" % (msg))
-
-        if nb_schemas_tests != old_schemas_tests:
-            print("found %d test schemas: %d success %d failures" % (
-                  nb_schemas_tests - old_schemas_tests,
-                  nb_schemas_success - old_schemas_success,
-                  nb_schemas_failed - old_schemas_failed))
-        if nb_instances_tests != old_instances_tests:
-            print("found %d test instances: %d success %d failures" % (
-                  nb_instances_tests - old_instances_tests,
-                  nb_instances_success - old_instances_success,
-                  nb_instances_failed - old_instances_failed))
-#
-# Parse the conf file
-#
-libxml2.substituteEntitiesDefault(1);
-testsuite = libxml2.parseFile(CONF)
-
-#
-# Error and warnng callbacks
-#
-def callback(ctx, str):
-    global log
-    log.write("%s%s" % (ctx, str))
-
-libxml2.registerErrorHandler(callback, "")
-
-libxml2.setEntityLoader(resolver)
-root = testsuite.getRootElement()
-if root.name != 'testSuite':
-    print("%s doesn't start with a testSuite element, aborting" % (CONF))
-    sys.exit(1)
-if quiet == 0:
-    print("Running Relax NG testsuite")
-handle_testSuite(root)
-
-if quiet == 0 or nb_schemas_failed != 0:
-    print("\nTOTAL:\nfound %d test schemas: %d success %d failures" % (
-      nb_schemas_tests, nb_schemas_success, nb_schemas_failed))
-if quiet == 0 or nb_instances_failed != 0:
-    print("found %d test instances: %d success %d failures" % (
-      nb_instances_tests, nb_instances_success, nb_instances_failed))
-
-testsuite.freeDoc()
-
-# Memory debug specific
-libxml2.relaxNGCleanupTypes()
-libxml2.cleanupParser()
-if libxml2.debugMemory(1) == 0:
-    if quiet == 0:
-        print("OK")
-else:
-    print("Memory leak %d bytes" % (libxml2.debugMemory(1)))
diff --git a/config.h b/config.h
index d436e0f9..6d8a1c13 100644
--- a/config.h
+++ b/config.h
@@ -1,14 +1,17 @@
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
-/* A form that will not confuse apibuild.py */
-#define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))
+/* Define to 1 if you have the declaration of `getentropy', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_GETENTROPY */
 
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#define HAVE_ARPA_INET_H 1
+/* Define to 1 if you have the declaration of `glob', and to 0 if you don't.
+   */
+#define HAVE_DECL_GLOB 1
 
-/* Define if __attribute__((destructor)) is accepted */
-#define HAVE_ATTRIBUTE_DESTRUCTOR 1
+/* Define to 1 if you have the declaration of `mmap', and to 0 if you don't.
+   */
+#define HAVE_DECL_MMAP 1
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1
@@ -16,65 +19,30 @@
 /* Have dlopen based dso */
 #define HAVE_DLOPEN /**/
 
-/* Define to 1 if you have the <dl.h> header file. */
-/* #undef HAVE_DL_H */
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `ftime' function. */
-#define HAVE_FTIME 1
-
-/* Define to 1 if you have the `getentropy' function. */
-/* #undef HAVE_GETENTROPY */
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#define HAVE_GETTIMEOFDAY 1
-
-/* Define to 1 if you have the <glob.h> header file. */
-#define HAVE_GLOB_H 1
+/* Define to 1 if the system has the `destructor' function attribute */
+#define HAVE_FUNC_ATTRIBUTE_DESTRUCTOR 1
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
 
-/* Define if history library is there (-lhistory) */
+/* Define if history library is available */
 /* #undef HAVE_LIBHISTORY */
 
-/* Define if readline library is there (-lreadline) */
+/* Define if readline library is available */
 /* #undef HAVE_LIBREADLINE */
 
 /* Define to 1 if you have the <lzma.h> header file. */
 /* #undef HAVE_LZMA_H */
 
-/* Define to 1 if you have the `mmap' function. */
-#define HAVE_MMAP 1
-
-/* Define to 1 if you have the `munmap' function. */
-#define HAVE_MUNMAP 1
-
-/* mmap() is no good without munmap() */
-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)
-#  undef /**/ HAVE_MMAP
-#endif
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#define HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define HAVE_NETINET_IN_H 1
-
 /* Define to 1 if you have the <poll.h> header file. */
 #define HAVE_POLL_H 1
 
 /* Define to 1 if you have the <pthread.h> header file. */
-#define HAVE_PTHREAD_H /**/
+#define HAVE_PTHREAD_H 1
 
 /* Have shl_load based dso */
 /* #undef HAVE_SHLLOAD */
 
-/* Define to 1 if you have the `stat' function. */
-#define HAVE_STAT 1
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
@@ -90,27 +58,9 @@
 /* Define to 1 if you have the <string.h> header file. */
 #define HAVE_STRING_H 1
 
-/* Define to 1 if you have the <sys/mman.h> header file. */
-#define HAVE_SYS_MMAN_H 1
-
-/* Define to 1 if you have the <sys/random.h> header file. */
-/* #undef HAVE_SYS_RANDOM_H */
-
-/* Define to 1 if you have the <sys/select.h> header file. */
-#define HAVE_SYS_SELECT_H 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define HAVE_SYS_SOCKET_H 1
-
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #define HAVE_SYS_STAT_H 1
 
-/* Define to 1 if you have the <sys/timeb.h> header file. */
-#define HAVE_SYS_TIMEB_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#define HAVE_SYS_TIME_H 1
-
 /* Define to 1 if you have the <sys/types.h> header file. */
 #define HAVE_SYS_TYPES_H 1
 
@@ -149,23 +99,8 @@
    backward compatibility; new code need not use it. */
 #define STDC_HEADERS 1
 
-/* Support for IPv6 */
-#define SUPPORT_IP6
-
 /* Version number of package */
 #define VERSION "2.14.0"
 
-/* Determine what socket length (socklen_t) data type is */
-#define XML_SOCKLEN_T socklen_t
-
 /* TLS specifier */
 #define XML_THREAD_LOCAL _Thread_local
-
-/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
-   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
-   #define below would cause a syntax error. */
-/* #undef _UINT32_T */
-
-/* Define to the type of an unsigned integer type of width exactly 32 bits if
-   such a type exists and the standard includes do not define it. */
-/* #undef uint32_t */
diff --git a/config.h.cmake.in b/config.h.cmake.in
index 2f4aeba3..4da8c765 100644
--- a/config.h.cmake.in
+++ b/config.h.cmake.in
@@ -1,106 +1,38 @@
-/* A form that will not confuse apibuild.py */
-#cmakedefine ATTRIBUTE_DESTRUCTOR @ATTRIBUTE_DESTRUCTOR@
+/* Define to 1 if you have the declaration of 'getentropy', and to 0 if you
+   don't. */
+#cmakedefine01 HAVE_DECL_GETENTROPY
 
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#cmakedefine HAVE_ARPA_INET_H 1
+/* Define to 1 if you have the declaration of 'glob', and to 0 if you don't.
+   */
+#cmakedefine01 HAVE_DECL_GLOB
 
-/* Define if __attribute__((destructor)) is accepted */
-#cmakedefine HAVE_ATTRIBUTE_DESTRUCTOR 1
+/* Define to 1 if you have the declaration of 'mmap', and to 0 if you don't.
+   */
+#cmakedefine01 HAVE_DECL_MMAP
 
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#cmakedefine HAVE_DLFCN_H 1
+/* Define if __attribute__((destructor)) is accepted */
+#cmakedefine HAVE_FUNC_ATTRIBUTE_DESTRUCTOR 1
 
 /* Have dlopen based dso */
 #cmakedefine HAVE_DLOPEN 1
 
-/* Define to 1 if you have the <dl.h> header file. */
-#cmakedefine HAVE_DL_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#cmakedefine HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `ftime' function. */
-#cmakedefine HAVE_FTIME 1
-
-/* Define to 1 if you have the `getentropy' function. */
-#cmakedefine HAVE_GETENTROPY 1
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#cmakedefine HAVE_GETTIMEOFDAY 1
-
 /* Define if history library is there (-lhistory) */
 #cmakedefine HAVE_LIBHISTORY 1
 
 /* Define if readline library is there (-lreadline) */
 #cmakedefine HAVE_LIBREADLINE 1
 
-/* Define to 1 if you have the `mmap' function. */
-#cmakedefine HAVE_MMAP 1
-
-/* Define to 1 if you have the `munmap' function. */
-#cmakedefine HAVE_MUNMAP 1
-
-/* mmap() is no good without munmap() */
-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)
-#  undef /**/ HAVE_MMAP
-#endif
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#cmakedefine HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#cmakedefine HAVE_NETINET_IN_H 1
-
 /* Define to 1 if you have the <poll.h> header file. */
 #cmakedefine HAVE_POLL_H 1
 
-/* Define to 1 if you have the <pthread.h> header file. */
-#cmakedefine HAVE_PTHREAD_H 1
-
 /* Have shl_load based dso */
 #cmakedefine HAVE_SHLLOAD 1
 
-/* Define to 1 if you have the `stat' function. */
-#cmakedefine HAVE_STAT 1
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #cmakedefine HAVE_STDINT_H 1
 
-/* Define to 1 if you have the <sys/mman.h> header file. */
-#cmakedefine HAVE_SYS_MMAN_H 1
-
-/* Define to 1 if you have the <sys/random.h> header file. */
-#cmakedefine HAVE_SYS_RANDOM_H 1
-
-/* Define to 1 if you have the <sys/select.h> header file. */
-#cmakedefine HAVE_SYS_SELECT_H 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#cmakedefine HAVE_SYS_SOCKET_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#cmakedefine HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/timeb.h> header file. */
-#cmakedefine HAVE_SYS_TIMEB_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#cmakedefine HAVE_SYS_TIME_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#cmakedefine HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the <zlib.h> header file. */
-#cmakedefine HAVE_ZLIB_H 1
-
-/* Support for IPv6 */
-#cmakedefine SUPPORT_IP6 1
-
 /* Version number of package */
 #cmakedefine VERSION "@VERSION@"
 
-/* Determine what socket length (socklen_t) data type is */
-#cmakedefine XML_SOCKLEN_T @XML_SOCKLEN_T@
-
 /* TLS specifier */
 #cmakedefine XML_THREAD_LOCAL @XML_THREAD_LOCAL@
diff --git a/configure.ac b/configure.ac
index bdd37f8e..c6dc93d5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,22 +1,25 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ([2.63])
 
-m4_define([MAJOR_VERSION], 2)
-m4_define([MINOR_VERSION], 14)
-m4_define([MICRO_VERSION], 0)
+m4_define([version_macro], m4_normalize(m4_include([VERSION])))
 
-AC_INIT([libxml2],[MAJOR_VERSION.MINOR_VERSION.MICRO_VERSION])
+AC_INIT([libxml2],[version_macro])
 AC_CONFIG_SRCDIR([entities.c])
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CANONICAL_HOST
 
-LIBXML_MAJOR_VERSION=MAJOR_VERSION
-LIBXML_MINOR_VERSION=MINOR_VERSION
-LIBXML_MICRO_VERSION=MICRO_VERSION
+LIBXML_VERSION=version_macro
+LIBXML_MAJOR_VERSION=`echo $LIBXML_VERSION | cut -d . -f 1`
+LIBXML_MINOR_VERSION=`echo $LIBXML_VERSION | cut -d . -f 2`
+LIBXML_MICRO_VERSION=`echo $LIBXML_VERSION | cut -d . -f 3`
 LIBXML_MICRO_VERSION_SUFFIX=
-LIBXML_VERSION=$LIBXML_MAJOR_VERSION.$LIBXML_MINOR_VERSION.$LIBXML_MICRO_VERSION$LIBXML_MICRO_VERSION_SUFFIX
-LIBXML_VERSION_INFO=`expr $LIBXML_MAJOR_VERSION + $LIBXML_MINOR_VERSION`:$LIBXML_MICRO_VERSION:$LIBXML_MINOR_VERSION
+
+# The oldest minor version we are compatible with.
+LIBXML_MINOR_COMPAT=0
+LIBXML_CURRENT=`expr $LIBXML_MAJOR_VERSION + $LIBXML_MINOR_VERSION`
+LIBXML_AGE=`expr $LIBXML_MINOR_VERSION - $LIBXML_MINOR_COMPAT`
+LIBXML_VERSION_INFO=$LIBXML_CURRENT:$LIBXML_MICRO_VERSION:$LIBXML_AGE
 
 LIBXML_VERSION_NUMBER=`expr $LIBXML_MAJOR_VERSION \* 10000 + $LIBXML_MINOR_VERSION \* 100 + $LIBXML_MICRO_VERSION`
 
@@ -49,7 +52,6 @@ AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_MKDIR_P
 AC_PATH_PROG(TAR, tar, /bin/tar)
-AC_PATH_PROG(PERL, perl, /usr/bin/perl)
 AC_PATH_PROG(WGET, wget, /usr/bin/wget)
 AC_PATH_PROG(XSLTPROC, xsltproc, /usr/bin/xsltproc)
 PKG_PROG_PKG_CONFIG
@@ -68,11 +70,11 @@ AC_ARG_WITH(c14n,
 AC_ARG_WITH(catalog,
 [  --with-catalog          XML Catalogs support (on)])
 AC_ARG_WITH(debug,
-[  --with-debug            debugging module and shell (on)])
+[  --with-debug            debugging module (on)])
 AC_ARG_WITH(history,
-[  --with-history          history support for shell (off)])
+[  --with-history          history support for xmllint shell (off)])
 AC_ARG_WITH(readline,
-[  --with-readline[[=DIR]]   use readline in DIR (for shell history)])
+[  --with-readline[[=DIR]]   use readline in DIR for shell (off)])
 AC_ARG_WITH(html,
 [  --with-html             HTML parser (on)])
 AC_ARG_WITH(http,
@@ -109,8 +111,6 @@ AC_ARG_WITH(threads,
 [  --with-threads          multithreading support (on)])
 AC_ARG_WITH(thread-alloc,
 [  --with-thread-alloc     per-thread malloc hooks (off)])
-AC_ARG_WITH(tree,
-[  --with-tree             DOM like tree manipulation APIs (on)])
 AC_ARG_WITH(valid,
 [  --with-valid            DTD validation support (on)])
 AC_ARG_WITH(writer,
@@ -175,10 +175,6 @@ if test "$with_schematron" = "yes"; then
         echo WARNING: --with-schematron overrides --without-pattern
     fi
     with_pattern=yes
-    if test "$with_tree" = "no"; then
-        echo WARNING: --with-schematron overrides --without-tree
-    fi
-    with_tree=yes
     if test "$with_xpath" = "no"; then
         echo WARNING: --with-schematron overrides --without-xpath
     fi
@@ -189,10 +185,6 @@ if test "$with_reader" = "yes"; then
         echo WARNING: --with-reader overrides --without-push
     fi
     with_push=yes
-    if test "$with_tree" = "no"; then
-        echo WARNING: --with-reader overrides --without-tree
-    fi
-    with_tree=yes
 fi
 if test "$with_writer" = "yes"; then
     if test "$with_output" = "no"; then
@@ -216,6 +208,15 @@ if test "$with_xptr" = "yes"; then
     fi
     with_xpath=yes
 fi
+if test "$with_history" = "yes"; then
+    if test "$with_readline" = "no"; then
+        echo WARNING: --with-history overrides --without-readline
+        with_readline=yes
+    fi
+    if test "$with_readline" = ""; then
+        with_readline=yes
+    fi
+fi
 
 if test "$with_minimum" = "yes"; then
     dnl
@@ -243,7 +244,6 @@ if test "$with_minimum" = "yes"; then
     test "$with_schematron" = "" && with_schematron=no
     test "$with_threads" = "" && with_threads=no
     test "$with_thread_alloc" = "" && with_thread_alloc=no
-    test "$with_tree" = "" && with_tree=no
     test "$with_valid" = "" && with_valid=no
     test "$with_writer" = "" && with_writer=no
     test "$with_xinclude" = "" && with_xinclude=no
@@ -270,10 +270,6 @@ else
     if test "$with_regexps" = "no"; then
         with_schemas=no
     fi
-    if test "$with_tree" = "no"; then
-        with_reader=no
-        with_schematron=no
-    fi
     if test "$with_xpath" = "no"; then
         with_c14n=no
         with_schematron=no
@@ -282,37 +278,39 @@ else
     fi
 fi
 
+dnl
+dnl Extra flags
+dnl
+XML_LIBDIR='-L${libdir}'
+XML_INCLUDEDIR='-I${includedir}/libxml2'
+XML_CFLAGS=""
+XML_STATIC_CFLAGS=""
+XML_PC_CFLAGS_PRIVATE=""
+
 XML_PRIVATE_LIBS=
 XML_PRIVATE_CFLAGS=
 XML_PC_LIBS=
 XML_PC_REQUIRES=
 
+AX_GCC_FUNC_ATTRIBUTE([destructor])
+
 dnl
 dnl Checks for header files.
 dnl
 AC_CHECK_HEADERS([stdint.h])
-AC_CHECK_HEADERS([fcntl.h unistd.h sys/stat.h])
-AC_CHECK_HEADERS([sys/mman.h])
-AC_CHECK_HEADERS([sys/time.h sys/timeb.h])
-AC_CHECK_HEADERS([sys/random.h])
-AC_CHECK_HEADERS([dl.h dlfcn.h])
-AC_CHECK_HEADERS([glob.h])
-AM_CONDITIONAL(WITH_GLOB, test "$ac_cv_header_glob_h" = "yes")
 
 dnl Checks for library functions.
-AC_CHECK_FUNCS([getentropy gettimeofday ftime stat mmap munmap])
+AC_CHECK_DECLS([getentropy], [], [], [#include <sys/random.h>])
+AC_CHECK_DECLS([glob], [], [], [#include <glob.h>])
+AC_CHECK_DECLS([mmap], [], [], [#include <sys/mman.h>])
 
-AH_VERBATIM([HAVE_MUNMAP_AFTER],[/* mmap() is no good without munmap() */
-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)
-#  undef /**/ HAVE_MMAP
-#endif])
+AM_CONDITIONAL(WITH_GLOB, test "$ac_cv_have_decl_glob" = "yes")
 
 dnl
 dnl Checks for inet libraries
 dnl
 if test "$with_http" = "yes"; then
-    AC_CHECK_HEADERS([sys/socket.h netinet/in.h arpa/inet.h netdb.h])
-    AC_CHECK_HEADERS([sys/select.h poll.h])
+    AC_CHECK_HEADERS([poll.h])
 
     case "$host" in
         *-*-mingw*)
@@ -334,72 +332,10 @@ if test "$with_http" = "yes"; then
             ;;
     esac
 
-    dnl Determine what socket length (socklen_t) data type is
-    AC_MSG_CHECKING([for type of socket length (socklen_t)])
-    AC_TRY_COMPILE2([
-    #include <stddef.h>
-    #ifdef _WIN32
-      #include <ws2tcpip.h>
-    #else
-      #include <sys/socket.h>
-    #endif],[
-    (void)getsockopt (1, 1, 1, NULL, (socklen_t *)NULL)],[
-      AC_MSG_RESULT(socklen_t *)
-      XML_SOCKLEN_T=socklen_t],[
-      AC_TRY_COMPILE2([
-    #include <stddef.h>
-    #include <sys/socket.h>],[
-    (void)getsockopt (1, 1, 1, NULL, (size_t *)NULL)],[
-        AC_MSG_RESULT(size_t *)
-        XML_SOCKLEN_T=size_t],[
-        AC_TRY_COMPILE2([
-    #include <stddef.h>
-    #include <sys/socket.h>],[
-    (void)getsockopt (1, 1, 1, NULL, (int *)NULL)],[
-          AC_MSG_RESULT(int *)
-          XML_SOCKLEN_T=int],[
-          AC_MSG_WARN(could not determine)
-          XML_SOCKLEN_T="int"])])])
-    AC_DEFINE_UNQUOTED(XML_SOCKLEN_T, $XML_SOCKLEN_T, [Determine what socket length (socklen_t) data type is])
-
-    dnl
-    dnl Checking for availability of IPv6
-    dnl
-    AC_ARG_ENABLE(ipv6, [  --enable-ipv6[[=yes/no]]  enables compilation of IPv6 code [[default=yes]]],, enable_ipv6=yes)
-    if test "$with_minimum" = "yes"
-    then
-        enable_ipv6=no
-    fi
-    if test $enable_ipv6 = yes; then
-        AC_MSG_CHECKING([whether to enable IPv6])
-        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-            #ifdef _WIN32
-              #include <winsock2.h>
-            #else
-              #include <sys/socket.h>
-              #ifdef HAVE_NETDB_H
-                #include <netdb.h>
-              #endif
-            #endif
-            ]], [[
-            struct sockaddr_storage ss;
-            socket(AF_INET6, SOCK_STREAM, 0);
-            getaddrinfo(0, 0, 0, 0);
-            ]])], [
-            AC_DEFINE([SUPPORT_IP6], [], [Support for IPv6])
-            AC_MSG_RESULT([yes])], [
-            AC_MSG_RESULT([no])]
-        )
-    fi
+    XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${NET_LIBS}"
+    XML_PC_LIBS="${XML_PC_LIBS} ${NET_LIBS}"
 fi
 
-dnl
-dnl Extra flags
-dnl
-XML_LIBDIR='-L${libdir}'
-XML_INCLUDEDIR='-I${includedir}/libxml2'
-XML_CFLAGS=""
-
 dnl Thread-local storage
 if test "$with_tls" = "yes"; then
     AC_COMPILE_IFELSE([
@@ -411,41 +347,34 @@ if test "$with_tls" = "yes"; then
     AC_COMPILE_IFELSE([
         AC_LANG_SOURCE([__declspec(thread) int v;]) ], [
         AC_DEFINE([XML_THREAD_LOCAL], [__declspec(thread)], [TLS specifier]) ], [
-    WARN_NO_TLS=1 ])])])
+    ])])])
 fi
 
-dnl Checking whether __attribute__((destructor)) is accepted by the compiler
-AC_MSG_CHECKING([whether __attribute__((destructor)) is accepted])
-AC_TRY_COMPILE2([
-void __attribute__((destructor))
-f(void) {}], [], [
-  AC_MSG_RESULT(yes)
-  AC_DEFINE([HAVE_ATTRIBUTE_DESTRUCTOR], [1],[Define if __attribute__((destructor)) is accepted])
-  AC_DEFINE([ATTRIBUTE_DESTRUCTOR], [__attribute__((destructor))],[A form that will not confuse apibuild.py])],[
-  AC_MSG_RESULT(no)])
-
 dnl
 dnl Linker version scripts for symbol versioning
 dnl
 VERSION_SCRIPT_FLAGS=
-# lt_cv_prog_gnu_ld is from libtool 2.+
-if test "$lt_cv_prog_gnu_ld" = yes; then
-  case $host in
-    *-*-cygwin* | *-*-mingw* | *-*-msys* )
-      ;;
-    *)
-      dnl lld 16 defaults to --no-undefined-version but the version script
-      dnl can contain symbols disabled by configuration options.
-      AX_APPEND_LINK_FLAGS([-Wl,--undefined-version], [VERSION_SCRIPT_FLAGS])
-      AX_APPEND_FLAG([-Wl,--version-script=], [VERSION_SCRIPT_FLAGS])
-      ;;
-  esac
-else
-  case $host in
-  *-*-sunos*) VERSION_SCRIPT_FLAGS="-Wl,-M -Wl,";;
-  esac
+if test "$with_legacy" = "yes"; then
+    # lt_cv_prog_gnu_ld is from libtool 2.+
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+        case $host in
+            *-*-cygwin* | *-*-mingw* | *-*-msys* )
+                ;;
+            *)
+                dnl lld 16 defaults to --no-undefined-version but the version
+                dnl script can contain symbols disabled by configuration
+                dnl options.
+                AX_APPEND_LINK_FLAGS([-Wl,--undefined-version], [VERSION_SCRIPT_FLAGS])
+                AX_APPEND_FLAG([-Wl,--version-script=], [VERSION_SCRIPT_FLAGS])
+                ;;
+        esac
+    else
+        case $host in
+        *-*-sunos*) VERSION_SCRIPT_FLAGS="-Wl,-M -Wl,";;
+        esac
+    fi
+    AC_SUBST(VERSION_SCRIPT_FLAGS)
 fi
-AC_SUBST(VERSION_SCRIPT_FLAGS)
 AM_CONDITIONAL([USE_VERSION_SCRIPT], [test -n "$VERSION_SCRIPT_FLAGS"])
 
 dnl
@@ -469,7 +398,7 @@ else
     # warnings we'd like to see
     AM_CFLAGS="${AM_CFLAGS} -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes"
     # warnings we'd like to suppress
-    AM_CFLAGS="${AM_CFLAGS} -Wno-long-long -Wno-format-extra-args"
+    AM_CFLAGS="${AM_CFLAGS} -Wno-long-long -Wno-format-extra-args -Wno-array-bounds"
     case "${host}" in
           alpha*-*-linux* )
 	       AM_CFLAGS="${AM_CFLAGS} -mieee"
@@ -489,9 +418,13 @@ case ${host} in
         # work properly (without it, xmlexports.h would force the use of
         # DLL imports, which obviously aren't present in a static
         # library).
-        if test "x$enable_shared" = "xno"; then
-            XML_CFLAGS="$XML_CFLAGS -DLIBXML_STATIC"
-            AM_CFLAGS="$AM_CFLAGS -DLIBXML_STATIC"
+        XML_STATIC_CFLAGS="-DLIBXML_STATIC"
+        if test "x$enable_shared" = "xyes"; then
+            XML_PC_CFLAGS_PRIVATE="
+Cflags.private:"
+        else
+            XML_CFLAGS="$XML_STATIC_CFLAGS"
+            AM_CFLAGS="$AM_CFLAGS $XML_STATIC_CFLAGS"
         fi
         ;;
 esac
@@ -501,14 +434,6 @@ dnl
 dnl Simple API modules
 dnl
 
-if test "$with_tree" = "no" ; then
-    echo Disabling DOM like tree manipulation APIs
-    WITH_TREE=0
-else
-    WITH_TREE=1
-fi
-AC_SUBST(WITH_TREE)
-
 if test "$with_http" != "yes" ; then
     WITH_HTTP=0
 else
@@ -740,21 +665,27 @@ if test "$with_modules" != "no" ; then
         AC_SEARCH_LIBS([dlopen], [dl], [
             WITH_MODULES=1
             if test "$ac_cv_search_dlopen" != "none required"; then
-                MODULE_PLATFORM_LIBS=$ac_cv_search_dlopen
+                MODULE_LIBS=$ac_cv_search_dlopen
             fi
             AC_DEFINE([HAVE_DLOPEN], [], [Have dlopen based dso])], [
             AC_SEARCH_LIBS([shl_load], [dld], [
                 WITH_MODULES=1
                 if test "$ac_cv_search_shl_load" != "none required"; then
-                    MODULE_PLATFORM_LIBS=$ac_cv_search_shl_load
+                    MODULE_LIBS=$ac_cv_search_shl_load
                 fi
                 AC_DEFINE([HAVE_SHLLOAD], [], [Have shl_load based dso])])])
         LIBS=$_libs
     fi
+
+    if test "$WITH_MODULES" = "0"; then
+        AC_MSG_ERROR([dlopen or equivalent not found])
+    fi
+
+    XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${MODULE_LIBS}"
+    XML_PC_LIBS="${XML_PC_LIBS} ${MODULE_LIBS}"
 fi
 
 AC_SUBST(WITH_MODULES)
-AC_SUBST(MODULE_PLATFORM_LIBS)
 AC_SUBST(MODULE_EXTENSION)
 AM_CONDITIONAL(WITH_MODULES_SOURCES, test "$WITH_MODULES" = "1")
 
@@ -762,7 +693,6 @@ dnl
 dnl Thread-related stuff
 dnl
 THREAD_LIBS=""
-BASE_THREAD_LIBS=""
 WITH_THREADS=0
 WITH_THREAD_ALLOC=0
 
@@ -782,69 +712,101 @@ else
                     WITH_THREADS="1"
                     if test "$ac_cv_search_pthread_create" != "none required"; then
                         THREAD_LIBS=$ac_cv_search_pthread_create
-                    fi
-                    AC_DEFINE([HAVE_PTHREAD_H], [],
-                              [Define if <pthread.h> is there])]))
+                    fi]))
             LIBS=$_libs
             ;;
     esac
 
-    case $host_os in
-        *linux*)
-            if test "${GCC}" = "yes" ; then
-                BASE_THREAD_LIBS="$THREAD_LIBS"
-                THREAD_LIBS=""
-            fi
-            ;;
-    esac
+    if test "$WITH_THREADS" = "0"; then
+        AC_MSG_ERROR([libpthread not found])
+    fi
+
+    XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${THREAD_LIBS}"
+    XML_PC_LIBS="${XML_PC_LIBS} ${THREAD_LIBS}"
 fi
 if test "$with_thread_alloc" = "yes" && test "$WITH_THREADS" = "1" ; then
     WITH_THREAD_ALLOC=1
 fi
 
 AC_SUBST(THREAD_LIBS)
-AC_SUBST(BASE_THREAD_LIBS)
 AC_SUBST(WITH_THREADS)
 AC_SUBST(WITH_THREAD_ALLOC)
 
 dnl
-dnl xmllint shell history
+dnl Checks for readline and history libraries.
 dnl
-if test "$with_history" = "yes" && test "$with_readline" != "no"; then
-    echo Enabling xmllint shell history
-    dnl check for terminal library. this is a very cool solution
-    dnl from octave's configure.in
-    unset tcap
-    for termlib in ncurses curses termcap terminfo termlib; do
-	AC_CHECK_LIB(${termlib}, tputs, [tcap="-l$termlib"])
-	test -n "$tcap" && break
-    done
+if test "$with_readline" != "no" && test "$with_readline" != ""; then
+    WITH_READLINE=0
+    WITH_HISTORY=0
 
-    _cppflags=$CPPFLAGS
-    _libs=$LIBS
-    if test "$with_readline" != "" && test "$with_readline" != "yes"; then
+    if test "$with_readline" != "yes"; then
         RDL_DIR=$with_readline
-        CPPFLAGS="${CPPFLAGS} -I$RDL_DIR/include"
-        LIBS="${LIBS} -L$RDL_DIR/lib"
     fi
-    AC_CHECK_HEADER(readline/history.h,
-	AC_CHECK_LIB(history, append_history,[
-	    RDL_LIBS="-lhistory"
-            if test "x${RDL_DIR}" != "x"; then
-                RDL_CFLAGS="-I$RDL_DIR/include"
-                RDL_LIBS="-L$RDL_DIR/lib $RDL_LIBS"
-            fi
-	    AC_DEFINE([HAVE_LIBHISTORY], [], [Define if history library is there (-lhistory)])]))
-    AC_CHECK_HEADER(readline/readline.h,
-	AC_CHECK_LIB(readline, readline,[
-	    RDL_LIBS="-lreadline $RDL_LIBS $tcap"
-            if test "x$RDL_DIR" != "x"; then
-                RDL_CFLAGS="-I$RDL_DIR/include"
-                RDL_LIBS="-L$RDL_DIR/lib $RDL_LIBS"
+
+    if test "$RDL_DIR" = ""; then
+        PKG_CHECK_MODULES([RDL], [readline], [ WITH_READLINE=1 ], [:])
+    fi
+
+    if test "$WITH_READLINE" = "0"; then
+        _cppflags=$CPPFLAGS
+        _libs=$LIBS
+
+        if test "$RDL_DIR" != ""; then
+            CPPFLAGS="${CPPFLAGS} -I$RDL_DIR/include"
+            LIBS="${LIBS} -L$RDL_DIR/lib"
+        fi
+        AC_CHECK_HEADER(readline/readline.h,
+            AC_CHECK_LIB(readline, readline, [
+                WITH_READLINE=1
+                RDL_LIBS="-lreadline"
+            ], [
+                AC_MSG_ERROR([libreadline not found])
+            ]))
+
+        CPPFLAGS=$_cppflags
+        LIBS=$_libs
+    fi
+
+    AC_DEFINE([HAVE_LIBREADLINE], [],
+              [Define if readline library is available])
+
+    if test "$with_history" = "yes"; then
+        if test "$RDL_DIR" = ""; then
+            PKG_CHECK_MODULES([HISTORY], [history], [
+                WITH_HISTORY=1
+                RDL_CFLAGS="$HISTORY_CFLAGS $RDL_CFLAGS"
+                RDL_LIBS="$HISTORY_LIBS $RDL_LIBS"
+            ], [:])
+        fi
+
+        if test "$WITH_HISTORY" = "0"; then
+            _cppflags=$CPPFLAGS
+            _libs=$LIBS
+
+            if test "$RDL_DIR" != ""; then
+                CPPFLAGS="${CPPFLAGS} -I$RDL_DIR/include"
+                LIBS="${LIBS} -L$RDL_DIR/lib"
             fi
-	    AC_DEFINE([HAVE_LIBREADLINE], [], [Define if readline library is there (-lreadline)])], , $tcap))
-    CPPFLAGS=$_cppflags
-    LIBS=$_libs
+            AC_CHECK_HEADER(readline/history.h,
+                AC_CHECK_LIB(history, append_history, [
+                    WITH_HISTORY=1
+                    RDL_LIBS="-lhistory $RDL_LIBS"
+                ], [
+                    AC_MSG_ERROR([libhistory not found])
+                ]))
+
+            CPPFLAGS=$_cppflags
+            LIBS=$_libs
+        fi
+
+        AC_DEFINE([HAVE_LIBHISTORY], [],
+                  [Define if history library is available])
+    fi
+
+    if test "$RDL_DIR" != ""; then
+        RDL_CFLAGS="-I$RDL_DIR/include"
+        RDL_LIBS="-L$RDL_DIR/lib $RDL_LIBS"
+    fi
 fi
 AC_SUBST(RDL_CFLAGS)
 AC_SUBST(RDL_LIBS)
@@ -896,6 +858,10 @@ if test "$with_zlib" != "no" && test "$with_zlib" != ""; then
         LIBS=$_libs
     fi
 
+    if test "$WITH_ZLIB" = "0"; then
+        AC_MSG_ERROR([zlib not found])
+    fi
+
     XML_PRIVATE_CFLAGS="${XML_PRIVATE_CFLAGS} ${Z_CFLAGS}"
     XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${Z_LIBS}"
 fi
@@ -946,6 +912,10 @@ if test "$with_lzma" != "no" && test "$with_lzma" != ""; then
         LIBS=$_libs
     fi
 
+    if test "$WITH_LZMA" = "0"; then
+        AC_MSG_ERROR([liblzma not found])
+    fi
+
     XML_PRIVATE_CFLAGS="${XML_PRIVATE_CFLAGS} ${LZMA_CFLAGS}"
     XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${LZMA_LIBS}"
 fi
@@ -985,14 +955,21 @@ else
             AC_MSG_RESULT([no])
         ])
     ])
+
+    if test "$WITH_ICONV" = "0"; then
+        AC_MSG_ERROR([libiconv not found])
+    fi
+
     if test "$WITH_ICONV" = "1" && test "$ICONV_DIR" != ""; then
         ICONV_CFLAGS="-I$ICONV_DIR/include"
         ICONV_LIBS="-L$ICONV_DIR/lib $ICONV_LIBS"
-	# Export this since our headers include iconv.h
-	XML_INCLUDEDIR="$XML_INCLUDEDIR -I$ICONV_DIR/include"
     fi
     CPPFLAGS=$_cppflags
     LIBS=$_libs
+
+    XML_PRIVATE_CFLAGS="${XML_PRIVATE_CFLAGS} ${ICONV_CFLAGS}"
+    XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${ICONV_LIBS}"
+    XML_PC_LIBS="${XML_PC_LIBS} ${ICONV_LIBS}"
 fi
 AC_SUBST(WITH_ICONV)
 AC_SUBST(ICONV_CFLAGS)
@@ -1046,6 +1023,10 @@ if test "$with_icu" != "no" && test "$with_icu" != "" ; then
         fi
     fi
 
+    if test "$WITH_ICU" = "0"; then
+        AC_MSG_ERROR([ICU not found])
+    fi
+
     XML_PRIVATE_CFLAGS="${XML_PRIVATE_CFLAGS} ${ICU_CFLAGS}"
     XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${ICU_LIBS}"
 fi
@@ -1057,15 +1038,14 @@ dnl
 case "$host" in
     *-*-mingw*)
         CRYPTO_LIBS="-lbcrypt"
+        XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${CRYPTO_LIBS}"
+        XML_PC_LIBS="${XML_PC_LIBS} ${CRYPTO_LIBS}"
         ;;
 esac
 
 XML_LIBS="-lxml2"
-XML_LIBTOOLLIBS="libxml2.la"
-NON_PC_LIBS="${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${NET_LIBS} ${CRYPTO_LIBS}"
-XML_PC_LIBS="${XML_PC_LIBS} ${NON_PC_LIBS}"
-XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${NON_PC_LIBS}"
-XML_PRIVATE_CFLAGS="${XML_PRIVATE_CFLAGS} ${ICONV_CFLAGS}"
+XML_PC_LIBS="${XML_PC_LIBS} ${LIBM}"
+XML_PRIVATE_LIBS="${XML_PRIVATE_LIBS} ${LIBM}"
 
 dnl When static-only:
 dnl * Duplicate xml-config static --libs into --dynamic.
@@ -1083,9 +1063,11 @@ fi
 AC_SUBST(XML_PRIVATE_LIBS_NO_SHARED)
 AC_SUBST(XML_PC_PRIVATE)
 AC_SUBST(XML_PC_LIBS_PRIVATE)
+AC_SUBST(XML_PC_CFLAGS_PRIVATE)
 AM_SUBST_NOTMAKE(XML_PRIVATE_LIBS_NO_SHARED)
 AM_SUBST_NOTMAKE(XML_PC_PRIVATE)
 AM_SUBST_NOTMAKE(XML_PC_LIBS_PRIVATE)
+AM_SUBST_NOTMAKE(XML_PC_CFLAGS_PRIVATE)
 
 AC_SUBST(XML_PC_LIBS)
 AC_SUBST(XML_PC_REQUIRES)
@@ -1095,28 +1077,16 @@ AM_SUBST_NOTMAKE(XML_PC_REQUIRES)
 AC_SUBST(AM_CFLAGS)
 AC_SUBST(AM_LDFLAGS)
 AC_SUBST(XML_CFLAGS)
+AC_SUBST(XML_STATIC_CFLAGS)
 
 AC_SUBST(XML_LIBDIR)
 AC_SUBST(XML_LIBS)
 AC_SUBST(XML_PRIVATE_LIBS)
 AC_SUBST(XML_PRIVATE_CFLAGS)
-AC_SUBST(XML_LIBTOOLLIBS)
 AC_SUBST(XML_INCLUDEDIR)
 
-dnl for the spec file
-RELDATE=`date +'%a %b %e %Y'`
-AC_SUBST(RELDATE)
-
 # keep on one line for cygwin c.f. #130896
-AC_CONFIG_FILES([Makefile include/Makefile include/libxml/Makefile include/private/Makefile doc/Makefile doc/devhelp/Makefile example/Makefile fuzz/Makefile python/Makefile python/tests/Makefile xstc/Makefile include/libxml/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])
+AC_CONFIG_FILES([Makefile include/Makefile include/libxml/Makefile include/private/Makefile doc/Makefile doc/devhelp/Makefile example/Makefile fuzz/Makefile python/Makefile python/tests/Makefile xstc/Makefile include/libxml/xmlversion.h libxml-2.0.pc libxml2-config.cmake])
 AC_CONFIG_FILES([python/setup.py], [chmod +x python/setup.py])
 AC_CONFIG_FILES([xml2-config], [chmod +x xml2-config])
 AC_OUTPUT
-
-if test "$WARN_NO_TLS" != ""; then
-    echo "================================================================"
-    echo "WARNING: Your C compiler appears to not support thread-local"
-    echo "storage. Future versions of libxml2 will require this feature"
-    echo "for multi-threading."
-    echo "================================================================"
-fi
diff --git a/dbgen.pl b/dbgen.pl
deleted file mode 100755
index 1383d6e9..00000000
--- a/dbgen.pl
+++ /dev/null
@@ -1,43 +0,0 @@
-#!/usr/bin/perl
-
-$size = shift;
-
-if ($size eq "") 
-{
-    die "usage:  dbgen.pl [size]\n";
-}
-
-@firstnames = ("Al", "Bob", "Charles", "David", "Egon", "Farbood", 
-               "George", "Hank", "Inki", "James");
-@lastnames = ("Aranow", "Barker", "Corsetti", "Dershowitz", "Engleman", 
-              "Franklin", "Grice", "Haverford", "Ilvedson", "Jones");
-@states = ("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", 
-           "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", 
-           "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", 
-           "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", 
-           "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY");
-
-print "<?xml version=\"1.0\"?>\n";
-print "\n";
-print "<table>\n";
-
-for ($i=0; $i<$size; $i++)
-{
-    $first = $firstnames [$i % 10];
-    $last = $lastnames [($i / 10) % 10];
-    $state = $states [($i / 100) % 50];
-    $zip = 22000 + $i / 5000;
-
-    printf "  <row>\n";
-    printf "    <id>%04d</id>\n", $i;
-    printf "    <firstname>$first</firstname>\n", $i;
-    printf "    <lastname>$last</lastname>\n", $i;
-    printf "    <street>%d Any St.</street>\n", ($i % 100) + 1;
-    printf "    <city>Anytown</city>\n";
-    printf "    <state>$state</state>\n";
-    printf "    <zip>%d</zip>\n", $zip;
-    printf "  </row>\n";
-}
-
-print "</table>\n";
-
diff --git a/dbgenattr.pl b/dbgenattr.pl
deleted file mode 100755
index dce11cd8..00000000
--- a/dbgenattr.pl
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/usr/bin/perl
-
-$size = shift;
-
-if ($size eq "") 
-{
-    die "usage:  dbgen.pl [size]\n";
-}
-
-@firstnames = ("Al", "Bob", "Charles", "David", "Egon", "Farbood", 
-               "George", "Hank", "Inki", "James");
-@lastnames = ("Aranow", "Barker", "Corsetti", "Dershowitz", "Engleman", 
-              "Franklin", "Grice", "Haverford", "Ilvedson", "Jones");
-@states = ("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", 
-           "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", 
-           "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", 
-           "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", 
-           "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY");
-
-print "<?xml version=\"1.0\"?>\n";
-print "\n";
-print "<table>\n";
-
-for ($i=0; $i<$size; $i++)
-{
-    $first = $firstnames [$i % 10];
-    $last = $lastnames [($i / 10) % 10];
-    $state = $states [($i / 100) % 50];
-    $zip = 22000 + $i / 5000;
-
-    printf "  <row\n";
-    printf "    id='%04d'\n", $i;
-    printf "    firstname='$first'\n", $i;
-    printf "    lastname='$last'\n", $i;
-    printf "    street='%d Any St.'\n", ($i % 100) + 1;
-    printf "    city='Anytown'\n";
-    printf "    state='$state'\n";
-    printf "    zip='%d'/>\n", $zip;
-}
-
-print "</table>\n";
-
diff --git a/debugXML.c b/debugXML.c
index 90563984..f5ffe60c 100644
--- a/debugXML.c
+++ b/debugXML.c
@@ -14,19 +14,14 @@
 #include <string.h>
 #include <stdlib.h>
 
+#include <libxml/debugXML.h>
 #include <libxml/xmlmemory.h>
 #include <libxml/tree.h>
 #include <libxml/parser.h>
 #include <libxml/parserInternals.h>
-#include <libxml/debugXML.h>
 #include <libxml/HTMLtree.h>
 #include <libxml/HTMLparser.h>
 #include <libxml/xmlerror.h>
-#include <libxml/xpathInternals.h>
-#include <libxml/uri.h>
-#ifdef LIBXML_SCHEMAS_ENABLED
-#include <libxml/relaxng.h>
-#endif
 
 #include "private/error.h"
 
@@ -240,12 +235,10 @@ xmlCtxtCheckName(xmlDebugCtxtPtr ctxt, const xmlChar * name)
 	    xmlDebugErr(ctxt, XML_CHECK_NO_NAME, "Name is NULL");
 	    return;
 	}
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
         if (xmlValidateName(name, 0)) {
 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_NCNAME,
 			 "Name is not an NCName '%s'", (const char *) name);
 	}
-#endif
 	if ((ctxt->dict != NULL) &&
 	    (!xmlDictOwns(ctxt->dict, name)) &&
             ((ctxt->doc == NULL) ||
@@ -274,12 +267,6 @@ xmlCtxtGenericNodeCheck(xmlDebugCtxtPtr ctxt, xmlNodePtr node) {
     } else {
 	dict = doc->dict;
 	if ((dict == NULL) && (ctxt->nodict == 0)) {
-#if 0
-            /* deactivated right now as it raises too many errors */
-	    if (doc->type == XML_DOCUMENT_NODE)
-		xmlDebugErr(ctxt, XML_CHECK_NO_DICT,
-			    "Document has no dictionary\n");
-#endif
 	    ctxt->nodict = 1;
 	}
 	if (ctxt->doc == NULL)
@@ -1570,1763 +1557,4 @@ xmlDebugCheckDocument(FILE * output, xmlDocPtr doc)
     return(ctxt.errors);
 }
 
-/************************************************************************
- *									*
- *			Helpers for Shell				*
- *									*
- ************************************************************************/
-
-/**
- * xmlLsCountNode:
- * @node:  the node to count
- *
- * Count the children of @node.
- *
- * Returns the number of children of @node.
- */
-int
-xmlLsCountNode(xmlNodePtr node) {
-    int ret = 0;
-    xmlNodePtr list = NULL;
-
-    if (node == NULL)
-	return(0);
-
-    switch (node->type) {
-	case XML_ELEMENT_NODE:
-	    list = node->children;
-	    break;
-	case XML_DOCUMENT_NODE:
-	case XML_HTML_DOCUMENT_NODE:
-	    list = ((xmlDocPtr) node)->children;
-	    break;
-	case XML_ATTRIBUTE_NODE:
-	    list = ((xmlAttrPtr) node)->children;
-	    break;
-	case XML_TEXT_NODE:
-	case XML_CDATA_SECTION_NODE:
-	case XML_PI_NODE:
-	case XML_COMMENT_NODE:
-	    if (node->content != NULL) {
-		ret = xmlStrlen(node->content);
-            }
-	    break;
-	case XML_ENTITY_REF_NODE:
-	case XML_DOCUMENT_TYPE_NODE:
-	case XML_ENTITY_NODE:
-	case XML_DOCUMENT_FRAG_NODE:
-	case XML_NOTATION_NODE:
-	case XML_DTD_NODE:
-        case XML_ELEMENT_DECL:
-        case XML_ATTRIBUTE_DECL:
-        case XML_ENTITY_DECL:
-	case XML_NAMESPACE_DECL:
-	case XML_XINCLUDE_START:
-	case XML_XINCLUDE_END:
-	    ret = 1;
-	    break;
-    }
-    for (;list != NULL;ret++)
-        list = list->next;
-    return(ret);
-}
-
-/**
- * xmlLsOneNode:
- * @output:  the FILE * for the output
- * @node:  the node to dump
- *
- * Dump to @output the type and name of @node.
- */
-void
-xmlLsOneNode(FILE *output, xmlNodePtr node) {
-    if (output == NULL) return;
-    if (node == NULL) {
-	fprintf(output, "NULL\n");
-	return;
-    }
-    switch (node->type) {
-	case XML_ELEMENT_NODE:
-	    fprintf(output, "-");
-	    break;
-	case XML_ATTRIBUTE_NODE:
-	    fprintf(output, "a");
-	    break;
-	case XML_TEXT_NODE:
-	    fprintf(output, "t");
-	    break;
-	case XML_CDATA_SECTION_NODE:
-	    fprintf(output, "C");
-	    break;
-	case XML_ENTITY_REF_NODE:
-	    fprintf(output, "e");
-	    break;
-	case XML_ENTITY_NODE:
-	    fprintf(output, "E");
-	    break;
-	case XML_PI_NODE:
-	    fprintf(output, "p");
-	    break;
-	case XML_COMMENT_NODE:
-	    fprintf(output, "c");
-	    break;
-	case XML_DOCUMENT_NODE:
-	    fprintf(output, "d");
-	    break;
-	case XML_HTML_DOCUMENT_NODE:
-	    fprintf(output, "h");
-	    break;
-	case XML_DOCUMENT_TYPE_NODE:
-	    fprintf(output, "T");
-	    break;
-	case XML_DOCUMENT_FRAG_NODE:
-	    fprintf(output, "F");
-	    break;
-	case XML_NOTATION_NODE:
-	    fprintf(output, "N");
-	    break;
-	case XML_NAMESPACE_DECL:
-	    fprintf(output, "n");
-	    break;
-	default:
-	    fprintf(output, "?");
-    }
-    if (node->type != XML_NAMESPACE_DECL) {
-	if (node->properties != NULL)
-	    fprintf(output, "a");
-	else
-	    fprintf(output, "-");
-	if (node->nsDef != NULL)
-	    fprintf(output, "n");
-	else
-	    fprintf(output, "-");
-    }
-
-    fprintf(output, " %8d ", xmlLsCountNode(node));
-
-    switch (node->type) {
-	case XML_ELEMENT_NODE:
-	    if (node->name != NULL) {
-                if ((node->ns != NULL) && (node->ns->prefix != NULL))
-                    fprintf(output, "%s:", node->ns->prefix);
-		fprintf(output, "%s", (const char *) node->name);
-            }
-	    break;
-	case XML_ATTRIBUTE_NODE:
-	    if (node->name != NULL)
-		fprintf(output, "%s", (const char *) node->name);
-	    break;
-	case XML_TEXT_NODE:
-	    if (node->content != NULL) {
-		xmlDebugDumpString(output, node->content);
-            }
-	    break;
-	case XML_CDATA_SECTION_NODE:
-	    break;
-	case XML_ENTITY_REF_NODE:
-	    if (node->name != NULL)
-		fprintf(output, "%s", (const char *) node->name);
-	    break;
-	case XML_ENTITY_NODE:
-	    if (node->name != NULL)
-		fprintf(output, "%s", (const char *) node->name);
-	    break;
-	case XML_PI_NODE:
-	    if (node->name != NULL)
-		fprintf(output, "%s", (const char *) node->name);
-	    break;
-	case XML_COMMENT_NODE:
-	    break;
-	case XML_DOCUMENT_NODE:
-	    break;
-	case XML_HTML_DOCUMENT_NODE:
-	    break;
-	case XML_DOCUMENT_TYPE_NODE:
-	    break;
-	case XML_DOCUMENT_FRAG_NODE:
-	    break;
-	case XML_NOTATION_NODE:
-	    break;
-	case XML_NAMESPACE_DECL: {
-	    xmlNsPtr ns = (xmlNsPtr) node;
-
-	    if (ns->prefix == NULL)
-		fprintf(output, "default -> %s", (char *)ns->href);
-	    else
-		fprintf(output, "%s -> %s", (char *)ns->prefix,
-			(char *)ns->href);
-	    break;
-	}
-	default:
-	    if (node->name != NULL)
-		fprintf(output, "%s", (const char *) node->name);
-    }
-    fprintf(output, "\n");
-}
-
-/**
- * xmlBoolToText:
- * @boolval: a bool to turn into text
- *
- * Convenient way to turn bool into text
- *
- * Returns a pointer to either "True" or "False"
- */
-const char *
-xmlBoolToText(int boolval)
-{
-    if (boolval)
-        return("True");
-    else
-        return("False");
-}
-
-#ifdef LIBXML_XPATH_ENABLED
-/****************************************************************
- *								*
- *		The XML shell related functions			*
- *								*
- ****************************************************************/
-
-
-
-/*
- * TODO: Improvement/cleanups for the XML shell
- *     - allow to shell out an editor on a subpart
- *     - cleanup function registrations (with help) and calling
- *     - provide registration routines
- */
-
-/**
- * xmlShellPrintXPathError:
- * @errorType: valid xpath error id
- * @arg: the argument that cause xpath to fail
- *
- * Print the xpath error to libxml default error channel
- */
-void
-xmlShellPrintXPathError(int errorType, const char *arg)
-{
-    const char *default_arg = "Result";
-
-    if (!arg)
-        arg = default_arg;
-
-    switch (errorType) {
-        case XPATH_UNDEFINED:
-            fprintf(stderr,
-                            "%s: no such node\n", arg);
-            break;
-
-        case XPATH_BOOLEAN:
-            fprintf(stderr,
-                            "%s is a Boolean\n", arg);
-            break;
-        case XPATH_NUMBER:
-            fprintf(stderr,
-                            "%s is a number\n", arg);
-            break;
-        case XPATH_STRING:
-            fprintf(stderr,
-                            "%s is a string\n", arg);
-            break;
-        case XPATH_USERS:
-            fprintf(stderr,
-                            "%s is user-defined\n", arg);
-            break;
-        case XPATH_XSLT_TREE:
-            fprintf(stderr,
-                            "%s is an XSLT value tree\n", arg);
-            break;
-    }
-#if 0
-    fprintf(stderr,
-                    "Try casting the result string function (xpath builtin)\n",
-                    arg);
-#endif
-}
-
-
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * xmlShellPrintNodeCtxt:
- * @ctxt : a non-null shell context
- * @node : a non-null node to print to the output FILE
- *
- * Print node to the output FILE
- */
-static void
-xmlShellPrintNodeCtxt(xmlShellCtxtPtr ctxt,xmlNodePtr node)
-{
-    FILE *fp;
-
-    if (!node)
-        return;
-    if (ctxt == NULL)
-	fp = stdout;
-    else
-	fp = ctxt->output;
-
-    if (node->type == XML_DOCUMENT_NODE)
-        xmlDocDump(fp, (xmlDocPtr) node);
-    else if (node->type == XML_ATTRIBUTE_NODE)
-        xmlDebugDumpAttrList(fp, (xmlAttrPtr) node, 0);
-    else
-        xmlElemDump(fp, node->doc, node);
-
-    fprintf(fp, "\n");
-}
-
-/**
- * xmlShellPrintNode:
- * @node : a non-null node to print to the output FILE
- *
- * Print node to the output FILE
- */
-void
-xmlShellPrintNode(xmlNodePtr node)
-{
-    xmlShellPrintNodeCtxt(NULL, node);
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-/**
- * xmlShellPrintXPathResultCtxt:
- * @ctxt: a valid shell context
- * @list: a valid result generated by an xpath evaluation
- *
- * Prints result to the output FILE
- */
-static void
-xmlShellPrintXPathResultCtxt(xmlShellCtxtPtr ctxt,xmlXPathObjectPtr list)
-{
-    if (!ctxt)
-       return;
-
-    if (list != NULL) {
-        switch (list->type) {
-            case XPATH_NODESET:{
-#ifdef LIBXML_OUTPUT_ENABLED
-                    int indx;
-
-                    if (list->nodesetval) {
-                        for (indx = 0; indx < list->nodesetval->nodeNr;
-                             indx++) {
-                            xmlShellPrintNodeCtxt(ctxt,
-				    list->nodesetval->nodeTab[indx]);
-                        }
-                    } else {
-                        fprintf(ctxt->output,
-                                        "Empty node set\n");
-                    }
-                    break;
-#else
-		    fprintf(ctxt->output,
-				    "Node set\n");
-#endif /* LIBXML_OUTPUT_ENABLED */
-                }
-            case XPATH_BOOLEAN:
-                fprintf(ctxt->output,
-                                "Is a Boolean:%s\n",
-                                xmlBoolToText(list->boolval));
-                break;
-            case XPATH_NUMBER:
-                fprintf(ctxt->output,
-                                "Is a number:%0g\n", list->floatval);
-                break;
-            case XPATH_STRING:
-                fprintf(ctxt->output,
-                                "Is a string:%s\n", list->stringval);
-                break;
-
-            default:
-                xmlShellPrintXPathError(list->type, NULL);
-        }
-    }
-}
-
-/**
- * xmlShellPrintXPathResult:
- * @list: a valid result generated by an xpath evaluation
- *
- * Prints result to the output FILE
- */
-void
-xmlShellPrintXPathResult(xmlXPathObjectPtr list)
-{
-    xmlShellPrintXPathResultCtxt(NULL, list);
-}
-
-/**
- * xmlShellList:
- * @ctxt:  the shell context
- * @arg:  unused
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "ls"
- * Does an Unix like listing of the given node (like a directory)
- *
- * Returns 0
- */
-int
-xmlShellList(xmlShellCtxtPtr ctxt,
-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
-             xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlNodePtr cur;
-    if (!ctxt)
-        return (0);
-    if (node == NULL) {
-	fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-    if ((node->type == XML_DOCUMENT_NODE) ||
-        (node->type == XML_HTML_DOCUMENT_NODE)) {
-        cur = ((xmlDocPtr) node)->children;
-    } else if (node->type == XML_NAMESPACE_DECL) {
-        xmlLsOneNode(ctxt->output, node);
-        return (0);
-    } else if (node->children != NULL) {
-        cur = node->children;
-    } else {
-        xmlLsOneNode(ctxt->output, node);
-        return (0);
-    }
-    while (cur != NULL) {
-        xmlLsOneNode(ctxt->output, cur);
-        cur = cur->next;
-    }
-    return (0);
-}
-
-/**
- * xmlShellBase:
- * @ctxt:  the shell context
- * @arg:  unused
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "base"
- * dumps the current XML base of the node
- *
- * Returns 0
- */
-int
-xmlShellBase(xmlShellCtxtPtr ctxt,
-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
-             xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlChar *base;
-    if (!ctxt)
-        return 0;
-    if (node == NULL) {
-	fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-
-    base = xmlNodeGetBase(node->doc, node);
-
-    if (base == NULL) {
-        fprintf(ctxt->output, " No base found !!!\n");
-    } else {
-        fprintf(ctxt->output, "%s\n", base);
-        xmlFree(base);
-    }
-    return (0);
-}
-
-#ifdef LIBXML_TREE_ENABLED
-/**
- * xmlShellSetBase:
- * @ctxt:  the shell context
- * @arg:  the new base
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "setbase"
- * change the current XML base of the node
- *
- * Returns 0
- */
-static int
-xmlShellSetBase(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
-             xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlNodeSetBase(node, (xmlChar*) arg);
-    return (0);
-}
-#endif
-
-#ifdef LIBXML_XPATH_ENABLED
-/**
- * xmlShellRegisterNamespace:
- * @ctxt:  the shell context
- * @arg:  a string in prefix=nsuri format
- * @node:  unused
- * @node2:  unused
- *
- * Implements the XML shell function "setns"
- * register/unregister a prefix=namespace pair
- * on the XPath context
- *
- * Returns 0 on success and a negative value otherwise.
- */
-static int
-xmlShellRegisterNamespace(xmlShellCtxtPtr ctxt, char *arg,
-      xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlChar* nsListDup;
-    xmlChar* prefix;
-    xmlChar* href;
-    xmlChar* next;
-
-    nsListDup = xmlStrdup((xmlChar *) arg);
-    next = nsListDup;
-    while(next != NULL) {
-	/* skip spaces */
-	/*while((*next) == ' ') next++;*/
-	if((*next) == '\0') break;
-
-	/* find prefix */
-	prefix = next;
-	next = (xmlChar*)xmlStrchr(next, '=');
-	if(next == NULL) {
-	    fprintf(ctxt->output, "setns: prefix=[nsuri] required\n");
-	    xmlFree(nsListDup);
-	    return(-1);
-	}
-	*(next++) = '\0';
-
-	/* find href */
-	href = next;
-	next = (xmlChar*)xmlStrchr(next, ' ');
-	if(next != NULL) {
-	    *(next++) = '\0';
-	}
-
-	/* do register namespace */
-	if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {
-	    fprintf(ctxt->output,"Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", prefix, href);
-	    xmlFree(nsListDup);
-	    return(-1);
-	}
-    }
-
-    xmlFree(nsListDup);
-    return(0);
-}
-/**
- * xmlShellRegisterRootNamespaces:
- * @ctxt:  the shell context
- * @arg:  unused
- * @node:  the root element
- * @node2:  unused
- *
- * Implements the XML shell function "setrootns"
- * which registers all namespaces declarations found on the root element.
- *
- * Returns 0 on success and a negative value otherwise.
- */
-static int
-xmlShellRegisterRootNamespaces(xmlShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,
-      xmlNodePtr root, xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlNsPtr ns;
-
-    if ((root == NULL) || (root->type != XML_ELEMENT_NODE) ||
-        (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))
-	return(-1);
-    ns = root->nsDef;
-    while (ns != NULL) {
-        if (ns->prefix == NULL)
-	    xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST "defaultns", ns->href);
-	else
-	    xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);
-        ns = ns->next;
-    }
-    return(0);
-}
-#endif
-
-/**
- * xmlShellGrep:
- * @ctxt:  the shell context
- * @arg:  the string or regular expression to find
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "grep"
- * dumps information about the node (namespace, attributes, content).
- *
- * Returns 0
- */
-static int
-xmlShellGrep(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
-            char *arg, xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    if (!ctxt)
-        return (0);
-    if (node == NULL)
-	return (0);
-    if (arg == NULL)
-	return (0);
-#ifdef LIBXML_REGEXP_ENABLED
-    if ((xmlStrchr((xmlChar *) arg, '?')) ||
-	(xmlStrchr((xmlChar *) arg, '*')) ||
-	(xmlStrchr((xmlChar *) arg, '.')) ||
-	(xmlStrchr((xmlChar *) arg, '['))) {
-    }
-#endif
-    while (node != NULL) {
-        if (node->type == XML_COMMENT_NODE) {
-	    if (xmlStrstr(node->content, (xmlChar *) arg)) {
-
-		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node));
-                xmlShellList(ctxt, NULL, node, NULL);
-	    }
-        } else if (node->type == XML_TEXT_NODE) {
-	    if (xmlStrstr(node->content, (xmlChar *) arg)) {
-
-		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node->parent));
-                xmlShellList(ctxt, NULL, node->parent, NULL);
-	    }
-        }
-
-        /*
-         * Browse the full subtree, deep first
-         */
-
-        if ((node->type == XML_DOCUMENT_NODE) ||
-            (node->type == XML_HTML_DOCUMENT_NODE)) {
-            node = ((xmlDocPtr) node)->children;
-        } else if ((node->children != NULL)
-                   && (node->type != XML_ENTITY_REF_NODE)) {
-            /* deep first */
-            node = node->children;
-        } else if (node->next != NULL) {
-            /* then siblings */
-            node = node->next;
-        } else {
-            /* go up to parents->next if needed */
-            while (node != NULL) {
-                if (node->parent != NULL) {
-                    node = node->parent;
-                }
-                if (node->next != NULL) {
-                    node = node->next;
-                    break;
-                }
-                if (node->parent == NULL) {
-                    node = NULL;
-                    break;
-                }
-            }
-	}
-    }
-    return (0);
-}
-
-/**
- * xmlShellDir:
- * @ctxt:  the shell context
- * @arg:  unused
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "dir"
- * dumps information about the node (namespace, attributes, content).
- *
- * Returns 0
- */
-int
-xmlShellDir(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
-            char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
-            xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    if (!ctxt)
-        return (0);
-    if (node == NULL) {
-	fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-    if ((node->type == XML_DOCUMENT_NODE) ||
-        (node->type == XML_HTML_DOCUMENT_NODE)) {
-        xmlDebugDumpDocumentHead(ctxt->output, (xmlDocPtr) node);
-    } else if (node->type == XML_ATTRIBUTE_NODE) {
-        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr) node, 0);
-    } else {
-        xmlDebugDumpOneNode(ctxt->output, node, 0);
-    }
-    return (0);
-}
-
-/**
- * xmlShellSetContent:
- * @ctxt:  the shell context
- * @value:  the content as a string
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "dir"
- * dumps information about the node (namespace, attributes, content).
- *
- * Returns 0
- */
-static int
-xmlShellSetContent(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
-            char *value, xmlNodePtr node,
-            xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlNodePtr results;
-    xmlParserErrors ret;
-
-    if (!ctxt)
-        return (0);
-    if (node == NULL) {
-	fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-    if (value == NULL) {
-        fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-
-    ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);
-    if (ret == XML_ERR_OK) {
-	if (node->children != NULL) {
-	    xmlFreeNodeList(node->children);
-	    node->children = NULL;
-	    node->last = NULL;
-	}
-	xmlAddChildList(node, results);
-    } else {
-        fprintf(ctxt->output, "failed to parse content\n");
-    }
-    return (0);
-}
-
-static void
-xmlShellPrintf(void *ctx, const char *msg, ...) {
-    xmlShellCtxtPtr sctxt = ctx;
-    va_list ap;
-
-    va_start(ap, msg);
-    vfprintf(sctxt->output, msg, ap);
-    va_end(ap);
-}
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-/**
- * xmlShellRNGValidate:
- * @ctxt:  the shell context
- * @schemas:  the path to the Relax-NG schemas
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "relaxng"
- * validating the instance against a Relax-NG schemas
- *
- * Returns 0
- */
-static int
-xmlShellRNGValidate(xmlShellCtxtPtr sctxt, char *schemas,
-            xmlNodePtr node ATTRIBUTE_UNUSED,
-	    xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlRelaxNGPtr relaxngschemas;
-    xmlRelaxNGParserCtxtPtr ctxt;
-    xmlRelaxNGValidCtxtPtr vctxt;
-    int ret;
-
-    ctxt = xmlRelaxNGNewParserCtxt(schemas);
-    xmlRelaxNGSetParserErrors(ctxt, xmlShellPrintf, xmlShellPrintf, sctxt);
-    relaxngschemas = xmlRelaxNGParse(ctxt);
-    xmlRelaxNGFreeParserCtxt(ctxt);
-    if (relaxngschemas == NULL) {
-	fprintf(sctxt->output,
-		"Relax-NG schema %s failed to compile\n", schemas);
-	return(-1);
-    }
-    vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);
-    xmlRelaxNGSetValidErrors(vctxt, xmlShellPrintf, xmlShellPrintf, sctxt);
-    ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);
-    if (ret == 0) {
-	fprintf(sctxt->output, "%s validates\n", sctxt->filename);
-    } else if (ret > 0) {
-	fprintf(sctxt->output, "%s fails to validate\n", sctxt->filename);
-    } else {
-	fprintf(sctxt->output, "%s validation generated an internal error\n",
-	       sctxt->filename);
-    }
-    xmlRelaxNGFreeValidCtxt(vctxt);
-    if (relaxngschemas != NULL)
-	xmlRelaxNGFree(relaxngschemas);
-    return(0);
-}
-#endif
-
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * xmlShellCat:
- * @ctxt:  the shell context
- * @arg:  unused
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "cat"
- * dumps the serialization node content (XML or HTML).
- *
- * Returns 0
- */
-int
-xmlShellCat(xmlShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,
-            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    if (!ctxt)
-        return (0);
-    if (node == NULL) {
-	fprintf(ctxt->output, "NULL\n");
-	return (0);
-    }
-    if (ctxt->doc->type == XML_HTML_DOCUMENT_NODE) {
-#ifdef LIBXML_HTML_ENABLED
-        if (node->type == XML_HTML_DOCUMENT_NODE)
-            htmlDocDump(ctxt->output, (htmlDocPtr) node);
-        else
-            htmlNodeDumpFile(ctxt->output, ctxt->doc, node);
-#else
-        if (node->type == XML_DOCUMENT_NODE)
-            xmlDocDump(ctxt->output, (xmlDocPtr) node);
-        else
-            xmlElemDump(ctxt->output, ctxt->doc, node);
-#endif /* LIBXML_HTML_ENABLED */
-    } else {
-        if (node->type == XML_DOCUMENT_NODE)
-            xmlDocDump(ctxt->output, (xmlDocPtr) node);
-        else
-            xmlElemDump(ctxt->output, ctxt->doc, node);
-    }
-    fprintf(ctxt->output, "\n");
-    return (0);
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-/**
- * xmlShellLoad:
- * @ctxt:  the shell context
- * @filename:  the file name
- * @node:  unused
- * @node2:  unused
- *
- * Implements the XML shell function "load"
- * loads a new document specified by the filename
- *
- * Returns 0 or -1 if loading failed
- */
-int
-xmlShellLoad(xmlShellCtxtPtr ctxt, char *filename,
-             xmlNodePtr node ATTRIBUTE_UNUSED,
-             xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlDocPtr doc;
-    int html = 0;
-
-    if ((ctxt == NULL) || (filename == NULL)) return(-1);
-    if (ctxt->doc != NULL)
-        html = (ctxt->doc->type == XML_HTML_DOCUMENT_NODE);
-
-    if (html) {
-#ifdef LIBXML_HTML_ENABLED
-        doc = htmlParseFile(filename, NULL);
-#else
-        fprintf(ctxt->output, "HTML support not compiled in\n");
-        doc = NULL;
-#endif /* LIBXML_HTML_ENABLED */
-    } else {
-        doc = xmlReadFile(filename,NULL,0);
-    }
-    if (doc != NULL) {
-        if (ctxt->loaded == 1) {
-            xmlFreeDoc(ctxt->doc);
-        }
-        ctxt->loaded = 1;
-#ifdef LIBXML_XPATH_ENABLED
-        xmlXPathFreeContext(ctxt->pctxt);
-#endif /* LIBXML_XPATH_ENABLED */
-        xmlFree(ctxt->filename);
-        ctxt->doc = doc;
-        ctxt->node = (xmlNodePtr) doc;
-#ifdef LIBXML_XPATH_ENABLED
-        ctxt->pctxt = xmlXPathNewContext(doc);
-#endif /* LIBXML_XPATH_ENABLED */
-        ctxt->filename = (char *) xmlCanonicPath((xmlChar *) filename);
-    } else
-        return (-1);
-    return (0);
-}
-
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * xmlShellWrite:
- * @ctxt:  the shell context
- * @filename:  the file name
- * @node:  a node in the tree
- * @node2:  unused
- *
- * Implements the XML shell function "write"
- * Write the current node to the filename, it saves the serialization
- * of the subtree under the @node specified
- *
- * Returns 0 or -1 in case of error
- */
-int
-xmlShellWrite(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node,
-              xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    if (node == NULL)
-        return (-1);
-    if ((filename == NULL) || (filename[0] == 0)) {
-        return (-1);
-    }
-#ifdef W_OK
-    if (access((char *) filename, W_OK)) {
-        fprintf(ctxt->output,
-                        "Cannot write to %s\n", filename);
-        return (-1);
-    }
-#endif
-    switch (node->type) {
-        case XML_DOCUMENT_NODE:
-            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
-                fprintf(ctxt->output,
-                                "Failed to write to %s\n", filename);
-                return (-1);
-            }
-            break;
-        case XML_HTML_DOCUMENT_NODE:
-#ifdef LIBXML_HTML_ENABLED
-            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {
-                fprintf(ctxt->output,
-                                "Failed to write to %s\n", filename);
-                return (-1);
-            }
-#else
-            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
-                fprintf(ctxt->output,
-                                "Failed to write to %s\n", filename);
-                return (-1);
-            }
-#endif /* LIBXML_HTML_ENABLED */
-            break;
-        default:{
-                FILE *f;
-
-                f = fopen((char *) filename, "w");
-                if (f == NULL) {
-                    fprintf(ctxt->output,
-                                    "Failed to write to %s\n", filename);
-                    return (-1);
-                }
-                xmlElemDump(f, ctxt->doc, node);
-                fclose(f);
-            }
-    }
-    return (0);
-}
-
-/**
- * xmlShellSave:
- * @ctxt:  the shell context
- * @filename:  the file name (optional)
- * @node:  unused
- * @node2:  unused
- *
- * Implements the XML shell function "save"
- * Write the current document to the filename, or it's original name
- *
- * Returns 0 or -1 in case of error
- */
-int
-xmlShellSave(xmlShellCtxtPtr ctxt, char *filename,
-             xmlNodePtr node ATTRIBUTE_UNUSED,
-             xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    if ((ctxt == NULL) || (ctxt->doc == NULL))
-        return (-1);
-    if ((filename == NULL) || (filename[0] == 0))
-        filename = ctxt->filename;
-    if (filename == NULL)
-        return (-1);
-#ifdef W_OK
-    if (access((char *) filename, W_OK)) {
-        fprintf(ctxt->output,
-                        "Cannot save to %s\n", filename);
-        return (-1);
-    }
-#endif
-    switch (ctxt->doc->type) {
-        case XML_DOCUMENT_NODE:
-            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
-                fprintf(ctxt->output,
-                                "Failed to save to %s\n", filename);
-            }
-            break;
-        case XML_HTML_DOCUMENT_NODE:
-#ifdef LIBXML_HTML_ENABLED
-            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {
-                fprintf(ctxt->output,
-                                "Failed to save to %s\n", filename);
-            }
-#else
-            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
-                fprintf(ctxt->output,
-                                "Failed to save to %s\n", filename);
-            }
-#endif /* LIBXML_HTML_ENABLED */
-            break;
-        default:
-            fprintf(ctxt->output,
-	    "To save to subparts of a document use the 'write' command\n");
-            return (-1);
-
-    }
-    return (0);
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-#ifdef LIBXML_VALID_ENABLED
-/**
- * xmlShellValidate:
- * @ctxt:  the shell context
- * @dtd:  the DTD URI (optional)
- * @node:  unused
- * @node2:  unused
- *
- * Implements the XML shell function "validate"
- * Validate the document, if a DTD path is provided, then the validation
- * is done against the given DTD.
- *
- * Returns 0 or -1 in case of error
- */
-int
-xmlShellValidate(xmlShellCtxtPtr ctxt, char *dtd,
-                 xmlNodePtr node ATTRIBUTE_UNUSED,
-                 xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlValidCtxt vctxt;
-    int res = -1;
-
-    if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);
-    memset(&vctxt, 0, sizeof(vctxt));
-    vctxt.error = xmlShellPrintf;
-    vctxt.warning = xmlShellPrintf;
-    vctxt.userData = ctxt;
-
-    if ((dtd == NULL) || (dtd[0] == 0)) {
-        res = xmlValidateDocument(&vctxt, ctxt->doc);
-    } else {
-        xmlDtdPtr subset;
-
-        subset = xmlParseDTD(NULL, (xmlChar *) dtd);
-        if (subset != NULL) {
-            res = xmlValidateDtd(&vctxt, ctxt->doc, subset);
-
-            xmlFreeDtd(subset);
-        }
-    }
-    return (res);
-}
-#endif /* LIBXML_VALID_ENABLED */
-
-/**
- * xmlShellDu:
- * @ctxt:  the shell context
- * @arg:  unused
- * @tree:  a node defining a subtree
- * @node2:  unused
- *
- * Implements the XML shell function "du"
- * show the structure of the subtree under node @tree
- * If @tree is null, the command works on the current node.
- *
- * Returns 0 or -1 in case of error
- */
-int
-xmlShellDu(xmlShellCtxtPtr ctxt,
-           char *arg ATTRIBUTE_UNUSED, xmlNodePtr tree,
-           xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlNodePtr node;
-    int indent = 0, i;
-
-    if (!ctxt)
-	return (-1);
-
-    if (tree == NULL)
-        return (-1);
-    node = tree;
-    while (node != NULL) {
-        if ((node->type == XML_DOCUMENT_NODE) ||
-            (node->type == XML_HTML_DOCUMENT_NODE)) {
-            fprintf(ctxt->output, "/\n");
-        } else if (node->type == XML_ELEMENT_NODE) {
-            for (i = 0; i < indent; i++)
-                fprintf(ctxt->output, "  ");
-            if ((node->ns) && (node->ns->prefix))
-                fprintf(ctxt->output, "%s:", node->ns->prefix);
-            fprintf(ctxt->output, "%s\n", node->name);
-        } else {
-        }
-
-        /*
-         * Browse the full subtree, deep first
-         */
-
-        if ((node->type == XML_DOCUMENT_NODE) ||
-            (node->type == XML_HTML_DOCUMENT_NODE)) {
-            node = ((xmlDocPtr) node)->children;
-        } else if ((node->children != NULL)
-                   && (node->type != XML_ENTITY_REF_NODE)) {
-            /* deep first */
-            node = node->children;
-            indent++;
-        } else if ((node != tree) && (node->next != NULL)) {
-            /* then siblings */
-            node = node->next;
-        } else if (node != tree) {
-            /* go up to parents->next if needed */
-            while (node != tree) {
-                if (node->parent != NULL) {
-                    node = node->parent;
-                    indent--;
-                }
-                if ((node != tree) && (node->next != NULL)) {
-                    node = node->next;
-                    break;
-                }
-                if (node->parent == NULL) {
-                    node = NULL;
-                    break;
-                }
-                if (node == tree) {
-                    node = NULL;
-                    break;
-                }
-            }
-            /* exit condition */
-            if (node == tree)
-                node = NULL;
-        } else
-            node = NULL;
-    }
-    return (0);
-}
-
-/**
- * xmlShellPwd:
- * @ctxt:  the shell context
- * @buffer:  the output buffer
- * @node:  a node
- * @node2:  unused
- *
- * Implements the XML shell function "pwd"
- * Show the full path from the root to the node, if needed building
- * thumblers when similar elements exists at a given ancestor level.
- * The output is compatible with XPath commands.
- *
- * Returns 0 or -1 in case of error
- */
-int
-xmlShellPwd(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED, char *buffer,
-            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
-{
-    xmlChar *path;
-
-    if ((node == NULL) || (buffer == NULL))
-        return (-1);
-
-    path = xmlGetNodePath(node);
-    if (path == NULL)
-	return (-1);
-
-    /*
-     * This test prevents buffer overflow, because this routine
-     * is only called by xmlShell, in which the second argument is
-     * 500 chars long.
-     * It is a dirty hack before a cleaner solution is found.
-     * Documentation should mention that the second argument must
-     * be at least 500 chars long, and could be stripped if too long.
-     */
-    snprintf(buffer, 499, "%s", path);
-    buffer[499] = '0';
-    xmlFree(path);
-
-    return (0);
-}
-
-/**
- * xmlShell:
- * @doc:  the initial document
- * @filename:  the output buffer
- * @input:  the line reading function
- * @output:  the output FILE*, defaults to stdout if NULL
- *
- * Implements the XML shell
- * This allow to load, validate, view, modify and save a document
- * using a environment similar to a UNIX commandline.
- */
-void
-xmlShell(xmlDocPtr doc, const char *filename, xmlShellReadlineFunc input,
-         FILE * output)
-{
-    char prompt[500] = "/ > ";
-    char *cmdline = NULL, *cur;
-    char command[100];
-    char arg[400];
-    int i;
-    xmlShellCtxtPtr ctxt;
-    xmlXPathObjectPtr list;
-
-    if (doc == NULL)
-        return;
-    if (filename == NULL)
-        return;
-    if (input == NULL)
-        return;
-    if (output == NULL)
-        output = stdout;
-    ctxt = (xmlShellCtxtPtr) xmlMalloc(sizeof(xmlShellCtxt));
-    if (ctxt == NULL)
-        return;
-    ctxt->loaded = 0;
-    ctxt->doc = doc;
-    ctxt->input = input;
-    ctxt->output = output;
-    ctxt->filename = (char *) xmlStrdup((xmlChar *) filename);
-    ctxt->node = (xmlNodePtr) ctxt->doc;
-
-#ifdef LIBXML_XPATH_ENABLED
-    ctxt->pctxt = xmlXPathNewContext(ctxt->doc);
-    if (ctxt->pctxt == NULL) {
-        xmlFree(ctxt);
-        return;
-    }
-#endif /* LIBXML_XPATH_ENABLED */
-    while (1) {
-        if (ctxt->node == (xmlNodePtr) ctxt->doc)
-            snprintf(prompt, sizeof(prompt), "%s > ", "/");
-        else if ((ctxt->node != NULL) && (ctxt->node->name) &&
-                 (ctxt->node->ns) && (ctxt->node->ns->prefix))
-            snprintf(prompt, sizeof(prompt), "%s:%s > ",
-                     (ctxt->node->ns->prefix), ctxt->node->name);
-        else if ((ctxt->node != NULL) && (ctxt->node->name))
-            snprintf(prompt, sizeof(prompt), "%s > ", ctxt->node->name);
-        else
-            snprintf(prompt, sizeof(prompt), "? > ");
-        prompt[sizeof(prompt) - 1] = 0;
-
-        /*
-         * Get a new command line
-         */
-        cmdline = ctxt->input(prompt);
-        if (cmdline == NULL)
-            break;
-
-        /*
-         * Parse the command itself
-         */
-        cur = cmdline;
-        while ((*cur == ' ') || (*cur == '\t'))
-            cur++;
-        i = 0;
-        while ((*cur != ' ') && (*cur != '\t') &&
-               (*cur != '\n') && (*cur != '\r')) {
-            if (*cur == 0)
-                break;
-            command[i++] = *cur++;
-        }
-        command[i] = 0;
-        if (i == 0)
-            continue;
-
-        /*
-         * Parse the argument
-         */
-        while ((*cur == ' ') || (*cur == '\t'))
-            cur++;
-        i = 0;
-        while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {
-            if (*cur == 0)
-                break;
-            arg[i++] = *cur++;
-        }
-        arg[i] = 0;
-
-        /*
-         * start interpreting the command
-         */
-        if (!strcmp(command, "exit"))
-            break;
-        if (!strcmp(command, "quit"))
-            break;
-        if (!strcmp(command, "bye"))
-            break;
-		if (!strcmp(command, "help")) {
-		  fprintf(ctxt->output, "\tbase         display XML base of the node\n");
-		  fprintf(ctxt->output, "\tsetbase URI  change the XML base of the node\n");
-		  fprintf(ctxt->output, "\tbye          leave shell\n");
-		  fprintf(ctxt->output, "\tcat [node]   display node or current node\n");
-		  fprintf(ctxt->output, "\tcd [path]    change directory to path or to root\n");
-		  fprintf(ctxt->output, "\tdir [path]   dumps information about the node (namespace, attributes, content)\n");
-		  fprintf(ctxt->output, "\tdu [path]    show the structure of the subtree under path or the current node\n");
-		  fprintf(ctxt->output, "\texit         leave shell\n");
-		  fprintf(ctxt->output, "\thelp         display this help\n");
-		  fprintf(ctxt->output, "\tfree         display memory usage\n");
-		  fprintf(ctxt->output, "\tload [name]  load a new document with name\n");
-		  fprintf(ctxt->output, "\tls [path]    list contents of path or the current directory\n");
-		  fprintf(ctxt->output, "\tset xml_fragment replace the current node content with the fragment parsed in context\n");
-#ifdef LIBXML_XPATH_ENABLED
-		  fprintf(ctxt->output, "\txpath expr   evaluate the XPath expression in that context and print the result\n");
-		  fprintf(ctxt->output, "\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n");
-		  fprintf(ctxt->output, "\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n");
-		  fprintf(ctxt->output, "\tsetrootns    register all namespace found on the root element\n");
-		  fprintf(ctxt->output, "\t             the default namespace if any uses 'defaultns' prefix\n");
-#endif /* LIBXML_XPATH_ENABLED */
-		  fprintf(ctxt->output, "\tpwd          display current working directory\n");
-		  fprintf(ctxt->output, "\twhereis      display absolute path of [path] or current working directory\n");
-		  fprintf(ctxt->output, "\tquit         leave shell\n");
-#ifdef LIBXML_OUTPUT_ENABLED
-		  fprintf(ctxt->output, "\tsave [name]  save this document to name or the original name\n");
-		  fprintf(ctxt->output, "\twrite [name] write the current node to the filename\n");
-#endif /* LIBXML_OUTPUT_ENABLED */
-#ifdef LIBXML_VALID_ENABLED
-		  fprintf(ctxt->output, "\tvalidate     check the document for errors\n");
-#endif /* LIBXML_VALID_ENABLED */
-#ifdef LIBXML_SCHEMAS_ENABLED
-		  fprintf(ctxt->output, "\trelaxng rng  validate the document against the Relax-NG schemas\n");
-#endif
-		  fprintf(ctxt->output, "\tgrep string  search for a string in the subtree\n");
-#ifdef LIBXML_VALID_ENABLED
-        } else if (!strcmp(command, "validate")) {
-            xmlShellValidate(ctxt, arg, NULL, NULL);
-#endif /* LIBXML_VALID_ENABLED */
-        } else if (!strcmp(command, "load")) {
-            xmlShellLoad(ctxt, arg, NULL, NULL);
-#ifdef LIBXML_SCHEMAS_ENABLED
-        } else if (!strcmp(command, "relaxng")) {
-            xmlShellRNGValidate(ctxt, arg, NULL, NULL);
-#endif
-#ifdef LIBXML_OUTPUT_ENABLED
-        } else if (!strcmp(command, "save")) {
-            xmlShellSave(ctxt, arg, NULL, NULL);
-        } else if (!strcmp(command, "write")) {
-	    if (arg[0] == 0)
-		fprintf(ctxt->output,
-                        "Write command requires a filename argument\n");
-	    else
-		xmlShellWrite(ctxt, arg, ctxt->node, NULL);
-#endif /* LIBXML_OUTPUT_ENABLED */
-        } else if (!strcmp(command, "grep")) {
-            xmlShellGrep(ctxt, arg, ctxt->node, NULL);
-        } else if (!strcmp(command, "pwd")) {
-            char dir[500];
-
-            if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))
-                fprintf(ctxt->output, "%s\n", dir);
-        } else if (!strcmp(command, "du")) {
-            if (arg[0] == 0) {
-                xmlShellDu(ctxt, NULL, ctxt->node, NULL);
-            } else {
-                ctxt->pctxt->node = ctxt->node;
-#ifdef LIBXML_XPATH_ENABLED
-                ctxt->pctxt->node = ctxt->node;
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-#else
-                list = NULL;
-#endif /* LIBXML_XPATH_ENABLED */
-                if (list != NULL) {
-                    switch (list->type) {
-                        case XPATH_UNDEFINED:
-                            fprintf(ctxt->output,
-                                            "%s: no such node\n", arg);
-                            break;
-                        case XPATH_NODESET:{
-                            int indx;
-
-                            if (list->nodesetval == NULL)
-                                break;
-
-                            for (indx = 0;
-                                 indx < list->nodesetval->nodeNr;
-                                 indx++)
-                                xmlShellDu(ctxt, NULL,
-                                           list->nodesetval->
-                                           nodeTab[indx], NULL);
-                            break;
-                        }
-                        case XPATH_BOOLEAN:
-                            fprintf(ctxt->output,
-                                            "%s is a Boolean\n", arg);
-                            break;
-                        case XPATH_NUMBER:
-                            fprintf(ctxt->output,
-                                            "%s is a number\n", arg);
-                            break;
-                        case XPATH_STRING:
-                            fprintf(ctxt->output,
-                                            "%s is a string\n", arg);
-                            break;
-                        case XPATH_USERS:
-                            fprintf(ctxt->output,
-                                            "%s is user-defined\n", arg);
-                            break;
-                        case XPATH_XSLT_TREE:
-                            fprintf(ctxt->output,
-                                            "%s is an XSLT value tree\n",
-                                            arg);
-                            break;
-                    }
-#ifdef LIBXML_XPATH_ENABLED
-                    xmlXPathFreeObject(list);
-#endif
-                } else {
-                    fprintf(ctxt->output,
-                                    "%s: no such node\n", arg);
-                }
-                ctxt->pctxt->node = NULL;
-            }
-        } else if (!strcmp(command, "base")) {
-            xmlShellBase(ctxt, NULL, ctxt->node, NULL);
-        } else if (!strcmp(command, "set")) {
-	    xmlShellSetContent(ctxt, arg, ctxt->node, NULL);
-#ifdef LIBXML_XPATH_ENABLED
-        } else if (!strcmp(command, "setns")) {
-            if (arg[0] == 0) {
-		fprintf(ctxt->output,
-				"setns: prefix=[nsuri] required\n");
-            } else {
-                xmlShellRegisterNamespace(ctxt, arg, NULL, NULL);
-            }
-        } else if (!strcmp(command, "setrootns")) {
-	    xmlNodePtr root;
-
-	    root = xmlDocGetRootElement(ctxt->doc);
-	    xmlShellRegisterRootNamespaces(ctxt, NULL, root, NULL);
-        } else if (!strcmp(command, "xpath")) {
-            if (arg[0] == 0) {
-		fprintf(ctxt->output,
-				"xpath: expression required\n");
-	    } else {
-                ctxt->pctxt->node = ctxt->node;
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-		xmlXPathDebugDumpObject(ctxt->output, list, 0);
-		xmlXPathFreeObject(list);
-	    }
-#endif /* LIBXML_XPATH_ENABLED */
-#ifdef LIBXML_TREE_ENABLED
-        } else if (!strcmp(command, "setbase")) {
-            xmlShellSetBase(ctxt, arg, ctxt->node, NULL);
-#endif
-        } else if ((!strcmp(command, "ls")) || (!strcmp(command, "dir"))) {
-            int dir = (!strcmp(command, "dir"));
-
-            if (arg[0] == 0) {
-                if (dir)
-                    xmlShellDir(ctxt, NULL, ctxt->node, NULL);
-                else
-                    xmlShellList(ctxt, NULL, ctxt->node, NULL);
-            } else {
-                ctxt->pctxt->node = ctxt->node;
-#ifdef LIBXML_XPATH_ENABLED
-                ctxt->pctxt->node = ctxt->node;
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-#else
-                list = NULL;
-#endif /* LIBXML_XPATH_ENABLED */
-                if (list != NULL) {
-                    switch (list->type) {
-                        case XPATH_UNDEFINED:
-                            fprintf(ctxt->output,
-                                            "%s: no such node\n", arg);
-                            break;
-                        case XPATH_NODESET:{
-                                int indx;
-
-				if (list->nodesetval == NULL)
-				    break;
-
-                                for (indx = 0;
-                                     indx < list->nodesetval->nodeNr;
-                                     indx++) {
-                                    if (dir)
-                                        xmlShellDir(ctxt, NULL,
-                                                    list->nodesetval->
-                                                    nodeTab[indx], NULL);
-                                    else
-                                        xmlShellList(ctxt, NULL,
-                                                     list->nodesetval->
-                                                     nodeTab[indx], NULL);
-                                }
-                                break;
-                            }
-                        case XPATH_BOOLEAN:
-                            fprintf(ctxt->output,
-                                            "%s is a Boolean\n", arg);
-                            break;
-                        case XPATH_NUMBER:
-                            fprintf(ctxt->output,
-                                            "%s is a number\n", arg);
-                            break;
-                        case XPATH_STRING:
-                            fprintf(ctxt->output,
-                                            "%s is a string\n", arg);
-                            break;
-                        case XPATH_USERS:
-                            fprintf(ctxt->output,
-                                            "%s is user-defined\n", arg);
-                            break;
-                        case XPATH_XSLT_TREE:
-                            fprintf(ctxt->output,
-                                            "%s is an XSLT value tree\n",
-                                            arg);
-                            break;
-                    }
-#ifdef LIBXML_XPATH_ENABLED
-                    xmlXPathFreeObject(list);
-#endif
-                } else {
-                    fprintf(ctxt->output,
-                                    "%s: no such node\n", arg);
-                }
-                ctxt->pctxt->node = NULL;
-            }
-        } else if (!strcmp(command, "whereis")) {
-            char dir[500];
-
-            if (arg[0] == 0) {
-                if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))
-                    fprintf(ctxt->output, "%s\n", dir);
-            } else {
-                ctxt->pctxt->node = ctxt->node;
-#ifdef LIBXML_XPATH_ENABLED
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-#else
-                list = NULL;
-#endif /* LIBXML_XPATH_ENABLED */
-                if (list != NULL) {
-                    switch (list->type) {
-                        case XPATH_UNDEFINED:
-                            fprintf(ctxt->output,
-                                            "%s: no such node\n", arg);
-                            break;
-                        case XPATH_NODESET:{
-                                int indx;
-
-				if (list->nodesetval == NULL)
-				    break;
-
-                                for (indx = 0;
-                                     indx < list->nodesetval->nodeNr;
-                                     indx++) {
-                                    if (!xmlShellPwd(ctxt, dir, list->nodesetval->
-                                                     nodeTab[indx], NULL))
-                                        fprintf(ctxt->output, "%s\n", dir);
-                                }
-                                break;
-                            }
-                        case XPATH_BOOLEAN:
-                            fprintf(ctxt->output,
-                                            "%s is a Boolean\n", arg);
-                            break;
-                        case XPATH_NUMBER:
-                            fprintf(ctxt->output,
-                                            "%s is a number\n", arg);
-                            break;
-                        case XPATH_STRING:
-                            fprintf(ctxt->output,
-                                            "%s is a string\n", arg);
-                            break;
-                        case XPATH_USERS:
-                            fprintf(ctxt->output,
-                                            "%s is user-defined\n", arg);
-                            break;
-                        case XPATH_XSLT_TREE:
-                            fprintf(ctxt->output,
-                                            "%s is an XSLT value tree\n",
-                                            arg);
-                            break;
-                    }
-#ifdef LIBXML_XPATH_ENABLED
-                    xmlXPathFreeObject(list);
-#endif
-                } else {
-                    fprintf(ctxt->output,
-                                    "%s: no such node\n", arg);
-                }
-                ctxt->pctxt->node = NULL;
-            }
-        } else if (!strcmp(command, "cd")) {
-            if (arg[0] == 0) {
-                ctxt->node = (xmlNodePtr) ctxt->doc;
-            } else {
-#ifdef LIBXML_XPATH_ENABLED
-                int l;
-
-                ctxt->pctxt->node = ctxt->node;
-		l = strlen(arg);
-		if ((l >= 2) && (arg[l - 1] == '/'))
-		    arg[l - 1] = 0;
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-#else
-                list = NULL;
-#endif /* LIBXML_XPATH_ENABLED */
-                if (list != NULL) {
-                    switch (list->type) {
-                        case XPATH_UNDEFINED:
-                            fprintf(ctxt->output,
-                                            "%s: no such node\n", arg);
-                            break;
-                        case XPATH_NODESET:
-                            if (list->nodesetval != NULL) {
-				if (list->nodesetval->nodeNr == 1) {
-				    ctxt->node = list->nodesetval->nodeTab[0];
-				    if ((ctxt->node != NULL) &&
-				        (ctxt->node->type ==
-					 XML_NAMESPACE_DECL)) {
-					fprintf(ctxt->output,
-						    "cannot cd to namespace\n");
-					ctxt->node = NULL;
-				    }
-				} else
-				    fprintf(ctxt->output,
-						    "%s is a %d Node Set\n",
-						    arg,
-						    list->nodesetval->nodeNr);
-                            } else
-                                fprintf(ctxt->output,
-                                                "%s is an empty Node Set\n",
-                                                arg);
-                            break;
-                        case XPATH_BOOLEAN:
-                            fprintf(ctxt->output,
-                                            "%s is a Boolean\n", arg);
-                            break;
-                        case XPATH_NUMBER:
-                            fprintf(ctxt->output,
-                                            "%s is a number\n", arg);
-                            break;
-                        case XPATH_STRING:
-                            fprintf(ctxt->output,
-                                            "%s is a string\n", arg);
-                            break;
-                        case XPATH_USERS:
-                            fprintf(ctxt->output,
-                                            "%s is user-defined\n", arg);
-                            break;
-                        case XPATH_XSLT_TREE:
-                            fprintf(ctxt->output,
-                                            "%s is an XSLT value tree\n",
-                                            arg);
-                            break;
-                    }
-#ifdef LIBXML_XPATH_ENABLED
-                    xmlXPathFreeObject(list);
-#endif
-                } else {
-                    fprintf(ctxt->output,
-                                    "%s: no such node\n", arg);
-                }
-                ctxt->pctxt->node = NULL;
-            }
-#ifdef LIBXML_OUTPUT_ENABLED
-        } else if (!strcmp(command, "cat")) {
-            if (arg[0] == 0) {
-                xmlShellCat(ctxt, NULL, ctxt->node, NULL);
-            } else {
-                ctxt->pctxt->node = ctxt->node;
-#ifdef LIBXML_XPATH_ENABLED
-                ctxt->pctxt->node = ctxt->node;
-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
-#else
-                list = NULL;
-#endif /* LIBXML_XPATH_ENABLED */
-                if (list != NULL) {
-                    switch (list->type) {
-                        case XPATH_UNDEFINED:
-                            fprintf(ctxt->output,
-                                            "%s: no such node\n", arg);
-                            break;
-                        case XPATH_NODESET:{
-                                int indx;
-
-				if (list->nodesetval == NULL)
-				    break;
-
-                                for (indx = 0;
-                                     indx < list->nodesetval->nodeNr;
-                                     indx++) {
-                                    if (i > 0)
-                                        fprintf(ctxt->output, " -------\n");
-                                    xmlShellCat(ctxt, NULL,
-                                                list->nodesetval->
-                                                nodeTab[indx], NULL);
-                                }
-                                break;
-                            }
-                        case XPATH_BOOLEAN:
-                            fprintf(ctxt->output,
-                                            "%s is a Boolean\n", arg);
-                            break;
-                        case XPATH_NUMBER:
-                            fprintf(ctxt->output,
-                                            "%s is a number\n", arg);
-                            break;
-                        case XPATH_STRING:
-                            fprintf(ctxt->output,
-                                            "%s is a string\n", arg);
-                            break;
-                        case XPATH_USERS:
-                            fprintf(ctxt->output,
-                                            "%s is user-defined\n", arg);
-                            break;
-                        case XPATH_XSLT_TREE:
-                            fprintf(ctxt->output,
-                                            "%s is an XSLT value tree\n",
-                                            arg);
-                            break;
-                    }
-#ifdef LIBXML_XPATH_ENABLED
-                    xmlXPathFreeObject(list);
-#endif
-                } else {
-                    fprintf(ctxt->output,
-                                    "%s: no such node\n", arg);
-                }
-                ctxt->pctxt->node = NULL;
-            }
-#endif /* LIBXML_OUTPUT_ENABLED */
-        } else {
-            fprintf(ctxt->output,
-                            "Unknown command %s\n", command);
-        }
-        free(cmdline);          /* not xmlFree here ! */
-	cmdline = NULL;
-    }
-#ifdef LIBXML_XPATH_ENABLED
-    xmlXPathFreeContext(ctxt->pctxt);
-#endif /* LIBXML_XPATH_ENABLED */
-    if (ctxt->loaded) {
-        xmlFreeDoc(ctxt->doc);
-    }
-    if (ctxt->filename != NULL)
-        xmlFree(ctxt->filename);
-    xmlFree(ctxt);
-    if (cmdline != NULL)
-        free(cmdline);          /* not xmlFree here ! */
-}
-
-#endif /* LIBXML_XPATH_ENABLED */
-
 #endif /* LIBXML_DEBUG_ENABLED */
diff --git a/dict.c b/dict.c
index 49e1c6bf..ccd8b542 100644
--- a/dict.c
+++ b/dict.c
@@ -25,6 +25,7 @@
 #include <string.h>
 
 #include "private/dict.h"
+#include "private/error.h"
 #include "private/globals.h"
 #include "private/threads.h"
 
@@ -928,13 +929,9 @@ xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
   #define WIN32_LEAN_AND_MEAN
   #include <windows.h>
   #include <bcrypt.h>
-#elif defined(HAVE_GETENTROPY)
-  #ifdef HAVE_UNISTD_H
-    #include <unistd.h>
-  #endif
-  #ifdef HAVE_SYS_RANDOM_H
-    #include <sys/random.h>
-  #endif
+#elif HAVE_DECL_GETENTROPY
+  #include <unistd.h>
+  #include <sys/random.h>
 #else
   #include <time.h>
 #endif
@@ -960,21 +957,17 @@ xmlInitRandom(void) {
         status = BCryptGenRandom(NULL, (unsigned char *) globalRngState,
                                  sizeof(globalRngState),
                                  BCRYPT_USE_SYSTEM_PREFERRED_RNG);
-        if (!BCRYPT_SUCCESS(status)) {
-            fprintf(stderr, "libxml2: BCryptGenRandom failed with "
-                    "error code %lu\n", GetLastError());
-            abort();
-        }
-#elif defined(HAVE_GETENTROPY)
+        if (!BCRYPT_SUCCESS(status))
+            xmlAbort("libxml2: BCryptGenRandom failed with error code %lu\n",
+                     GetLastError());
+#elif HAVE_DECL_GETENTROPY
         while (1) {
             if (getentropy(globalRngState, sizeof(globalRngState)) == 0)
                 break;
 
-            if (errno != EINTR) {
-                fprintf(stderr, "libxml2: getentropy failed with "
-                        "error code %d\n", errno);
-                abort();
-            }
+            if (errno != EINTR)
+                xmlAbort("libxml2: getentropy failed with error code %d\n",
+                         errno);
         }
 #else
         int var;
diff --git a/doc/apibuild.py b/doc/apibuild.py
index 9255413b..a59b39d8 100755
--- a/doc/apibuild.py
+++ b/doc/apibuild.py
@@ -21,9 +21,7 @@ debugsym=None
 ignored_files = {
   "config.h": "generated portability layer",
   "libxml.h": "internal only",
-  "rngparser.c": "not yet integrated",
   "testModule.c": "test tool",
-  "testThreads.c": "test tool",
   "testapi.c": "generated regression tests",
   "runtest.c": "regression tests program",
   "runsuite.c": "regression tests program",
@@ -32,6 +30,8 @@ ignored_files = {
   "testdso.c": "test for dynamid shared libraries",
   "testrecurse.c": "test for entities recursions",
   "timsort.h": "Internal header only for xpath.c 2.9.0",
+  "nanoftp.h": "empty",
+  "SAX.h": "empty",
 }
 
 ignored_words = {
@@ -58,6 +58,7 @@ ignored_words = {
   "ATTRIBUTE_NO_SANITIZE": (3, "macro keyword"),
   "ATTRIBUTE_NO_SANITIZE_INTEGER": (0, "macro keyword"),
   "XML_DEPRECATED": (0, "macro keyword"),
+  "XML_DEPRECATED_MEMBER": (0, "macro keyword"),
   "XML_GLOBALS_ALLOC": (0, "macro keyword"),
   "XML_GLOBALS_ERROR": (0, "macro keyword"),
   "XML_GLOBALS_IO": (0, "macro keyword"),
@@ -1161,10 +1162,8 @@ class CParser:
                     fname = token[1]
                     token = self.token()
                     if token[0] == "sep" and token[1] == ";":
-                        self.comment = None
                         token = self.token()
-                        fields.append((self.type, fname, self.comment))
-                        self.comment = None
+                        fields.append((self.type, fname))
                     else:
                         self.error("parseStruct: expecting ;", token)
                 elif token != None and token[0] == "sep" and token[1] == "{":
@@ -1714,12 +1713,7 @@ class docBuilder:
                 output.write(">\n");
                 try:
                     for field in self.idx.structs[name].info:
-                        desc = field[2]
-                        if desc == None:
-                            desc = ''
-                        else:
-                            desc = escape(desc)
-                        output.write("      <field name='%s' type='%s' info='%s'/>\n" % (field[1] , field[0], desc))
+                        output.write("      <field name='%s' type='%s'/>\n" % (field[1] , field[0]))
                 except:
                     print("Failed to serialize struct %s" % (name))
                 output.write("    </struct>\n")
diff --git a/doc/libxml2-api.xml b/doc/libxml2-api.xml
index 6ed39fa8..2e857751 100644
--- a/doc/libxml2-api.xml
+++ b/doc/libxml2-api.xml
@@ -112,48 +112,6 @@
      <exports symbol='htmlSaveFileFormat' type='function'/>
      <exports symbol='htmlSetMetaEncoding' type='function'/>
     </file>
-    <file name='SAX'>
-     <summary>Old SAX version 1 handler, deprecated</summary>
-     <description>DEPRECATED set of SAX version 1 interfaces used to build the DOM tree. </description>
-     <author>Daniel Veillard </author>
-     <deprecated/>
-     <exports symbol='attribute' type='function'/>
-     <exports symbol='attributeDecl' type='function'/>
-     <exports symbol='cdataBlock' type='function'/>
-     <exports symbol='characters' type='function'/>
-     <exports symbol='checkNamespace' type='function'/>
-     <exports symbol='comment' type='function'/>
-     <exports symbol='elementDecl' type='function'/>
-     <exports symbol='endDocument' type='function'/>
-     <exports symbol='endElement' type='function'/>
-     <exports symbol='entityDecl' type='function'/>
-     <exports symbol='externalSubset' type='function'/>
-     <exports symbol='getColumnNumber' type='function'/>
-     <exports symbol='getEntity' type='function'/>
-     <exports symbol='getLineNumber' type='function'/>
-     <exports symbol='getNamespace' type='function'/>
-     <exports symbol='getParameterEntity' type='function'/>
-     <exports symbol='getPublicId' type='function'/>
-     <exports symbol='getSystemId' type='function'/>
-     <exports symbol='globalNamespace' type='function'/>
-     <exports symbol='hasExternalSubset' type='function'/>
-     <exports symbol='hasInternalSubset' type='function'/>
-     <exports symbol='ignorableWhitespace' type='function'/>
-     <exports symbol='inithtmlDefaultSAXHandler' type='function'/>
-     <exports symbol='initxmlDefaultSAXHandler' type='function'/>
-     <exports symbol='internalSubset' type='function'/>
-     <exports symbol='isStandalone' type='function'/>
-     <exports symbol='namespaceDecl' type='function'/>
-     <exports symbol='notationDecl' type='function'/>
-     <exports symbol='processingInstruction' type='function'/>
-     <exports symbol='reference' type='function'/>
-     <exports symbol='resolveEntity' type='function'/>
-     <exports symbol='setDocumentLocator' type='function'/>
-     <exports symbol='setNamespace' type='function'/>
-     <exports symbol='startDocument' type='function'/>
-     <exports symbol='startElement' type='function'/>
-     <exports symbol='unparsedEntityDecl' type='function'/>
-    </file>
     <file name='SAX2'>
      <summary>SAX2 parser interface used to build the DOM tree</summary>
      <description>those are the default SAX2 interfaces used by the library when building DOM tree. </description>
@@ -311,10 +269,6 @@
      <summary>Tree debugging APIs</summary>
      <description>Interfaces to a set of routines used for debugging the tree produced by the XML parser. </description>
      <author>Daniel Veillard </author>
-     <exports symbol='xmlShellCtxt' type='typedef'/>
-     <exports symbol='xmlShellCtxtPtr' type='typedef'/>
-     <exports symbol='_xmlShellCtxt' type='struct'/>
-     <exports symbol='xmlBoolToText' type='function'/>
      <exports symbol='xmlDebugCheckDocument' type='function'/>
      <exports symbol='xmlDebugDumpAttr' type='function'/>
      <exports symbol='xmlDebugDumpAttrList' type='function'/>
@@ -326,24 +280,6 @@
      <exports symbol='xmlDebugDumpNodeList' type='function'/>
      <exports symbol='xmlDebugDumpOneNode' type='function'/>
      <exports symbol='xmlDebugDumpString' type='function'/>
-     <exports symbol='xmlLsCountNode' type='function'/>
-     <exports symbol='xmlLsOneNode' type='function'/>
-     <exports symbol='xmlShell' type='function'/>
-     <exports symbol='xmlShellBase' type='function'/>
-     <exports symbol='xmlShellCat' type='function'/>
-     <exports symbol='xmlShellCmd' type='function'/>
-     <exports symbol='xmlShellDir' type='function'/>
-     <exports symbol='xmlShellDu' type='function'/>
-     <exports symbol='xmlShellList' type='function'/>
-     <exports symbol='xmlShellLoad' type='function'/>
-     <exports symbol='xmlShellPrintNode' type='function'/>
-     <exports symbol='xmlShellPrintXPathError' type='function'/>
-     <exports symbol='xmlShellPrintXPathResult' type='function'/>
-     <exports symbol='xmlShellPwd' type='function'/>
-     <exports symbol='xmlShellReadlineFunc' type='function'/>
-     <exports symbol='xmlShellSave' type='function'/>
-     <exports symbol='xmlShellValidate' type='function'/>
-     <exports symbol='xmlShellWrite' type='function'/>
     </file>
     <file name='dict'>
      <summary>string dictionary</summary>
@@ -371,6 +307,12 @@
      <author>Daniel Veillard </author>
      <exports symbol='XML_CHAR_ENCODING_2022_JP' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_8859_1' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_10' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_11' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_13' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_14' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_15' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_8859_16' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_8859_2' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_8859_3' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_8859_4' type='enum'/>
@@ -383,6 +325,7 @@
      <exports symbol='XML_CHAR_ENCODING_EBCDIC' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_ERROR' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_EUC_JP' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_HTML' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_NONE' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_SHIFT_JIS' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UCS2' type='enum'/>
@@ -390,13 +333,13 @@
      <exports symbol='XML_CHAR_ENCODING_UCS4LE' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UCS4_2143' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UCS4_3412' type='enum'/>
+     <exports symbol='XML_CHAR_ENCODING_UTF16' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UTF16BE' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UTF16LE' type='enum'/>
      <exports symbol='XML_CHAR_ENCODING_UTF8' type='enum'/>
      <exports symbol='XML_ENC_ERR_INPUT' type='enum'/>
      <exports symbol='XML_ENC_ERR_INTERNAL' type='enum'/>
      <exports symbol='XML_ENC_ERR_MEMORY' type='enum'/>
-     <exports symbol='XML_ENC_ERR_PARTIAL' type='enum'/>
      <exports symbol='XML_ENC_ERR_SPACE' type='enum'/>
      <exports symbol='XML_ENC_ERR_SUCCESS' type='enum'/>
      <exports symbol='xmlCharEncError' type='typedef'/>
@@ -404,10 +347,14 @@
      <exports symbol='xmlCharEncodingHandler' type='typedef'/>
      <exports symbol='xmlCharEncodingHandlerPtr' type='typedef'/>
      <exports symbol='_xmlCharEncodingHandler' type='struct'/>
+     <exports symbol='xmlCharEncConverter' type='struct'/>
      <exports symbol='UTF8Toisolat1' type='function'/>
      <exports symbol='isolat1ToUTF8' type='function'/>
      <exports symbol='xmlAddEncodingAlias' type='function'/>
      <exports symbol='xmlCharEncCloseFunc' type='function'/>
+     <exports symbol='xmlCharEncConvCtxtDtor' type='function'/>
+     <exports symbol='xmlCharEncConvFunc' type='function'/>
+     <exports symbol='xmlCharEncConvImpl' type='function'/>
      <exports symbol='xmlCharEncFirstLine' type='function'/>
      <exports symbol='xmlCharEncInFunc' type='function'/>
      <exports symbol='xmlCharEncOutFunc' type='function'/>
@@ -415,6 +362,7 @@
      <exports symbol='xmlCharEncodingOutputFunc' type='function'/>
      <exports symbol='xmlCleanupCharEncodingHandlers' type='function'/>
      <exports symbol='xmlCleanupEncodingAliases' type='function'/>
+     <exports symbol='xmlCreateCharEncodingHandler' type='function'/>
      <exports symbol='xmlDelEncodingAlias' type='function'/>
      <exports symbol='xmlDetectCharEncoding' type='function'/>
      <exports symbol='xmlFindCharEncodingHandler' type='function'/>
@@ -445,12 +393,10 @@
      <exports symbol='xmlAddDocEntity' type='function'/>
      <exports symbol='xmlAddDtdEntity' type='function'/>
      <exports symbol='xmlAddEntity' type='function'/>
-     <exports symbol='xmlCleanupPredefinedEntities' type='function'/>
      <exports symbol='xmlCopyEntitiesTable' type='function'/>
      <exports symbol='xmlCreateEntitiesTable' type='function'/>
      <exports symbol='xmlDumpEntitiesTable' type='function'/>
      <exports symbol='xmlDumpEntityDecl' type='function'/>
-     <exports symbol='xmlEncodeEntities' type='function'/>
      <exports symbol='xmlEncodeEntitiesReentrant' type='function'/>
      <exports symbol='xmlEncodeSpecialChars' type='function'/>
      <exports symbol='xmlFreeEntitiesTable' type='function'/>
@@ -459,7 +405,6 @@
      <exports symbol='xmlGetDtdEntity' type='function'/>
      <exports symbol='xmlGetParameterEntity' type='function'/>
      <exports symbol='xmlGetPredefinedEntity' type='function'/>
-     <exports symbol='xmlInitializePredefinedEntities' type='function'/>
      <exports symbol='xmlNewEntity' type='function'/>
     </file>
     <file name='globals'>
@@ -549,38 +494,6 @@
      <exports symbol='xmlListWalk' type='function'/>
      <exports symbol='xmlListWalker' type='function'/>
     </file>
-    <file name='nanoftp'>
-     <summary>minimal FTP implementation</summary>
-     <description>minimal FTP implementation allowing to fetch resources like external subset. This module is DEPRECATED, do not use any of its functions. </description>
-     <author>Daniel Veillard </author>
-     <deprecated/>
-     <exports symbol='INVALID_SOCKET' type='macro'/>
-     <exports symbol='SOCKET' type='macro'/>
-     <exports symbol='ftpDataCallback' type='function'/>
-     <exports symbol='ftpListCallback' type='function'/>
-     <exports symbol='xmlNanoFTPCheckResponse' type='function'/>
-     <exports symbol='xmlNanoFTPCleanup' type='function'/>
-     <exports symbol='xmlNanoFTPClose' type='function'/>
-     <exports symbol='xmlNanoFTPCloseConnection' type='function'/>
-     <exports symbol='xmlNanoFTPConnect' type='function'/>
-     <exports symbol='xmlNanoFTPConnectTo' type='function'/>
-     <exports symbol='xmlNanoFTPCwd' type='function'/>
-     <exports symbol='xmlNanoFTPDele' type='function'/>
-     <exports symbol='xmlNanoFTPFreeCtxt' type='function'/>
-     <exports symbol='xmlNanoFTPGet' type='function'/>
-     <exports symbol='xmlNanoFTPGetConnection' type='function'/>
-     <exports symbol='xmlNanoFTPGetResponse' type='function'/>
-     <exports symbol='xmlNanoFTPGetSocket' type='function'/>
-     <exports symbol='xmlNanoFTPInit' type='function'/>
-     <exports symbol='xmlNanoFTPList' type='function'/>
-     <exports symbol='xmlNanoFTPNewCtxt' type='function'/>
-     <exports symbol='xmlNanoFTPOpen' type='function'/>
-     <exports symbol='xmlNanoFTPProxy' type='function'/>
-     <exports symbol='xmlNanoFTPQuit' type='function'/>
-     <exports symbol='xmlNanoFTPRead' type='function'/>
-     <exports symbol='xmlNanoFTPScanProxy' type='function'/>
-     <exports symbol='xmlNanoFTPUpdateURL' type='function'/>
-    </file>
     <file name='nanohttp'>
      <summary>minimal HTTP implementation</summary>
      <description>minimal HTTP implementation allowing to fetch resources like external subset. </description>
@@ -608,7 +521,15 @@
      <description>Interfaces, constants and types related to the XML parser </description>
      <author>Daniel Veillard </author>
      <exports symbol='XML_DEFAULT_VERSION' type='macro'/>
+     <exports symbol='XML_INPUT_BUF_STATIC' type='macro'/>
+     <exports symbol='XML_INPUT_BUF_ZERO_TERMINATED' type='macro'/>
+     <exports symbol='XML_INPUT_NETWORK' type='macro'/>
+     <exports symbol='XML_INPUT_UNZIP' type='macro'/>
      <exports symbol='XML_SAX2_MAGIC' type='macro'/>
+     <exports symbol='XML_STATUS_CATASTROPHIC_ERROR' type='macro'/>
+     <exports symbol='XML_STATUS_DTD_VALIDATION_FAILED' type='macro'/>
+     <exports symbol='XML_STATUS_NOT_NS_WELL_FORMED' type='macro'/>
+     <exports symbol='XML_STATUS_NOT_WELL_FORMED' type='macro'/>
      <exports symbol='XML_PARSER_ATTRIBUTE_VALUE' type='enum'/>
      <exports symbol='XML_PARSER_CDATA_SECTION' type='enum'/>
      <exports symbol='XML_PARSER_COMMENT' type='enum'/>
@@ -645,6 +566,9 @@
      <exports symbol='XML_PARSE_NONET' type='enum'/>
      <exports symbol='XML_PARSE_NOWARNING' type='enum'/>
      <exports symbol='XML_PARSE_NOXINCNODE' type='enum'/>
+     <exports symbol='XML_PARSE_NO_CATALOG_PI' type='enum'/>
+     <exports symbol='XML_PARSE_NO_SYS_CATALOG' type='enum'/>
+     <exports symbol='XML_PARSE_NO_UNZIP' type='enum'/>
      <exports symbol='XML_PARSE_NO_XXE' type='enum'/>
      <exports symbol='XML_PARSE_NSCLEAN' type='enum'/>
      <exports symbol='XML_PARSE_OLD10' type='enum'/>
@@ -658,6 +582,13 @@
      <exports symbol='XML_PARSE_SAX1' type='enum'/>
      <exports symbol='XML_PARSE_UNKNOWN' type='enum'/>
      <exports symbol='XML_PARSE_XINCLUDE' type='enum'/>
+     <exports symbol='XML_RESOURCE_DTD' type='enum'/>
+     <exports symbol='XML_RESOURCE_GENERAL_ENTITY' type='enum'/>
+     <exports symbol='XML_RESOURCE_MAIN_DOCUMENT' type='enum'/>
+     <exports symbol='XML_RESOURCE_PARAMETER_ENTITY' type='enum'/>
+     <exports symbol='XML_RESOURCE_UNKNOWN' type='enum'/>
+     <exports symbol='XML_RESOURCE_XINCLUDE' type='enum'/>
+     <exports symbol='XML_RESOURCE_XINCLUDE_TEXT' type='enum'/>
      <exports symbol='XML_WITH_AUTOMATA' type='enum'/>
      <exports symbol='XML_WITH_C14N' type='enum'/>
      <exports symbol='XML_WITH_CATALOG' type='enum'/>
@@ -702,6 +633,7 @@
      <exports symbol='xmlParserNodeInfoSeqPtr' type='typedef'/>
      <exports symbol='xmlParserNsData' type='typedef'/>
      <exports symbol='xmlParserOption' type='typedef'/>
+     <exports symbol='xmlResourceType' type='typedef'/>
      <exports symbol='xmlSAXHandlerV1' type='typedef'/>
      <exports symbol='xmlSAXHandlerV1Ptr' type='typedef'/>
      <exports symbol='xmlStartTag' type='typedef'/>
@@ -755,6 +687,15 @@
      <exports symbol='xmlCreateDocParserCtxt' type='function'/>
      <exports symbol='xmlCreateIOParserCtxt' type='function'/>
      <exports symbol='xmlCreatePushParserCtxt' type='function'/>
+     <exports symbol='xmlCtxtGetCatalogs' type='function'/>
+     <exports symbol='xmlCtxtGetDeclaredEncoding' type='function'/>
+     <exports symbol='xmlCtxtGetDict' type='function'/>
+     <exports symbol='xmlCtxtGetOptions' type='function'/>
+     <exports symbol='xmlCtxtGetPrivate' type='function'/>
+     <exports symbol='xmlCtxtGetStandalone' type='function'/>
+     <exports symbol='xmlCtxtGetStatus' type='function'/>
+     <exports symbol='xmlCtxtGetVersion' type='function'/>
+     <exports symbol='xmlCtxtParseContent' type='function'/>
      <exports symbol='xmlCtxtParseDocument' type='function'/>
      <exports symbol='xmlCtxtReadDoc' type='function'/>
      <exports symbol='xmlCtxtReadFd' type='function'/>
@@ -763,25 +704,34 @@
      <exports symbol='xmlCtxtReadMemory' type='function'/>
      <exports symbol='xmlCtxtReset' type='function'/>
      <exports symbol='xmlCtxtResetPush' type='function'/>
+     <exports symbol='xmlCtxtSetCatalogs' type='function'/>
+     <exports symbol='xmlCtxtSetCharEncConvImpl' type='function'/>
+     <exports symbol='xmlCtxtSetDict' type='function'/>
      <exports symbol='xmlCtxtSetErrorHandler' type='function'/>
      <exports symbol='xmlCtxtSetMaxAmplification' type='function'/>
      <exports symbol='xmlCtxtSetOptions' type='function'/>
+     <exports symbol='xmlCtxtSetPrivate' type='function'/>
+     <exports symbol='xmlCtxtSetResourceLoader' type='function'/>
      <exports symbol='xmlCtxtUseOptions' type='function'/>
      <exports symbol='xmlExternalEntityLoader' type='function'/>
      <exports symbol='xmlFreeParserCtxt' type='function'/>
      <exports symbol='xmlGetExternalEntityLoader' type='function'/>
-     <exports symbol='xmlGetFeature' type='function'/>
-     <exports symbol='xmlGetFeaturesList' type='function'/>
      <exports symbol='xmlHasFeature' type='function'/>
      <exports symbol='xmlIOParseDTD' type='function'/>
      <exports symbol='xmlInitGlobals' type='function'/>
      <exports symbol='xmlInitNodeInfoSeq' type='function'/>
      <exports symbol='xmlInitParser' type='function'/>
      <exports symbol='xmlInitParserCtxt' type='function'/>
+     <exports symbol='xmlInputSetEncodingHandler' type='function'/>
      <exports symbol='xmlKeepBlanksDefault' type='function'/>
      <exports symbol='xmlLineNumbersDefault' type='function'/>
      <exports symbol='xmlLoadExternalEntity' type='function'/>
      <exports symbol='xmlNewIOInputStream' type='function'/>
+     <exports symbol='xmlNewInputFromFd' type='function'/>
+     <exports symbol='xmlNewInputFromIO' type='function'/>
+     <exports symbol='xmlNewInputFromMemory' type='function'/>
+     <exports symbol='xmlNewInputFromString' type='function'/>
+     <exports symbol='xmlNewInputFromUrl' type='function'/>
      <exports symbol='xmlNewParserCtxt' type='function'/>
      <exports symbol='xmlNewSAXParserCtxt' type='function'/>
      <exports symbol='xmlParseBalancedChunkMemory' type='function'/>
@@ -812,6 +762,7 @@
      <exports symbol='xmlRecoverDoc' type='function'/>
      <exports symbol='xmlRecoverFile' type='function'/>
      <exports symbol='xmlRecoverMemory' type='function'/>
+     <exports symbol='xmlResourceLoader' type='function'/>
      <exports symbol='xmlSAXParseDTD' type='function'/>
      <exports symbol='xmlSAXParseDoc' type='function'/>
      <exports symbol='xmlSAXParseEntity' type='function'/>
@@ -822,7 +773,6 @@
      <exports symbol='xmlSAXUserParseFile' type='function'/>
      <exports symbol='xmlSAXUserParseMemory' type='function'/>
      <exports symbol='xmlSetExternalEntityLoader' type='function'/>
-     <exports symbol='xmlSetFeature' type='function'/>
      <exports symbol='xmlSetupParserForBuffer' type='function'/>
      <exports symbol='xmlStopParser' type='function'/>
      <exports symbol='xmlSubstituteEntitiesDefault' type='function'/>
@@ -888,14 +838,8 @@
      <exports symbol='xmlCreateURLParserCtxt' type='function'/>
      <exports symbol='xmlCtxtErrMemory' type='function'/>
      <exports symbol='xmlCurrentChar' type='function'/>
-     <exports symbol='xmlDecodeEntities' type='function'/>
-     <exports symbol='xmlEntityReferenceFunc' type='function'/>
      <exports symbol='xmlFreeInputStream' type='function'/>
-     <exports symbol='xmlHandleEntity' type='function'/>
      <exports symbol='xmlIsLetter' type='function'/>
-     <exports symbol='xmlNamespaceParseNCName' type='function'/>
-     <exports symbol='xmlNamespaceParseNSDef' type='function'/>
-     <exports symbol='xmlNamespaceParseQName' type='function'/>
      <exports symbol='xmlNewEntityInputStream' type='function'/>
      <exports symbol='xmlNewInputFromFile' type='function'/>
      <exports symbol='xmlNewInputStream' type='function'/>
@@ -930,7 +874,6 @@
      <exports symbol='xmlParseMarkupDecl' type='function'/>
      <exports symbol='xmlParseMisc' type='function'/>
      <exports symbol='xmlParseName' type='function'/>
-     <exports symbol='xmlParseNamespace' type='function'/>
      <exports symbol='xmlParseNmtoken' type='function'/>
      <exports symbol='xmlParseNotationDecl' type='function'/>
      <exports symbol='xmlParseNotationType' type='function'/>
@@ -938,7 +881,6 @@
      <exports symbol='xmlParsePI' type='function'/>
      <exports symbol='xmlParsePITarget' type='function'/>
      <exports symbol='xmlParsePubidLiteral' type='function'/>
-     <exports symbol='xmlParseQuotedString' type='function'/>
      <exports symbol='xmlParseReference' type='function'/>
      <exports symbol='xmlParseSDDecl' type='function'/>
      <exports symbol='xmlParseStartTag' type='function'/>
@@ -948,12 +890,9 @@
      <exports symbol='xmlParseVersionNum' type='function'/>
      <exports symbol='xmlParseXMLDecl' type='function'/>
      <exports symbol='xmlParserHandlePEReference' type='function'/>
-     <exports symbol='xmlParserHandleReference' type='function'/>
      <exports symbol='xmlParserInputShrink' type='function'/>
      <exports symbol='xmlPopInput' type='function'/>
      <exports symbol='xmlPushInput' type='function'/>
-     <exports symbol='xmlScanName' type='function'/>
-     <exports symbol='xmlSetEntityReferenceFunc' type='function'/>
      <exports symbol='xmlSkipBlankChars' type='function'/>
      <exports symbol='xmlSplitQName' type='function'/>
      <exports symbol='xmlStringCurrentChar' type='function'/>
@@ -1065,6 +1004,7 @@
      <exports symbol='xmlRelaxNGParse' type='function'/>
      <exports symbol='xmlRelaxNGSetParserErrors' type='function'/>
      <exports symbol='xmlRelaxNGSetParserStructuredErrors' type='function'/>
+     <exports symbol='xmlRelaxNGSetResourceLoader' type='function'/>
      <exports symbol='xmlRelaxNGSetValidErrors' type='function'/>
      <exports symbol='xmlRelaxNGSetValidStructuredErrors' type='function'/>
      <exports symbol='xmlRelaxNGValidateDoc' type='function'/>
@@ -1602,7 +1542,6 @@
      <exports symbol='xmlNewDocText' type='function'/>
      <exports symbol='xmlNewDocTextLen' type='function'/>
      <exports symbol='xmlNewDtd' type='function'/>
-     <exports symbol='xmlNewGlobalNs' type='function'/>
      <exports symbol='xmlNewNode' type='function'/>
      <exports symbol='xmlNewNodeEatName' type='function'/>
      <exports symbol='xmlNewNs' type='function'/>
@@ -1822,6 +1761,7 @@
      <exports symbol='xmlXIncludeProcessTreeFlagsData' type='function'/>
      <exports symbol='xmlXIncludeSetErrorHandler' type='function'/>
      <exports symbol='xmlXIncludeSetFlags' type='function'/>
+     <exports symbol='xmlXIncludeSetResourceLoader' type='function'/>
     </file>
     <file name='xlink'>
      <summary>unfinished XLink detection module</summary>
@@ -1874,10 +1814,6 @@
      <exports symbol='xmlFileOpen' type='function'/>
      <exports symbol='xmlFileRead' type='function'/>
      <exports symbol='xmlFreeParserInputBuffer' type='function'/>
-     <exports symbol='xmlIOFTPClose' type='function'/>
-     <exports symbol='xmlIOFTPMatch' type='function'/>
-     <exports symbol='xmlIOFTPOpen' type='function'/>
-     <exports symbol='xmlIOFTPRead' type='function'/>
      <exports symbol='xmlIOHTTPClose' type='function'/>
      <exports symbol='xmlIOHTTPMatch' type='function'/>
      <exports symbol='xmlIOHTTPOpen' type='function'/>
@@ -2945,6 +2881,7 @@
      <exports symbol='xmlTextReaderSetErrorHandler' type='function'/>
      <exports symbol='xmlTextReaderSetMaxAmplification' type='function'/>
      <exports symbol='xmlTextReaderSetParserProp' type='function'/>
+     <exports symbol='xmlTextReaderSetResourceLoader' type='function'/>
      <exports symbol='xmlTextReaderSetSchema' type='function'/>
      <exports symbol='xmlTextReaderSetStructuredErrorHandler' type='function'/>
      <exports symbol='xmlTextReaderSetup' type='function'/>
@@ -2956,42 +2893,10 @@
      <summary>regular expressions handling</summary>
      <description>basic API for libxml regular expressions handling used for XML Schemas and validation. </description>
      <author>Daniel Veillard </author>
-     <exports symbol='XML_EXP_ATOM' type='enum'/>
-     <exports symbol='XML_EXP_COUNT' type='enum'/>
-     <exports symbol='XML_EXP_EMPTY' type='enum'/>
-     <exports symbol='XML_EXP_FORBID' type='enum'/>
-     <exports symbol='XML_EXP_OR' type='enum'/>
-     <exports symbol='XML_EXP_SEQ' type='enum'/>
-     <exports symbol='xmlExpCtxt' type='typedef'/>
-     <exports symbol='xmlExpCtxtPtr' type='typedef'/>
-     <exports symbol='xmlExpNode' type='typedef'/>
-     <exports symbol='xmlExpNodePtr' type='typedef'/>
-     <exports symbol='xmlExpNodeType' type='typedef'/>
      <exports symbol='xmlRegExecCtxt' type='typedef'/>
      <exports symbol='xmlRegExecCtxtPtr' type='typedef'/>
      <exports symbol='xmlRegexp' type='typedef'/>
      <exports symbol='xmlRegexpPtr' type='typedef'/>
-     <exports symbol='emptyExp' type='variable'/>
-     <exports symbol='forbiddenExp' type='variable'/>
-     <exports symbol='xmlExpCtxtNbCons' type='function'/>
-     <exports symbol='xmlExpCtxtNbNodes' type='function'/>
-     <exports symbol='xmlExpDump' type='function'/>
-     <exports symbol='xmlExpExpDerive' type='function'/>
-     <exports symbol='xmlExpFree' type='function'/>
-     <exports symbol='xmlExpFreeCtxt' type='function'/>
-     <exports symbol='xmlExpGetLanguage' type='function'/>
-     <exports symbol='xmlExpGetStart' type='function'/>
-     <exports symbol='xmlExpIsNillable' type='function'/>
-     <exports symbol='xmlExpMaxToken' type='function'/>
-     <exports symbol='xmlExpNewAtom' type='function'/>
-     <exports symbol='xmlExpNewCtxt' type='function'/>
-     <exports symbol='xmlExpNewOr' type='function'/>
-     <exports symbol='xmlExpNewRange' type='function'/>
-     <exports symbol='xmlExpNewSeq' type='function'/>
-     <exports symbol='xmlExpParse' type='function'/>
-     <exports symbol='xmlExpRef' type='function'/>
-     <exports symbol='xmlExpStringDerive' type='function'/>
-     <exports symbol='xmlExpSubsume' type='function'/>
      <exports symbol='xmlRegExecCallbacks' type='function'/>
      <exports symbol='xmlRegExecErrInfo' type='function'/>
      <exports symbol='xmlRegExecNextValues' type='function'/>
@@ -3011,9 +2916,12 @@
      <author>Daniel Veillard </author>
      <exports symbol='XML_SAVE_AS_HTML' type='enum'/>
      <exports symbol='XML_SAVE_AS_XML' type='enum'/>
+     <exports symbol='XML_SAVE_EMPTY' type='enum'/>
      <exports symbol='XML_SAVE_FORMAT' type='enum'/>
+     <exports symbol='XML_SAVE_INDENT' type='enum'/>
      <exports symbol='XML_SAVE_NO_DECL' type='enum'/>
      <exports symbol='XML_SAVE_NO_EMPTY' type='enum'/>
+     <exports symbol='XML_SAVE_NO_INDENT' type='enum'/>
      <exports symbol='XML_SAVE_NO_XHTML' type='enum'/>
      <exports symbol='XML_SAVE_WSNONSIG' type='enum'/>
      <exports symbol='XML_SAVE_XHTML' type='enum'/>
@@ -3026,6 +2934,7 @@
      <exports symbol='xmlSaveFlush' type='function'/>
      <exports symbol='xmlSaveSetAttrEscape' type='function'/>
      <exports symbol='xmlSaveSetEscape' type='function'/>
+     <exports symbol='xmlSaveSetIndentString' type='function'/>
      <exports symbol='xmlSaveToBuffer' type='function'/>
      <exports symbol='xmlSaveToFd' type='function'/>
      <exports symbol='xmlSaveToFilename' type='function'/>
@@ -3092,6 +3001,7 @@
      <exports symbol='xmlSchemaSAXUnplug' type='function'/>
      <exports symbol='xmlSchemaSetParserErrors' type='function'/>
      <exports symbol='xmlSchemaSetParserStructuredErrors' type='function'/>
+     <exports symbol='xmlSchemaSetResourceLoader' type='function'/>
      <exports symbol='xmlSchemaSetValidErrors' type='function'/>
      <exports symbol='xmlSchemaSetValidOptions' type='function'/>
      <exports symbol='xmlSchemaSetValidStructuredErrors' type='function'/>
@@ -3368,7 +3278,6 @@
      <exports symbol='LIBXML_CATALOG_ENABLED' type='macro'/>
      <exports symbol='LIBXML_DEBUG_ENABLED' type='macro'/>
      <exports symbol='LIBXML_DOTTED_VERSION' type='macro'/>
-     <exports symbol='LIBXML_FTP_ENABLED' type='macro'/>
      <exports symbol='LIBXML_HTML_ENABLED' type='macro'/>
      <exports symbol='LIBXML_HTTP_ENABLED' type='macro'/>
      <exports symbol='LIBXML_ICONV_ENABLED' type='macro'/>
@@ -3399,7 +3308,6 @@
      <exports symbol='LIBXML_XINCLUDE_ENABLED' type='macro'/>
      <exports symbol='LIBXML_XPATH_ENABLED' type='macro'/>
      <exports symbol='LIBXML_XPTR_ENABLED' type='macro'/>
-     <exports symbol='LIBXML_XPTR_LOCS_ENABLED' type='macro'/>
      <exports symbol='LIBXML_ZLIB_ENABLED' type='macro'/>
     </file>
     <file name='xmlwriter'>
@@ -3514,14 +3422,11 @@
      <exports symbol='XPATH_INVALID_OPERAND' type='enum'/>
      <exports symbol='XPATH_INVALID_PREDICATE_ERROR' type='enum'/>
      <exports symbol='XPATH_INVALID_TYPE' type='enum'/>
-     <exports symbol='XPATH_LOCATIONSET' type='enum'/>
      <exports symbol='XPATH_MEMORY_ERROR' type='enum'/>
      <exports symbol='XPATH_NODESET' type='enum'/>
      <exports symbol='XPATH_NUMBER' type='enum'/>
      <exports symbol='XPATH_NUMBER_ERROR' type='enum'/>
      <exports symbol='XPATH_OP_LIMIT_EXCEEDED' type='enum'/>
-     <exports symbol='XPATH_POINT' type='enum'/>
-     <exports symbol='XPATH_RANGE' type='enum'/>
      <exports symbol='XPATH_RECURSION_LIMIT_EXCEEDED' type='enum'/>
      <exports symbol='XPATH_STACK_ERROR' type='enum'/>
      <exports symbol='XPATH_START_LITERAL_ERROR' type='enum'/>
@@ -3772,30 +3677,8 @@
      <summary>API to handle XML Pointers</summary>
      <description>API to handle XML Pointers Base implementation was made accordingly to W3C Candidate Recommendation 7 June 2000</description>
      <author>Daniel Veillard </author>
-     <exports symbol='xmlLocationSet' type='typedef'/>
-     <exports symbol='xmlLocationSetPtr' type='typedef'/>
-     <exports symbol='_xmlLocationSet' type='struct'/>
-     <exports symbol='xmlXPtrBuildNodeList' type='function'/>
      <exports symbol='xmlXPtrEval' type='function'/>
-     <exports symbol='xmlXPtrEvalRangePredicate' type='function'/>
-     <exports symbol='xmlXPtrFreeLocationSet' type='function'/>
-     <exports symbol='xmlXPtrLocationSetAdd' type='function'/>
-     <exports symbol='xmlXPtrLocationSetCreate' type='function'/>
-     <exports symbol='xmlXPtrLocationSetDel' type='function'/>
-     <exports symbol='xmlXPtrLocationSetMerge' type='function'/>
-     <exports symbol='xmlXPtrLocationSetRemove' type='function'/>
-     <exports symbol='xmlXPtrNewCollapsedRange' type='function'/>
      <exports symbol='xmlXPtrNewContext' type='function'/>
-     <exports symbol='xmlXPtrNewLocationSetNodeSet' type='function'/>
-     <exports symbol='xmlXPtrNewLocationSetNodes' type='function'/>
-     <exports symbol='xmlXPtrNewRange' type='function'/>
-     <exports symbol='xmlXPtrNewRangeNodeObject' type='function'/>
-     <exports symbol='xmlXPtrNewRangeNodePoint' type='function'/>
-     <exports symbol='xmlXPtrNewRangeNodes' type='function'/>
-     <exports symbol='xmlXPtrNewRangePointNode' type='function'/>
-     <exports symbol='xmlXPtrNewRangePoints' type='function'/>
-     <exports symbol='xmlXPtrRangeToFunction' type='function'/>
-     <exports symbol='xmlXPtrWrapLocationSet' type='function'/>
     </file>
   </files>
   <symbols>
@@ -3850,9 +3733,6 @@
     <macro name='INPUT_CHUNK' file='parserInternals'>
       <info>The parser tries to always have that amount of input ready. One of the point is providing context when reporting errors.</info>
     </macro>
-    <macro name='INVALID_SOCKET' file='nanoftp'>
-      <info>macro used to provide portability of code to windows sockets the value to be used when the socket is not valid</info>
-    </macro>
     <macro name='IS_ASCII_DIGIT' file='parserInternals'>
       <info>Macro to check [0-9]</info>
       <arg name='c' info='an xmlChar value'/>
@@ -3947,9 +3827,6 @@
     <macro name='LIBXML_DOTTED_VERSION' file='xmlversion'>
       <info>the version string like &quot;1.2.3&quot;</info>
     </macro>
-    <macro name='LIBXML_FTP_ENABLED' file='xmlversion'>
-      <info>Whether the FTP support is configured in</info>
-    </macro>
     <macro name='LIBXML_HTML_ENABLED' file='xmlversion'>
       <info>Whether the HTML support is configured in</info>
     </macro>
@@ -4011,7 +3888,7 @@
       <info>Whether the thread support is configured in</info>
     </macro>
     <macro name='LIBXML_TREE_ENABLED' file='xmlversion'>
-      <info>Whether the DOM like tree manipulation API support is configured in</info>
+      <info>Always enabled since 2.14.0</info>
     </macro>
     <macro name='LIBXML_UNICODE_ENABLED' file='xmlversion'>
       <info>Whether the Unicode related interfaces are compiled in</info>
@@ -4040,15 +3917,9 @@
     <macro name='LIBXML_XPTR_ENABLED' file='xmlversion'>
       <info>Whether XPointer is configured in</info>
     </macro>
-    <macro name='LIBXML_XPTR_LOCS_ENABLED' file='xmlversion'>
-      <info>Whether support for XPointer locations is configured in</info>
-    </macro>
     <macro name='LIBXML_ZLIB_ENABLED' file='xmlversion'>
       <info>Whether the Zlib support is compiled in</info>
     </macro>
-    <macro name='SOCKET' file='nanoftp'>
-      <info>macro used to provide portability of code to windows sockets</info>
-    </macro>
     <macro name='XINCLUDE_FALLBACK' file='xinclude'>
       <info>Macro defining &quot;fallback&quot;</info>
     </macro>
@@ -4098,6 +3969,14 @@
     <macro name='XML_GET_LINE' file='tree'>
       <info>Macro to extract the line number of an element node.</info>
     </macro>
+    <macro name='XML_INPUT_BUF_STATIC' file='parser'>
+    </macro>
+    <macro name='XML_INPUT_BUF_ZERO_TERMINATED' file='parser'>
+    </macro>
+    <macro name='XML_INPUT_NETWORK' file='parser'>
+    </macro>
+    <macro name='XML_INPUT_UNZIP' file='parser'>
+    </macro>
     <macro name='XML_LOCAL_NAMESPACE' file='tree'>
       <info>A namespace declaration node.</info>
     </macro>
@@ -4368,6 +4247,14 @@
     <macro name='XML_SCHEMAS_WILDCARD_COMPLETE' file='schemasInternals'>
       <info>If the wildcard is complete.</info>
     </macro>
+    <macro name='XML_STATUS_CATASTROPHIC_ERROR' file='parser'>
+    </macro>
+    <macro name='XML_STATUS_DTD_VALIDATION_FAILED' file='parser'>
+    </macro>
+    <macro name='XML_STATUS_NOT_NS_WELL_FORMED' file='parser'>
+    </macro>
+    <macro name='XML_STATUS_NOT_WELL_FORMED' file='parser'>
+    </macro>
     <macro name='XML_SUBSTITUTE_BOTH' file='parserInternals'>
       <info>Both general and parameter entities need to be substituted.</info>
     </macro>
@@ -4649,6 +4536,12 @@
     <enum name='XML_CDATA_SECTION_NODE' file='tree' value='4' type='xmlElementType'/>
     <enum name='XML_CHAR_ENCODING_2022_JP' file='encoding' value='19' type='xmlCharEncoding' info='ISO-2022-JP'/>
     <enum name='XML_CHAR_ENCODING_8859_1' file='encoding' value='10' type='xmlCharEncoding' info='ISO-8859-1 ISO Latin 1'/>
+    <enum name='XML_CHAR_ENCODING_8859_10' file='encoding' value='25' type='xmlCharEncoding' info='ISO-8859-10'/>
+    <enum name='XML_CHAR_ENCODING_8859_11' file='encoding' value='26' type='xmlCharEncoding' info='ISO-8859-11'/>
+    <enum name='XML_CHAR_ENCODING_8859_13' file='encoding' value='27' type='xmlCharEncoding' info='ISO-8859-13'/>
+    <enum name='XML_CHAR_ENCODING_8859_14' file='encoding' value='28' type='xmlCharEncoding' info='ISO-8859-14'/>
+    <enum name='XML_CHAR_ENCODING_8859_15' file='encoding' value='29' type='xmlCharEncoding' info='ISO-8859-15'/>
+    <enum name='XML_CHAR_ENCODING_8859_16' file='encoding' value='30' type='xmlCharEncoding' info=' ISO-8859-16'/>
     <enum name='XML_CHAR_ENCODING_8859_2' file='encoding' value='11' type='xmlCharEncoding' info='ISO-8859-2 ISO Latin 2'/>
     <enum name='XML_CHAR_ENCODING_8859_3' file='encoding' value='12' type='xmlCharEncoding' info='ISO-8859-3'/>
     <enum name='XML_CHAR_ENCODING_8859_4' file='encoding' value='13' type='xmlCharEncoding' info='ISO-8859-4'/>
@@ -4657,10 +4550,11 @@
     <enum name='XML_CHAR_ENCODING_8859_7' file='encoding' value='16' type='xmlCharEncoding' info='ISO-8859-7'/>
     <enum name='XML_CHAR_ENCODING_8859_8' file='encoding' value='17' type='xmlCharEncoding' info='ISO-8859-8'/>
     <enum name='XML_CHAR_ENCODING_8859_9' file='encoding' value='18' type='xmlCharEncoding' info='ISO-8859-9'/>
-    <enum name='XML_CHAR_ENCODING_ASCII' file='encoding' value='22' type='xmlCharEncoding' info=' pure ASCII'/>
+    <enum name='XML_CHAR_ENCODING_ASCII' file='encoding' value='22' type='xmlCharEncoding' info='pure ASCII Available since 2.14.0'/>
     <enum name='XML_CHAR_ENCODING_EBCDIC' file='encoding' value='6' type='xmlCharEncoding' info='EBCDIC uh!'/>
     <enum name='XML_CHAR_ENCODING_ERROR' file='encoding' value='-1' type='xmlCharEncoding' info='No char encoding detected'/>
     <enum name='XML_CHAR_ENCODING_EUC_JP' file='encoding' value='21' type='xmlCharEncoding' info='EUC-JP'/>
+    <enum name='XML_CHAR_ENCODING_HTML' file='encoding' value='24' type='xmlCharEncoding' info='HTML (output only)'/>
     <enum name='XML_CHAR_ENCODING_NONE' file='encoding' value='0' type='xmlCharEncoding' info='No char encoding detected'/>
     <enum name='XML_CHAR_ENCODING_SHIFT_JIS' file='encoding' value='20' type='xmlCharEncoding' info='Shift_JIS'/>
     <enum name='XML_CHAR_ENCODING_UCS2' file='encoding' value='9' type='xmlCharEncoding' info='UCS-2'/>
@@ -4668,6 +4562,7 @@
     <enum name='XML_CHAR_ENCODING_UCS4LE' file='encoding' value='4' type='xmlCharEncoding' info='UCS-4 little endian'/>
     <enum name='XML_CHAR_ENCODING_UCS4_2143' file='encoding' value='7' type='xmlCharEncoding' info='UCS-4 unusual ordering'/>
     <enum name='XML_CHAR_ENCODING_UCS4_3412' file='encoding' value='8' type='xmlCharEncoding' info='UCS-4 unusual ordering'/>
+    <enum name='XML_CHAR_ENCODING_UTF16' file='encoding' value='23' type='xmlCharEncoding' info='UTF-16 native'/>
     <enum name='XML_CHAR_ENCODING_UTF16BE' file='encoding' value='3' type='xmlCharEncoding' info='UTF-16 big endian'/>
     <enum name='XML_CHAR_ENCODING_UTF16LE' file='encoding' value='2' type='xmlCharEncoding' info='UTF-16 little endian'/>
     <enum name='XML_CHAR_ENCODING_UTF8' file='encoding' value='1' type='xmlCharEncoding' info='UTF-8'/>
@@ -4781,10 +4676,9 @@ and not by parsing an instance'/>
     <enum name='XML_ELEMENT_TYPE_MIXED' file='tree' value='3' type='xmlElementTypeVal'/>
     <enum name='XML_ELEMENT_TYPE_UNDEFINED' file='tree' value='0' type='xmlElementTypeVal'/>
     <enum name='XML_ENC_ERR_INPUT' file='encoding' value='-2' type='xmlCharEncError'/>
-    <enum name='XML_ENC_ERR_INTERNAL' file='encoding' value='-4' type='xmlCharEncError'/>
-    <enum name='XML_ENC_ERR_MEMORY' file='encoding' value='-5' type='xmlCharEncError'/>
-    <enum name='XML_ENC_ERR_PARTIAL' file='encoding' value='-3' type='xmlCharEncError'/>
-    <enum name='XML_ENC_ERR_SPACE' file='encoding' value='-1' type='xmlCharEncError'/>
+    <enum name='XML_ENC_ERR_INTERNAL' file='encoding' value='-1' type='xmlCharEncError'/>
+    <enum name='XML_ENC_ERR_MEMORY' file='encoding' value='-4' type='xmlCharEncError'/>
+    <enum name='XML_ENC_ERR_SPACE' file='encoding' value='-3' type='xmlCharEncError'/>
     <enum name='XML_ENC_ERR_SUCCESS' file='encoding' value='0' type='xmlCharEncError'/>
     <enum name='XML_ENTITY_DECL' file='tree' value='17' type='xmlElementType'/>
     <enum name='XML_ENTITY_NODE' file='tree' value='6' type='xmlElementType' info='unused'/>
@@ -4902,12 +4796,6 @@ and not by parsing an instance'/>
     <enum name='XML_ERR_WARNING' file='xmlerror' value='1' type='xmlErrorLevel' info='A simple warning'/>
     <enum name='XML_ERR_XMLDECL_NOT_FINISHED' file='xmlerror' value='57' type='xmlParserErrors' info='57'/>
     <enum name='XML_ERR_XMLDECL_NOT_STARTED' file='xmlerror' value='56' type='xmlParserErrors' info='56'/>
-    <enum name='XML_EXP_ATOM' file='xmlregexp' value='2' type='xmlExpNodeType'/>
-    <enum name='XML_EXP_COUNT' file='xmlregexp' value='5' type='xmlExpNodeType'/>
-    <enum name='XML_EXP_EMPTY' file='xmlregexp' value='0' type='xmlExpNodeType'/>
-    <enum name='XML_EXP_FORBID' file='xmlregexp' value='1' type='xmlExpNodeType'/>
-    <enum name='XML_EXP_OR' file='xmlregexp' value='4' type='xmlExpNodeType'/>
-    <enum name='XML_EXP_SEQ' file='xmlregexp' value='3' type='xmlExpNodeType'/>
     <enum name='XML_EXTERNAL_GENERAL_PARSED_ENTITY' file='entities' value='2' type='xmlEntityType'/>
     <enum name='XML_EXTERNAL_GENERAL_UNPARSED_ENTITY' file='entities' value='3' type='xmlEntityType'/>
     <enum name='XML_EXTERNAL_PARAMETER_ENTITY' file='entities' value='5' type='xmlEntityType'/>
@@ -5058,7 +4946,7 @@ and not by parsing an instance'/>
     <enum name='XML_PARSER_SYSTEM_LITERAL' file='parser' value='13' type='xmlParserInputState' info='within a SYSTEM value'/>
     <enum name='XML_PARSER_VALIDATE' file='xmlreader' value='3' type='xmlParserProperties'/>
     <enum name='XML_PARSER_XML_DECL' file='parser' value='17' type='xmlParserInputState' info=' before XML decl (but after BOM)'/>
-    <enum name='XML_PARSE_BIG_LINES' file='parser' value='4194304' type='xmlParserOption' info='Store big lines numbers in text PSVI field'/>
+    <enum name='XML_PARSE_BIG_LINES' file='parser' value='4194304' type='xmlParserOption' info='Store big lines numbers in text PSVI field since 2.13.0'/>
     <enum name='XML_PARSE_COMPACT' file='parser' value='65536' type='xmlParserOption' info='compact small text nodes; no modification of
 the tree allowed afterwards (will possibly
 crash if you try to modify the tree)'/>
@@ -5077,7 +4965,10 @@ crash if you try to modify the tree)'/>
     <enum name='XML_PARSE_NONET' file='parser' value='2048' type='xmlParserOption' info='Forbid network access'/>
     <enum name='XML_PARSE_NOWARNING' file='parser' value='64' type='xmlParserOption' info='suppress warning reports'/>
     <enum name='XML_PARSE_NOXINCNODE' file='parser' value='32768' type='xmlParserOption' info='do not generate XINCLUDE START/END nodes'/>
-    <enum name='XML_PARSE_NO_XXE' file='parser' value='8388608' type='xmlParserOption' info=' disable loading of external content'/>
+    <enum name='XML_PARSE_NO_CATALOG_PI' file='parser' value='67108864' type='xmlParserOption' info=' ignore catalog PIs'/>
+    <enum name='XML_PARSE_NO_SYS_CATALOG' file='parser' value='33554432' type='xmlParserOption' info='disable global system catalog'/>
+    <enum name='XML_PARSE_NO_UNZIP' file='parser' value='16777216' type='xmlParserOption' info='disable compressed content'/>
+    <enum name='XML_PARSE_NO_XXE' file='parser' value='8388608' type='xmlParserOption' info='disable loading of external content since 2.14.0'/>
     <enum name='XML_PARSE_NSCLEAN' file='parser' value='8192' type='xmlParserOption' info='remove redundant namespaces declarations'/>
     <enum name='XML_PARSE_OLD10' file='parser' value='131072' type='xmlParserOption' info='parse using XML-1.0 before update 5'/>
     <enum name='XML_PARSE_OLDSAX' file='parser' value='1048576' type='xmlParserOption' info='parse using SAX2 interface before 2.7.0'/>
@@ -5157,6 +5048,13 @@ crash if you try to modify the tree)'/>
     <enum name='XML_RELAXNG_ERR_VALELEM' file='relaxng' value='29' type='xmlRelaxNGValidErr'/>
     <enum name='XML_RELAXNG_ERR_VALUE' file='relaxng' value='32' type='xmlRelaxNGValidErr'/>
     <enum name='XML_RELAXNG_OK' file='relaxng' value='0' type='xmlRelaxNGValidErr'/>
+    <enum name='XML_RESOURCE_DTD' file='parser' value='2' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_GENERAL_ENTITY' file='parser' value='3' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_MAIN_DOCUMENT' file='parser' value='1' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_PARAMETER_ENTITY' file='parser' value='4' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_UNKNOWN' file='parser' value='0' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_XINCLUDE' file='parser' value='5' type='xmlResourceType'/>
+    <enum name='XML_RESOURCE_XINCLUDE_TEXT' file='parser' value='6' type='xmlResourceType'/>
     <enum name='XML_RNGP_ANYNAME_ATTR_ANCESTOR' file='xmlerror' value='1000' type='xmlParserErrors'/>
     <enum name='XML_RNGP_ATTRIBUTE_CHILDREN' file='xmlerror' value='1002' type='xmlParserErrors' info='1002'/>
     <enum name='XML_RNGP_ATTRIBUTE_CONTENT' file='xmlerror' value='1003' type='xmlParserErrors' info='1003'/>
@@ -5283,14 +5181,17 @@ crash if you try to modify the tree)'/>
     <enum name='XML_SAVE_AS_HTML' file='xmlsave' value='64' type='xmlSaveOption' info='force HTML serialization on XML doc'/>
     <enum name='XML_SAVE_AS_XML' file='xmlsave' value='32' type='xmlSaveOption' info='force XML serialization on HTML doc'/>
     <enum name='XML_SAVE_CHAR_INVALID' file='xmlerror' value='1401' type='xmlParserErrors' info='1401'/>
+    <enum name='XML_SAVE_EMPTY' file='xmlsave' value='256' type='xmlSaveOption' info='force empty tags, overriding global'/>
     <enum name='XML_SAVE_FORMAT' file='xmlsave' value='1' type='xmlSaveOption' info='format save output'/>
+    <enum name='XML_SAVE_INDENT' file='xmlsave' value='1024' type='xmlSaveOption' info=' force indenting, overriding global'/>
     <enum name='XML_SAVE_NOT_UTF8' file='xmlerror' value='1400' type='xmlParserErrors'/>
     <enum name='XML_SAVE_NO_DECL' file='xmlsave' value='2' type='xmlSaveOption' info='drop the xml declaration'/>
     <enum name='XML_SAVE_NO_DOCTYPE' file='xmlerror' value='1402' type='xmlParserErrors' info='1402'/>
     <enum name='XML_SAVE_NO_EMPTY' file='xmlsave' value='4' type='xmlSaveOption' info='no empty tags'/>
+    <enum name='XML_SAVE_NO_INDENT' file='xmlsave' value='512' type='xmlSaveOption' info='disable indenting'/>
     <enum name='XML_SAVE_NO_XHTML' file='xmlsave' value='8' type='xmlSaveOption' info='disable XHTML1 specific rules'/>
     <enum name='XML_SAVE_UNKNOWN_ENCODING' file='xmlerror' value='1403' type='xmlParserErrors' info='1403'/>
-    <enum name='XML_SAVE_WSNONSIG' file='xmlsave' value='128' type='xmlSaveOption' info=' format with non-significant whitespace'/>
+    <enum name='XML_SAVE_WSNONSIG' file='xmlsave' value='128' type='xmlSaveOption' info='format with non-significant whitespace Available since 2.14.0'/>
     <enum name='XML_SAVE_XHTML' file='xmlsave' value='16' type='xmlSaveOption' info='force XHTML1 specific rules'/>
     <enum name='XML_SCHEMAP_AG_PROPS_CORRECT' file='xmlerror' value='3087' type='xmlParserErrors' info='3086'/>
     <enum name='XML_SCHEMAP_ATTRFORMDEFAULT_VALUE' file='xmlerror' value='1701' type='xmlParserErrors' info='1701'/>
@@ -5816,14 +5717,11 @@ crash if you try to modify the tree)'/>
     <enum name='XPATH_INVALID_OPERAND' file='xpath' value='10' type='xmlXPathError'/>
     <enum name='XPATH_INVALID_PREDICATE_ERROR' file='xpath' value='6' type='xmlXPathError'/>
     <enum name='XPATH_INVALID_TYPE' file='xpath' value='11' type='xmlXPathError'/>
-    <enum name='XPATH_LOCATIONSET' file='xpath' value='7' type='xmlXPathObjectType'/>
     <enum name='XPATH_MEMORY_ERROR' file='xpath' value='15' type='xmlXPathError'/>
     <enum name='XPATH_NODESET' file='xpath' value='1' type='xmlXPathObjectType'/>
     <enum name='XPATH_NUMBER' file='xpath' value='3' type='xmlXPathObjectType'/>
     <enum name='XPATH_NUMBER_ERROR' file='xpath' value='1' type='xmlXPathError'/>
     <enum name='XPATH_OP_LIMIT_EXCEEDED' file='xpath' value='25' type='xmlXPathError'/>
-    <enum name='XPATH_POINT' file='xpath' value='5' type='xmlXPathObjectType'/>
-    <enum name='XPATH_RANGE' file='xpath' value='6' type='xmlXPathObjectType'/>
     <enum name='XPATH_RECURSION_LIMIT_EXCEEDED' file='xpath' value='26' type='xmlXPathError'/>
     <enum name='XPATH_STACK_ERROR' file='xpath' value='23' type='xmlXPathError'/>
     <enum name='XPATH_START_LITERAL_ERROR' file='xpath' value='3' type='xmlXPathError'/>
@@ -5842,36 +5740,26 @@ crash if you try to modify the tree)'/>
     <enum name='XPTR_SYNTAX_ERROR' file='xpath' value='16' type='xmlXPathError'/>
     <typedef name='htmlDocPtr' file='HTMLparser' type='xmlDocPtr'/>
     <struct name='htmlElemDesc' file='HTMLparser' type='struct _htmlElemDesc'>
-      <field name='name' type='const char *' info=' The tag name'/>
-      <field name='startTag' type='char' info=' Whether the start tag can be implied'/>
-      <field name='endTag' type='char' info=' Whether the end tag can be implied'/>
-      <field name='saveEndTag' type='char' info=' Whether the end tag should be saved'/>
-      <field name='empty' type='char' info=' Is this an empty element ?'/>
-      <field name='depr' type='char' info=' Is this a deprecated element ?'/>
-      <field name='dtd' type='char' info=' 1: only in Loose DTD, 2: only Frameset one'/>
-      <field name='isinline' type='char' info=' is this a block 0 or inline 1 element'/>
-      <field name='desc' type='const char *' info=' the description NRK Jan.2003
-* New fields encapsulating HTML structure
-*
-* Bugs:
-*	This is a very limited representation.  It fails to tell us when
-*	an element *requires* subelements (we only have whether they&apos;re
-*	allowed or not), and it doesn&apos;t tell us where CDATA and PCDATA
-*	are allowed.  Some element relationships are not fully represented:
-*	these are flagged with the word MODIFIER
-*'/>
-      <field name='subelts' type='const char **' info=' allowed sub-elements of this element'/>
-      <field name='defaultsubelt' type='const char *' info=' subelement for suggested auto-repair
-if necessary or NULL'/>
-      <field name='attrs_opt' type='const char **' info=' Optional Attributes'/>
-      <field name='attrs_depr' type='const char **' info=' Additional deprecated attributes'/>
-      <field name='attrs_req' type='const char **' info=' Required attributes'/>
+      <field name='name' type='const char *'/>
+      <field name='startTag' type='char'/>
+      <field name='endTag' type='char'/>
+      <field name='saveEndTag' type='char'/>
+      <field name='empty' type='char'/>
+      <field name='depr' type='char'/>
+      <field name='dtd' type='char'/>
+      <field name='isinline' type='char'/>
+      <field name='desc' type='const char *'/>
+      <field name='subelts' type='const char **'/>
+      <field name='defaultsubelt' type='const char *'/>
+      <field name='attrs_opt' type='const char **'/>
+      <field name='attrs_depr' type='const char **'/>
+      <field name='attrs_req' type='const char **'/>
     </struct>
     <typedef name='htmlElemDescPtr' file='HTMLparser' type='htmlElemDesc *'/>
     <struct name='htmlEntityDesc' file='HTMLparser' type='struct _htmlEntityDesc'>
-      <field name='value' type='unsigned int' info=' the UNICODE value for the character'/>
-      <field name='name' type='const char *' info=' The entity name'/>
-      <field name='desc' type='const char *' info=' the description'/>
+      <field name='value' type='unsigned int'/>
+      <field name='name' type='const char *'/>
+      <field name='desc' type='const char *'/>
     </struct>
     <typedef name='htmlEntityDescPtr' file='HTMLparser' type='htmlEntityDesc *'/>
     <typedef name='htmlNodePtr' file='HTMLparser' type='xmlNodePtr'/>
@@ -5887,9 +5775,9 @@ if necessary or NULL'/>
     <typedef name='xlinkActuate' file='xlink' type='enum'/>
     <typedef name='xlinkHRef' file='xlink' type='xmlChar *'/>
     <struct name='xlinkHandler' file='xlink' type='struct _xlinkHandler'>
-      <field name='simple' type='xlinkSimpleLinkFunk' info=''/>
-      <field name='extended' type='xlinkExtendedLinkFunk' info=''/>
-      <field name='set' type='xlinkExtendedLinkSetFunk' info=''/>
+      <field name='simple' type='xlinkSimpleLinkFunk'/>
+      <field name='extended' type='xlinkExtendedLinkFunk'/>
+      <field name='set' type='xlinkExtendedLinkSetFunk'/>
     </struct>
     <typedef name='xlinkHandlerPtr' file='xlink' type='xlinkHandler *'/>
     <typedef name='xlinkRole' file='xlink' type='xmlChar *'/>
@@ -5897,39 +5785,39 @@ if necessary or NULL'/>
     <typedef name='xlinkTitle' file='xlink' type='xmlChar *'/>
     <typedef name='xlinkType' file='xlink' type='enum'/>
     <struct name='xmlAttr' file='tree' type='struct _xmlAttr'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_ATTRIBUTE_NODE, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' the name of the property'/>
-      <field name='children' type='struct _xmlNode *' info=' the value of the property'/>
-      <field name='last' type='struct _xmlNode *' info=' NULL'/>
-      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
-      <field name='next' type='struct _xmlAttr *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlAttr *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
-      <field name='ns' type='xmlNs *' info=' pointer to the associated namespace'/>
-      <field name='atype' type='xmlAttributeType' info=' the attribute type if validating'/>
-      <field name='psvi' type='void *' info=' for type/PSVI information'/>
-      <field name='id' type='struct _xmlID *' info=' the ID struct'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlNode *'/>
+      <field name='next' type='struct _xmlAttr *'/>
+      <field name='prev' type='struct _xmlAttr *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='ns' type='xmlNs *'/>
+      <field name='atype' type='xmlAttributeType'/>
+      <field name='psvi' type='void *'/>
+      <field name='id' type='struct _xmlID *'/>
     </struct>
     <struct name='xmlAttrHashBucket' file='parser' type='struct _xmlAttrHashBucket'/>
     <typedef name='xmlAttrPtr' file='tree' type='xmlAttr *'/>
     <struct name='xmlAttribute' file='tree' type='struct _xmlAttribute'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_ATTRIBUTE_DECL, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' Attribute name'/>
-      <field name='children' type='struct _xmlNode *' info=' NULL'/>
-      <field name='last' type='struct _xmlNode *' info=' NULL'/>
-      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
-      <field name='nexth' type='struct _xmlAttribute *' info=' next in hash table'/>
-      <field name='atype' type='xmlAttributeType' info=' The attribute type'/>
-      <field name='def' type='xmlAttributeDefault' info=' the default'/>
-      <field name='defaultValue' type='const xmlChar *' info=' or the default value'/>
-      <field name='tree' type='xmlEnumerationPtr' info=' or the enumeration tree if any'/>
-      <field name='prefix' type='const xmlChar *' info=' the namespace prefix if any'/>
-      <field name='elem' type='const xmlChar *' info=' Element holding the attribute'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlDtd *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='nexth' type='struct _xmlAttribute *'/>
+      <field name='atype' type='xmlAttributeType'/>
+      <field name='def' type='xmlAttributeDefault'/>
+      <field name='defaultValue' type='const xmlChar *'/>
+      <field name='tree' type='xmlEnumerationPtr'/>
+      <field name='prefix' type='const xmlChar *'/>
+      <field name='elem' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlAttributeDefault' file='tree' type='enum'/>
     <typedef name='xmlAttributePtr' file='tree' type='xmlAttribute *'/>
@@ -5949,11 +5837,11 @@ if necessary or NULL'/>
       <info>A pointer to a buffer structure, the actual structure internals are not public</info>
     </typedef>
     <struct name='xmlBuffer' file='tree' type='struct _xmlBuffer'>
-      <field name='content' type='xmlChar *' info=' The buffer content UTF8'/>
-      <field name='use' type='unsigned int' info=' The buffer size used'/>
-      <field name='size' type='unsigned int' info=' The buffer size'/>
-      <field name='alloc' type='xmlBufferAllocationScheme' info=' The realloc method'/>
-      <field name='contentIO' type='xmlChar *' info=' in IO mode we may have a different base'/>
+      <field name='content' type='xmlChar *'/>
+      <field name='use' type='unsigned int'/>
+      <field name='size' type='unsigned int'/>
+      <field name='alloc' type='xmlBufferAllocationScheme'/>
+      <field name='contentIO' type='xmlChar *'/>
     </struct>
     <typedef name='xmlBufferAllocationScheme' file='tree' type='enum'/>
     <typedef name='xmlBufferPtr' file='tree' type='xmlBuffer *'/>
@@ -5963,20 +5851,20 @@ if necessary or NULL'/>
     <typedef name='xmlCatalogPrefer' file='catalog' type='enum'/>
     <typedef name='xmlCatalogPtr' file='catalog' type='xmlCatalog *'/>
     <struct name='xmlChLRange' file='chvalid' type='struct _xmlChLRange'>
-      <field name='low' type='unsigned int' info=''/>
-      <field name='high' type='unsigned int' info=''/>
+      <field name='low' type='unsigned int'/>
+      <field name='high' type='unsigned int'/>
     </struct>
     <typedef name='xmlChLRangePtr' file='chvalid' type='xmlChLRange *'/>
     <struct name='xmlChRangeGroup' file='chvalid' type='struct _xmlChRangeGroup'>
-      <field name='nbShortRange' type='int' info=''/>
-      <field name='nbLongRange' type='int' info=''/>
-      <field name='shortRange' type='const xmlChSRange *' info=' points to an array of ranges'/>
-      <field name='longRange' type='const xmlChLRange *' info=''/>
+      <field name='nbShortRange' type='int'/>
+      <field name='nbLongRange' type='int'/>
+      <field name='shortRange' type='const xmlChSRange *'/>
+      <field name='longRange' type='const xmlChLRange *'/>
     </struct>
     <typedef name='xmlChRangeGroupPtr' file='chvalid' type='xmlChRangeGroup *'/>
     <struct name='xmlChSRange' file='chvalid' type='struct _xmlChSRange'>
-      <field name='low' type='unsigned short' info=''/>
-      <field name='high' type='unsigned short' info=''/>
+      <field name='low' type='unsigned short'/>
+      <field name='high' type='unsigned short'/>
     </struct>
     <typedef name='xmlChSRangePtr' file='chvalid' type='xmlChSRange *'/>
     <typedef name='xmlChar' file='xmlstring' type='unsigned char'>
@@ -5985,108 +5873,98 @@ if necessary or NULL'/>
     <typedef name='xmlCharEncError' file='encoding' type='enum'/>
     <typedef name='xmlCharEncoding' file='encoding' type='enum'/>
     <struct name='xmlCharEncodingHandler' file='encoding' type='struct _xmlCharEncodingHandler'>
-      <field name='name' type='char *' info=''/>
-      <field name='input' type='xmlCharEncodingInputFunc' info=''/>
-      <field name='output' type='xmlCharEncodingOutputFunc' info=''/>
-      <field name='iconv_in' type='iconv_t' info=''/>
-      <field name='iconv_out' type='iconv_t' info=''/>
-      <field name='uconv_in' type='struct _uconv_t *' info=''/>
-      <field name='uconv_out' type='struct _uconv_t *' info=''/>
+      <field name='name' type='char *'/>
+      <field name='input' type='xmlCharEncodingInputFunc'/>
+      <field name='output' type='xmlCharEncodingOutputFunc'/>
+      <field name='iconv_in' type='void *'/>
+      <field name='iconv_out' type='void *'/>
+      <field name='inputCtxt' type='void *'/>
+      <field name='outputCtxt' type='void *'/>
+      <field name='ctxtDtor' type='xmlCharEncConvCtxtDtor'/>
+      <field name='flags' type='int'/>
     </struct>
     <typedef name='xmlCharEncodingHandlerPtr' file='encoding' type='xmlCharEncodingHandler *'/>
     <struct name='xmlDOMWrapCtxt' file='tree' type='struct _xmlDOMWrapCtxt'>
-      <field name='_private' type='void *' info='* The type of this context, just in case we need specialized
-* contexts in the future.
-*'/>
-      <field name='type' type='int' info='* Internal namespace map used for various operations.
-*'/>
-      <field name='namespaceMap' type='void *' info='* Use this one to acquire an xmlNsPtr intended for node-&gt;ns.
-* (Note that this is not intended for elem-&gt;nsDef).
-*'/>
-      <field name='getNsForNodeFunc' type='xmlDOMWrapAcquireNsFunction' info=''/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='int'/>
+      <field name='namespaceMap' type='void *'/>
+      <field name='getNsForNodeFunc' type='xmlDOMWrapAcquireNsFunction'/>
     </struct>
     <typedef name='xmlDOMWrapCtxtPtr' file='tree' type='xmlDOMWrapCtxt *'/>
     <struct name='xmlDict' file='dict' type='struct _xmlDict'/>
     <typedef name='xmlDictPtr' file='dict' type='xmlDict *'/>
     <struct name='xmlDoc' file='tree' type='struct _xmlDoc'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_DOCUMENT_NODE, must be second !'/>
-      <field name='name' type='char *' info=' name/filename/URI of the document'/>
-      <field name='children' type='struct _xmlNode *' info=' the document tree'/>
-      <field name='last' type='struct _xmlNode *' info=' last child link'/>
-      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' autoreference to itself End of common part'/>
-      <field name='compression' type='int' info=' level of zlib compression'/>
-      <field name='standalone' type='int' info=' standalone document (no external refs)
-1 if standalone=&quot;yes&quot;
-0 if standalone=&quot;no&quot;
--1 if there is no XML declaration
--2 if there is an XML declaration, but no
-standalone attribute was specified'/>
-      <field name='intSubset' type='struct _xmlDtd *' info=' the document internal subset'/>
-      <field name='extSubset' type='struct _xmlDtd *' info=' the document external subset'/>
-      <field name='oldNs' type='struct _xmlNs *' info=' Global namespace, the old way'/>
-      <field name='version' type='const xmlChar *' info=' the XML version string'/>
-      <field name='encoding' type='const xmlChar *' info=' actual encoding, if any'/>
-      <field name='ids' type='void *' info=' Hash table for ID attributes if any'/>
-      <field name='refs' type='void *' info=' Hash table for IDREFs attributes if any'/>
-      <field name='URL' type='const xmlChar *' info=' The URI for that document'/>
-      <field name='charset' type='int' info=' unused'/>
-      <field name='dict' type='struct _xmlDict *' info=' dict used to allocate names or NULL'/>
-      <field name='psvi' type='void *' info=' for type/PSVI information'/>
-      <field name='parseFlags' type='int' info=' set of xmlParserOption used to parse the
-document'/>
-      <field name='properties' type='int' info=' set of xmlDocProperties for this document
-set at the end of parsing'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='char *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlNode *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='compression' type='int'/>
+      <field name='standalone' type='int'/>
+      <field name='intSubset' type='struct _xmlDtd *'/>
+      <field name='extSubset' type='struct _xmlDtd *'/>
+      <field name='oldNs' type='struct _xmlNs *'/>
+      <field name='version' type='const xmlChar *'/>
+      <field name='encoding' type='const xmlChar *'/>
+      <field name='ids' type='void *'/>
+      <field name='refs' type='void *'/>
+      <field name='URL' type='const xmlChar *'/>
+      <field name='charset' type='int'/>
+      <field name='dict' type='struct _xmlDict *'/>
+      <field name='psvi' type='void *'/>
+      <field name='parseFlags' type='int'/>
+      <field name='properties' type='int'/>
     </struct>
     <typedef name='xmlDocProperties' file='tree' type='enum'/>
     <typedef name='xmlDocPtr' file='tree' type='xmlDoc *'/>
     <struct name='xmlDtd' file='tree' type='struct _xmlDtd'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_DTD_NODE, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' Name of the DTD'/>
-      <field name='children' type='struct _xmlNode *' info=' the value of the property link'/>
-      <field name='last' type='struct _xmlNode *' info=' last child link'/>
-      <field name='parent' type='struct _xmlDoc *' info=' child-&gt;parent link'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document End of common part'/>
-      <field name='notations' type='void *' info=' Hash table for notations if any'/>
-      <field name='elements' type='void *' info=' Hash table for elements if any'/>
-      <field name='attributes' type='void *' info=' Hash table for attributes if any'/>
-      <field name='entities' type='void *' info=' Hash table for entities if any'/>
-      <field name='ExternalID' type='const xmlChar *' info=' External identifier for PUBLIC DTD'/>
-      <field name='SystemID' type='const xmlChar *' info=' URI for a SYSTEM or PUBLIC DTD'/>
-      <field name='pentities' type='void *' info=' Hash table for param entities if any'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlDoc *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='notations' type='void *'/>
+      <field name='elements' type='void *'/>
+      <field name='attributes' type='void *'/>
+      <field name='entities' type='void *'/>
+      <field name='ExternalID' type='const xmlChar *'/>
+      <field name='SystemID' type='const xmlChar *'/>
+      <field name='pentities' type='void *'/>
     </struct>
     <typedef name='xmlDtdPtr' file='tree' type='xmlDtd *'/>
     <struct name='xmlElement' file='tree' type='struct _xmlElement'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_ELEMENT_DECL, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' Element name'/>
-      <field name='children' type='struct _xmlNode *' info=' NULL'/>
-      <field name='last' type='struct _xmlNode *' info=' NULL'/>
-      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
-      <field name='etype' type='xmlElementTypeVal' info=' The type'/>
-      <field name='content' type='xmlElementContentPtr' info=' the allowed element content'/>
-      <field name='attributes' type='xmlAttributePtr' info=' List of the declared attributes'/>
-      <field name='prefix' type='const xmlChar *' info=' the namespace prefix if any'/>
-      <field name='contModel' type='xmlRegexpPtr' info=' the validating regexp'/>
-      <field name='contModel' type='void *' info=''/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlDtd *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='etype' type='xmlElementTypeVal'/>
+      <field name='content' type='xmlElementContentPtr'/>
+      <field name='attributes' type='xmlAttributePtr'/>
+      <field name='prefix' type='const xmlChar *'/>
+      <field name='contModel' type='xmlRegexpPtr'/>
+      <field name='contModel' type='void *'/>
     </struct>
     <struct name='xmlElementContent' file='tree' type='struct _xmlElementContent'>
-      <field name='type' type='xmlElementContentType' info=' PCDATA, ELEMENT, SEQ or OR'/>
-      <field name='ocur' type='xmlElementContentOccur' info=' ONCE, OPT, MULT or PLUS'/>
-      <field name='name' type='const xmlChar *' info=' Element name'/>
-      <field name='c1' type='struct _xmlElementContent *' info=' first child'/>
-      <field name='c2' type='struct _xmlElementContent *' info=' second child'/>
-      <field name='parent' type='struct _xmlElementContent *' info=' parent'/>
-      <field name='prefix' type='const xmlChar *' info=' Namespace prefix'/>
+      <field name='type' type='xmlElementContentType'/>
+      <field name='ocur' type='xmlElementContentOccur'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='c1' type='struct _xmlElementContent *'/>
+      <field name='c2' type='struct _xmlElementContent *'/>
+      <field name='parent' type='struct _xmlElementContent *'/>
+      <field name='prefix' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlElementContentOccur' file='tree' type='enum'/>
     <typedef name='xmlElementContentPtr' file='tree' type='xmlElementContent *'/>
@@ -6099,69 +5977,64 @@ set at the end of parsing'/>
     <struct name='xmlEntitiesTable' file='entities' type='struct _xmlHashTable'/>
     <typedef name='xmlEntitiesTablePtr' file='entities' type='xmlEntitiesTable *'/>
     <struct name='xmlEntity' file='tree' type='struct _xmlEntity'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' XML_ENTITY_DECL, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' Entity name'/>
-      <field name='children' type='struct _xmlNode *' info=' First child link'/>
-      <field name='last' type='struct _xmlNode *' info=' Last child link'/>
-      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
-      <field name='orig' type='xmlChar *' info=' content without ref substitution'/>
-      <field name='content' type='xmlChar *' info=' content or ndata if unparsed'/>
-      <field name='length' type='int' info=' the content length'/>
-      <field name='etype' type='xmlEntityType' info=' The entity type'/>
-      <field name='ExternalID' type='const xmlChar *' info=' External identifier for PUBLIC'/>
-      <field name='SystemID' type='const xmlChar *' info=' URI for a SYSTEM or PUBLIC Entity'/>
-      <field name='nexte' type='struct _xmlEntity *' info=' unused'/>
-      <field name='URI' type='const xmlChar *' info=' the full URI as computed'/>
-      <field name='owner' type='int' info=' unused'/>
-      <field name='flags' type='int' info=' various flags'/>
-      <field name='expandedSize' type='unsigned long' info=' expanded size'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlDtd *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='orig' type='xmlChar *'/>
+      <field name='content' type='xmlChar *'/>
+      <field name='length' type='int'/>
+      <field name='etype' type='xmlEntityType'/>
+      <field name='ExternalID' type='const xmlChar *'/>
+      <field name='SystemID' type='const xmlChar *'/>
+      <field name='nexte' type='struct _xmlEntity *'/>
+      <field name='URI' type='const xmlChar *'/>
+      <field name='owner' type='int'/>
+      <field name='flags' type='int'/>
+      <field name='expandedSize' type='unsigned long'/>
     </struct>
     <typedef name='xmlEntityPtr' file='tree' type='xmlEntity *'/>
     <typedef name='xmlEntityType' file='entities' type='enum'/>
     <struct name='xmlEnumeration' file='tree' type='struct _xmlEnumeration'>
-      <field name='next' type='struct _xmlEnumeration *' info=' next one'/>
-      <field name='name' type='const xmlChar *' info=' Enumeration name'/>
+      <field name='next' type='struct _xmlEnumeration *'/>
+      <field name='name' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlEnumerationPtr' file='tree' type='xmlEnumeration *'/>
     <struct name='xmlError' file='xmlerror' type='struct _xmlError'>
-      <field name='domain' type='int' info=' What part of the library raised this error'/>
-      <field name='code' type='int' info=' The error code, e.g. an xmlParserError'/>
-      <field name='message' type='char *' info=' human-readable informative error message'/>
-      <field name='level' type='xmlErrorLevel' info=' how consequent is the error'/>
-      <field name='file' type='char *' info=' the filename'/>
-      <field name='line' type='int' info=' the line number if available'/>
-      <field name='str1' type='char *' info=' extra string information'/>
-      <field name='str2' type='char *' info=' extra string information'/>
-      <field name='str3' type='char *' info=' extra string information'/>
-      <field name='int1' type='int' info=' extra number information'/>
-      <field name='int2' type='int' info=' error column # or 0 if N/A (todo: rename field when we would brk ABI)'/>
-      <field name='ctxt' type='void *' info=' the parser context if available'/>
-      <field name='node' type='void *' info=' the node in the tree'/>
+      <field name='domain' type='int'/>
+      <field name='code' type='int'/>
+      <field name='message' type='char *'/>
+      <field name='level' type='xmlErrorLevel'/>
+      <field name='file' type='char *'/>
+      <field name='line' type='int'/>
+      <field name='str1' type='char *'/>
+      <field name='str2' type='char *'/>
+      <field name='str3' type='char *'/>
+      <field name='int1' type='int'/>
+      <field name='int2' type='int'/>
+      <field name='ctxt' type='void *'/>
+      <field name='node' type='void *'/>
     </struct>
     <typedef name='xmlErrorDomain' file='xmlerror' type='enum'/>
     <typedef name='xmlErrorLevel' file='xmlerror' type='enum'/>
     <typedef name='xmlErrorPtr' file='xmlerror' type='xmlError *'/>
-    <struct name='xmlExpCtxt' file='xmlregexp' type='struct _xmlExpCtxt'/>
-    <typedef name='xmlExpCtxtPtr' file='xmlregexp' type='xmlExpCtxt *'/>
-    <struct name='xmlExpNode' file='xmlregexp' type='struct _xmlExpNode'/>
-    <typedef name='xmlExpNodePtr' file='xmlregexp' type='xmlExpNode *'/>
-    <typedef name='xmlExpNodeType' file='xmlregexp' type='enum'/>
     <typedef name='xmlFeature' file='parser' type='enum'/>
     <struct name='xmlGlobalState' file='globals' type='struct _xmlGlobalState'/>
     <typedef name='xmlGlobalStatePtr' file='globals' type='xmlGlobalState *'/>
     <struct name='xmlHashTable' file='hash' type='struct _xmlHashTable'/>
     <typedef name='xmlHashTablePtr' file='hash' type='xmlHashTable *'/>
     <struct name='xmlID' file='tree' type='struct _xmlID'>
-      <field name='next' type='struct _xmlID *' info=' next ID'/>
-      <field name='value' type='const xmlChar *' info=' The ID name'/>
-      <field name='attr' type='xmlAttrPtr' info=' The attribute holding it'/>
-      <field name='name' type='const xmlChar *' info=' The attribute if attr is not available'/>
-      <field name='lineno' type='int' info=' The line number if attr is not available'/>
-      <field name='doc' type='struct _xmlDoc *' info=' The document holding the ID'/>
+      <field name='next' type='struct _xmlID *'/>
+      <field name='value' type='const xmlChar *'/>
+      <field name='attr' type='xmlAttrPtr'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='lineno' type='int'/>
+      <field name='doc' type='struct _xmlDoc *'/>
     </struct>
     <typedef name='xmlIDPtr' file='tree' type='xmlID *'/>
     <struct name='xmlIDTable' file='valid' type='struct _xmlHashTable'/>
@@ -6170,12 +6043,6 @@ set at the end of parsing'/>
     <typedef name='xmlLinkPtr' file='list' type='xmlLink *'/>
     <struct name='xmlList' file='list' type='struct _xmlList'/>
     <typedef name='xmlListPtr' file='list' type='xmlList *'/>
-    <struct name='xmlLocationSet' file='xpointer' type='struct _xmlLocationSet'>
-      <field name='locNr' type='int' info=' number of locations in the set'/>
-      <field name='locMax' type='int' info=' size of the array as allocated'/>
-      <field name='locTab' type='xmlXPathObjectPtr *' info=' array of locations'/>
-    </struct>
-    <typedef name='xmlLocationSetPtr' file='xpointer' type='xmlLocationSet *'/>
     <struct name='xmlModule' file='xmlmodule' type='struct _xmlModule'/>
     <typedef name='xmlModuleOption' file='xmlmodule' type='enum'/>
     <typedef name='xmlModulePtr' file='xmlmodule' type='xmlModule *'>
@@ -6184,214 +6051,211 @@ set at the end of parsing'/>
     <struct name='xmlMutex' file='threads' type='struct _xmlMutex'/>
     <typedef name='xmlMutexPtr' file='threads' type='xmlMutex *'/>
     <struct name='xmlNode' file='tree' type='struct _xmlNode'>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='type' type='xmlElementType' info=' type number, must be second !'/>
-      <field name='name' type='const xmlChar *' info=' the name of the node, or the entity'/>
-      <field name='children' type='struct _xmlNode *' info=' parent-&gt;childs link'/>
-      <field name='last' type='struct _xmlNode *' info=' last child link'/>
-      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
-      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
-      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
-      <field name='doc' type='struct _xmlDoc *' info=' the containing document End of common part'/>
-      <field name='ns' type='xmlNs *' info=' pointer to the associated namespace'/>
-      <field name='content' type='xmlChar *' info=' the content'/>
-      <field name='properties' type='struct _xmlAttr *' info=' properties list'/>
-      <field name='nsDef' type='xmlNs *' info=' namespace definitions on this node'/>
-      <field name='psvi' type='void *' info=' for type/PSVI information'/>
-      <field name='line' type='unsigned short' info=' line number'/>
-      <field name='extra' type='unsigned short' info=' extra data for XPath/XSLT'/>
+      <field name='_private' type='void *'/>
+      <field name='type' type='xmlElementType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='children' type='struct _xmlNode *'/>
+      <field name='last' type='struct _xmlNode *'/>
+      <field name='parent' type='struct _xmlNode *'/>
+      <field name='next' type='struct _xmlNode *'/>
+      <field name='prev' type='struct _xmlNode *'/>
+      <field name='doc' type='struct _xmlDoc *'/>
+      <field name='ns' type='xmlNs *'/>
+      <field name='content' type='xmlChar *'/>
+      <field name='properties' type='struct _xmlAttr *'/>
+      <field name='nsDef' type='xmlNs *'/>
+      <field name='psvi' type='void *'/>
+      <field name='line' type='unsigned short'/>
+      <field name='extra' type='unsigned short'/>
     </struct>
     <typedef name='xmlNodePtr' file='tree' type='xmlNode *'/>
     <struct name='xmlNodeSet' file='xpath' type='struct _xmlNodeSet'>
-      <field name='nodeNr' type='int' info=' number of nodes in the set'/>
-      <field name='nodeMax' type='int' info=' size of the array as allocated'/>
-      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes in no particular order @@ with_ns to check whether namespace nodes should be looked at @@'/>
+      <field name='nodeNr' type='int'/>
+      <field name='nodeMax' type='int'/>
+      <field name='nodeTab' type='xmlNodePtr *'/>
     </struct>
     <typedef name='xmlNodeSetPtr' file='xpath' type='xmlNodeSet *'/>
     <struct name='xmlNotation' file='tree' type='struct _xmlNotation'>
-      <field name='name' type='const xmlChar *' info=' Notation name'/>
-      <field name='PublicID' type='const xmlChar *' info=' Public identifier, if any'/>
-      <field name='SystemID' type='const xmlChar *' info=' System identifier, if any'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='PublicID' type='const xmlChar *'/>
+      <field name='SystemID' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlNotationPtr' file='tree' type='xmlNotation *'/>
     <struct name='xmlNotationTable' file='valid' type='struct _xmlHashTable'/>
     <typedef name='xmlNotationTablePtr' file='valid' type='xmlNotationTable *'/>
     <struct name='xmlNs' file='tree' type='struct _xmlNs'>
-      <field name='next' type='struct _xmlNs *' info=' next Ns link for this node '/>
-      <field name='type' type='xmlNsType' info=' global or local'/>
-      <field name='href' type='const xmlChar *' info=' URL for the namespace'/>
-      <field name='prefix' type='const xmlChar *' info=' prefix for the namespace'/>
-      <field name='_private' type='void *' info=' application data'/>
-      <field name='context' type='struct _xmlDoc *' info=' normally an xmlDoc'/>
+      <field name='next' type='struct _xmlNs *'/>
+      <field name='type' type='xmlNsType'/>
+      <field name='href' type='const xmlChar *'/>
+      <field name='prefix' type='const xmlChar *'/>
+      <field name='_private' type='void *'/>
+      <field name='context' type='struct _xmlDoc *'/>
     </struct>
     <typedef name='xmlNsPtr' file='tree' type='xmlNs *'/>
     <typedef name='xmlNsType' file='tree' type='xmlElementType'/>
     <struct name='xmlOutputBuffer' file='tree' type='struct _xmlOutputBuffer'>
-      <field name='context' type='void *' info=''/>
-      <field name='writecallback' type='xmlOutputWriteCallback' info=''/>
-      <field name='closecallback' type='xmlOutputCloseCallback' info=''/>
-      <field name='encoder' type='xmlCharEncodingHandlerPtr' info=' I18N conversions to UTF-8'/>
-      <field name='buffer' type='xmlBufPtr' info=' Local buffer encoded in UTF-8 or ISOLatin'/>
-      <field name='conv' type='xmlBufPtr' info=' if encoder != NULL buffer for output'/>
-      <field name='written' type='int' info=' total number of byte written'/>
-      <field name='error' type='int' info=''/>
+      <field name='context' type='void *'/>
+      <field name='writecallback' type='xmlOutputWriteCallback'/>
+      <field name='closecallback' type='xmlOutputCloseCallback'/>
+      <field name='encoder' type='xmlCharEncodingHandlerPtr'/>
+      <field name='buffer' type='xmlBufPtr'/>
+      <field name='conv' type='xmlBufPtr'/>
+      <field name='written' type='int'/>
+      <field name='error' type='int'/>
     </struct>
     <typedef name='xmlOutputBufferPtr' file='tree' type='xmlOutputBuffer *'/>
     <struct name='xmlParserCtxt' file='tree' type='struct _xmlParserCtxt'>
-      <field name='sax' type='struct _xmlSAXHandler *' info=' The SAX handler'/>
-      <field name='userData' type='void *' info=' For SAX interface only, used by DOM build'/>
-      <field name='myDoc' type='xmlDocPtr' info=' the document being built'/>
-      <field name='wellFormed' type='int' info=' is the document well formed'/>
-      <field name='replaceEntities' type='int' info=' shall we replace entities ?'/>
-      <field name='version' type='const xmlChar *' info=' the XML version string'/>
-      <field name='encoding' type='const xmlChar *' info=' the declared encoding, if any'/>
-      <field name='standalone' type='int' info=' standalone document'/>
-      <field name='html' type='int' info=' an HTML(1) document
-* 3 is HTML after &lt;head&gt;
-* 10 is HTML after &lt;body&gt;
-* Input stream stack'/>
-      <field name='input' type='xmlParserInputPtr' info=' Current input stream'/>
-      <field name='inputNr' type='int' info=' Number of current input streams'/>
-      <field name='inputMax' type='int' info=' Max number of input streams'/>
-      <field name='inputTab' type='xmlParserInputPtr *' info=' stack of inputs Node analysis stack only used for DOM building'/>
-      <field name='node' type='xmlNodePtr' info=' Current parsed Node'/>
-      <field name='nodeNr' type='int' info=' Depth of the parsing stack'/>
-      <field name='nodeMax' type='int' info=' Max depth of the parsing stack'/>
-      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes'/>
-      <field name='record_info' type='int' info=' Whether node info should be kept'/>
-      <field name='node_seq' type='xmlParserNodeInfoSeq' info=' info about each node parsed'/>
-      <field name='errNo' type='int' info=' error code'/>
-      <field name='hasExternalSubset' type='int' info=' reference and external subset'/>
-      <field name='hasPErefs' type='int' info=' the internal subset has PE refs'/>
-      <field name='external' type='int' info=' unused'/>
-      <field name='valid' type='int' info=' is the document valid'/>
-      <field name='validate' type='int' info=' shall we try to validate ?'/>
-      <field name='vctxt' type='xmlValidCtxt' info=' The validity context'/>
-      <field name='instate' type='xmlParserInputState' info=' push parser state'/>
-      <field name='token' type='int' info=' unused'/>
-      <field name='directory' type='char *' info=' unused Node name stack'/>
-      <field name='name' type='const xmlChar *' info=' Current parsed Node'/>
-      <field name='nameNr' type='int' info=' Depth of the parsing stack'/>
-      <field name='nameMax' type='int' info=' Max depth of the parsing stack'/>
-      <field name='nameTab' type='const xmlChar * *' info=' array of nodes'/>
-      <field name='nbChars' type='long' info=' unused'/>
-      <field name='checkIndex' type='long' info=' used by progressive parsing lookup'/>
-      <field name='keepBlanks' type='int' info=' ugly but ...'/>
-      <field name='disableSAX' type='int' info=' SAX callbacks are disabled'/>
-      <field name='inSubset' type='int' info=' Parsing is in int 1/ext 2 subset'/>
-      <field name='intSubName' type='const xmlChar *' info=' name of subset'/>
-      <field name='extSubURI' type='xmlChar *' info=' URI of external subset'/>
-      <field name='extSubSystem' type='xmlChar *' info=' SYSTEM ID of external subset xml:space values'/>
-      <field name='space' type='int *' info=' Should the parser preserve spaces'/>
-      <field name='spaceNr' type='int' info=' Depth of the parsing stack'/>
-      <field name='spaceMax' type='int' info=' Max depth of the parsing stack'/>
-      <field name='spaceTab' type='int *' info=' array of space infos'/>
-      <field name='depth' type='int' info=' to prevent entity substitution loops'/>
-      <field name='entity' type='xmlParserInputPtr' info=' unused'/>
-      <field name='charset' type='int' info=' unused'/>
-      <field name='nodelen' type='int' info=' Those two fields are there to'/>
-      <field name='nodemem' type='int' info=' Speed up large node parsing'/>
-      <field name='pedantic' type='int' info=' signal pedantic warnings'/>
-      <field name='_private' type='void *' info=' For user data, libxml won&apos;t touch it'/>
-      <field name='loadsubset' type='int' info=' should the external subset be loaded'/>
-      <field name='linenumbers' type='int' info=' set line number in element content'/>
-      <field name='catalogs' type='void *' info=' document&apos;s own catalog'/>
-      <field name='recovery' type='int' info=' run in recovery mode'/>
-      <field name='progressive' type='int' info=' unused'/>
-      <field name='dict' type='xmlDictPtr' info=' dictionary for the parser'/>
-      <field name='atts' type='const xmlChar * *' info=' array for the attributes callbacks'/>
-      <field name='maxatts' type='int' info=' the size of the array'/>
-      <field name='docdict' type='int' info='* pre-interned strings
-*'/>
-      <field name='str_xml' type='const xmlChar *' info=''/>
-      <field name='str_xmlns' type='const xmlChar *' info=''/>
-      <field name='str_xml_ns' type='const xmlChar *' info='* Everything below is used only by the new SAX mode
-*'/>
-      <field name='sax2' type='int' info=' operating in the new SAX mode'/>
-      <field name='nsNr' type='int' info=' the number of inherited namespaces'/>
-      <field name='nsMax' type='int' info=' the size of the arrays'/>
-      <field name='nsTab' type='const xmlChar * *' info=' the array of prefix/namespace name'/>
-      <field name='attallocs' type='unsigned *' info=' which attribute were allocated'/>
-      <field name='pushTab' type='xmlStartTag *' info=' array of data for push'/>
-      <field name='attsDefault' type='xmlHashTablePtr' info=' defaulted attributes if any'/>
-      <field name='attsSpecial' type='xmlHashTablePtr' info=' non-CDATA attributes if any'/>
-      <field name='nsWellFormed' type='int' info=' is the document XML Namespace okay'/>
-      <field name='options' type='int' info='* Those fields are needed only for streaming parsing so far
-*'/>
-      <field name='dictNames' type='int' info=' Use dictionary names for the tree'/>
-      <field name='freeElemsNr' type='int' info=' number of freed element nodes'/>
-      <field name='freeElems' type='xmlNodePtr' info=' List of freed element nodes'/>
-      <field name='freeAttrsNr' type='int' info=' number of freed attributes nodes'/>
-      <field name='freeAttrs' type='xmlAttrPtr' info='* the complete error information for the last error.
-*'/>
-      <field name='lastError' type='xmlError' info=''/>
-      <field name='parseMode' type='xmlParserMode' info=' the parser mode'/>
-      <field name='nbentities' type='unsigned long' info=' unused'/>
-      <field name='sizeentities' type='unsigned long' info=' size of external entities for use by HTML non-recursive parser'/>
-      <field name='nodeInfo' type='xmlParserNodeInfo *' info=' Current NodeInfo'/>
-      <field name='nodeInfoNr' type='int' info=' Depth of the parsing stack'/>
-      <field name='nodeInfoMax' type='int' info=' Max depth of the parsing stack'/>
-      <field name='nodeInfoTab' type='xmlParserNodeInfo *' info=' array of nodeInfos'/>
-      <field name='input_id' type='int' info=' we need to label inputs'/>
-      <field name='sizeentcopy' type='unsigned long' info=' volume of entity copy'/>
-      <field name='endCheckState' type='int' info=' quote state for push parser'/>
-      <field name='nbErrors' type='unsigned short' info=' number of errors'/>
-      <field name='nbWarnings' type='unsigned short' info=' number of warnings'/>
-      <field name='maxAmpl' type='unsigned' info=' maximum amplification factor'/>
-      <field name='nsdb' type='xmlParserNsData *' info=' namespace database'/>
-      <field name='attrHashMax' type='unsigned' info=' allocated size'/>
-      <field name='attrHash' type='xmlAttrHashBucket *' info=' atttribute hash table'/>
-      <field name='errorHandler' type='xmlStructuredErrorFunc' info=''/>
-      <field name='errorCtxt' type='void *' info=''/>
+      <field name='sax' type='struct _xmlSAXHandler *'/>
+      <field name='userData' type='void *'/>
+      <field name='myDoc' type='xmlDocPtr'/>
+      <field name='wellFormed' type='int'/>
+      <field name='replaceEntities' type='int'/>
+      <field name='version' type='const xmlChar *'/>
+      <field name='encoding' type='const xmlChar *'/>
+      <field name='standalone' type='int'/>
+      <field name='html' type='int'/>
+      <field name='input' type='xmlParserInputPtr'/>
+      <field name='inputNr' type='int'/>
+      <field name='inputMax' type='int'/>
+      <field name='inputTab' type='xmlParserInputPtr *'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='nodeNr' type='int'/>
+      <field name='nodeMax' type='int'/>
+      <field name='nodeTab' type='xmlNodePtr *'/>
+      <field name='record_info' type='int'/>
+      <field name='node_seq' type='xmlParserNodeInfoSeq'/>
+      <field name='errNo' type='int'/>
+      <field name='hasExternalSubset' type='int'/>
+      <field name='hasPErefs' type='int'/>
+      <field name='external' type='int'/>
+      <field name='valid' type='int'/>
+      <field name='validate' type='int'/>
+      <field name='vctxt' type='xmlValidCtxt'/>
+      <field name='instate' type='xmlParserInputState'/>
+      <field name='token' type='int'/>
+      <field name='directory' type='char *'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='nameNr' type='int'/>
+      <field name='nameMax' type='int'/>
+      <field name='nameTab' type='const xmlChar **'/>
+      <field name='nbChars' type='long'/>
+      <field name='checkIndex' type='long'/>
+      <field name='keepBlanks' type='int'/>
+      <field name='disableSAX' type='int'/>
+      <field name='inSubset' type='int'/>
+      <field name='intSubName' type='const xmlChar *'/>
+      <field name='extSubURI' type='xmlChar *'/>
+      <field name='extSubSystem' type='xmlChar *'/>
+      <field name='space' type='int *'/>
+      <field name='spaceNr' type='int'/>
+      <field name='spaceMax' type='int'/>
+      <field name='spaceTab' type='int *'/>
+      <field name='depth' type='int'/>
+      <field name='entity' type='xmlParserInputPtr'/>
+      <field name='charset' type='int'/>
+      <field name='nodelen' type='int'/>
+      <field name='nodemem' type='int'/>
+      <field name='pedantic' type='int'/>
+      <field name='_private' type='void *'/>
+      <field name='loadsubset' type='int'/>
+      <field name='linenumbers' type='int'/>
+      <field name='catalogs' type='void *'/>
+      <field name='recovery' type='int'/>
+      <field name='progressive' type='int'/>
+      <field name='dict' type='xmlDictPtr'/>
+      <field name='atts' type='const xmlChar **'/>
+      <field name='maxatts' type='int'/>
+      <field name='docdict' type='int'/>
+      <field name='str_xml' type='const xmlChar *'/>
+      <field name='str_xmlns' type='const xmlChar *'/>
+      <field name='str_xml_ns' type='const xmlChar *'/>
+      <field name='sax2' type='int'/>
+      <field name='nsNr' type='int'/>
+      <field name='nsMax' type='int'/>
+      <field name='nsTab' type='const xmlChar **'/>
+      <field name='attallocs' type='unsigned *'/>
+      <field name='pushTab' type='xmlStartTag *'/>
+      <field name='attsDefault' type='xmlHashTablePtr'/>
+      <field name='attsSpecial' type='xmlHashTablePtr'/>
+      <field name='nsWellFormed' type='int'/>
+      <field name='options' type='int'/>
+      <field name='dictNames' type='int'/>
+      <field name='freeElemsNr' type='int'/>
+      <field name='freeElems' type='xmlNodePtr'/>
+      <field name='freeAttrsNr' type='int'/>
+      <field name='freeAttrs' type='xmlAttrPtr'/>
+      <field name='lastError' type='xmlError'/>
+      <field name='parseMode' type='xmlParserMode'/>
+      <field name='nbentities' type='unsigned long'/>
+      <field name='sizeentities' type='unsigned long'/>
+      <field name='nodeInfo' type='xmlParserNodeInfo *'/>
+      <field name='nodeInfoNr' type='int'/>
+      <field name='nodeInfoMax' type='int'/>
+      <field name='nodeInfoTab' type='xmlParserNodeInfo *'/>
+      <field name='input_id' type='int'/>
+      <field name='sizeentcopy' type='unsigned long'/>
+      <field name='endCheckState' type='int'/>
+      <field name='nbErrors' type='unsigned short'/>
+      <field name='nbWarnings' type='unsigned short'/>
+      <field name='maxAmpl' type='unsigned'/>
+      <field name='nsdb' type='xmlParserNsData *'/>
+      <field name='attrHashMax' type='unsigned'/>
+      <field name='attrHash' type='xmlAttrHashBucket *'/>
+      <field name='errorHandler' type='xmlStructuredErrorFunc'/>
+      <field name='errorCtxt' type='void *'/>
+      <field name='resourceLoader' type='xmlResourceLoader'/>
+      <field name='resourceCtxt' type='void *'/>
+      <field name='convImpl' type='xmlCharEncConvImpl'/>
+      <field name='convCtxt' type='void *'/>
     </struct>
     <typedef name='xmlParserCtxtPtr' file='tree' type='xmlParserCtxt *'/>
     <typedef name='xmlParserErrors' file='xmlerror' type='enum'/>
     <struct name='xmlParserInput' file='tree' type='struct _xmlParserInput'>
-      <field name='buf' type='xmlParserInputBufferPtr' info=' UTF-8 encoded buffer'/>
-      <field name='filename' type='const char *' info=' The file analyzed, if any'/>
-      <field name='directory' type='const char *' info=' unused'/>
-      <field name='base' type='const xmlChar *' info=' Base of the array to parse'/>
-      <field name='cur' type='const xmlChar *' info=' Current char being parsed'/>
-      <field name='end' type='const xmlChar *' info=' end of the array to parse'/>
-      <field name='length' type='int' info=' unused'/>
-      <field name='line' type='int' info=' Current line'/>
-      <field name='col' type='int' info=' Current column'/>
-      <field name='consumed' type='unsigned long' info=' How many xmlChars already consumed'/>
-      <field name='free' type='xmlParserInputDeallocate' info=' function to deallocate the base'/>
-      <field name='encoding' type='const xmlChar *' info=' unused'/>
-      <field name='version' type='const xmlChar *' info=' the version string for entity'/>
-      <field name='flags' type='int' info=' Flags'/>
-      <field name='id' type='int' info=' an unique identifier for the entity'/>
-      <field name='parentConsumed' type='unsigned long' info=' unused'/>
-      <field name='entity' type='xmlEntityPtr' info=' entity, if any'/>
+      <field name='buf' type='xmlParserInputBufferPtr'/>
+      <field name='filename' type='const char *'/>
+      <field name='directory' type='const char *'/>
+      <field name='base' type='const xmlChar *'/>
+      <field name='cur' type='const xmlChar *'/>
+      <field name='end' type='const xmlChar *'/>
+      <field name='length' type='int'/>
+      <field name='line' type='int'/>
+      <field name='col' type='int'/>
+      <field name='consumed' type='unsigned long'/>
+      <field name='free' type='xmlParserInputDeallocate'/>
+      <field name='encoding' type='const xmlChar *'/>
+      <field name='version' type='const xmlChar *'/>
+      <field name='flags' type='int'/>
+      <field name='id' type='int'/>
+      <field name='parentConsumed' type='unsigned long'/>
+      <field name='entity' type='xmlEntityPtr'/>
     </struct>
     <struct name='xmlParserInputBuffer' file='tree' type='struct _xmlParserInputBuffer'>
-      <field name='context' type='void *' info=''/>
-      <field name='readcallback' type='xmlInputReadCallback' info=''/>
-      <field name='closecallback' type='xmlInputCloseCallback' info=''/>
-      <field name='encoder' type='xmlCharEncodingHandlerPtr' info=' I18N conversions to UTF-8'/>
-      <field name='buffer' type='xmlBufPtr' info=' Local buffer encoded in UTF-8'/>
-      <field name='raw' type='xmlBufPtr' info=' if encoder != NULL buffer for raw input'/>
-      <field name='compressed' type='int' info=' -1=unknown, 0=not compressed, 1=compressed'/>
-      <field name='error' type='int' info=''/>
-      <field name='rawconsumed' type='unsigned long' info=' amount consumed from raw'/>
+      <field name='context' type='void *'/>
+      <field name='readcallback' type='xmlInputReadCallback'/>
+      <field name='closecallback' type='xmlInputCloseCallback'/>
+      <field name='encoder' type='xmlCharEncodingHandlerPtr'/>
+      <field name='buffer' type='xmlBufPtr'/>
+      <field name='raw' type='xmlBufPtr'/>
+      <field name='compressed' type='int'/>
+      <field name='error' type='int'/>
+      <field name='rawconsumed' type='unsigned long'/>
     </struct>
     <typedef name='xmlParserInputBufferPtr' file='tree' type='xmlParserInputBuffer *'/>
     <typedef name='xmlParserInputPtr' file='tree' type='xmlParserInput *'/>
     <typedef name='xmlParserInputState' file='parser' type='enum'/>
     <typedef name='xmlParserMode' file='parser' type='enum'/>
     <struct name='xmlParserNodeInfo' file='parser' type='struct _xmlParserNodeInfo'>
-      <field name='node' type='const struct _xmlNode *' info=' Position &amp; line # that text that created the node begins &amp; ends on'/>
-      <field name='begin_pos' type='unsigned long' info=''/>
-      <field name='begin_line' type='unsigned long' info=''/>
-      <field name='end_pos' type='unsigned long' info=''/>
-      <field name='end_line' type='unsigned long' info=''/>
+      <field name='node' type='const struct _xmlNode *'/>
+      <field name='begin_pos' type='unsigned long'/>
+      <field name='begin_line' type='unsigned long'/>
+      <field name='end_pos' type='unsigned long'/>
+      <field name='end_line' type='unsigned long'/>
     </struct>
     <typedef name='xmlParserNodeInfoPtr' file='parser' type='xmlParserNodeInfo *'/>
     <struct name='xmlParserNodeInfoSeq' file='parser' type='struct _xmlParserNodeInfoSeq'>
-      <field name='maximum' type='unsigned long' info=''/>
-      <field name='length' type='unsigned long' info=''/>
-      <field name='buffer' type='xmlParserNodeInfo *' info=''/>
+      <field name='maximum' type='unsigned long'/>
+      <field name='length' type='unsigned long'/>
+      <field name='buffer' type='xmlParserNodeInfo *'/>
     </struct>
     <typedef name='xmlParserNodeInfoSeqPtr' file='parser' type='xmlParserNodeInfoSeq *'/>
     <struct name='xmlParserNsData' file='parser' type='struct _xmlParserNsData'/>
@@ -6405,11 +6269,11 @@ set at the end of parsing'/>
     <typedef name='xmlRMutexPtr' file='threads' type='xmlRMutex *'/>
     <typedef name='xmlReaderTypes' file='xmlreader' type='enum'/>
     <struct name='xmlRef' file='tree' type='struct _xmlRef'>
-      <field name='next' type='struct _xmlRef *' info=' next Ref'/>
-      <field name='value' type='const xmlChar *' info=' The Ref name'/>
-      <field name='attr' type='xmlAttrPtr' info=' The attribute holding it'/>
-      <field name='name' type='const xmlChar *' info=' The attribute if attr is not available'/>
-      <field name='lineno' type='int' info=' The line number if attr is not available'/>
+      <field name='next' type='struct _xmlRef *'/>
+      <field name='value' type='const xmlChar *'/>
+      <field name='attr' type='xmlAttrPtr'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='lineno' type='int'/>
     </struct>
     <typedef name='xmlRefPtr' file='tree' type='xmlRef *'/>
     <struct name='xmlRefTable' file='valid' type='struct _xmlHashTable'/>
@@ -6430,224 +6294,210 @@ set at the end of parsing'/>
     <struct name='xmlRelaxNGValidCtxt' file='relaxng' type='struct _xmlRelaxNGValidCtxt'/>
     <typedef name='xmlRelaxNGValidCtxtPtr' file='relaxng' type='xmlRelaxNGValidCtxt *'/>
     <typedef name='xmlRelaxNGValidErr' file='relaxng' type='enum'/>
+    <typedef name='xmlResourceType' file='parser' type='enum'/>
     <struct name='xmlSAXHandler' file='tree' type='struct _xmlSAXHandler'>
-      <field name='internalSubset' type='internalSubsetSAXFunc' info=''/>
-      <field name='isStandalone' type='isStandaloneSAXFunc' info=''/>
-      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc' info=''/>
-      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc' info=''/>
-      <field name='resolveEntity' type='resolveEntitySAXFunc' info=''/>
-      <field name='getEntity' type='getEntitySAXFunc' info=''/>
-      <field name='entityDecl' type='entityDeclSAXFunc' info=''/>
-      <field name='notationDecl' type='notationDeclSAXFunc' info=''/>
-      <field name='attributeDecl' type='attributeDeclSAXFunc' info=''/>
-      <field name='elementDecl' type='elementDeclSAXFunc' info=''/>
-      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc' info=''/>
-      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc' info=''/>
-      <field name='startDocument' type='startDocumentSAXFunc' info=''/>
-      <field name='endDocument' type='endDocumentSAXFunc' info='* `startElement` and `endElement` are only used by the legacy SAX1
-* interface and should not be used in new software. If you really
-* have to enable SAX1, the preferred way is set the `initialized`
-* member to 1 instead of XML_SAX2_MAGIC.
-*
-* For backward compatibility, it&apos;s also possible to set the
-* `startElementNs` and `endElementNs` handlers to NULL.
-*
-* You can also set the XML_PARSE_SAX1 parser option, but versions
-* older than 2.12.0 will probably crash if this option is provided
-* together with custom SAX callbacks.
-*'/>
-      <field name='startElement' type='startElementSAXFunc' info=''/>
-      <field name='endElement' type='endElementSAXFunc' info=''/>
-      <field name='reference' type='referenceSAXFunc' info=''/>
-      <field name='characters' type='charactersSAXFunc' info=''/>
-      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc' info=''/>
-      <field name='processingInstruction' type='processingInstructionSAXFunc' info=''/>
-      <field name='comment' type='commentSAXFunc' info=''/>
-      <field name='warning' type='warningSAXFunc' info=''/>
-      <field name='error' type='errorSAXFunc' info=''/>
-      <field name='fatalError' type='fatalErrorSAXFunc' info=' unused error() get all the errors'/>
-      <field name='getParameterEntity' type='getParameterEntitySAXFunc' info=''/>
-      <field name='cdataBlock' type='cdataBlockSAXFunc' info=''/>
-      <field name='externalSubset' type='externalSubsetSAXFunc' info='* `initialized` should always be set to XML_SAX2_MAGIC to enable the
-* modern SAX2 interface.
-*'/>
-      <field name='initialized' type='unsigned int' info='* The following members are only used by the SAX2 interface.
-*'/>
-      <field name='_private' type='void *' info=''/>
-      <field name='startElementNs' type='startElementNsSAX2Func' info=''/>
-      <field name='endElementNs' type='endElementNsSAX2Func' info=''/>
-      <field name='serror' type='xmlStructuredErrorFunc' info=''/>
+      <field name='internalSubset' type='internalSubsetSAXFunc'/>
+      <field name='isStandalone' type='isStandaloneSAXFunc'/>
+      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc'/>
+      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc'/>
+      <field name='resolveEntity' type='resolveEntitySAXFunc'/>
+      <field name='getEntity' type='getEntitySAXFunc'/>
+      <field name='entityDecl' type='entityDeclSAXFunc'/>
+      <field name='notationDecl' type='notationDeclSAXFunc'/>
+      <field name='attributeDecl' type='attributeDeclSAXFunc'/>
+      <field name='elementDecl' type='elementDeclSAXFunc'/>
+      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc'/>
+      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc'/>
+      <field name='startDocument' type='startDocumentSAXFunc'/>
+      <field name='endDocument' type='endDocumentSAXFunc'/>
+      <field name='startElement' type='startElementSAXFunc'/>
+      <field name='endElement' type='endElementSAXFunc'/>
+      <field name='reference' type='referenceSAXFunc'/>
+      <field name='characters' type='charactersSAXFunc'/>
+      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc'/>
+      <field name='processingInstruction' type='processingInstructionSAXFunc'/>
+      <field name='comment' type='commentSAXFunc'/>
+      <field name='warning' type='warningSAXFunc'/>
+      <field name='error' type='errorSAXFunc'/>
+      <field name='fatalError' type='fatalErrorSAXFunc'/>
+      <field name='getParameterEntity' type='getParameterEntitySAXFunc'/>
+      <field name='cdataBlock' type='cdataBlockSAXFunc'/>
+      <field name='externalSubset' type='externalSubsetSAXFunc'/>
+      <field name='initialized' type='unsigned int'/>
+      <field name='_private' type='void *'/>
+      <field name='startElementNs' type='startElementNsSAX2Func'/>
+      <field name='endElementNs' type='endElementNsSAX2Func'/>
+      <field name='serror' type='xmlStructuredErrorFunc'/>
     </struct>
     <typedef name='xmlSAXHandlerPtr' file='tree' type='xmlSAXHandler *'/>
     <struct name='xmlSAXHandlerV1' file='parser' type='struct _xmlSAXHandlerV1'>
-      <field name='internalSubset' type='internalSubsetSAXFunc' info=''/>
-      <field name='isStandalone' type='isStandaloneSAXFunc' info=''/>
-      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc' info=''/>
-      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc' info=''/>
-      <field name='resolveEntity' type='resolveEntitySAXFunc' info=''/>
-      <field name='getEntity' type='getEntitySAXFunc' info=''/>
-      <field name='entityDecl' type='entityDeclSAXFunc' info=''/>
-      <field name='notationDecl' type='notationDeclSAXFunc' info=''/>
-      <field name='attributeDecl' type='attributeDeclSAXFunc' info=''/>
-      <field name='elementDecl' type='elementDeclSAXFunc' info=''/>
-      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc' info=''/>
-      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc' info=''/>
-      <field name='startDocument' type='startDocumentSAXFunc' info=''/>
-      <field name='endDocument' type='endDocumentSAXFunc' info=''/>
-      <field name='startElement' type='startElementSAXFunc' info=''/>
-      <field name='endElement' type='endElementSAXFunc' info=''/>
-      <field name='reference' type='referenceSAXFunc' info=''/>
-      <field name='characters' type='charactersSAXFunc' info=''/>
-      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc' info=''/>
-      <field name='processingInstruction' type='processingInstructionSAXFunc' info=''/>
-      <field name='comment' type='commentSAXFunc' info=''/>
-      <field name='warning' type='warningSAXFunc' info=''/>
-      <field name='error' type='errorSAXFunc' info=''/>
-      <field name='fatalError' type='fatalErrorSAXFunc' info=' unused error() get all the errors'/>
-      <field name='getParameterEntity' type='getParameterEntitySAXFunc' info=''/>
-      <field name='cdataBlock' type='cdataBlockSAXFunc' info=''/>
-      <field name='externalSubset' type='externalSubsetSAXFunc' info=''/>
-      <field name='initialized' type='unsigned int' info=''/>
+      <field name='internalSubset' type='internalSubsetSAXFunc'/>
+      <field name='isStandalone' type='isStandaloneSAXFunc'/>
+      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc'/>
+      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc'/>
+      <field name='resolveEntity' type='resolveEntitySAXFunc'/>
+      <field name='getEntity' type='getEntitySAXFunc'/>
+      <field name='entityDecl' type='entityDeclSAXFunc'/>
+      <field name='notationDecl' type='notationDeclSAXFunc'/>
+      <field name='attributeDecl' type='attributeDeclSAXFunc'/>
+      <field name='elementDecl' type='elementDeclSAXFunc'/>
+      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc'/>
+      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc'/>
+      <field name='startDocument' type='startDocumentSAXFunc'/>
+      <field name='endDocument' type='endDocumentSAXFunc'/>
+      <field name='startElement' type='startElementSAXFunc'/>
+      <field name='endElement' type='endElementSAXFunc'/>
+      <field name='reference' type='referenceSAXFunc'/>
+      <field name='characters' type='charactersSAXFunc'/>
+      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc'/>
+      <field name='processingInstruction' type='processingInstructionSAXFunc'/>
+      <field name='comment' type='commentSAXFunc'/>
+      <field name='warning' type='warningSAXFunc'/>
+      <field name='error' type='errorSAXFunc'/>
+      <field name='fatalError' type='fatalErrorSAXFunc'/>
+      <field name='getParameterEntity' type='getParameterEntitySAXFunc'/>
+      <field name='cdataBlock' type='cdataBlockSAXFunc'/>
+      <field name='externalSubset' type='externalSubsetSAXFunc'/>
+      <field name='initialized' type='unsigned int'/>
     </struct>
     <typedef name='xmlSAXHandlerV1Ptr' file='parser' type='xmlSAXHandlerV1 *'/>
     <struct name='xmlSAXLocator' file='tree' type='struct _xmlSAXLocator'>
-      <field name='getPublicId' type='const xmlChar *(*getPublicId)' info=''/>
-      <field name='getSystemId' type='const xmlChar *(*getSystemId)' info=''/>
-      <field name='getLineNumber' type='int(*getLineNumber)' info=''/>
-      <field name='getColumnNumber' type='int(*getColumnNumber)' info=''/>
+      <field name='getPublicId' type='const xmlChar *(*getPublicId)'/>
+      <field name='getSystemId' type='const xmlChar *(*getSystemId)'/>
+      <field name='getLineNumber' type='int(*getLineNumber)'/>
+      <field name='getColumnNumber' type='int(*getColumnNumber)'/>
     </struct>
     <typedef name='xmlSAXLocatorPtr' file='tree' type='xmlSAXLocator *'/>
     <struct name='xmlSaveCtxt' file='xmlsave' type='struct _xmlSaveCtxt'/>
     <typedef name='xmlSaveCtxtPtr' file='xmlsave' type='xmlSaveCtxt *'/>
     <typedef name='xmlSaveOption' file='xmlsave' type='enum'/>
     <struct name='xmlSchema' file='xmlschemas' type='struct _xmlSchema'>
-      <field name='name' type='const xmlChar *' info=' schema name'/>
-      <field name='targetNamespace' type='const xmlChar *' info=' the target namespace'/>
-      <field name='version' type='const xmlChar *' info=''/>
-      <field name='id' type='const xmlChar *' info=' Obsolete'/>
-      <field name='doc' type='xmlDocPtr' info=''/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='flags' type='int' info=''/>
-      <field name='typeDecl' type='xmlHashTablePtr' info=''/>
-      <field name='attrDecl' type='xmlHashTablePtr' info=''/>
-      <field name='attrgrpDecl' type='xmlHashTablePtr' info=''/>
-      <field name='elemDecl' type='xmlHashTablePtr' info=''/>
-      <field name='notaDecl' type='xmlHashTablePtr' info=''/>
-      <field name='schemasImports' type='xmlHashTablePtr' info=''/>
-      <field name='_private' type='void *' info=' unused by the library for users or bindings'/>
-      <field name='groupDecl' type='xmlHashTablePtr' info=''/>
-      <field name='dict' type='xmlDictPtr' info=''/>
-      <field name='includes' type='void *' info=' the includes, this is opaque for now'/>
-      <field name='preserve' type='int' info=' whether to free the document'/>
-      <field name='counter' type='int' info=' used to give anonymous components unique names'/>
-      <field name='idcDef' type='xmlHashTablePtr' info=' All identity-constraint defs.'/>
-      <field name='volatiles' type='void *' info=' Obsolete'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
+      <field name='version' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='doc' type='xmlDocPtr'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='flags' type='int'/>
+      <field name='typeDecl' type='xmlHashTablePtr'/>
+      <field name='attrDecl' type='xmlHashTablePtr'/>
+      <field name='attrgrpDecl' type='xmlHashTablePtr'/>
+      <field name='elemDecl' type='xmlHashTablePtr'/>
+      <field name='notaDecl' type='xmlHashTablePtr'/>
+      <field name='schemasImports' type='xmlHashTablePtr'/>
+      <field name='_private' type='void *'/>
+      <field name='groupDecl' type='xmlHashTablePtr'/>
+      <field name='dict' type='xmlDictPtr'/>
+      <field name='includes' type='void *'/>
+      <field name='preserve' type='int'/>
+      <field name='counter' type='int'/>
+      <field name='idcDef' type='xmlHashTablePtr'/>
+      <field name='volatiles' type='void *'/>
     </struct>
     <struct name='xmlSchemaAnnot' file='schemasInternals' type='struct _xmlSchemaAnnot'>
-      <field name='next' type='struct _xmlSchemaAnnot *' info=''/>
-      <field name='content' type='xmlNodePtr' info=' the annotation'/>
+      <field name='next' type='struct _xmlSchemaAnnot *'/>
+      <field name='content' type='xmlNodePtr'/>
     </struct>
     <typedef name='xmlSchemaAnnotPtr' file='schemasInternals' type='xmlSchemaAnnot *'/>
     <struct name='xmlSchemaAttribute' file='schemasInternals' type='struct _xmlSchemaAttribute'>
-      <field name='type' type='xmlSchemaTypeType' info=''/>
-      <field name='next' type='struct _xmlSchemaAttribute *' info=' the next attribute (not used?)'/>
-      <field name='name' type='const xmlChar *' info=' the name of the declaration'/>
-      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='typeName' type='const xmlChar *' info=' the local name of the type definition'/>
-      <field name='typeNs' type='const xmlChar *' info=' the ns URI of the type definition'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='base' type='xmlSchemaTypePtr' info=' Deprecated; not used'/>
-      <field name='occurs' type='int' info=' Deprecated; not used'/>
-      <field name='defValue' type='const xmlChar *' info=' The initial value of the value constraint'/>
-      <field name='subtypes' type='xmlSchemaTypePtr' info=' the type definition'/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='targetNamespace' type='const xmlChar *' info=''/>
-      <field name='flags' type='int' info=''/>
-      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='defVal' type='xmlSchemaValPtr' info=' The compiled value constraint'/>
-      <field name='refDecl' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='next' type='struct _xmlSchemaAttribute *'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='ref' type='const xmlChar *'/>
+      <field name='refNs' type='const xmlChar *'/>
+      <field name='typeName' type='const xmlChar *'/>
+      <field name='typeNs' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='base' type='xmlSchemaTypePtr'/>
+      <field name='occurs' type='int'/>
+      <field name='defValue' type='const xmlChar *'/>
+      <field name='subtypes' type='xmlSchemaTypePtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
+      <field name='flags' type='int'/>
+      <field name='refPrefix' type='const xmlChar *'/>
+      <field name='defVal' type='xmlSchemaValPtr'/>
+      <field name='refDecl' type='xmlSchemaAttributePtr'/>
     </struct>
     <struct name='xmlSchemaAttributeGroup' file='schemasInternals' type='struct _xmlSchemaAttributeGroup'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='next' type='struct _xmlSchemaAttribute *' info=' the next attribute if in a group ...'/>
-      <field name='name' type='const xmlChar *' info=''/>
-      <field name='id' type='const xmlChar *' info=''/>
-      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='attributes' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='flags' type='int' info=''/>
-      <field name='attributeWildcard' type='xmlSchemaWildcardPtr' info=''/>
-      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='refItem' type='xmlSchemaAttributeGroupPtr' info=' Deprecated; not used'/>
-      <field name='targetNamespace' type='const xmlChar *' info=''/>
-      <field name='attrUses' type='void *' info=''/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='next' type='struct _xmlSchemaAttribute *'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='ref' type='const xmlChar *'/>
+      <field name='refNs' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='attributes' type='xmlSchemaAttributePtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='flags' type='int'/>
+      <field name='attributeWildcard' type='xmlSchemaWildcardPtr'/>
+      <field name='refPrefix' type='const xmlChar *'/>
+      <field name='refItem' type='xmlSchemaAttributeGroupPtr'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
+      <field name='attrUses' type='void *'/>
     </struct>
     <typedef name='xmlSchemaAttributeGroupPtr' file='schemasInternals' type='xmlSchemaAttributeGroup *'/>
     <struct name='xmlSchemaAttributeLink' file='schemasInternals' type='struct _xmlSchemaAttributeLink'>
-      <field name='next' type='struct _xmlSchemaAttributeLink *' info=' the next attribute link ...'/>
-      <field name='attr' type='struct _xmlSchemaAttribute *' info=' the linked attribute'/>
+      <field name='next' type='struct _xmlSchemaAttributeLink *'/>
+      <field name='attr' type='struct _xmlSchemaAttribute *'/>
     </struct>
     <typedef name='xmlSchemaAttributeLinkPtr' file='schemasInternals' type='xmlSchemaAttributeLink *'/>
     <typedef name='xmlSchemaAttributePtr' file='schemasInternals' type='xmlSchemaAttribute *'/>
     <typedef name='xmlSchemaContentType' file='schemasInternals' type='enum'/>
     <struct name='xmlSchemaElement' file='schemasInternals' type='struct _xmlSchemaElement'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='next' type='struct _xmlSchemaType *' info=' Not used?'/>
-      <field name='name' type='const xmlChar *' info=''/>
-      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='subtypes' type='xmlSchemaTypePtr' info=' the type definition'/>
-      <field name='attributes' type='xmlSchemaAttributePtr' info=''/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='flags' type='int' info=''/>
-      <field name='targetNamespace' type='const xmlChar *' info=''/>
-      <field name='namedType' type='const xmlChar *' info=''/>
-      <field name='namedTypeNs' type='const xmlChar *' info=''/>
-      <field name='substGroup' type='const xmlChar *' info=''/>
-      <field name='substGroupNs' type='const xmlChar *' info=''/>
-      <field name='scope' type='const xmlChar *' info=''/>
-      <field name='value' type='const xmlChar *' info=' The original value of the value constraint.'/>
-      <field name='refDecl' type='struct _xmlSchemaElement *' info=' This will now be used for the
-substitution group affiliation'/>
-      <field name='contModel' type='xmlRegexpPtr' info=' Obsolete for WXS, maybe used for RelaxNG'/>
-      <field name='contentType' type='xmlSchemaContentType' info=''/>
-      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='defVal' type='xmlSchemaValPtr' info=' The compiled value constraint.'/>
-      <field name='idcs' type='void *' info=' The identity-constraint defs'/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='next' type='struct _xmlSchemaType *'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='ref' type='const xmlChar *'/>
+      <field name='refNs' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='subtypes' type='xmlSchemaTypePtr'/>
+      <field name='attributes' type='xmlSchemaAttributePtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='minOccurs' type='int'/>
+      <field name='maxOccurs' type='int'/>
+      <field name='flags' type='int'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
+      <field name='namedType' type='const xmlChar *'/>
+      <field name='namedTypeNs' type='const xmlChar *'/>
+      <field name='substGroup' type='const xmlChar *'/>
+      <field name='substGroupNs' type='const xmlChar *'/>
+      <field name='scope' type='const xmlChar *'/>
+      <field name='value' type='const xmlChar *'/>
+      <field name='refDecl' type='struct _xmlSchemaElement *'/>
+      <field name='contModel' type='xmlRegexpPtr'/>
+      <field name='contentType' type='xmlSchemaContentType'/>
+      <field name='refPrefix' type='const xmlChar *'/>
+      <field name='defVal' type='xmlSchemaValPtr'/>
+      <field name='idcs' type='void *'/>
     </struct>
     <typedef name='xmlSchemaElementPtr' file='schemasInternals' type='xmlSchemaElement *'/>
     <struct name='xmlSchemaFacet' file='schemasInternals' type='struct _xmlSchemaFacet'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='next' type='struct _xmlSchemaFacet *' info=' the next type if in a sequence ...'/>
-      <field name='value' type='const xmlChar *' info=' The original value'/>
-      <field name='id' type='const xmlChar *' info=' Obsolete'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='fixed' type='int' info=' XML_SCHEMAS_FACET_PRESERVE, etc.'/>
-      <field name='whitespace' type='int' info=''/>
-      <field name='val' type='xmlSchemaValPtr' info=' The compiled value'/>
-      <field name='regexp' type='xmlRegexpPtr' info=' The regex for patterns'/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='next' type='struct _xmlSchemaFacet *'/>
+      <field name='value' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='fixed' type='int'/>
+      <field name='whitespace' type='int'/>
+      <field name='val' type='xmlSchemaValPtr'/>
+      <field name='regexp' type='xmlRegexpPtr'/>
     </struct>
     <struct name='xmlSchemaFacetLink' file='schemasInternals' type='struct _xmlSchemaFacetLink'>
-      <field name='next' type='struct _xmlSchemaFacetLink *' info=' the next facet link ...'/>
-      <field name='facet' type='xmlSchemaFacetPtr' info=' the linked facet'/>
+      <field name='next' type='struct _xmlSchemaFacetLink *'/>
+      <field name='facet' type='xmlSchemaFacetPtr'/>
     </struct>
     <typedef name='xmlSchemaFacetLinkPtr' file='schemasInternals' type='xmlSchemaFacetLink *'/>
     <typedef name='xmlSchemaFacetPtr' file='schemasInternals' type='xmlSchemaFacet *'/>
     <struct name='xmlSchemaNotation' file='schemasInternals' type='struct _xmlSchemaNotation'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='name' type='const xmlChar *' info=''/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='identifier' type='const xmlChar *' info=''/>
-      <field name='targetNamespace' type='const xmlChar *' info=''/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='identifier' type='const xmlChar *'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlSchemaNotationPtr' file='schemasInternals' type='xmlSchemaNotation *'/>
     <struct name='xmlSchemaParserCtxt' file='xmlschemas' type='struct _xmlSchemaParserCtxt'/>
@@ -6656,41 +6506,40 @@ substitution group affiliation'/>
     <typedef name='xmlSchemaSAXPlugPtr' file='xmlschemas' type='xmlSchemaSAXPlugStruct *'/>
     <struct name='xmlSchemaSAXPlugStruct' file='xmlschemas' type='struct _xmlSchemaSAXPlug'/>
     <struct name='xmlSchemaType' file='schemasInternals' type='struct _xmlSchemaType'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='next' type='struct _xmlSchemaType *' info=' the next type if in a sequence ...'/>
-      <field name='name' type='const xmlChar *' info=''/>
-      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='subtypes' type='xmlSchemaTypePtr' info=''/>
-      <field name='attributes' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='flags' type='int' info=''/>
-      <field name='contentType' type='xmlSchemaContentType' info=''/>
-      <field name='base' type='const xmlChar *' info=' Base type&apos;s local name'/>
-      <field name='baseNs' type='const xmlChar *' info=' Base type&apos;s target namespace'/>
-      <field name='baseType' type='xmlSchemaTypePtr' info=' The base type component'/>
-      <field name='facets' type='xmlSchemaFacetPtr' info=' Local facets'/>
-      <field name='redef' type='struct _xmlSchemaType *' info=' Deprecated; not used'/>
-      <field name='recurse' type='int' info=' Obsolete'/>
-      <field name='attributeUses' type='xmlSchemaAttributeLinkPtr *' info=' Deprecated; not used'/>
-      <field name='attributeWildcard' type='xmlSchemaWildcardPtr' info=''/>
-      <field name='builtInType' type='int' info=' Type of built-in types.'/>
-      <field name='memberTypes' type='xmlSchemaTypeLinkPtr' info=' member-types if a union type.'/>
-      <field name='facetSet' type='xmlSchemaFacetLinkPtr' info=' All facets (incl. inherited)'/>
-      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='contentTypeDef' type='xmlSchemaTypePtr' info=' Used for the simple content of complex types.
-Could we use @subtypes for this?'/>
-      <field name='contModel' type='xmlRegexpPtr' info=' Holds the automaton of the content model'/>
-      <field name='targetNamespace' type='const xmlChar *' info=''/>
-      <field name='attrUses' type='void *' info=''/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='next' type='struct _xmlSchemaType *'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='ref' type='const xmlChar *'/>
+      <field name='refNs' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='subtypes' type='xmlSchemaTypePtr'/>
+      <field name='attributes' type='xmlSchemaAttributePtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='minOccurs' type='int'/>
+      <field name='maxOccurs' type='int'/>
+      <field name='flags' type='int'/>
+      <field name='contentType' type='xmlSchemaContentType'/>
+      <field name='base' type='const xmlChar *'/>
+      <field name='baseNs' type='const xmlChar *'/>
+      <field name='baseType' type='xmlSchemaTypePtr'/>
+      <field name='facets' type='xmlSchemaFacetPtr'/>
+      <field name='redef' type='struct _xmlSchemaType *'/>
+      <field name='recurse' type='int'/>
+      <field name='attributeUses' type='xmlSchemaAttributeLinkPtr *'/>
+      <field name='attributeWildcard' type='xmlSchemaWildcardPtr'/>
+      <field name='builtInType' type='int'/>
+      <field name='memberTypes' type='xmlSchemaTypeLinkPtr'/>
+      <field name='facetSet' type='xmlSchemaFacetLinkPtr'/>
+      <field name='refPrefix' type='const xmlChar *'/>
+      <field name='contentTypeDef' type='xmlSchemaTypePtr'/>
+      <field name='contModel' type='xmlRegexpPtr'/>
+      <field name='targetNamespace' type='const xmlChar *'/>
+      <field name='attrUses' type='void *'/>
     </struct>
     <struct name='xmlSchemaTypeLink' file='schemasInternals' type='struct _xmlSchemaTypeLink'>
-      <field name='next' type='struct _xmlSchemaTypeLink *' info=' the next type link ...'/>
-      <field name='type' type='xmlSchemaTypePtr' info=' the linked type'/>
+      <field name='next' type='struct _xmlSchemaTypeLink *'/>
+      <field name='type' type='xmlSchemaTypePtr'/>
     </struct>
     <typedef name='xmlSchemaTypeLinkPtr' file='schemasInternals' type='xmlSchemaTypeLink *'/>
     <typedef name='xmlSchemaTypePtr' file='schemasInternals' type='xmlSchemaType *'/>
@@ -6704,21 +6553,21 @@ Could we use @subtypes for this?'/>
     <typedef name='xmlSchemaValidOption' file='xmlschemas' type='enum'/>
     <typedef name='xmlSchemaWhitespaceValueType' file='xmlschemastypes' type='enum'/>
     <struct name='xmlSchemaWildcard' file='schemasInternals' type='struct _xmlSchemaWildcard'>
-      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
-      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
-      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
-      <field name='processContents' type='int' info=''/>
-      <field name='any' type='int' info=' Indicates if the ns constraint is of ##any'/>
-      <field name='nsSet' type='xmlSchemaWildcardNsPtr' info=' The list of allowed namespaces'/>
-      <field name='negNsSet' type='xmlSchemaWildcardNsPtr' info=' The negated namespace'/>
-      <field name='flags' type='int' info=''/>
+      <field name='type' type='xmlSchemaTypeType'/>
+      <field name='id' type='const xmlChar *'/>
+      <field name='annot' type='xmlSchemaAnnotPtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='minOccurs' type='int'/>
+      <field name='maxOccurs' type='int'/>
+      <field name='processContents' type='int'/>
+      <field name='any' type='int'/>
+      <field name='nsSet' type='xmlSchemaWildcardNsPtr'/>
+      <field name='negNsSet' type='xmlSchemaWildcardNsPtr'/>
+      <field name='flags' type='int'/>
     </struct>
     <struct name='xmlSchemaWildcardNs' file='schemasInternals' type='struct _xmlSchemaWildcardNs'>
-      <field name='next' type='struct _xmlSchemaWildcardNs *' info=' the next constraint link ...'/>
-      <field name='value' type='const xmlChar *' info=' the value'/>
+      <field name='next' type='struct _xmlSchemaWildcardNs *'/>
+      <field name='value' type='const xmlChar *'/>
     </struct>
     <typedef name='xmlSchemaWildcardNsPtr' file='schemasInternals' type='xmlSchemaWildcardNs *'/>
     <typedef name='xmlSchemaWildcardPtr' file='schemasInternals' type='xmlSchemaWildcard *'/>
@@ -6729,16 +6578,6 @@ Could we use @subtypes for this?'/>
     <struct name='xmlSchematronValidCtxt' file='schematron' type='struct _xmlSchematronValidCtxt'/>
     <typedef name='xmlSchematronValidCtxtPtr' file='schematron' type='xmlSchematronValidCtxt *'/>
     <typedef name='xmlSchematronValidOptions' file='schematron' type='enum'/>
-    <struct name='xmlShellCtxt' file='debugXML' type='struct _xmlShellCtxt'>
-      <field name='filename' type='char *' info=''/>
-      <field name='doc' type='xmlDocPtr' info=''/>
-      <field name='node' type='xmlNodePtr' info=''/>
-      <field name='pctxt' type='xmlXPathContextPtr' info=''/>
-      <field name='loaded' type='int' info=''/>
-      <field name='output' type='FILE *' info=''/>
-      <field name='input' type='xmlShellReadlineFunc' info=''/>
-    </struct>
-    <typedef name='xmlShellCtxtPtr' file='debugXML' type='xmlShellCtxt *'/>
     <struct name='xmlStartTag' file='parser' type='struct _xmlStartTag'/>
     <struct name='xmlStreamCtxt' file='pattern' type='struct _xmlStreamCtxt'/>
     <typedef name='xmlStreamCtxtPtr' file='pattern' type='xmlStreamCtxt *'/>
@@ -6751,38 +6590,38 @@ Could we use @subtypes for this?'/>
     <struct name='xmlTextWriter' file='xmlwriter' type='struct _xmlTextWriter'/>
     <typedef name='xmlTextWriterPtr' file='xmlwriter' type='xmlTextWriter *'/>
     <struct name='xmlURI' file='uri' type='struct _xmlURI'>
-      <field name='scheme' type='char *' info=' the URI scheme'/>
-      <field name='opaque' type='char *' info=' opaque part'/>
-      <field name='authority' type='char *' info=' the authority part'/>
-      <field name='server' type='char *' info=' the server part'/>
-      <field name='user' type='char *' info=' the user part'/>
-      <field name='port' type='int' info=' the port number'/>
-      <field name='path' type='char *' info=' the path string'/>
-      <field name='query' type='char *' info=' the query string (deprecated - use with caution)'/>
-      <field name='fragment' type='char *' info=' the fragment identifier'/>
-      <field name='cleanup' type='int' info=' parsing potentially unclean URI'/>
-      <field name='query_raw' type='char *' info=' the query string (as it appears in the URI)'/>
+      <field name='scheme' type='char *'/>
+      <field name='opaque' type='char *'/>
+      <field name='authority' type='char *'/>
+      <field name='server' type='char *'/>
+      <field name='user' type='char *'/>
+      <field name='port' type='int'/>
+      <field name='path' type='char *'/>
+      <field name='query' type='char *'/>
+      <field name='fragment' type='char *'/>
+      <field name='cleanup' type='int'/>
+      <field name='query_raw' type='char *'/>
     </struct>
     <typedef name='xmlURIPtr' file='uri' type='xmlURI *'/>
     <struct name='xmlValidCtxt' file='valid' type='struct _xmlValidCtxt'>
-      <field name='userData' type='void *' info=' user specific data block'/>
-      <field name='error' type='xmlValidityErrorFunc' info=' the callback in case of errors'/>
-      <field name='warning' type='xmlValidityWarningFunc' info=' the callback in case of warning Node analysis stack used when validating within entities'/>
-      <field name='node' type='xmlNodePtr' info=' Current parsed Node'/>
-      <field name='nodeNr' type='int' info=' Depth of the parsing stack'/>
-      <field name='nodeMax' type='int' info=' Max depth of the parsing stack'/>
-      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes'/>
-      <field name='flags' type='unsigned int' info=' internal flags'/>
-      <field name='doc' type='xmlDocPtr' info=' the document'/>
-      <field name='valid' type='int' info=' temporary validity check result state state used for non-determinist content validation'/>
-      <field name='vstate' type='xmlValidState *' info=' current state'/>
-      <field name='vstateNr' type='int' info=' Depth of the validation stack'/>
-      <field name='vstateMax' type='int' info=' Max depth of the validation stack'/>
-      <field name='vstateTab' type='xmlValidState *' info=' array of validation states'/>
-      <field name='am' type='xmlAutomataPtr' info=' the automata'/>
-      <field name='state' type='xmlAutomataStatePtr' info=' used to build the automata'/>
-      <field name='am' type='void *' info=''/>
-      <field name='state' type='void *' info=''/>
+      <field name='userData' type='void *'/>
+      <field name='error' type='xmlValidityErrorFunc'/>
+      <field name='warning' type='xmlValidityWarningFunc'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='nodeNr' type='int'/>
+      <field name='nodeMax' type='int'/>
+      <field name='nodeTab' type='xmlNodePtr *'/>
+      <field name='flags' type='unsigned int'/>
+      <field name='doc' type='xmlDocPtr'/>
+      <field name='valid' type='int'/>
+      <field name='vstate' type='xmlValidState *'/>
+      <field name='vstateNr' type='int'/>
+      <field name='vstateMax' type='int'/>
+      <field name='vstateTab' type='xmlValidState *'/>
+      <field name='am' type='xmlAutomataPtr'/>
+      <field name='state' type='xmlAutomataStatePtr'/>
+      <field name='am' type='void *'/>
+      <field name='state' type='void *'/>
     </struct>
     <typedef name='xmlValidCtxtPtr' file='valid' type='xmlValidCtxt *'/>
     <struct name='xmlValidState' file='valid' type='struct _xmlValidState'/>
@@ -6790,108 +6629,106 @@ Could we use @subtypes for this?'/>
     <struct name='xmlXIncludeCtxt' file='xinclude' type='struct _xmlXIncludeCtxt'/>
     <typedef name='xmlXIncludeCtxtPtr' file='xinclude' type='xmlXIncludeCtxt *'/>
     <struct name='xmlXPathAxis' file='xpath' type='struct _xmlXPathAxis'>
-      <field name='name' type='const xmlChar *' info=' the axis name'/>
-      <field name='func' type='xmlXPathAxisFunc' info=' the search function'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='func' type='xmlXPathAxisFunc'/>
     </struct>
     <typedef name='xmlXPathAxisPtr' file='xpath' type='xmlXPathAxis *'/>
     <struct name='xmlXPathCompExpr' file='xpath' type='struct _xmlXPathCompExpr'/>
     <typedef name='xmlXPathCompExprPtr' file='xpath' type='xmlXPathCompExpr *'/>
     <struct name='xmlXPathContext' file='xpath' type='struct _xmlXPathContext'>
-      <field name='doc' type='xmlDocPtr' info=' The current document'/>
-      <field name='node' type='xmlNodePtr' info=' The current node'/>
-      <field name='nb_variables_unused' type='int' info=' unused (hash table)'/>
-      <field name='max_variables_unused' type='int' info=' unused (hash table)'/>
-      <field name='varHash' type='xmlHashTablePtr' info=' Hash table of defined variables'/>
-      <field name='nb_types' type='int' info=' number of defined types'/>
-      <field name='max_types' type='int' info=' max number of types'/>
-      <field name='types' type='xmlXPathTypePtr' info=' Array of defined types'/>
-      <field name='nb_funcs_unused' type='int' info=' unused (hash table)'/>
-      <field name='max_funcs_unused' type='int' info=' unused (hash table)'/>
-      <field name='funcHash' type='xmlHashTablePtr' info=' Hash table of defined funcs'/>
-      <field name='nb_axis' type='int' info=' number of defined axis'/>
-      <field name='max_axis' type='int' info=' max number of axis'/>
-      <field name='axis' type='xmlXPathAxisPtr' info=' Array of defined axis the namespace nodes of the context node'/>
-      <field name='namespaces' type='xmlNsPtr *' info=' Array of namespaces'/>
-      <field name='nsNr' type='int' info=' number of namespace in scope'/>
-      <field name='user' type='void *' info=' function to free extra variables'/>
-      <field name='contextSize' type='int' info=' the context size'/>
-      <field name='proximityPosition' type='int' info=' the proximity position extra stuff for XPointer'/>
-      <field name='xptr' type='int' info=' is this an XPointer context?'/>
-      <field name='here' type='xmlNodePtr' info=' for here()'/>
-      <field name='origin' type='xmlNodePtr' info=' for origin() the set of namespace declarations in scope for the expression'/>
-      <field name='nsHash' type='xmlHashTablePtr' info=' The namespaces hash table'/>
-      <field name='varLookupFunc' type='xmlXPathVariableLookupFunc' info=' variable lookup func'/>
-      <field name='varLookupData' type='void *' info=' variable lookup data Possibility to link in an extra item'/>
-      <field name='extra' type='void *' info=' needed for XSLT The function name and URI when calling a function'/>
-      <field name='function' type='const xmlChar *' info=''/>
-      <field name='functionURI' type='const xmlChar *' info=' function lookup function and data'/>
-      <field name='funcLookupFunc' type='xmlXPathFuncLookupFunc' info=' function lookup func'/>
-      <field name='funcLookupData' type='void *' info=' function lookup data temporary namespace lists kept for walking the namespace axis'/>
-      <field name='tmpNsList' type='xmlNsPtr *' info=' Array of namespaces'/>
-      <field name='tmpNsNr' type='int' info=' number of namespaces in scope error reporting mechanism'/>
-      <field name='userData' type='void *' info=' user specific data block'/>
-      <field name='error' type='xmlStructuredErrorFunc' info=' the callback in case of errors'/>
-      <field name='lastError' type='xmlError' info=' the last error'/>
-      <field name='debugNode' type='xmlNodePtr' info=' the source node XSLT dictionary'/>
-      <field name='dict' type='xmlDictPtr' info=' dictionary if any'/>
-      <field name='flags' type='int' info=' flags to control compilation Cache for reusal of XPath objects'/>
-      <field name='cache' type='void *' info=' Resource limits'/>
-      <field name='opLimit' type='unsigned long' info=''/>
-      <field name='opCount' type='unsigned long' info=''/>
-      <field name='depth' type='int' info=''/>
+      <field name='doc' type='xmlDocPtr'/>
+      <field name='node' type='xmlNodePtr'/>
+      <field name='nb_variables_unused' type='int'/>
+      <field name='max_variables_unused' type='int'/>
+      <field name='varHash' type='xmlHashTablePtr'/>
+      <field name='nb_types' type='int'/>
+      <field name='max_types' type='int'/>
+      <field name='types' type='xmlXPathTypePtr'/>
+      <field name='nb_funcs_unused' type='int'/>
+      <field name='max_funcs_unused' type='int'/>
+      <field name='funcHash' type='xmlHashTablePtr'/>
+      <field name='nb_axis' type='int'/>
+      <field name='max_axis' type='int'/>
+      <field name='axis' type='xmlXPathAxisPtr'/>
+      <field name='namespaces' type='xmlNsPtr *'/>
+      <field name='nsNr' type='int'/>
+      <field name='user' type='void *'/>
+      <field name='contextSize' type='int'/>
+      <field name='proximityPosition' type='int'/>
+      <field name='xptr' type='int'/>
+      <field name='here' type='xmlNodePtr'/>
+      <field name='origin' type='xmlNodePtr'/>
+      <field name='nsHash' type='xmlHashTablePtr'/>
+      <field name='varLookupFunc' type='xmlXPathVariableLookupFunc'/>
+      <field name='varLookupData' type='void *'/>
+      <field name='extra' type='void *'/>
+      <field name='function' type='const xmlChar *'/>
+      <field name='functionURI' type='const xmlChar *'/>
+      <field name='funcLookupFunc' type='xmlXPathFuncLookupFunc'/>
+      <field name='funcLookupData' type='void *'/>
+      <field name='tmpNsList' type='xmlNsPtr *'/>
+      <field name='tmpNsNr' type='int'/>
+      <field name='userData' type='void *'/>
+      <field name='error' type='xmlStructuredErrorFunc'/>
+      <field name='lastError' type='xmlError'/>
+      <field name='debugNode' type='xmlNodePtr'/>
+      <field name='dict' type='xmlDictPtr'/>
+      <field name='flags' type='int'/>
+      <field name='cache' type='void *'/>
+      <field name='opLimit' type='unsigned long'/>
+      <field name='opCount' type='unsigned long'/>
+      <field name='depth' type='int'/>
     </struct>
     <typedef name='xmlXPathContextPtr' file='xpath' type='xmlXPathContext *'/>
     <typedef name='xmlXPathError' file='xpath' type='enum'/>
     <typedef name='xmlXPathFuncPtr' file='xpath' type='xmlXPathFunct *'/>
     <struct name='xmlXPathFunct' file='xpath' type='struct _xmlXPathFunct'>
-      <field name='name' type='const xmlChar *' info=' the function name'/>
-      <field name='func' type='xmlXPathEvalFunc' info=' the evaluation function'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='func' type='xmlXPathEvalFunc'/>
     </struct>
     <struct name='xmlXPathObject' file='xpath' type='struct _xmlXPathObject'>
-      <field name='type' type='xmlXPathObjectType' info=''/>
-      <field name='nodesetval' type='xmlNodeSetPtr' info=''/>
-      <field name='boolval' type='int' info=''/>
-      <field name='floatval' type='double' info=''/>
-      <field name='stringval' type='xmlChar *' info=''/>
-      <field name='user' type='void *' info=''/>
-      <field name='index' type='int' info=''/>
-      <field name='user2' type='void *' info=''/>
-      <field name='index2' type='int' info=''/>
+      <field name='type' type='xmlXPathObjectType'/>
+      <field name='nodesetval' type='xmlNodeSetPtr'/>
+      <field name='boolval' type='int'/>
+      <field name='floatval' type='double'/>
+      <field name='stringval' type='xmlChar *'/>
+      <field name='user' type='void *'/>
+      <field name='index' type='int'/>
+      <field name='user2' type='void *'/>
+      <field name='index2' type='int'/>
     </struct>
     <typedef name='xmlXPathObjectPtr' file='xpath' type='xmlXPathObject *'/>
     <typedef name='xmlXPathObjectType' file='xpath' type='enum'/>
     <struct name='xmlXPathParserContext' file='xpath' type='struct _xmlXPathParserContext'>
-      <field name='cur' type='const xmlChar *' info=' the current char being parsed'/>
-      <field name='base' type='const xmlChar *' info=' the full expression'/>
-      <field name='error' type='int' info=' error code'/>
-      <field name='context' type='xmlXPathContextPtr' info=' the evaluation context'/>
-      <field name='value' type='xmlXPathObjectPtr' info=' the current value'/>
-      <field name='valueNr' type='int' info=' number of values stacked'/>
-      <field name='valueMax' type='int' info=' max number of values stacked'/>
-      <field name='valueTab' type='xmlXPathObjectPtr *' info=' stack of values'/>
-      <field name='comp' type='xmlXPathCompExprPtr' info=' the precompiled expression'/>
-      <field name='xptr' type='int' info=' it this an XPointer expression'/>
-      <field name='ancestor' type='xmlNodePtr' info=' used for walking preceding axis'/>
-      <field name='valueFrame' type='int' info=' always zero for compatibility'/>
+      <field name='cur' type='const xmlChar *'/>
+      <field name='base' type='const xmlChar *'/>
+      <field name='error' type='int'/>
+      <field name='context' type='xmlXPathContextPtr'/>
+      <field name='value' type='xmlXPathObjectPtr'/>
+      <field name='valueNr' type='int'/>
+      <field name='valueMax' type='int'/>
+      <field name='valueTab' type='xmlXPathObjectPtr *'/>
+      <field name='comp' type='xmlXPathCompExprPtr'/>
+      <field name='xptr' type='int'/>
+      <field name='ancestor' type='xmlNodePtr'/>
+      <field name='valueFrame' type='int'/>
     </struct>
     <typedef name='xmlXPathParserContextPtr' file='xpath' type='xmlXPathParserContext *'/>
     <struct name='xmlXPathType' file='xpath' type='struct _xmlXPathType'>
-      <field name='name' type='const xmlChar *' info=' the type name'/>
-      <field name='func' type='xmlXPathConvertFunc' info=' the conversion function'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='func' type='xmlXPathConvertFunc'/>
     </struct>
     <typedef name='xmlXPathTypePtr' file='xpath' type='xmlXPathType *'/>
     <struct name='xmlXPathVariable' file='xpath' type='struct _xmlXPathVariable'>
-      <field name='name' type='const xmlChar *' info=' the variable name'/>
-      <field name='value' type='xmlXPathObjectPtr' info=' the value'/>
+      <field name='name' type='const xmlChar *'/>
+      <field name='value' type='xmlXPathObjectPtr'/>
     </struct>
     <typedef name='xmlXPathVariablePtr' file='xpath' type='xmlXPathVariable *'/>
-    <variable name='emptyExp' file='xmlregexp' type='xmlExpNodePtr'/>
-    <variable name='forbiddenExp' file='xmlregexp' type='xmlExpNodePtr'/>
     <variable name='htmlDefaultSAXHandler' file='HTMLparser' type='const xmlSAXHandlerV1'>
       <info>DEPRECATED: This handler is unused and will be removed from future versions.  Default old SAX v1 handler for HTML, builds the DOM tree</info>
     </variable>
     <variable name='oldXMLWDcompatibility' file='parser' type='const int'>
-      <info>Global setting, DEPRECATED.</info>
+      <info>DEPRECATED, always 0.</info>
     </variable>
     <variable name='xmlDefaultSAXHandler' file='parser' type='const xmlSAXHandlerV1'>
       <info>DEPRECATED: This handler is unused and will be removed from future versions.  Default SAX version1 handler for XML, builds the DOM tree</info>
@@ -6919,7 +6756,7 @@ Could we use @subtypes for this?'/>
       <info>@str: a zero terminated string  The variable holding the libxml strdup() implementation  Returns the copy of the string or NULL in case of error</info>
     </variable>
     <variable name='xmlParserDebugEntities' file='parser' type='const int'>
-      <info>DEPRECATED: Don&apos;t use  Global setting, asking the parser to print out debugging information. while handling entities. Disabled by default</info>
+      <info>DEPRECATED, always 0.</info>
     </variable>
     <variable name='xmlParserMaxDepth' file='parserInternals' type='const unsigned int'>
       <info>arbitrary depth limit for the XML documents that we allow to process. This is not a limitation of the parser but a safety boundary feature. It can be disabled with the XML_PARSE_HUGE parser option.</info>
@@ -6954,26 +6791,6 @@ Could we use @subtypes for this?'/>
       <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
       <arg name='inlen' type='int *' info='the length of @in'/>
     </function>
-    <function name='attribute' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element. DEPRECATED: use xmlSAX2Attribute()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='fullname' type='const xmlChar *' info='The attribute name, including namespace prefix'/>
-      <arg name='value' type='const xmlChar *' info='The attribute value'/>
-    </function>
-    <function name='attributeDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>An attribute definition has been parsed DEPRECATED: use xmlSAX2AttributeDecl()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='elem' type='const xmlChar *' info='the name of the element'/>
-      <arg name='fullname' type='const xmlChar *' info='the attribute name'/>
-      <arg name='type' type='int' info='the attribute type'/>
-      <arg name='def' type='int' info='the type of default value'/>
-      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value'/>
-      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set'/>
-    </function>
     <functype name='attributeDeclSAXFunc' file='parser' module='parser'>
       <info>An attribute definition has been parsed.</info>
       <return type='void'/>
@@ -6992,14 +6809,6 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='The attribute name, including namespace prefix'/>
       <arg name='value' type='const xmlChar *' info='The attribute value'/>
     </functype>
-    <function name='cdataBlock' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when a pcdata block has been parsed DEPRECATED: use xmlSAX2CDataBlock()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='value' type='const xmlChar *' info='The pcdata content'/>
-      <arg name='len' type='int' info='the block length'/>
-    </function>
     <functype name='cdataBlockSAXFunc' file='parser' module='parser'>
       <info>Called when a pcdata block has been parsed.</info>
       <return type='void'/>
@@ -7007,14 +6816,6 @@ Could we use @subtypes for this?'/>
       <arg name='value' type='const xmlChar *' info='The pcdata content'/>
       <arg name='len' type='int' info='the block length'/>
     </functype>
-    <function name='characters' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>receiving some chars from the parser. DEPRECATED: use xmlSAX2Characters()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
-      <arg name='len' type='int' info='the number of xmlChar'/>
-    </function>
     <functype name='charactersSAXFunc' file='parser' module='parser'>
       <info>Receiving some chars from the parser.</info>
       <return type='void'/>
@@ -7022,35 +6823,12 @@ Could we use @subtypes for this?'/>
       <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
       <arg name='len' type='int' info='the number of xmlChar'/>
     </functype>
-    <function name='checkNamespace' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Check that the current element namespace is the same as the one read upon parsing. DEPRECATED</info>
-      <return type='int' info='1 if true 0 otherwise'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='namespace' type='xmlChar *' info='the namespace to check against'/>
-    </function>
-    <function name='comment' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>A comment has been parsed. DEPRECATED: use xmlSAX2Comment()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='value' type='const xmlChar *' info='the comment content'/>
-    </function>
     <functype name='commentSAXFunc' file='parser' module='parser'>
       <info>A comment has been parsed.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='value' type='const xmlChar *' info='the comment content'/>
     </functype>
-    <function name='elementDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>An element definition has been parsed DEPRECATED: use xmlSAX2ElementDecl()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='the element name'/>
-      <arg name='type' type='int' info='the element type'/>
-      <arg name='content' type='xmlElementContentPtr' info='the element value tree'/>
-    </function>
     <functype name='elementDeclSAXFunc' file='parser' module='parser'>
       <info>An element definition has been parsed.</info>
       <return type='void'/>
@@ -7059,24 +6837,11 @@ Could we use @subtypes for this?'/>
       <arg name='type' type='int' info='the element type'/>
       <arg name='content' type='xmlElementContentPtr' info='the element value tree'/>
     </functype>
-    <function name='endDocument' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when the document end has been detected. DEPRECATED: use xmlSAX2EndDocument()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
     <functype name='endDocumentSAXFunc' file='parser' module='parser'>
       <info>Called when the document end has been detected.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
     </functype>
-    <function name='endElement' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when the end of an element has been detected. DEPRECATED: use xmlSAX2EndElement()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The element name'/>
-    </function>
     <functype name='endElementNsSAX2Func' file='parser' module='parser'>
       <info>SAX2 callback when an element end has been detected by the parser. It provides the namespace information for the element.</info>
       <return type='void'/>
@@ -7091,17 +6856,6 @@ Could we use @subtypes for this?'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='name' type='const xmlChar *' info='The element name'/>
     </functype>
-    <function name='entityDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>An entity definition has been parsed DEPRECATED: use xmlSAX2EntityDecl()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='the entity name'/>
-      <arg name='type' type='int' info='the entity type'/>
-      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
-      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
-      <arg name='content' type='xmlChar *' info='the entity value (without processing).'/>
-    </function>
     <functype name='entityDeclSAXFunc' file='parser' module='parser'>
       <info>An entity definition has been parsed.</info>
       <return type='void'/>
@@ -7119,15 +6873,6 @@ Could we use @subtypes for this?'/>
       <arg name='msg' type='const char *' info='the message to display/transmit'/>
       <arg name='...' type='...' info='extra parameters for the message display'/>
     </functype>
-    <function name='externalSubset' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Callback on external subset declaration. DEPRECATED: use xmlSAX2ExternalSubset()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='the root element name'/>
-      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
-      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
-    </function>
     <functype name='externalSubsetSAXFunc' file='parser' module='parser'>
       <info>Callback on external subset declaration.</info>
       <return type='void'/>
@@ -7143,112 +6888,23 @@ Could we use @subtypes for this?'/>
       <arg name='msg' type='const char *' info='the message to display/transmit'/>
       <arg name='...' type='...' info='extra parameters for the message display'/>
     </functype>
-    <functype name='ftpDataCallback' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>A callback for the xmlNanoFTPGet command.</info>
-      <return type='void'/>
-      <arg name='userData' type='void *' info='the user provided context'/>
-      <arg name='data' type='const char *' info='the data received'/>
-      <arg name='len' type='int' info='its size in bytes'/>
-    </functype>
-    <functype name='ftpListCallback' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>A callback for the xmlNanoFTPList command. Note that only one of year and day:minute are specified.</info>
-      <return type='void'/>
-      <arg name='userData' type='void *' info='user provided data for the callback'/>
-      <arg name='filename' type='const char *' info='the file name (including &quot;-&gt;&quot; when links are shown)'/>
-      <arg name='attrib' type='const char *' info='the attribute string'/>
-      <arg name='owner' type='const char *' info='the owner string'/>
-      <arg name='group' type='const char *' info='the group string'/>
-      <arg name='size' type='unsigned long' info='the file size'/>
-      <arg name='links' type='int' info='the link count'/>
-      <arg name='year' type='int' info='the year'/>
-      <arg name='month' type='const char *' info='the month'/>
-      <arg name='day' type='int' info='the day'/>
-      <arg name='hour' type='int' info='the hour'/>
-      <arg name='minute' type='int' info='the minute'/>
-    </functype>
-    <function name='getColumnNumber' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Provide the column number of the current parsing point. DEPRECATED: use xmlSAX2GetColumnNumber()</info>
-      <return type='int' info='an int'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
-    <function name='getEntity' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Get an entity by name DEPRECATED: use xmlSAX2GetEntity()</info>
-      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The entity name'/>
-    </function>
     <functype name='getEntitySAXFunc' file='parser' module='parser'>
       <info>Get an entity by name.</info>
       <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='name' type='const xmlChar *' info='The entity name'/>
     </functype>
-    <function name='getLineNumber' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Provide the line number of the current parsing point. DEPRECATED: use xmlSAX2GetLineNumber()</info>
-      <return type='int' info='an int'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
-    <function name='getNamespace' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Get the current element namespace. DEPRECATED</info>
-      <return type='xmlNsPtr' info='the xmlNsPtr or NULL if none'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
-    <function name='getParameterEntity' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Get a parameter entity by name DEPRECATED: use xmlSAX2GetParameterEntity()</info>
-      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The entity name'/>
-    </function>
     <functype name='getParameterEntitySAXFunc' file='parser' module='parser'>
       <info>Get a parameter entity by name.</info>
       <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='name' type='const xmlChar *' info='The entity name'/>
     </functype>
-    <function name='getPublicId' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Provides the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot; DEPRECATED: use xmlSAX2GetPublicId()</info>
-      <return type='const xmlChar *' info='a xmlChar *'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
-    <function name='getSystemId' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Provides the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd DEPRECATED: use xmlSAX2GetSystemId()</info>
-      <return type='const xmlChar *' info='a xmlChar *'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
-    <function name='globalNamespace' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>An old global namespace has been parsed. DEPRECATED</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='href' type='const xmlChar *' info='the namespace associated URN'/>
-      <arg name='prefix' type='const xmlChar *' info='the namespace prefix'/>
-    </function>
-    <function name='hasExternalSubset' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Does this document has an external subset DEPRECATED: use xmlSAX2HasExternalSubset()</info>
-      <return type='int' info='1 if true'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
     <functype name='hasExternalSubsetSAXFunc' file='parser' module='parser'>
       <info>Does this document has an external subset?</info>
       <return type='int' info='1 if true'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
     </functype>
-    <function name='hasInternalSubset' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Does this document has an internal subset DEPRECATED: use xmlSAX2HasInternalSubset()</info>
-      <return type='int' info='1 if true'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
     <functype name='hasInternalSubsetSAXFunc' file='parser' module='parser'>
       <info>Does this document has an internal subset.</info>
       <return type='int' info='1 if true'/>
@@ -7324,7 +6980,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='htmlCtxtReadFile' file='HTMLparser' module='HTMLparser'>
       <cond>defined(LIBXML_HTML_ENABLED)</cond>
-      <info>Parse an HTML file from the filesystem, the network or a user-defined resource loader.  See xmlNewInputURL and htmlCtxtUseOptions for details.</info>
+      <info>Parse an HTML file from the filesystem, the network or a user-defined resource loader.  See htmlCtxtUseOptions for details.</info>
       <return type='htmlDocPtr' info='the resulting document tree'/>
       <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
       <arg name='filename' type='const char *' info='a file or URL'/>
@@ -7333,7 +6989,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='htmlCtxtReadIO' file='HTMLparser' module='HTMLparser'>
       <cond>defined(LIBXML_HTML_ENABLED)</cond>
-      <info>Parse an HTML document from I/O functions and source and build a tree.  See xmlNewInputIO and htmlCtxtUseOptions for details.</info>
+      <info>Parse an HTML document from I/O functions and source and build a tree.  See htmlCtxtUseOptions for details.</info>
       <return type='htmlDocPtr' info='the resulting document tree'/>
       <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
       <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
@@ -7507,7 +7163,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='htmlNewParserCtxt' file='HTMLparser' module='HTMLparser'>
       <cond>defined(LIBXML_HTML_ENABLED)</cond>
-      <info>Allocate and initialize a new HTML parser context.  This can be used to parse HTML documents into DOM trees with functions like xmlCtxtReadFile or xmlCtxtReadMemory.  See htmlCtxtUseOptions for parser options.  See xmlCtxtSetErrorHandler for advanced error handling.  See xmlNewInputURL, xmlNewInputMemory, xmlNewInputIO and similar functions for advanced input control.  See htmlNewSAXParserCtxt for custom SAX parsers.</info>
+      <info>Allocate and initialize a new HTML parser context.  This can be used to parse HTML documents into DOM trees with functions like xmlCtxtReadFile or xmlCtxtReadMemory.  See htmlCtxtUseOptions for parser options.  See xmlCtxtSetErrorHandler for advanced error handling.  See htmlNewSAXParserCtxt for custom SAX parsers.</info>
       <return type='htmlParserCtxtPtr' info='the htmlParserCtxtPtr or NULL in case of allocation error'/>
     </function>
     <function name='htmlNewSAXParserCtxt' file='HTMLparser' module='HTMLparser'>
@@ -7612,7 +7268,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='htmlParseFile' file='HTMLparser' module='HTMLparser'>
       <cond>defined(LIBXML_HTML_ENABLED)</cond>
-      <info>Parse an HTML file and build a tree.  See xmlNewInputURL for details.</info>
+      <info>Parse an HTML file and build a tree.</info>
       <return type='htmlDocPtr' info='the resulting document tree'/>
       <arg name='filename' type='const char *' info='the filename'/>
       <arg name='encoding' type='const char *' info='encoding (optional)'/>
@@ -7719,14 +7375,6 @@ Could we use @subtypes for this?'/>
       <return type='const htmlElemDesc *' info='the related htmlElemDescPtr or NULL if not found.'/>
       <arg name='tag' type='const xmlChar *' info='The tag name in lowercase'/>
     </function>
-    <function name='ignorableWhitespace' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters DEPRECATED: use xmlSAX2IgnorableWhitespace()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
-      <arg name='len' type='int' info='the number of xmlChar'/>
-    </function>
     <functype name='ignorableWhitespaceSAXFunc' file='parser' module='parser'>
       <info>Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.</info>
       <return type='void'/>
@@ -7739,19 +7387,6 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='handler' type='xmlGenericErrorFunc *' info='the handler'/>
     </function>
-    <function name='inithtmlDefaultSAXHandler' file='SAX' module='SAX'>
-      <cond>defined(LIBXML_LEGACY_ENABLED) &amp;&amp; defined(LIBXML_SAX1_ENABLED) &amp;&amp; defined(LIBXML_HTML_ENABLED)</cond>
-      <info>Initialize the default HTML SAX version 1 handler DEPRECATED: use xmlSAX2InitHtmlDefaultSAXHandler() for the new SAX2 blocks</info>
-      <return type='void'/>
-      <arg name='hdlr' type='xmlSAXHandlerV1 *' info='the SAX handler'/>
-    </function>
-    <function name='initxmlDefaultSAXHandler' file='SAX' module='SAX'>
-      <cond>defined(LIBXML_LEGACY_ENABLED) &amp;&amp; defined(LIBXML_SAX1_ENABLED)</cond>
-      <info>Initialize the default XML SAX version 1 handler DEPRECATED: use xmlSAX2InitDefaultSAXHandler() for the new SAX2 blocks</info>
-      <return type='void'/>
-      <arg name='hdlr' type='xmlSAXHandlerV1 *' info='the SAX handler'/>
-      <arg name='warning' type='int' info='flag if non-zero sets the handler warning procedure'/>
-    </function>
     <function name='inputPop' file='parserInternals' module='parser'>
       <info>Pops the top parser input from the input stack</info>
       <return type='xmlParserInputPtr' info='the input just removed'/>
@@ -7763,15 +7398,6 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='value' type='xmlParserInputPtr' info='the parser input'/>
     </function>
-    <function name='internalSubset' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Callback on internal subset declaration. DEPRECATED: use xmlSAX2InternalSubset()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='the root element name'/>
-      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
-      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
-    </function>
     <functype name='internalSubsetSAXFunc' file='parser' module='parser'>
       <info>Callback on internal subset declaration.</info>
       <return type='void'/>
@@ -7780,12 +7406,6 @@ Could we use @subtypes for this?'/>
       <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
       <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
     </functype>
-    <function name='isStandalone' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Is this document tagged standalone ? DEPRECATED: use xmlSAX2IsStandalone()</info>
-      <return type='int' info='1 if true'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
     <functype name='isStandaloneSAXFunc' file='parser' module='parser'>
       <info>Is this document tagged standalone?</info>
       <return type='int' info='1 if true'/>
@@ -7810,14 +7430,6 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='value' type='const xmlChar *' info='the element name'/>
     </function>
-    <function name='namespaceDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>A namespace has been parsed. DEPRECATED</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='href' type='const xmlChar *' info='the namespace associated URN'/>
-      <arg name='prefix' type='const xmlChar *' info='the namespace prefix'/>
-    </function>
     <function name='nodePop' file='parserInternals' module='parser'>
       <info>DEPRECATED: Internal function, do not use.  Pops the top element node from the node stack</info>
       <return type='xmlNodePtr' info='the node just removed'/>
@@ -7829,15 +7441,6 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='value' type='xmlNodePtr' info='the element node'/>
     </function>
-    <function name='notationDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>What to do when a notation declaration has been parsed. DEPRECATED: use xmlSAX2NotationDecl()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The name of the notation'/>
-      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
-      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
-    </function>
     <functype name='notationDeclSAXFunc' file='parser' module='parser'>
       <info>What to do when a notation declaration has been parsed.</info>
       <return type='void'/>
@@ -7846,14 +7449,6 @@ Could we use @subtypes for this?'/>
       <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
       <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
     </functype>
-    <function name='processingInstruction' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>A processing instruction has been parsed. DEPRECATED: use xmlSAX2ProcessingInstruction()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='target' type='const xmlChar *' info='the target name'/>
-      <arg name='data' type='const xmlChar *' info='the PI data&apos;s'/>
-    </function>
     <functype name='processingInstructionSAXFunc' file='parser' module='parser'>
       <info>A processing instruction has been parsed.</info>
       <return type='void'/>
@@ -7861,27 +7456,12 @@ Could we use @subtypes for this?'/>
       <arg name='target' type='const xmlChar *' info='the target name'/>
       <arg name='data' type='const xmlChar *' info='the PI data&apos;s'/>
     </functype>
-    <function name='reference' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when an entity reference is detected. DEPRECATED: use xmlSAX2Reference()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The entity name'/>
-    </function>
     <functype name='referenceSAXFunc' file='parser' module='parser'>
       <info>Called when an entity reference is detected.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='name' type='const xmlChar *' info='The entity name'/>
     </functype>
-    <function name='resolveEntity' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine DEPRECATED: use xmlSAX2ResolveEntity()</info>
-      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
-      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
-    </function>
     <functype name='resolveEntitySAXFunc' file='parser' module='parser'>
       <info>Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
       <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
@@ -7889,45 +7469,17 @@ Could we use @subtypes for this?'/>
       <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
       <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
     </functype>
-    <function name='setDocumentLocator' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case. DEPRECATED</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator'/>
-    </function>
     <functype name='setDocumentLocatorSAXFunc' file='parser' module='parser'>
       <info>Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator'/>
     </functype>
-    <function name='setNamespace' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Set the current element namespace. DEPRECATED</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='the namespace prefix'/>
-    </function>
-    <function name='startDocument' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when the document start being processed. DEPRECATED: use xmlSAX2StartDocument()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-    </function>
     <functype name='startDocumentSAXFunc' file='parser' module='parser'>
       <info>Called when the document start being processed.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
     </functype>
-    <function name='startElement' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when an opening tag has been processed. DEPRECATED: use xmlSAX2StartElement()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='fullname' type='const xmlChar *' info='The element name, including namespace prefix'/>
-      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated'/>
-    </function>
     <functype name='startElementNsSAX2Func' file='parser' module='parser'>
       <info>SAX2 callback when an element start has been detected by the parser. It provides the namespace information for the element, as well as the new namespace declarations on the element.</info>
       <return type='void'/>
@@ -7948,16 +7500,6 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='The element name, including namespace prefix'/>
       <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated'/>
     </functype>
-    <function name='unparsedEntityDecl' file='SAX' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>What to do when an unparsed entity declaration is parsed DEPRECATED: use xmlSAX2UnparsedEntityDecl()</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
-      <arg name='name' type='const xmlChar *' info='The name of the entity'/>
-      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
-      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
-      <arg name='notationName' type='const xmlChar *' info='the name of the notation'/>
-    </function>
     <functype name='unparsedEntityDeclSAXFunc' file='parser' module='parser'>
       <info>What to do when an unparsed entity declaration is parsed.</info>
       <return type='void'/>
@@ -8020,12 +7562,12 @@ Could we use @subtypes for this?'/>
     </functype>
     <function name='xlinkGetDefaultDetect' file='xlink' module='xlink'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
-      <info>Get the default xlink detection routine</info>
+      <info>DEPRECATED: Don&apos;t use.  Get the default xlink detection routine</info>
       <return type='xlinkNodeDetectFunc' info='the current function or NULL;'/>
     </function>
     <function name='xlinkGetDefaultHandler' file='xlink' module='xlink'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
-      <info>Get the default xlink handler.</info>
+      <info>DEPRECATED: Don&apos;t use.  Get the default xlink handler.</info>
       <return type='xlinkHandlerPtr' info='the current xlinkHandlerPtr value.'/>
     </function>
     <function name='xlinkIsLink' file='xlink' module='xlink'>
@@ -8044,13 +7586,13 @@ Could we use @subtypes for this?'/>
     </functype>
     <function name='xlinkSetDefaultDetect' file='xlink' module='xlink'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
-      <info>Set the default xlink detection routine</info>
+      <info>DEPRECATED: Don&apos;t use.  Set the default xlink detection routine</info>
       <return type='void'/>
       <arg name='func' type='xlinkNodeDetectFunc' info='pointer to the new detection routine.'/>
     </function>
     <function name='xlinkSetDefaultHandler' file='xlink' module='xlink'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
-      <info>Set the default xlink handlers</info>
+      <info>DEPRECATED: Don&apos;t use.  Set the default xlink handlers</info>
       <return type='void'/>
       <arg name='handler' type='xlinkHandlerPtr' info='the new value for the xlink handler block'/>
     </function>
@@ -8171,7 +7713,7 @@ Could we use @subtypes for this?'/>
       <arg name='content' type='xmlElementContentPtr' info='the element content tree or NULL'/>
     </function>
     <function name='xmlAddEncodingAlias' file='encoding' module='encoding'>
-      <info>Registers an alias @alias for an encoding named @name. Existing alias will be overwritten.</info>
+      <info>DEPRECATED: This function modifies global state and is not thread-safe.  Registers an alias @alias for an encoding named @name. Existing alias will be overwritten.</info>
       <return type='int' info='0 in case of success, -1 in case of error'/>
       <arg name='name' type='const char *' info='the encoding name as parsed, in UTF-8 format (ASCII actually)'/>
       <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
@@ -8218,7 +7760,6 @@ Could we use @subtypes for this?'/>
       <arg name='SystemID' type='const xmlChar *' info='the system identifier or NULL'/>
     </function>
     <function name='xmlAddPrevSibling' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)</cond>
       <info>Unlinks @cur and inserts it as previous sibling before @next.  Unlike xmlAddChild this function does not merge text nodes.  If @cur is an attribute node, it is inserted before attribute @next. If the attribute list contains an attribute with a name matching @cur, the old attribute is destroyed.  See the notes in xmlAddChild.</info>
       <return type='xmlNodePtr' info='@cur or a sibling if @cur was merged. Returns NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='next' type='xmlNodePtr' info='the target node'/>
@@ -8259,25 +7800,25 @@ Could we use @subtypes for this?'/>
       <arg name='string' type='const xmlChar *' info='the text content'/>
     </function>
     <function name='xmlAutomataCompile' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Compile the automata into a Reg Exp ready for being executed. The automata should be free after this point.</info>
       <return type='xmlRegexpPtr' info='the compiled regexp or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
     </function>
     <function name='xmlAutomataGetInitState' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Initial state lookup</info>
       <return type='xmlAutomataStatePtr' info='the initial state of the automata'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
     </function>
     <function name='xmlAutomataIsDeterminist' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Checks if an automata is determinist.</info>
       <return type='int' info='1 if true, 0 if not, and -1 in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
     </function>
     <function name='xmlAutomataNewAllTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a an ALL transition from the @from state to the target state. That transition is an epsilon transition allowed only when all transitions from the @from node have been activated.</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8286,7 +7827,7 @@ Could we use @subtypes for this?'/>
       <arg name='lax' type='int' info='allow to transition if not all all transitions have been activated'/>
     </function>
     <function name='xmlAutomataNewCountTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and whose number is between @min and @max</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8298,7 +7839,7 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data associated to the transition'/>
     </function>
     <function name='xmlAutomataNewCountTrans2' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and @token2 and whose number is between @min and @max</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8311,7 +7852,7 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data associated to the transition'/>
     </function>
     <function name='xmlAutomataNewCountedTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state which will increment the counter provided</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8320,7 +7861,7 @@ Could we use @subtypes for this?'/>
       <arg name='counter' type='int' info='the counter associated to that transition'/>
     </function>
     <function name='xmlAutomataNewCounter' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Create a new counter</info>
       <return type='int' info='the counter number or -1 in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8328,7 +7869,7 @@ Could we use @subtypes for this?'/>
       <arg name='max' type='int' info='the maximal value on the counter'/>
     </function>
     <function name='xmlAutomataNewCounterTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state which will be allowed only if the counter is within the right range.</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8337,7 +7878,7 @@ Could we use @subtypes for this?'/>
       <arg name='counter' type='int' info='the counter associated to that transition'/>
     </function>
     <function name='xmlAutomataNewEpsilon' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8345,7 +7886,7 @@ Could we use @subtypes for this?'/>
       <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
     </function>
     <function name='xmlAutomataNewNegTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by any value except (@token,@token2) Note that if @token2 is not NULL, then (X, NULL) won&apos;t match to follow # the semantic of XSD ##other</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8356,7 +7897,7 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
     </function>
     <function name='xmlAutomataNewOnceTrans' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and whose number is between @min and @max, moreover that transition can only be crossed once.</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8368,7 +7909,7 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data associated to the transition'/>
     </function>
     <function name='xmlAutomataNewOnceTrans2' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and @token2 and whose number is between @min and @max, moreover that transition can only be crossed once.</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8381,13 +7922,13 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data associated to the transition'/>
     </function>
     <function name='xmlAutomataNewState' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Create a new disconnected state in the automata</info>
       <return type='xmlAutomataStatePtr' info='the new state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
     </function>
     <function name='xmlAutomataNewTransition' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by the value of @token</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8397,7 +7938,7 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
     </function>
     <function name='xmlAutomataNewTransition2' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by the value of @token</info>
       <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -8408,18 +7949,12 @@ Could we use @subtypes for this?'/>
       <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
     </function>
     <function name='xmlAutomataSetFinalState' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Makes that state a final state</info>
       <return type='int' info='0 or -1 in case of error'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
       <arg name='state' type='xmlAutomataStatePtr' info='a state in this automata'/>
     </function>
-    <function name='xmlBoolToText' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
-      <info>Convenient way to turn bool into text</info>
-      <return type='const char *' info='a pointer to either &quot;True&quot; or &quot;False&quot;'/>
-      <arg name='boolval' type='int' info='a bool to turn into text'/>
-    </function>
     <function name='xmlBufContent' file='tree' module='buf'>
       <info>Function to extract the content of a buffer</info>
       <return type='xmlChar *' info='the internal content'/>
@@ -8586,7 +8121,7 @@ Could we use @subtypes for this?'/>
       <arg name='base' type='const xmlChar *' info='the base value'/>
     </function>
     <function name='xmlBuildRelativeURISafe' file='uri' module='uri'>
-      <info>Expresses the URI of the reference in terms relative to the base.  Some examples of this operation include: base = &quot;http://site1.com/docs/book1.html&quot; URI input                        URI returned docs/pic1.gif                    pic1.gif docs/img/pic1.gif                img/pic1.gif img/pic1.gif                     ../img/pic1.gif http://site1.com/docs/pic1.gif   pic1.gif http://site2.com/docs/pic1.gif   http://site2.com/docs/pic1.gif  base = &quot;docs/book1.html&quot; URI input                        URI returned docs/pic1.gif                    pic1.gif docs/img/pic1.gif                img/pic1.gif img/pic1.gif                     ../img/pic1.gif http://site1.com/docs/pic1.gif   http://site1.com/docs/pic1.gif   Note: if the URI reference is really weird or complicated, it may be worthwhile to first convert it into a &quot;nice&quot; one by calling xmlBuildURI (using &apos;base&apos;) before calling this routine, since this routine (for reasonable efficiency) assumes URI has already been through some validation.  Available since 2.13.0.</info>
+      <info>Expresses the URI of the reference in terms relative to the base. Some examples of this operation include:  base = &quot;http://site1.com/docs/book1.html&quot; URI input                        URI returned http://site1.com/docs/pic1.gif   pic1.gif http://site2.com/docs/pic1.gif   http://site2.com/docs/pic1.gif  base = &quot;docs/book1.html&quot; URI input                        URI returned docs/pic1.gif                    pic1.gif docs/img/pic1.gif                img/pic1.gif img/pic1.gif                     ../img/pic1.gif http://site1.com/docs/pic1.gif   http://site1.com/docs/pic1.gif  Available since 2.13.0.</info>
       <return type='int' info='0 on success, -1 if a memory allocation failed or an error code if URI or base are invalid.'/>
       <arg name='URI' type='const xmlChar *' info='the URI reference under consideration'/>
       <arg name='base' type='const xmlChar *' info='the base value'/>
@@ -8708,7 +8243,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlCatalogGetDefaults' file='catalog' module='catalog'>
       <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
-      <info>Used to get the user preference w.r.t. to what catalogs should be accepted</info>
+      <info>DEPRECATED: Use XML_PARSE_NO_SYS_CATALOG and XML_PARSE_NO_CATALOG_PI.  Used to get the user preference w.r.t. to what catalogs should be accepted</info>
       <return type='xmlCatalogAllow' info='the current xmlCatalogAllow value'/>
     </function>
     <function name='xmlCatalogGetPublic' file='catalog' module='catalog'>
@@ -8783,21 +8318,42 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlCatalogSetDefaultPrefer' file='catalog' module='catalog'>
       <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
-      <info>Allows to set the preference between public and system for deletion in XML Catalog resolution. C.f. section 4.1.1 of the spec Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM</info>
+      <info>DEPRECATED: This setting is global and not thread-safe.  Allows to set the preference between public and system for deletion in XML Catalog resolution. C.f. section 4.1.1 of the spec Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM</info>
       <return type='xmlCatalogPrefer' info='the previous value of the default preference for delegation'/>
       <arg name='prefer' type='xmlCatalogPrefer' info='the default preference for delegation'/>
     </function>
     <function name='xmlCatalogSetDefaults' file='catalog' module='catalog'>
       <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
-      <info>Used to set the user preference w.r.t. to what catalogs should be accepted</info>
+      <info>DEPRECATED: Use XML_PARSE_NO_SYS_CATALOG and XML_PARSE_NO_CATALOG_PI.  Used to set the user preference w.r.t. to what catalogs should be accepted</info>
       <return type='void'/>
       <arg name='allow' type='xmlCatalogAllow' info='what catalogs should be accepted'/>
     </function>
     <function name='xmlCharEncCloseFunc' file='encoding' module='encoding'>
-      <info>Generic front-end for encoding handler close function</info>
-      <return type='int' info='0 if success, or -1 in case of error'/>
+      <info>Releases an xmlCharEncodingHandler. Must be called after a handler is no longer in use.</info>
+      <return type='int' info='0.'/>
       <arg name='handler' type='xmlCharEncodingHandler *' info='char encoding transformation data structure'/>
     </function>
+    <functype name='xmlCharEncConvCtxtDtor' file='encoding' module='encoding'>
+      <info>Free a conversion context.</info>
+      <return type='void'/>
+      <arg name='vctxt' type='void *' info='conversion context'/>
+    </functype>
+    <functype name='xmlCharEncConvFunc' file='encoding' module='encoding'>
+      <info>Convert between character encodings.  On success, the value of @inlen after return is the number of bytes consumed and @outlen is the number of bytes produced.</info>
+      <return type='int' info='the number of bytes written or an XML_ENC_ERR code.'/>
+      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
+      <arg name='outlen' type='int *' info='the length of @out'/>
+      <arg name='in' type='const unsigned char *' info='a pointer to an array of input bytes'/>
+      <arg name='inlen' type='int *' info='the length of @in'/>
+      <arg name='vctxt' type='void *' info='conversion context'/>
+    </functype>
+    <functype name='xmlCharEncConvImpl' file='encoding' module='encoding'>
+      <info>vctxt:  user data name:  encoding name conv:  pointer to xmlCharEncConverter struct  If this function returns XML_ERR_OK, it must fill the @conv struct with a conversion function, and optional destructor and optional input and output conversion contexts.</info>
+      <return type='int' info='an xmlParserErrors code.'/>
+      <arg name='vctxt' type='void *' info=''/>
+      <arg name='name' type='const char *' info=''/>
+      <arg name='conv' type='xmlCharEncConverter *' info=''/>
+    </functype>
     <function name='xmlCharEncFirstLine' file='encoding' module='encoding'>
       <info>DEPERECATED: Don&apos;t use.</info>
       <return type='int' info='the number of bytes written or an XML_ENC_ERR code.'/>
@@ -8820,16 +8376,16 @@ Could we use @subtypes for this?'/>
       <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input'/>
     </function>
     <functype name='xmlCharEncodingInputFunc' file='encoding' module='encoding'>
-      <info>Take a block of chars in the original encoding and try to convert it to an UTF-8 block of chars out.</info>
-      <return type='int' info='the number of bytes written, -1 if lack of space, or -2 if the transcoding failed. The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictiable. The value of @outlen after return is the number of octets consumed.'/>
+      <info>Convert characters to UTF-8.  On success, the value of @inlen after return is the number of bytes consumed and @outlen is the number of bytes produced.</info>
+      <return type='int' info='the number of bytes written or an XML_ENC_ERR code.'/>
       <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the UTF-8 result'/>
       <arg name='outlen' type='int *' info='the length of @out'/>
       <arg name='in' type='const unsigned char *' info='a pointer to an array of chars in the original encoding'/>
       <arg name='inlen' type='int *' info='the length of @in'/>
     </functype>
     <functype name='xmlCharEncodingOutputFunc' file='encoding' module='encoding'>
-      <info>Take a block of UTF-8 chars in and try to convert it to another encoding. Note: a first call designed to produce heading info is called with in = NULL. If stateful this should also initialize the encoder state.</info>
-      <return type='int' info='the number of bytes written, -1 if lack of space, or -2 if the transcoding failed. The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictiable. The value of @outlen after return is the number of octets produced.'/>
+      <info>Convert characters from UTF-8.  On success, the value of @inlen after return is the number of bytes consumed and @outlen is the number of bytes produced.</info>
+      <return type='int' info='the number of bytes written or an XML_ENC_ERR code.'/>
       <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
       <arg name='outlen' type='int *' info='the length of @out'/>
       <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
@@ -8878,7 +8434,6 @@ Could we use @subtypes for this?'/>
       <arg name='utf' type='const unsigned char *' info='Pointer to putative UTF-8 encoded string.'/>
     </function>
     <function name='xmlChildElementCount' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Count the number of child nodes which are elements.  Note that entity references are not expanded.</info>
       <return type='unsigned long' info='the number of element children or 0 if arguments are invalid.'/>
       <arg name='parent' type='xmlNodePtr' info='the parent node'/>
@@ -8888,7 +8443,7 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
     </function>
     <function name='xmlCleanupEncodingAliases' file='encoding' module='encoding'>
-      <info>Unregisters all aliases</info>
+      <info>DEPRECATED: This function modifies global state and is not thread-safe.  Unregisters all aliases</info>
       <return type='void'/>
     </function>
     <function name='xmlCleanupGlobals' file='parser' module='globals'>
@@ -8912,11 +8467,6 @@ Could we use @subtypes for this?'/>
       <info>This function name is somewhat misleading. It does not clean up parser state, it cleans up memory allocated by the library itself. It is a cleanup function for the XML library. It tries to reclaim all related global memory allocated for the library processing. It doesn&apos;t deallocate any document related memory. One should call xmlCleanupParser() only when the process has finished using the library and all XML/HTML documents built with it. See also xmlInitParser() which has the opposite function of preparing the library for operations.  WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It&apos;s sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !</info>
       <return type='void'/>
     </function>
-    <function name='xmlCleanupPredefinedEntities' file='entities' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Cleanup up the predefined entities table. Deprecated call</info>
-      <return type='void'/>
-    </function>
     <function name='xmlCleanupThreads' file='threads' module='threads'>
       <info>DEPRECATED: This function is a no-op. Call xmlCleanupParser to free global state but see the warnings there. xmlCleanupParser should be only called once at program exit. In most cases, you don&apos;t have call cleanup functions at all.</info>
       <return type='void'/>
@@ -8938,13 +8488,12 @@ Could we use @subtypes for this?'/>
       <arg name='catal' type='xmlCatalogPtr' info='the catalog'/>
     </function>
     <function name='xmlCopyAttributeTable' file='valid' module='valid'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Build a copy of an attribute table.</info>
       <return type='xmlAttributeTablePtr' info='the new xmlAttributeTablePtr or NULL in case of error.'/>
       <arg name='table' type='xmlAttributeTablePtr' info='An attribute table'/>
     </function>
     <function name='xmlCopyChar' file='parserInternals' module='parserInternals'>
-      <info>append the char value in the array</info>
+      <info>DEPRECATED: Don&apos;t use.  append the char value in the array</info>
       <return type='int' info='the number of xmlChar written'/>
       <arg name='len' type='int' info='Ignored, compatibility'/>
       <arg name='out' type='xmlChar *' info='pointer to an array of xmlChar'/>
@@ -8957,7 +8506,6 @@ Could we use @subtypes for this?'/>
       <arg name='val' type='int' info='the char value'/>
     </function>
     <function name='xmlCopyDoc' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Copy a document. If recursive, the content tree will be copied too as well as DTD, namespaces and entities.</info>
       <return type='xmlDocPtr' info='the copied document or NULL if a memory allocation failed.'/>
       <arg name='doc' type='xmlDocPtr' info='the document'/>
@@ -8970,7 +8518,6 @@ Could we use @subtypes for this?'/>
       <arg name='cur' type='xmlElementContentPtr' info='An element content pointer.'/>
     </function>
     <function name='xmlCopyDtd' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Copy a DTD.</info>
       <return type='xmlDtdPtr' info='the copied DTD or NULL if a memory allocation failed.'/>
       <arg name='dtd' type='xmlDtdPtr' info='the DTD'/>
@@ -8981,19 +8528,16 @@ Could we use @subtypes for this?'/>
       <arg name='cur' type='xmlElementContentPtr' info='An element content pointer.'/>
     </function>
     <function name='xmlCopyElementTable' file='valid' module='valid'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Build a copy of an element table.</info>
       <return type='xmlElementTablePtr' info='the new xmlElementTablePtr or NULL in case of error.'/>
       <arg name='table' type='xmlElementTablePtr' info='An element table'/>
     </function>
     <function name='xmlCopyEntitiesTable' file='entities' module='entities'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Build a copy of an entity table.</info>
       <return type='xmlEntitiesTablePtr' info='the new xmlEntitiesTablePtr or NULL in case of error.'/>
       <arg name='table' type='xmlEntitiesTablePtr' info='An entity table'/>
     </function>
     <function name='xmlCopyEnumeration' file='valid' module='valid'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Copy an enumeration attribute node (recursive).</info>
       <return type='xmlEnumerationPtr' info='the xmlEnumerationPtr just created or NULL in case of error.'/>
       <arg name='cur' type='xmlEnumerationPtr' info='the tree to copy.'/>
@@ -9026,7 +8570,6 @@ Could we use @subtypes for this?'/>
       <arg name='node' type='xmlNodePtr' info='the first node in the list.'/>
     </function>
     <function name='xmlCopyNotationTable' file='valid' module='valid'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Build a copy of a notation table.</info>
       <return type='xmlNotationTablePtr' info='the new xmlNotationTablePtr or NULL in case of error.'/>
       <arg name='table' type='xmlNotationTablePtr' info='A notation table'/>
@@ -9043,6 +8586,15 @@ Could we use @subtypes for this?'/>
       <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted'/>
       <arg name='cur' type='xmlAttrPtr' info='the first attribute'/>
     </function>
+    <function name='xmlCreateCharEncodingHandler' file='encoding' module='encoding'>
+      <info>Find or create a handler matching the encoding. The following converters are looked up in order:  - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII) - Custom implementation if provided - User-registered global handler (deprecated) - iconv if enabled - ICU if enabled  The handler must be closed with xmlCharEncCloseFunc.  If the encoding is UTF-8, a NULL handler and no error code will be returned.  Available since 2.14.0.</info>
+      <return type='int' info='XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another xmlParserErrors error code.'/>
+      <arg name='name' type='const char *' info='a string describing the char encoding.'/>
+      <arg name='output' type='int' info='boolean, use handler for output'/>
+      <arg name='impl' type='xmlCharEncConvImpl' info='a conversion implementation (optional)'/>
+      <arg name='implCtxt' type='void *' info='user data for conversion implementation (optional)'/>
+      <arg name='out' type='xmlCharEncodingHandler **' info='pointer to result'/>
+    </function>
     <function name='xmlCreateDocParserCtxt' file='parser' module='parser'>
       <info>Creates a parser context for an XML in-memory document.</info>
       <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
@@ -9053,7 +8605,7 @@ Could we use @subtypes for this?'/>
       <return type='xmlEntitiesTablePtr' info='the xmlEntitiesTablePtr just created or NULL in case of error.'/>
     </function>
     <function name='xmlCreateEntityParserCtxt' file='parserInternals' module='parser'>
-      <info>DEPRECATED: Use xmlNewInputURL.  Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
+      <info>DEPRECATED: Don&apos;t use.  Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
       <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
       <arg name='URL' type='const xmlChar *' info='the entity URL'/>
       <arg name='ID' type='const xmlChar *' info='the entity PUBLIC ID'/>
@@ -9096,7 +8648,7 @@ Could we use @subtypes for this?'/>
     <function name='xmlCreatePushParserCtxt' file='parser' module='parser'>
       <cond>defined(LIBXML_PUSH_ENABLED)</cond>
       <info>Create a parser context for using the XML parser in push mode. See xmlParseChunk.  Passing an initial chunk is useless and deprecated.  @filename is used as base URI to fetch external entities and for error reports.</info>
-      <return type='xmlParserCtxtPtr' info='the new parser context or NULL in case of error.'/>
+      <return type='xmlParserCtxtPtr' info='the new parser context or NULL if a memory allocation failed.'/>
       <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler (optional)'/>
       <arg name='user_data' type='void *' info='user data for SAX callbacks (optional)'/>
       <arg name='chunk' type='const char *' info='initial chunk (optional, deprecated)'/>
@@ -9118,11 +8670,59 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
-    <function name='xmlCtxtGetLastError' file='xmlerror' module='error'>
+    <function name='xmlCtxtGetCatalogs' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='void *' info='the local catalogs.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtGetDeclaredEncoding' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='const xmlChar *' info='the encoding from the encoding declaration. This can differ from the actual encoding.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtGetDict' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='xmlDictPtr' info='the dictionary.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtGetLastError' file='xmlerror' module='parserInternals'>
       <info>Get the last parsing error registered.</info>
       <return type='const xmlError *' info='NULL if no error occurred or a pointer to the error'/>
       <arg name='ctx' type='void *' info='an XML parser context'/>
     </function>
+    <function name='xmlCtxtGetOptions' file='parser' module='parser'>
+      <info>Get the current options of the parser context.  Available since 2.14.0.</info>
+      <return type='int' info='the current options set in the parser context, or -1 if ctxt is NULL.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
+    </function>
+    <function name='xmlCtxtGetPrivate' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='void *' info='the private application data.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtGetStandalone' file='parser' module='parser'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='int' info='the value from the standalone document declaration.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtGetStatus' file='parser' module='parserInternals'>
+      <info>Get well-formedness and validation status after parsing. Also reports catastrophic errors which are not related to parsing like out-of-memory, I/O or other errors.  Available since 2.14.0.</info>
+      <return type='int' info='a bitmask of XML_STATUS_* flags ORed together.'/>
+      <arg name='ctxt' type='xmlParserCtxt *' info='an XML parser context'/>
+    </function>
+    <function name='xmlCtxtGetVersion' file='parser' module='parser'>
+      <info>ctxt:  parser context  Available since 2.14.0.</info>
+      <return type='const xmlChar *' info='the version from the XML declaration.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+    </function>
+    <function name='xmlCtxtParseContent' file='parser' module='parser'>
+      <info>Parse a well-balanced chunk of XML matching the &apos;content&apos; production.  Namespaces in scope of @node and entities of @node&apos;s document are recognized. When validating, the DTD of @node&apos;s document is used.  Always consumes @input even in error case.  Available since 2.14.0.</info>
+      <return type='xmlNodePtr' info='a node list or NULL in case of error.'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info='parser context'/>
+      <arg name='input' type='xmlParserInputPtr' info='parser input'/>
+      <arg name='node' type='xmlNodePtr' info='target node or document'/>
+      <arg name='hasTextDecl' type='int' info='whether to parse text declaration'/>
+    </function>
     <function name='xmlCtxtParseDocument' file='parser' module='parser'>
       <info>Parse an XML document and return the resulting document tree. Takes ownership of the input object.  Available since 2.13.0.</info>
       <return type='xmlDocPtr' info='the resulting document tree or NULL'/>
@@ -9148,7 +8748,7 @@ Could we use @subtypes for this?'/>
       <arg name='options' type='int' info='a combination of xmlParserOption'/>
     </function>
     <function name='xmlCtxtReadFile' file='parser' module='parser'>
-      <info>Parse an XML file from the filesystem, the network or a user-defined resource loader.  See xmlNewInputURL and xmlCtxtUseOptions for details.</info>
+      <info>Parse an XML file from the filesystem, the network or a user-defined resource loader.</info>
       <return type='xmlDocPtr' info='the resulting document tree'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='filename' type='const char *' info='a file or URL'/>
@@ -9181,7 +8781,7 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
-    <function name='xmlCtxtResetLastError' file='xmlerror' module='error'>
+    <function name='xmlCtxtResetLastError' file='xmlerror' module='parserInternals'>
       <info>Cleanup the last global error registered. For parsing error this does not change the well-formedness result.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='an XML parser context'/>
@@ -9195,6 +8795,25 @@ Could we use @subtypes for this?'/>
       <arg name='filename' type='const char *' info='an optional file name or URI'/>
       <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
     </function>
+    <function name='xmlCtxtSetCatalogs' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context catalogs:  catalogs pointer  Available since 2.14.0.  Set the local catalogs.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+      <arg name='catalogs' type='void *' info=''/>
+    </function>
+    <function name='xmlCtxtSetCharEncConvImpl' file='parser' module='parserInternals'>
+      <info>Installs a custom implementation to convert between character encodings.  This bypasses legacy feature like global encoding handlers or encoding aliases.  Available since 2.14.0.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info='parser context'/>
+      <arg name='impl' type='xmlCharEncConvImpl' info='callback'/>
+      <arg name='vctxt' type='void *' info='user data'/>
+    </function>
+    <function name='xmlCtxtSetDict' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context dict:  dictionary  Available since 2.14.0.  Set the dictionary. This should only be done immediately after creating a parser context.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+      <arg name='dict' type='xmlDictPtr' info=''/>
+    </function>
     <function name='xmlCtxtSetErrorHandler' file='parser' module='parserInternals'>
       <info>Register a callback function that will be called on errors and warnings. If handler is NULL, the error handler will be deactivated.  This is the recommended way to collect errors from the parser and takes precedence over all other error reporting mechanisms. These are (in order of precedence):  - per-context structured handler (xmlCtxtSetErrorHandler) - per-context structured &quot;serror&quot; SAX handler - global structured handler (xmlSetStructuredErrorFunc) - per-context generic &quot;error&quot; and &quot;warning&quot; SAX handlers - global generic handler (xmlSetGenericErrorFunc) - print to stderr  Available since 2.13.0.</info>
       <return type='void'/>
@@ -9209,11 +8828,24 @@ Could we use @subtypes for this?'/>
       <arg name='maxAmpl' type='unsigned' info='maximum amplification factor'/>
     </function>
     <function name='xmlCtxtSetOptions' file='parser' module='parser'>
-      <info>Applies the options to the parser context. Unset options are cleared.  Available since 2.13.0. With older versions, you can use xmlCtxtUseOptions.  XML_PARSE_RECOVER  Enable &quot;recovery&quot; mode which allows non-wellformed documents. How this mode behaves exactly is unspecified and may change without further notice. Use of this feature is DISCOURAGED.  XML_PARSE_NOENT  Despite the confusing name, this option enables substitution of entities. The resulting tree won&apos;t contain any entity reference nodes.  This option also enables loading of external entities (both general and parameter entities) which is dangerous. If you process untrusted data, it&apos;s recommended to set the XML_PARSE_NO_XXE option to disable loading of external entities.  XML_PARSE_DTDLOAD  Enables loading of an external DTD and the loading and substitution of external parameter entities. Has no effect if XML_PARSE_NO_XXE is set.  XML_PARSE_DTDATTR  Adds default attributes from the DTD to the result document.  Implies XML_PARSE_DTDLOAD, but loading of external content can be disabled with XML_PARSE_NO_XXE.  XML_PARSE_DTDVALID  This option enables DTD validation which requires to load external DTDs and external entities (both general and parameter entities) unless XML_PARSE_NO_XXE was set.  XML_PARSE_NO_XXE  Disables loading of external DTDs or entities.  XML_PARSE_NOERROR  Disable error and warning reports to the error handlers. Errors are still accessible with xmlCtxtGetLastError.  XML_PARSE_NOWARNING  Disable warning reports.  XML_PARSE_PEDANTIC  Enable some pedantic warnings.  XML_PARSE_NOBLANKS  Remove some text nodes containing only whitespace from the result document. Which nodes are removed depends on DTD element declarations or a conservative heuristic. The reindenting feature of the serialization code relies on this option to be set when parsing. Use of this option is DISCOURAGED.  XML_PARSE_SAX1  Always invoke the deprecated SAX1 startElement and endElement handlers. This option is DEPRECATED.  XML_PARSE_NONET  Disable network access with the builtin HTTP and FTP clients.  XML_PARSE_NODICT  Create a document without interned strings, making all strings separate memory allocations.  XML_PARSE_NSCLEAN  Remove redundant namespace declarations from the result document.  XML_PARSE_NOCDATA  Output normal text nodes instead of CDATA nodes.  XML_PARSE_COMPACT  Store small strings directly in the node struct to save memory.  XML_PARSE_OLD10  Use old Name productions from before XML 1.0 Fifth Edition. This options is DEPRECATED.  XML_PARSE_HUGE  Relax some internal limits.  Maximum size of text nodes, tags, comments, processing instructions, CDATA sections, entity values  normal: 10M huge:    1B  Maximum size of names, system literals, pubid literals  normal: 50K huge:   10M  Maximum nesting depth of elements  normal:  256 huge:   2048  Maximum nesting depth of entities  normal: 20 huge:   40  XML_PARSE_OLDSAX  Enable an unspecified legacy mode for SAX parsers. This option is DEPRECATED.  XML_PARSE_IGNORE_ENC  Ignore the encoding in the XML declaration. This option is mostly unneeded these days. The only effect is to enforce UTF-8 decoding of ASCII-like data.  XML_PARSE_BIG_LINES  Enable reporting of line numbers larger than 65535.</info>
+      <info>Applies the options to the parser context. Unset options are cleared.  Available since 2.13.0. With older versions, you can use xmlCtxtUseOptions.  XML_PARSE_RECOVER  Enable &quot;recovery&quot; mode which allows non-wellformed documents. How this mode behaves exactly is unspecified and may change without further notice. Use of this feature is DISCOURAGED.  XML_PARSE_NOENT  Despite the confusing name, this option enables substitution of entities. The resulting tree won&apos;t contain any entity reference nodes.  This option also enables loading of external entities (both general and parameter entities) which is dangerous. If you process untrusted data, it&apos;s recommended to set the XML_PARSE_NO_XXE option to disable loading of external entities.  XML_PARSE_DTDLOAD  Enables loading of an external DTD and the loading and substitution of external parameter entities. Has no effect if XML_PARSE_NO_XXE is set.  XML_PARSE_DTDATTR  Adds default attributes from the DTD to the result document.  Implies XML_PARSE_DTDLOAD, but loading of external content can be disabled with XML_PARSE_NO_XXE.  XML_PARSE_DTDVALID  This option enables DTD validation which requires to load external DTDs and external entities (both general and parameter entities) unless XML_PARSE_NO_XXE was set.  XML_PARSE_NO_XXE  Disables loading of external DTDs or entities.  XML_PARSE_NOERROR  Disable error and warning reports to the error handlers. Errors are still accessible with xmlCtxtGetLastError.  XML_PARSE_NOWARNING  Disable warning reports.  XML_PARSE_PEDANTIC  Enable some pedantic warnings.  XML_PARSE_NOBLANKS  Remove some text nodes containing only whitespace from the result document. Which nodes are removed depends on DTD element declarations or a conservative heuristic. The reindenting feature of the serialization code relies on this option to be set when parsing. Use of this option is DISCOURAGED.  XML_PARSE_SAX1  Always invoke the deprecated SAX1 startElement and endElement handlers. This option is DEPRECATED.  XML_PARSE_NONET  Disable network access with the builtin HTTP client.  XML_PARSE_NODICT  Create a document without interned strings, making all strings separate memory allocations.  XML_PARSE_NSCLEAN  Remove redundant namespace declarations from the result document.  XML_PARSE_NOCDATA  Output normal text nodes instead of CDATA nodes.  XML_PARSE_COMPACT  Store small strings directly in the node struct to save memory.  XML_PARSE_OLD10  Use old Name productions from before XML 1.0 Fifth Edition. This options is DEPRECATED.  XML_PARSE_HUGE  Relax some internal limits.  Maximum size of text nodes, tags, comments, processing instructions, CDATA sections, entity values  normal: 10M huge:    1B  Maximum size of names, system literals, pubid literals  normal: 50K huge:   10M  Maximum nesting depth of elements  normal:  256 huge:   2048  Maximum nesting depth of entities  normal: 20 huge:   40  XML_PARSE_OLDSAX  Enable an unspecified legacy mode for SAX parsers. This option is DEPRECATED.  XML_PARSE_IGNORE_ENC  Ignore the encoding in the XML declaration. This option is mostly unneeded these days. The only effect is to enforce UTF-8 decoding of ASCII-like data.  XML_PARSE_BIG_LINES  Enable reporting of line numbers larger than 65535.  XML_PARSE_NO_UNZIP  Disables input decompression. Setting this option is recommended to avoid zip bombs.  Available since 2.14.0.  XML_PARSE_NO_SYS_CATALOG  Disables the global system XML catalog.  Available since 2.14.0.  XML_PARSE_NO_CATALOG_PI  Ignore XML catalog processing instructions.  Available since 2.14.0.</info>
       <return type='int' info='0 in case of success, the set of unknown or unimplemented options in case of error.'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='options' type='int' info='a bitmask of xmlParserOption values'/>
     </function>
+    <function name='xmlCtxtSetPrivate' file='parser' module='parserInternals'>
+      <info>ctxt:  parser context priv:  private application data  Available since 2.14.0.  Set the private application data.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info=''/>
+      <arg name='priv' type='void *' info=''/>
+    </function>
+    <function name='xmlCtxtSetResourceLoader' file='parser' module='parserInternals'>
+      <info>Installs a custom callback to load documents, DTDs or external entities.  Available since 2.14.0.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlParserCtxtPtr' info='parser context'/>
+      <arg name='loader' type='xmlResourceLoader' info='callback'/>
+      <arg name='vctxt' type='void *' info='user data'/>
+    </function>
     <function name='xmlCtxtUseOptions' file='parser' module='parser'>
       <info>DEPRECATED: Use xmlCtxtSetOptions.  Applies the options to the parser context. The following options are never cleared and can only be enabled:  XML_PARSE_NOERROR XML_PARSE_NOWARNING XML_PARSE_NONET XML_PARSE_NSCLEAN XML_PARSE_NOCDATA XML_PARSE_COMPACT XML_PARSE_OLD10 XML_PARSE_HUGE XML_PARSE_OLDSAX XML_PARSE_IGNORE_ENC XML_PARSE_BIG_LINES</info>
       <return type='int' info='0 in case of success, the set of unknown or unimplemented options in case of error.'/>
@@ -9362,23 +8994,12 @@ Could we use @subtypes for this?'/>
       <arg name='output' type='FILE *' info='the FILE * for the output'/>
       <arg name='str' type='const xmlChar *' info='the string'/>
     </function>
-    <function name='xmlDecodeEntities' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>This function is deprecated, we now always process entities content through xmlStringDecodeEntities  TODO: remove it in next major release.  [67] Reference ::= EntityRef | CharRef  [69] PEReference ::= &apos;%&apos; Name &apos;;&apos;</info>
-      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it !'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
-      <arg name='len' type='int' info='the len to decode (in bytes !), -1 for no size limit'/>
-      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF'/>
-      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
-      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
-      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
-    </function>
     <function name='xmlDefaultSAXHandlerInit' file='SAX2' module='SAX2'>
       <info>DEPRECATED: This function is a no-op. Call xmlInitParser to initialize the library.  Initialize the default SAX2 handler</info>
       <return type='void'/>
     </function>
     <function name='xmlDelEncodingAlias' file='encoding' module='encoding'>
-      <info>Unregisters an encoding alias @alias</info>
+      <info>DEPRECATED: This function modifies global state and is not thread-safe.  Unregisters an encoding alias @alias</info>
       <return type='int' info='0 in case of success, -1 in case of error'/>
       <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
     </function>
@@ -9534,7 +9155,6 @@ Could we use @subtypes for this?'/>
       <arg name='doc' type='const xmlDoc *' info='the document'/>
     </function>
     <function name='xmlDocSetRootElement' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)</cond>
       <info>Set the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).  @root must be an element node. It is unlinked before insertion.</info>
       <return type='xmlNodePtr' info='the unlinked old root element or NULL if the document didn&apos;t have a root element or a memory allocation failed.'/>
       <arg name='doc' type='xmlDocPtr' info='the document'/>
@@ -9604,13 +9224,6 @@ Could we use @subtypes for this?'/>
       <arg name='doc' type='xmlDocPtr' info='the document'/>
       <arg name='cur' type='xmlNodePtr' info='the current node'/>
     </function>
-    <function name='xmlEncodeEntities' file='entities' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>TODO: remove xmlEncodeEntities, once we are not afraid of breaking binary compatibility  People must migrate their code to xmlEncodeEntitiesReentrant ! This routine will issue a warning when encountered.</info>
-      <return type='const xmlChar *' info='NULL'/>
-      <arg name='doc' type='xmlDocPtr' info='the document containing the string'/>
-      <arg name='input' type='const xmlChar *' info='A string to convert to XML.'/>
-    </function>
     <function name='xmlEncodeEntitiesReentrant' file='entities' module='entities'>
       <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. Contrary to xmlEncodeEntities, this routine is reentrant, and result must be deallocated.</info>
       <return type='xmlChar *' info='A newly allocated string with the substitution done.'/>
@@ -9623,154 +9236,6 @@ Could we use @subtypes for this?'/>
       <arg name='doc' type='const xmlDoc *' info='the document containing the string'/>
       <arg name='input' type='const xmlChar *' info='A string to convert to XML.'/>
     </function>
-    <functype name='xmlEntityReferenceFunc' file='parserInternals' module='parserInternals'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Callback function used when one needs to be able to track back the provenance of a chunk of nodes inherited from an entity replacement.</info>
-      <return type='void'/>
-      <arg name='ent' type='xmlEntityPtr' info='the entity'/>
-      <arg name='firstNode' type='xmlNodePtr' info='the fist node in the chunk'/>
-      <arg name='lastNode' type='xmlNodePtr' info='the last nod in the chunk'/>
-    </functype>
-    <function name='xmlExpCtxtNbCons' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Debugging facility provides the number of allocated nodes over lifetime</info>
-      <return type='int' info='the number of nodes ever allocated or -1 in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
-    </function>
-    <function name='xmlExpCtxtNbNodes' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Debugging facility provides the number of allocated nodes at a that point</info>
-      <return type='int' info='the number of nodes in use or -1 in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
-    </function>
-    <function name='xmlExpDump' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Serialize the expression as compiled to the buffer</info>
-      <return type='void'/>
-      <arg name='buf' type='xmlBufferPtr' info='a buffer to receive the output'/>
-      <arg name='expr' type='xmlExpNodePtr' info='the compiled expression'/>
-    </function>
-    <function name='xmlExpExpDerive' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Evaluates the expression resulting from @exp consuming a sub expression @sub Based on algebraic derivation and sometimes direct Brzozowski derivation it usually takes less than linear time and can handle expressions generating infinite languages.</info>
-      <return type='xmlExpNodePtr' info='the resulting expression or NULL in case of internal error, the result must be freed'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the englobing expression'/>
-      <arg name='sub' type='xmlExpNodePtr' info='the subexpression'/>
-    </function>
-    <function name='xmlExpFree' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Dereference the expression</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-    </function>
-    <function name='xmlExpFreeCtxt' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Free an expression context</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
-    </function>
-    <function name='xmlExpGetLanguage' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Find all the strings used in @exp and store them in @list</info>
-      <return type='int' info='the number of unique strings found, -1 in case of errors and -2 if there is more than @len strings'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-      <arg name='langList' type='const xmlChar **' info='where to store the tokens'/>
-      <arg name='len' type='int' info='the allocated length of @list'/>
-    </function>
-    <function name='xmlExpGetStart' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Find all the strings that appears at the start of the languages accepted by @exp and store them in @list. E.g. for (a, b) | c it will return the list [a, c]</info>
-      <return type='int' info='the number of unique strings found, -1 in case of errors and -2 if there is more than @len strings'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-      <arg name='tokList' type='const xmlChar **' info='where to store the tokens'/>
-      <arg name='len' type='int' info='the allocated length of @list'/>
-    </function>
-    <function name='xmlExpIsNillable' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Finds if the expression is nillable, i.e. if it accepts the empty sequence</info>
-      <return type='int' info='1 if nillable, 0 if not and -1 in case of error'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-    </function>
-    <function name='xmlExpMaxToken' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Indicate the maximum number of input a expression can accept</info>
-      <return type='int' info='the maximum length or -1 in case of error'/>
-      <arg name='expr' type='xmlExpNodePtr' info='a compiled expression'/>
-    </function>
-    <function name='xmlExpNewAtom' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Get the atom associated to this name from that context</info>
-      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='name' type='const xmlChar *' info='the atom name'/>
-      <arg name='len' type='int' info='the atom name length in byte (or -1);'/>
-    </function>
-    <function name='xmlExpNewCtxt' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Creates a new context for manipulating expressions</info>
-      <return type='xmlExpCtxtPtr' info='the context or NULL in case of error'/>
-      <arg name='maxNodes' type='int' info='the maximum number of nodes'/>
-      <arg name='dict' type='xmlDictPtr' info='optional dictionary to use internally'/>
-    </function>
-    <function name='xmlExpNewOr' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Get the atom associated to the choice @left | @right Note that @left and @right are consumed in the operation, to keep an handle on them use xmlExpRef() and use xmlExpFree() to release them, this is true even in case of failure (unless ctxt == NULL).</info>
-      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='left' type='xmlExpNodePtr' info='left expression'/>
-      <arg name='right' type='xmlExpNodePtr' info='right expression'/>
-    </function>
-    <function name='xmlExpNewRange' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Get the atom associated to the range (@subset){@min, @max} Note that @subset is consumed in the operation, to keep an handle on it use xmlExpRef() and use xmlExpFree() to release it, this is true even in case of failure (unless ctxt == NULL).</info>
-      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='subset' type='xmlExpNodePtr' info='the expression to be repeated'/>
-      <arg name='min' type='int' info='the lower bound for the repetition'/>
-      <arg name='max' type='int' info='the upper bound for the repetition, -1 means infinite'/>
-    </function>
-    <function name='xmlExpNewSeq' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Get the atom associated to the sequence @left , @right Note that @left and @right are consumed in the operation, to keep an handle on them use xmlExpRef() and use xmlExpFree() to release them, this is true even in case of failure (unless ctxt == NULL).</info>
-      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='left' type='xmlExpNodePtr' info='left expression'/>
-      <arg name='right' type='xmlExpNodePtr' info='right expression'/>
-    </function>
-    <function name='xmlExpParse' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Minimal parser for regexps, it understand the following constructs - string terminals - choice operator | - sequence operator , - subexpressions (...) - usual cardinality operators + * and ? - finite sequences  { min, max } - infinite sequences { min, * } There is minimal checkings made especially no checking on strings values</info>
-      <return type='xmlExpNodePtr' info='a new expression or NULL in case of failure'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
-      <arg name='expr' type='const char *' info='the 0 terminated string'/>
-    </function>
-    <function name='xmlExpRef' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Increase the reference count of the expression</info>
-      <return type='void'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-    </function>
-    <function name='xmlExpStringDerive' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Do one step of Brzozowski derivation of the expression @exp with respect to the input string</info>
-      <return type='xmlExpNodePtr' info='the resulting expression or NULL in case of internal error'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
-      <arg name='str' type='const xmlChar *' info='the string'/>
-      <arg name='len' type='int' info='the string len in bytes if available'/>
-    </function>
-    <function name='xmlExpSubsume' file='xmlregexp' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
-      <info>Check whether @exp accepts all the languages accepted by @sub the input being a subexpression.</info>
-      <return type='int' info='1 if true 0 if false and -1 in case of failure.'/>
-      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
-      <arg name='exp' type='xmlExpNodePtr' info='the englobing expression'/>
-      <arg name='sub' type='xmlExpNodePtr' info='the subexpression'/>
-    </function>
     <functype name='xmlExternalEntityLoader' file='parser' module='parser'>
       <info>External entity loaders types.</info>
       <return type='xmlParserInputPtr' info='the entity input parser.'/>
@@ -9801,12 +9266,11 @@ Could we use @subtypes for this?'/>
       <arg name='len' type='int' info='number of bytes to write'/>
     </function>
     <function name='xmlFindCharEncodingHandler' file='encoding' module='encoding'>
-      <info>DEPRECATED: Use xmlOpenCharEncodingHandler which has better error reporting.</info>
+      <info>DEPRECATED: Use xmlOpenCharEncodingHandler which has better error reporting.  If the encoding is UTF-8, this will return a no-op handler that shouldn&apos;t be used.</info>
       <return type='xmlCharEncodingHandlerPtr' info='the handler or NULL if no handler was found or an error occurred.'/>
       <arg name='name' type='const char *' info='a string describing the char encoding.'/>
     </function>
     <function name='xmlFirstElementChild' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Find the first child node which is an element.  Note that entity references are not expanded.</info>
       <return type='xmlNodePtr' info='the first element or NULL if parent has no children.'/>
       <arg name='parent' type='xmlNodePtr' info='the parent node'/>
@@ -9824,7 +9288,7 @@ Could we use @subtypes for this?'/>
       <arg name='table' type='xmlAttributeTablePtr' info='An attribute table'/>
     </function>
     <function name='xmlFreeAutomata' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Free an automata</info>
       <return type='void'/>
       <arg name='am' type='xmlAutomataPtr' info='an automata'/>
@@ -10087,29 +9551,14 @@ Could we use @subtypes for this?'/>
       <arg name='prefix' type='const xmlChar *' info='the element namespace prefix'/>
     </function>
     <function name='xmlGetEncodingAlias' file='encoding' module='encoding'>
-      <info>Lookup an encoding name for the given alias.</info>
+      <info>DEPRECATED: This function is not thread-safe.  Lookup an encoding name for the given alias.</info>
       <return type='const char *' info='NULL if not found, otherwise the original name'/>
       <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
     </function>
     <function name='xmlGetExternalEntityLoader' file='parser' module='parserInternals'>
-      <info>Get the default external entity resolver function for the application</info>
+      <info>DEPRECATED: See xmlSetExternalEntityLoader.  Get the default external entity resolver function for the application</info>
       <return type='xmlExternalEntityLoader' info='the xmlExternalEntityLoader function pointer'/>
     </function>
-    <function name='xmlGetFeature' file='parser' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Read the current value of one feature of this parser instance</info>
-      <return type='int' info='-1 in case or error, 0 otherwise'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context'/>
-      <arg name='name' type='const char *' info='the feature name'/>
-      <arg name='result' type='void *' info='location to store the result'/>
-    </function>
-    <function name='xmlGetFeaturesList' file='parser' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Copy at most *@len feature names into the @result array</info>
-      <return type='int' info='-1 in case or error, or the total number of features, len is updated with the number of strings copied, strings must not be deallocated'/>
-      <arg name='len' type='int *' info='the length of the features name array (input/output)'/>
-      <arg name='result' type='const char **' info='an array of string to be filled with the features name.'/>
-    </function>
     <function name='xmlGetGlobalState' file='globals' module='globals'>
       <info>DEPRECATED</info>
       <return type='xmlGlobalStatePtr' info='NULL.'/>
@@ -10146,20 +9595,17 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='the attribute name'/>
     </function>
     <function name='xmlGetNodePath' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)</cond>
       <info>Build a structure based Path for the given node</info>
       <return type='xmlChar *' info='the new path or NULL in case of error. The caller must free the returned string'/>
       <arg name='node' type='const xmlNode *' info='a node'/>
     </function>
     <function name='xmlGetNsList' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Find all in-scope namespaces of a node.  Use xmlGetNsListSafe for better error reporting.</info>
       <return type='xmlNsPtr *' info='a NULL terminated array of namespace pointers that must be freed by the caller or NULL if no namespaces were found or a memory allocation failed.'/>
       <arg name='doc' type='const xmlDoc *' info='the document'/>
       <arg name='node' type='const xmlNode *' info='the current node'/>
     </function>
     <function name='xmlGetNsListSafe' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Find all in-scope namespaces of a node. @out returns a NULL terminated array of namespace pointers that must be freed by the caller.  Available since 2.13.0.</info>
       <return type='int' info='0 on success, 1 if no namespaces were found, -1 if a memory allocation failed.'/>
       <arg name='doc' type='const xmlDoc *' info='the document'/>
@@ -10206,13 +9652,6 @@ Could we use @subtypes for this?'/>
       <arg name='utf' type='const unsigned char *' info='a sequence of UTF-8 encoded bytes'/>
       <arg name='len' type='int *' info='a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence.'/>
     </function>
-    <function name='xmlHandleEntity' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Default handling of defined entities, when should we define a new input stream ? When do we just handle that as a set of chars ?  OBSOLETE: to be removed at some point.</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-      <arg name='entity' type='xmlEntityPtr' info='an XML entity pointer.'/>
-    </function>
     <function name='xmlHasFeature' file='parser' module='parser'>
       <info>Examines if the library has been compiled with a given feature.</info>
       <return type='int' info='a non-zero value if the feature exist, otherwise zero. Returns zero (0) if the feature does not exist or an unknown unknown feature is requested, non-zero otherwise.'/>
@@ -10481,32 +9920,6 @@ Could we use @subtypes for this?'/>
       <arg name='payload' type='void *' info='pointer to the payload'/>
       <arg name='dealloc' type='xmlHashDeallocator' info='deallocator function for replaced item or NULL'/>
     </function>
-    <function name='xmlIOFTPClose' file='xmlIO' module='xmlIO'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>DEPRECATED: Internal function, don&apos;t use.  Close an FTP I/O channel</info>
-      <return type='int' info='0'/>
-      <arg name='context' type='void *' info='the I/O context'/>
-    </function>
-    <function name='xmlIOFTPMatch' file='xmlIO' module='xmlIO'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>DEPRECATED: Internal function, don&apos;t use.  check if the URI matches an FTP one</info>
-      <return type='int' info='1 if matches, 0 otherwise'/>
-      <arg name='filename' type='const char *' info='the URI for matching'/>
-    </function>
-    <function name='xmlIOFTPOpen' file='xmlIO' module='xmlIO'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>DEPRECATED: Internal function, don&apos;t use.  open an FTP I/O channel</info>
-      <return type='void *' info='an I/O context or NULL in case of error'/>
-      <arg name='filename' type='const char *' info='the URI for matching'/>
-    </function>
-    <function name='xmlIOFTPRead' file='xmlIO' module='xmlIO'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>DEPRECATED: Internal function, don&apos;t use.  Read @len bytes to @buffer from the I/O channel.</info>
-      <return type='int' info='the number of bytes written'/>
-      <arg name='context' type='void *' info='the I/O context'/>
-      <arg name='buffer' type='char *' info='where to drop data'/>
-      <arg name='len' type='int' info='number of bytes to write'/>
-    </function>
     <function name='xmlIOHTTPClose' file='xmlIO' module='xmlIO'>
       <cond>defined(LIBXML_HTTP_ENABLED)</cond>
       <info>DEPRECATED: Internal function, don&apos;t use.  Close an HTTP I/O channel</info>
@@ -10580,7 +9993,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlInitializeCatalog' file='catalog' module='catalog'>
       <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
-      <info>Do the catalog initialization. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
+      <info>Load the default system catalog.</info>
       <return type='void'/>
     </function>
     <function name='xmlInitializeDict' file='dict' module='dict'>
@@ -10592,11 +10005,6 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='gs' type='xmlGlobalStatePtr' info='a pointer to a newly allocated global state'/>
     </function>
-    <function name='xmlInitializePredefinedEntities' file='entities' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Set up the predefined entities. Deprecated call</info>
-      <return type='void'/>
-    </function>
     <functype name='xmlInputCloseCallback' file='xmlIO' module='xmlIO'>
       <info>Callback used in the I/O Input API to close the resource</info>
       <return type='int' info='0 or -1 in case of error'/>
@@ -10619,6 +10027,12 @@ Could we use @subtypes for this?'/>
       <arg name='buffer' type='char *' info='the buffer to store data read'/>
       <arg name='len' type='int' info='the length of the buffer in bytes'/>
     </functype>
+    <function name='xmlInputSetEncodingHandler' file='parser' module='parserInternals'>
+      <info>Use encoding handler to decode input data.  Closes the handler on error.</info>
+      <return type='int' info='an xmlParserErrors code.'/>
+      <arg name='input' type='xmlParserInputPtr' info='the input stream'/>
+      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the encoding handler'/>
+    </function>
     <function name='xmlIsBaseChar' file='chvalid' module='chvalid'>
       <info>This function is DEPRECATED. Use xmlIsBaseChar_ch or xmlIsBaseCharQ instead</info>
       <return type='int' info='true if argument valid, false otherwise'/>
@@ -10667,7 +10081,7 @@ Could we use @subtypes for this?'/>
       <arg name='ch' type='unsigned int' info='character to validate'/>
     </function>
     <function name='xmlIsLetter' file='parserInternals' module='parserInternals'>
-      <info>Check whether the character is allowed by the production [84] Letter ::= BaseChar | Ideographic</info>
+      <info>DEPRECATED: Internal function, don&apos;t use.  Check whether the character is allowed by the production [84] Letter ::= BaseChar | Ideographic</info>
       <return type='int' info='0 if not, non-zero otherwise'/>
       <arg name='c' type='int' info='an unicode character (int)'/>
     </function>
@@ -10705,7 +10119,6 @@ Could we use @subtypes for this?'/>
       <arg name='val' type='int' info='int 0 or 1'/>
     </function>
     <function name='xmlLastElementChild' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Find the last child node which is an element.  Note that entity references are not expanded.</info>
       <return type='xmlNodePtr' info='the last element or NULL if parent has no children.'/>
       <arg name='parent' type='xmlNodePtr' info='the parent node'/>
@@ -10897,7 +10310,7 @@ Could we use @subtypes for this?'/>
       <arg name='pathss' type='const char *' info='a list of directories separated by a colon or a space.'/>
     </function>
     <function name='xmlLoadExternalEntity' file='parser' module='parserInternals'>
-      <info></info>
+      <info>@URL is a filename or URL. If if contains the substring &quot;://&quot;, it is assumed to be a Legacy Extended IRI. Otherwise, it is treated as a filesystem path.  @ID is an optional XML public ID, typically from a doctype declaration. It is used for catalog lookups.  If catalog lookup is enabled (default is yes) and URL or ID are found in system or local XML catalogs, URL is replaced with the result. Then the following resource loaders will be called if they were registered (in order of precedence):  - the resource loader set with xmlCtxtSetResourceLoader - the global external entity loader set with xmlSetExternalEntityLoader (without catalog resolution, deprecated) - the per-thread xmlParserInputBufferCreateFilenameFunc set with xmlParserInputBufferCreateFilenameDefault (deprecated) - the default loader which will return - the result from a matching global input callback set with xmlRegisterInputCallbacks (deprecated) - a HTTP resource if support is compiled in. - a file opened from the filesystem, with automatic detection of compressed files if support is compiled in.</info>
       <return type='xmlParserInputPtr' info='the xmlParserInputPtr or NULL'/>
       <arg name='URL' type='const char *' info='the URL for the entity to load'/>
       <arg name='ID' type='const char *' info='the Public ID for the entity to load'/>
@@ -10914,24 +10327,11 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
     </function>
     <function name='xmlLookupCharEncodingHandler' file='encoding' module='encoding'>
-      <info>Find or create a handler matching the encoding. If no default or registered handler could be found, try to create a handler using iconv or ICU if supported.  The handler must be closed with xmlCharEncCloseFunc.  Available since 2.13.0.</info>
-      <return type='int' info='an xmlParserErrors error code.'/>
+      <info>Find or create a handler matching the encoding. The following converters are looked up in order:  - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII) - User-registered global handler (deprecated) - iconv if enabled - ICU if enabled  The handler must be closed with xmlCharEncCloseFunc.  If the encoding is UTF-8, a NULL handler and no error code will be returned.  Available since 2.13.0.</info>
+      <return type='int' info='XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another xmlParserErrors error code.'/>
       <arg name='enc' type='xmlCharEncoding' info='an xmlCharEncoding value.'/>
       <arg name='out' type='xmlCharEncodingHandler **' info='pointer to result'/>
     </function>
-    <function name='xmlLsCountNode' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
-      <info>Count the children of @node.</info>
-      <return type='int' info='the number of children of @node.'/>
-      <arg name='node' type='xmlNodePtr' info='the node to count'/>
-    </function>
-    <function name='xmlLsOneNode' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
-      <info>Dump to @output the type and name of @node.</info>
-      <return type='void'/>
-      <arg name='output' type='FILE *' info='the FILE * for the output'/>
-      <arg name='node' type='xmlNodePtr' info='the node to dump'/>
-    </function>
     <function name='xmlMallocAtomicLoc' file='xmlmemory' module='xmlmemory'>
       <info>DEPRECATED: don&apos;t use</info>
       <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
@@ -11066,172 +10466,6 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='tok' type='xmlMutexPtr' info='the simple mutex'/>
     </function>
-    <function name='xmlNamespaceParseNCName' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>parse an XML namespace name.  TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  [NS 3] NCName ::= (Letter | &apos;_&apos;) (NCNameChar)*  [NS 4] NCNameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | CombiningChar | Extender</info>
-      <return type='xmlChar *' info='the namespace name or NULL'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-    </function>
-    <function name='xmlNamespaceParseNSDef' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>parse a namespace prefix declaration  TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  [NS 1] NSDef ::= PrefixDef Eq SystemLiteral  [NS 2] PrefixDef ::= &apos;xmlns&apos; (&apos;:&apos; NCName)?</info>
-      <return type='xmlChar *' info='the namespace name'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-    </function>
-    <function name='xmlNamespaceParseQName' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  parse an XML qualified name  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
-      <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any.'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-      <arg name='prefix' type='xmlChar **' info='a xmlChar **'/>
-    </function>
-    <function name='xmlNanoFTPCheckResponse' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Check if there is a response from the FTP server after a command.</info>
-      <return type='int' info='the code number, or 0'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPCleanup' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Cleanup the FTP protocol layer. This cleanup proxy information.</info>
-      <return type='void'/>
-    </function>
-    <function name='xmlNanoFTPClose' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Close the connection and both control and transport</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPCloseConnection' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Close the data connection from the server</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPConnect' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Tries to open a control connection</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPConnectTo' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Tries to open a control connection to the given server/port</info>
-      <return type='void *' info='an fTP context or NULL if it failed'/>
-      <arg name='server' type='const char *' info='an FTP server name'/>
-      <arg name='port' type='int' info='the port (use 21 if 0)'/>
-    </function>
-    <function name='xmlNanoFTPCwd' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Tries to change the remote directory</info>
-      <return type='int' info='-1 in case of error, 1 if CWD worked, 0 if it failed'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='directory' type='const char *' info='a directory on the server'/>
-    </function>
-    <function name='xmlNanoFTPDele' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Tries to delete an item (file or directory) from server</info>
-      <return type='int' info='-1 in case of error, 1 if DELE worked, 0 if it failed'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='file' type='const char *' info='a file or directory on the server'/>
-    </function>
-    <function name='xmlNanoFTPFreeCtxt' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Frees the context after closing the connection.</info>
-      <return type='void'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPGet' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Fetch the given file from the server. All data are passed back in the callbacks. The last callback has a size of 0 block.</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='callback' type='ftpDataCallback' info='the user callback'/>
-      <arg name='userData' type='void *' info='the user callback data'/>
-      <arg name='filename' type='const char *' info='the file to retrieve'/>
-    </function>
-    <function name='xmlNanoFTPGetConnection' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Try to open a data connection to the server. Currently only passive mode is supported.</info>
-      <return type='SOCKET' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPGetResponse' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Get the response from the FTP server after a command.</info>
-      <return type='int' info='the code number'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPGetSocket' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Initiate fetch of the given file from the server.</info>
-      <return type='SOCKET' info='the socket for the data connection, or &lt;0 in case of error'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='filename' type='const char *' info='the file to retrieve (or NULL if path is in context).'/>
-    </function>
-    <function name='xmlNanoFTPInit' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Initialize the FTP protocol layer. Currently it just checks for proxy information, and get the hostname</info>
-      <return type='void'/>
-    </function>
-    <function name='xmlNanoFTPList' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Do a listing on the server. All files info are passed back in the callbacks.</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='callback' type='ftpListCallback' info='the user callback'/>
-      <arg name='userData' type='void *' info='the user callback data'/>
-      <arg name='filename' type='const char *' info='optional files to list'/>
-    </function>
-    <function name='xmlNanoFTPNewCtxt' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Allocate and initialize a new FTP context.</info>
-      <return type='void *' info='an FTP context or NULL in case of error.'/>
-      <arg name='URL' type='const char *' info='The URL used to initialize the context'/>
-    </function>
-    <function name='xmlNanoFTPOpen' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Start to fetch the given ftp:// resource</info>
-      <return type='void *' info='an FTP context, or NULL'/>
-      <arg name='URL' type='const char *' info='the URL to the resource'/>
-    </function>
-    <function name='xmlNanoFTPProxy' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Setup the FTP proxy information. This can also be done by using ftp_proxy ftp_proxy_user and ftp_proxy_password environment variables.</info>
-      <return type='void'/>
-      <arg name='host' type='const char *' info='the proxy host name'/>
-      <arg name='port' type='int' info='the proxy port'/>
-      <arg name='user' type='const char *' info='the proxy user name'/>
-      <arg name='passwd' type='const char *' info='the proxy password'/>
-      <arg name='type' type='int' info='the type of proxy 1 for using SITE, 2 for USER a@b'/>
-    </function>
-    <function name='xmlNanoFTPQuit' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Send a QUIT command to the server</info>
-      <return type='int' info='-1 in case of error, 0 otherwise'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-    </function>
-    <function name='xmlNanoFTPRead' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>This function tries to read @len bytes from the existing FTP connection and saves them in @dest. This is a blocking call.</info>
-      <return type='int' info='the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error.'/>
-      <arg name='ctx' type='void *' info='the FTP context'/>
-      <arg name='dest' type='void *' info='a buffer'/>
-      <arg name='len' type='int' info='the buffer length'/>
-    </function>
-    <function name='xmlNanoFTPScanProxy' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>(Re)Initialize the FTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like ftp://myproxy/ or ftp://myproxy:3128/ A NULL URL cleans up proxy information.</info>
-      <return type='void'/>
-      <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context'/>
-    </function>
-    <function name='xmlNanoFTPUpdateURL' file='nanoftp' module='nanoftp'>
-      <cond>defined(LIBXML_FTP_ENABLED)</cond>
-      <info>Update an FTP context by parsing the URL and finding new path it indicates. If there is an error in the protocol, hostname, port or other information, the error is raised. It indicates a new connection has to be established.</info>
-      <return type='int' info='0 if Ok, -1 in case of error (other host).'/>
-      <arg name='ctx' type='void *' info='an FTP context'/>
-      <arg name='URL' type='const char *' info='The URL used to update the context'/>
-    </function>
     <function name='xmlNanoHTTPAuthHeader' file='nanohttp' module='nanohttp'>
       <cond>defined(LIBXML_HTTP_ENABLED)</cond>
       <info>Get the authentication header of an HTTP context</info>
@@ -11352,7 +10586,7 @@ Could we use @subtypes for this?'/>
       <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context'/>
     </function>
     <function name='xmlNewAutomata' file='xmlautomata' module='xmlregexp'>
-      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
+      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
       <info>Create a new automata</info>
       <return type='xmlAutomataPtr' info='the new object or NULL in case of failure'/>
     </function>
@@ -11370,7 +10604,7 @@ Could we use @subtypes for this?'/>
       <arg name='sgml' type='int' info='should this create an SGML catalog'/>
     </function>
     <function name='xmlNewCharEncodingHandler' file='encoding' module='encoding'>
-      <info>Create and registers an xmlCharEncodingHandler.</info>
+      <info>DEPRECATED: This function modifies global state and is not thread-safe.  Create and registers an xmlCharEncodingHandler.</info>
       <return type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr created (or NULL in case of error).'/>
       <arg name='name' type='const char *' info='the encoding name, in UTF-8 format (ASCII actually)'/>
       <arg name='input' type='xmlCharEncodingInputFunc' info='the xmlCharEncodingInputFunc to read that encoding'/>
@@ -11383,7 +10617,6 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='the entity name'/>
     </function>
     <function name='xmlNewChild' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Create a new child element and append it to a parent element.  If @ns is NULL, the newly created element inherits the namespace of the parent.  If provided, @content is expected to be a valid XML attribute value possibly containing character and entity references. Text and entity reference node will be added to the child element, see xmlNewDocNode.</info>
       <return type='xmlNodePtr' info='a pointer to the new node object or NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='parent' type='xmlNodePtr' info='the parent node'/>
@@ -11415,7 +10648,6 @@ Could we use @subtypes for this?'/>
       <arg name='type' type='xmlElementContentType' info='the type of element content decl'/>
     </function>
     <function name='xmlNewDocFragment' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Create a document fragment node.</info>
       <return type='xmlNodePtr' info='a pointer to the new node object or NULL if a memory allocation failed.'/>
       <arg name='doc' type='xmlDocPtr' info='the target document (optional)'/>
@@ -11451,7 +10683,6 @@ Could we use @subtypes for this?'/>
       <arg name='value' type='const xmlChar *' info='attribute value with XML references (optional)'/>
     </function>
     <function name='xmlNewDocRawNode' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Create an element node.  If provided, @value should be a raw, unescaped string.</info>
       <return type='xmlNodePtr' info='a pointer to the new node object or NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='doc' type='xmlDocPtr' info='the target document'/>
@@ -11502,14 +10733,6 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='ent' type='xmlEntityPtr' info='an Entity pointer'/>
     </function>
-    <function name='xmlNewGlobalNs' file='tree' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Creation of a Namespace, the old way using PI and without scoping DEPRECATED !!!</info>
-      <return type='xmlNsPtr' info='NULL this functionality had been removed'/>
-      <arg name='doc' type='xmlDocPtr' info='the document carrying the namespace'/>
-      <arg name='href' type='const xmlChar *' info='the URI associated'/>
-      <arg name='prefix' type='const xmlChar *' info='the prefix for the namespace'/>
-    </function>
     <function name='xmlNewIOInputStream' file='parser' module='parserInternals'>
       <info>Create a new input stream structure encapsulating the @input into a stream suitable for the parser.</info>
       <return type='xmlParserInputPtr' info='the new input stream or NULL'/>
@@ -11517,14 +10740,52 @@ Could we use @subtypes for this?'/>
       <arg name='buf' type='xmlParserInputBufferPtr' info='an input buffer'/>
       <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
     </function>
+    <function name='xmlNewInputFromFd' file='parser' module='parserInternals'>
+      <info>Creates a new parser input to read from a zero-terminated string.  @url is used as base to resolve external entities and for error reporting.  @fd is closed after parsing has finished.  Available since 2.14.0.</info>
+      <return type='xmlParserInputPtr' info='a new parser input or NULL if a memory allocation failed.'/>
+      <arg name='url' type='const char *' info='base URL (optional)'/>
+      <arg name='fd' type='int' info='file descriptor'/>
+      <arg name='flags' type='int' info='unused, pass 0'/>
+    </function>
     <function name='xmlNewInputFromFile' file='parserInternals' module='parserInternals'>
-      <info>Create a new input stream based on a file or an URL.</info>
+      <info>DEPRECATED: Use xmlNewInputFromUrl.  Create a new input stream based on a file or an URL.</info>
       <return type='xmlParserInputPtr' info='the new input stream or NULL in case of error'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='filename' type='const char *' info='the filename to use as entity'/>
     </function>
+    <function name='xmlNewInputFromIO' file='parser' module='parserInternals'>
+      <info>Creates a new parser input to read from input callbacks and cintext.  @url is used as base to resolve external entities and for error reporting.  @ioRead is called to read new data into a provided buffer. It must return the number of bytes written into the buffer ot a negative xmlParserErrors code on failure.  @ioClose is called after parsing has finished.  @ioCtxt is an opaque pointer passed to the callbacks.  Available since 2.14.0.</info>
+      <return type='xmlParserInputPtr' info='a new parser input or NULL if a memory allocation failed.'/>
+      <arg name='url' type='const char *' info='base URL (optional)'/>
+      <arg name='ioRead' type='xmlInputReadCallback' info='read callback'/>
+      <arg name='ioClose' type='xmlInputCloseCallback' info='close callback (optional)'/>
+      <arg name='ioCtxt' type='void *' info='IO context'/>
+      <arg name='flags' type='int' info='unused, pass 0'/>
+    </function>
+    <function name='xmlNewInputFromMemory' file='parser' module='parserInternals'>
+      <info>Creates a new parser input to read from a memory area.  @url is used as base to resolve external entities and for error reporting.  If the XML_INPUT_BUF_STATIC flag is set, the memory area must stay unchanged until parsing has finished. This can avoid temporary copies.  If the XML_INPUT_BUF_ZERO_TERMINATED flag is set, the memory area must contain a zero byte after the buffer at position @size. This can avoid temporary copies.  Available since 2.14.0.</info>
+      <return type='xmlParserInputPtr' info='a new parser input or NULL if a memory allocation failed.'/>
+      <arg name='url' type='const char *' info='base URL (optional)'/>
+      <arg name='mem' type='const void *' info='pointer to char array'/>
+      <arg name='size' type='size_t' info='size of array'/>
+      <arg name='flags' type='int' info='optimization hints'/>
+    </function>
+    <function name='xmlNewInputFromString' file='parser' module='parserInternals'>
+      <info>Creates a new parser input to read from a zero-terminated string.  @url is used as base to resolve external entities and for error reporting.  If the XML_INPUT_BUF_STATIC flag is set, the string must stay unchanged until parsing has finished. This can avoid temporary copies.  Available since 2.14.0.</info>
+      <return type='xmlParserInputPtr' info='a new parser input or NULL if a memory allocation failed.'/>
+      <arg name='url' type='const char *' info='base URL (optional)'/>
+      <arg name='str' type='const char *' info='zero-terminated string'/>
+      <arg name='flags' type='int' info='optimization hints'/>
+    </function>
+    <function name='xmlNewInputFromUrl' file='parser' module='parserInternals'>
+      <info>Create a new input stream based on a file or a URL.  The flag XML_INPUT_UNZIP allows decompression.  The flag XML_INPUT_NETWORK allows network access.  The following resource loaders will be called if they were registered (in order of precedence):  - the per-thread xmlParserInputBufferCreateFilenameFunc set with xmlParserInputBufferCreateFilenameDefault (deprecated) - the default loader which will return - the result from a matching global input callback set with xmlRegisterInputCallbacks (deprecated) - a HTTP resource if support is compiled in. - a file opened from the filesystem, with automatic detection of compressed files if support is compiled in.  Available since 2.14.0.</info>
+      <return type='int' info='an xmlParserErrors code.'/>
+      <arg name='filename' type='const char *' info='the filename to use as entity'/>
+      <arg name='flags' type='int' info='XML_INPUT flags'/>
+      <arg name='out' type='xmlParserInputPtr *' info='pointer to new parser input'/>
+    </function>
     <function name='xmlNewInputStream' file='parserInternals' module='parserInternals'>
-      <info>Create a new input stream structure.</info>
+      <info>DEPRECATED: Use xmlNewInputFromUrl or similar functions.  Create a new input stream structure.</info>
       <return type='xmlParserInputPtr' info='the new input stream or NULL'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
@@ -11578,7 +10839,6 @@ Could we use @subtypes for this?'/>
       <return type='xmlParserCtxtPtr' info='the xmlParserCtxtPtr or NULL'/>
     </function>
     <function name='xmlNewProp' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Create an attribute node.  If provided, @value should be a raw, unescaped string.  If @node is provided, the created attribute will be appended without checking for duplicate names. It is an error if @node is not an element.</info>
       <return type='xmlAttrPtr' info='a pointer to the attribute or NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='node' type='xmlNodePtr' info='the parent node (optional)'/>
@@ -11602,7 +10862,7 @@ Could we use @subtypes for this?'/>
       <arg name='userData' type='void *' info='user data'/>
     </function>
     <function name='xmlNewStringInputStream' file='parserInternals' module='parserInternals'>
-      <info>Create a new input stream based on a memory buffer.</info>
+      <info>DEPRECATED: Use xmlNewInputFromString.  Create a new input stream based on a memory buffer.</info>
       <return type='xmlParserInputPtr' info='the new input stream'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='buffer' type='const xmlChar *' info='an memory buffer'/>
@@ -11613,7 +10873,6 @@ Could we use @subtypes for this?'/>
       <arg name='content' type='const xmlChar *' info='raw text content (optional)'/>
     </function>
     <function name='xmlNewTextChild' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Create a new child element and append it to a parent element.  If @ns is NULL, the newly created element inherits the namespace of the parent.  If @content is provided, a text node will be added to the child element, see xmlNewDocRawNode.</info>
       <return type='xmlNodePtr' info='a pointer to the new node object or NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='parent' type='xmlNodePtr' info='the parent node'/>
@@ -11693,13 +10952,12 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context'/>
     </function>
     <function name='xmlNextElementSibling' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Find the closest following sibling which is a element.  Note that entity references are not expanded.</info>
       <return type='xmlNodePtr' info='the sibling or NULL if no sibling was found.'/>
       <arg name='node' type='xmlNodePtr' info='the current node'/>
     </function>
     <function name='xmlNoNetExternalEntityLoader' file='xmlIO' module='parserInternals'>
-      <info>A specific entity loader disabling network accesses, though still allowing local catalog accesses for resolution.</info>
+      <info>DEPRECATED: Use XML_PARSE_NONET.  A specific entity loader disabling network accesses, though still allowing local catalog accesses for resolution.</info>
       <return type='xmlParserInputPtr' info='a new allocated xmlParserInputPtr, or NULL.'/>
       <arg name='URL' type='const char *' info='the URL for the entity to load'/>
       <arg name='ID' type='const char *' info='the System ID for the entity to load'/>
@@ -11787,7 +11045,6 @@ Could we use @subtypes for this?'/>
       <arg name='node' type='const xmlNode *' info='the node'/>
     </function>
     <function name='xmlNodeListGetRawString' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Serializes attribute children (text and entity reference nodes) into a string. An empty list produces an empty string.  If @inLine is true, entity references will be substituted. Otherwise, entity references will be kept and special characters like &apos;&amp;&apos; will be escaped.</info>
       <return type='xmlChar *' info='a string or NULL if a memory allocation failed.'/>
       <arg name='doc' type='const xmlDoc *' info='a document (optional)'/>
@@ -11802,7 +11059,6 @@ Could we use @subtypes for this?'/>
       <arg name='inLine' type='int' info='whether entity references are substituted'/>
     </function>
     <function name='xmlNodeSetBase' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)</cond>
       <info>Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.</info>
       <return type='int' info='0 on success, -1 on error.'/>
       <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
@@ -11815,7 +11071,6 @@ Could we use @subtypes for this?'/>
       <arg name='content' type='const xmlChar *' info='the new value of the content'/>
     </function>
     <function name='xmlNodeSetContentLen' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>See xmlNodeSetContent.</info>
       <return type='int' info='0 on success, 1 on error, -1 if a memory allocation failed.'/>
       <arg name='cur' type='xmlNodePtr' info='the node being modified'/>
@@ -11823,21 +11078,18 @@ Could we use @subtypes for this?'/>
       <arg name='len' type='int' info='the size of @content'/>
     </function>
     <function name='xmlNodeSetLang' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Set the language of a node, i.e. the values of the xml:lang attribute.</info>
       <return type='int' info='0 on success, 1 if arguments are invalid, -1 if a memory allocation failed.'/>
       <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
       <arg name='lang' type='const xmlChar *' info='the language description'/>
     </function>
     <function name='xmlNodeSetName' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Set (or reset) the name of a node.</info>
       <return type='void'/>
       <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
       <arg name='name' type='const xmlChar *' info='the new tag name'/>
     </function>
     <function name='xmlNodeSetSpacePreserve' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.</info>
       <return type='int' info='0 on success, 1 if arguments are invalid, -1 if a memory allocation failed.'/>
       <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
@@ -11854,8 +11106,8 @@ Could we use @subtypes for this?'/>
       <arg name='path' type='const xmlChar *' info='the input file path'/>
     </function>
     <function name='xmlOpenCharEncodingHandler' file='encoding' module='encoding'>
-      <info>Find or create a handler matching the encoding. If no default or registered handler could be found, try to create a handler using iconv or ICU if supported.  The handler must be closed with xmlCharEncCloseFunc.  Available since 2.13.0.</info>
-      <return type='int' info='an xmlParserErrors error code.'/>
+      <info>Find or create a handler matching the encoding. The following converters are looked up in order:  - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII) - User-registered global handler (deprecated) - iconv if enabled - ICU if enabled  The handler must be closed with xmlCharEncCloseFunc.  If the encoding is UTF-8, a NULL handler and no error code will be returned.  Available since 2.13.0.</info>
+      <return type='int' info='XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another xmlParserErrors error code.'/>
       <arg name='name' type='const char *' info='a string describing the char encoding.'/>
       <arg name='output' type='int' info='boolean, use handler for output'/>
       <arg name='out' type='xmlCharEncodingHandler **' info='pointer to result'/>
@@ -12071,7 +11323,7 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
     <function name='xmlParseContent' file='parserInternals' module='parser'>
-      <info>Parse XML element content. This is useful if you&apos;re only interested in custom SAX callbacks. If you want a node list, use xmlParseInNodeContext.</info>
+      <info>Parse XML element content. This is useful if you&apos;re only interested in custom SAX callbacks. If you want a node list, use xmlCtxtParseContent.</info>
       <return type='void'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
@@ -12228,13 +11480,13 @@ Could we use @subtypes for this?'/>
       <arg name='filename' type='const char *' info='the filename'/>
     </function>
     <function name='xmlParseInNodeContext' file='parser' module='parser'>
-      <info>Parse a well-balanced chunk of an XML document within the context (DTD, namespaces, etc ...) of the given node.  The allowed sequence for the data is a Well Balanced Chunk defined by the content production in the XML grammar:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</info>
+      <info>Parse a well-balanced chunk of an XML document within the context (DTD, namespaces, etc ...) of the given node.  The allowed sequence for the data is a Well Balanced Chunk defined by the content production in the XML grammar:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*  This function assumes the encoding of @node&apos;s document which is typically not what you want. A better alternative is xmlCtxtParseContent.</info>
       <return type='xmlParserErrors' info='XML_ERR_OK if the chunk is well balanced, and the parser error code otherwise'/>
       <arg name='node' type='xmlNodePtr' info='the context node'/>
       <arg name='data' type='const char *' info='the input string'/>
       <arg name='datalen' type='int' info='the input string length in bytes'/>
       <arg name='options' type='int' info='a combination of xmlParserOption'/>
-      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
+      <arg name='listOut' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
     </function>
     <function name='xmlParseMarkupDecl' file='parserInternals' module='parser'>
       <info>DEPRECATED: Internal function, don&apos;t use.  Parse markup declarations. Always consumes &apos;&lt;!&apos; or &apos;&lt;?&apos;.  [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment  [ VC: Proper Declaration/PE Nesting ] Parameter-entity replacement text must be properly nested with markup declarations. That is to say, if either the first character or the last character of a markup declaration (markupdecl above) is contained in the replacement text for a parameter-entity reference, both must be contained in the same replacement text.  [ WFC: PEs in Internal Subset ] In the internal DTD subset, parameter-entity references can occur only where markup declarations can occur, not within markup declarations. (This does not apply to references that occur in external parameter entities or to the external subset.)</info>
@@ -12258,12 +11510,6 @@ Could we use @subtypes for this?'/>
       <return type='const xmlChar *' info='the Name parsed or NULL'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
-    <function name='xmlParseNamespace' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>xmlParseNamespace: parse specific PI &apos;&lt;?namespace ...&apos; constructs.  This is what the older xml-name Working Draft specified, a bunch of other stuff may still rely on it, so support is still here as if it was declared on the root of the Tree:-(  TODO: remove from library  To be removed at next drop of binary compatibility</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-    </function>
     <function name='xmlParseNmtoken' file='parserInternals' module='parser'>
       <info>DEPRECATED: Internal function, don&apos;t use.  parse an XML Nmtoken.  [7] Nmtoken ::= (NameChar)+  [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*</info>
       <return type='xmlChar *' info='the Nmtoken parsed or NULL'/>
@@ -12299,12 +11545,6 @@ Could we use @subtypes for this?'/>
       <return type='xmlChar *' info='the PubidLiteral parsed or NULL.'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
     </function>
-    <function name='xmlParseQuotedString' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Parse and return a string between quotes or doublequotes  TODO: Deprecated, to  be removed at next drop of binary compatibility</info>
-      <return type='xmlChar *' info='the string parser or NULL.'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-    </function>
     <function name='xmlParseReference' file='parserInternals' module='parser'>
       <info>DEPRECATED: Internal function, don&apos;t use.  parse and handle entity references in content, depending on the SAX interface, this may end-up in a call to character() if this is a CharRef, a predefined entity, if there is no reference() callback. or if the parser was asked to switch to that mode.  Always consumes &apos;&amp;&apos;.  [67] Reference ::= EntityRef | CharRef</info>
       <return type='void'/>
@@ -12404,12 +11644,6 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
     </function>
-    <function name='xmlParserHandleReference' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>TODO: Remove, now deprecated ... the test is done directly in the content parsing routines.  [67] Reference ::= EntityRef | CharRef  [68] EntityRef ::= &apos;&amp;&apos; Name &apos;;&apos;  [ WFC: Entity Declared ] the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot.  [ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity  [66] CharRef ::= &apos;&amp;#&apos; [0-9]+ &apos;;&apos; | &apos;&amp;#x&apos; [0-9a-fA-F]+ &apos;;&apos;  A PEReference may have been detected in the current input stream the handling is done accordingly to http://www.w3.org/TR/REC-xml#entproc</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
-    </function>
     <function name='xmlParserInputBufferCreateFd' file='xmlIO' module='xmlIO'>
       <info>Create a buffered parser input for the progressive parsing for the input from a file descriptor  The encoding argument is deprecated and should be set to XML_CHAR_ENCODING_NONE. The encoding can be changed with xmlSwitchEncoding or xmlSwitchEncodingName later on.</info>
       <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
@@ -12429,7 +11663,7 @@ Could we use @subtypes for this?'/>
       <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
     </function>
     <function name='xmlParserInputBufferCreateFilenameDefault' file='xmlIO' module='xmlIO'>
-      <info>Registers a callback for URI input file handling</info>
+      <info>DEPRECATED: Use xmlCtxtSetResourceLoader or similar functions.  Registers a callback for URI input file handling</info>
       <return type='xmlParserInputBufferCreateFilenameFunc' info='the old value of the registration function'/>
       <arg name='func' type='xmlParserInputBufferCreateFilenameFunc' info='function pointer to the new ParserInputBufferCreateFilenameFunc'/>
     </function>
@@ -12614,7 +11848,6 @@ Could we use @subtypes for this?'/>
       <return type='int' info='the number of output callback registered or -1 in case of error.'/>
     </function>
     <function name='xmlPreviousElementSibling' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>Find the closest preceding sibling which is a element.  Note that entity references are not expanded.</info>
       <return type='xmlNodePtr' info='the sibling or NULL if no sibling was found.'/>
       <arg name='node' type='xmlNodePtr' info='the current node'/>
@@ -12626,7 +11859,7 @@ Could we use @subtypes for this?'/>
       <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI'/>
     </function>
     <function name='xmlPushInput' file='parserInternals' module='parser'>
-      <info>Push an input stream onto the stack.  This makes the parser use an input returned from advanced functions like xmlNewInputURL or xmlNewInputMemory.</info>
+      <info>Push an input stream onto the stack.</info>
       <return type='int' info='-1 in case of error or the index in the input stack'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='input' type='xmlParserInputPtr' info='an XML parser input fragment (entity, XML fragment ...).'/>
@@ -12810,7 +12043,6 @@ Could we use @subtypes for this?'/>
       <arg name='line' type='int' info='the line number'/>
     </function>
     <function name='xmlReconciliateNs' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED)</cond>
       <info>This function checks that all the namespaces declared within the given tree are properly declared. This is needed for example after Copy or Cut and then paste operations. The subtree may still hold pointers to namespace declarations outside the subtree or invalid/masked. As much as possible the function try to reuse the existing namespaces found in the new environment. If not possible the new namespaces are redeclared on @tree at the top of the given subtree.</info>
       <return type='int' info='0 on success or -1 in case of error.'/>
       <arg name='doc' type='xmlDocPtr' info='the document'/>
@@ -12929,7 +12161,7 @@ Could we use @subtypes for this?'/>
       <arg name='regexp' type='xmlRegexpPtr' info='the compiled regexp'/>
     </function>
     <function name='xmlRegisterCharEncodingHandler' file='encoding' module='encoding'>
-      <info>Register the char encoding handler, surprising, isn&apos;t it ?</info>
+      <info>DEPRECATED: This function modifies global state and is not thread-safe.  Register the char encoding handler.</info>
       <return type='void'/>
       <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr handler block'/>
     </function>
@@ -12948,7 +12180,7 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
     </function>
     <function name='xmlRegisterInputCallbacks' file='xmlIO' module='xmlIO'>
-      <info>Register a new set of I/O callback for handling parser input.</info>
+      <info>DEPRECATED: Use xmlCtxtSetResourceLoader or similar functions.  Register a new set of I/O callback for handling parser input.</info>
       <return type='int' info='the registered handler number or -1 in case of error'/>
       <arg name='matchFunc' type='xmlInputMatchCallback' info='the xmlInputMatchCallback'/>
       <arg name='openFunc' type='xmlInputOpenCallback' info='the xmlInputOpenCallback'/>
@@ -13082,6 +12314,14 @@ Could we use @subtypes for this?'/>
       <arg name='serror' type='xmlStructuredErrorFunc' info='the error callback'/>
       <arg name='ctx' type='void *' info='contextual data for the callbacks'/>
     </function>
+    <function name='xmlRelaxNGSetResourceLoader' file='relaxng' module='relaxng'>
+      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <info>Set the callback function used to load external resources.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a Relax-NG parser context'/>
+      <arg name='loader' type='xmlResourceLoader' info='the callback'/>
+      <arg name='vctxt' type='void *' info='contextual data for the callbacks'/>
+    </function>
     <function name='xmlRelaxNGSetValidErrors' file='relaxng' module='relaxng'>
       <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>DEPRECATED: Use xmlRelaxNGSetValidStructuredErrors.  Set the error and warning callback information</info>
@@ -13179,7 +12419,6 @@ Could we use @subtypes for this?'/>
       <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
     </function>
     <function name='xmlReplaceNode' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)</cond>
       <info>Unlink the old node. If @cur is provided, it is unlinked and inserted in place of @old.  It is an error if @old has no parent.  Unlike xmlAddChild, this function doesn&apos;t merge text nodes or delete duplicate attributes.  See the notes in xmlAddChild.</info>
       <return type='xmlNodePtr' info='@old or NULL if arguments are invalid or a memory allocation failed.'/>
       <arg name='old' type='xmlNodePtr' info='the old node'/>
@@ -13194,6 +12433,16 @@ Could we use @subtypes for this?'/>
       <info>Cleanup the last global error registered. For parsing error this does not change the well-formedness result.</info>
       <return type='void'/>
     </function>
+    <functype name='xmlResourceLoader' file='parser' module='parser'>
+      <info></info>
+      <return type='int' info=''/>
+      <arg name='ctxt' type='void *' info=''/>
+      <arg name='url' type='const char *' info=''/>
+      <arg name='publicId' type='const char *' info=''/>
+      <arg name='type' type='xmlResourceType' info=''/>
+      <arg name='flags' type='int' info=''/>
+      <arg name='out' type='xmlParserInputPtr *' info=''/>
+    </functype>
     <function name='xmlSAX2AttributeDecl' file='SAX2' module='SAX2'>
       <info>An attribute definition has been parsed</info>
       <return type='void'/>
@@ -13239,8 +12488,7 @@ Could we use @subtypes for this?'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
     </function>
     <function name='xmlSAX2EndElement' file='SAX2' module='SAX2'>
-      <cond>defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when the end of an element has been detected.</info>
+      <info>DEPRECATED: Don&apos;t call this function directly.  called when the end of an element has been detected.  Used for HTML and SAX1.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='name' type='const xmlChar *' info='The element name'/>
@@ -13367,8 +12615,8 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='The entity name'/>
     </function>
     <function name='xmlSAX2ResolveEntity' file='SAX2' module='SAX2'>
-      <info>The entity loader, to control the loading of external entities, the application can either: - override this xmlSAX2ResolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
-      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
+      <info>This is only used to load DTDs. The preferred way to install custom resolvers is xmlCtxtSetResourceLoader.</info>
+      <return type='xmlParserInputPtr' info='a parser input.'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
       <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
@@ -13385,8 +12633,7 @@ Could we use @subtypes for this?'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
     </function>
     <function name='xmlSAX2StartElement' file='SAX2' module='SAX2'>
-      <cond>defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>called when an opening tag has been processed.</info>
+      <info>DEPRECATED: Don&apos;t call this function directly.  Called when an opening tag has been processed.  Used for HTML and SAX1.</info>
       <return type='void'/>
       <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
       <arg name='fullname' type='const xmlChar *' info='The element name, including namespace prefix'/>
@@ -13416,9 +12663,9 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlSAXDefaultVersion' file='SAX2' module='SAX2'>
       <cond>defined(LIBXML_SAX1_ENABLED)</cond>
-      <info>DEPRECATED: Use parser option XML_PARSE_SAX1.  Set the default version of SAX used globally by the library. By default, during initialization the default is set to 2. Note that it is generally a better coding style to use xmlSAXVersion() to set up the version explicitly for a given parsing context.</info>
-      <return type='int' info='the previous value in case of success and -1 in case of error.'/>
-      <arg name='version' type='int' info='the version, 1 or 2'/>
+      <info>DEPRECATED: Use parser option XML_PARSE_SAX1.  Has no effect.</info>
+      <return type='int' info='2 in case of success and -1 in case of error.'/>
+      <arg name='version' type='int' info='the version, must be 2'/>
     </function>
     <function name='xmlSAXParseDTD' file='parser' module='parser'>
       <cond>defined(LIBXML_VALID_ENABLED)</cond>
@@ -13590,6 +12837,13 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
       <arg name='escape' type='xmlCharEncodingOutputFunc' info='the escaping function'/>
     </function>
+    <function name='xmlSaveSetIndentString' file='xmlsave' module='xmlsave'>
+      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
+      <info>Sets the indent string.  Available since 2.14.0.</info>
+      <return type='int' info='0 on success, -1 if the string is NULL, empty or too long.'/>
+      <arg name='ctxt' type='xmlSaveCtxtPtr' info='save context'/>
+      <arg name='indent' type='const char *' info='indent string'/>
+    </function>
     <function name='xmlSaveToBuffer' file='xmlsave' module='xmlsave'>
       <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
       <info>Create a document saving context serializing to a buffer with the encoding and the options given</info>
@@ -13636,12 +12890,6 @@ Could we use @subtypes for this?'/>
       <return type='xmlChar *' info='a new string (to be deallocated by caller)'/>
       <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI'/>
     </function>
-    <function name='xmlScanName' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Trickery: parse an XML name but without consuming the input flow Needed for rollback cases. Used only when parsing entities references.  TODO: seems deprecated now, only used in the default part of xmlParserHandleReference  [4] NameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | &apos;:&apos; | CombiningChar | Extender  [5] Name ::= (Letter | &apos;_&apos; | &apos;:&apos;) (NameChar)*  [6] Names ::= Name (S Name)*</info>
-      <return type='xmlChar *' info='the Name parsed or NULL'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
-    </function>
     <function name='xmlSchemaCheckFacet' file='xmlschemastypes' module='xmlschemas'>
       <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Checks and computes the values of facets.</info>
@@ -13903,6 +13151,14 @@ Could we use @subtypes for this?'/>
       <arg name='serror' type='xmlStructuredErrorFunc' info='the structured error function'/>
       <arg name='ctx' type='void *' info='the functions context'/>
     </function>
+    <function name='xmlSchemaSetResourceLoader' file='xmlschemas' module='xmlschemas'>
+      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <info>Register a callback function that will be called to load documents or external entities.  Available since 2.14.0.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='schema parser'/>
+      <arg name='loader' type='xmlResourceLoader' info='resource loader'/>
+      <arg name='data' type='void *' info='user data which will be passed to the loader'/>
+    </function>
     <function name='xmlSchemaSetValidErrors' file='xmlschemas' module='xmlschemas'>
       <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>DEPRECATED: Use xmlSchemaSetValidStructuredErrors.  Set the error and warning callback information</info>
@@ -14228,25 +13484,11 @@ Could we use @subtypes for this?'/>
       <arg name='doc' type='xmlDocPtr' info='the document'/>
       <arg name='mode' type='int' info='the compression ratio'/>
     </function>
-    <function name='xmlSetEntityReferenceFunc' file='parserInternals' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Set the function to call call back when a xml reference has been made</info>
-      <return type='void'/>
-      <arg name='func' type='xmlEntityReferenceFunc' info='A valid function'/>
-    </function>
     <function name='xmlSetExternalEntityLoader' file='parser' module='parserInternals'>
-      <info>Changes the defaultexternal entity resolver function for the application</info>
+      <info>DEPRECATED: This is a global setting and not thread-safe. Use xmlCtxtSetResourceLoader or similar functions.  Changes the default external entity resolver function for the application.</info>
       <return type='void'/>
       <arg name='f' type='xmlExternalEntityLoader' info='the new entity resolver function'/>
     </function>
-    <function name='xmlSetFeature' file='parser' module='legacy'>
-      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
-      <info>Change the current value of one feature of this parser instance</info>
-      <return type='int' info='-1 in case or error, 0 otherwise'/>
-      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context'/>
-      <arg name='name' type='const char *' info='the feature name'/>
-      <arg name='value' type='void *' info='pointer to the location of the new value'/>
-    </function>
     <function name='xmlSetGenericErrorFunc' file='xmlerror' module='error'>
       <info>DEPRECATED: See xmlSetStructuredErrorFunc for alternatives.  Set the global &quot;generic&quot; handler and context for error messages. The generic error handler will only receive fragments of error messages which should be concatenated or printed to a stream.  If handler is NULL, use the built-in default handler which prints to stderr.  Since this is a global setting, it&apos;s a good idea to reset the error handler to its default value after collecting the errors you&apos;re interested in.  For multi-threaded applications, this must be set separately for each thread.</info>
       <return type='void'/>
@@ -14266,7 +13508,6 @@ Could we use @subtypes for this?'/>
       <arg name='ns' type='xmlNsPtr' info='a namespace pointer (optional)'/>
     </function>
     <function name='xmlSetNsProp' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)</cond>
       <info>Set (or reset) an attribute carried by a node. The ns structure must be in scope, this is not checked</info>
       <return type='xmlAttrPtr' info='the attribute pointer.'/>
       <arg name='node' type='xmlNodePtr' info='the node'/>
@@ -14275,7 +13516,6 @@ Could we use @subtypes for this?'/>
       <arg name='value' type='const xmlChar *' info='the attribute value'/>
     </function>
     <function name='xmlSetProp' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)</cond>
       <info>Set (or reset) an attribute carried by a node. If @name has a prefix, then the corresponding namespace-binding will be used, if in scope; it is an error it there&apos;s no such ns-binding for the prefix in scope.</info>
       <return type='xmlAttrPtr' info='the attribute pointer.'/>
       <arg name='node' type='xmlNodePtr' info='the node'/>
@@ -14302,139 +13542,6 @@ Could we use @subtypes for this?'/>
       <arg name='buffer' type='const xmlChar *' info='a xmlChar * buffer'/>
       <arg name='filename' type='const char *' info='a file name'/>
     </function>
-    <function name='xmlShell' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell This allow to load, validate, view, modify and save a document using a environment similar to a UNIX commandline.</info>
-      <return type='void'/>
-      <arg name='doc' type='xmlDocPtr' info='the initial document'/>
-      <arg name='filename' type='const char *' info='the output buffer'/>
-      <arg name='input' type='xmlShellReadlineFunc' info='the line reading function'/>
-      <arg name='output' type='FILE *' info='the output FILE*, defaults to stdout if NULL'/>
-    </function>
-    <function name='xmlShellBase' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;base&quot; dumps the current XML base of the node</info>
-      <return type='int' info='0'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='arg' type='char *' info='unused'/>
-      <arg name='node' type='xmlNodePtr' info='a node'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellCat' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;cat&quot; dumps the serialization node content (XML or HTML).</info>
-      <return type='int' info='0'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='arg' type='char *' info='unused'/>
-      <arg name='node' type='xmlNodePtr' info='a node'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <functype name='xmlShellCmd' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>This is a generic signature for the XML shell functions.</info>
-      <return type='int' info='an int, negative returns indicating errors.'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='a shell context'/>
-      <arg name='arg' type='char *' info='a string argument'/>
-      <arg name='node' type='xmlNodePtr' info='a first node'/>
-      <arg name='node2' type='xmlNodePtr' info='a second node'/>
-    </functype>
-    <function name='xmlShellDir' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;dir&quot; dumps information about the node (namespace, attributes, content).</info>
-      <return type='int' info='0'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='arg' type='char *' info='unused'/>
-      <arg name='node' type='xmlNodePtr' info='a node'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellDu' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;du&quot; show the structure of the subtree under node @tree If @tree is null, the command works on the current node.</info>
-      <return type='int' info='0 or -1 in case of error'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='arg' type='char *' info='unused'/>
-      <arg name='tree' type='xmlNodePtr' info='a node defining a subtree'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellList' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;ls&quot; Does an Unix like listing of the given node (like a directory)</info>
-      <return type='int' info='0'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='arg' type='char *' info='unused'/>
-      <arg name='node' type='xmlNodePtr' info='a node'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellLoad' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;load&quot; loads a new document specified by the filename</info>
-      <return type='int' info='0 or -1 if loading failed'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='filename' type='char *' info='the file name'/>
-      <arg name='node' type='xmlNodePtr' info='unused'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellPrintNode' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
-      <info>Print node to the output FILE</info>
-      <return type='void'/>
-      <arg name='node' type='xmlNodePtr' info='a non-null node to print to the output FILE'/>
-    </function>
-    <function name='xmlShellPrintXPathError' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Print the xpath error to libxml default error channel</info>
-      <return type='void'/>
-      <arg name='errorType' type='int' info='valid xpath error id'/>
-      <arg name='arg' type='const char *' info='the argument that cause xpath to fail'/>
-    </function>
-    <function name='xmlShellPrintXPathResult' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Prints result to the output FILE</info>
-      <return type='void'/>
-      <arg name='list' type='xmlXPathObjectPtr' info='a valid result generated by an xpath evaluation'/>
-    </function>
-    <function name='xmlShellPwd' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;pwd&quot; Show the full path from the root to the node, if needed building thumblers when similar elements exists at a given ancestor level. The output is compatible with XPath commands.</info>
-      <return type='int' info='0 or -1 in case of error'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='buffer' type='char *' info='the output buffer'/>
-      <arg name='node' type='xmlNodePtr' info='a node'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <functype name='xmlShellReadlineFunc' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
-      <info>This is a generic signature for the XML shell input function.</info>
-      <return type='char *' info='a string which will be freed by the Shell.'/>
-      <arg name='prompt' type='char *' info='a string prompt'/>
-    </functype>
-    <function name='xmlShellSave' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;save&quot; Write the current document to the filename, or it&apos;s original name</info>
-      <return type='int' info='0 or -1 in case of error'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='filename' type='char *' info='the file name (optional)'/>
-      <arg name='node' type='xmlNodePtr' info='unused'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellValidate' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_VALID_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;validate&quot; Validate the document, if a DTD path is provided, then the validation is done against the given DTD.</info>
-      <return type='int' info='0 or -1 in case of error'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='dtd' type='char *' info='the DTD URI (optional)'/>
-      <arg name='node' type='xmlNodePtr' info='unused'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
-    <function name='xmlShellWrite' file='debugXML' module='debugXML'>
-      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
-      <info>Implements the XML shell function &quot;write&quot; Write the current node to the filename, it saves the serialization of the subtree under the @node specified</info>
-      <return type='int' info='0 or -1 in case of error'/>
-      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
-      <arg name='filename' type='char *' info='the file name'/>
-      <arg name='node' type='xmlNodePtr' info='a node in the tree'/>
-      <arg name='node2' type='xmlNodePtr' info='unused'/>
-    </function>
     <function name='xmlSkipBlankChars' file='parserInternals' module='parser'>
       <info>DEPRECATED: Internal function, do not use.  Skip whitespace in the input stream.</info>
       <return type='int' info='the number of space chars skipped'/>
@@ -14449,7 +13556,7 @@ Could we use @subtypes for this?'/>
       <arg name='englob' type='int' info='1 if one must print the englobing parenthesis, 0 otherwise'/>
     </function>
     <function name='xmlSplitQName' file='parserInternals' module='parser'>
-      <info>parse an UTF8 encoded XML qualified name string  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
+      <info>DEPRECATED: Don&apos;t use.  parse an UTF8 encoded XML qualified name string  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
       <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any.'/>
       <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
       <arg name='name' type='const xmlChar *' info='an XML parser context'/>
@@ -14605,7 +13712,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlStringGetNodeList' file='tree' module='tree'>
       <info>DEPRECATED: Use xmlNodeSetContent.  Parse an attribute value and build a node list containing only text and entity reference nodes. The resulting nodes will be associated with the document if provided. The document is also used to look up entities.  The input is not validated. Syntax errors or references to undeclared entities will be ignored silently with unspecified results.</info>
-      <return type='xmlNodePtr' info='a pointer to the first child or NULL if a memory allocation failed.'/>
+      <return type='xmlNodePtr' info='a pointer to the first child or NULL if the value if empty or a memory allocation failed.'/>
       <arg name='doc' type='const xmlDoc *' info='a document (optional)'/>
       <arg name='value' type='const xmlChar *' info='an attribute value'/>
     </function>
@@ -14622,7 +13729,7 @@ Could we use @subtypes for this?'/>
     </function>
     <function name='xmlStringLenGetNodeList' file='tree' module='tree'>
       <info>DEPRECATED: Use xmlNodeSetContentLen.  See xmlStringGetNodeList.</info>
-      <return type='xmlNodePtr' info='a pointer to the first child or NULL if a memory allocation failed.'/>
+      <return type='xmlNodePtr' info='a pointer to the first child or NULL if the value if empty or a memory allocation failed.'/>
       <arg name='doc' type='const xmlDoc *' info='a document (optional)'/>
       <arg name='value' type='const xmlChar *' info='an attribute value'/>
       <arg name='len' type='int' info='maximum length of the attribute value'/>
@@ -15166,6 +14273,14 @@ Could we use @subtypes for this?'/>
       <arg name='prop' type='int' info='the xmlParserProperties to set'/>
       <arg name='value' type='int' info='usually 0 or 1 to (de)activate it'/>
     </function>
+    <function name='xmlTextReaderSetResourceLoader' file='xmlreader' module='xmlreader'>
+      <cond>defined(LIBXML_READER_ENABLED)</cond>
+      <info>Register a callback function that will be called to load external resources like entities.  Available since 2.14.0.</info>
+      <return type='void'/>
+      <arg name='reader' type='xmlTextReaderPtr' info='thr reader'/>
+      <arg name='loader' type='xmlResourceLoader' info='resource loader'/>
+      <arg name='data' type='void *' info='user data which will be passed to the loader'/>
+    </function>
     <function name='xmlTextReaderSetSchema' file='xmlreader' module='xmlreader'>
       <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Use XSD Schema to validate the document as it is processed. Activation is only possible before the first Read(). if @schema is NULL, then Schema validation is deactivated. The @schema should not be freed until the reader is deallocated or its use has been deactivated.</info>
@@ -16986,7 +16101,6 @@ Could we use @subtypes for this?'/>
       <return type='void'/>
     </function>
     <function name='xmlUnsetNsProp' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Remove an attribute carried by a node.</info>
       <return type='int' info='0 if successful, -1 if not found'/>
       <arg name='node' type='xmlNodePtr' info='the node'/>
@@ -16994,7 +16108,6 @@ Could we use @subtypes for this?'/>
       <arg name='name' type='const xmlChar *' info='the attribute name'/>
     </function>
     <function name='xmlUnsetProp' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Remove an attribute carried by a node. This handles only attributes in no namespace.</info>
       <return type='int' info='0 if successful, -1 if not found'/>
       <arg name='node' type='xmlNodePtr' info='the node'/>
@@ -17111,14 +16224,12 @@ Could we use @subtypes for this?'/>
       <arg name='space' type='int' info='allow spaces in front and end of the string'/>
     </function>
     <function name='xmlValidateNMToken' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Check that a value conforms to the lexical space of NMToken</info>
       <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
       <arg name='value' type='const xmlChar *' info='the value to check'/>
       <arg name='space' type='int' info='allow spaces in front and end of the string'/>
     </function>
     <function name='xmlValidateName' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Check that a value conforms to the lexical space of Name</info>
       <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
       <arg name='value' type='const xmlChar *' info='the value to check'/>
@@ -17157,7 +16268,7 @@ Could we use @subtypes for this?'/>
       <arg name='nota' type='xmlNotationPtr' info='a notation definition'/>
     </function>
     <function name='xmlValidateNotationUse' file='valid' module='valid'>
-      <cond>defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <cond>defined(LIBXML_VALID_ENABLED)</cond>
       <info>DEPRECATED: Internal function, don&apos;t use.  Validate that the given name match a notation declaration. - [ VC: Notation Declared ]</info>
       <return type='int' info='1 if valid or 0 otherwise'/>
       <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
@@ -17220,7 +16331,6 @@ Could we use @subtypes for this?'/>
       <arg name='qname' type='const xmlChar *' info='the qualified name as appearing in the serialization'/>
     </function>
     <function name='xmlValidateQName' file='tree' module='tree'>
-      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
       <info>Check that a value conforms to the lexical space of QName</info>
       <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
       <arg name='value' type='const xmlChar *' info='the value to check'/>
@@ -17329,6 +16439,14 @@ Could we use @subtypes for this?'/>
       <arg name='ctxt' type='xmlXIncludeCtxtPtr' info='an XInclude processing context'/>
       <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
     </function>
+    <function name='xmlXIncludeSetResourceLoader' file='xinclude' module='xinclude'>
+      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
+      <info>Register a callback function that will be called to load included documents.  Available since 2.14.0.</info>
+      <return type='void'/>
+      <arg name='ctxt' type='xmlXIncludeCtxtPtr' info='an XInclude processing context'/>
+      <arg name='loader' type='xmlResourceLoader' info='resource loader'/>
+      <arg name='data' type='void *' info='user data which will be passed to the loader'/>
+    </function>
     <function name='xmlXPathAddValues' file='xpathInternals' module='xpath'>
       <cond>defined(LIBXML_XPATH_ENABLED)</cond>
       <info>Implement the add operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
@@ -17727,7 +16845,7 @@ Could we use @subtypes for this?'/>
       <arg name='nargs' type='int' info='the number of arguments'/>
     </function>
     <function name='xmlXPathInit' file='xpath' module='xpath'>
-      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
       <info>DEPRECATED: Alias for xmlInitParser.</info>
       <return type='void'/>
     </function>
@@ -17739,13 +16857,13 @@ Could we use @subtypes for this?'/>
       <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
     </function>
     <function name='xmlXPathIsInf' file='xpath' module='xpath'>
-      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
       <info>Checks whether a double is an infinity.</info>
       <return type='int' info='1 if the value is +Infinite, -1 if -Infinite, 0 otherwise'/>
       <arg name='val' type='double' info='a double value'/>
     </function>
     <function name='xmlXPathIsNaN' file='xpath' module='xpath'>
-      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
+      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
       <info>Checks whether a double is a NaN.</info>
       <return type='int' info='1 if the value is a NaN, 0 otherwise'/>
       <arg name='val' type='double' info='a double value'/>
@@ -18416,12 +17534,6 @@ Could we use @subtypes for this?'/>
       <arg name='line' type='int' info='the line number'/>
       <arg name='no' type='int' info='the error number'/>
     </function>
-    <function name='xmlXPtrBuildNodeList' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Build a node list tree copy of the XPointer result. This will drop Attributes and Namespace declarations.</info>
-      <return type='xmlNodePtr' info='an xmlNodePtr list or NULL. the caller has to free the node tree.'/>
-      <arg name='obj' type='xmlXPathObjectPtr' info='the XPointer result from the evaluation.'/>
-    </function>
     <function name='xmlXPtrEval' file='xpointer' module='xpointer'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
       <info>Evaluate the XPath Location Path in the given context.</info>
@@ -18429,58 +17541,6 @@ Could we use @subtypes for this?'/>
       <arg name='str' type='const xmlChar *' info='the XPointer expression'/>
       <arg name='ctx' type='xmlXPathContextPtr' info='the XPointer context'/>
     </function>
-    <function name='xmlXPtrEvalRangePredicate' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>[8]   Predicate ::=   &apos;[&apos; PredicateExpr &apos;]&apos; [9]   PredicateExpr ::=   Expr  Evaluate a predicate as in xmlXPathEvalPredicate() but for a Location Set instead of a node set</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context'/>
-    </function>
-    <function name='xmlXPtrFreeLocationSet' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Free the LocationSet compound (not the actual ranges !).</info>
-      <return type='void'/>
-      <arg name='obj' type='xmlLocationSetPtr' info='the xmlLocationSetPtr to free'/>
-    </function>
-    <function name='xmlXPtrLocationSetAdd' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>add a new xmlXPathObjectPtr to an existing LocationSet If the location already exist in the set @val is freed.</info>
-      <return type='void'/>
-      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
-      <arg name='val' type='xmlXPathObjectPtr' info='a new xmlXPathObjectPtr'/>
-    </function>
-    <function name='xmlXPtrLocationSetCreate' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlLocationSetPtr of type double and of value @val</info>
-      <return type='xmlLocationSetPtr' info='the newly created object.'/>
-      <arg name='val' type='xmlXPathObjectPtr' info='an initial xmlXPathObjectPtr, or NULL'/>
-    </function>
-    <function name='xmlXPtrLocationSetDel' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Removes an xmlXPathObjectPtr from an existing LocationSet</info>
-      <return type='void'/>
-      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
-      <arg name='val' type='xmlXPathObjectPtr' info='an xmlXPathObjectPtr'/>
-    </function>
-    <function name='xmlXPtrLocationSetMerge' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Merges two rangesets, all ranges from @val2 are added to @val1</info>
-      <return type='xmlLocationSetPtr' info='val1 once extended or NULL in case of error.'/>
-      <arg name='val1' type='xmlLocationSetPtr' info='the first LocationSet'/>
-      <arg name='val2' type='xmlLocationSetPtr' info='the second LocationSet'/>
-    </function>
-    <function name='xmlXPtrLocationSetRemove' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Removes an entry from an existing LocationSet list.</info>
-      <return type='void'/>
-      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
-      <arg name='val' type='int' info='the index to remove'/>
-    </function>
-    <function name='xmlXPtrNewCollapsedRange' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range using a single nodes</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the starting and ending node'/>
-    </function>
     <function name='xmlXPtrNewContext' file='xpointer' module='xpointer'>
       <cond>defined(LIBXML_XPTR_ENABLED)</cond>
       <info>Create a new XPointer context</info>
@@ -18489,75 +17549,5 @@ Could we use @subtypes for this?'/>
       <arg name='here' type='xmlNodePtr' info='the node that directly contains the XPointer being evaluated or NULL'/>
       <arg name='origin' type='xmlNodePtr' info='the element from which a user or program initiated traversal of the link, or NULL.'/>
     </function>
-    <function name='xmlXPtrNewLocationSetNodeSet' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with all the nodes from @set</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='set' type='xmlNodeSetPtr' info='a node set'/>
-    </function>
-    <function name='xmlXPtrNewLocationSetNodes' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with the single range made of the two nodes @start and @end</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the start NodePtr value'/>
-      <arg name='end' type='xmlNodePtr' info='the end NodePtr value or NULL'/>
-    </function>
-    <function name='xmlXPtrNewRange' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the starting node'/>
-      <arg name='startindex' type='int' info='the start index'/>
-      <arg name='end' type='xmlNodePtr' info='the ending point'/>
-      <arg name='endindex' type='int' info='the ending index'/>
-    </function>
-    <function name='xmlXPtrNewRangeNodeObject' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range from a not to an object</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the starting node'/>
-      <arg name='end' type='xmlXPathObjectPtr' info='the ending object'/>
-    </function>
-    <function name='xmlXPtrNewRangeNodePoint' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range from a node to a point</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the starting node'/>
-      <arg name='end' type='xmlXPathObjectPtr' info='the ending point'/>
-    </function>
-    <function name='xmlXPtrNewRangeNodes' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range using 2 nodes</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlNodePtr' info='the starting node'/>
-      <arg name='end' type='xmlNodePtr' info='the ending node'/>
-    </function>
-    <function name='xmlXPtrNewRangePointNode' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range from a point to a node</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlXPathObjectPtr' info='the starting point'/>
-      <arg name='end' type='xmlNodePtr' info='the ending node'/>
-    </function>
-    <function name='xmlXPtrNewRangePoints' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Create a new xmlXPathObjectPtr of type range using 2 Points</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='start' type='xmlXPathObjectPtr' info='the starting point'/>
-      <arg name='end' type='xmlXPathObjectPtr' info='the ending point'/>
-    </function>
-    <function name='xmlXPtrRangeToFunction' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Implement the range-to() XPointer function  Obsolete. range-to is not a real function but a special type of location step which is handled in xpath.c.</info>
-      <return type='void'/>
-      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context'/>
-      <arg name='nargs' type='int' info='the number of args'/>
-    </function>
-    <function name='xmlXPtrWrapLocationSet' file='xpointer' module='xpointer'>
-      <cond>defined(LIBXML_XPTR_ENABLED) &amp;&amp; defined(LIBXML_XPTR_LOCS_ENABLED)</cond>
-      <info>Wrap the LocationSet @val in a new xmlXPathObjectPtr</info>
-      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
-      <arg name='val' type='xmlLocationSetPtr' info='the LocationSet value'/>
-    </function>
   </symbols>
 </api>
diff --git a/doc/xmllint.xml b/doc/xmllint.xml
index 97c88200..547bf678 100644
--- a/doc/xmllint.xml
+++ b/doc/xmllint.xml
@@ -72,8 +72,13 @@
             <arg choice="plain"><option>--debugent</option></arg>
             <arg choice="plain"><option>--copy</option></arg>
             <arg choice="plain"><option>--recover</option></arg>
+            <arg choice="plain"><option>--huge</option></arg>
+            <arg choice="plain"><option>--nocompact</option></arg>
+            <arg choice="plain"><option>--nodefdtd</option></arg>
             <arg choice="plain"><option>--nodict</option></arg>
+            <arg choice="plain"><option>--noenc</option></arg>
             <arg choice="plain"><option>--noent</option></arg>
+            <arg choice="plain"><option>--nofixup-base-uris</option></arg>
             <arg choice="plain"><option>--noout</option></arg>
             <arg choice="plain"><option>--nonet</option></arg>
             <arg choice="plain"><option>--path "<replaceable class="option">PATH(S)</replaceable>"</option></arg>
@@ -99,6 +104,7 @@
             <arg choice="plain"><option>--noblanks</option></arg>
             <arg choice="plain"><option>--nocdata</option></arg>
             <arg choice="plain"><option>--format</option></arg>
+            <arg choice="plain"><option>--pretty <replaceable class="option">INTEGER</replaceable></option></arg>
             <arg choice="plain"><option>--encode <replaceable class="option">ENCODING</replaceable></option></arg>
             <arg choice="plain"><option>--dropdtd</option></arg>
             <arg choice="plain"><option>--nsclean</option></arg>
@@ -115,18 +121,20 @@
             <arg choice="plain"><option>--pattern <replaceable class="option">PATTERNVALUE</replaceable></option></arg>
             <arg choice="plain"><option>--relaxng <replaceable class="option">SCHEMA</replaceable></option></arg>
             <arg choice="plain"><option>--schema <replaceable class="option">SCHEMA</replaceable></option></arg>
+            <arg choice="plain"><option>--schematron <replaceable class="option">SCHEMA</replaceable></option></arg>
             <arg choice="plain"><option>--c14n</option></arg>
+            <arg choice="plain"><option>--c14n11</option></arg>
+            <arg choice="plain"><option>--exc-c14n</option></arg>
             <arg choice="plain"><option>--pedantic</option></arg>
+            <arg choice="plain"><option>--sax</option></arg>
+            <arg choice="plain"><option>--sax1</option></arg>
+            <arg choice="plain"><option>--oldxml10</option></arg>
         </group>
         <group choice="req">
             <arg choice="plain" rep="repeat"><replaceable>XML-FILE(S)</replaceable></arg>
             <arg choice="plain" rep="norepeat">-</arg>
         </group>
     </cmdsynopsis>
-    <cmdsynopsis>
-        <command>xmllint</command>
-        <arg choice="plain"><option>--help</option></arg>
-    </cmdsynopsis>
 </refsynopsisdiv>
 
 <refsect1 id="description">
@@ -194,6 +202,8 @@
 
         <varlistentry>
             <term><option>--c14n</option></term>
+            <term><option>--c14n11</option></term>
+            <term><option>--exc-c14n</option></term>
             <listitem>
                 <para>
                     Use the W3C <acronym>XML</acronym> Canonicalisation (<acronym>C14N</acronym>) to
@@ -276,13 +286,6 @@
             </listitem>
         </varlistentry>
 
-        <varlistentry>
-            <term><option>--help</option></term>
-            <listitem>
-                <para>Print out a short usage summary for &xmllint;.</para>
-            </listitem>
-        </varlistentry>
-
         <varlistentry>
             <term><option>--html</option></term>
             <listitem>
@@ -302,6 +305,13 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--huge</option></term>
+            <listitem>
+                <para>Ignore some hardcoded parser limits.</para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--insert</option></term>
             <listitem>
@@ -379,6 +389,26 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--nocompact</option></term>
+            <listitem>
+                <para>
+                    Do not generate compact text nodes (parser option
+                    XML_PARSE_COMPACT). Only for debugging.
+                </para>
+            </listitem>
+        </varlistentry>
+
+        <varlistentry>
+            <term><option>--nodefdtd</option></term>
+            <listitem>
+                <para>
+                    Do not set default HTML doctype (parser option
+                    HTML_PARSE_NODEFDTD).
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--nodict</option></term>
             <listitem>
@@ -389,6 +419,16 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--noenc</option></term>
+            <listitem>
+                <para>
+                    Ignore encoding declaration (parser option
+                    XML_PARSE_IGNORE_ENC).
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--noent</option></term>
             <listitem>
@@ -399,6 +439,16 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--nofixup-base-uris</option></term>
+            <listitem>
+                <para>
+                    Don't fix xml:base URIs when processing XIncludes
+                    (parser option XML_PARSE_NOBASEFIX).
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--nonet</option></term>
             <listitem>
@@ -447,6 +497,16 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--oldxml10</option></term>
+            <listitem>
+                <para>
+                    Use deprecated parsing rules before XML 1.0,
+                    5th edition.
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--output <replaceable class="option">FILE</replaceable></option></term>
             <listitem>
@@ -496,6 +556,16 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--pretty <replaceable class="option">INTEGER</replaceable></option></term>
+            <listitem>
+                <para>
+                    Value 0 means no formatting, 1 means XML_SAVE_FORMAT
+                    (same as --format), 2 means XML_SAVE_WSNONSIG.
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--push</option></term>
             <listitem>
@@ -534,6 +604,20 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--sax</option></term>
+            <listitem>
+                <para>Print SAX callbacks (only for debugging).</para>
+            </listitem>
+        </varlistentry>
+
+        <varlistentry>
+            <term><option>--sax1</option></term>
+            <listitem>
+                <para>Use deprecated SAX1 interface (only for debugging).</para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--schema <replaceable>SCHEMA</replaceable></option></term>
             <listitem>
@@ -544,6 +628,16 @@
             </listitem>
         </varlistentry>
 
+        <varlistentry>
+            <term><option>--schematron <replaceable>SCHEMA</replaceable></option></term>
+            <listitem>
+                <para>
+                    Use a Schematron file
+                    named <replaceable>SCHEMA</replaceable> for validation.
+                </para>
+            </listitem>
+        </varlistentry>
+
         <varlistentry>
             <term><option>--shell</option></term>
             <listitem>
diff --git a/encoding.c b/encoding.c
index 04c24e42..88a3e5ba 100644
--- a/encoding.c
+++ b/encoding.c
@@ -29,6 +29,7 @@
 #include <stdlib.h>
 
 #ifdef LIBXML_ICONV_ENABLED
+#include <iconv.h>
 #include <errno.h>
 #endif
 
@@ -42,22 +43,15 @@
 
 #include "private/buf.h"
 #include "private/enc.h"
+#include "private/entities.h"
 #include "private/error.h"
 
 #ifdef LIBXML_ICU_ENABLED
 #include <unicode/ucnv.h>
-/* Size of pivot buffer, same as icu/source/common/ucnv.cpp CHUNK_SIZE */
-#define ICU_PIVOT_BUF_SIZE 1024
-typedef struct _uconv_t uconv_t;
-struct _uconv_t {
-  UConverter *uconv; /* for conversion between an encoding and UTF-16 */
-  UConverter *utf8; /* for conversion between UTF-8 and UTF-16 */
-  UChar      pivot_buf[ICU_PIVOT_BUF_SIZE];
-  UChar      *pivot_source;
-  UChar      *pivot_target;
-};
 #endif
 
+#define XML_HANDLER_STATIC 1
+
 typedef struct _xmlCharEncodingAlias xmlCharEncodingAlias;
 typedef xmlCharEncodingAlias *xmlCharEncodingAliasPtr;
 struct _xmlCharEncodingAlias {
@@ -71,798 +65,217 @@ static int xmlCharEncodingAliasesMax = 0;
 
 static int xmlLittleEndian = 1;
 
-/************************************************************************
- *									*
- *		Conversions To/From UTF8 encoding			*
- *									*
- ************************************************************************/
+typedef struct {
+    const char *name;
+    xmlCharEncoding enc;
+} xmlEncTableEntry;
+
+static const xmlEncTableEntry xmlEncTable[] = {
+    { "ASCII", XML_CHAR_ENCODING_ASCII },
+    { "EUC-JP", XML_CHAR_ENCODING_EUC_JP },
+    { "HTML", XML_CHAR_ENCODING_HTML },
+    { "ISO LATIN 1", XML_CHAR_ENCODING_8859_1 },
+    { "ISO LATIN 2", XML_CHAR_ENCODING_8859_2 },
+    { "ISO-10646-UCS-2", XML_CHAR_ENCODING_UCS2 },
+    { "ISO-10646-UCS-4", XML_CHAR_ENCODING_UCS4LE },
+    { "ISO-2022-JP", XML_CHAR_ENCODING_2022_JP },
+    { "ISO-8859-1", XML_CHAR_ENCODING_8859_1 },
+    { "ISO-8859-10", XML_CHAR_ENCODING_8859_10 },
+    { "ISO-8859-11", XML_CHAR_ENCODING_8859_11 },
+    { "ISO-8859-13", XML_CHAR_ENCODING_8859_13 },
+    { "ISO-8859-14", XML_CHAR_ENCODING_8859_14 },
+    { "ISO-8859-15", XML_CHAR_ENCODING_8859_15 },
+    { "ISO-8859-16", XML_CHAR_ENCODING_8859_16 },
+    { "ISO-8859-2", XML_CHAR_ENCODING_8859_2 },
+    { "ISO-8859-3", XML_CHAR_ENCODING_8859_3 },
+    { "ISO-8859-4", XML_CHAR_ENCODING_8859_4 },
+    { "ISO-8859-5", XML_CHAR_ENCODING_8859_5 },
+    { "ISO-8859-6", XML_CHAR_ENCODING_8859_6 },
+    { "ISO-8859-7", XML_CHAR_ENCODING_8859_7 },
+    { "ISO-8859-8", XML_CHAR_ENCODING_8859_8 },
+    { "ISO-8859-9", XML_CHAR_ENCODING_8859_9 },
+    { "ISO-LATIN-1", XML_CHAR_ENCODING_8859_1 },
+    { "ISO-LATIN-2", XML_CHAR_ENCODING_8859_2 },
+    { "SHIFT_JIS", XML_CHAR_ENCODING_SHIFT_JIS },
+    { "UCS-2", XML_CHAR_ENCODING_UCS2 },
+    { "UCS-4", XML_CHAR_ENCODING_UCS4LE },
+    { "UCS2", XML_CHAR_ENCODING_UCS2 },
+    { "UCS4", XML_CHAR_ENCODING_UCS4LE },
+    { "US-ASCII", XML_CHAR_ENCODING_ASCII },
+    { "UTF-16", XML_CHAR_ENCODING_UTF16 },
+    { "UTF-16BE", XML_CHAR_ENCODING_UTF16BE },
+    { "UTF-16LE", XML_CHAR_ENCODING_UTF16LE },
+    { "UTF-8", XML_CHAR_ENCODING_UTF8 },
+    { "UTF16", XML_CHAR_ENCODING_UTF16LE },
+    { "UTF8", XML_CHAR_ENCODING_UTF8 }
+};
 
-/**
- * asciiToUTF8:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of ASCII chars
- * @inlen:  the length of @in
- *
- * Take a block of ASCII chars in and try to convert it to an UTF-8
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets produced.
- */
 static int
-asciiToUTF8(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen) {
-    unsigned char* outstart = out;
-    const unsigned char* base = in;
-    const unsigned char* processed = in;
-    unsigned char* outend = out + *outlen;
-    const unsigned char* inend;
-    unsigned int c;
-
-    inend = in + (*inlen);
-    while ((in < inend) && (out - outstart + 5 < *outlen)) {
-	c= *in++;
-
-        if (out >= outend)
-	    break;
-        if (c < 0x80) {
-	    *out++ = c;
-	} else {
-	    *outlen = out - outstart;
-	    *inlen = processed - base;
-	    return(XML_ENC_ERR_INPUT);
-	}
-
-	processed = (const unsigned char*) in;
-    }
-    *outlen = out - outstart;
-    *inlen = processed - base;
-    return(*outlen);
-}
+asciiToAscii(unsigned char* out, int *outlen,
+             const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF8ToUTF8(unsigned char* out, int *outlen,
+           const unsigned char* inb, int *inlenb, void *vctxt);
+static int
+latin1ToUTF8(unsigned char* out, int *outlen,
+             const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF16LEToUTF8(unsigned char* out, int *outlen,
+              const unsigned char* inb, int *inlenb, void *vctxt);
+static int
+UTF16BEToUTF8(unsigned char* out, int *outlen,
+              const unsigned char* inb, int *inlenb, void *vctxt);
 
 #ifdef LIBXML_OUTPUT_ENABLED
-/**
- * UTF8Toascii:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and try to convert it to an ASCII
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets produced.
- */
-static int
-UTF8Toascii(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen) {
-    const unsigned char* processed = in;
-    const unsigned char* outend;
-    const unsigned char* outstart = out;
-    const unsigned char* instart = in;
-    const unsigned char* inend;
-    unsigned int c, d;
-    int trailing;
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
-        return(XML_ENC_ERR_INTERNAL);
-    if (in == NULL) {
-        /*
-	 * initialization nothing to do
-	 */
-	*outlen = 0;
-	*inlen = 0;
-	return(0);
-    }
-    inend = in + (*inlen);
-    outend = out + (*outlen);
-    while (in < inend) {
-	d = *in++;
-	if      (d < 0x80)  { c= d; trailing= 0; }
-	else if (d < 0xC0) {
-	    /* trailing byte in leading position */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
-	else {
-	    /* no chance for this in Ascii */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-	}
+static int
+UTF8ToLatin1(unsigned char* outb, int *outlen,
+             const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF8ToUTF16(unsigned char* outb, int *outlen,
+            const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF8ToUTF16LE(unsigned char* outb, int *outlen,
+              const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF8ToUTF16BE(unsigned char* outb, int *outlen,
+              const unsigned char* in, int *inlen, void *vctxt);
 
-	if (inend - in < trailing) {
-	    break;
-	}
+#else /* LIBXML_OUTPUT_ENABLED */
 
-	for ( ; trailing; trailing--) {
-	    if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))
-		break;
-	    c <<= 6;
-	    c |= d & 0x3F;
-	}
+#define UTF8ToLatin1 NULL
+#define UTF8ToUTF16 NULL
+#define UTF8ToUTF16LE NULL
+#define UTF8ToUTF16BE NULL
 
-	/* assertion: c is a single UTF-4 value */
-	if (c < 0x80) {
-	    if (out >= outend)
-		break;
-	    *out++ = c;
-	} else {
-	    /* no chance for this in Ascii */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-	}
-	processed = in;
-    }
-    *outlen = out - outstart;
-    *inlen = processed - instart;
-    return(*outlen);
-}
 #endif /* LIBXML_OUTPUT_ENABLED */
 
-/**
- * isolat1ToUTF8:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of ISO Latin 1 chars
- * @inlen:  the length of @in
- *
- * Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets produced.
- */
-int
-isolat1ToUTF8(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen) {
-    unsigned char* outstart = out;
-    const unsigned char* base = in;
-    unsigned char* outend;
-    const unsigned char* inend;
-    const unsigned char* instop;
+#if defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTML_ENABLED)
+static int
+UTF8ToHtmlWrapper(unsigned char *out, int *outlen,
+                  const unsigned char *in, int *inlen, void *vctxt);
+#else
+#define UTF8ToHtmlWrapper NULL
+#endif
 
-    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
-	return(XML_ENC_ERR_INTERNAL);
+#ifdef LIBXML_ICONV_ENABLED
+  #define EMPTY_ICONV , (iconv_t) 0, (iconv_t) 0
+#else
+  #define EMPTY_ICONV
+#endif
 
-    outend = out + *outlen;
-    inend = in + (*inlen);
-    instop = inend;
-
-    while ((in < inend) && (out < outend - 1)) {
-	if (*in >= 0x80) {
-	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
-            *out++ = ((*in) & 0x3F) | 0x80;
-	    ++in;
-	}
-	if ((instop - in) > (outend - out)) instop = in + (outend - out);
-	while ((in < instop) && (*in < 0x80)) {
-	    *out++ = *in++;
-	}
-    }
-    if ((in < inend) && (out < outend) && (*in < 0x80)) {
-        *out++ = *in++;
-    }
-    *outlen = out - outstart;
-    *inlen = in - base;
-    return(*outlen);
-}
+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \
+    defined(LIBXML_ISO8859X_ENABLED)
+
+#include "iso8859x.inc"
 
-/**
- * UTF8ToUTF8:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @inb:  a pointer to an array of UTF-8 chars
- * @inlenb:  the length of @in in UTF-8 chars
- *
- * No op copy operation for UTF8 handling.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- *     The value of *inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- */
 static int
-UTF8ToUTF8(unsigned char* out, int *outlen,
-           const unsigned char* inb, int *inlenb)
-{
-    int len;
+ISO8859xToUTF8(unsigned char* out, int *outlen,
+               const unsigned char* in, int *inlen, void *vctxt);
+static int
+UTF8ToISO8859x(unsigned char *out, int *outlen,
+               const unsigned char *in, int *inlen, void *vctxt);
 
-    if ((out == NULL) || (outlen == NULL) || (inlenb == NULL))
-	return(XML_ENC_ERR_INTERNAL);
-    if (inb == NULL) {
-        /* inb == NULL means output is initialized. */
-        *outlen = 0;
-        *inlenb = 0;
-        return(0);
-    }
-    if (*outlen > *inlenb) {
-	len = *inlenb;
-    } else {
-	len = *outlen;
-    }
-    if (len < 0)
-	return(XML_ENC_ERR_INTERNAL);
+#define MAKE_ISO_HANDLER(name, n) \
+    { (char *) name, \
+      (xmlCharEncodingInputFunc) (void (*)(void)) ISO8859xToUTF8, \
+      (xmlCharEncodingInputFunc) (void (*)(void)) UTF8ToISO8859x \
+      EMPTY_ICONV, \
+      (void *) xmlunicodetable_ISO8859_##n, \
+      (void *) xmltranscodetable_ISO8859_##n, \
+      NULL, XML_HANDLER_STATIC }
 
-    /*
-     * FIXME: Conversion functions must assure valid UTF-8, so we have
-     * to check for UTF-8 validity. Preferably, this converter shouldn't
-     * be used at all.
-     */
-    memcpy(out, inb, len);
+#else /* LIBXML_ISO8859X_ENABLED */
 
-    *outlen = len;
-    *inlenb = len;
-    return(*outlen);
-}
+#define MAKE_ISO_HANDLER(name, n) \
+    { (char *) name, NULL, NULL EMPTY_ICONV, NULL, NULL, NULL, \
+      XML_HANDLER_STATIC }
 
+#endif /* LIBXML_ISO8859X_ENABLED */
 
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * UTF8Toisolat1:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
+#define MAKE_HANDLER(name, in, out) \
+    { (char *) name, \
+      (xmlCharEncodingInputFunc) (void (*)(void)) in, \
+      (xmlCharEncodingOutputFunc) (void (*)(void)) out \
+      EMPTY_ICONV, NULL, NULL, NULL, XML_HANDLER_STATIC }
+
+/*
+ * The layout must match enum xmlCharEncoding.
  *
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets produced.
+ * Names should match the IANA registry if possible:
+ * https://www.iana.org/assignments/character-sets/character-sets.xhtml
  */
-int
-UTF8Toisolat1(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen) {
-    const unsigned char* processed = in;
-    const unsigned char* outend;
-    const unsigned char* outstart = out;
-    const unsigned char* instart = in;
-    const unsigned char* inend;
-    unsigned int c, d;
-    int trailing;
+static const xmlCharEncodingHandler defaultHandlers[31] = {
+    MAKE_HANDLER(NULL, NULL, NULL), /* NONE */
+    MAKE_HANDLER("UTF-8", UTF8ToUTF8, UTF8ToUTF8),
+    MAKE_HANDLER("UTF-16LE", UTF16LEToUTF8, UTF8ToUTF16LE),
+    MAKE_HANDLER("UTF-16BE", UTF16BEToUTF8, UTF8ToUTF16BE),
+    MAKE_HANDLER("UCS-4LE", NULL, NULL),
+    MAKE_HANDLER("UCS-4BE", NULL, NULL),
+    MAKE_HANDLER("IBM037", NULL, NULL),
+    MAKE_HANDLER("ISO-10646-UCS-4", NULL, NULL), /* UCS4_2143 */
+    MAKE_HANDLER("ISO-10646-UCS-4", NULL, NULL), /* UCS4_2143 */
+    MAKE_HANDLER("ISO-10646-UCS-2", NULL, NULL),
+    MAKE_HANDLER("ISO-8859-1", latin1ToUTF8, UTF8ToLatin1),
+    MAKE_ISO_HANDLER("ISO-8859-2", 2),
+    MAKE_ISO_HANDLER("ISO-8859-3", 3),
+    MAKE_ISO_HANDLER("ISO-8859-4", 4),
+    MAKE_ISO_HANDLER("ISO-8859-5", 5),
+    MAKE_ISO_HANDLER("ISO-8859-6", 6),
+    MAKE_ISO_HANDLER("ISO-8859-7", 7),
+    MAKE_ISO_HANDLER("ISO-8859-8", 8),
+    MAKE_ISO_HANDLER("ISO-8859-9", 9),
+    MAKE_HANDLER("ISO-2022-JP", NULL, NULL),
+    MAKE_HANDLER("Shift_JIS", NULL, NULL),
+    MAKE_HANDLER("EUC-JP", NULL, NULL),
+    MAKE_HANDLER("US-ASCII", asciiToAscii, asciiToAscii),
+    MAKE_HANDLER("UTF-16", UTF16LEToUTF8, UTF8ToUTF16),
+    MAKE_HANDLER("HTML", NULL, UTF8ToHtmlWrapper),
+    MAKE_ISO_HANDLER("ISO-8859-10", 10),
+    MAKE_ISO_HANDLER("ISO-8859-11", 11),
+    MAKE_ISO_HANDLER("ISO-8859-13", 13),
+    MAKE_ISO_HANDLER("ISO-8859-14", 14),
+    MAKE_ISO_HANDLER("ISO-8859-15", 15),
+    MAKE_ISO_HANDLER("ISO-8859-16", 16),
+};
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
-        return(XML_ENC_ERR_INTERNAL);
-    if (in == NULL) {
-        /*
-	 * initialization nothing to do
-	 */
-	*outlen = 0;
-	*inlen = 0;
-	return(0);
-    }
-    inend = in + (*inlen);
-    outend = out + (*outlen);
-    while (in < inend) {
-	d = *in++;
-	if      (d < 0x80)  { c= d; trailing= 0; }
-	else if (d < 0xC0) {
-	    /* trailing byte in leading position */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
-	else {
-	    /* no chance for this in IsoLat1 */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-	}
+#define NUM_DEFAULT_HANDLERS \
+    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
 
-	if (inend - in < trailing) {
-	    break;
-	}
+/* the size should be growable, but it's not a big deal ... */
+#define MAX_ENCODING_HANDLERS 50
+static xmlCharEncodingHandlerPtr *globalHandlers = NULL;
+static int nbCharEncodingHandler = 0;
 
-	for ( ; trailing; trailing--) {
-	    if (in >= inend)
-		break;
-	    if (((d= *in++) & 0xC0) != 0x80) {
-		*outlen = out - outstart;
-		*inlen = processed - instart;
-		return(XML_ENC_ERR_INPUT);
-	    }
-	    c <<= 6;
-	    c |= d & 0x3F;
-	}
+#ifdef LIBXML_ICONV_ENABLED
+static int
+xmlCharEncIconv(void *vctxt, const char *name, xmlCharEncConverter *conv);
+#endif
 
-	/* assertion: c is a single UTF-4 value */
-	if (c <= 0xFF) {
-	    if (out >= outend)
-		break;
-	    *out++ = c;
-	} else {
-	    /* no chance for this in IsoLat1 */
-	    *outlen = out - outstart;
-	    *inlen = processed - instart;
-	    return(XML_ENC_ERR_INPUT);
-	}
-	processed = in;
-    }
-    *outlen = out - outstart;
-    *inlen = processed - instart;
-    return(*outlen);
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
+#ifdef LIBXML_ICU_ENABLED
+static int
+xmlCharEncUconv(void *vctxt, const char *name, xmlCharEncConverter *conv);
+#endif
+
+/************************************************************************
+ *									*
+ *		Generic encoding handling routines			*
+ *									*
+ ************************************************************************/
 
 /**
- * UTF16LEToUTF8:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @inb:  a pointer to an array of UTF-16LE passwd as a byte array
- * @inlenb:  the length of @in in UTF-16LE chars
- *
- * Take a block of UTF-16LE ushorts in and try to convert it to an UTF-8
- * block of chars out. This function assumes the endian property
- * is the same between the native type of this machine and the
- * inputed one.
+ * xmlDetectCharEncoding:
+ * @in:  a pointer to the first bytes of the XML entity, must be at least
+ *       2 bytes long (at least 4 if encoding is UTF4 variant).
+ * @len:  pointer to the length of the buffer
  *
- * Returns the number of bytes written or an XML_ENC_ERR code.
+ * Guess the encoding of the entity using the first bytes of the entity content
+ * according to the non-normative appendix F of the XML-1.0 recommendation.
  *
- * The value of *inlen after return is the number of octets consumed
- * if the return value is positive, else unpredictable.
+ * Returns one of the XML_CHAR_ENCODING_... values.
  */
-static int
-UTF16LEToUTF8(unsigned char* out, int *outlen,
-            const unsigned char* inb, int *inlenb)
-{
-    unsigned char* outstart = out;
-    const unsigned char* processed = inb;
-    unsigned char* outend;
-    unsigned short* in = (unsigned short *) (void *) inb;
-    unsigned short* inend;
-    unsigned int c, d, inlen;
-    unsigned char *tmp;
-    int bits;
-
-    if (*outlen == 0) {
-        *inlenb = 0;
-        return(0);
-    }
-    outend = out + *outlen;
-    if ((*inlenb % 2) == 1)
-        (*inlenb)--;
-    inlen = *inlenb / 2;
-    inend = in + inlen;
-    while ((in < inend) && (out - outstart + 5 < *outlen)) {
-        if (xmlLittleEndian) {
-	    c= *in++;
-	} else {
-	    tmp = (unsigned char *) in;
-	    c = *tmp++;
-	    c = c | (*tmp << 8);
-	    in++;
-	}
-        if ((c & 0xFC00) == 0xD800) {    /* surrogates */
-	    if (in >= inend) {           /* handle split mutli-byte characters */
-		break;
-	    }
-	    if (xmlLittleEndian) {
-		d = *in++;
-	    } else {
-		tmp = (unsigned char *) in;
-		d = *tmp++;
-		d = d | (*tmp << 8);
-		in++;
-	    }
-            if ((d & 0xFC00) == 0xDC00) {
-                c &= 0x03FF;
-                c <<= 10;
-                c |= d & 0x03FF;
-                c += 0x10000;
-            }
-            else {
-		*outlen = out - outstart;
-		*inlenb = processed - inb;
-	        return(XML_ENC_ERR_INPUT);
-	    }
-        }
-
-	/* assertion: c is a single UTF-4 value */
-        if (out >= outend)
-	    break;
-        if      (c <    0x80) {  *out++=  c;                bits= -6; }
-        else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
-        else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
-        else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }
-
-        for ( ; bits >= 0; bits-= 6) {
-            if (out >= outend)
-	        break;
-            *out++= ((c >> bits) & 0x3F) | 0x80;
-        }
-	processed = (const unsigned char*) in;
-    }
-    *outlen = out - outstart;
-    *inlenb = processed - inb;
-    return(*outlen);
-}
-
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * UTF8ToUTF16LE:
- * @outb:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @outb
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and try to convert it to an UTF-16LE
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- */
-static int
-UTF8ToUTF16LE(unsigned char* outb, int *outlen,
-            const unsigned char* in, int *inlen)
-{
-    unsigned short* out = (unsigned short *) (void *) outb;
-    const unsigned char* processed = in;
-    const unsigned char *const instart = in;
-    unsigned short* outstart= out;
-    unsigned short* outend;
-    const unsigned char* inend;
-    unsigned int c, d;
-    int trailing;
-    unsigned char *tmp;
-    unsigned short tmp1, tmp2;
-
-    /* UTF16LE encoding has no BOM */
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
-        return(XML_ENC_ERR_INTERNAL);
-    if (in == NULL) {
-	*outlen = 0;
-	*inlen = 0;
-	return(0);
-    }
-    inend= in + *inlen;
-    outend = out + (*outlen / 2);
-    while (in < inend) {
-      d= *in++;
-      if      (d < 0x80)  { c= d; trailing= 0; }
-      else if (d < 0xC0) {
-          /* trailing byte in leading position */
-	  *outlen = (out - outstart) * 2;
-	  *inlen = processed - instart;
-	  return(XML_ENC_ERR_INPUT);
-      } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
-      else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
-      else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
-      else {
-	/* no chance for this in UTF-16 */
-	*outlen = (out - outstart) * 2;
-	*inlen = processed - instart;
-	return(XML_ENC_ERR_INPUT);
-      }
-
-      if (inend - in < trailing) {
-          break;
-      }
-
-      for ( ; trailing; trailing--) {
-          if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))
-	      break;
-          c <<= 6;
-          c |= d & 0x3F;
-      }
-
-      /* assertion: c is a single UTF-4 value */
-        if (c < 0x10000) {
-            if (out >= outend)
-	        break;
-	    if (xmlLittleEndian) {
-		*out++ = c;
-	    } else {
-		tmp = (unsigned char *) out;
-		*tmp = (unsigned char) c; /* Explicit truncation */
-		*(tmp + 1) = c >> 8 ;
-		out++;
-	    }
-        }
-        else if (c < 0x110000) {
-            if (out+1 >= outend)
-	        break;
-            c -= 0x10000;
-	    if (xmlLittleEndian) {
-		*out++ = 0xD800 | (c >> 10);
-		*out++ = 0xDC00 | (c & 0x03FF);
-	    } else {
-		tmp1 = 0xD800 | (c >> 10);
-		tmp = (unsigned char *) out;
-		*tmp = (unsigned char) tmp1; /* Explicit truncation */
-		*(tmp + 1) = tmp1 >> 8;
-		out++;
-
-		tmp2 = 0xDC00 | (c & 0x03FF);
-		tmp = (unsigned char *) out;
-		*tmp  = (unsigned char) tmp2; /* Explicit truncation */
-		*(tmp + 1) = tmp2 >> 8;
-		out++;
-	    }
-        }
-        else
-	    break;
-	processed = in;
-    }
-    *outlen = (out - outstart) * 2;
-    *inlen = processed - instart;
-    return(*outlen);
-}
-
-/**
- * UTF8ToUTF16:
- * @outb:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @outb
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and try to convert it to an UTF-16
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- */
-static int
-UTF8ToUTF16(unsigned char* outb, int *outlen,
-            const unsigned char* in, int *inlen)
-{
-    if (in == NULL) {
-	/*
-	 * initialization, add the Byte Order Mark for UTF-16LE
-	 */
-        if (*outlen >= 2) {
-	    outb[0] = 0xFF;
-	    outb[1] = 0xFE;
-	    *outlen = 2;
-	    *inlen = 0;
-	    return(2);
-	}
-	*outlen = 0;
-	*inlen = 0;
-	return(0);
-    }
-    return (UTF8ToUTF16LE(outb, outlen, in, inlen));
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-/**
- * UTF16BEToUTF8:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @inb:  a pointer to an array of UTF-16 passed as a byte array
- * @inlenb:  the length of @in in UTF-16 chars
- *
- * Take a block of UTF-16 ushorts in and try to convert it to an UTF-8
- * block of chars out. This function assumes the endian property
- * is the same between the native type of this machine and the
- * inputed one.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of *inlen after return is the number of octets consumed
- * if the return value is positive, else unpredictable.
- */
-static int
-UTF16BEToUTF8(unsigned char* out, int *outlen,
-            const unsigned char* inb, int *inlenb)
-{
-    unsigned char* outstart = out;
-    const unsigned char* processed = inb;
-    unsigned char* outend;
-    unsigned short* in = (unsigned short *) (void *) inb;
-    unsigned short* inend;
-    unsigned int c, d, inlen;
-    unsigned char *tmp;
-    int bits;
-
-    if (*outlen == 0) {
-        *inlenb = 0;
-        return(0);
-    }
-    outend = out + *outlen;
-    if ((*inlenb % 2) == 1)
-        (*inlenb)--;
-    inlen = *inlenb / 2;
-    inend= in + inlen;
-    while ((in < inend) && (out - outstart + 5 < *outlen)) {
-	if (xmlLittleEndian) {
-	    tmp = (unsigned char *) in;
-	    c = *tmp++;
-	    c = (c << 8) | *tmp;
-	    in++;
-	} else {
-	    c= *in++;
-	}
-        if ((c & 0xFC00) == 0xD800) {    /* surrogates */
-	    if (in >= inend) {           /* handle split mutli-byte characters */
-                break;
-	    }
-	    if (xmlLittleEndian) {
-		tmp = (unsigned char *) in;
-		d = *tmp++;
-		d = (d << 8) | *tmp;
-		in++;
-	    } else {
-		d= *in++;
-	    }
-            if ((d & 0xFC00) == 0xDC00) {
-                c &= 0x03FF;
-                c <<= 10;
-                c |= d & 0x03FF;
-                c += 0x10000;
-            }
-            else {
-		*outlen = out - outstart;
-		*inlenb = processed - inb;
-	        return(XML_ENC_ERR_INPUT);
-	    }
-        }
-
-	/* assertion: c is a single UTF-4 value */
-        if (out >= outend)
-	    break;
-        if      (c <    0x80) {  *out++=  c;                bits= -6; }
-        else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }
-        else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }
-        else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }
-
-        for ( ; bits >= 0; bits-= 6) {
-            if (out >= outend)
-	        break;
-            *out++= ((c >> bits) & 0x3F) | 0x80;
-        }
-	processed = (const unsigned char*) in;
-    }
-    *outlen = out - outstart;
-    *inlenb = processed - inb;
-    return(*outlen);
-}
-
-#ifdef LIBXML_OUTPUT_ENABLED
-/**
- * UTF8ToUTF16BE:
- * @outb:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @outb
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and try to convert it to an UTF-16BE
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- */
-static int
-UTF8ToUTF16BE(unsigned char* outb, int *outlen,
-            const unsigned char* in, int *inlen)
-{
-    unsigned short* out = (unsigned short *) (void *) outb;
-    const unsigned char* processed = in;
-    const unsigned char *const instart = in;
-    unsigned short* outstart= out;
-    unsigned short* outend;
-    const unsigned char* inend;
-    unsigned int c, d;
-    int trailing;
-    unsigned char *tmp;
-    unsigned short tmp1, tmp2;
-
-    /* UTF-16BE has no BOM */
-    if ((outb == NULL) || (outlen == NULL) || (inlen == NULL))
-        return(XML_ENC_ERR_INTERNAL);
-    if (in == NULL) {
-	*outlen = 0;
-	*inlen = 0;
-	return(0);
-    }
-    inend= in + *inlen;
-    outend = out + (*outlen / 2);
-    while (in < inend) {
-      d= *in++;
-      if      (d < 0x80)  { c= d; trailing= 0; }
-      else if (d < 0xC0)  {
-          /* trailing byte in leading position */
-	  *outlen = out - outstart;
-	  *inlen = processed - instart;
-	  return(XML_ENC_ERR_INPUT);
-      } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
-      else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
-      else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
-      else {
-          /* no chance for this in UTF-16 */
-	  *outlen = out - outstart;
-	  *inlen = processed - instart;
-	  return(XML_ENC_ERR_INPUT);
-      }
-
-      if (inend - in < trailing) {
-          break;
-      }
-
-      for ( ; trailing; trailing--) {
-          if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))  break;
-          c <<= 6;
-          c |= d & 0x3F;
-      }
-
-      /* assertion: c is a single UTF-4 value */
-        if (c < 0x10000) {
-            if (out >= outend)  break;
-	    if (xmlLittleEndian) {
-		tmp = (unsigned char *) out;
-		*tmp = c >> 8;
-		*(tmp + 1) = (unsigned char) c; /* Explicit truncation */
-		out++;
-	    } else {
-		*out++ = c;
-	    }
-        }
-        else if (c < 0x110000) {
-            if (out+1 >= outend)  break;
-            c -= 0x10000;
-	    if (xmlLittleEndian) {
-		tmp1 = 0xD800 | (c >> 10);
-		tmp = (unsigned char *) out;
-		*tmp = tmp1 >> 8;
-		*(tmp + 1) = (unsigned char) tmp1; /* Explicit truncation */
-		out++;
-
-		tmp2 = 0xDC00 | (c & 0x03FF);
-		tmp = (unsigned char *) out;
-		*tmp = tmp2 >> 8;
-		*(tmp + 1) = (unsigned char) tmp2; /* Explicit truncation */
-		out++;
-	    } else {
-		*out++ = 0xD800 | (c >> 10);
-		*out++ = 0xDC00 | (c & 0x03FF);
-	    }
-        }
-        else
-	    break;
-	processed = in;
-    }
-    *outlen = (out - outstart) * 2;
-    *inlen = processed - instart;
-    return(*outlen);
-}
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-/************************************************************************
- *									*
- *		Generic encoding handling routines			*
- *									*
- ************************************************************************/
-
-/**
- * xmlDetectCharEncoding:
- * @in:  a pointer to the first bytes of the XML entity, must be at least
- *       2 bytes long (at least 4 if encoding is UTF4 variant).
- * @len:  pointer to the length of the buffer
- *
- * Guess the encoding of the entity using the first bytes of the entity content
- * according to the non-normative appendix F of the XML-1.0 recommendation.
- *
- * Returns one of the XML_CHAR_ENCODING_... values.
- */
-xmlCharEncoding
-xmlDetectCharEncoding(const unsigned char* in, int len)
+xmlCharEncoding
+xmlDetectCharEncoding(const unsigned char* in, int len)
 {
     if (in == NULL)
         return(XML_CHAR_ENCODING_NONE);
@@ -919,6 +332,9 @@ xmlDetectCharEncoding(const unsigned char* in, int len)
 /**
  * xmlCleanupEncodingAliases:
  *
+ * DEPRECATED: This function modifies global state and is not
+ * thread-safe.
+ *
  * Unregisters all aliases
  */
 void
@@ -944,6 +360,8 @@ xmlCleanupEncodingAliases(void) {
  * xmlGetEncodingAlias:
  * @alias:  the alias name as parsed, in UTF-8 format (ASCII actually)
  *
+ * DEPRECATED: This function is not thread-safe.
+ *
  * Lookup an encoding name for the given alias.
  *
  * Returns NULL if not found, otherwise the original name
@@ -981,6 +399,9 @@ xmlGetEncodingAlias(const char *alias) {
  * @name:  the encoding name as parsed, in UTF-8 format (ASCII actually)
  * @alias:  the alias name as parsed, in UTF-8 format (ASCII actually)
  *
+ * DEPRECATED: This function modifies global state and is not
+ * thread-safe.
+ *
  * Registers an alias @alias for an encoding named @name. Existing alias
  * will be overwritten.
  *
@@ -1053,6 +474,9 @@ xmlAddEncodingAlias(const char *name, const char *alias) {
  * xmlDelEncodingAlias:
  * @alias:  the alias name as parsed, in UTF-8 format (ASCII actually)
  *
+ * DEPRECATED: This function modifies global state and is not
+ * thread-safe.
+ *
  * Unregisters an encoding alias @alias
  *
  * Returns 0 in case of success, -1 in case of error
@@ -1082,6 +506,31 @@ xmlDelEncodingAlias(const char *alias) {
     return(-1);
 }
 
+static int
+xmlCompareEncTableEntries(const void *vkey, const void *ventry) {
+    const char *key = vkey;
+    const xmlEncTableEntry *entry = ventry;
+
+    return(xmlStrcasecmp(BAD_CAST key, BAD_CAST entry->name));
+}
+
+static xmlCharEncoding
+xmlParseCharEncodingInternal(const char *name)
+{
+    const xmlEncTableEntry *entry;
+
+    if (name == NULL)
+       return(XML_CHAR_ENCODING_NONE);
+
+    entry = bsearch(name, xmlEncTable,
+                    sizeof(xmlEncTable) / sizeof(xmlEncTable[0]),
+                    sizeof(xmlEncTable[0]), xmlCompareEncTableEntries);
+    if (entry != NULL)
+        return(entry->enc);
+
+    return(XML_CHAR_ENCODING_ERROR);
+}
+
 /**
  * xmlParseCharEncoding:
  * @name:  the encoding name as parsed, in UTF-8 format (ASCII actually)
@@ -1094,73 +543,15 @@ xmlDelEncodingAlias(const char *alias) {
  * if not recognized.
  */
 xmlCharEncoding
-xmlParseCharEncoding(const char* name)
+xmlParseCharEncoding(const char *name)
 {
-    const char *alias;
-    char upper[500];
-    int i;
-
-    if (name == NULL)
-	return(XML_CHAR_ENCODING_NONE);
-
-    /*
-     * Do the alias resolution
-     */
-    alias = xmlGetEncodingAlias(name);
-    if (alias != NULL)
-	name = alias;
-
-    for (i = 0;i < 499;i++) {
-        upper[i] = (char) toupper((unsigned char) name[i]);
-	if (upper[i] == 0) break;
-    }
-    upper[i] = 0;
-
-    if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);
-    if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);
-    if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);
-
-    /*
-     * NOTE: if we were able to parse this, the endianness of UTF16 is
-     *       already found and in use
-     */
-    if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);
-    if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);
-
-    if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);
-    if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);
-    if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);
-
-    /*
-     * NOTE: if we were able to parse this, the endianness of UCS4 is
-     *       already found and in use
-     */
-    if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
-    if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
-    if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);
-
-
-    if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);
-    if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);
-    if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);
+    xmlCharEncoding enc = xmlParseCharEncodingInternal(name);
 
-    if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);
-    if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);
-    if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);
+    /* Backward compatibility */
+    if (enc == XML_CHAR_ENCODING_UTF16)
+        enc = XML_CHAR_ENCODING_UTF16LE;
 
-    if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);
-    if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);
-    if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);
-    if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);
-    if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);
-    if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);
-    if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);
-
-    if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);
-    if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);
-    if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);
-
-    return(XML_CHAR_ENCODING_ERROR);
+    return(enc);
 }
 
 /**
@@ -1173,60 +564,25 @@ xmlParseCharEncoding(const char* name)
  *
  * Returns the canonical name for the given encoding
  */
-
 const char*
 xmlGetCharEncodingName(xmlCharEncoding enc) {
     switch (enc) {
-        case XML_CHAR_ENCODING_ERROR:
-	    return(NULL);
-        case XML_CHAR_ENCODING_NONE:
-	    return(NULL);
-        case XML_CHAR_ENCODING_UTF8:
-	    return("UTF-8");
         case XML_CHAR_ENCODING_UTF16LE:
 	    return("UTF-16");
         case XML_CHAR_ENCODING_UTF16BE:
 	    return("UTF-16");
-        case XML_CHAR_ENCODING_EBCDIC:
-            return("EBCDIC");
         case XML_CHAR_ENCODING_UCS4LE:
             return("ISO-10646-UCS-4");
         case XML_CHAR_ENCODING_UCS4BE:
             return("ISO-10646-UCS-4");
-        case XML_CHAR_ENCODING_UCS4_2143:
-            return("ISO-10646-UCS-4");
-        case XML_CHAR_ENCODING_UCS4_3412:
-            return("ISO-10646-UCS-4");
-        case XML_CHAR_ENCODING_UCS2:
-            return("ISO-10646-UCS-2");
-        case XML_CHAR_ENCODING_8859_1:
-	    return("ISO-8859-1");
-        case XML_CHAR_ENCODING_8859_2:
-	    return("ISO-8859-2");
-        case XML_CHAR_ENCODING_8859_3:
-	    return("ISO-8859-3");
-        case XML_CHAR_ENCODING_8859_4:
-	    return("ISO-8859-4");
-        case XML_CHAR_ENCODING_8859_5:
-	    return("ISO-8859-5");
-        case XML_CHAR_ENCODING_8859_6:
-	    return("ISO-8859-6");
-        case XML_CHAR_ENCODING_8859_7:
-	    return("ISO-8859-7");
-        case XML_CHAR_ENCODING_8859_8:
-	    return("ISO-8859-8");
-        case XML_CHAR_ENCODING_8859_9:
-	    return("ISO-8859-9");
-        case XML_CHAR_ENCODING_2022_JP:
-            return("ISO-2022-JP");
-        case XML_CHAR_ENCODING_SHIFT_JIS:
-            return("Shift-JIS");
-        case XML_CHAR_ENCODING_EUC_JP:
-            return("EUC-JP");
-	case XML_CHAR_ENCODING_ASCII:
-	    return(NULL);
+        default:
+            break;
     }
-    return(NULL);
+
+    if ((enc <= 0) || ((size_t) enc >= NUM_DEFAULT_HANDLERS))
+        return(NULL);
+
+    return(defaultHandlers[enc].name);
 }
 
 /************************************************************************
@@ -1235,108 +591,15 @@ xmlGetCharEncodingName(xmlCharEncoding enc) {
  *									*
  ************************************************************************/
 
-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \
-    defined(LIBXML_ISO8859X_ENABLED)
-
-#define DECLARE_ISO_FUNCS(n) \
-    static int ISO8859_##n##ToUTF8(unsigned char* out, int *outlen, \
-                                   const unsigned char* in, int *inlen); \
-    static int UTF8ToISO8859_##n(unsigned char* out, int *outlen, \
-                                 const unsigned char* in, int *inlen);
-
-/** DOC_DISABLE */
-DECLARE_ISO_FUNCS(2)
-DECLARE_ISO_FUNCS(3)
-DECLARE_ISO_FUNCS(4)
-DECLARE_ISO_FUNCS(5)
-DECLARE_ISO_FUNCS(6)
-DECLARE_ISO_FUNCS(7)
-DECLARE_ISO_FUNCS(8)
-DECLARE_ISO_FUNCS(9)
-DECLARE_ISO_FUNCS(10)
-DECLARE_ISO_FUNCS(11)
-DECLARE_ISO_FUNCS(13)
-DECLARE_ISO_FUNCS(14)
-DECLARE_ISO_FUNCS(15)
-DECLARE_ISO_FUNCS(16)
-/** DOC_ENABLE */
-
-#endif /* LIBXML_ISO8859X_ENABLED */
-
-#ifdef LIBXML_ICONV_ENABLED
-  #define EMPTY_ICONV , (iconv_t) 0, (iconv_t) 0
-#else
-  #define EMPTY_ICONV
-#endif
-
-#ifdef LIBXML_ICU_ENABLED
-  #define EMPTY_UCONV , NULL, NULL
-#else
-  #define EMPTY_UCONV
-#endif
-
-#define MAKE_HANDLER(name, in, out) \
-    { (char *) name, in, out EMPTY_ICONV EMPTY_UCONV }
-
-static const xmlCharEncodingHandler defaultHandlers[] = {
-    MAKE_HANDLER("UTF-8", UTF8ToUTF8, UTF8ToUTF8)
-#ifdef LIBXML_OUTPUT_ENABLED
-    ,MAKE_HANDLER("UTF-16LE", UTF16LEToUTF8, UTF8ToUTF16LE)
-    ,MAKE_HANDLER("UTF-16BE", UTF16BEToUTF8, UTF8ToUTF16BE)
-    ,MAKE_HANDLER("UTF-16", UTF16LEToUTF8, UTF8ToUTF16)
-    ,MAKE_HANDLER("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1)
-    ,MAKE_HANDLER("ASCII", asciiToUTF8, UTF8Toascii)
-    ,MAKE_HANDLER("US-ASCII", asciiToUTF8, UTF8Toascii)
-#ifdef LIBXML_HTML_ENABLED
-    ,MAKE_HANDLER("HTML", NULL, UTF8ToHtml)
-#endif
-#else
-    ,MAKE_HANDLER("UTF-16LE", UTF16LEToUTF8, NULL)
-    ,MAKE_HANDLER("UTF-16BE", UTF16BEToUTF8, NULL)
-    ,MAKE_HANDLER("UTF-16", UTF16LEToUTF8, NULL)
-    ,MAKE_HANDLER("ISO-8859-1", isolat1ToUTF8, NULL)
-    ,MAKE_HANDLER("ASCII", asciiToUTF8, NULL)
-    ,MAKE_HANDLER("US-ASCII", asciiToUTF8, NULL)
-#endif /* LIBXML_OUTPUT_ENABLED */
-
-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \
-    defined(LIBXML_ISO8859X_ENABLED)
-    ,MAKE_HANDLER("ISO-8859-2", ISO8859_2ToUTF8, UTF8ToISO8859_2)
-    ,MAKE_HANDLER("ISO-8859-3", ISO8859_3ToUTF8, UTF8ToISO8859_3)
-    ,MAKE_HANDLER("ISO-8859-4", ISO8859_4ToUTF8, UTF8ToISO8859_4)
-    ,MAKE_HANDLER("ISO-8859-5", ISO8859_5ToUTF8, UTF8ToISO8859_5)
-    ,MAKE_HANDLER("ISO-8859-6", ISO8859_6ToUTF8, UTF8ToISO8859_6)
-    ,MAKE_HANDLER("ISO-8859-7", ISO8859_7ToUTF8, UTF8ToISO8859_7)
-    ,MAKE_HANDLER("ISO-8859-8", ISO8859_8ToUTF8, UTF8ToISO8859_8)
-    ,MAKE_HANDLER("ISO-8859-9", ISO8859_9ToUTF8, UTF8ToISO8859_9)
-    ,MAKE_HANDLER("ISO-8859-10", ISO8859_10ToUTF8, UTF8ToISO8859_10)
-    ,MAKE_HANDLER("ISO-8859-11", ISO8859_11ToUTF8, UTF8ToISO8859_11)
-    ,MAKE_HANDLER("ISO-8859-13", ISO8859_13ToUTF8, UTF8ToISO8859_13)
-    ,MAKE_HANDLER("ISO-8859-14", ISO8859_14ToUTF8, UTF8ToISO8859_14)
-    ,MAKE_HANDLER("ISO-8859-15", ISO8859_15ToUTF8, UTF8ToISO8859_15)
-    ,MAKE_HANDLER("ISO-8859-16", ISO8859_16ToUTF8, UTF8ToISO8859_16)
-#endif
-};
-
-#define NUM_DEFAULT_HANDLERS \
-    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
-
-static const xmlCharEncodingHandler *xmlUTF16LEHandler = &defaultHandlers[1];
-static const xmlCharEncodingHandler *xmlUTF16BEHandler = &defaultHandlers[2];
-static const xmlCharEncodingHandler *xmlLatin1Handler = &defaultHandlers[4];
-static const xmlCharEncodingHandler *xmlAsciiHandler = &defaultHandlers[5];
-
-/* the size should be growable, but it's not a big deal ... */
-#define MAX_ENCODING_HANDLERS 50
-static xmlCharEncodingHandlerPtr *handlers = NULL;
-static int nbCharEncodingHandler = 0;
-
 /**
  * xmlNewCharEncodingHandler:
  * @name:  the encoding name, in UTF-8 format (ASCII actually)
  * @input:  the xmlCharEncodingInputFunc to read that encoding
  * @output:  the xmlCharEncodingOutputFunc to write that encoding
  *
+ * DEPRECATED: This function modifies global state and is not
+ * thread-safe.
+ *
  * Create and registers an xmlCharEncodingHandler.
  *
  * Returns the xmlCharEncodingHandlerPtr created (or NULL in case of error).
@@ -1385,15 +648,12 @@ xmlNewCharEncodingHandler(const char *name,
     handler->input = input;
     handler->output = output;
     handler->name = up;
+    handler->flags = XML_HANDLER_STATIC;
 
 #ifdef LIBXML_ICONV_ENABLED
     handler->iconv_in = NULL;
     handler->iconv_out = NULL;
 #endif
-#ifdef LIBXML_ICU_ENABLED
-    handler->uconv_in = NULL;
-    handler->uconv_out = NULL;
-#endif
 
     /*
      * registers and returns the handler.
@@ -1441,18 +701,21 @@ void
 xmlCleanupCharEncodingHandlers(void) {
     xmlCleanupEncodingAliases();
 
-    if (handlers == NULL) return;
+    if (globalHandlers == NULL) return;
 
     for (;nbCharEncodingHandler > 0;) {
+        xmlCharEncodingHandler *handler;
+
         nbCharEncodingHandler--;
-	if (handlers[nbCharEncodingHandler] != NULL) {
-	    if (handlers[nbCharEncodingHandler]->name != NULL)
-		xmlFree(handlers[nbCharEncodingHandler]->name);
-	    xmlFree(handlers[nbCharEncodingHandler]);
+        handler = globalHandlers[nbCharEncodingHandler];
+	if (handler != NULL) {
+	    if (handler->name != NULL)
+		xmlFree(handler->name);
+	    xmlFree(handler);
 	}
     }
-    xmlFree(handlers);
-    handlers = NULL;
+    xmlFree(globalHandlers);
+    globalHandlers = NULL;
     nbCharEncodingHandler = 0;
 }
 
@@ -1460,21 +723,25 @@ xmlCleanupCharEncodingHandlers(void) {
  * xmlRegisterCharEncodingHandler:
  * @handler:  the xmlCharEncodingHandlerPtr handler block
  *
- * Register the char encoding handler, surprising, isn't it ?
+ * DEPRECATED: This function modifies global state and is not
+ * thread-safe.
+ *
+ * Register the char encoding handler.
  */
 void
 xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler) {
     if (handler == NULL)
         return;
-    if (handlers == NULL) {
-        handlers = xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(handlers[0]));
-        if (handlers == NULL)
+    if (globalHandlers == NULL) {
+        globalHandlers = xmlMalloc(
+                MAX_ENCODING_HANDLERS * sizeof(globalHandlers[0]));
+        if (globalHandlers == NULL)
             goto free_handler;
     }
 
     if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS)
         goto free_handler;
-    handlers[nbCharEncodingHandler++] = handler;
+    globalHandlers[nbCharEncodingHandler++] = handler;
     return;
 
 free_handler:
@@ -1486,278 +753,121 @@ free_handler:
     }
 }
 
-#ifdef LIBXML_ICONV_ENABLED
 static int
-xmlCreateIconvHandler(const char *name, xmlCharEncodingHandler **out) {
-    xmlCharEncodingHandlerPtr enc = NULL;
-    iconv_t icv_in = (iconv_t) -1;
-    iconv_t icv_out = (iconv_t) -1;
+xmlInvokeConvImpl(xmlCharEncConvImpl impl, void *implCtxt,
+                  const char *name, xmlCharEncodingHandler *handler) {
+    xmlCharEncConverter conv = { NULL, NULL, NULL, NULL, NULL };
     int ret;
 
-    *out = NULL;
+    ret = impl(implCtxt, name, &conv);
 
-    icv_in = iconv_open("UTF-8", name);
-    if (icv_in == (iconv_t) -1) {
-        if (errno == EINVAL)
-            ret = XML_ERR_UNSUPPORTED_ENCODING;
-        else if (errno == ENOMEM)
-            ret = XML_ERR_NO_MEMORY;
-        else
-            ret = XML_ERR_SYSTEM;
-        goto error;
-    }
-
-    icv_out = iconv_open(name, "UTF-8");
-    if (icv_out == (iconv_t) -1) {
-        if (errno == EINVAL)
-            ret = XML_ERR_UNSUPPORTED_ENCODING;
-        else if (errno == ENOMEM)
-            ret = XML_ERR_NO_MEMORY;
-        else
-            ret = XML_ERR_SYSTEM;
-        goto error;
-    }
-
-    enc = xmlMalloc(sizeof(*enc));
-    if (enc == NULL) {
-        ret = XML_ERR_NO_MEMORY;
-        goto error;
-    }
-    memset(enc, 0, sizeof(*enc));
-
-    enc->name = xmlMemStrdup(name);
-    if (enc->name == NULL) {
-        ret = XML_ERR_NO_MEMORY;
-        goto error;
-    }
-    enc->iconv_in = icv_in;
-    enc->iconv_out = icv_out;
-
-    *out = enc;
-    return(0);
-
-error:
-    if (enc != NULL)
-        xmlFree(enc);
-    if (icv_in != (iconv_t) -1)
-        iconv_close(icv_in);
-    if (icv_out != (iconv_t) -1)
-        iconv_close(icv_out);
-    return(ret);
-}
-#endif /* LIBXML_ICONV_ENABLED */
-
-#ifdef LIBXML_ICU_ENABLED
-static int
-openIcuConverter(const char* name, int toUnicode, uconv_t **out)
-{
-    UErrorCode status;
-    uconv_t *conv;
-
-    *out = NULL;
-
-    conv = (uconv_t *) xmlMalloc(sizeof(uconv_t));
-    if (conv == NULL)
-        return(XML_ERR_NO_MEMORY);
-
-    conv->pivot_source = conv->pivot_buf;
-    conv->pivot_target = conv->pivot_buf;
-
-    status = U_ZERO_ERROR;
-    conv->uconv = ucnv_open(name, &status);
-    if (U_FAILURE(status))
-        goto error;
-
-    status = U_ZERO_ERROR;
-    if (toUnicode) {
-        ucnv_setToUCallBack(conv->uconv, UCNV_TO_U_CALLBACK_STOP,
-                                                NULL, NULL, NULL, &status);
-    }
-    else {
-        ucnv_setFromUCallBack(conv->uconv, UCNV_FROM_U_CALLBACK_STOP,
-                                                NULL, NULL, NULL, &status);
-    }
-    if (U_FAILURE(status))
-        goto error;
-
-    status = U_ZERO_ERROR;
-    conv->utf8 = ucnv_open("UTF-8", &status);
-    if (U_FAILURE(status))
-        goto error;
-
-    *out = conv;
-    return(0);
-
-error:
-    if (conv->uconv)
-        ucnv_close(conv->uconv);
-    xmlFree(conv);
-
-    if (status == U_FILE_ACCESS_ERROR)
-        return(XML_ERR_UNSUPPORTED_ENCODING);
-    if (status == U_MEMORY_ALLOCATION_ERROR)
-        return(XML_ERR_NO_MEMORY);
-    return(XML_ERR_SYSTEM);
-}
-
-static void
-closeIcuConverter(uconv_t *conv)
-{
-    if (conv == NULL)
-        return;
-    ucnv_close(conv->uconv);
-    ucnv_close(conv->utf8);
-    xmlFree(conv);
-}
-
-static int
-xmlCreateUconvHandler(const char *name, xmlCharEncodingHandler **out) {
-    xmlCharEncodingHandlerPtr enc = NULL;
-    uconv_t *ucv_in = NULL;
-    uconv_t *ucv_out = NULL;
-    int ret;
-
-    ret = openIcuConverter(name, 1, &ucv_in);
-    if (ret != 0)
-        goto error;
-    ret = openIcuConverter(name, 0, &ucv_out);
-    if (ret != 0)
-        goto error;
-
-    enc = (xmlCharEncodingHandlerPtr)
-           xmlMalloc(sizeof(xmlCharEncodingHandler));
-    if (enc == NULL) {
-        ret = XML_ERR_NO_MEMORY;
-        goto error;
-    }
-    memset(enc, 0, sizeof(xmlCharEncodingHandler));
-
-    enc->name = xmlMemStrdup(name);
-    if (enc->name == NULL) {
-        ret = XML_ERR_NO_MEMORY;
-        goto error;
+    if (ret == XML_ERR_OK) {
+        handler->input =
+            (xmlCharEncodingInputFunc) (void (*)(void)) conv.input;
+        handler->output =
+            (xmlCharEncodingOutputFunc) (void (*)(void)) conv.output;
+        handler->ctxtDtor = conv.ctxtDtor;
+        handler->inputCtxt = conv.inputCtxt;
+        handler->outputCtxt = conv.outputCtxt;
     }
-    enc->input = NULL;
-    enc->output = NULL;
-    enc->uconv_in = ucv_in;
-    enc->uconv_out = ucv_out;
-
-    *out = enc;
-    return(0);
 
-error:
-    if (enc != NULL)
-        xmlFree(enc);
-    if (ucv_in != NULL)
-        closeIcuConverter(ucv_in);
-    if (ucv_out != NULL)
-        closeIcuConverter(ucv_out);
     return(ret);
 }
-#endif /* LIBXML_ICU_ENABLED */
 
 /**
  * xmlFindExtraHandler:
- * @name:  a string describing the char encoding.
+ * @norig:  name of the char encoding
+ * @name:  potentially aliased name of the encoding
  * @output:  boolean, use handler for output
+ * @impl:  a conversion implementation (optional)
+ * @implCtxt:  user data for conversion implementation (optional)
  * @out:  pointer to resulting handler
  *
  * Search the non-default handlers for an exact match.
  *
- * Returns 0 on success, 1 if no handler was found, -1 if a memory
- * allocation failed.
+ * Returns an xmlParserErrors error code.
  */
 static int
-xmlFindExtraHandler(const char *name, int output,
+xmlFindExtraHandler(const char *norig, const char *name, int output,
+                    xmlCharEncConvImpl impl, void *implCtxt,
                     xmlCharEncodingHandler **out) {
+    xmlCharEncodingHandler *handler;
     int ret;
     int i;
 
-    (void) ret;
+    handler = xmlMalloc(sizeof(*handler));
+    if (handler == NULL)
+        return(XML_ERR_NO_MEMORY);
+    memset(handler, 0, sizeof(*handler));
+
+    handler->name = xmlMemStrdup(name);
+    if (handler->name == NULL) {
+        ret = XML_ERR_NO_MEMORY;
+        goto done;
+    }
+
+    /*
+     * Try custom implementation before deprecated global handlers.
+     *
+     * Note that we pass the original name without deprecated
+     * alias resolution.
+     */
+    if (impl != NULL) {
+        ret = xmlInvokeConvImpl(impl, implCtxt, norig, handler);
+        if (ret != XML_ERR_OK)
+            goto done;
+
+        *out = handler;
+        return(XML_ERR_OK);
+    }
 
-    if (handlers != NULL) {
+    /*
+     * Deprecated
+     */
+    if (globalHandlers != NULL) {
         for (i = 0; i < nbCharEncodingHandler; i++) {
-            xmlCharEncodingHandler *handler = handlers[i];
+            xmlCharEncodingHandler *h = globalHandlers[i];
 
             if (!xmlStrcasecmp((const xmlChar *) name,
-                               (const xmlChar *) handler->name)) {
-                if (output) {
-                    if (handler->output != NULL) {
-                        *out = handler;
-                        return(0);
-                    }
-                } else {
-                    if (handler->input != NULL) {
-                        *out = handler;
-                        return(0);
-                    }
+                               (const xmlChar *) h->name)) {
+                if ((output ? h->output : h->input) != NULL) {
+                    *out = h;
+                    ret = XML_ERR_OK;
+                    goto done;
                 }
             }
         }
     }
 
 #ifdef LIBXML_ICONV_ENABLED
-    ret = xmlCreateIconvHandler(name, out);
-    if (*out != NULL)
-        return(0);
+    ret = xmlInvokeConvImpl(xmlCharEncIconv, handler, name, handler);
+    if (ret == XML_ERR_OK) {
+        *out = handler;
+        return(XML_ERR_OK);
+    }
     if (ret != XML_ERR_UNSUPPORTED_ENCODING)
-        return(ret);
+        goto done;
 #endif /* LIBXML_ICONV_ENABLED */
 
 #ifdef LIBXML_ICU_ENABLED
-    ret = xmlCreateUconvHandler(name, out);
-    if (*out != NULL)
-        return(0);
+    ret = xmlInvokeConvImpl(xmlCharEncUconv, handler, name, handler);
+    if (ret == XML_ERR_OK) {
+        *out = handler;
+        return(XML_ERR_OK);
+    }
     if (ret != XML_ERR_UNSUPPORTED_ENCODING)
-        return(ret);
+        goto done;
 #endif /* LIBXML_ICU_ENABLED */
 
-    return(XML_ERR_UNSUPPORTED_ENCODING);
-}
-
-/**
- * xmlFindHandler:
- * @name:  a string describing the char encoding.
- * @output:  boolean, use handler for output
- * @out:  pointer to resulting handler
- *
- * Search all handlers for an exact match.
- *
- * Returns 0 on success, 1 if no handler was found, -1 if a memory
- * allocation failed.
- */
-static int
-xmlFindHandler(const char *name, int output, xmlCharEncodingHandler **out) {
-    int i;
-
-    /*
-     * Check for default handlers
-     */
-    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
-        xmlCharEncodingHandler *handler;
-
-        handler = (xmlCharEncodingHandler *) &defaultHandlers[i];
+    ret = XML_ERR_UNSUPPORTED_ENCODING;
 
-        if (xmlStrcasecmp((const xmlChar *) name,
-                          (const xmlChar *) handler->name) == 0) {
-            if (output) {
-                if (handler->output != NULL) {
-                    *out = handler;
-                    return(0);
-                }
-            } else {
-                if (handler->input != NULL) {
-                    *out = handler;
-                    return(0);
-                }
-            }
-        }
+done:
+    if (handler != NULL) {
+        xmlFree(handler->name);
+        xmlFree(handler);
     }
 
-    /*
-     * Check for other handlers
-     */
-    return(xmlFindExtraHandler(name, output, out));
+    return(ret);
 }
 
 /**
@@ -1765,130 +875,51 @@ xmlFindHandler(const char *name, int output, xmlCharEncodingHandler **out) {
  * @enc:  an xmlCharEncoding value.
  * @out:  pointer to result
  *
- * Find or create a handler matching the encoding. If no default or
- * registered handler could be found, try to create a handler using
- * iconv or ICU if supported.
+ * Find or create a handler matching the encoding. The following
+ * converters are looked up in order:
+ *
+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)
+ * - User-registered global handler (deprecated)
+ * - iconv if enabled
+ * - ICU if enabled
  *
  * The handler must be closed with xmlCharEncCloseFunc.
  *
+ * If the encoding is UTF-8, a NULL handler and no error code will
+ * be returned.
+ *
  * Available since 2.13.0.
  *
- * Returns an xmlParserErrors error code.
+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another
+ * xmlParserErrors error code.
  */
 int
 xmlLookupCharEncodingHandler(xmlCharEncoding enc,
                              xmlCharEncodingHandler **out) {
-    const char *name = NULL;
-    static const char *const ebcdicNames[] = {
-        "EBCDIC", "ebcdic", "EBCDIC-US", "IBM-037"
-    };
-    static const char *const ucs4Names[] = {
-        "ISO-10646-UCS-4", "UCS-4", "UCS4"
-    };
-    static const char *const ucs2Names[] = {
-        "ISO-10646-UCS-2", "UCS-2", "UCS2"
-    };
-    static const char *const shiftJisNames[] = {
-        "SHIFT-JIS", "SHIFT_JIS", "Shift_JIS",
-    };
-    const char *const *names = NULL;
-    int numNames = 0;
-    int ret;
-    int i;
+    const xmlCharEncodingHandler *handler;
 
     if (out == NULL)
         return(XML_ERR_ARGUMENT);
     *out = NULL;
 
-    switch (enc) {
-        case XML_CHAR_ENCODING_ERROR:
-	    return(XML_ERR_UNSUPPORTED_ENCODING);
-        case XML_CHAR_ENCODING_NONE:
-	    return(0);
-        case XML_CHAR_ENCODING_UTF8:
-	    return(0);
-        case XML_CHAR_ENCODING_UTF16LE:
-	    *out = (xmlCharEncodingHandler *) xmlUTF16LEHandler;
-            return(0);
-        case XML_CHAR_ENCODING_UTF16BE:
-	    *out = (xmlCharEncodingHandler *) xmlUTF16BEHandler;
-            return(0);
-        case XML_CHAR_ENCODING_EBCDIC:
-            names = ebcdicNames;
-            numNames = sizeof(ebcdicNames) / sizeof(ebcdicNames[0]);
-	    break;
-        case XML_CHAR_ENCODING_UCS4BE:
-        case XML_CHAR_ENCODING_UCS4LE:
-            names = ucs4Names;
-            numNames = sizeof(ucs4Names) / sizeof(ucs4Names[0]);
-	    break;
-        case XML_CHAR_ENCODING_UCS4_2143:
-	    break;
-        case XML_CHAR_ENCODING_UCS4_3412:
-	    break;
-        case XML_CHAR_ENCODING_UCS2:
-            names = ucs2Names;
-            numNames = sizeof(ucs2Names) / sizeof(ucs2Names[0]);
-	    break;
-
-        case XML_CHAR_ENCODING_ASCII:
-	    *out = (xmlCharEncodingHandler *) xmlAsciiHandler;
-            return(0);
-        case XML_CHAR_ENCODING_8859_1:
-	    *out = (xmlCharEncodingHandler *) xmlLatin1Handler;
-            return(0);
-        case XML_CHAR_ENCODING_8859_2:
-	    name = "ISO-8859-2";
-	    break;
-        case XML_CHAR_ENCODING_8859_3:
-	    name = "ISO-8859-3";
-	    break;
-        case XML_CHAR_ENCODING_8859_4:
-	    name = "ISO-8859-4";
-	    break;
-        case XML_CHAR_ENCODING_8859_5:
-	    name = "ISO-8859-5";
-	    break;
-        case XML_CHAR_ENCODING_8859_6:
-	    name = "ISO-8859-6";
-	    break;
-        case XML_CHAR_ENCODING_8859_7:
-	    name = "ISO-8859-7";
-	    break;
-        case XML_CHAR_ENCODING_8859_8:
-	    name = "ISO-8859-8";
-	    break;
-        case XML_CHAR_ENCODING_8859_9:
-	    name = "ISO-8859-9";
-	    break;
-
-        case XML_CHAR_ENCODING_2022_JP:
-            name = "ISO-2022-JP";
-	    break;
-        case XML_CHAR_ENCODING_SHIFT_JIS:
-            names = shiftJisNames;
-            numNames = sizeof(shiftJisNames) / sizeof(shiftJisNames[0]);
-	    break;
-        case XML_CHAR_ENCODING_EUC_JP:
-            name = "EUC-JP";
-	    break;
-	default:
-	    break;
-    }
-
-    if (name != NULL)
-        return(xmlFindExtraHandler(name, 0, out));
-
-    if (names != NULL) {
-        for (i = 0; i < numNames; i++) {
-            ret = xmlFindExtraHandler(names[i], 0, out);
-            if (*out != NULL)
-                return(0);
-            if (ret != XML_ERR_UNSUPPORTED_ENCODING)
-                return(ret);
-        }
+    if ((enc <= 0) || ((size_t) enc >= NUM_DEFAULT_HANDLERS))
+        return(XML_ERR_UNSUPPORTED_ENCODING);
+
+    /* Return NULL handler for UTF-8 */
+    if ((enc == XML_CHAR_ENCODING_UTF8) ||
+        (enc == XML_CHAR_ENCODING_NONE))
+        return(XML_ERR_OK);
+
+    handler = &defaultHandlers[enc];
+    if ((handler->input != NULL) || (handler->output != NULL)) {
+        *out = (xmlCharEncodingHandler *) handler;
+        return(XML_ERR_OK);
     }
 
+    if (handler->name != NULL)
+        return(xmlFindExtraHandler(handler->name, handler->name, 0,
+                                   NULL, NULL, out));
+
     return(XML_ERR_UNSUPPORTED_ENCODING);
 }
 
@@ -1911,28 +942,39 @@ xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 }
 
 /**
- * xmlOpenCharEncodingHandler:
+ * xmlCreateCharEncodingHandler:
  * @name:  a string describing the char encoding.
  * @output:  boolean, use handler for output
+ * @impl:  a conversion implementation (optional)
+ * @implCtxt:  user data for conversion implementation (optional)
  * @out:  pointer to result
  *
- * Find or create a handler matching the encoding. If no default or
- * registered handler could be found, try to create a handler using
- * iconv or ICU if supported.
+ * Find or create a handler matching the encoding. The following
+ * converters are looked up in order:
+ *
+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)
+ * - Custom implementation if provided
+ * - User-registered global handler (deprecated)
+ * - iconv if enabled
+ * - ICU if enabled
  *
  * The handler must be closed with xmlCharEncCloseFunc.
  *
- * Available since 2.13.0.
+ * If the encoding is UTF-8, a NULL handler and no error code will
+ * be returned.
  *
- * Returns an xmlParserErrors error code.
+ * Available since 2.14.0.
+ *
+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another
+ * xmlParserErrors error code.
  */
 int
-xmlOpenCharEncodingHandler(const char *name, int output,
-                           xmlCharEncodingHandler **out) {
-    const char *nalias;
-    const char *norig;
+xmlCreateCharEncodingHandler(const char *name, int output,
+                             xmlCharEncConvImpl impl, void *implCtxt,
+                             xmlCharEncodingHandler **out) {
+    const xmlCharEncodingHandler *handler;
+    const char *norig, *nalias;
     xmlCharEncoding enc;
-    int ret;
 
     if (out == NULL)
         return(XML_ERR_ARGUMENT);
@@ -1941,25 +983,56 @@ xmlOpenCharEncodingHandler(const char *name, int output,
     if (name == NULL)
         return(XML_ERR_ARGUMENT);
 
-    /*
-     * Do the alias resolution
-     */
     norig = name;
     nalias = xmlGetEncodingAlias(name);
     if (nalias != NULL)
 	name = nalias;
 
-    ret = xmlFindHandler(name, output, out);
-    if (*out != NULL)
-        return(0);
-    if (ret != XML_ERR_UNSUPPORTED_ENCODING)
-        return(ret);
+    enc = xmlParseCharEncodingInternal(name);
 
-    /*
-     * Fallback using the canonical names
-     */
-    enc = xmlParseCharEncoding(norig);
-    return(xmlLookupCharEncodingHandler(enc, out));
+    /* Return NULL handler for UTF-8 */
+    if (enc == XML_CHAR_ENCODING_UTF8)
+        return(XML_ERR_OK);
+
+    if ((enc > 0) && ((size_t) enc < NUM_DEFAULT_HANDLERS)) {
+        handler = &defaultHandlers[enc];
+        if ((output ? handler->output : handler->input) != NULL) {
+            *out = (xmlCharEncodingHandler *) handler;
+            return(XML_ERR_OK);
+        }
+    }
+
+    return(xmlFindExtraHandler(norig, name, output, impl, implCtxt, out));
+}
+
+/**
+ * xmlOpenCharEncodingHandler:
+ * @name:  a string describing the char encoding.
+ * @output:  boolean, use handler for output
+ * @out:  pointer to result
+ *
+ * Find or create a handler matching the encoding. The following
+ * converters are looked up in order:
+ *
+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)
+ * - User-registered global handler (deprecated)
+ * - iconv if enabled
+ * - ICU if enabled
+ *
+ * The handler must be closed with xmlCharEncCloseFunc.
+ *
+ * If the encoding is UTF-8, a NULL handler and no error code will
+ * be returned.
+ *
+ * Available since 2.13.0.
+ *
+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another
+ * xmlParserErrors error code.
+ */
+int
+xmlOpenCharEncodingHandler(const char *name, int output,
+                           xmlCharEncodingHandler **out) {
+    return(xmlCreateCharEncodingHandler(name, output, NULL, NULL, out));
 }
 
 /**
@@ -1969,6 +1042,9 @@ xmlOpenCharEncodingHandler(const char *name, int output,
  * DEPRECATED: Use xmlOpenCharEncodingHandler which has better error
  * reporting.
  *
+ * If the encoding is UTF-8, this will return a no-op handler that
+ * shouldn't be used.
+ *
  * Returns the handler or NULL if no handler was found or an error
  * occurred.
  */
@@ -1976,6 +1052,15 @@ xmlCharEncodingHandlerPtr
 xmlFindCharEncodingHandler(const char *name) {
     xmlCharEncodingHandler *ret;
 
+    /*
+     * This handler shouldn't be used, but we must return a non-NULL
+     * handler.
+     */
+    if ((xmlStrcasecmp(BAD_CAST name, BAD_CAST "UTF-8") == 0) ||
+        (xmlStrcasecmp(BAD_CAST name, BAD_CAST "UTF8") == 0))
+        return((xmlCharEncodingHandlerPtr)
+                &defaultHandlers[XML_CHAR_ENCODING_UTF8]);
+
     xmlOpenCharEncodingHandler(name, 0, &ret);
     return(ret);
 }
@@ -1987,9 +1072,13 @@ xmlFindCharEncodingHandler(const char *name) {
  ************************************************************************/
 
 #ifdef LIBXML_ICONV_ENABLED
+typedef struct {
+    iconv_t cd;
+} xmlIconvCtxt;
+
 /**
- * xmlIconvWrapper:
- * @cd:		iconv converter data structure
+ * xmlIconvConvert:
+ * @vctxt:  conversion context
  * @out:  a pointer to an array of bytes to store the result
  * @outlen:  the length of @out
  * @in:  a pointer to an array of input bytes
@@ -2002,8 +1091,9 @@ xmlFindCharEncodingHandler(const char *name) {
  * The value of @outlen after return is the number of octets produced.
  */
 static int
-xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
-                const unsigned char *in, int *inlen) {
+xmlIconvConvert(unsigned char *out, int *outlen,
+                const unsigned char *in, int *inlen, void *vctxt) {
+    xmlIconvCtxt *ctxt = vctxt;
     size_t icv_inlen, icv_outlen;
     const char *icv_in = (const char *) in;
     char *icv_out = (char *) out;
@@ -2018,7 +1108,7 @@ xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
     /*
      * Some versions take const, other versions take non-const input.
      */
-    ret = iconv(cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);
+    ret = iconv(ctxt->cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);
     *inlen -= icv_inlen;
     *outlen -= icv_outlen;
     if (ret == (size_t) -1) {
@@ -2026,45 +1116,143 @@ xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
             return(XML_ENC_ERR_INPUT);
         if (errno == E2BIG)
             return(XML_ENC_ERR_SPACE);
+        /*
+         * EINVAL means a truncated multi-byte sequence at the end
+         * of the input buffer. We treat this as success.
+         */
         if (errno == EINVAL)
-            return(XML_ENC_ERR_PARTIAL);
+            return(XML_ENC_ERR_SUCCESS);
         return(XML_ENC_ERR_INTERNAL);
     }
     return(XML_ENC_ERR_SUCCESS);
 }
-#endif /* LIBXML_ICONV_ENABLED */
 
-/************************************************************************
- *									*
- *		ICU based generic conversion functions		*
- *									*
- ************************************************************************/
+static void
+xmlIconvFree(void *vctxt) {
+    xmlIconvCtxt *ctxt = vctxt;
 
-#ifdef LIBXML_ICU_ENABLED
-/**
- * xmlUconvWrapper:
- * @cd: ICU uconverter data structure
- * @toUnicode : non-zero if toUnicode. 0 otherwise.
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of input bytes
- * @inlen:  the length of @in
- *
- * Returns an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- *     as the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets produced.
- */
-static int
-xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,
-                const unsigned char *in, int *inlen) {
-    const char *ucv_in = (const char *) in;
-    char *ucv_out = (char *) out;
-    UErrorCode err = U_ZERO_ERROR;
+    if (ctxt->cd != (iconv_t) -1)
+        iconv_close(ctxt->cd);
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {
-        if (outlen != NULL) *outlen = 0;
+    xmlFree(ctxt);
+}
+
+static int
+xmlCharEncIconv(void *vctxt, const char *name, xmlCharEncConverter *conv) {
+    xmlCharEncodingHandler *handler = vctxt;
+    xmlIconvCtxt *inputCtxt = NULL, *outputCtxt = NULL;
+    iconv_t icv_in;
+    iconv_t icv_out;
+    int ret;
+
+    inputCtxt = xmlMalloc(sizeof(xmlIconvCtxt));
+    if (inputCtxt == NULL) {
+        ret = XML_ERR_NO_MEMORY;
+        goto error;
+    }
+    inputCtxt->cd = (iconv_t) -1;
+
+    icv_in = iconv_open("UTF-8", name);
+    if (icv_in == (iconv_t) -1) {
+        if (errno == EINVAL)
+            ret = XML_ERR_UNSUPPORTED_ENCODING;
+        else if (errno == ENOMEM)
+            ret = XML_ERR_NO_MEMORY;
+        else
+            ret = XML_ERR_SYSTEM;
+        goto error;
+    }
+    inputCtxt->cd = icv_in;
+
+    outputCtxt = xmlMalloc(sizeof(xmlIconvCtxt));
+    if (outputCtxt == NULL) {
+        ret = XML_ERR_NO_MEMORY;
+        goto error;
+    }
+    outputCtxt->cd = (iconv_t) -1;
+
+    icv_out = iconv_open(name, "UTF-8");
+    if (icv_out == (iconv_t) -1) {
+        if (errno == EINVAL)
+            ret = XML_ERR_UNSUPPORTED_ENCODING;
+        else if (errno == ENOMEM)
+            ret = XML_ERR_NO_MEMORY;
+        else
+            ret = XML_ERR_SYSTEM;
+        goto error;
+    }
+    outputCtxt->cd = icv_out;
+
+    conv->input = xmlIconvConvert;
+    conv->output = xmlIconvConvert;
+    conv->ctxtDtor = xmlIconvFree;
+    conv->inputCtxt = inputCtxt;
+    conv->outputCtxt = outputCtxt;
+
+    /* Backward compatibility */
+    if (handler != NULL) {
+        handler->iconv_in = icv_in;
+        handler->iconv_out = icv_out;
+    }
+
+    return(XML_ERR_OK);
+
+error:
+    if (inputCtxt != NULL)
+        xmlIconvFree(inputCtxt);
+    if (outputCtxt != NULL)
+        xmlIconvFree(outputCtxt);
+    return(ret);
+}
+#endif /* LIBXML_ICONV_ENABLED */
+
+/************************************************************************
+ *									*
+ *		ICU based generic conversion functions		*
+ *									*
+ ************************************************************************/
+
+#ifdef LIBXML_ICU_ENABLED
+/* Size of pivot buffer, same as icu/source/common/ucnv.cpp CHUNK_SIZE */
+#define ICU_PIVOT_BUF_SIZE 1024
+
+typedef struct _uconv_t xmlUconvCtxt;
+struct _uconv_t {
+  UConverter *uconv; /* for conversion between an encoding and UTF-16 */
+  UConverter *utf8; /* for conversion between UTF-8 and UTF-16 */
+  UChar      *pivot_source;
+  UChar      *pivot_target;
+  int        isInput;
+  UChar      pivot_buf[ICU_PIVOT_BUF_SIZE];
+};
+
+/**
+ * xmlUconvConvert:
+ * @vctxt:  converison context
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of input bytes
+ * @inlen:  the length of @in
+ *
+ * Returns an XML_ENC_ERR code.
+ *
+ * The value of @inlen after return is the number of octets consumed
+ *     as the return value is positive, else unpredictable.
+ * The value of @outlen after return is the number of octets produced.
+ */
+static int
+xmlUconvConvert(unsigned char *out, int *outlen,
+                const unsigned char *in, int *inlen, void *vctxt) {
+    xmlUconvCtxt *cd = vctxt;
+    const char *ucv_in = (const char *) in;
+    char *ucv_out = (char *) out;
+    UConverter *target, *source;
+    UErrorCode err = U_ZERO_ERROR;
+    int ret;
+
+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {
+        if (outlen != NULL)
+            *outlen = 0;
         return(XML_ENC_ERR_INTERNAL);
     }
 
@@ -2077,34 +1265,152 @@ xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,
      * ucnv_convertEx is always called with reset and flush set to 0,
      * so we don't mess up the state. This should never generate
      * U_TRUNCATED_CHAR_FOUND errors.
-     *
-     * This also means that ICU xmlCharEncodingHandlers should never be
-     * reused. It would be a lot nicer if there was a way to emulate the
-     * stateless iconv API.
      */
-    if (toUnicode) {
-        /* encoding => UTF-16 => UTF-8 */
-        ucnv_convertEx(cd->utf8, cd->uconv, &ucv_out, ucv_out + *outlen,
-                       &ucv_in, ucv_in + *inlen, cd->pivot_buf,
-                       &cd->pivot_source, &cd->pivot_target,
-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);
+    if (cd->isInput) {
+        source = cd->uconv;
+        target = cd->utf8;
     } else {
-        /* UTF-8 => UTF-16 => encoding */
-        ucnv_convertEx(cd->uconv, cd->utf8, &ucv_out, ucv_out + *outlen,
-                       &ucv_in, ucv_in + *inlen, cd->pivot_buf,
-                       &cd->pivot_source, &cd->pivot_target,
-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);
+        source = cd->utf8;
+        target = cd->uconv;
     }
+
+    ucnv_convertEx(target, source, &ucv_out, ucv_out + *outlen,
+                   &ucv_in, ucv_in + *inlen, cd->pivot_buf,
+                   &cd->pivot_source, &cd->pivot_target,
+                   cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);
+
     *inlen = ucv_in - (const char*) in;
     *outlen = ucv_out - (char *) out;
+
     if (U_SUCCESS(err)) {
-        return(XML_ENC_ERR_SUCCESS);
+        ret = XML_ENC_ERR_SUCCESS;
+    } else {
+        switch (err) {
+            case U_TRUNCATED_CHAR_FOUND:
+                /* Shouldn't happen without flush */
+                ret = XML_ENC_ERR_SUCCESS;
+                break;
+
+            case U_BUFFER_OVERFLOW_ERROR:
+                ret = XML_ENC_ERR_SPACE;
+                break;
+
+            case U_INVALID_CHAR_FOUND:
+            case U_ILLEGAL_CHAR_FOUND:
+            case U_ILLEGAL_ESCAPE_SEQUENCE:
+            case U_UNSUPPORTED_ESCAPE_SEQUENCE:
+                ret = XML_ENC_ERR_INPUT;
+                break;
+
+            case U_MEMORY_ALLOCATION_ERROR:
+                ret = XML_ENC_ERR_MEMORY;
+                break;
+
+            default:
+                ret = XML_ENC_ERR_INTERNAL;
+                break;
+        }
+    }
+
+    return(ret);
+}
+
+static int
+openIcuConverter(const char* name, int isInput, xmlUconvCtxt **out)
+{
+    UErrorCode status;
+    xmlUconvCtxt *conv;
+
+    *out = NULL;
+
+    conv = (xmlUconvCtxt *) xmlMalloc(sizeof(xmlUconvCtxt));
+    if (conv == NULL)
+        return(XML_ERR_NO_MEMORY);
+
+    conv->isInput = isInput;
+    conv->pivot_source = conv->pivot_buf;
+    conv->pivot_target = conv->pivot_buf;
+
+    status = U_ZERO_ERROR;
+    conv->uconv = ucnv_open(name, &status);
+    if (U_FAILURE(status))
+        goto error;
+
+    status = U_ZERO_ERROR;
+    if (isInput) {
+        ucnv_setToUCallBack(conv->uconv, UCNV_TO_U_CALLBACK_STOP,
+                                                NULL, NULL, NULL, &status);
+    }
+    else {
+        ucnv_setFromUCallBack(conv->uconv, UCNV_FROM_U_CALLBACK_STOP,
+                                                NULL, NULL, NULL, &status);
     }
-    if (err == U_BUFFER_OVERFLOW_ERROR)
-        return(XML_ENC_ERR_SPACE);
-    if (err == U_INVALID_CHAR_FOUND || err == U_ILLEGAL_CHAR_FOUND)
-        return(XML_ENC_ERR_INPUT);
-    return(XML_ENC_ERR_PARTIAL);
+    if (U_FAILURE(status))
+        goto error;
+
+    status = U_ZERO_ERROR;
+    conv->utf8 = ucnv_open("UTF-8", &status);
+    if (U_FAILURE(status))
+        goto error;
+
+    *out = conv;
+    return(0);
+
+error:
+    if (conv->uconv)
+        ucnv_close(conv->uconv);
+    xmlFree(conv);
+
+    if (status == U_FILE_ACCESS_ERROR)
+        return(XML_ERR_UNSUPPORTED_ENCODING);
+    if (status == U_MEMORY_ALLOCATION_ERROR)
+        return(XML_ERR_NO_MEMORY);
+    return(XML_ERR_SYSTEM);
+}
+
+static void
+closeIcuConverter(xmlUconvCtxt *conv)
+{
+    if (conv == NULL)
+        return;
+    ucnv_close(conv->uconv);
+    ucnv_close(conv->utf8);
+    xmlFree(conv);
+}
+
+static void
+xmlUconvFree(void *vctxt) {
+    closeIcuConverter(vctxt);
+}
+
+static int
+xmlCharEncUconv(void *vctxt ATTRIBUTE_UNUSED, const char *name,
+                xmlCharEncConverter *conv) {
+    xmlUconvCtxt *ucv_in = NULL;
+    xmlUconvCtxt *ucv_out = NULL;
+    int ret;
+
+    ret = openIcuConverter(name, 1, &ucv_in);
+    if (ret != 0)
+        goto error;
+    ret = openIcuConverter(name, 0, &ucv_out);
+    if (ret != 0)
+        goto error;
+
+    conv->input = xmlUconvConvert;
+    conv->output = xmlUconvConvert;
+    conv->ctxtDtor = xmlUconvFree;
+    conv->inputCtxt = ucv_in;
+    conv->outputCtxt = ucv_out;
+
+    return(XML_ERR_OK);
+
+error:
+    if (ucv_in != NULL)
+        closeIcuConverter(ucv_in);
+    if (ucv_out != NULL)
+        closeIcuConverter(ucv_out);
+    return(ret);
 }
 #endif /* LIBXML_ICU_ENABLED */
 
@@ -2162,43 +1468,19 @@ xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
     int ret;
 
     if (handler->input != NULL) {
-        int oldinlen = *inlen;
-
-        ret = handler->input(out, outlen, in, inlen);
-        if (ret >= 0) {
-            /*
-             * The built-in converters don't signal XML_ENC_ERR_SPACE.
-             */
-            if (*inlen < oldinlen) {
-                if (*outlen > 0)
-                    ret = XML_ENC_ERR_SPACE;
-                else
-                    ret = XML_ENC_ERR_PARTIAL;
-            } else {
-                ret = XML_ENC_ERR_SUCCESS;
-            }
-        }
-    }
-#ifdef LIBXML_ICONV_ENABLED
-    else if (handler->iconv_in != NULL) {
-        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
-    }
-#endif /* LIBXML_ICONV_ENABLED */
-#ifdef LIBXML_ICU_ENABLED
-    else if (handler->uconv_in != NULL) {
-        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
+        xmlCharEncConvFunc conv =
+            (xmlCharEncConvFunc) (void (*)(void)) handler->input;
+
+        ret = conv(out, outlen, in, inlen, handler->inputCtxt);
+        if (ret > 0)
+            ret = XML_ENC_ERR_SUCCESS;
     }
-#endif /* LIBXML_ICU_ENABLED */
     else {
         *outlen = 0;
         *inlen = 0;
         ret = XML_ENC_ERR_INTERNAL;
     }
 
-    /* Ignore partial errors when reading. */
-    if (ret == XML_ENC_ERR_PARTIAL)
-        ret = XML_ENC_ERR_SUCCESS;
-
     return(ret);
 }
 
@@ -2222,43 +1504,19 @@ xmlEncOutputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
     int ret;
 
     if (handler->output != NULL) {
-        int oldinlen = *inlen;
-
-        ret = handler->output(out, outlen, in, inlen);
-        if (ret >= 0) {
-            /*
-             * The built-in converters don't signal XML_ENC_ERR_SPACE.
-             */
-            if (*inlen < oldinlen) {
-                if (*outlen > 0)
-                    ret = XML_ENC_ERR_SPACE;
-                else
-                    ret = XML_ENC_ERR_PARTIAL;
-            } else {
-                ret = XML_ENC_ERR_SUCCESS;
-            }
-        }
-    }
-#ifdef LIBXML_ICONV_ENABLED
-    else if (handler->iconv_out != NULL) {
-        ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);
-    }
-#endif /* LIBXML_ICONV_ENABLED */
-#ifdef LIBXML_ICU_ENABLED
-    else if (handler->uconv_out != NULL) {
-        ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen);
+        xmlCharEncConvFunc conv =
+            (xmlCharEncConvFunc) (void (*)(void)) handler->output;
+
+        ret = conv(out, outlen, in, inlen, handler->outputCtxt);
+        if (ret > 0)
+            ret = XML_ENC_ERR_SUCCESS;
     }
-#endif /* LIBXML_ICU_ENABLED */
     else {
         *outlen = 0;
         *inlen = 0;
         ret = XML_ENC_ERR_INTERNAL;
     }
 
-    /* We shouldn't generate partial sequences when writing. */
-    if (ret == XML_ENC_ERR_PARTIAL)
-        ret = XML_ENC_ERR_INTERNAL;
-
     return(ret);
 }
 
@@ -2281,75 +1539,104 @@ xmlCharEncFirstLine(xmlCharEncodingHandler *handler, xmlBufferPtr out,
 /**
  * xmlCharEncInput:
  * @input: a parser input buffer
+ * @sizeOut:  pointer to output size
+ *
+ * @sizeOut should be set to the maximum output size (or SIZE_MAX).
+ * After return, it is set to the number of bytes written.
  *
  * Generic front-end for the encoding handler on parser input
  *
- * Returns the number of bytes written or an XML_ENC_ERR code.
+ * Returns an XML_ENC_ERR code.
  */
 int
-xmlCharEncInput(xmlParserInputBufferPtr input)
+xmlCharEncInput(xmlParserInputBufferPtr input, size_t *sizeOut)
 {
+    xmlBufPtr out, in;
+    const xmlChar *dataIn;
+    size_t availIn;
+    size_t maxOut;
+    size_t totalIn, totalOut;
     int ret;
-    size_t avail;
-    size_t toconv;
-    int c_in;
-    int c_out;
-    xmlBufPtr in;
-    xmlBufPtr out;
-    const xmlChar *inData;
-    size_t inTotal = 0;
 
-    if ((input == NULL) || (input->encoder == NULL) ||
-        (input->buffer == NULL) || (input->raw == NULL))
-        return(XML_ENC_ERR_INTERNAL);
     out = input->buffer;
     in = input->raw;
 
-    toconv = xmlBufUse(in);
-    if (toconv == 0)
-        return (0);
-    inData = xmlBufContent(in);
-    inTotal = 0;
+    maxOut = *sizeOut;
+    totalOut = 0;
+
+    *sizeOut = 0;
+
+    availIn = xmlBufUse(in);
+    if (availIn == 0)
+        return(0);
+    dataIn = xmlBufContent(in);
+    totalIn = 0;
 
-    do {
-        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
+    while (1) {
+        size_t availOut;
+        int completeOut, completeIn;
+        int c_out, c_in;
 
-        avail = xmlBufAvail(out);
-        if (avail > INT_MAX)
-            avail = INT_MAX;
-        if (avail < 4096) {
+        availOut = xmlBufAvail(out);
+        if (availOut > INT_MAX / 2)
+            availOut = INT_MAX / 2;
+
+        if (availOut < maxOut) {
+            c_out = availOut;
+            completeOut = 0;
+        } else {
+            c_out = maxOut;
+            completeOut = 1;
+        }
+
+        if (availIn > INT_MAX / 2) {
+            c_in = INT_MAX / 2;
+            completeIn = 0;
+        } else {
+            c_in = availIn;
+            completeIn = 1;
+        }
+
+        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
+                               dataIn, &c_in);
+
+        totalIn += c_in;
+        dataIn += c_in;
+        availIn -= c_in;
+
+        totalOut += c_out;
+        maxOut -= c_out;
+        xmlBufAddLen(out, c_out);
+
+        if ((ret != XML_ENC_ERR_SUCCESS) && (ret != XML_ENC_ERR_SPACE)) {
+            input->error = xmlEncConvertError(ret);
+            return(ret);
+        }
+
+        if ((completeOut) && (completeIn))
+            break;
+        if ((completeOut) && (ret == XML_ENC_ERR_SPACE))
+            break;
+        if ((completeIn) && (ret == XML_ENC_ERR_SUCCESS))
+            break;
+
+        if (ret == XML_ENC_ERR_SPACE) {
             if (xmlBufGrow(out, 4096) < 0) {
                 input->error = XML_ERR_NO_MEMORY;
                 return(XML_ENC_ERR_MEMORY);
             }
-            avail = xmlBufAvail(out);
         }
+    }
 
-        c_in = toconv;
-        c_out = avail;
-        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
-                               inData, &c_in);
-        inTotal += c_in;
-        inData += c_in;
-        toconv -= c_in;
-        xmlBufAddLen(out, c_out);
-    } while (ret == XML_ENC_ERR_SPACE);
-
-    xmlBufShrink(in, inTotal);
+    xmlBufShrink(in, totalIn);
 
-    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
+    if (input->rawconsumed > ULONG_MAX - (unsigned long) totalIn)
         input->rawconsumed = ULONG_MAX;
     else
-        input->rawconsumed += c_in;
+        input->rawconsumed += totalIn;
 
-    if (((ret != 0) && (c_out == 0)) ||
-        (ret == XML_ENC_ERR_MEMORY)) {
-        if (input->error == 0)
-            input->error = xmlEncConvertError(ret);
-        return(ret);
-    }
-
-    return (c_out);
+    *sizeOut = totalOut;
+    return(XML_ERR_OK);
 }
 
 /**
@@ -2489,8 +1776,7 @@ retry:
          * and continue the transcoding phase, hoping the error
          * did not mangle the encoder state.
          */
-        charrefLen = snprintf((char *) &charref[0], sizeof(charref),
-                         "&#%d;", cur);
+        charrefLen = xmlSerializeDecCharRef((char *) charref, cur);
         xmlBufGrow(out, charrefLen * 4);
         c_out = xmlBufAvail(out);
         c_in = charrefLen;
@@ -2601,8 +1887,7 @@ retry:
          * and continue the transcoding phase, hoping the error
          * did not mangle the encoder state.
          */
-        charrefLen = snprintf((char *) &charref[0], sizeof(charref),
-                         "&#%d;", cur);
+        charrefLen = xmlSerializeDecCharRef((char *) charref, cur);
         xmlBufferShrink(in, len);
         xmlBufferGrow(out, charrefLen * 4);
         written = out->size - out->use - 1;
@@ -2612,1191 +1897,830 @@ retry:
         if ((ret < 0) || (toconv != charrefLen))
             return(XML_ENC_ERR_INTERNAL);
 
-        out->use += written;
-        writtentot += written;
-        out->content[out->use] = 0;
-        goto retry;
-    }
-    return(writtentot ? writtentot : ret);
-}
+        out->use += written;
+        writtentot += written;
+        out->content[out->use] = 0;
+        goto retry;
+    }
+    return(writtentot ? writtentot : ret);
+}
+
+/**
+ * xmlCharEncCloseFunc:
+ * @handler:	char encoding transformation data structure
+ *
+ * Releases an xmlCharEncodingHandler. Must be called after
+ * a handler is no longer in use.
+ *
+ * Returns 0.
+ */
+int
+xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
+    if (handler == NULL)
+        return(0);
+
+    if (handler->flags & XML_HANDLER_STATIC)
+        return(0);
+
+    xmlFree(handler->name);
+    if (handler->ctxtDtor != NULL) {
+        handler->ctxtDtor(handler->inputCtxt);
+        handler->ctxtDtor(handler->outputCtxt);
+    }
+    xmlFree(handler);
+    return(0);
+}
+
+/**
+ * xmlByteConsumed:
+ * @ctxt: an XML parser context
+ *
+ * DEPRECATED: Don't use.
+ *
+ * This function provides the current index of the parser relative
+ * to the start of the current entity. This function is computed in
+ * bytes from the beginning starting at zero and finishing at the
+ * size in byte of the file if parsing a file. The function is
+ * of constant cost if the input is UTF-8 but can be costly if run
+ * on non-UTF-8 input.
+ *
+ * Returns the index in bytes from the beginning of the entity or -1
+ *         in case the index could not be computed.
+ */
+long
+xmlByteConsumed(xmlParserCtxtPtr ctxt) {
+    xmlParserInputPtr in;
+
+    if (ctxt == NULL)
+        return(-1);
+    in = ctxt->input;
+    if (in == NULL)
+        return(-1);
+
+    if ((in->buf != NULL) && (in->buf->encoder != NULL)) {
+        int unused = 0;
+	xmlCharEncodingHandler * handler = in->buf->encoder;
+
+        /*
+	 * Encoding conversion, compute the number of unused original
+	 * bytes from the input not consumed and subtract that from
+	 * the raw consumed value, this is not a cheap operation
+	 */
+        if (in->end - in->cur > 0) {
+	    unsigned char *convbuf;
+	    const unsigned char *cur = (const unsigned char *)in->cur;
+	    int toconv, ret;
+
+            convbuf = xmlMalloc(32000);
+            if (convbuf == NULL)
+                return(-1);
+
+            toconv = in->end - cur;
+            unused = 32000;
+            ret = xmlEncOutputChunk(handler, convbuf, &unused, cur, &toconv);
+
+            xmlFree(convbuf);
+
+            if (ret != XML_ENC_ERR_SUCCESS)
+                return(-1);
+	}
+
+	if (in->buf->rawconsumed < (unsigned long) unused)
+	    return(-1);
+	return(in->buf->rawconsumed - unused);
+    }
+
+    return(in->consumed + (in->cur - in->base));
+}
+
+/************************************************************************
+ *									*
+ *		Conversions To/From UTF8 encoding			*
+ *									*
+ ************************************************************************/
+
+static int
+asciiToAscii(unsigned char* out, int *poutlen,
+             const unsigned char* in, int *pinlen,
+             void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char *inend;
+    const unsigned char *instart = in;
+    int inlen, outlen, ret;
+
+    if (in == NULL) {
+        *pinlen = 0;
+        *poutlen = 0;
+        return(XML_ENC_ERR_SUCCESS);
+    }
+
+    inlen = *pinlen;
+    outlen = *poutlen;
+
+    if (outlen < inlen) {
+        inlen = outlen;
+        ret = XML_ENC_ERR_SPACE;
+    } else {
+        ret = inlen;
+    }
+
+    inend = in + inlen;
+    *poutlen = inlen;
+    *pinlen = inlen;
+
+    while (in < inend) {
+	unsigned c = *in;
+
+        if (c >= 0x80) {
+	    *poutlen = in - instart;
+	    *pinlen = in - instart;
+	    return(XML_ENC_ERR_INPUT);
+	}
+
+        in++;
+	*out++ = c;
+    }
+
+    return(ret);
+}
+
+static int
+latin1ToUTF8(unsigned char* out, int *outlen,
+             const unsigned char* in, int *inlen,
+             void *vctxt ATTRIBUTE_UNUSED) {
+    unsigned char* outstart = out;
+    const unsigned char* instart = in;
+    unsigned char* outend;
+    const unsigned char* inend;
+    int ret = XML_ENC_ERR_SPACE;
+
+    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
+	return(XML_ENC_ERR_INTERNAL);
+
+    outend = out + *outlen;
+    inend = in + *inlen;
+
+    while (in < inend) {
+        unsigned c = *in;
+
+	if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            *out++ = c;
+	} else {
+            if (outend - out < 2)
+                goto done;
+	    *out++ = (c >> 6) | 0xC0;
+            *out++ = (c & 0x3F) | 0x80;
+        }
+
+        in++;
+    }
+
+    ret = out - outstart;
+
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
+}
+
+/**
+ * isolat1ToUTF8:
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of ISO Latin 1 chars
+ * @inlen:  the length of @in
+ *
+ * Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8
+ * block of chars out.
+ *
+ * Returns the number of bytes written or an XML_ENC_ERR code.
+ *
+ * The value of @inlen after return is the number of octets consumed
+ *     if the return value is positive, else unpredictable.
+ * The value of @outlen after return is the number of octets produced.
+ */
+int
+isolat1ToUTF8(unsigned char* out, int *outlen,
+              const unsigned char* in, int *inlen) {
+    return(latin1ToUTF8(out, outlen, in, inlen, NULL));
+}
+
+static int
+UTF8ToUTF8(unsigned char* out, int *outlen,
+           const unsigned char* in, int *inlen,
+           void *vctxt ATTRIBUTE_UNUSED) {
+    int len;
+    int ret;
+
+    if (in == NULL) {
+        *inlen = 0;
+        *outlen = 0;
+        return(XML_ENC_ERR_SUCCESS);
+    }
+
+    if (*outlen < *inlen) {
+	len = *outlen;
+        ret = XML_ENC_ERR_SPACE;
+    } else {
+	len = *inlen;
+        ret = len;
+    }
+
+    memcpy(out, in, len);
+
+    *outlen = len;
+    *inlen = len;
+    return(ret);
+}
+
+
+#ifdef LIBXML_OUTPUT_ENABLED
+static int
+UTF8ToLatin1(unsigned char* out, int *outlen,
+             const unsigned char* in, int *inlen,
+             void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char* outend;
+    const unsigned char* outstart = out;
+    const unsigned char* instart = in;
+    const unsigned char* inend;
+    unsigned c;
+    int ret = XML_ENC_ERR_SPACE;
+
+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
+        return(XML_ENC_ERR_INTERNAL);
+
+    if (in == NULL) {
+        *inlen = 0;
+        *outlen = 0;
+        return(XML_ENC_ERR_SUCCESS);
+    }
+
+    inend = in + *inlen;
+    outend = out + *outlen;
+    while (in < inend) {
+        if (out >= outend)
+            goto done;
+
+	c = *in;
+
+        if (c < 0x80) {
+            *out++ = c;
+        } else if ((c >= 0xC2) && (c <= 0xC3)) {
+            if (inend - in < 2)
+                break;
+            in++;
+            *out++ = (unsigned char) ((c << 6) | (*in & 0x3F));
+        } else {
+            ret = XML_ENC_ERR_INPUT;
+            goto done;
+	}
+
+        in++;
+    }
+
+    ret = out - outstart;
+
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
+}
+
+/**
+ * UTF8Toisolat1:
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of UTF-8 chars
+ * @inlen:  the length of @in
+ *
+ * Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1
+ * block of chars out.
+ *
+ * Returns the number of bytes written or an XML_ENC_ERR code.
+ *
+ * The value of @inlen after return is the number of octets consumed
+ *     if the return value is positive, else unpredictable.
+ * The value of @outlen after return is the number of octets produced.
+ */
+int
+UTF8Toisolat1(unsigned char* out, int *outlen,
+              const unsigned char* in, int *inlen) {
+    if ((out == NULL) || (outlen == NULL) || (in == NULL) || (inlen == NULL))
+        return(XML_ENC_ERR_INTERNAL);
+
+    return(UTF8ToLatin1(out, outlen, in, inlen, NULL));
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+static int
+UTF16LEToUTF8(unsigned char *out, int *outlen,
+              const unsigned char *in, int *inlen,
+              void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char *instart = in;
+    const unsigned char *inend = in + (*inlen & ~1);
+    unsigned char *outstart = out;
+    unsigned char *outend = out + *outlen;
+    unsigned c, d;
+    int ret = XML_ENC_ERR_SPACE;
+
+    while (in < inend) {
+        c = in[0] | (in[1] << 8);
+
+        if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            out[0] = c;
+            in += 2;
+            out += 1;
+        } else if (c < 0x800) {
+            if (outend - out < 2)
+                goto done;
+            out[0] = (c >> 6)   | 0xC0;
+            out[1] = (c & 0x3F) | 0x80;
+            in += 2;
+            out += 2;
+        } else if ((c & 0xF800) != 0xD800) {
+            if (outend - out < 3)
+                goto done;
+            out[0] =  (c >> 12)         | 0xE0;
+            out[1] = ((c >>  6) & 0x3F) | 0x80;
+            out[2] =  (c        & 0x3F) | 0x80;
+            in += 2;
+            out += 3;
+        } else {
+            /* Surrogate pair */
+            if ((c & 0xFC00) != 0xD800) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
+	    if (inend - in < 4)
+		break;
+            d = in[2] | (in[3] << 8);
+            if ((d & 0xFC00) != 0xDC00) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
+	    if (outend - out < 4)
+		goto done;
+            c = (c << 10) + d - ((0xD800 << 10) + 0xDC00 - 0x10000);
+            out[0] =  (c >> 18)         | 0xF0;
+            out[1] = ((c >> 12) & 0x3F) | 0x80;
+            out[2] = ((c >>  6) & 0x3F) | 0x80;
+            out[3] =  (c        & 0x3F) | 0x80;
+            in += 4;
+            out += 4;
+        }
+    }
+
+    ret = out - outstart;
+
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
+}
+
+#ifdef LIBXML_OUTPUT_ENABLED
+static int
+UTF8ToUTF16LE(unsigned char *out, int *outlen,
+              const unsigned char *in, int *inlen,
+              void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char *instart = in;
+    const unsigned char *inend;
+    unsigned char *outstart = out;
+    unsigned char *outend;
+    unsigned c, d;
+    int ret = XML_ENC_ERR_SPACE;
+
+    /* UTF16LE encoding has no BOM */
+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
+        return(XML_ENC_ERR_INTERNAL);
+    if (in == NULL) {
+	*outlen = 0;
+	*inlen = 0;
+	return(0);
+    }
+    inend = in + *inlen;
+    outend = out + (*outlen & ~1);
+    while (in < inend) {
+        c = in[0];
+
+        if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            out[0] = c;
+            out[1] = 0;
+            in += 1;
+            out += 2;
+        } else {
+            int i, len;
+            unsigned min;
+
+            if (c < 0xE0) {
+                if (c < 0xC2) {
+                    ret = XML_ENC_ERR_INPUT;
+                    goto done;
+                }
+                c &= 0x1F;
+                len = 2;
+                min = 0x80;
+            } else if (c < 0xF0) {
+                c &= 0x0F;
+                len = 3;
+                min = 0x800;
+            } else {
+                c &= 0x0F;
+                len = 4;
+                min = 0x10000;
+            }
+
+            if (inend - in < len)
+                break;
+
+            for (i = 1; i < len; i++) {
+                if ((in[i] & 0xC0) != 0x80) {
+                    ret = XML_ENC_ERR_INPUT;
+                    goto done;
+                }
+                c = (c << 6) | (in[i] & 0x3F);
+            }
+
+            if ((c < min) ||
+                ((c >= 0xD800) && (c <= 0xDFFF)) ||
+                (c > 0x10FFFF)) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
+
+            if (c < 0x10000) {
+                if (out >= outend)
+                    goto done;
+                out[0] = c & 0xFF;
+                out[1] = c >> 8;
+                out += 2;
+            } else {
+                if (outend - out < 4)
+                    goto done;
+                c -= 0x10000;
+                d = (c & 0x03FF) | 0xDC00;
+                c = (c >> 10)    | 0xD800;
+                out[0] = c & 0xFF;
+                out[1] = c >> 8;
+                out[2] = d & 0xFF;
+                out[3] = d >> 8;
+                out += 4;
+            }
+
+            in += len;
+        }
+    }
+
+    ret = out - outstart;
+
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
+}
+
+static int
+UTF8ToUTF16(unsigned char* outb, int *outlen,
+            const unsigned char* in, int *inlen,
+            void *vctxt ATTRIBUTE_UNUSED) {
+    if (in == NULL) {
+	/*
+	 * initialization, add the Byte Order Mark for UTF-16LE
+	 */
+        if (*outlen >= 2) {
+	    outb[0] = 0xFF;
+	    outb[1] = 0xFE;
+	    *outlen = 2;
+	    *inlen = 0;
+	    return(2);
+	}
+	*outlen = 0;
+	*inlen = 0;
+	return(0);
+    }
+    return (UTF8ToUTF16LE(outb, outlen, in, inlen, NULL));
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+static int
+UTF16BEToUTF8(unsigned char *out, int *outlen,
+              const unsigned char *in, int *inlen,
+              void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char *instart = in;
+    const unsigned char *inend = in + (*inlen & ~1);
+    unsigned char *outstart = out;
+    unsigned char *outend = out + *outlen;
+    unsigned c, d;
+    int ret = XML_ENC_ERR_SPACE;
+
+    while (in < inend) {
+        c = (in[0] << 8) | in[1];
+
+        if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            out[0] = c;
+            in += 2;
+            out += 1;
+        } else if (c < 0x800) {
+            if (outend - out < 2)
+                goto done;
+            out[0] = (c >> 6)   | 0xC0;
+            out[1] = (c & 0x3F) | 0x80;
+            in += 2;
+            out += 2;
+        } else if ((c & 0xF800) != 0xD800) {
+            if (outend - out < 3)
+                goto done;
+            out[0] =  (c >> 12)         | 0xE0;
+            out[1] = ((c >>  6) & 0x3F) | 0x80;
+            out[2] =  (c        & 0x3F) | 0x80;
+            in += 2;
+            out += 3;
+        } else {
+            /* Surrogate pair */
+            if ((c & 0xFC00) != 0xD800) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
+	    if (inend - in < 4)
+		break;
+            d = (in[2] << 8) | in[3];
+            if ((d & 0xFC00) != 0xDC00) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
+	    if (outend - out < 4)
+		goto done;
+            c = (c << 10) + d - ((0xD800 << 10) + 0xDC00 - 0x10000);
+            out[0] =  (c >> 18)         | 0xF0;
+            out[1] = ((c >> 12) & 0x3F) | 0x80;
+            out[2] = ((c >>  6) & 0x3F) | 0x80;
+            out[3] =  (c        & 0x3F) | 0x80;
+            in += 4;
+            out += 4;
+        }
+    }
+
+    ret = out - outstart;
+
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
+}
+
+#ifdef LIBXML_OUTPUT_ENABLED
+static int
+UTF8ToUTF16BE(unsigned char *out, int *outlen,
+              const unsigned char *in, int *inlen,
+              void *vctxt ATTRIBUTE_UNUSED) {
+    const unsigned char *instart = in;
+    const unsigned char *inend;
+    unsigned char *outstart = out;
+    unsigned char *outend;
+    unsigned c, d;
+    int ret = XML_ENC_ERR_SPACE;
+
+    /* UTF-16BE has no BOM */
+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);
+    if (in == NULL) {
+	*outlen = 0;
+	*inlen = 0;
+	return(0);
+    }
+    inend = in + *inlen;
+    outend = out + (*outlen & ~1);
+    while (in < inend) {
+        c = in[0];
+
+        if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            out[0] = 0;
+            out[1] = c;
+            in += 1;
+            out += 2;
+        } else {
+            int i, len;
+            unsigned min;
+
+            if (c < 0xE0) {
+                if (c < 0xC2) {
+                    ret = XML_ENC_ERR_INPUT;
+                    goto done;
+                }
+                c &= 0x1F;
+                len = 2;
+                min = 0x80;
+            } else if (c < 0xF0) {
+                c &= 0x0F;
+                len = 3;
+                min = 0x800;
+            } else {
+                c &= 0x0F;
+                len = 4;
+                min = 0x10000;
+            }
+
+            if (inend - in < len)
+                break;
+
+            for (i = 1; i < len; i++) {
+                if ((in[i] & 0xC0) != 0x80) {
+                    ret = XML_ENC_ERR_INPUT;
+                    goto done;
+                }
+                c = (c << 6) | (in[i] & 0x3F);
+            }
 
-/**
- * xmlCharEncCloseFunc:
- * @handler:	char encoding transformation data structure
- *
- * Generic front-end for encoding handler close function
- *
- * Returns 0 if success, or -1 in case of error
- */
-int
-xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
-    int ret = 0;
-    int tofree = 0;
-    int i = 0;
+            if ((c < min) ||
+                ((c >= 0xD800) && (c <= 0xDFFF)) ||
+                (c > 0x10FFFF)) {
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
+            }
 
-    if (handler == NULL) return(-1);
+            if (c < 0x10000) {
+                if (out >= outend)
+                    goto done;
+                out[0] = c >> 8;
+                out[1] = c & 0xFF;
+                out += 2;
+            } else {
+                if (outend - out < 4)
+                    goto done;
+                c -= 0x10000;
+                d = (c & 0x03FF) | 0xDC00;
+                c = (c >> 10)    | 0xD800;
+                out[0] = c >> 8;
+                out[1] = c & 0xFF;
+                out[2] = d >> 8;
+                out[3] = d & 0xFF;
+                out += 4;
+            }
 
-    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
-        if (handler == &defaultHandlers[i])
-            return(0);
+            in += len;
+        }
     }
 
-    if (handlers != NULL) {
-        for (i = 0;i < nbCharEncodingHandler; i++) {
-            if (handler == handlers[i])
-                return(0);
-	}
-    }
-#ifdef LIBXML_ICONV_ENABLED
-    /*
-     * Iconv handlers can be used only once, free the whole block.
-     * and the associated icon resources.
-     */
-    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
-        tofree = 1;
-	if (handler->iconv_out != NULL) {
-	    if (iconv_close(handler->iconv_out))
-		ret = -1;
-	    handler->iconv_out = NULL;
-	}
-	if (handler->iconv_in != NULL) {
-	    if (iconv_close(handler->iconv_in))
-		ret = -1;
-	    handler->iconv_in = NULL;
-	}
-    }
-#endif /* LIBXML_ICONV_ENABLED */
-#ifdef LIBXML_ICU_ENABLED
-    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
-        tofree = 1;
-	if (handler->uconv_out != NULL) {
-	    closeIcuConverter(handler->uconv_out);
-	    handler->uconv_out = NULL;
-	}
-	if (handler->uconv_in != NULL) {
-	    closeIcuConverter(handler->uconv_in);
-	    handler->uconv_in = NULL;
-	}
-    }
-#endif
-    if (tofree) {
-        /* free up only dynamic handlers iconv/uconv */
-        if (handler->name != NULL)
-            xmlFree(handler->name);
-        handler->name = NULL;
-        xmlFree(handler);
-    }
+    ret = out - outstart;
 
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
     return(ret);
 }
+#endif /* LIBXML_OUTPUT_ENABLED */
 
-/**
- * xmlByteConsumed:
- * @ctxt: an XML parser context
- *
- * This function provides the current index of the parser relative
- * to the start of the current entity. This function is computed in
- * bytes from the beginning starting at zero and finishing at the
- * size in byte of the file if parsing a file. The function is
- * of constant cost if the input is UTF-8 but can be costly if run
- * on non-UTF-8 input.
- *
- * Returns the index in bytes from the beginning of the entity or -1
- *         in case the index could not be computed.
- */
-long
-xmlByteConsumed(xmlParserCtxtPtr ctxt) {
-    xmlParserInputPtr in;
-
-    if (ctxt == NULL) return(-1);
-    in = ctxt->input;
-    if (in == NULL)  return(-1);
-    if ((in->buf != NULL) && (in->buf->encoder != NULL)) {
-        unsigned int unused = 0;
-	xmlCharEncodingHandler * handler = in->buf->encoder;
-        /*
-	 * Encoding conversion, compute the number of unused original
-	 * bytes from the input not consumed and subtract that from
-	 * the raw consumed value, this is not a cheap operation
-	 */
-        if (in->end - in->cur > 0) {
-	    unsigned char convbuf[32000];
-	    const unsigned char *cur = (const unsigned char *)in->cur;
-	    int toconv = in->end - in->cur, written = 32000;
-
-	    int ret;
-
-            do {
-                toconv = in->end - cur;
-                written = 32000;
-                ret = xmlEncOutputChunk(handler, &convbuf[0], &written,
-                                        cur, &toconv);
-                if ((ret != XML_ENC_ERR_SUCCESS) && (ret != XML_ENC_ERR_SPACE))
-                    return(-1);
-                unused += written;
-                cur += toconv;
-            } while (ret == XML_ENC_ERR_SPACE);
-	}
-	if (in->buf->rawconsumed < unused)
-	    return(-1);
-	return(in->buf->rawconsumed - unused);
-    }
-    return(in->consumed + (in->cur - in->base));
+#if defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTML_ENABLED)
+static int
+UTF8ToHtmlWrapper(unsigned char *out, int *outlen,
+                  const unsigned char *in, int *inlen,
+                  void *vctxt ATTRIBUTE_UNUSED) {
+    return(UTF8ToHtml(out, outlen, in, inlen));
 }
+#endif
 
-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)
-#ifdef LIBXML_ISO8859X_ENABLED
+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \
+    defined(LIBXML_ISO8859X_ENABLED)
 
-/**
- * UTF8ToISO8859x:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of UTF-8 chars
- * @inlen:  the length of @in
- * @xlattable: the 2-level transcoding table
- *
- * Take a block of UTF-8 chars in and try to convert it to an ISO 8859-*
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- * as the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
- */
 static int
-UTF8ToISO8859x(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen,
-              const unsigned char* const xlattable) {
-    const unsigned char* outstart = out;
-    const unsigned char* inend;
-    const unsigned char* instart = in;
-    const unsigned char* processed = in;
+UTF8ToISO8859x(unsigned char *out, int *outlen,
+               const unsigned char *in, int *inlen, void *vctxt) {
+    const unsigned char *xlattable = vctxt;
+    const unsigned char *instart = in;
+    const unsigned char *inend;
+    unsigned char *outstart = out;
+    unsigned char *outend;
+    int ret = XML_ENC_ERR_SPACE;
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) ||
-        (xlattable == NULL))
-	return(XML_ENC_ERR_INTERNAL);
     if (in == NULL) {
         /*
         * initialization nothing to do
         */
         *outlen = 0;
         *inlen = 0;
-        return(0);
+        return(XML_ENC_ERR_SUCCESS);
     }
-    inend = in + (*inlen);
+
+    inend = in + *inlen;
+    outend = out + *outlen;
     while (in < inend) {
-        unsigned char d = *in++;
+        unsigned d = *in;
+
         if  (d < 0x80)  {
-            *out++ = d;
-        } else if (d < 0xC0) {
-            /* trailing byte in leading position */
-            *outlen = out - outstart;
-            *inlen = processed - instart;
-            return(XML_ENC_ERR_INPUT);
+            if (out >= outend)
+                goto done;
+            in += 1;
         } else if (d < 0xE0) {
-            unsigned char c;
-            if (!(in < inend)) {
-                /* trailing byte not in input buffer */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_PARTIAL);
-            }
-            c = *in++;
-            if ((c & 0xC0) != 0x80) {
-                /* not a trailing byte */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_INPUT);
-            }
-            c = c & 0x3F;
+            unsigned c;
+
+            if (inend - in < 2)
+                break;
+            c = in[1] & 0x3F;
             d = d & 0x1F;
             d = xlattable [48 + c + xlattable [d] * 64];
             if (d == 0) {
                 /* not in character set */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_INPUT);
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
             }
-            *out++ = d;
+            if (out >= outend)
+                goto done;
+            in += 2;
         } else if (d < 0xF0) {
-            unsigned char c1;
-            unsigned char c2;
-            if (!(in < inend - 1)) {
-                /* trailing bytes not in input buffer */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_PARTIAL);
-            }
-            c1 = *in++;
-            if ((c1 & 0xC0) != 0x80) {
-                /* not a trailing byte (c1) */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_INPUT);
-            }
-            c2 = *in++;
-            if ((c2 & 0xC0) != 0x80) {
-                /* not a trailing byte (c2) */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_INPUT);
-            }
-            c1 = c1 & 0x3F;
-            c2 = c2 & 0x3F;
+            unsigned c1;
+            unsigned c2;
+
+            if (inend - in < 3)
+                break;
+            c1 = in[1] & 0x3F;
+            c2 = in[2] & 0x3F;
 	    d = d & 0x0F;
 	    d = xlattable [48 + c2 + xlattable [48 + c1 +
 			xlattable [32 + d] * 64] * 64];
             if (d == 0) {
                 /* not in character set */
-                *outlen = out - outstart;
-                *inlen = processed - instart;
-                return(XML_ENC_ERR_INPUT);
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
             }
-            *out++ = d;
+            if (out >= outend)
+                goto done;
+            in += 3;
         } else {
             /* cannot transcode >= U+010000 */
-            *outlen = out - outstart;
-            *inlen = processed - instart;
-            return(XML_ENC_ERR_INPUT);
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
         }
-        processed = in;
+
+        *out++ = d;
     }
+
+    ret = out - outstart;
+
+done:
     *outlen = out - outstart;
-    *inlen = processed - instart;
-    return(*outlen);
+    *inlen = in - instart;
+    return(ret);
 }
 
-/**
- * ISO8859xToUTF8
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of ISO Latin 1 chars
- * @inlen:  the length of @in
- *
- * Take a block of ISO 8859-* chars in and try to convert it to an UTF-8
- * block of chars out.
- *
- * Returns the number of bytes written or an XML_ENC_ERR code.
- *
- * The value of @inlen after return is the number of octets consumed
- * The value of @outlen after return is the number of octets produced.
- */
 static int
 ISO8859xToUTF8(unsigned char* out, int *outlen,
-              const unsigned char* in, int *inlen,
-              unsigned short const *unicodetable) {
-    unsigned char* outstart = out;
-    unsigned char* outend;
+               const unsigned char* in, int *inlen, void *vctxt) {
+    unsigned short const *unicodetable = vctxt;
     const unsigned char* instart = in;
     const unsigned char* inend;
-    const unsigned char* instop;
-    unsigned int c;
+    unsigned char* outstart = out;
+    unsigned char* outend;
+    int ret = XML_ENC_ERR_SPACE;
 
-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) ||
-        (in == NULL) || (unicodetable == NULL))
-	return(XML_ENC_ERR_INTERNAL);
     outend = out + *outlen;
     inend = in + *inlen;
-    instop = inend;
 
-    while ((in < inend) && (out < outend - 2)) {
-        if (*in >= 0x80) {
-            c = unicodetable [*in - 0x80];
+    while (in < inend) {
+        unsigned c = *in;
+
+        if (c < 0x80) {
+            if (out >= outend)
+                goto done;
+            *out++ = c;
+        } else {
+            c = unicodetable[c - 0x80];
             if (c == 0) {
                 /* undefined code point */
-                *outlen = out - outstart;
-                *inlen = in - instart;
-                return(XML_ENC_ERR_INPUT);
+                ret = XML_ENC_ERR_INPUT;
+                goto done;
             }
             if (c < 0x800) {
+                if (outend - out < 2)
+                    goto done;
                 *out++ = ((c >>  6) & 0x1F) | 0xC0;
                 *out++ = (c & 0x3F) | 0x80;
             } else {
+                if (outend - out < 3)
+                    goto done;
                 *out++ = ((c >>  12) & 0x0F) | 0xE0;
                 *out++ = ((c >>  6) & 0x3F) | 0x80;
                 *out++ = (c & 0x3F) | 0x80;
             }
-            ++in;
         }
-        if (instop - in > outend - out) instop = in + (outend - out);
-        while ((*in < 0x80) && (in < instop)) {
-            *out++ = *in++;
-        }
-    }
-    if ((in < inend) && (out < outend) && (*in < 0x80)) {
-        *out++ =  *in++;
-    }
-    if ((in < inend) && (out < outend) && (*in < 0x80)) {
-        *out++ =  *in++;
-    }
-    *outlen = out - outstart;
-    *inlen = in - instart;
-    return (*outlen);
-}
-
-
-/************************************************************************
- * Lookup tables for ISO-8859-2..ISO-8859-16 transcoding                *
- ************************************************************************/
-
-static const unsigned short xmlunicodetable_ISO8859_2 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7,
-    0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
-    0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7,
-    0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
-    0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
-    0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
-    0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
-    0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
-    0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
-    0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_2 [48 + 6 * 64] = {
-    "\x00\x00\x01\x05\x02\x04\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\x00"
-    "\xb0\x00\x00\x00\xb4\x00\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xc3\xe3\xa1\xb1\xc6\xe6\x00\x00\x00\x00\xc8\xe8\xcf\xef"
-    "\xd0\xf0\x00\x00\x00\x00\x00\x00\xca\xea\xcc\xec\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc5\xe5\x00\x00\xa5\xb5\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\xa2\xff\x00\xb2\x00\xbd\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\xa3\xb3\xd1\xf1\x00\x00\xd2\xf2\x00\x00\x00\x00\x00\x00\x00"
-    "\xd5\xf5\x00\x00\xc0\xe0\x00\x00\xd8\xf8\xa6\xb6\x00\x00\xaa\xba"
-    "\xa9\xb9\xde\xfe\xab\xbb\x00\x00\x00\x00\x00\x00\x00\x00\xd9\xf9"
-    "\xdb\xfb\x00\x00\x00\x00\x00\x00\x00\xac\xbc\xaf\xbf\xae\xbe\x00"
-    "\x00\xc1\xc2\x00\xc4\x00\x00\xc7\x00\xc9\x00\xcb\x00\xcd\xce\x00"
-    "\x00\x00\x00\xd3\xd4\x00\xd6\xd7\x00\x00\xda\x00\xdc\xdd\x00\xdf"
-    "\x00\xe1\xe2\x00\xe4\x00\x00\xe7\x00\xe9\x00\xeb\x00\xed\xee\x00"
-    "\x00\x00\x00\xf3\xf4\x00\xf6\xf7\x00\x00\xfa\x00\xfc\xfd\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_3 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4, 0x0000, 0x0124, 0x00a7,
-    0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0x0000, 0x017b,
-    0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7,
-    0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd, 0x0000, 0x017c,
-    0x00c0, 0x00c1, 0x00c2, 0x0000, 0x00c4, 0x010a, 0x0108, 0x00c7,
-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
-    0x0000, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7,
-    0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,
-    0x00e0, 0x00e1, 0x00e2, 0x0000, 0x00e4, 0x010b, 0x0109, 0x00e7,
-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
-    0x0000, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7,
-    0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_3 [48 + 7 * 64] = {
-    "\x04\x00\x01\x06\x02\x05\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\xa3\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\x00"
-    "\xb0\x00\xb2\xb3\xb4\xb5\x00\xb7\xb8\x00\x00\x00\x00\xbd\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\xc6\xe6\xc5\xe5\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd8\xf8\xab\xbb"
-    "\xd5\xf5\x00\x00\xa6\xb6\xa1\xb1\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xa9\xb9\x00\x00\xac\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\xa2\xff\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xfe\xaa\xba"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdd\xfd\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xaf\xbf\x00\x00\x00"
-    "\xc0\xc1\xc2\x00\xc4\x00\x00\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\x00\xd1\xd2\xd3\xd4\x00\xd6\xd7\x00\xd9\xda\xdb\xdc\x00\x00\xdf"
-    "\xe0\xe1\xe2\x00\xe4\x00\x00\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\x00\xf1\xf2\xf3\xf4\x00\xf6\xf7\x00\xf9\xfa\xfb\xfc\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_4 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7,
-    0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af,
-    0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7,
-    0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,
-    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,
-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,
-    0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
-    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,
-    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,
-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,
-    0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
-    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_4 [48 + 6 * 64] = {
-    "\x00\x00\x01\x05\x02\x03\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\xaf"
-    "\xb0\x00\x00\x00\xb4\x00\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
-    "\xc0\xe0\x00\x00\xa1\xb1\x00\x00\x00\x00\x00\x00\xc8\xe8\x00\x00"
-    "\xd0\xf0\xaa\xba\x00\x00\xcc\xec\xca\xea\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xab\xbb\x00\x00\x00\x00\xa5\xb5\xcf\xef\x00\x00\xc7\xe7"
-    "\x00\x00\x00\x00\x00\x00\xd3\xf3\xa2\x00\x00\xa6\xb6\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\xd1\xf1\x00\x00\x00\xbd\xbf\xd2\xf2\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\xa3\xb3\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xa9\xb9\x00\x00\x00\x00\xac\xbc\xdd\xfd\xde\xfe\x00\x00\x00\x00"
-    "\x00\x00\xd9\xf9\x00\x00\x00\x00\x00\x00\x00\x00\x00\xae\xbe\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\xb2\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\x00\x00\xc9\x00\xcb\x00\xcd\xce\x00"
-    "\x00\x00\x00\x00\xd4\xd5\xd6\xd7\xd8\x00\xda\xdb\xdc\x00\x00\xdf"
-    "\x00\xe1\xe2\xe3\xe4\xe5\xe6\x00\x00\xe9\x00\xeb\x00\xed\xee\x00"
-    "\x00\x00\x00\x00\xf4\xf5\xf6\xf7\xf8\x00\xfa\xfb\xfc\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_5 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407,
-    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 0x040f,
-    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
-    0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f,
-    0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
-    0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f,
-    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
-    0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f,
-    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
-    0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f,
-    0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
-    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x00a7, 0x045e, 0x045f,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_5 [48 + 6 * 64] = {
-    "\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x02\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\x00\x00\x00\xfd\x00\x00\x00\x00\x00\xad\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\x00\xae\xaf"
-    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\x00\xfe\xff"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_6 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0000, 0x0000, 0x0000, 0x00a4, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x060c, 0x00ad, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x061b, 0x0000, 0x0000, 0x0000, 0x061f,
-    0x0000, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
-    0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f,
-    0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637,
-    0x0638, 0x0639, 0x063a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647,
-    0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f,
-    0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_6 [48 + 5 * 64] = {
-    "\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x04\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\xa4\x00\x00\x00\x00\x00\x00\x00\x00\xad\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbb\x00\x00\x00\xbf"
-    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\x00\x00\x00\x00\x00"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\xf0\xf1\xf2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_7 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x2018, 0x2019, 0x00a3, 0x0000, 0x0000, 0x00a6, 0x00a7,
-    0x00a8, 0x00a9, 0x0000, 0x00ab, 0x00ac, 0x00ad, 0x0000, 0x2015,
-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 0x0386, 0x00b7,
-    0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 0x00bd, 0x038e, 0x038f,
-    0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
-    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
-    0x03a0, 0x03a1, 0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
-    0x03a8, 0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af,
-    0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
-    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
-    0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
-    0x03c8, 0x03c9, 0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0x0000,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_7 [48 + 7 * 64] = {
-    "\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x06"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\xa3\x00\x00\xa6\xa7\xa8\xa9\x00\xab\xac\xad\x00\x00"
-    "\xb0\xb1\xb2\xb3\x00\x00\x00\xb7\x00\x00\x00\xbb\x00\xbd\x00\x00"
-    "\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\xaf\x00\x00\xa1\xa2\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\xb4\xb5\xb6\x00\xb8\xb9\xba\x00\xbc\x00\xbe\xbf"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\xd0\xd1\x00\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_8 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0000, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
-    0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
-    0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017,
-    0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7,
-    0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df,
-    0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7,
-    0x05e8, 0x05e9, 0x05ea, 0x0000, 0x0000, 0x200e, 0x200f, 0x0000,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_8 [48 + 7 * 64] = {
-    "\x02\x00\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\x00\xab\xac\xad\xae\xaf"
-    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\x00\xbb\xbc\xbd\xbe\x00"
-    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\xaa\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\xba\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfd\xfe"
-    "\x00\x00\x00\x00\x00\x00\x00\xdf\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_9 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
-    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
-    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
-    0x011e, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df,
-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
-    0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0131, 0x015f, 0x00ff,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_9 [48 + 5 * 64] = {
-    "\x00\x00\x01\x02\x03\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
-    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\x00\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\x00\x00\xdf"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\x00\x00\xff"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xf0"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xdd\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xfe"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_10 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7,
-    0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 0x014a,
-    0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 0x0137, 0x00b7,
-    0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 0x2015, 0x016b, 0x014b,
-    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,
-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf,
-    0x00d0, 0x0145, 0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168,
-    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
-    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,
-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x00ef,
-    0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x0169,
-    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x0138,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_10 [48 + 7 * 64] = {
-    "\x00\x00\x01\x06\x02\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\x00\x00\x00\xa7\x00\x00\x00\x00\x00\xad\x00\x00"
-    "\xb0\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xc0\xe0\x00\x00\xa1\xb1\x00\x00\x00\x00\x00\x00\xc8\xe8\x00\x00"
-    "\xa9\xb9\xa2\xb2\x00\x00\xcc\xec\xca\xea\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xa3\xb3\x00\x00\x00\x00\xa5\xb5\xa4\xb4\x00\x00\xc7\xe7"
-    "\x00\x00\x00\x00\x00\x00\xa6\xb6\xff\x00\x00\xa8\xb8\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\xd1\xf1\x00\x00\x00\xaf\xbf\xd2\xf2\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xaa\xba\x00\x00\x00\x00\xab\xbb\xd7\xf7\xae\xbe\x00\x00\x00\x00"
-    "\x00\x00\xd9\xf9\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\xbc\x00"
-    "\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\xbd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\x00\x00\xc9\x00\xcb\x00\xcd\xce\xcf"
-    "\xd0\x00\x00\xd3\xd4\xd5\xd6\x00\xd8\x00\xda\xdb\xdc\xdd\xde\xdf"
-    "\x00\xe1\xe2\xe3\xe4\xe5\xe6\x00\x00\xe9\x00\xeb\x00\xed\xee\xef"
-    "\xf0\x00\x00\xf3\xf4\xf5\xf6\x00\xf8\x00\xfa\xfb\xfc\xfd\xfe\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_11 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07,
-    0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f,
-    0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17,
-    0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f,
-    0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27,
-    0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f,
-    0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37,
-    0x0e38, 0x0e39, 0x0e3a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0e3f,
-    0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47,
-    0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f,
-    0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57,
-    0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0x0000, 0x0000, 0x0000, 0x0000,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_11 [48 + 6 * 64] = {
-    "\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x05\x00\x00\x00\x00\x00\x00"
-    "\x00\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
-    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\x00\x00\x00\x00\xdf"
-    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_13 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7,
-    0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00c6,
-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 0x00b6, 0x00b7,
-    0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00e6,
-    0x0104, 0x012e, 0x0100, 0x0106, 0x00c4, 0x00c5, 0x0118, 0x0112,
-    0x010c, 0x00c9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012a, 0x013b,
-    0x0160, 0x0143, 0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7,
-    0x0172, 0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df,
-    0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 0x0113,
-    0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 0x012b, 0x013c,
-    0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 0x00f5, 0x00f6, 0x00f7,
-    0x0173, 0x0142, 0x015b, 0x016b, 0x00fc, 0x017c, 0x017e, 0x2019,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_13 [48 + 7 * 64] = {
-    "\x00\x00\x01\x04\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\xa2\xa3\xa4\x00\xa6\xa7\x00\xa9\x00\xab\xac\xad\xae\x00"
-    "\xb0\xb1\xb2\xb3\x00\xb5\xb6\xb7\x00\xb9\x00\xbb\xbc\xbd\xbe\x00"
-    "\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xb4\xa1\xa5\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\xc4\xc5\xaf\x00\x00\xc9\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\xd3\x00\xd5\xd6\xd7\xa8\x00\x00\x00\xdc\x00\x00\xdf"
-    "\x00\x00\x00\x00\xe4\xe5\xbf\x00\x00\xe9\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\xf3\x00\xf5\xf6\xf7\xb8\x00\x00\x00\xfc\x00\x00\x00"
-    "\x00\xd9\xf9\xd1\xf1\xd2\xf2\x00\x00\x00\x00\x00\xd4\xf4\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\xaa\xba\x00\x00\xda\xfa\x00\x00\x00\x00"
-    "\xd0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xfb\x00\x00\x00\x00"
-    "\x00\x00\xd8\xf8\x00\x00\x00\x00\x00\xca\xea\xdd\xfd\xde\xfe\x00"
-    "\xc2\xe2\x00\x00\xc0\xe0\xc3\xe3\x00\x00\x00\x00\xc8\xe8\x00\x00"
-    "\x00\x00\xc7\xe7\x00\x00\xcb\xeb\xc6\xe6\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xcc\xec\x00\x00\x00\x00\x00\x00\xce\xee\x00\x00\xc1\xe1"
-    "\x00\x00\x00\x00\x00\x00\xcd\xed\x00\x00\x00\xcf\xef\x00\x00\x00"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_14 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7,
-    0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 0x0178,
-    0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 0x00b6, 0x1e56,
-    0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 0x1e84, 0x1e85, 0x1e61,
-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
-    0x0174, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a,
-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00df,
-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
-    0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x1e6b,
-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x0177, 0x00ff,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_14 [48 + 10 * 64] = {
-    "\x00\x00\x01\x09\x04\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\xa3\x00\x00\x00\xa7\x00\xa9\x00\x00\x00\xad\xae\x00"
-    "\x00\x00\x00\x00\x00\x00\xb6\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x08\x05\x06\x00\x00\x00\x00"
-    "\x00\x00\xa1\xa2\x00\x00\x00\x00\x00\x00\xa6\xab\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb0\xb1"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\xa5\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xb2\xb3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xa8\xb8\xaa\xba\xbd\xbe\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xac\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\xd0\xf0\xde\xfe\xaf\x00\x00\x00\x00\x00\x00\x00"
-    "\xb4\xb5\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\xb7\xb9\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xbb\xbf\x00\x00\x00\x00\x00\x00\x00\x00\xd7\xf7\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\x00\xd1\xd2\xd3\xd4\xd5\xd6\x00\xd8\xd9\xda\xdb\xdc\xdd\x00\xdf"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\x00\xf8\xf9\xfa\xfb\xfc\xfd\x00\xff"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_15 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7,
-    0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 0x00b6, 0x00b7,
-    0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 0x0153, 0x0178, 0x00bf,
-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
-    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
-    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_15 [48 + 6 * 64] = {
-    "\x00\x00\x01\x05\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\xa1\xa2\xa3\x00\xa5\x00\xa7\x00\xa9\xaa\xab\xac\xad\xae\xaf"
-    "\xb0\xb1\xb2\xb3\x00\xb5\xb6\xb7\x00\xb9\xba\xbb\x00\x00\x00\xbf"
-    "\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\xbc\xbd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xa6\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\xbe\x00\x00\x00\x00\xb4\xb8\x00"
-    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
-    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
-};
-
-static const unsigned short xmlunicodetable_ISO8859_16 [128] = {
-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
-    0x00a0, 0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7,
-    0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 0x017b,
-    0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 0x00b6, 0x00b7,
-    0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 0x0153, 0x0178, 0x017c,
-    0x00c0, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0106, 0x00c6, 0x00c7,
-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
-    0x0110, 0x0143, 0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a,
-    0x0170, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df,
-    0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 0x00e7,
-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
-    0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x015b,
-    0x0171, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0119, 0x021b, 0x00ff,
-};
-
-static const unsigned char xmltranscodetable_ISO8859_16 [48 + 9 * 64] = {
-    "\x00\x00\x01\x08\x02\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
-    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
-    "\xa0\x00\x00\x00\x00\x00\x00\xa7\x00\xa9\x00\xab\x00\xad\x00\x00"
-    "\xb0\xb1\x00\x00\x00\x00\xb6\xb7\x00\x00\x00\xbb\x00\x00\x00\x00"
-    "\x00\x00\xc3\xe3\xa1\xa2\xc5\xe5\x00\x00\x00\x00\xb2\xb9\x00\x00"
-    "\xd0\xf0\x00\x00\x00\x00\x00\x00\xdd\xfd\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\xa3\xb3\xd1\xf1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xd5\xf5\xbc\xbd\x00\x00\x00\x00\x00\x00\xd7\xf7\x00\x00\x00\x00"
-    "\xa6\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xd8\xf8\x00\x00\x00\x00\x00\x00\xbe\xac\xae\xaf\xbf\xb4\xb8\x00"
-    "\x06\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb5\xa5\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\xaa\xba\xde\xfe\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-    "\xc0\xc1\xc2\x00\xc4\x00\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
-    "\x00\x00\xd2\xd3\xd4\x00\xd6\x00\x00\xd9\xda\xdb\xdc\x00\x00\xdf"
-    "\xe0\xe1\xe2\x00\xe4\x00\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
-    "\x00\x00\xf2\xf3\xf4\x00\xf6\x00\x00\xf9\xfa\xfb\xfc\x00\x00\xff"
-};
-
-
-/*
- * auto-generated functions for ISO-8859-2 .. ISO-8859-16
- */
-
-static int ISO8859_2ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_2);
-}
-static int UTF8ToISO8859_2 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_2);
-}
-
-static int ISO8859_3ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_3);
-}
-static int UTF8ToISO8859_3 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_3);
-}
-
-static int ISO8859_4ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_4);
-}
-static int UTF8ToISO8859_4 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_4);
-}
-
-static int ISO8859_5ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_5);
-}
-static int UTF8ToISO8859_5 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_5);
-}
-
-static int ISO8859_6ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_6);
-}
-static int UTF8ToISO8859_6 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_6);
-}
-
-static int ISO8859_7ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_7);
-}
-static int UTF8ToISO8859_7 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_7);
-}
-
-static int ISO8859_8ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_8);
-}
-static int UTF8ToISO8859_8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_8);
-}
-
-static int ISO8859_9ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_9);
-}
-static int UTF8ToISO8859_9 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_9);
-}
-
-static int ISO8859_10ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_10);
-}
-static int UTF8ToISO8859_10 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_10);
-}
 
-static int ISO8859_11ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_11);
-}
-static int UTF8ToISO8859_11 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_11);
-}
-
-static int ISO8859_13ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_13);
-}
-static int UTF8ToISO8859_13 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_13);
-}
-
-static int ISO8859_14ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_14);
-}
-static int UTF8ToISO8859_14 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_14);
-}
+        in += 1;
+    }
 
-static int ISO8859_15ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_15);
-}
-static int UTF8ToISO8859_15 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_15);
-}
+    ret = out - outstart;
 
-static int ISO8859_16ToUTF8 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_16);
-}
-static int UTF8ToISO8859_16 (unsigned char* out, int *outlen,
-    const unsigned char* in, int *inlen) {
-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_16);
+done:
+    *outlen = out - outstart;
+    *inlen = in - instart;
+    return(ret);
 }
 
 #endif
-#endif
 
diff --git a/entities.c b/entities.c
index f7792a81..3b36a2da 100644
--- a/entities.c
+++ b/entities.c
@@ -512,204 +512,254 @@ xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {
     return(xmlGetPredefinedEntity(name));
 }
 
-/*
- * Macro used to grow the current buffer.
- */
-#define growBufferReentrant() {						\
-    xmlChar *tmp;                                                       \
-    size_t new_size = buffer_size * 2;                                  \
-    if (new_size < buffer_size) goto mem_error;                         \
-    tmp = (xmlChar *) xmlRealloc(buffer, new_size);	                \
-    if (tmp == NULL) goto mem_error;                                    \
-    buffer = tmp;							\
-    buffer_size = new_size;						\
+int
+xmlSerializeHexCharRef(char *buf, int val) {
+    char *out = buf;
+    int shift = 0, bits;
+
+    *out++ = '&';
+    *out++ = '#';
+    *out++ = 'x';
+
+    bits = val;
+    if (bits & 0xFF0000) {
+        shift = 16;
+        bits &= 0xFF0000;
+    } else if (bits & 0x00FF00) {
+        shift = 8;
+        bits &= 0x00FF00;
+    }
+    if (bits & 0xF0F0F0) {
+        shift += 4;
+    }
+
+    do {
+        int d = (val >> shift) & 0x0F;
+
+        if (d < 10)
+            *out++ = '0' + d;
+        else
+            *out++ = 'A' + (d - 10);
+
+	shift -= 4;
+    } while (shift >= 0);
+
+    *out++ = ';';
+
+    return(out - buf);
 }
 
-/**
- * xmlEncodeEntitiesInternal:
- * @doc:  the document containing the string
- * @input:  A string to convert to XML.
- * @attr: are we handling an attribute value
- *
- * Do a global encoding of a string, replacing the predefined entities
- * and non ASCII values with their entities and CharRef counterparts.
- * Contrary to xmlEncodeEntities, this routine is reentrant, and result
- * must be deallocated.
- *
- * Returns A newly allocated string with the substitution done.
- */
-static xmlChar *
-xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {
-    const xmlChar *cur = input;
-    xmlChar *buffer = NULL;
-    xmlChar *out = NULL;
-    size_t buffer_size = 0;
-    int html = 0;
-
-    if (input == NULL) return(NULL);
-    if (doc != NULL)
-        html = (doc->type == XML_HTML_DOCUMENT_NODE);
+int
+xmlSerializeDecCharRef(char *buf, int val) {
+    char *out = buf;
+    int len, i;
+
+    *out++ = '&';
+    *out++ = '#';
+
+    if (val < 100) {
+        len = (val < 10) ? 1 : 2;
+    } else if (val < 10000) {
+        len = (val < 1000) ? 3 : 4;
+    } else if (val < 1000000) {
+        len = (val < 100000) ? 5 : 6;
+    } else {
+        len = 7;
+    }
 
-    /*
-     * allocate an translation buffer.
-     */
-    buffer_size = 1000;
-    buffer = (xmlChar *) xmlMalloc(buffer_size);
-    if (buffer == NULL)
-	return(NULL);
-    out = buffer;
+    for (i = len - 1; i >= 0; i--) {
+        out[i] = '0' + val % 10;
+        val /= 10;
+    }
 
-    while (*cur != '\0') {
-        size_t indx = out - buffer;
-        if (indx + 100 > buffer_size) {
+    out[len] = ';';
 
-	    growBufferReentrant();
-	    out = &buffer[indx];
-	}
+    return(len + 3);
+}
 
-	/*
-	 * By default one have to encode at least '<', '>', '"' and '&' !
-	 */
-	if (*cur == '<') {
-	    const xmlChar *end;
+static const char xmlEscapeSafe[128] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
+};
+
+xmlChar *
+xmlEscapeText(const xmlChar *text, int flags) {
+    const xmlChar *cur;
+    xmlChar *buffer;
+    xmlChar *out;
+    const xmlChar *unescaped;
+    size_t size = 50;
+
+    buffer = xmlMalloc(size + 1);
+    if (buffer == NULL)
+        return(NULL);
+    out = buffer;
+
+    cur = text;
+    unescaped = cur;
 
+    while (*cur != '\0') {
+        char buf[12];
+	const xmlChar *end;
+        const xmlChar *repl;
+        size_t used;
+        size_t replSize;
+        size_t unescapedSize;
+        size_t totalSize;
+        int chunkSize = 1;
+        int c;
+
+        /* accelerator */
+	while (1) {
+            c = *cur;
+
+            if (c < 0x80) {
+                if (!xmlEscapeSafe[*cur])
+                    break;
+            } else {
+               if (flags & XML_ESCAPE_NON_ASCII)
+                   break;
+            }
+            cur += 1;
+        }
+
+        if (c == 0) {
+            chunkSize = 0;
+            repl = BAD_CAST "";
+            replSize = 0;
+        } else if (c == '<') {
 	    /*
 	     * Special handling of server side include in HTML attributes
 	     */
-	    if (html && attr &&
+	    if ((flags & XML_ESCAPE_HTML) && (flags & XML_ESCAPE_ATTR) &&
 	        (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&
 	        ((end = xmlStrstr(cur, BAD_CAST "-->")) != NULL)) {
-	        while (cur != end) {
-		    *out++ = *cur++;
-		    indx = out - buffer;
-		    if (indx + 100 > buffer_size) {
-			growBufferReentrant();
-			out = &buffer[indx];
-		    }
-		}
-		*out++ = *cur++;
-		*out++ = *cur++;
-		*out++ = *cur++;
-		continue;
-	    }
-	    *out++ = '&';
-	    *out++ = 'l';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*cur == '>') {
-	    *out++ = '&';
-	    *out++ = 'g';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*cur == '&') {
+                chunkSize = (end - cur) + 3;
+                repl = cur;
+                replSize = chunkSize;
+	    } else {
+                repl = BAD_CAST "&lt;";
+                replSize = 4;
+            }
+	} else if (c == '>') {
+            repl = BAD_CAST "&gt;";
+            replSize = 4;
+	} else if (c == '&') {
 	    /*
 	     * Special handling of &{...} construct from HTML 4, see
 	     * http://www.w3.org/TR/html401/appendix/notes.html#h-B.7.1
 	     */
-	    if (html && attr && (cur[1] == '{') &&
-	        (strchr((const char *) cur, '}'))) {
-	        while (*cur != '}') {
-		    *out++ = *cur++;
-		    indx = out - buffer;
-		    if (indx + 100 > buffer_size) {
-			growBufferReentrant();
-			out = &buffer[indx];
-		    }
-		}
-		*out++ = *cur++;
-		continue;
-	    }
-	    *out++ = '&';
-	    *out++ = 'a';
-	    *out++ = 'm';
-	    *out++ = 'p';
-	    *out++ = ';';
-	} else if (((*cur >= 0x20) && (*cur < 0x80)) ||
-	    (*cur == '\n') || (*cur == '\t') || ((html) && (*cur == '\r'))) {
-	    /*
-	     * default case, just copy !
-	     */
-	    *out++ = *cur;
-	} else if (*cur >= 0x80) {
-	    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {
-		/*
-		 * Bjrn Reese <br@sseusa.com> provided the patch
-	        xmlChar xc;
-	        xc = (*cur & 0x3F) << 6;
-	        if (cur[1] != 0) {
-		    xc += *(++cur) & 0x3F;
-		    *out++ = xc;
-	        } else
-		 */
-		*out++ = *cur;
+	    if ((flags & XML_ESCAPE_HTML) && (flags & XML_ESCAPE_ATTR) &&
+                (cur[1] == '{') && (end = xmlStrchr(cur, '}'))) {
+                chunkSize = (end - cur) + 1;
+                repl = cur;
+                replSize = chunkSize;
 	    } else {
-		/*
-		 * We assume we have UTF-8 input.
-		 * It must match either:
-		 *   110xxxxx 10xxxxxx
-		 *   1110xxxx 10xxxxxx 10xxxxxx
-		 *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-		 * That is:
-		 *   cur[0] is 11xxxxxx
-		 *   cur[1] is 10xxxxxx
-		 *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx
-		 *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx
-		 *   cur[0] is not 11111xxx
-		 */
-		char buf[13], *ptr;
-		int val, l;
-
-                l = 4;
-                val = xmlGetUTF8Char(cur, &l);
-                if (val < 0) {
-                    val = 0xFFFD;
-                    cur++;
-                } else {
-                    if (!IS_CHAR(val))
-                        val = 0xFFFD;
-                    cur += l;
-		}
-		/*
-		 * We could do multiple things here. Just save as a char ref
-		 */
-		snprintf(buf, sizeof(buf), "&#x%X;", val);
-		buf[sizeof(buf) - 1] = 0;
-		ptr = buf;
-		while (*ptr != 0) *out++ = *ptr++;
-		continue;
-	    }
-	} else if (IS_BYTE_CHAR(*cur)) {
-	    char buf[11], *ptr;
+                repl = BAD_CAST "&amp;";
+                replSize = 5;
+            }
+	} else if ((flags & XML_ESCAPE_QUOT) && (c == '"')) {
+            repl = BAD_CAST "&quot;";
+            replSize = 6;
+	} else if (((flags & XML_ESCAPE_HTML) == 0) && (c == '\r')) {
+	    repl = BAD_CAST "&#13;";
+            replSize = 5;
+	} else if ((flags & XML_ESCAPE_NON_ASCII) && (c >= 0x80)) {
+            int val;
+
+            chunkSize = 4;
+            val = xmlGetUTF8Char(cur, &chunkSize);
+            if (val < 0) {
+                val = 0xFFFD;
+                chunkSize = 1;
+            } else if (((flags & XML_ESCAPE_ALLOW_INVALID) == 0) &&
+                       (!IS_CHAR(val))) {
+                val = 0xFFFD;
+            }
 
-	    snprintf(buf, sizeof(buf), "&#%d;", *cur);
-	    buf[sizeof(buf) - 1] = 0;
-            ptr = buf;
-	    while (*ptr != 0) *out++ = *ptr++;
-	}
-	cur++;
+            replSize = xmlSerializeHexCharRef(buf, val);
+            repl = BAD_CAST buf;
+	} else if ((flags & XML_ESCAPE_ALLOW_INVALID) ||
+                   (c >= 0x20) ||
+	           (c == '\n') || (c == '\t') || (c == '\r')) {
+	    /* default case, just copy */
+            cur += 1;
+            if (*cur != 0)
+                continue;
+
+            chunkSize = 0;
+            repl = BAD_CAST "";
+            replSize = 0;
+	} else {
+            /* ignore */
+            repl = BAD_CAST "";
+            replSize = 0;
+        }
+
+        used = out - buffer;
+        unescapedSize = cur - unescaped;
+        totalSize = unescapedSize + replSize;
+
+	cur += chunkSize;
+
+        if (totalSize > size - used) {
+            xmlChar *tmp;
+
+            size += totalSize;
+            if (*cur != 0)
+                size *= 2;
+            tmp = xmlRealloc(buffer, size + 1);
+            if (tmp == NULL) {
+                xmlFree(buffer);
+                return(NULL);
+            }
+            buffer = tmp;
+            out = buffer + used;
+        }
+
+        memcpy(out, unescaped, unescapedSize);
+        out += unescapedSize;
+        memcpy(out, repl, replSize);
+        out += replSize;
+
+        unescaped = cur;
     }
+
     *out = 0;
     return(buffer);
-
-mem_error:
-    xmlFree(buffer);
-    return(NULL);
 }
 
 /**
- * xmlEncodeAttributeEntities:
+ * xmlEncodeEntitiesInternal:
  * @doc:  the document containing the string
  * @input:  A string to convert to XML.
+ * @attr: are we handling an attribute value
  *
  * Do a global encoding of a string, replacing the predefined entities
- * and non ASCII values with their entities and CharRef counterparts for
- * attribute values.
+ * and non ASCII values with their entities and CharRef counterparts.
+ * Contrary to xmlEncodeEntities, this routine is reentrant, and result
+ * must be deallocated.
  *
  * Returns A newly allocated string with the substitution done.
  */
 xmlChar *
-xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {
-    return xmlEncodeEntitiesInternal(doc, input, 1);
+xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input,
+                          unsigned flags) {
+    if (input == NULL)
+        return(NULL);
+
+    if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE))
+        flags |= XML_ESCAPE_HTML;
+    else if ((doc == NULL) || (doc->encoding == NULL))
+        flags |= XML_ESCAPE_NON_ASCII;
+
+    return(xmlEscapeText(input, flags));
 }
 
 /**
@@ -722,6 +772,10 @@ xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {
  * Contrary to xmlEncodeEntities, this routine is reentrant, and result
  * must be deallocated.
  *
+ * This escapes '<', '>', '&' and '\r'. If the document has no encoding,
+ * non-ASCII codepoints are escaped. There is some special handling for
+ * HTML documents.
+ *
  * Returns A newly allocated string with the substitution done.
  */
 xmlChar *
@@ -731,86 +785,23 @@ xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input) {
 
 /**
  * xmlEncodeSpecialChars:
- * @doc:  the document containing the string
+ * @doc:  unused
  * @input:  A string to convert to XML.
  *
  * Do a global encoding of a string, replacing the predefined entities
  * this routine is reentrant, and result must be deallocated.
  *
+ * This escapes '<', '>', '&', '"' and '\r' chars.
+ *
  * Returns A newly allocated string with the substitution done.
  */
 xmlChar *
-xmlEncodeSpecialChars(const xmlDoc *doc ATTRIBUTE_UNUSED, const xmlChar *input) {
-    const xmlChar *cur = input;
-    xmlChar *buffer = NULL;
-    xmlChar *out = NULL;
-    size_t buffer_size = 0;
-    if (input == NULL) return(NULL);
-
-    /*
-     * allocate an translation buffer.
-     */
-    buffer_size = 1000;
-    buffer = (xmlChar *) xmlMalloc(buffer_size);
-    if (buffer == NULL)
-	return(NULL);
-    out = buffer;
-
-    while (*cur != '\0') {
-        size_t indx = out - buffer;
-        if (indx + 10 > buffer_size) {
-
-	    growBufferReentrant();
-	    out = &buffer[indx];
-	}
-
-	/*
-	 * By default one have to encode at least '<', '>', '"' and '&' !
-	 */
-	if (*cur == '<') {
-	    *out++ = '&';
-	    *out++ = 'l';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*cur == '>') {
-	    *out++ = '&';
-	    *out++ = 'g';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*cur == '&') {
-	    *out++ = '&';
-	    *out++ = 'a';
-	    *out++ = 'm';
-	    *out++ = 'p';
-	    *out++ = ';';
-	} else if (*cur == '"') {
-	    *out++ = '&';
-	    *out++ = 'q';
-	    *out++ = 'u';
-	    *out++ = 'o';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*cur == '\r') {
-	    *out++ = '&';
-	    *out++ = '#';
-	    *out++ = '1';
-	    *out++ = '3';
-	    *out++ = ';';
-	} else {
-	    /*
-	     * Works because on UTF-8, all extended sequences cannot
-	     * result in bytes in the ASCII range.
-	     */
-	    *out++ = *cur;
-	}
-	cur++;
-    }
-    *out = 0;
-    return(buffer);
+xmlEncodeSpecialChars(const xmlDoc *doc ATTRIBUTE_UNUSED,
+                      const xmlChar *input) {
+    if (input == NULL)
+        return(NULL);
 
-mem_error:
-    xmlFree(buffer);
-    return(NULL);
+    return(xmlEscapeText(input, XML_ESCAPE_QUOT | XML_ESCAPE_ALLOW_INVALID));
 }
 
 /**
@@ -850,7 +841,6 @@ xmlFreeEntitiesTable(xmlEntitiesTablePtr table) {
     xmlHashFree(table, xmlFreeEntityWrapper);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlCopyEntity:
  * @ent:  An entity
@@ -920,7 +910,6 @@ xmlEntitiesTablePtr
 xmlCopyEntitiesTable(xmlEntitiesTablePtr table) {
     return(xmlHashCopySafe(table, xmlCopyEntity, xmlFreeEntityWrapper));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_OUTPUT_ENABLED
 
diff --git a/error.c b/error.c
index b678a0ee..fc28bb69 100644
--- a/error.c
+++ b/error.c
@@ -17,6 +17,7 @@
 #include <libxml/xmlmemory.h>
 
 #include "private/error.h"
+#include "private/globals.h"
 #include "private/string.h"
 
 /************************************************************************
@@ -635,7 +636,7 @@ void
 xmlRaiseMemoryError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,
                     void *data, int domain, xmlError *error)
 {
-    xmlError *lastError = &xmlLastError;
+    xmlError *lastError = xmlGetLastErrorInternal();
 
     xmlResetLastError();
     lastError->domain = domain;
@@ -694,16 +695,14 @@ xmlVRaiseError(xmlStructuredErrorFunc schannel,
 {
     xmlParserCtxtPtr ctxt = NULL;
     /* xmlLastError is a macro retrieving the per-thread global. */
-    xmlErrorPtr lastError = &xmlLastError;
+    xmlErrorPtr lastError = xmlGetLastErrorInternal();
     xmlErrorPtr to = lastError;
 
     if (code == XML_ERR_OK)
         return(0);
 #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (code == XML_ERR_INTERNAL_ERROR) {
-        fprintf(stderr, "Unexpected error: %d\n", code);
-        abort();
-    }
+    if (code == XML_ERR_INTERNAL_ERROR)
+        xmlAbort("Unexpected error: %d\n", code);
 #endif
     if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
         return(0);
@@ -746,7 +745,7 @@ xmlVRaiseError(xmlStructuredErrorFunc schannel,
 }
 
 /**
- * __xmlRaiseError:
+ * xmlRaiseError:
  * @schannel: the structured callback channel
  * @channel: the old callback channel
  * @data: the callback data
@@ -772,12 +771,12 @@ xmlVRaiseError(xmlStructuredErrorFunc schannel,
  * Returns 0 on success, -1 if a memory allocation failed.
  */
 int
-__xmlRaiseError(xmlStructuredErrorFunc schannel,
-                xmlGenericErrorFunc channel, void *data, void *ctx,
-                xmlNode *node, int domain, int code, xmlErrorLevel level,
-                const char *file, int line, const char *str1,
-                const char *str2, const char *str3, int int1, int col,
-                const char *msg, ...)
+xmlRaiseError(xmlStructuredErrorFunc schannel,
+              xmlGenericErrorFunc channel, void *data, void *ctx,
+              xmlNode *node, int domain, int code, xmlErrorLevel level,
+              const char *file, int line, const char *str1,
+              const char *str2, const char *str3, int int1, int col,
+              const char *msg, ...)
 {
     va_list ap;
     int res;
@@ -921,9 +920,11 @@ xmlParserValidityWarning(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...)
 const xmlError *
 xmlGetLastError(void)
 {
-    if (xmlLastError.code == XML_ERR_OK)
-        return (NULL);
-    return (&xmlLastError);
+    const xmlError *error = xmlGetLastErrorInternal();
+
+    if (error->code == XML_ERR_OK)
+        return(NULL);
+    return(error);
 }
 
 /**
@@ -962,49 +963,10 @@ xmlResetError(xmlErrorPtr err)
 void
 xmlResetLastError(void)
 {
-    if (xmlLastError.code == XML_ERR_OK)
-        return;
-    xmlResetError(&xmlLastError);
-}
-
-/**
- * xmlCtxtGetLastError:
- * @ctx:  an XML parser context
- *
- * Get the last parsing error registered.
- *
- * Returns NULL if no error occurred or a pointer to the error
- */
-const xmlError *
-xmlCtxtGetLastError(void *ctx)
-{
-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
-
-    if (ctxt == NULL)
-        return (NULL);
-    if (ctxt->lastError.code == XML_ERR_OK)
-        return (NULL);
-    return (&ctxt->lastError);
-}
-
-/**
- * xmlCtxtResetLastError:
- * @ctx:  an XML parser context
- *
- * Cleanup the last global error registered. For parsing error
- * this does not change the well-formedness result.
- */
-void
-xmlCtxtResetLastError(void *ctx)
-{
-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
+    xmlError *error = xmlGetLastErrorInternal();
 
-    if (ctxt == NULL)
-        return;
-    ctxt->errNo = XML_ERR_OK;
-    if (ctxt->lastError.code == XML_ERR_OK)
-        return;
-    xmlResetError(&ctxt->lastError);
+    if (error->code != XML_ERR_OK)
+        xmlResetError(error);
 }
 
 /**
@@ -1366,3 +1328,28 @@ xmlErrString(xmlParserErrors code) {
 
     return(errmsg);
 }
+
+void
+xmlVPrintErrorMessage(const char *fmt, va_list ap) {
+    vfprintf(stderr, fmt, ap);
+}
+
+void
+xmlPrintErrorMessage(const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    xmlVPrintErrorMessage(fmt, ap);
+    va_end(ap);
+}
+
+void
+xmlAbort(const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    xmlVPrintErrorMessage(fmt, ap);
+    va_end(ap);
+
+    abort();
+}
diff --git a/example/gjobread.c b/example/gjobread.c
index 926cab07..f45a9b95 100644
--- a/example/gjobread.c
+++ b/example/gjobread.c
@@ -177,7 +177,7 @@ typedef struct gjob {
 
 
 static gJobPtr
-parseGjobFile(char *filename ATTRIBUTE_UNUSED) {
+parseGjobFile(char *filename) {
     xmlDocPtr doc;
     gJobPtr ret;
     jobPtr curjob;
diff --git a/example/io2.c b/example/io2.c
index 98e1a503..29149e1c 100644
--- a/example/io2.c
+++ b/example/io2.c
@@ -11,7 +11,7 @@
 
 #include <libxml/parser.h>
 
-#if defined(LIBXML_TREE_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
 int
 main(void)
 {
@@ -52,7 +52,7 @@ int
 main(void)
 {
     fprintf(stderr,
-            "library not configured with tree and output support\n");
+            "library not configured with output support\n");
     return (0);
 }
 #endif
diff --git a/example/tree1.c b/example/tree1.c
index 28fc1b70..cbbb0ae7 100644
--- a/example/tree1.c
+++ b/example/tree1.c
@@ -13,8 +13,6 @@
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 
-#ifdef LIBXML_TREE_ENABLED
-
 /*
  *To compile this file using gcc you can type
  *gcc `xml2-config --cflags --libs` -o xmlexample libxml2-example.c
@@ -80,9 +78,3 @@ main(int argc, char **argv)
 
     return 0;
 }
-#else
-int main(void) {
-    fprintf(stderr, "Tree support not compiled in\n");
-    return 0;
-}
-#endif
diff --git a/example/tree2.c b/example/tree2.c
index ef137af6..3f4810ce 100644
--- a/example/tree2.c
+++ b/example/tree2.c
@@ -12,7 +12,7 @@
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 
-#if defined(LIBXML_TREE_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
 
 /*
  *To compile this file using gcc you can type
@@ -101,7 +101,7 @@ main(int argc, char **argv)
 }
 #else
 int main(void) {
-    fprintf(stderr, "tree support not compiled in\n");
+    fprintf(stderr, "output support not compiled in\n");
     return(0);
 }
 #endif
diff --git a/fuzz/api.c b/fuzz/api.c
index e5245f8a..7134db25 100644
--- a/fuzz/api.c
+++ b/fuzz/api.c
@@ -2496,7 +2496,7 @@ LLVMFuzzerTestOneInput(const char *data, size_t size) {
                 list = xmlStringGetNodeList(
                     getDoc(0),
                     value = getStr(0));
-                oomReport = (value != NULL && list == NULL);
+                oomReport = (value != NULL && value[0] != 0 && list == NULL);
                 xmlFreeNodeList(list);
                 endOp();
                 break;
@@ -2514,37 +2514,45 @@ LLVMFuzzerTestOneInput(const char *data, size_t size) {
                     doc,
                     value,
                     xmlStrlen(value));
-                oomReport = (value != NULL && list == NULL);
+                oomReport = (value != NULL && value[0] != 0 && list == NULL);
                 xmlFreeNodeList(list);
                 endOp();
                 break;
             }
 
             case OP_XML_NODE_LIST_GET_STRING: {
+                xmlDocPtr doc;
+                xmlNodePtr list;
                 xmlChar *string;
 
                 startOp("xmlNodeListGetString");
                 incStrIdx();
+                doc = getDoc(0);
+                list = getNode(1);
                 string = xmlNodeListGetString(
-                    getDoc(0),
-                    getNode(1),
+                    doc,
+                    list,
                     getInt(0));
-                oomReport = (string == NULL);
+                oomReport = (list != NULL && string == NULL);
                 moveStr(0, string);
                 endOp();
                 break;
             }
 
             case OP_XML_NODE_LIST_GET_RAW_STRING: {
+                xmlDocPtr doc;
+                xmlNodePtr list;
                 xmlChar *string;
 
                 startOp("xmlNodeListGetRawString");
                 incStrIdx();
+                doc = getDoc(0);
+                list = getNode(1);
                 string = xmlNodeListGetRawString(
-                    getDoc(0),
-                    getNode(1),
+                    doc,
+                    list,
                     getInt(0));
-                oomReport = (string == NULL);
+                oomReport = (list != NULL && string == NULL);
                 moveStr(0, string);
                 endOp();
                 break;
diff --git a/fuzz/fuzz.c b/fuzz/fuzz.c
index 82c9fcbf..1b7ae0cd 100644
--- a/fuzz/fuzz.c
+++ b/fuzz/fuzz.c
@@ -413,9 +413,9 @@ xmlFuzzResourceLoader(void *data ATTRIBUTE_UNUSED, const char *URL,
     if (entity == NULL)
         return(XML_IO_ENOENT);
 
-    input = xmlInputCreateMemory(URL, entity->data, entity->size,
-                                 XML_INPUT_BUF_STATIC |
-                                 XML_INPUT_BUF_ZERO_TERMINATED);
+    input = xmlNewInputFromMemory(URL, entity->data, entity->size,
+                                  XML_INPUT_BUF_STATIC |
+                                  XML_INPUT_BUF_ZERO_TERMINATED);
     if (input == NULL)
         return(XML_ERR_NO_MEMORY);
 
diff --git a/fuzz/fuzz.h b/fuzz/fuzz.h
index 8c69790b..75249c4f 100644
--- a/fuzz/fuzz.h
+++ b/fuzz/fuzz.h
@@ -15,6 +15,12 @@
 extern "C" {
 #endif
 
+#if __GNUC__ * 100 + __GNUC_MINOR__ >= 207 || defined(__clang__)
+  #define ATTRIBUTE_UNUSED __attribute__((unused))
+#else
+  #define ATTRIBUTE_UNUSED
+#endif
+
 #if defined(LIBXML_HTML_ENABLED)
   #define HAVE_HTML_FUZZER
 #endif
diff --git a/fuzz/genSeed.c b/fuzz/genSeed.c
index 958860c0..ca129504 100644
--- a/fuzz/genSeed.c
+++ b/fuzz/genSeed.c
@@ -64,7 +64,7 @@ fuzzResourceRecorder(void *data ATTRIBUTE_UNUSED, const char *URL,
 
     *out = NULL;
 
-    code = xmlInputCreateUrl(URL, flags, &in);
+    code = xmlNewInputFromUrl(URL, flags, &in);
     if (code != XML_ERR_OK)
         return(code);
 
@@ -77,7 +77,7 @@ fuzzResourceRecorder(void *data ATTRIBUTE_UNUSED, const char *URL,
     }
 
     do {
-        len = xmlParserInputBufferGrow(in->buf, chunkSize);
+        len = xmlParserInputGrow(in, chunkSize);
         if (len < 0) {
             fprintf(stderr, "Error reading %s\n", URL);
             xmlFreeInputStream(in);
@@ -94,7 +94,7 @@ fuzzResourceRecorder(void *data ATTRIBUTE_UNUSED, const char *URL,
     xmlHashAddEntry(globalData.entities, (const xmlChar *) URL,
                     globalData.entities);
 
-    return(xmlInputCreateUrl(URL, flags, out));
+    return(xmlNewInputFromUrl(URL, flags, out));
 }
 
 static void
diff --git a/fuzz/reader.c b/fuzz/reader.c
index 3ec211da..83d6567e 100644
--- a/fuzz/reader.c
+++ b/fuzz/reader.c
@@ -15,9 +15,7 @@
 #include <string.h>
 
 #if 0
-  #define DEBUG printf
-#else
-  #define DEBUG noop
+  #define DEBUG
 #endif
 
 typedef enum {
@@ -81,15 +79,12 @@ typedef enum {
     OP_MAX
 } opType;
 
-static void
-noop(const char *fmt, ...) {
-    (void) fmt;
-}
-
 static void
 startOp(const char *name) {
     (void) name;
-    DEBUG("%s\n", name);
+#ifdef DEBUG
+    fprintf(stderr, "%s\n", name);
+#endif
 }
 
 int
@@ -130,6 +125,19 @@ LLVMFuzzerTestOneInput(const char *data, size_t size) {
     if (docBuffer == NULL)
         goto exit;
 
+#ifdef DEBUG
+    fprintf(stderr, "Input document (%d bytes):\n", (int) docSize);
+    for (i = 0; (size_t) i < docSize; i++) {
+        int c = (unsigned char) docBuffer[i];
+
+        if ((c == '\n' || (c >= 0x20 && c <= 0x7E)))
+            putc(c, stderr);
+        else
+            fprintf(stderr, "\\x%02X", c);
+    }
+    fprintf(stderr, "\nEOF\n");
+#endif
+
     xmlFuzzMemSetLimit(maxAlloc);
     reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);
     if (reader == NULL)
@@ -520,6 +528,7 @@ LLVMFuzzerTestOneInput(const char *data, size_t size) {
             case OP_BYTE_CONSUMED:
                 startOp("ByteConsumed");
                 xmlTextReaderByteConsumed(reader);
+                oomReport = -1;
                 break;
         }
 
diff --git a/globals.c b/globals.c
index d5ef2065..05bc8ed1 100644
--- a/globals.c
+++ b/globals.c
@@ -11,7 +11,6 @@
 #define IN_LIBXML
 #include "libxml.h"
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -32,6 +31,11 @@
 #include "private/threads.h"
 #include "private/tree.h"
 
+/*
+ * Mutex to protect "ForNewThreads" variables
+ */
+static xmlMutex xmlThrDefMutex;
+
 /*
  * Thread-local storage emulation.
  *
@@ -46,113 +50,90 @@
  *     #define xmlError (*__xmlLastError());
  *
  * The code can operate in a multitude of ways depending on the environment.
- * First we support POSIX and Windows threads. Then we support both thread-local
- * storage provided by the compiler and older methods like thread-specific data
- * (pthreads) or TlsAlloc (Windows).
+ * First we support POSIX and Windows threads. Then we support both
+ * thread-local storage provided by the compiler and older methods like
+ * thread-specific data (pthreads) or TlsAlloc (Windows).
  *
  * To clean up thread-local storage, we use thread-specific data on POSIX.
- * On Windows, we either use DllMain when compiling a DLL or a registered wait
- * function for static builds.
+ * On Windows, we either use DllMain when compiling a DLL or a registered
+ * wait function for static builds.
+ *
+ * Compiler TLS isn't really useful. It can make allocation more robust
+ * on some platforms but it also increases the memory consumption of each
+ * thread by ~250 bytes whether it uses libxml2 or not. The main problem
+ * is that be have to deallocate strings in xmlLastError and C offers no
+ * simple way to deallocate dynamic data in _Thread_local variables.
+ * In C++, one could simply use a thread_local variable with a destructor.
  */
 
+#ifdef LIBXML_THREAD_ENABLED
+
 /*
- * Helpful Macro
+ * On Darwin, thread-local storage destructors seem to be run before
+ * pthread thread-specific data destructors. This causes ASan to
+ * report a use-after-free.
+ *
+ * On Windows, we can't use TLS in static builds. The RegisterWait
+ * callback would run after TLS was deallocated.
  */
-#ifdef LIBXML_THREAD_ENABLED
-#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
-#else
-#define IS_MAIN_THREAD 1
+#if defined(XML_THREAD_LOCAL) && \
+    !defined(__APPLE__) && \
+    !defined(USE_WAIT_DTOR)
+#define USE_TLS
+#endif
+
+#ifdef HAVE_WIN32_THREADS
+  #if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)
+    #define USE_WAIT_DTOR
+  #else
+    #define USE_DLL_MAIN
+  #endif
 #endif
 
 #define XML_DECLARE_MEMBER(name, type, attrs) \
   type gs_##name;
 
 struct _xmlGlobalState {
+#ifdef USE_TLS
     int initialized;
+#endif
 
-#if defined(HAVE_WIN32_THREADS) && \
-    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)
+#ifdef USE_WAIT_DTOR
     void *threadHandle;
     void *waitHandle;
 #endif
 
-#ifdef LIBXML_THREAD_ENABLED
     unsigned localRngState[2];
-#endif
+
+    xmlError lastError;
 
 #define XML_OP XML_DECLARE_MEMBER
 XML_GLOBALS_ALLOC
-XML_GLOBALS_ERROR
-XML_GLOBALS_IO
 XML_GLOBALS_PARSER
+XML_GLOBALS_ERROR
 XML_GLOBALS_TREE
+XML_GLOBALS_IO
 #undef XML_OP
 };
 
-static int parserInitialized;
-
-/*
- * Mutex to protect "ForNewThreads" variables
- */
-static xmlMutex xmlThrDefMutex;
-
-#ifdef LIBXML_THREAD_ENABLED
-
-/*
- * On Darwin, thread-local storage destructors seem to be run before
- * pthread thread-specific data destructors. This causes ASan to
- * report a use-after-free.
- *
- * On Windows, we can't use TLS in static builds. The RegisterWait
- * callback would run after TLS was deallocated.
- */
-#if defined(XML_THREAD_LOCAL) && \
-    !defined(__APPLE__) && \
-    (!defined(HAVE_WIN32_THREADS) || \
-     !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
-#define USE_TLS
-#endif
-
 #ifdef USE_TLS
 static XML_THREAD_LOCAL xmlGlobalState globalState;
 #endif
 
 #ifdef HAVE_POSIX_THREADS
 
-/*
- * Weak symbol hack, see threads.c
- */
-#if defined(__GNUC__) && \
-    defined(__GLIBC__) && \
-    __GLIBC__ * 100 + __GLIBC_MINOR__ < 234
-
-#pragma weak pthread_getspecific
-#pragma weak pthread_setspecific
-#pragma weak pthread_key_create
-#pragma weak pthread_key_delete
-#pragma weak pthread_equal
-#pragma weak pthread_self
-
-#define XML_PTHREAD_WEAK
-
-static int libxml_is_threaded = -1;
-
-#endif
-
 /*
  * On POSIX, we need thread-specific data even with thread-local storage
  * to destroy indirect references from global state (xmlLastError) at
  * thread exit.
  */
 static pthread_key_t globalkey;
-static pthread_t mainthread;
 
 #elif defined HAVE_WIN32_THREADS
 
 #ifndef USE_TLS
 static DWORD globalkey = TLS_OUT_OF_INDEXES;
 #endif
-static DWORD mainthread;
 
 #endif /* HAVE_WIN32_THREADS */
 
@@ -167,10 +148,6 @@ xmlFreeGlobalState(void *state);
  *									*
  ************************************************************************/
 
-#ifdef LIBXML_THREAD_ENABLED
-static unsigned xmlMainThreadRngState[2];
-#endif
-
 /*
  * Memory allocation routines
  */
@@ -242,8 +219,7 @@ xmlStrdupFunc xmlMemStrdup = xmlPosixStrdup;
  * Global setting, default allocation policy for buffers, default is
  * XML_BUFFER_ALLOC_EXACT
  */
-xmlBufferAllocationScheme xmlBufferAllocScheme = XML_BUFFER_ALLOC_EXACT;
-static xmlBufferAllocationScheme xmlBufferAllocSchemeThrDef = XML_BUFFER_ALLOC_EXACT;
+const xmlBufferAllocationScheme xmlBufferAllocScheme = XML_BUFFER_ALLOC_EXACT;
 /**
  * xmlDefaultBufferSize:
  *
@@ -251,8 +227,7 @@ static xmlBufferAllocationScheme xmlBufferAllocSchemeThrDef = XML_BUFFER_ALLOC_E
  *
  * Global setting, default buffer size. Default value is BASE_BUFFER_SIZE
  */
-int xmlDefaultBufferSize = BASE_BUFFER_SIZE;
-static int xmlDefaultBufferSizeThrDef = BASE_BUFFER_SIZE;
+const int xmlDefaultBufferSize = BASE_BUFFER_SIZE;
 
 /*
  * Parser defaults
@@ -261,17 +236,13 @@ static int xmlDefaultBufferSizeThrDef = BASE_BUFFER_SIZE;
 /**
  * oldXMLWDcompatibility:
  *
- * Global setting, DEPRECATED.
+ * DEPRECATED, always 0.
  */
 const int oldXMLWDcompatibility = 0; /* DEPRECATED */
 /**
  * xmlParserDebugEntities:
  *
- * DEPRECATED: Don't use
- *
- * Global setting, asking the parser to print out debugging information.
- * while handling entities.
- * Disabled by default
+ * DEPRECATED, always 0.
  */
 const int xmlParserDebugEntities = 0;
 /**
@@ -282,7 +253,9 @@ const int xmlParserDebugEntities = 0;
  * Global setting, indicate that the parser should work in validating mode.
  * Disabled by default.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlDoValidityCheckingDefaultValue = 0;
+#endif
 static int xmlDoValidityCheckingDefaultValueThrDef = 0;
 /**
  * xmlGetWarningsDefaultValue:
@@ -292,7 +265,9 @@ static int xmlDoValidityCheckingDefaultValueThrDef = 0;
  * Global setting, indicate that the DTD validation should provide warnings.
  * Activated by default.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlGetWarningsDefaultValue = 1;
+#endif
 static int xmlGetWarningsDefaultValueThrDef = 1;
 /**
  * xmlLoadExtDtdDefaultValue:
@@ -303,7 +278,9 @@ static int xmlGetWarningsDefaultValueThrDef = 1;
  * validating.
  * Disabled by default.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlLoadExtDtdDefaultValue = 0;
+#endif
 static int xmlLoadExtDtdDefaultValueThrDef = 0;
 /**
  * xmlPedanticParserDefaultValue:
@@ -313,7 +290,9 @@ static int xmlLoadExtDtdDefaultValueThrDef = 0;
  * Global setting, indicate that the parser be pedantic
  * Disabled by default.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlPedanticParserDefaultValue = 0;
+#endif
 static int xmlPedanticParserDefaultValueThrDef = 0;
 /**
  * xmlLineNumbersDefaultValue:
@@ -325,7 +304,9 @@ static int xmlPedanticParserDefaultValueThrDef = 0;
  * Disabled by default since this may not be safe for old classes of
  * application.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlLineNumbersDefaultValue = 0;
+#endif
 static int xmlLineNumbersDefaultValueThrDef = 0;
 /**
  * xmlKeepBlanksDefaultValue:
@@ -338,7 +319,9 @@ static int xmlLineNumbersDefaultValueThrDef = 0;
  * conformant to the XML Recommendation, however the option is kept
  * for some applications since this was libxml1 default behaviour.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlKeepBlanksDefaultValue = 1;
+#endif
 static int xmlKeepBlanksDefaultValueThrDef = 1;
 /**
  * xmlSubstituteEntitiesDefaultValue:
@@ -351,7 +334,9 @@ static int xmlKeepBlanksDefaultValueThrDef = 1;
  * the XPath data model requires entities replacement and the XPath
  * engine does not handle entities references transparently.
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlSubstituteEntitiesDefaultValue = 0;
+#endif
 static int xmlSubstituteEntitiesDefaultValueThrDef = 0;
 
 /**
@@ -359,7 +344,9 @@ static int xmlSubstituteEntitiesDefaultValueThrDef = 0;
  *
  * DEPRECATED: Don't use
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlRegisterNodeFunc xmlRegisterNodeDefaultValue = NULL;
+#endif
 static xmlRegisterNodeFunc xmlRegisterNodeDefaultValueThrDef = NULL;
 
 /**
@@ -367,7 +354,9 @@ static xmlRegisterNodeFunc xmlRegisterNodeDefaultValueThrDef = NULL;
  *
  * DEPRECATED: Don't use
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue = NULL;
+#endif
 static xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValueThrDef = NULL;
 
 /**
@@ -375,46 +364,71 @@ static xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValueThrDef = NULL;
  *
  * DEPRECATED: Don't use
  */
-xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue = NULL;
-static xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValueThrDef = NULL;
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
+xmlParserInputBufferCreateFilenameFunc
+xmlParserInputBufferCreateFilenameValue = NULL;
+#endif
+static xmlParserInputBufferCreateFilenameFunc
+xmlParserInputBufferCreateFilenameValueThrDef = NULL;
 
 /**
  * xmlOutputBufferCreateFilenameValue:
  *
  * DEPRECATED: Don't use
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue = NULL;
-static xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValueThrDef = NULL;
+#endif
+static xmlOutputBufferCreateFilenameFunc
+xmlOutputBufferCreateFilenameValueThrDef = NULL;
 
 /**
  * xmlGenericError:
  *
+ * DEPRECATED: Use xmlCtxtSetErrorHandler.
+ *
  * Global setting: function used for generic error callbacks
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlGenericErrorFunc xmlGenericError = xmlGenericErrorDefaultFunc;
+#endif
 static xmlGenericErrorFunc xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;
 /**
  * xmlStructuredError:
  *
+ * DEPRECATED: Use xmlCtxtSetErrorHandler.
+ *
  * Global setting: function used for structured error callbacks
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlStructuredErrorFunc xmlStructuredError = NULL;
+#endif
 static xmlStructuredErrorFunc xmlStructuredErrorThrDef = NULL;
 /**
  * xmlGenericErrorContext:
  *
+ * DEPRECATED: Use xmlCtxtSetErrorHandler.
+ *
  * Global setting passed to generic error callbacks
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 void *xmlGenericErrorContext = NULL;
+#endif
 static void *xmlGenericErrorContextThrDef = NULL;
 /**
  * xmlStructuredErrorContext:
  *
+ * DEPRECATED: Use xmlCtxtSetErrorHandler.
+ *
  * Global setting passed to structured error callbacks
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 void *xmlStructuredErrorContext = NULL;
+#endif
 static void *xmlStructuredErrorContextThrDef = NULL;
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 xmlError xmlLastError;
+#endif
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /*
@@ -423,29 +437,42 @@ xmlError xmlLastError;
 /**
  * xmlIndentTreeOutput:
  *
+ * DEPRECATED: Use XML_SAVE_INDENT and XML_SAVE_NO_INDENT.
+ *
  * Global setting, asking the serializer to indent the output tree by default
  * Enabled by default
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlIndentTreeOutput = 1;
+#endif
 static int xmlIndentTreeOutputThrDef = 1;
 
 /**
  * xmlTreeIndentString:
  *
- * The string used to do one-level indent. By default is equal to "  " (two spaces)
+ * DEPRECATED: Use xmlSaveSetIndentString.
+ *
+ * The string used to do one-level indent. By default is equal to
+ * "  " (two spaces)
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 const char *xmlTreeIndentString = "  ";
+#endif
 static const char *xmlTreeIndentStringThrDef = "  ";
 
 /**
  * xmlSaveNoEmptyTags:
  *
+ * DEPRECATED: Use XML_SAVE_EMPTY and XML_SAVE_NO_EMPTY.
+ *
  * Global setting, asking the serializer to not output empty tags
  * as <empty/> but <empty></empty>. those two forms are indistinguishable
  * once parsed.
  * Disabled by default
  */
+#if !defined(LIBXML_THREAD_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 int xmlSaveNoEmptyTags = 0;
+#endif
 static int xmlSaveNoEmptyTagsThrDef = 0;
 #endif /* LIBXML_OUTPUT_ENABLED */
 
@@ -570,34 +597,12 @@ void xmlInitGlobalsInternal(void) {
     xmlInitMutex(&xmlThrDefMutex);
 
 #ifdef HAVE_POSIX_THREADS
-#ifdef XML_PTHREAD_WEAK
-    if (libxml_is_threaded == -1)
-        libxml_is_threaded =
-            (pthread_getspecific != NULL) &&
-            (pthread_setspecific != NULL) &&
-            (pthread_key_create != NULL) &&
-            (pthread_key_delete != NULL) &&
-            /*
-             * pthread_equal can be inline, resuting in -Waddress warnings.
-             * Let's assume it's available if all the other functions are.
-             */
-            /* (pthread_equal != NULL) && */
-            (pthread_self != NULL);
-    if (libxml_is_threaded == 0)
-        return;
-#endif /* XML_PTHREAD_WEAK */
     pthread_key_create(&globalkey, xmlFreeGlobalState);
-    mainthread = pthread_self();
 #elif defined(HAVE_WIN32_THREADS)
 #ifndef USE_TLS
-    globalkey = TlsAlloc();
-#endif
-    mainthread = GetCurrentThreadId();
+    if (globalkey == TLS_OUT_OF_INDEXES)
+        globalkey = TlsAlloc();
 #endif
-
-#ifdef LIBXML_THREAD_ENABLED
-    xmlMainThreadRngState[0] = xmlGlobalRandom();
-    xmlMainThreadRngState[1] = xmlGlobalRandom();
 #endif
 }
 
@@ -618,26 +623,33 @@ void xmlCleanupGlobals(void) {
  * Additional cleanup for multi-threading
  */
 void xmlCleanupGlobalsInternal(void) {
-    xmlResetError(&xmlLastError);
-
-    xmlCleanupMutex(&xmlThrDefMutex);
+    /*
+     * We assume that all other threads using the library have
+     * terminated and the last remaining thread calls
+     * xmlCleanupParser.
+     */
 
 #ifdef HAVE_POSIX_THREADS
-#ifdef XML_PTHREAD_WEAK
-    if (libxml_is_threaded == 0)
-        return;
-#endif /* XML_PTHREAD_WEAK */
+    /*
+     * Free thread-specific data of last thread before calling
+     * pthread_key_delete.
+     */
+    xmlGlobalState *gs = pthread_getspecific(globalkey);
+    if (gs != NULL)
+        xmlFreeGlobalState(gs);
     pthread_key_delete(globalkey);
 #elif defined(HAVE_WIN32_THREADS)
-#ifndef USE_TLS
+#if defined(USE_WAIT_DTOR) && !defined(USE_TLS)
     if (globalkey != TLS_OUT_OF_INDEXES) {
         TlsFree(globalkey);
         globalkey = TLS_OUT_OF_INDEXES;
     }
 #endif
+#else /* no thread support */
+    xmlResetError(&xmlLastError);
 #endif
 
-    parserInitialized = 0;
+    xmlCleanupMutex(&xmlThrDefMutex);
 }
 
 /**
@@ -664,26 +676,6 @@ xmlGetGlobalState(void)
     return(NULL);
 }
 
-static int
-xmlIsMainThreadInternal(void) {
-    if (parserInitialized == 0) {
-        xmlInitParser();
-        parserInitialized = 1;
-    }
-
-#ifdef HAVE_POSIX_THREADS
-#ifdef XML_PTHREAD_WEAK
-    if (libxml_is_threaded == 0)
-        return (1);
-#endif
-    return (pthread_equal(mainthread, pthread_self()));
-#elif defined HAVE_WIN32_THREADS
-    return (mainthread == GetCurrentThreadId());
-#else
-    return (1);
-#endif
-}
-
 /**
  * xmlIsMainThread:
  *
@@ -695,7 +687,7 @@ xmlIsMainThreadInternal(void) {
  */
 int
 xmlIsMainThread(void) {
-    return(xmlIsMainThreadInternal());
+    return(0);
 }
 
 #ifdef LIBXML_THREAD_ENABLED
@@ -715,14 +707,13 @@ xmlFreeGlobalState(void *state)
      * But the xmlError struct is fully public and widely used,
      * so changes are dangerous.
      */
-    xmlResetError(&(gs->gs_xmlLastError));
+    xmlResetError(&gs->lastError);
 #ifndef USE_TLS
     free(state);
 #endif
 }
 
-#if defined(HAVE_WIN32_THREADS) && \
-    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)
+#if defined(USE_WAIT_DTOR)
 static void WINAPI
 xmlGlobalStateDtor(void *ctxt, unsigned char timedOut ATTRIBUTE_UNUSED) {
     xmlGlobalStatePtr gs = ctxt;
@@ -753,68 +744,74 @@ xmlRegisterGlobalStateDtor(xmlGlobalState *gs) {
     gs->waitHandle = waitHandle;
     return(0);
 }
-#endif /* LIBXML_STATIC */
+#endif /* USE_WAIT_DTOR */
 
 static void
 xmlInitGlobalState(xmlGlobalStatePtr gs) {
-    xmlMutexLock(&xmlThrDefMutex);
-
-#ifdef LIBXML_THREAD_ENABLED
     gs->localRngState[0] = xmlGlobalRandom();
     gs->localRngState[1] = xmlGlobalRandom();
-#endif
 
-    gs->gs_xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;
-    gs->gs_xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;
-    gs->gs_xmlDoValidityCheckingDefaultValue =
-         xmlDoValidityCheckingDefaultValueThrDef;
+    memset(&gs->lastError, 0, sizeof(xmlError));
+
 #ifdef LIBXML_THREAD_ALLOC_ENABLED
+    /* XML_GLOBALS_ALLOC */
     gs->gs_xmlFree = free;
     gs->gs_xmlMalloc = malloc;
     gs->gs_xmlMallocAtomic = malloc;
     gs->gs_xmlRealloc = realloc;
     gs->gs_xmlMemStrdup = xmlPosixStrdup;
 #endif
+
+    xmlMutexLock(&xmlThrDefMutex);
+
+    /* XML_GLOBALS_PARSER */
+    gs->gs_xmlDoValidityCheckingDefaultValue =
+         xmlDoValidityCheckingDefaultValueThrDef;
     gs->gs_xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;
-#ifdef LIBXML_OUTPUT_ENABLED
-    gs->gs_xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;
-    gs->gs_xmlTreeIndentString = xmlTreeIndentStringThrDef;
-    gs->gs_xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;
-#endif
     gs->gs_xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;
     gs->gs_xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;
     gs->gs_xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;
     gs->gs_xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;
     gs->gs_xmlSubstituteEntitiesDefaultValue =
         xmlSubstituteEntitiesDefaultValueThrDef;
+#ifdef LIBXML_OUTPUT_ENABLED
+    gs->gs_xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;
+    gs->gs_xmlTreeIndentString = xmlTreeIndentStringThrDef;
+    gs->gs_xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;
+#endif
 
+    /* XML_GLOBALS_ERROR */
     gs->gs_xmlGenericError = xmlGenericErrorThrDef;
     gs->gs_xmlStructuredError = xmlStructuredErrorThrDef;
     gs->gs_xmlGenericErrorContext = xmlGenericErrorContextThrDef;
     gs->gs_xmlStructuredErrorContext = xmlStructuredErrorContextThrDef;
+
+    /* XML_GLOBALS_TREE */
     gs->gs_xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef;
     gs->gs_xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef;
 
+    /* XML_GLOBALS_IO */
     gs->gs_xmlParserInputBufferCreateFilenameValue =
         xmlParserInputBufferCreateFilenameValueThrDef;
     gs->gs_xmlOutputBufferCreateFilenameValue =
         xmlOutputBufferCreateFilenameValueThrDef;
-    memset(&gs->gs_xmlLastError, 0, sizeof(xmlError));
 
     xmlMutexUnlock(&xmlThrDefMutex);
 
+#ifdef USE_TLS
+    gs->initialized = 1;
+#endif
+
 #ifdef HAVE_POSIX_THREADS
     pthread_setspecific(globalkey, gs);
 #elif defined HAVE_WIN32_THREADS
 #ifndef USE_TLS
     TlsSetValue(globalkey, gs);
 #endif
-#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)
+#ifdef USE_WAIT_DTOR
     xmlRegisterGlobalStateDtor(gs);
 #endif
 #endif
-
-    gs->initialized = 1;
 }
 
 #ifndef USE_TLS
@@ -832,6 +829,10 @@ xmlNewGlobalState(int allowFailure)
 {
     xmlGlobalState *gs;
 
+    /*
+     * We use malloc/free to allow accessing globals before setting
+     * custom memory allocators.
+     */
     gs = malloc(sizeof(xmlGlobalState));
     if (gs == NULL) {
         if (allowFailure)
@@ -842,9 +843,8 @@ xmlNewGlobalState(int allowFailure)
          * sure that global state could be allocated, it's too late to
          * handle the error.
          */
-        fprintf(stderr, "libxml2: Failed to allocate globals for thread\n"
-                        "libxml2: See xmlCheckThreadLocalStorage\n");
-        abort();
+        xmlAbort("libxml2: Failed to allocate globals for thread\n"
+                 "libxml2: See xmlCheckThreadLocalStorage\n");
     }
 
     memset(gs, 0, sizeof(xmlGlobalState));
@@ -859,6 +859,8 @@ xmlGetThreadLocalStorage(int allowFailure) {
 
     (void) allowFailure;
 
+    xmlInitParser();
+
 #ifdef USE_TLS
     gs = &globalState;
     if (gs->initialized == 0)
@@ -882,21 +884,22 @@ xmlGetThreadLocalStorage(int allowFailure) {
 
 #define XML_DEFINE_GLOBAL_WRAPPER(name, type, attrs) \
     type *__##name(void) { \
-        if (IS_MAIN_THREAD) \
-            return (&name); \
-        else \
-            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
+        return (&xmlGetThreadLocalStorage(0)->gs_##name); \
     }
 
 #define XML_OP XML_DEFINE_GLOBAL_WRAPPER
 XML_GLOBALS_ALLOC
-XML_GLOBALS_ERROR
-XML_GLOBALS_IO
 XML_GLOBALS_PARSER
+XML_GLOBALS_ERROR
 XML_GLOBALS_TREE
+XML_GLOBALS_IO
 #undef XML_OP
 
-#ifdef LIBXML_THREAD_ENABLED
+const xmlError *
+__xmlLastError(void) {
+    return(&xmlGetThreadLocalStorage(0)->lastError);
+}
+
 /**
  * xmlGetLocalRngState:
  *
@@ -904,12 +907,8 @@ XML_GLOBALS_TREE
  */
 unsigned *
 xmlGetLocalRngState(void) {
-    if (IS_MAIN_THREAD)
-        return(xmlMainThreadRngState);
-    else
-        return(xmlGetThreadLocalStorage(0)->localRngState);
+    return(xmlGetThreadLocalStorage(0)->localRngState);
 }
-#endif
 
 /* For backward compatibility */
 
@@ -963,23 +962,26 @@ __htmlDefaultSAXHandler(void) {
  * allocation signals a typically fatal and irrecoverable out-of-memory
  * situation. Don't call any library functions in this case.
  *
- * This function never fails if the library is compiled with support
- * for thread-local storage.
- *
- * This function never fails for the "main" thread which is the first
- * thread calling xmlInitParser.
- *
- * Available since v2.12.0.
+ * Available since 2.12.0.
  */
 int
 xmlCheckThreadLocalStorage(void) {
 #if defined(LIBXML_THREAD_ENABLED) && !defined(USE_TLS)
-    if ((!xmlIsMainThreadInternal()) && (xmlGetThreadLocalStorage(1) == NULL))
+    if (xmlGetThreadLocalStorage(1) == NULL)
         return(-1);
 #endif
     return(0);
 }
 
+xmlError *
+xmlGetLastErrorInternal(void) {
+#ifdef LIBXML_THREAD_ENABLED
+    return(&xmlGetThreadLocalStorage(0)->lastError);
+#else
+    return(&xmlLastError);
+#endif
+}
+
 /** DOC_DISABLE */
 
 /**
@@ -993,8 +995,7 @@ xmlCheckThreadLocalStorage(void) {
  *
  * Returns TRUE always
  */
-#if defined(HAVE_WIN32_THREADS) && \
-    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
+#ifdef USE_DLL_MAIN
 #if defined(LIBXML_STATIC_FOR_DLL)
 int
 xmlDllMain(ATTRIBUTE_UNUSED void *hinstDLL, unsigned long fdwReason,
@@ -1031,10 +1032,21 @@ DllMain(ATTRIBUTE_UNUSED HINSTANCE hinstDLL, DWORD fdwReason,
             }
 #endif
             break;
+
+#ifndef LIBXML_THREAD_ALLOC_ENABLED
+        case DLL_PROCESS_DETACH:
+            if (xmlFree == free)
+                xmlCleanupParser();
+            if (globalkey != TLS_OUT_OF_INDEXES) {
+                TlsFree(globalkey);
+                globalkey = TLS_OUT_OF_INDEXES;
+            }
+            break;
+#endif
     }
     return TRUE;
 }
-#endif
+#endif /* USE_DLL_MAIN */
 
 void
 xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
@@ -1055,22 +1067,14 @@ xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler) {
     xmlMutexUnlock(&xmlThrDefMutex);
 }
 
-xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v) {
-    xmlBufferAllocationScheme ret;
-    xmlMutexLock(&xmlThrDefMutex);
-    ret = xmlBufferAllocSchemeThrDef;
-    xmlBufferAllocSchemeThrDef = v;
-    xmlMutexUnlock(&xmlThrDefMutex);
-    return ret;
+xmlBufferAllocationScheme
+xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v ATTRIBUTE_UNUSED) {
+    return xmlBufferAllocScheme;
 }
 
-int xmlThrDefDefaultBufferSize(int v) {
-    int ret;
-    xmlMutexLock(&xmlThrDefMutex);
-    ret = xmlDefaultBufferSizeThrDef;
-    xmlDefaultBufferSizeThrDef = v;
-    xmlMutexUnlock(&xmlThrDefMutex);
-    return ret;
+int
+xmlThrDefDefaultBufferSize(int v ATTRIBUTE_UNUSED) {
+    return xmlDefaultBufferSize;
 }
 
 int xmlThrDefDoValidityCheckingDefaultValue(int v) {
@@ -1177,7 +1181,7 @@ xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)
     xmlMutexLock(&xmlThrDefMutex);
     old = xmlRegisterNodeDefaultValueThrDef;
 
-    __xmlRegisterCallbacks = 1;
+    xmlRegisterCallbacks = 1;
     xmlRegisterNodeDefaultValueThrDef = func;
     xmlMutexUnlock(&xmlThrDefMutex);
 
@@ -1192,7 +1196,7 @@ xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)
     xmlMutexLock(&xmlThrDefMutex);
     old = xmlDeregisterNodeDefaultValueThrDef;
 
-    __xmlRegisterCallbacks = 1;
+    xmlRegisterCallbacks = 1;
     xmlDeregisterNodeDefaultValueThrDef = func;
     xmlMutexUnlock(&xmlThrDefMutex);
 
diff --git a/hash.c b/hash.c
index 6af8527e..0f728efa 100644
--- a/hash.c
+++ b/hash.c
@@ -427,7 +427,7 @@ xmlHashUpdateInternal(xmlHashTablePtr hash, const xmlChar *key,
                       void *payload, xmlHashDeallocator dealloc, int update) {
     xmlChar *copy, *copy2, *copy3;
     xmlHashEntry *entry = NULL;
-    size_t lengths[3];
+    size_t lengths[3] = {0, 0, 0};
     unsigned hashValue;
     int found = 0;
 
diff --git a/include/Makefile.am b/include/Makefile.am
index 328b9932..c2f978db 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,5 +1,5 @@
 ## Process this file with automake to produce Makefile.in
 SUBDIRS=libxml private
 
-EXTRA_DIST = win32config.h wsockcompat.h meson.build
+EXTRA_DIST = wsockcompat.h meson.build
 
diff --git a/include/libxml/SAX.h b/include/libxml/SAX.h
index eea1057b..178005b5 100644
--- a/include/libxml/SAX.h
+++ b/include/libxml/SAX.h
@@ -8,195 +8,7 @@
  * Author: Daniel Veillard
  */
 
-
 #ifndef __XML_SAX_H__
 #define __XML_SAX_H__
 
-#include <libxml/xmlversion.h>
-#include <libxml/parser.h>
-
-#ifdef LIBXML_LEGACY_ENABLED
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-XML_DEPRECATED
-XMLPUBFUN const xmlChar *
-		getPublicId			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN const xmlChar *
-		getSystemId			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN void
-		setDocumentLocator		(void *ctx,
-						 xmlSAXLocatorPtr loc);
-
-XML_DEPRECATED
-XMLPUBFUN int
-		getLineNumber			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN int
-		getColumnNumber			(void *ctx);
-
-XML_DEPRECATED
-XMLPUBFUN int
-		isStandalone			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN int
-		hasInternalSubset		(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN int
-		hasExternalSubset		(void *ctx);
-
-XML_DEPRECATED
-XMLPUBFUN void
-		internalSubset			(void *ctx,
-						 const xmlChar *name,
-						 const xmlChar *ExternalID,
-						 const xmlChar *SystemID);
-XML_DEPRECATED
-XMLPUBFUN void
-		externalSubset			(void *ctx,
-						 const xmlChar *name,
-						 const xmlChar *ExternalID,
-						 const xmlChar *SystemID);
-XML_DEPRECATED
-XMLPUBFUN xmlEntityPtr
-		getEntity			(void *ctx,
-						 const xmlChar *name);
-XML_DEPRECATED
-XMLPUBFUN xmlEntityPtr
-		getParameterEntity		(void *ctx,
-						 const xmlChar *name);
-XML_DEPRECATED
-XMLPUBFUN xmlParserInputPtr
-		resolveEntity			(void *ctx,
-						 const xmlChar *publicId,
-						 const xmlChar *systemId);
-
-XML_DEPRECATED
-XMLPUBFUN void
-		entityDecl			(void *ctx,
-						 const xmlChar *name,
-						 int type,
-						 const xmlChar *publicId,
-						 const xmlChar *systemId,
-						 xmlChar *content);
-XML_DEPRECATED
-XMLPUBFUN void
-		attributeDecl			(void *ctx,
-						 const xmlChar *elem,
-						 const xmlChar *fullname,
-						 int type,
-						 int def,
-						 const xmlChar *defaultValue,
-						 xmlEnumerationPtr tree);
-XML_DEPRECATED
-XMLPUBFUN void
-		elementDecl			(void *ctx,
-						 const xmlChar *name,
-						 int type,
-						 xmlElementContentPtr content);
-XML_DEPRECATED
-XMLPUBFUN void
-		notationDecl			(void *ctx,
-						 const xmlChar *name,
-						 const xmlChar *publicId,
-						 const xmlChar *systemId);
-XML_DEPRECATED
-XMLPUBFUN void
-		unparsedEntityDecl		(void *ctx,
-						 const xmlChar *name,
-						 const xmlChar *publicId,
-						 const xmlChar *systemId,
-						 const xmlChar *notationName);
-
-XML_DEPRECATED
-XMLPUBFUN void
-		startDocument			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN void
-		endDocument			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN void
-		attribute			(void *ctx,
-						 const xmlChar *fullname,
-						 const xmlChar *value);
-XML_DEPRECATED
-XMLPUBFUN void
-		startElement			(void *ctx,
-						 const xmlChar *fullname,
-						 const xmlChar **atts);
-XML_DEPRECATED
-XMLPUBFUN void
-		endElement			(void *ctx,
-						 const xmlChar *name);
-XML_DEPRECATED
-XMLPUBFUN void
-		reference			(void *ctx,
-						 const xmlChar *name);
-XML_DEPRECATED
-XMLPUBFUN void
-		characters			(void *ctx,
-						 const xmlChar *ch,
-						 int len);
-XML_DEPRECATED
-XMLPUBFUN void
-		ignorableWhitespace		(void *ctx,
-						 const xmlChar *ch,
-						 int len);
-XML_DEPRECATED
-XMLPUBFUN void
-		processingInstruction		(void *ctx,
-						 const xmlChar *target,
-						 const xmlChar *data);
-XML_DEPRECATED
-XMLPUBFUN void
-		globalNamespace			(void *ctx,
-						 const xmlChar *href,
-						 const xmlChar *prefix);
-XML_DEPRECATED
-XMLPUBFUN void
-		setNamespace			(void *ctx,
-						 const xmlChar *name);
-XML_DEPRECATED
-XMLPUBFUN xmlNsPtr
-		getNamespace			(void *ctx);
-XML_DEPRECATED
-XMLPUBFUN int
-		checkNamespace			(void *ctx,
-						 xmlChar *nameSpace);
-XML_DEPRECATED
-XMLPUBFUN void
-		namespaceDecl			(void *ctx,
-						 const xmlChar *href,
-						 const xmlChar *prefix);
-XML_DEPRECATED
-XMLPUBFUN void
-		comment				(void *ctx,
-						 const xmlChar *value);
-XML_DEPRECATED
-XMLPUBFUN void
-		cdataBlock			(void *ctx,
-						 const xmlChar *value,
-						 int len);
-
-#ifdef LIBXML_SAX1_ENABLED
-XML_DEPRECATED
-XMLPUBFUN void
-		initxmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr,
-						 int warning);
-#ifdef LIBXML_HTML_ENABLED
-XML_DEPRECATED
-XMLPUBFUN void
-		inithtmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr);
-#endif
-#endif /* LIBXML_SAX1_ENABLED */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LIBXML_LEGACY_ENABLED */
-
 #endif /* __XML_SAX_H__ */
diff --git a/include/libxml/SAX2.h b/include/libxml/SAX2.h
index 4c4ecce8..657acb02 100644
--- a/include/libxml/SAX2.h
+++ b/include/libxml/SAX2.h
@@ -95,16 +95,15 @@ XMLPUBFUN void
 		xmlSAX2StartDocument		(void *ctx);
 XMLPUBFUN void
 		xmlSAX2EndDocument		(void *ctx);
-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
-    defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
+XML_DEPRECATED
 XMLPUBFUN void
 		xmlSAX2StartElement		(void *ctx,
 						 const xmlChar *fullname,
 						 const xmlChar **atts);
+XML_DEPRECATED
 XMLPUBFUN void
 		xmlSAX2EndElement		(void *ctx,
 						 const xmlChar *name);
-#endif /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED or LIBXML_LEGACY_ENABLED */
 XMLPUBFUN void
 		xmlSAX2StartElementNs		(void *ctx,
 						 const xmlChar *localname,
diff --git a/include/libxml/catalog.h b/include/libxml/catalog.h
index 02fa7ab2..442092a4 100644
--- a/include/libxml/catalog.h
+++ b/include/libxml/catalog.h
@@ -161,6 +161,7 @@ XMLPUBFUN xmlChar *
  */
 XMLPUBFUN int
 		xmlCatalogSetDebug	(int level);
+XML_DEPRECATED
 XMLPUBFUN xmlCatalogPrefer
 		xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);
 XMLPUBFUN void
diff --git a/include/libxml/debugXML.h b/include/libxml/debugXML.h
index 1332dd73..55148d9d 100644
--- a/include/libxml/debugXML.h
+++ b/include/libxml/debugXML.h
@@ -71,144 +71,6 @@ XMLPUBFUN int
 	xmlDebugCheckDocument	(FILE * output,
 				 xmlDocPtr doc);
 
-/****************************************************************
- *								*
- *			XML shell helpers			*
- *								*
- ****************************************************************/
-
-XMLPUBFUN void
-	xmlLsOneNode		(FILE *output, xmlNodePtr node);
-XMLPUBFUN int
-	xmlLsCountNode		(xmlNodePtr node);
-
-XMLPUBFUN const char *
-	xmlBoolToText		(int boolval);
-
-/****************************************************************
- *								*
- *	 The XML shell related structures and functions		*
- *								*
- ****************************************************************/
-
-#ifdef LIBXML_XPATH_ENABLED
-/**
- * xmlShellReadlineFunc:
- * @prompt:  a string prompt
- *
- * This is a generic signature for the XML shell input function.
- *
- * Returns a string which will be freed by the Shell.
- */
-typedef char * (* xmlShellReadlineFunc)(char *prompt);
-
-/**
- * xmlShellCtxt:
- *
- * A debugging shell context.
- * TODO: add the defined function tables.
- */
-typedef struct _xmlShellCtxt xmlShellCtxt;
-typedef xmlShellCtxt *xmlShellCtxtPtr;
-struct _xmlShellCtxt {
-    char *filename;
-    xmlDocPtr doc;
-    xmlNodePtr node;
-    xmlXPathContextPtr pctxt;
-    int loaded;
-    FILE *output;
-    xmlShellReadlineFunc input;
-};
-
-/**
- * xmlShellCmd:
- * @ctxt:  a shell context
- * @arg:  a string argument
- * @node:  a first node
- * @node2:  a second node
- *
- * This is a generic signature for the XML shell functions.
- *
- * Returns an int, negative returns indicating errors.
- */
-typedef int (* xmlShellCmd) (xmlShellCtxtPtr ctxt,
-                             char *arg,
-			     xmlNodePtr node,
-			     xmlNodePtr node2);
-
-XMLPUBFUN void
-	xmlShellPrintXPathError	(int errorType,
-				 const char *arg);
-XMLPUBFUN void
-	xmlShellPrintXPathResult(xmlXPathObjectPtr list);
-XMLPUBFUN int
-	xmlShellList		(xmlShellCtxtPtr ctxt,
-				 char *arg,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellBase		(xmlShellCtxtPtr ctxt,
-				 char *arg,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellDir		(xmlShellCtxtPtr ctxt,
-				 char *arg,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellLoad		(xmlShellCtxtPtr ctxt,
-				 char *filename,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-#ifdef LIBXML_OUTPUT_ENABLED
-XMLPUBFUN void
-	xmlShellPrintNode	(xmlNodePtr node);
-XMLPUBFUN int
-	xmlShellCat		(xmlShellCtxtPtr ctxt,
-				 char *arg,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellWrite		(xmlShellCtxtPtr ctxt,
-				 char *filename,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellSave		(xmlShellCtxtPtr ctxt,
-				 char *filename,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-#endif /* LIBXML_OUTPUT_ENABLED */
-#ifdef LIBXML_VALID_ENABLED
-XMLPUBFUN int
-	xmlShellValidate	(xmlShellCtxtPtr ctxt,
-				 char *dtd,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-#endif /* LIBXML_VALID_ENABLED */
-XMLPUBFUN int
-	xmlShellDu		(xmlShellCtxtPtr ctxt,
-				 char *arg,
-				 xmlNodePtr tree,
-				 xmlNodePtr node2);
-XMLPUBFUN int
-	xmlShellPwd		(xmlShellCtxtPtr ctxt,
-				 char *buffer,
-				 xmlNodePtr node,
-				 xmlNodePtr node2);
-
-/*
- * The Shell interface.
- */
-XMLPUBFUN void
-	xmlShell		(xmlDocPtr doc,
-				 const char *filename,
-				 xmlShellReadlineFunc input,
-				 FILE *output);
-
-#endif /* LIBXML_XPATH_ENABLED */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/libxml/encoding.h b/include/libxml/encoding.h
index 74a77d36..293fb3f9 100644
--- a/include/libxml/encoding.h
+++ b/include/libxml/encoding.h
@@ -24,43 +24,22 @@
 
 #include <libxml/xmlversion.h>
 
-#ifdef LIBXML_ICONV_ENABLED
-#include <iconv.h>
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 typedef enum {
     XML_ENC_ERR_SUCCESS     =  0,
-    XML_ENC_ERR_SPACE       = -1,
+    XML_ENC_ERR_INTERNAL    = -1,
     XML_ENC_ERR_INPUT       = -2,
-    XML_ENC_ERR_PARTIAL     = -3,
-    XML_ENC_ERR_INTERNAL    = -4,
-    XML_ENC_ERR_MEMORY      = -5
+    XML_ENC_ERR_SPACE       = -3,
+    XML_ENC_ERR_MEMORY      = -4
 } xmlCharEncError;
 
 /*
  * xmlCharEncoding:
  *
  * Predefined values for some standard encodings.
- * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
- * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
- *
- * Anything else would have to be translated to UTF8 before being
- * given to the parser itself. The BOM for UTF16 and the encoding
- * declaration are looked at and a converter is looked for at that
- * point. If not found the parser stops here as asked by the XML REC. A
- * converter can be registered by the user using xmlRegisterCharEncodingHandler
- * but the current form doesn't allow stateful transcoding (a serious
- * problem agreed !). If iconv has been found it will be used
- * automatically and allow stateful transcoding, the simplest is then
- * to be sure to enable iconv and to provide iconv libs for the encoding
- * support needed.
- *
- * Note that the generic "UTF-16" is not a predefined value.  Instead, only
- * the specific UTF-16LE and UTF-16BE are present.
  */
 typedef enum {
     XML_CHAR_ENCODING_ERROR=   -1, /* No char encoding detected */
@@ -86,7 +65,16 @@ typedef enum {
     XML_CHAR_ENCODING_2022_JP=  19,/* ISO-2022-JP */
     XML_CHAR_ENCODING_SHIFT_JIS=20,/* Shift_JIS */
     XML_CHAR_ENCODING_EUC_JP=   21,/* EUC-JP */
-    XML_CHAR_ENCODING_ASCII=    22 /* pure ASCII */
+    XML_CHAR_ENCODING_ASCII=    22,/* pure ASCII */
+    /* Available since 2.14.0 */
+    XML_CHAR_ENCODING_UTF16=	23,/* UTF-16 native */
+    XML_CHAR_ENCODING_HTML=	24,/* HTML (output only) */
+    XML_CHAR_ENCODING_8859_10=	25,/* ISO-8859-10 */
+    XML_CHAR_ENCODING_8859_11=	26,/* ISO-8859-11 */
+    XML_CHAR_ENCODING_8859_13=	27,/* ISO-8859-13 */
+    XML_CHAR_ENCODING_8859_14=	28,/* ISO-8859-14 */
+    XML_CHAR_ENCODING_8859_15=	29,/* ISO-8859-15 */
+    XML_CHAR_ENCODING_8859_16=	30 /* ISO-8859-16 */
 } xmlCharEncoding;
 
 /**
@@ -96,17 +84,15 @@ typedef enum {
  * @in:  a pointer to an array of chars in the original encoding
  * @inlen:  the length of @in
  *
- * Take a block of chars in the original encoding and try to convert
- * it to an UTF-8 block of chars out.
+ * Convert characters to UTF-8.
+ *
+ * On success, the value of @inlen after return is the number of
+ * bytes consumed and @outlen is the number of bytes produced.
  *
- * Returns the number of bytes written, -1 if lack of space, or -2
- *     if the transcoding failed.
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictiable.
- * The value of @outlen after return is the number of octets consumed.
+ * Returns the number of bytes written or an XML_ENC_ERR code.
  */
-typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
-                                         const unsigned char *in, int *inlen);
+typedef int (*xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
+                                        const unsigned char *in, int *inlen);
 
 
 /**
@@ -116,39 +102,88 @@ typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
  * @in:  a pointer to an array of UTF-8 chars
  * @inlen:  the length of @in
  *
- * Take a block of UTF-8 chars in and try to convert it to another
- * encoding.
- * Note: a first call designed to produce heading info is called with
- * in = NULL. If stateful this should also initialize the encoder state.
+ * Convert characters from UTF-8.
+ *
+ * On success, the value of @inlen after return is the number of
+ * bytes consumed and @outlen is the number of bytes produced.
+ *
+ * Returns the number of bytes written or an XML_ENC_ERR code.
+ */
+typedef int (*xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,
+                                         const unsigned char *in, int *inlen);
+
+
+/**
+ * xmlCharEncConvFunc:
+ * @vctxt:  conversion context
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of input bytes
+ * @inlen:  the length of @in
+ *
+ * Convert between character encodings.
+ *
+ * On success, the value of @inlen after return is the number of
+ * bytes consumed and @outlen is the number of bytes produced.
+ *
+ * Returns the number of bytes written or an XML_ENC_ERR code.
+ */
+typedef int
+(*xmlCharEncConvFunc)(unsigned char *out, int *outlen,
+                      const unsigned char *in, int *inlen, void *vctxt);
+
+/**
+ * xmlCharEncConvCtxtDtor:
+ * @vctxt:  conversion context
  *
- * Returns the number of bytes written, -1 if lack of space, or -2
- *     if the transcoding failed.
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictiable.
- * The value of @outlen after return is the number of octets produced.
+ * Free a conversion context.
  */
-typedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,
-                                          const unsigned char *in, int *inlen);
+typedef void
+(*xmlCharEncConvCtxtDtor)(void *vctxt);
 
+typedef struct {
+    xmlCharEncConvFunc input;
+    xmlCharEncConvFunc output;
+    xmlCharEncConvCtxtDtor ctxtDtor;
+    void *inputCtxt;
+    void *outputCtxt;
+} xmlCharEncConverter;
+
+/**
+ * xmlCharEncConvImpl:
+ * vctxt:  user data
+ * name:  encoding name
+ * conv:  pointer to xmlCharEncConverter struct
+ *
+ * If this function returns XML_ERR_OK, it must fill the @conv struct
+ * with a conversion function, and optional destructor and optional
+ * input and output conversion contexts.
+ *
+ * Returns an xmlParserErrors code.
+ */
+typedef int
+(*xmlCharEncConvImpl)(void *vctxt, const char *name,
+                      xmlCharEncConverter *conv);
 
 /*
  * Block defining the handlers for non UTF-8 encodings.
- * If iconv is supported, there are two extra fields.
+ *
+ * This structure will be made private.
  */
 typedef struct _xmlCharEncodingHandler xmlCharEncodingHandler;
 typedef xmlCharEncodingHandler *xmlCharEncodingHandlerPtr;
 struct _xmlCharEncodingHandler {
-    char                       *name;
-    xmlCharEncodingInputFunc   input XML_DEPRECATED_MEMBER;
-    xmlCharEncodingOutputFunc  output XML_DEPRECATED_MEMBER;
+    char *name XML_DEPRECATED_MEMBER;
+    xmlCharEncodingInputFunc input XML_DEPRECATED_MEMBER;
+    xmlCharEncodingOutputFunc output XML_DEPRECATED_MEMBER;
 #ifdef LIBXML_ICONV_ENABLED
-    iconv_t                    iconv_in XML_DEPRECATED_MEMBER;
-    iconv_t                    iconv_out XML_DEPRECATED_MEMBER;
+    void *iconv_in XML_DEPRECATED_MEMBER;
+    void *iconv_out XML_DEPRECATED_MEMBER;
 #endif /* LIBXML_ICONV_ENABLED */
-#ifdef LIBXML_ICU_ENABLED
-    struct _uconv_t            *uconv_in XML_DEPRECATED_MEMBER;
-    struct _uconv_t            *uconv_out XML_DEPRECATED_MEMBER;
-#endif /* LIBXML_ICU_ENABLED */
+    void *inputCtxt XML_DEPRECATED_MEMBER;
+    void *outputCtxt XML_DEPRECATED_MEMBER;
+    xmlCharEncConvCtxtDtor ctxtDtor XML_DEPRECATED_MEMBER;
+    int flags XML_DEPRECATED_MEMBER;
 };
 
 /*
@@ -169,6 +204,12 @@ XMLPUBFUN int
 	xmlOpenCharEncodingHandler	(const char *name,
 					 int output,
 					 xmlCharEncodingHandlerPtr *out);
+XMLPUBFUN int
+	xmlCreateCharEncodingHandler	(const char *name,
+					 int output,
+					 xmlCharEncConvImpl impl,
+                                         void *implCtxt,
+					 xmlCharEncodingHandlerPtr *out);
 XMLPUBFUN xmlCharEncodingHandlerPtr
 	xmlGetCharEncodingHandler	(xmlCharEncoding enc);
 XMLPUBFUN xmlCharEncodingHandlerPtr
diff --git a/include/libxml/entities.h b/include/libxml/entities.h
index 96029ba1..d17c36be 100644
--- a/include/libxml/entities.h
+++ b/include/libxml/entities.h
@@ -11,8 +11,12 @@
 #ifndef __XML_ENTITIES_H__
 #define __XML_ENTITIES_H__
 
+/** DOC_DISABLE */
 #include <libxml/xmlversion.h>
+#define XML_TREE_INTERNALS
 #include <libxml/tree.h>
+#undef XML_TREE_INTERNALS
+/** DOC_ENABLE */
 
 #ifdef __cplusplus
 extern "C" {
@@ -72,12 +76,6 @@ typedef xmlEntitiesTable *xmlEntitiesTablePtr;
  * External functions:
  */
 
-#ifdef LIBXML_LEGACY_ENABLED
-XML_DEPRECATED
-XMLPUBFUN void
-		xmlInitializePredefinedEntities	(void);
-#endif /* LIBXML_LEGACY_ENABLED */
-
 XMLPUBFUN xmlEntityPtr
 			xmlNewEntity		(xmlDocPtr doc,
 						 const xmlChar *name,
@@ -121,12 +119,6 @@ XMLPUBFUN xmlEntityPtr
 XMLPUBFUN xmlEntityPtr
 			xmlGetParameterEntity	(xmlDocPtr doc,
 						 const xmlChar *name);
-#ifdef LIBXML_LEGACY_ENABLED
-XML_DEPRECATED
-XMLPUBFUN const xmlChar *
-			xmlEncodeEntities	(xmlDocPtr doc,
-						 const xmlChar *input);
-#endif /* LIBXML_LEGACY_ENABLED */
 XMLPUBFUN xmlChar *
 			xmlEncodeEntitiesReentrant(xmlDocPtr doc,
 						 const xmlChar *input);
@@ -135,10 +127,8 @@ XMLPUBFUN xmlChar *
 						 const xmlChar *input);
 XMLPUBFUN xmlEntitiesTablePtr
 			xmlCreateEntitiesTable	(void);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlEntitiesTablePtr
 			xmlCopyEntitiesTable	(xmlEntitiesTablePtr table);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN void
 			xmlFreeEntitiesTable	(xmlEntitiesTablePtr table);
 #ifdef LIBXML_OUTPUT_ENABLED
@@ -149,11 +139,6 @@ XMLPUBFUN void
 			xmlDumpEntityDecl	(xmlBufferPtr buf,
 						 xmlEntityPtr ent);
 #endif /* LIBXML_OUTPUT_ENABLED */
-#ifdef LIBXML_LEGACY_ENABLED
-XMLPUBFUN void
-			xmlCleanupPredefinedEntities(void);
-#endif /* LIBXML_LEGACY_ENABLED */
-
 
 #ifdef __cplusplus
 }
diff --git a/include/libxml/meson.build b/include/libxml/meson.build
index a3c37a74..cbc29b92 100644
--- a/include/libxml/meson.build
+++ b/include/libxml/meson.build
@@ -9,12 +9,12 @@ xmlversion_h.set10('WITH_CATALOG', want_catalog)
 xmlversion_h.set10('WITH_DEBUG', want_debug)
 xmlversion_h.set10('WITH_HTML', want_html)
 xmlversion_h.set10('WITH_HTTP', want_http)
-xmlversion_h.set10('WITH_ICONV', iconv_dep.found())
-xmlversion_h.set10('WITH_ICU', icu_dep.found())
+xmlversion_h.set10('WITH_ICONV', want_iconv)
+xmlversion_h.set10('WITH_ICU', want_icu)
 xmlversion_h.set10('WITH_ISO8859X', want_iso8859x)
 xmlversion_h.set10('WITH_LEGACY', want_legacy)
-xmlversion_h.set10('WITH_LZMA', lzma_dep.found())
-xmlversion_h.set10('WITH_MODULES', dl_dep.found())
+xmlversion_h.set10('WITH_LZMA', want_lzma)
+xmlversion_h.set10('WITH_MODULES', want_modules)
 xmlversion_h.set('MODULE_EXTENSION', module_extension)
 xmlversion_h.set10('WITH_OUTPUT', want_output)
 xmlversion_h.set10('WITH_PATTERN', want_pattern)
@@ -24,15 +24,14 @@ xmlversion_h.set10('WITH_REGEXPS', want_regexps)
 xmlversion_h.set10('WITH_SAX1', want_sax1)
 xmlversion_h.set10('WITH_SCHEMAS', want_schemas)
 xmlversion_h.set10('WITH_SCHEMATRON', want_schematron)
-xmlversion_h.set10('WITH_THREADS', threads_dep.found())
+xmlversion_h.set10('WITH_THREADS', want_threads)
 xmlversion_h.set10('WITH_THREAD_ALLOC', want_thread_alloc)
-xmlversion_h.set10('WITH_TREE', want_tree)
 xmlversion_h.set10('WITH_VALID', want_valid)
 xmlversion_h.set10('WITH_WRITER', want_writer)
 xmlversion_h.set10('WITH_XINCLUDE', want_xinclude)
 xmlversion_h.set10('WITH_XPATH', want_xpath)
 xmlversion_h.set10('WITH_XPTR', want_xptr)
-xmlversion_h.set10('WITH_ZLIB', zlib_dep.found())
+xmlversion_h.set10('WITH_ZLIB', want_zlib)
 
 configure_file(
     input: 'xmlversion.h.in',
diff --git a/include/libxml/parser.h b/include/libxml/parser.h
index ead922e9..55c24344 100644
--- a/include/libxml/parser.h
+++ b/include/libxml/parser.h
@@ -10,8 +10,11 @@
 #ifndef __XML_PARSER_H__
 #define __XML_PARSER_H__
 
+/** DOC_DISABLE */
 #include <libxml/xmlversion.h>
+#define XML_TREE_INTERNALS
 #include <libxml/tree.h>
+#undef XML_TREE_INTERNALS
 #include <libxml/dict.h>
 #include <libxml/hash.h>
 #include <libxml/valid.h>
@@ -24,6 +27,7 @@
 /* for compatibility */
 #include <libxml/SAX2.h>
 #include <libxml/threads.h>
+/** DOC_ENABLE */
 
 #ifdef __cplusplus
 extern "C" {
@@ -36,6 +40,11 @@ extern "C" {
  */
 #define XML_DEFAULT_VERSION	"1.0"
 
+#define XML_STATUS_NOT_WELL_FORMED          (1 << 0)
+#define XML_STATUS_NOT_NS_WELL_FORMED       (1 << 1)
+#define XML_STATUS_DTD_VALIDATION_FAILED    (1 << 2)
+#define XML_STATUS_CATASTROPHIC_ERROR       (1 << 3)
+
 typedef enum {
     XML_RESOURCE_UNKNOWN = 0,
     XML_RESOURCE_MAIN_DOCUMENT,
@@ -73,17 +82,17 @@ struct _xmlParserInput {
     /* unused */
     const char *directory XML_DEPRECATED_MEMBER;
     /* Base of the array to parse */
-    const xmlChar *base XML_DEPRECATED_MEMBER;
+    const xmlChar *base;
     /* Current char being parsed */
-    const xmlChar *cur XML_DEPRECATED_MEMBER;
+    const xmlChar *cur;
     /* end of the array to parse */
-    const xmlChar *end XML_DEPRECATED_MEMBER;
+    const xmlChar *end;
     /* unused */
     int length XML_DEPRECATED_MEMBER;
     /* Current line */
-    int line XML_DEPRECATED_MEMBER;
+    int line;
     /* Current column */
-    int col XML_DEPRECATED_MEMBER;
+    int col;
     /* How many xmlChars already consumed */
     unsigned long consumed XML_DEPRECATED_MEMBER;
     /* function to deallocate the base */
@@ -209,21 +218,20 @@ struct _xmlParserCtxt {
     xmlDocPtr myDoc;
     /* is the document well formed */
     int wellFormed;
-
     /* shall we replace entities ? */
     int replaceEntities XML_DEPRECATED_MEMBER;
     /* the XML version string */
-    const xmlChar *version XML_DEPRECATED_MEMBER;
+    const xmlChar *version;
     /* the declared encoding, if any */
-    const xmlChar *encoding XML_DEPRECATED_MEMBER;
+    const xmlChar *encoding;
     /* standalone document */
-    int standalone XML_DEPRECATED_MEMBER;
+    int standalone;
 
     /* an HTML(1) document
      * 3 is HTML after <head>
      * 10 is HTML after <body>
      */
-    int html XML_DEPRECATED_MEMBER;
+    int html;
 
     /* Input stream stack */
 
@@ -274,8 +282,8 @@ struct _xmlParserCtxt {
     /* unused */
     int token XML_DEPRECATED_MEMBER;
 
-    /* unused */
-    char *directory XML_DEPRECATED_MEMBER;
+    /* unused internally, still used downstream */
+    char *directory;
 
     /* Node name stack */
 
@@ -297,13 +305,13 @@ struct _xmlParserCtxt {
     /* SAX callbacks are disabled */
     int disableSAX XML_DEPRECATED_MEMBER;
     /* Parsing is in int 1/ext 2 subset */
-    int inSubset XML_DEPRECATED_MEMBER;
+    int inSubset;
     /* name of subset */
-    const xmlChar *intSubName XML_DEPRECATED_MEMBER;
+    const xmlChar *intSubName;
     /* URI of external subset */
-    xmlChar *extSubURI XML_DEPRECATED_MEMBER;
+    xmlChar *extSubURI;
     /* SYSTEM ID of external subset */
-    xmlChar *extSubSystem XML_DEPRECATED_MEMBER;
+    xmlChar *extSubSystem;
 
     /* xml:space values */
 
@@ -336,7 +344,7 @@ struct _xmlParserCtxt {
     /* set line number in element content */
     int linenumbers XML_DEPRECATED_MEMBER;
     /* document's own catalog */
-    void *catalogs;
+    void *catalogs XML_DEPRECATED_MEMBER;
     /* run in recovery mode */
     int recovery XML_DEPRECATED_MEMBER;
     /* unused */
@@ -380,7 +388,7 @@ struct _xmlParserCtxt {
     /* is the document XML Namespace okay */
     int nsWellFormed;
     /* Extra options */
-    int options XML_DEPRECATED_MEMBER;
+    int options;
 
     /*
      * Those fields are needed only for streaming parsing so far
@@ -400,7 +408,7 @@ struct _xmlParserCtxt {
     /*
      * the complete error information for the last error.
      */
-    xmlError lastError;
+    xmlError lastError XML_DEPRECATED_MEMBER;
     /* the parser mode */
     xmlParserMode parseMode XML_DEPRECATED_MEMBER;
     /* unused */
@@ -444,6 +452,9 @@ struct _xmlParserCtxt {
 
     xmlResourceLoader resourceLoader XML_DEPRECATED_MEMBER;
     void *resourceCtxt XML_DEPRECATED_MEMBER;
+
+    xmlCharEncConvImpl convImpl XML_DEPRECATED_MEMBER;
+    void *convCtxt XML_DEPRECATED_MEMBER;
 };
 
 /**
@@ -1055,7 +1066,6 @@ XML_DEPRECATED
 XMLPUBFUN int
 		xmlParserInputRead	(xmlParserInputPtr in,
 					 int len);
-XML_DEPRECATED
 XMLPUBFUN int
 		xmlParserInputGrow	(xmlParserInputPtr in,
 					 int len);
@@ -1076,7 +1086,7 @@ XML_DEPRECATED XMLPUBFUN int
 		xmlSubstituteEntitiesDefault(int val);
 XML_DEPRECATED XMLPUBFUN int
                 xmlThrDefSubstituteEntitiesDefaultValue(int v);
-XML_DEPRECATED XMLPUBFUN int
+XMLPUBFUN int
 		xmlKeepBlanksDefault	(int val);
 XML_DEPRECATED XMLPUBFUN int
 		xmlThrDefKeepBlanksDefaultValue(int v);
@@ -1251,6 +1261,7 @@ XMLPUBFUN xmlParserCtxtPtr
 		xmlCreateDocParserCtxt	(const xmlChar *cur);
 
 #ifdef LIBXML_LEGACY_ENABLED
+/** DOC_DISABLE */
 /*
  * Reading/setting optional parsing features.
  */
@@ -1268,6 +1279,7 @@ XMLPUBFUN int
 		xmlSetFeature		(xmlParserCtxtPtr ctxt,
 					 const char *name,
 					 void *value);
+/** DOC_ENABLE */
 #endif /* LIBXML_LEGACY_ENABLED */
 
 #ifdef LIBXML_PUSH_ENABLED
@@ -1329,18 +1341,12 @@ XMLPUBFUN void
 		xmlSetExternalEntityLoader(xmlExternalEntityLoader f);
 XMLPUBFUN xmlExternalEntityLoader
 		xmlGetExternalEntityLoader(void);
-XMLPUBFUN void
-		xmlCtxtSetResourceLoader(xmlParserCtxtPtr ctxt,
-					 xmlResourceLoader loader,
-					 void *vctxt);
 XMLPUBFUN xmlParserInputPtr
 		xmlLoadExternalEntity	(const char *URL,
 					 const char *ID,
 					 xmlParserCtxtPtr ctxt);
 
-/*
- * Index lookup, actually implemented in the encoding module
- */
+XML_DEPRECATED
 XMLPUBFUN long
 		xmlByteConsumed		(xmlParserCtxtPtr ctxt);
 
@@ -1382,7 +1388,9 @@ typedef enum {
     /* since 2.13.0 */
     XML_PARSE_NO_XXE    = 1<<23,/* disable loading of external content */
     /* since 2.14.0 */
-    XML_PARSE_NO_UNZIP  = 1<<24 /* disable compressed content */
+    XML_PARSE_NO_UNZIP       = 1<<24,/* disable compressed content */
+    XML_PARSE_NO_SYS_CATALOG = 1<<25,/* disable global system catalog */
+    XML_PARSE_NO_CATALOG_PI  = 1<<26 /* ignore catalog PIs */
 } xmlParserOption;
 
 XMLPUBFUN void
@@ -1393,16 +1401,49 @@ XMLPUBFUN int
 					 int size,
 					 const char *filename,
 					 const char *encoding);
+XMLPUBFUN int
+		xmlCtxtGetOptions	(xmlParserCtxtPtr ctxt);
 XMLPUBFUN int
 		xmlCtxtSetOptions	(xmlParserCtxtPtr ctxt,
 					 int options);
 XMLPUBFUN int
 		xmlCtxtUseOptions	(xmlParserCtxtPtr ctxt,
 					 int options);
+XMLPUBFUN void *
+		xmlCtxtGetPrivate	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void
+		xmlCtxtSetPrivate	(xmlParserCtxtPtr ctxt,
+					 void *priv);
+XMLPUBFUN void *
+		xmlCtxtGetCatalogs	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void
+		xmlCtxtSetCatalogs	(xmlParserCtxtPtr ctxt,
+					 void *catalogs);
+XMLPUBFUN xmlDictPtr
+		xmlCtxtGetDict		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void
+		xmlCtxtSetDict		(xmlParserCtxtPtr ctxt,
+					 xmlDictPtr);
+XMLPUBFUN const xmlChar *
+		xmlCtxtGetVersion	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN const xmlChar *
+		xmlCtxtGetDeclaredEncoding(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int
+		xmlCtxtGetStandalone	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int
+		xmlCtxtGetStatus	(xmlParserCtxtPtr ctxt);
 XMLPUBFUN void
 		xmlCtxtSetErrorHandler	(xmlParserCtxtPtr ctxt,
 					 xmlStructuredErrorFunc handler,
 					 void *data);
+XMLPUBFUN void
+		xmlCtxtSetResourceLoader(xmlParserCtxtPtr ctxt,
+					 xmlResourceLoader loader,
+					 void *vctxt);
+XMLPUBFUN void
+		xmlCtxtSetCharEncConvImpl(xmlParserCtxtPtr ctxt,
+					 xmlCharEncConvImpl impl,
+					 void *vctxt);
 XMLPUBFUN void
 		xmlCtxtSetMaxAmplification(xmlParserCtxtPtr ctxt,
 					 unsigned maxAmpl);
@@ -1436,6 +1477,11 @@ XMLPUBFUN xmlDocPtr
 XMLPUBFUN xmlDocPtr
 		xmlCtxtParseDocument	(xmlParserCtxtPtr ctxt,
 					 xmlParserInputPtr input);
+XMLPUBFUN xmlNodePtr
+		xmlCtxtParseContent	(xmlParserCtxtPtr ctxt,
+					 xmlParserInputPtr input,
+					 xmlNodePtr node,
+					 int hasTextDecl);
 XMLPUBFUN xmlDocPtr
 		xmlCtxtReadDoc		(xmlParserCtxtPtr ctxt,
 					 const xmlChar *cur,
@@ -1469,6 +1515,31 @@ XMLPUBFUN xmlDocPtr
 					 const char *encoding,
 					 int options);
 
+/**
+ * New input API
+ */
+
+#define XML_INPUT_BUF_STATIC		(1 << 1)
+#define XML_INPUT_BUF_ZERO_TERMINATED	(1 << 2)
+#define XML_INPUT_UNZIP                 (1 << 3)
+#define XML_INPUT_NETWORK               (1 << 4)
+
+XMLPUBFUN int
+xmlNewInputFromUrl(const char *url, int flags, xmlParserInputPtr *out);
+XMLPUBFUN xmlParserInputPtr
+xmlNewInputFromMemory(const char *url, const void *mem, size_t size,
+                      int flags);
+XMLPUBFUN xmlParserInputPtr
+xmlNewInputFromString(const char *url, const char *str, int flags);
+XMLPUBFUN xmlParserInputPtr
+xmlNewInputFromFd(const char *url, int fd, int flags);
+XMLPUBFUN xmlParserInputPtr
+xmlNewInputFromIO(const char *url, xmlInputReadCallback ioRead,
+                  xmlInputCloseCallback ioClose, void *ioCtxt, int flags);
+XMLPUBFUN int
+xmlInputSetEncodingHandler(xmlParserInputPtr input,
+                           xmlCharEncodingHandlerPtr handler);
+
 /*
  * Library wide options
  */
diff --git a/include/libxml/parserInternals.h b/include/libxml/parserInternals.h
index cbf705e5..706578eb 100644
--- a/include/libxml/parserInternals.h
+++ b/include/libxml/parserInternals.h
@@ -71,7 +71,7 @@ XMLPUBVAR const unsigned int xmlParserMaxDepth;
  * use XML_PARSE_HUGE option to override it.
  * Introduced in 2.9.0
  */
-#define XML_MAX_DICTIONARY_LIMIT 10000000
+#define XML_MAX_DICTIONARY_LIMIT 100000000
 
 /**
  * XML_MAX_LOOKUP_LIMIT:
@@ -296,9 +296,7 @@ XMLPUBVAR const xmlChar xmlStringText[];
 XMLPUBVAR const xmlChar xmlStringTextNoenc[];
 XMLPUBVAR const xmlChar xmlStringComment[];
 
-/*
- * Function to finish the work of the macros where needed.
- */
+XML_DEPRECATED
 XMLPUBFUN int                   xmlIsLetter     (int c);
 
 /**
@@ -356,30 +354,6 @@ XMLPUBFUN xmlParserInputPtr
 XMLPUBFUN xmlParserInputPtr
 			xmlNewInputStream	(xmlParserCtxtPtr ctxt);
 
-/**
- * New input API
- */
-
-#define XML_INPUT_BUF_STATIC		(1u << 1)
-#define XML_INPUT_BUF_ZERO_TERMINATED	(1u << 2)
-#define XML_INPUT_UNZIP                 (1u << 3)
-#define XML_INPUT_NETWORK               (1u << 4)
-
-XMLPUBFUN int
-xmlInputCreateUrl(const char *url, int flags, xmlParserInputPtr *out);
-XMLPUBFUN xmlParserInputPtr
-xmlInputCreateMemory(const char *url, const void *mem, size_t size,
-                     int flags);
-XMLPUBFUN xmlParserInputPtr
-xmlInputCreateString(const char *url, const char *str, int flags);
-XMLPUBFUN xmlParserInputPtr
-xmlInputCreateFd(const char *url, int fd, int flags);
-XMLPUBFUN xmlParserInputPtr
-xmlInputCreateIO(const char *url, xmlInputReadCallback ioRead,
-                 xmlInputCloseCallback ioClose, void *ioCtxt, int flags);
-XMLPUBFUN int
-xmlInputSetEncoding(xmlParserInputPtr input, const char *encoding);
-
 /**
  * Namespaces.
  */
@@ -621,6 +595,7 @@ XMLPUBFUN int			xmlCurrentChar		(xmlParserCtxtPtr ctxt,
 						 int *len);
 XMLPUBFUN int		xmlCopyCharMultiByte	(xmlChar *out,
 						 int val);
+XML_DEPRECATED
 XMLPUBFUN int			xmlCopyChar		(int len,
 						 xmlChar *out,
 						 int val);
@@ -629,66 +604,6 @@ XMLPUBFUN void			xmlNextChar		(xmlParserCtxtPtr ctxt);
 XML_DEPRECATED
 XMLPUBFUN void			xmlParserInputShrink	(xmlParserInputPtr in);
 
-/*
- * Specific function to keep track of entities references
- * and used by the XSLT debugger.
- */
-#ifdef LIBXML_LEGACY_ENABLED
-/**
- * xmlEntityReferenceFunc:
- * @ent: the entity
- * @firstNode:  the fist node in the chunk
- * @lastNode:  the last nod in the chunk
- *
- * Callback function used when one needs to be able to track back the
- * provenance of a chunk of nodes inherited from an entity replacement.
- */
-typedef	void	(*xmlEntityReferenceFunc)	(xmlEntityPtr ent,
-						 xmlNodePtr firstNode,
-						 xmlNodePtr lastNode);
-
-XML_DEPRECATED
-XMLPUBFUN void		xmlSetEntityReferenceFunc	(xmlEntityReferenceFunc func);
-
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-			xmlParseQuotedString	(xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN void
-                        xmlParseNamespace       (xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-			xmlNamespaceParseNSDef	(xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-			xmlScanName		(xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-			xmlNamespaceParseNCName	(xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN void	xmlParserHandleReference(xmlParserCtxtPtr ctxt);
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-			xmlNamespaceParseQName	(xmlParserCtxtPtr ctxt,
-						 xmlChar **prefix);
-/**
- * Entities
- */
-XML_DEPRECATED
-XMLPUBFUN xmlChar *
-		xmlDecodeEntities		(xmlParserCtxtPtr ctxt,
-						 int len,
-						 int what,
-						 xmlChar end,
-						 xmlChar  end2,
-						 xmlChar end3);
-XML_DEPRECATED
-XMLPUBFUN void
-			xmlHandleEntity		(xmlParserCtxtPtr ctxt,
-						 xmlEntityPtr entity);
-
-#endif /* LIBXML_LEGACY_ENABLED */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/libxml/tree.h b/include/libxml/tree.h
index dca20318..489ad031 100644
--- a/include/libxml/tree.h
+++ b/include/libxml/tree.h
@@ -9,6 +9,15 @@
  * Author: Daniel Veillard
  */
 
+#ifndef XML_TREE_INTERNALS
+
+/*
+ * Emulate circular dependency for backward compatibility
+ */
+#include <libxml/parser.h>
+
+#else /* XML_TREE_INTERNALS */
+
 #ifndef __XML_TREE_H__
 #define __XML_TREE_H__
 
@@ -669,10 +678,21 @@ typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);
  * Variables.
  */
 
+XML_DEPRECATED
+XMLPUBVAR const xmlBufferAllocationScheme xmlBufferAllocScheme;
+XML_DEPRECATED
+XMLPUBVAR const int xmlDefaultBufferSize;
+
+#ifdef LIBXML_THREAD_ENABLED
+/* backward compatibility */
+XML_DEPRECATED
+XMLPUBFUN const xmlBufferAllocationScheme *__xmlBufferAllocScheme(void);
+XML_DEPRECATED
+XMLPUBFUN const int *__xmlDefaultBufferSize(void);
+#endif
+
 /** DOC_DISABLE */
 #define XML_GLOBALS_TREE \
-  XML_OP(xmlBufferAllocScheme, xmlBufferAllocationScheme, XML_DEPRECATED) \
-  XML_OP(xmlDefaultBufferSize, int, XML_DEPRECATED) \
   XML_OP(xmlRegisterNodeDefaultValue, xmlRegisterNodeFunc, XML_DEPRECATED) \
   XML_OP(xmlDeregisterNodeDefaultValue, xmlDeregisterNodeFunc, \
          XML_DEPRECATED)
@@ -682,8 +702,6 @@ XML_GLOBALS_TREE
 #undef XML_OP
 
 #if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)
-  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
-  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
   #define xmlRegisterNodeDefaultValue \
     XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
   #define xmlDeregisterNodeDefaultValue \
@@ -698,7 +716,6 @@ XMLPUBFUN int
 		xmlValidateNCName	(const xmlChar *value,
 					 int space);
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN int
 		xmlValidateQName	(const xmlChar *value,
 					 int space);
@@ -708,7 +725,6 @@ XMLPUBFUN int
 XMLPUBFUN int
 		xmlValidateNMToken	(const xmlChar *value,
 					 int space);
-#endif
 
 XMLPUBFUN xmlChar *
 		xmlBuildQName		(const xmlChar *ncname,
@@ -726,8 +742,10 @@ XMLPUBFUN const xmlChar *
  * Handling Buffers, the old ones see @xmlBuf for the new ones.
  */
 
+XML_DEPRECATED
 XMLPUBFUN void
 		xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);
+XML_DEPRECATED
 XMLPUBFUN xmlBufferAllocationScheme
 		xmlGetBufferAllocationScheme(void);
 
@@ -738,6 +756,7 @@ XMLPUBFUN xmlBufferPtr
 XMLPUBFUN xmlBufferPtr
 		xmlBufferCreateStatic	(void *mem,
 					 size_t size);
+XML_DEPRECATED
 XMLPUBFUN int
 		xmlBufferResize		(xmlBufferPtr buf,
 					 unsigned int size);
@@ -760,9 +779,11 @@ XMLPUBFUN int
 XMLPUBFUN int
 		xmlBufferCCat		(xmlBufferPtr buf,
 					 const char *str);
+XML_DEPRECATED
 XMLPUBFUN int
 		xmlBufferShrink		(xmlBufferPtr buf,
 					 unsigned int len);
+XML_DEPRECATED
 XMLPUBFUN int
 		xmlBufferGrow		(xmlBufferPtr buf,
 					 unsigned int len);
@@ -795,13 +816,6 @@ XMLPUBFUN xmlDtdPtr
 		xmlGetIntSubset		(const xmlDoc *doc);
 XMLPUBFUN void
 		xmlFreeDtd		(xmlDtdPtr cur);
-#ifdef LIBXML_LEGACY_ENABLED
-XML_DEPRECATED
-XMLPUBFUN xmlNsPtr
-		xmlNewGlobalNs		(xmlDocPtr doc,
-					 const xmlChar *href,
-					 const xmlChar *prefix);
-#endif /* LIBXML_LEGACY_ENABLED */
 XMLPUBFUN xmlNsPtr
 		xmlNewNs		(xmlNodePtr node,
 					 const xmlChar *href,
@@ -818,13 +832,10 @@ XMLPUBFUN xmlAttrPtr
 		xmlNewDocProp		(xmlDocPtr doc,
 					 const xmlChar *name,
 					 const xmlChar *value);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN xmlAttrPtr
 		xmlNewProp		(xmlNodePtr node,
 					 const xmlChar *name,
 					 const xmlChar *value);
-#endif
 XMLPUBFUN xmlAttrPtr
 		xmlNewNsProp		(xmlNodePtr node,
 					 xmlNsPtr ns,
@@ -845,15 +856,11 @@ XMLPUBFUN xmlAttrPtr
 XMLPUBFUN xmlAttrPtr
 		xmlCopyPropList		(xmlNodePtr target,
 					 xmlAttrPtr cur);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlDtdPtr
 		xmlCopyDtd		(xmlDtdPtr dtd);
-#endif /* LIBXML_TREE_ENABLED */
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN xmlDocPtr
 		xmlCopyDoc		(xmlDocPtr doc,
 					 int recursive);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
 /*
  * Creating new nodes.
  */
@@ -873,13 +880,11 @@ XMLPUBFUN xmlNodePtr
 XMLPUBFUN xmlNodePtr
 		xmlNewNodeEatName	(xmlNsPtr ns,
 					 xmlChar *name);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN xmlNodePtr
 		xmlNewChild		(xmlNodePtr parent,
 					 xmlNsPtr ns,
 					 const xmlChar *name,
 					 const xmlChar *content);
-#endif
 XMLPUBFUN xmlNodePtr
 		xmlNewDocText		(const xmlDoc *doc,
 					 const xmlChar *content);
@@ -926,7 +931,6 @@ XMLPUBFUN xmlNodePtr
 					 xmlNodePtr node);
 XMLPUBFUN xmlNodePtr
 		xmlCopyNodeList		(xmlNodePtr node);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlNodePtr
 		xmlNewTextChild		(xmlNodePtr parent,
 					 xmlNsPtr ns,
@@ -939,17 +943,14 @@ XMLPUBFUN xmlNodePtr
 					 const xmlChar *content);
 XMLPUBFUN xmlNodePtr
 		xmlNewDocFragment	(xmlDocPtr doc);
-#endif /* LIBXML_TREE_ENABLED */
 
 /*
  * Navigating.
  */
 XMLPUBFUN long
 		xmlGetLineNo		(const xmlNode *node);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
 XMLPUBFUN xmlChar *
 		xmlGetNodePath		(const xmlNode *node);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
 XMLPUBFUN xmlNodePtr
 		xmlDocGetRootElement	(const xmlDoc *doc);
 XMLPUBFUN xmlNodePtr
@@ -962,33 +963,24 @@ XMLPUBFUN int
 /*
  * Changing the structure.
  */
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 XMLPUBFUN xmlNodePtr
 		xmlDocSetRootElement	(xmlDocPtr doc,
 					 xmlNodePtr root);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN void
 		xmlNodeSetName		(xmlNodePtr cur,
 					 const xmlChar *name);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN xmlNodePtr
 		xmlAddChild		(xmlNodePtr parent,
 					 xmlNodePtr cur);
 XMLPUBFUN xmlNodePtr
 		xmlAddChildList		(xmlNodePtr parent,
 					 xmlNodePtr cur);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 XMLPUBFUN xmlNodePtr
 		xmlReplaceNode		(xmlNodePtr old,
 					 xmlNodePtr cur);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
 XMLPUBFUN xmlNodePtr
 		xmlAddPrevSibling	(xmlNodePtr cur,
 					 xmlNodePtr elem);
-#endif /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
 XMLPUBFUN xmlNodePtr
 		xmlAddSibling		(xmlNodePtr cur,
 					 xmlNodePtr elem);
@@ -1025,8 +1017,6 @@ XMLPUBFUN xmlNsPtr
 		xmlSearchNsByHref	(xmlDocPtr doc,
 					 xmlNodePtr node,
 					 const xmlChar *href);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN int
 		xmlGetNsListSafe	(const xmlDoc *doc,
 					 const xmlNode *node,
@@ -1034,7 +1024,6 @@ XMLPUBFUN int
 XMLPUBFUN xmlNsPtr *
 		xmlGetNsList		(const xmlDoc *doc,
 					 const xmlNode *node);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */
 
 XMLPUBFUN void
 		xmlSetNs		(xmlNodePtr node,
@@ -1047,8 +1036,6 @@ XMLPUBFUN xmlNsPtr
 /*
  * Changing the content.
  */
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
 XMLPUBFUN xmlAttrPtr
 		xmlSetProp		(xmlNodePtr node,
 					 const xmlChar *name,
@@ -1058,8 +1045,6 @@ XMLPUBFUN xmlAttrPtr
 					 xmlNsPtr ns,
 					 const xmlChar *name,
 					 const xmlChar *value);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
-	  defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
 XMLPUBFUN int
 		xmlNodeGetAttrValue	(const xmlNode *node,
 					 const xmlChar *name,
@@ -1093,21 +1078,17 @@ XMLPUBFUN xmlChar *
 		xmlNodeListGetString	(xmlDocPtr doc,
 					 const xmlNode *list,
 					 int inLine);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlChar *
 		xmlNodeListGetRawString	(const xmlDoc *doc,
 					 const xmlNode *list,
 					 int inLine);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN int
 		xmlNodeSetContent	(xmlNodePtr cur,
 					 const xmlChar *content);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN int
 		xmlNodeSetContentLen	(xmlNodePtr cur,
 					 const xmlChar *content,
 					 int len);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN int
 		xmlNodeAddContent	(xmlNodePtr cur,
 					 const xmlChar *content);
@@ -1129,14 +1110,12 @@ XMLPUBFUN xmlChar *
 		xmlNodeGetLang		(const xmlNode *cur);
 XMLPUBFUN int
 		xmlNodeGetSpacePreserve	(const xmlNode *cur);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN int
 		xmlNodeSetLang		(xmlNodePtr cur,
 					 const xmlChar *lang);
 XMLPUBFUN int
 		xmlNodeSetSpacePreserve (xmlNodePtr cur,
 					 int val);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN int
 		xmlNodeGetBaseSafe	(const xmlDoc *doc,
 					 const xmlNode *cur,
@@ -1144,18 +1123,15 @@ XMLPUBFUN int
 XMLPUBFUN xmlChar *
 		xmlNodeGetBase		(const xmlDoc *doc,
 					 const xmlNode *cur);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
 XMLPUBFUN int
 		xmlNodeSetBase		(xmlNodePtr cur,
 					 const xmlChar *uri);
-#endif
 
 /*
  * Removing content.
  */
 XMLPUBFUN int
 		xmlRemoveProp		(xmlAttrPtr cur);
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 XMLPUBFUN int
 		xmlUnsetNsProp		(xmlNodePtr node,
 					 xmlNsPtr ns,
@@ -1163,7 +1139,6 @@ XMLPUBFUN int
 XMLPUBFUN int
 		xmlUnsetProp		(xmlNodePtr node,
 					 const xmlChar *name);
-#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
 
 /*
  * Internal, don't use.
@@ -1185,14 +1160,12 @@ XMLPUBFUN void xmlAttrSerializeTxtContent(xmlBufferPtr buf,
 					 const xmlChar *string);
 #endif /* LIBXML_OUTPUT_ENABLED */
 
-#ifdef LIBXML_TREE_ENABLED
 /*
  * Namespace handling.
  */
 XMLPUBFUN int
 		xmlReconciliateNs	(xmlDocPtr doc,
 					 xmlNodePtr tree);
-#endif
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /*
@@ -1333,7 +1306,6 @@ XMLPUBFUN int
 					 int deep,
 					 int options);
 
-#ifdef LIBXML_TREE_ENABLED
 /*
  * 5 interfaces from DOM ElementTraversal, but different in entities
  * traversal.
@@ -1348,7 +1320,6 @@ XMLPUBFUN xmlNodePtr
             xmlLastElementChild         (xmlNodePtr parent);
 XMLPUBFUN xmlNodePtr
             xmlPreviousElementSibling   (xmlNodePtr node);
-#endif
 
 XML_DEPRECATED
 XMLPUBFUN xmlRegisterNodeFunc
@@ -1374,3 +1345,5 @@ XML_DEPRECATED XMLPUBFUN int
 
 #endif /* __XML_TREE_H__ */
 
+#endif /* XML_TREE_INTERNALS */
+
diff --git a/include/libxml/valid.h b/include/libxml/valid.h
index 361e9655..7345ca57 100644
--- a/include/libxml/valid.h
+++ b/include/libxml/valid.h
@@ -11,12 +11,16 @@
 #ifndef __XML_VALID_H__
 #define __XML_VALID_H__
 
+/** DOC_DISABLE */
 #include <libxml/xmlversion.h>
 #include <libxml/xmlerror.h>
+#define XML_TREE_INTERNALS
 #include <libxml/tree.h>
+#undef XML_TREE_INTERNALS
 #include <libxml/list.h>
 #include <libxml/xmlautomata.h>
 #include <libxml/xmlregexp.h>
+/** DOC_ENABLE */
 
 #ifdef __cplusplus
 extern "C" {
@@ -141,10 +145,8 @@ XMLPUBFUN xmlNotationPtr
 					 const xmlChar *name,
 					 const xmlChar *PublicID,
 					 const xmlChar *SystemID);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlNotationTablePtr
 		xmlCopyNotationTable	(xmlNotationTablePtr table);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN void
 		xmlFreeNotationTable	(xmlNotationTablePtr table);
 #ifdef LIBXML_OUTPUT_ENABLED
@@ -198,10 +200,8 @@ XMLPUBFUN xmlElementPtr
 					 const xmlChar *name,
 					 xmlElementTypeVal type,
 					 xmlElementContentPtr content);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlElementTablePtr
 		xmlCopyElementTable	(xmlElementTablePtr table);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN void
 		xmlFreeElementTable	(xmlElementTablePtr table);
 #ifdef LIBXML_OUTPUT_ENABLED
@@ -220,10 +220,8 @@ XMLPUBFUN xmlEnumerationPtr
 		xmlCreateEnumeration	(const xmlChar *name);
 XMLPUBFUN void
 		xmlFreeEnumeration	(xmlEnumerationPtr cur);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlEnumerationPtr
 		xmlCopyEnumeration	(xmlEnumerationPtr cur);
-#endif /* LIBXML_TREE_ENABLED */
 
 /* Attribute */
 XMLPUBFUN xmlAttributePtr
@@ -236,10 +234,8 @@ XMLPUBFUN xmlAttributePtr
 					 xmlAttributeDefault def,
 					 const xmlChar *defaultValue,
 					 xmlEnumerationPtr tree);
-#ifdef LIBXML_TREE_ENABLED
 XMLPUBFUN xmlAttributeTablePtr
 		xmlCopyAttributeTable  (xmlAttributeTablePtr table);
-#endif /* LIBXML_TREE_ENABLED */
 XMLPUBFUN void
 		xmlFreeAttributeTable  (xmlAttributeTablePtr table);
 #ifdef LIBXML_OUTPUT_ENABLED
@@ -384,15 +380,12 @@ XML_DEPRECATED
 XMLPUBFUN int
 		xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,
 					 xmlDocPtr doc);
-#endif /* LIBXML_VALID_ENABLED */
-
-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 XML_DEPRECATED
 XMLPUBFUN int
 		xmlValidateNotationUse	(xmlValidCtxtPtr ctxt,
 					 xmlDocPtr doc,
 					 const xmlChar *notationName);
-#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
+#endif /* LIBXML_VALID_ENABLED */
 
 XMLPUBFUN int
 		xmlIsMixedElement	(xmlDocPtr doc,
diff --git a/include/libxml/xinclude.h b/include/libxml/xinclude.h
index da3623db..e1cb39fe 100644
--- a/include/libxml/xinclude.h
+++ b/include/libxml/xinclude.h
@@ -14,7 +14,9 @@
 #define __XML_XINCLUDE_H__
 
 #include <libxml/xmlversion.h>
+#include <libxml/xmlerror.h>
 #include <libxml/tree.h>
+#include <libxml/parser.h>
 
 #ifdef LIBXML_XINCLUDE_ENABLED
 
diff --git a/include/libxml/xmlIO.h b/include/libxml/xmlIO.h
index 81f850e2..11d41a33 100644
--- a/include/libxml/xmlIO.h
+++ b/include/libxml/xmlIO.h
@@ -10,10 +10,14 @@
 #ifndef __XML_IO_H__
 #define __XML_IO_H__
 
+/** DOC_DISABLE */
 #include <stdio.h>
 #include <libxml/xmlversion.h>
 #include <libxml/encoding.h>
+#define XML_TREE_INTERNALS
 #include <libxml/tree.h>
+#undef XML_TREE_INTERNALS
+/** DOC_ENABLE */
 
 #ifdef __cplusplus
 extern "C" {
@@ -207,6 +211,7 @@ XMLPUBFUN xmlParserInputBufferPtr
 XMLPUBFUN xmlParserInputBufferPtr
 	xmlParserInputBufferCreateFilename	(const char *URI,
                                                  xmlCharEncoding enc);
+XML_DEPRECATED
 XMLPUBFUN xmlParserInputBufferPtr
 	xmlParserInputBufferCreateFile		(FILE *file,
                                                  xmlCharEncoding enc);
@@ -224,12 +229,15 @@ XMLPUBFUN xmlParserInputBufferPtr
 						 xmlInputCloseCallback  ioclose,
 						 void *ioctx,
 	                                         xmlCharEncoding enc);
+XML_DEPRECATED
 XMLPUBFUN int
 	xmlParserInputBufferRead		(xmlParserInputBufferPtr in,
 						 int len);
+XML_DEPRECATED
 XMLPUBFUN int
 	xmlParserInputBufferGrow		(xmlParserInputBufferPtr in,
 						 int len);
+XML_DEPRECATED
 XMLPUBFUN int
 	xmlParserInputBufferPush		(xmlParserInputBufferPtr in,
 						 int len,
diff --git a/include/libxml/xmlautomata.h b/include/libxml/xmlautomata.h
index ea38eb37..f40e8af9 100644
--- a/include/libxml/xmlautomata.h
+++ b/include/libxml/xmlautomata.h
@@ -13,7 +13,6 @@
 #include <libxml/xmlversion.h>
 
 #ifdef LIBXML_REGEXP_ENABLED
-#ifdef LIBXML_AUTOMATA_ENABLED
 
 #include <libxml/xmlstring.h>
 
@@ -140,7 +139,6 @@ XMLPUBFUN int
 }
 #endif
 
-#endif /* LIBXML_AUTOMATA_ENABLED */
 #endif /* LIBXML_REGEXP_ENABLED */
 
 #endif /* __XML_AUTOMATA_H__ */
diff --git a/include/libxml/xmlerror.h b/include/libxml/xmlerror.h
index 36381bec..d847bfde 100644
--- a/include/libxml/xmlerror.h
+++ b/include/libxml/xmlerror.h
@@ -865,8 +865,16 @@ typedef void (*xmlGenericErrorFunc) (void *ctx,
 typedef void (*xmlStructuredErrorFunc) (void *userData, const xmlError *error);
 
 /** DOC_DISABLE */
+#if defined(LIBXML_THREAD_ENABLED)
+XML_DEPRECATED
+XMLPUBFUN const xmlError *
+__xmlLastError(void);
+#elif !defined(IN_LIBXML)
+XML_DEPRECATED
+XMLPUBVAR const xmlError xmlLastError;
+#endif
+
 #define XML_GLOBALS_ERROR \
-  XML_OP(xmlLastError, xmlError, XML_DEPRECATED) \
   XML_OP(xmlGenericError, xmlGenericErrorFunc, XML_NO_ATTR) \
   XML_OP(xmlGenericErrorContext, void *, XML_NO_ATTR) \
   XML_OP(xmlStructuredError, xmlStructuredErrorFunc, XML_NO_ATTR) \
diff --git a/include/libxml/xmlexports.h b/include/libxml/xmlexports.h
index 5ac1e217..52267fae 100644
--- a/include/libxml/xmlexports.h
+++ b/include/libxml/xmlexports.h
@@ -41,14 +41,6 @@
  * Attributes
  */
 
-#ifndef ATTRIBUTE_UNUSED
-# if __GNUC__ * 100 + __GNUC_MINOR__ >= 207
-#  define ATTRIBUTE_UNUSED __attribute__((unused))
-# else
-#  define ATTRIBUTE_UNUSED
-# endif
-#endif
-
 #if !defined(__clang__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)
   #define LIBXML_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))
 #else
@@ -67,7 +59,7 @@
     #define XML_DEPRECATED
   #elif __GNUC__ * 100 + __GNUC_MINOR__ >= 301
     #define XML_DEPRECATED __attribute__((deprecated))
-  #elif _MSC_VER >= 1400
+  #elif defined(_MSC_VER) && _MSC_VER >= 1400
     /* Available since Visual Studio 2005 */
     #define XML_DEPRECATED __declspec(deprecated)
   #else
@@ -110,7 +102,7 @@
   #define XML_POP_WARNINGS \
     _Pragma("GCC diagnostic pop")
 
-#elif _MSC_VER >= 1400
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
 
   #define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))
   #define XML_POP_WARNINGS __pragma(warning(pop))
diff --git a/include/libxml/xmlmemory.h b/include/libxml/xmlmemory.h
index 1de3e9fc..9a57b129 100644
--- a/include/libxml/xmlmemory.h
+++ b/include/libxml/xmlmemory.h
@@ -112,12 +112,14 @@ XMLPUBFUN int
 			 xmlMallocFunc *mallocFunc,
 			 xmlReallocFunc *reallocFunc,
 			 xmlStrdupFunc *strdupFunc);
+XML_DEPRECATED
 XMLPUBFUN int
 	xmlGcMemSetup	(xmlFreeFunc freeFunc,
 			 xmlMallocFunc mallocFunc,
 			 xmlMallocFunc mallocAtomicFunc,
 			 xmlReallocFunc reallocFunc,
 			 xmlStrdupFunc strdupFunc);
+XML_DEPRECATED
 XMLPUBFUN int
 	xmlGcMemGet	(xmlFreeFunc *freeFunc,
 			 xmlMallocFunc *mallocFunc,
diff --git a/include/libxml/xmlmodule.h b/include/libxml/xmlmodule.h
index 279986c1..5db55856 100644
--- a/include/libxml/xmlmodule.h
+++ b/include/libxml/xmlmodule.h
@@ -37,15 +37,19 @@ typedef enum {
     XML_MODULE_LOCAL= 2		/* local binding */
 } xmlModuleOption;
 
+XML_DEPRECATED
 XMLPUBFUN xmlModulePtr xmlModuleOpen	(const char *filename,
 						 int options);
 
+XML_DEPRECATED
 XMLPUBFUN int xmlModuleSymbol		(xmlModulePtr module,
 						 const char* name,
 						 void **result);
 
+XML_DEPRECATED
 XMLPUBFUN int xmlModuleClose		(xmlModulePtr module);
 
+XML_DEPRECATED
 XMLPUBFUN int xmlModuleFree		(xmlModulePtr module);
 
 #ifdef __cplusplus
diff --git a/include/libxml/xmlreader.h b/include/libxml/xmlreader.h
index 35124a32..65e5cc75 100644
--- a/include/libxml/xmlreader.h
+++ b/include/libxml/xmlreader.h
@@ -18,7 +18,6 @@
 #include <libxml/relaxng.h>
 #include <libxml/xmlschemas.h>
 #endif
-/* for compatibility */
 #include <libxml/parser.h>
 
 #ifdef __cplusplus
diff --git a/include/libxml/xmlregexp.h b/include/libxml/xmlregexp.h
index 2d66437a..210f99b3 100644
--- a/include/libxml/xmlregexp.h
+++ b/include/libxml/xmlregexp.h
@@ -99,113 +99,7 @@ XMLPUBFUN int
 					 int *nbneg,
 					 xmlChar **values,
 					 int *terminal);
-#ifdef LIBXML_EXPR_ENABLED
-/*
- * Formal regular expression handling
- * Its goal is to do some formal work on content models
- */
-
-/* expressions are used within a context */
-typedef struct _xmlExpCtxt xmlExpCtxt;
-typedef xmlExpCtxt *xmlExpCtxtPtr;
-
-XMLPUBFUN void
-			xmlExpFreeCtxt	(xmlExpCtxtPtr ctxt);
-XMLPUBFUN xmlExpCtxtPtr
-			xmlExpNewCtxt	(int maxNodes,
-					 xmlDictPtr dict);
-
-XMLPUBFUN int
-			xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);
-XMLPUBFUN int
-			xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);
-
-/* Expressions are trees but the tree is opaque */
-typedef struct _xmlExpNode xmlExpNode;
-typedef xmlExpNode *xmlExpNodePtr;
-
-typedef enum {
-    XML_EXP_EMPTY = 0,
-    XML_EXP_FORBID = 1,
-    XML_EXP_ATOM = 2,
-    XML_EXP_SEQ = 3,
-    XML_EXP_OR = 4,
-    XML_EXP_COUNT = 5
-} xmlExpNodeType;
-
-/*
- * 2 core expressions shared by all for the empty language set
- * and for the set with just the empty token
- */
-XMLPUBVAR xmlExpNodePtr forbiddenExp;
-XMLPUBVAR xmlExpNodePtr emptyExp;
-
-/*
- * Expressions are reference counted internally
- */
-XMLPUBFUN void
-			xmlExpFree	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr);
-XMLPUBFUN void
-			xmlExpRef	(xmlExpNodePtr expr);
 
-/*
- * constructors can be either manual or from a string
- */
-XMLPUBFUN xmlExpNodePtr
-			xmlExpParse	(xmlExpCtxtPtr ctxt,
-					 const char *expr);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpNewAtom	(xmlExpCtxtPtr ctxt,
-					 const xmlChar *name,
-					 int len);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpNewOr	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr left,
-					 xmlExpNodePtr right);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpNewSeq	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr left,
-					 xmlExpNodePtr right);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpNewRange	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr subset,
-					 int min,
-					 int max);
-/*
- * The really interesting APIs
- */
-XMLPUBFUN int
-			xmlExpIsNillable(xmlExpNodePtr expr);
-XMLPUBFUN int
-			xmlExpMaxToken	(xmlExpNodePtr expr);
-XMLPUBFUN int
-			xmlExpGetLanguage(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr,
-					 const xmlChar**langList,
-					 int len);
-XMLPUBFUN int
-			xmlExpGetStart	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr,
-					 const xmlChar**tokList,
-					 int len);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpStringDerive(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr,
-					 const xmlChar *str,
-					 int len);
-XMLPUBFUN xmlExpNodePtr
-			xmlExpExpDerive	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr,
-					 xmlExpNodePtr sub);
-XMLPUBFUN int
-			xmlExpSubsume	(xmlExpCtxtPtr ctxt,
-					 xmlExpNodePtr expr,
-					 xmlExpNodePtr sub);
-XMLPUBFUN void
-			xmlExpDump	(xmlBufferPtr buf,
-					 xmlExpNodePtr expr);
-#endif /* LIBXML_EXPR_ENABLED */
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/libxml/xmlsave.h b/include/libxml/xmlsave.h
index e266e467..176b1c7a 100644
--- a/include/libxml/xmlsave.h
+++ b/include/libxml/xmlsave.h
@@ -34,7 +34,11 @@ typedef enum {
     XML_SAVE_XHTML	= 1<<4, /* force XHTML1 specific rules */
     XML_SAVE_AS_XML     = 1<<5, /* force XML serialization on HTML doc */
     XML_SAVE_AS_HTML    = 1<<6, /* force HTML serialization on XML doc */
-    XML_SAVE_WSNONSIG   = 1<<7  /* format with non-significant whitespace */
+    XML_SAVE_WSNONSIG   = 1<<7, /* format with non-significant whitespace */
+    /* Available since 2.14.0 */
+    XML_SAVE_EMPTY      = 1<<8, /* force empty tags, overriding global */
+    XML_SAVE_NO_INDENT  = 1<<9, /* disable indenting */
+    XML_SAVE_INDENT     = 1<<10 /* force indenting, overriding global */
 } xmlSaveOption;
 
 
@@ -75,9 +79,14 @@ XMLPUBFUN int
 		xmlSaveClose		(xmlSaveCtxtPtr ctxt);
 XMLPUBFUN int
 		xmlSaveFinish		(xmlSaveCtxtPtr ctxt);
+XMLPUBFUN int
+		xmlSaveSetIndentString	(xmlSaveCtxtPtr ctxt,
+					 const char *indent);
+XML_DEPRECATED
 XMLPUBFUN int
 		xmlSaveSetEscape	(xmlSaveCtxtPtr ctxt,
 					 xmlCharEncodingOutputFunc escape);
+XML_DEPRECATED
 XMLPUBFUN int
 		xmlSaveSetAttrEscape	(xmlSaveCtxtPtr ctxt,
 					 xmlCharEncodingOutputFunc escape);
diff --git a/include/libxml/xmlversion.h b/include/libxml/xmlversion.h
index 807b82e0..f0d63e19 100644
--- a/include/libxml/xmlversion.h
+++ b/include/libxml/xmlversion.h
@@ -36,7 +36,7 @@
  *
  * extra version information, used to show a git commit description
  */
-#define LIBXML_VERSION_EXTRA "-GITv2.13.0-1355-g03bcb01c7"
+#define LIBXML_VERSION_EXTRA "-GITv2.13.0-1651-gccfe2bdd"
 
 /**
  * LIBXML_TEST_VERSION:
@@ -67,7 +67,7 @@
 /**
  * LIBXML_TREE_ENABLED:
  *
- * Whether the DOM like tree manipulation API support is configured in
+ * Always enabled since 2.14.0
  */
 #if 1
 #define LIBXML_TREE_ENABLED
@@ -335,7 +335,6 @@
 
 #ifdef __GNUC__
 /** DOC_DISABLE */
-
 #ifndef ATTRIBUTE_UNUSED
 # if ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))
 #  define ATTRIBUTE_UNUSED __attribute__((unused))
diff --git a/include/libxml/xmlversion.h.in b/include/libxml/xmlversion.h.in
index 0525b4ad..000a0fa9 100644
--- a/include/libxml/xmlversion.h.in
+++ b/include/libxml/xmlversion.h.in
@@ -67,11 +67,9 @@
 /**
  * LIBXML_TREE_ENABLED:
  *
- * Whether the DOM like tree manipulation API support is configured in
+ * Always enabled since 2.14.0
  */
-#if @WITH_TREE@
 #define LIBXML_TREE_ENABLED
-#endif
 
 /**
  * LIBXML_OUTPUT_ENABLED:
diff --git a/include/libxml/xpath.h b/include/libxml/xpath.h
index 902a1983..e089ac78 100644
--- a/include/libxml/xpath.h
+++ b/include/libxml/xpath.h
@@ -26,15 +26,10 @@
 #include <libxml/xmlerror.h>
 #include <libxml/tree.h>
 #include <libxml/hash.h>
-#endif /* LIBXML_XPATH_ENABLED */
 
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 #ifdef __cplusplus
 extern "C" {
 #endif
-#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED */
-
-#ifdef LIBXML_XPATH_ENABLED
 
 typedef struct _xmlXPathContext xmlXPathContext;
 typedef xmlXPathContext *xmlXPathContextPtr;
@@ -554,8 +549,7 @@ XMLPUBFUN int
 						 xmlXPathContextPtr ctxt);
 XMLPUBFUN void
 		    xmlXPathFreeCompExpr	(xmlXPathCompExprPtr comp);
-#endif /* LIBXML_XPATH_ENABLED */
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+
 XML_DEPRECATED
 XMLPUBFUN void
 		    xmlXPathInit		(void);
@@ -568,5 +562,5 @@ XMLPUBFUN int
 }
 #endif
 
-#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED*/
+#endif /* LIBXML_XPATH_ENABLED */
 #endif /* ! __XML_XPATH_H__ */
diff --git a/include/private/Makefile.am b/include/private/Makefile.am
index 29c0bdd6..5e1cdf84 100644
--- a/include/private/Makefile.am
+++ b/include/private/Makefile.am
@@ -1,5 +1,6 @@
 EXTRA_DIST = \
 	buf.h \
+	cata.h \
 	dict.h \
 	enc.h \
 	entities.h \
@@ -11,6 +12,7 @@ EXTRA_DIST = \
 	parser.h \
 	regexp.h \
 	save.h \
+	shell.h \
 	string.h \
 	threads.h \
 	tree.h \
diff --git a/include/private/buf.h b/include/private/buf.h
index 982b9eea..a8a568b1 100644
--- a/include/private/buf.h
+++ b/include/private/buf.h
@@ -1,57 +1,41 @@
 #ifndef XML_BUF_H_PRIVATE__
 #define XML_BUF_H_PRIVATE__
 
+#include <libxml/parser.h>
 #include <libxml/tree.h>
 
 XML_HIDDEN xmlBufPtr
-xmlBufCreate(void);
+xmlBufCreate(size_t size);
 XML_HIDDEN xmlBufPtr
-xmlBufCreateSize(size_t size);
-
-XML_HIDDEN int
-xmlBufSetAllocationScheme(xmlBufPtr buf, xmlBufferAllocationScheme scheme);
-XML_HIDDEN int
-xmlBufGetAllocationScheme(xmlBufPtr buf);
-
+xmlBufCreateMem(const xmlChar *mem, size_t size, int isStatic);
 XML_HIDDEN void
 xmlBufFree(xmlBufPtr buf);
+
 XML_HIDDEN void
 xmlBufEmpty(xmlBufPtr buf);
 
-/* size_t xmlBufShrink(xmlBufPtr buf, size_t len); */
-XML_HIDDEN int
-xmlBufGrow(xmlBufPtr buf, int len);
 XML_HIDDEN int
-xmlBufResize(xmlBufPtr buf, size_t len);
+xmlBufGrow(xmlBufPtr buf, size_t len);
 
 XML_HIDDEN int
-xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len);
+xmlBufAdd(xmlBufPtr buf, const xmlChar *str, size_t len);
 XML_HIDDEN int
 xmlBufCat(xmlBufPtr buf, const xmlChar *str);
 
 XML_HIDDEN size_t
 xmlBufAvail(const xmlBufPtr buf);
-XML_HIDDEN size_t
-xmlBufLength(const xmlBufPtr buf);
-/* size_t xmlBufUse(const xmlBufPtr buf); */
 XML_HIDDEN int
 xmlBufIsEmpty(const xmlBufPtr buf);
 XML_HIDDEN int
 xmlBufAddLen(xmlBufPtr buf, size_t len);
 
-/* const xmlChar * xmlBufContent(const xmlBuf *buf); */
-/* const xmlChar * xmlBufEnd(xmlBufPtr buf); */
-
 XML_HIDDEN xmlChar *
 xmlBufDetach(xmlBufPtr buf);
 
-XML_HIDDEN size_t
-xmlBufDump(FILE *file, xmlBufPtr buf);
-
 XML_HIDDEN xmlBufPtr
 xmlBufFromBuffer(xmlBufferPtr buffer);
-XML_HIDDEN xmlBufferPtr
-xmlBufBackToBuffer(xmlBufPtr buf);
+XML_HIDDEN int
+xmlBufBackToBuffer(xmlBufPtr buf, xmlBufferPtr ret);
 
 XML_HIDDEN int
 xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input);
diff --git a/include/private/cata.h b/include/private/cata.h
new file mode 100644
index 00000000..789808aa
--- /dev/null
+++ b/include/private/cata.h
@@ -0,0 +1,13 @@
+#ifndef XML_CATA_H_PRIVATE__
+#define XML_CATA_H_PRIVATE__
+
+#ifdef LIBXML_CATALOG_ENABLED
+
+XML_HIDDEN void
+xmlInitCatalogInternal(void);
+XML_HIDDEN void
+xmlCleanupCatalogInternal(void);
+
+#endif /* LIBXML_CATALOG_ENABLED */
+
+#endif /* XML_CATA_H_PRIVATE__ */
diff --git a/include/private/enc.h b/include/private/enc.h
index cd549145..864025f8 100644
--- a/include/private/enc.h
+++ b/include/private/enc.h
@@ -11,7 +11,7 @@ XML_HIDDEN int
 xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
                  int *outlen, const unsigned char *in, int *inlen);
 XML_HIDDEN int
-xmlCharEncInput(xmlParserInputBufferPtr input);
+xmlCharEncInput(xmlParserInputBufferPtr input, size_t *sizeOut);
 XML_HIDDEN int
 xmlCharEncOutput(xmlOutputBufferPtr output, int init);
 
diff --git a/include/private/entities.h b/include/private/entities.h
index d262ef47..d038cf05 100644
--- a/include/private/entities.h
+++ b/include/private/entities.h
@@ -21,7 +21,22 @@
 #define XML_ENT_VALIDATED   (1u << 2)
 #define XML_ENT_EXPANDING   (1u << 3)
 
+#define XML_ESCAPE_ATTR             (1u << 0)
+#define XML_ESCAPE_NON_ASCII        (1u << 1)
+#define XML_ESCAPE_HTML             (1u << 2)
+#define XML_ESCAPE_QUOT             (1u << 3)
+#define XML_ESCAPE_ALLOW_INVALID    (1u << 4)
+
+XML_HIDDEN int
+xmlSerializeHexCharRef(char *buf, int val);
+XML_HIDDEN int
+xmlSerializeDecCharRef(char *buf, int val);
+
+XML_HIDDEN xmlChar *
+xmlEscapeText(const xmlChar *text, int flags);
+
 XML_HIDDEN xmlChar *
-xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input);
+xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input,
+                          unsigned flags);
 
 #endif /* XML_ENTITIES_H_PRIVATE__ */
diff --git a/include/private/error.h b/include/private/error.h
index 506405a1..d99cfea3 100644
--- a/include/private/error.h
+++ b/include/private/error.h
@@ -1,6 +1,8 @@
 #ifndef XML_ERROR_H_PRIVATE__
 #define XML_ERROR_H_PRIVATE__
 
+#include <stdarg.h>
+
 #include <libxml/xmlerror.h>
 #include <libxml/xmlversion.h>
 
@@ -19,16 +21,23 @@ xmlVRaiseError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,
                const char *str2, const char *str3, int int1, int col,
                const char *msg, va_list ap);
 XML_HIDDEN int
-__xmlRaiseError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,
-                void *data, void *ctx, struct _xmlNode *node,
-                int domain, int code, xmlErrorLevel level,
-                const char *file, int line, const char *str1,
-                const char *str2, const char *str3, int int1, int col,
-	        const char *msg, ...) LIBXML_ATTR_FORMAT(16,17);
+xmlRaiseError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,
+              void *data, void *ctx, struct _xmlNode *node,
+              int domain, int code, xmlErrorLevel level,
+              const char *file, int line, const char *str1,
+              const char *str2, const char *str3, int int1, int col,
+              const char *msg, ...) LIBXML_ATTR_FORMAT(16,17);
 XML_HIDDEN void
 xmlGenericErrorDefaultFunc(void *ctx, const char *msg,
                            ...) LIBXML_ATTR_FORMAT(2,3);
 XML_HIDDEN const char *
 xmlErrString(xmlParserErrors code);
 
+XML_HIDDEN void
+xmlVPrintErrorMessage(const char *fmt, va_list ap);
+XML_HIDDEN void
+xmlPrintErrorMessage(const char *fmt, ...);
+XML_HIDDEN void
+xmlAbort(const char *fmt, ...);
+
 #endif /* XML_ERROR_H_PRIVATE__ */
diff --git a/include/private/globals.h b/include/private/globals.h
index 828b6d50..d111701e 100644
--- a/include/private/globals.h
+++ b/include/private/globals.h
@@ -6,6 +6,9 @@ xmlInitGlobalsInternal(void);
 XML_HIDDEN void
 xmlCleanupGlobalsInternal(void);
 
+XML_HIDDEN xmlError *
+xmlGetLastErrorInternal(void);
+
 #ifdef LIBXML_THREAD_ENABLED
 XML_HIDDEN unsigned *
 xmlGetLocalRngState(void);
diff --git a/include/private/html.h b/include/private/html.h
index 6b499296..415be221 100644
--- a/include/private/html.h
+++ b/include/private/html.h
@@ -5,8 +5,8 @@
 
 #ifdef LIBXML_HTML_ENABLED
 
-XML_HIDDEN void
-__htmlParseContent(void *ctx);
+XML_HIDDEN xmlNodePtr
+htmlCtxtParseContentInternal(xmlParserCtxtPtr ctxt, xmlParserInputPtr input);
 
 #endif /* LIBXML_HTML_ENABLED */
 
diff --git a/include/private/io.h b/include/private/io.h
index 70cbce99..8748c663 100644
--- a/include/private/io.h
+++ b/include/private/io.h
@@ -5,6 +5,16 @@
 #include <libxml/tree.h>
 #include <libxml/xmlversion.h>
 
+/*
+ * Initial buffer size should include
+ *
+ * - MINLEN = 4000 (I/O chunk size)
+ * - INPUT_CHUNK = 250 (parser prefetch)
+ * - LINE_LEN = 80 (shrink limit for error messages)
+ * - some amount for unshrunken content.
+ */
+#define XML_IO_BUFFER_SIZE 6000
+
 XML_HIDDEN void
 xmlInitIOCallbacks(void);
 
@@ -22,8 +32,6 @@ xmlNewInputBufferMemory(const void *mem, size_t size, int flags,
                         xmlCharEncoding enc);
 
 #ifdef LIBXML_OUTPUT_ENABLED
-XML_HIDDEN xmlOutputBufferPtr
-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);
 XML_HIDDEN void
 xmlOutputBufferWriteQuotedString(xmlOutputBufferPtr buf,
                                  const xmlChar *string);
diff --git a/include/private/parser.h b/include/private/parser.h
index 1c18de24..6b585200 100644
--- a/include/private/parser.h
+++ b/include/private/parser.h
@@ -4,6 +4,10 @@
 #include <libxml/parser.h>
 #include <libxml/xmlversion.h>
 
+#define XML_INVALID_CHAR 0x200000
+
+#define XML_MAX_URI_LENGTH 2000
+
 /**
  * XML_VCTXT_DTD_VALIDATED:
  *
@@ -92,26 +96,26 @@ XML_HIDDEN xmlParserInputPtr
 xmlLoadResource(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,
                 xmlResourceType type);
 XML_HIDDEN xmlParserInputPtr
-xmlNewInputURL(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,
-               const char *encoding, int flags);
+xmlCtxtNewInputFromUrl(xmlParserCtxtPtr ctxt, const char *url,
+                       const char *publicId, const char *encoding, int flags);
 XML_HIDDEN xmlParserInputPtr
-xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,
-                  const void *mem, size_t size,
-                  const char *encoding, int flags);
+xmlCtxtNewInputFromMemory(xmlParserCtxtPtr ctxt, const char *url,
+                          const void *mem, size_t size,
+                          const char *encoding, int flags);
 XML_HIDDEN xmlParserInputPtr
-xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url, const char *str,
-                  const char *encoding, int flags);
+xmlCtxtNewInputFromString(xmlParserCtxtPtr ctxt, const char *url,
+                          const char *str, const char *encoding, int flags);
 XML_HIDDEN xmlParserInputPtr
-xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *filename, int fd,
-              const char *encoding, int flags);
+xmlCtxtNewInputFromFd(xmlParserCtxtPtr ctxt, const char *filename, int fd,
+                      const char *encoding, int flags);
 XML_HIDDEN xmlParserInputPtr
-xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,
-              xmlInputReadCallback ioRead,
-              xmlInputCloseCallback ioClose,
-              void *ioCtxt,
-              const char *encoding, int flags);
+xmlCtxtNewInputFromIO(xmlParserCtxtPtr ctxt, const char *url,
+                      xmlInputReadCallback ioRead,
+                      xmlInputCloseCallback ioClose,
+                      void *ioCtxt,
+                      const char *encoding, int flags);
 XML_HIDDEN xmlParserInputPtr
-xmlInputCreatePush(const char *url, const char *chunk, int size);
+xmlNewPushInput(const char *url, const char *chunk, int size);
 
 XML_HIDDEN xmlChar *
 xmlExpandEntitiesInAttValue(xmlParserCtxtPtr ctxt, const xmlChar *str,
diff --git a/include/private/shell.h b/include/private/shell.h
new file mode 100644
index 00000000..53a857e2
--- /dev/null
+++ b/include/private/shell.h
@@ -0,0 +1,7 @@
+#ifndef XML_SHELL_H_PRIVATE__
+#define XML_SHELL_H_PRIVATE__
+
+void
+xmllintShell(xmlDocPtr doc, const char *filename, FILE *output);
+
+#endif /* XML_SHELL_H_PRIVATE__ */
diff --git a/include/private/threads.h b/include/private/threads.h
index 473bc7c0..95b38254 100644
--- a/include/private/threads.h
+++ b/include/private/threads.h
@@ -4,13 +4,17 @@
 #include <libxml/threads.h>
 
 #ifdef LIBXML_THREAD_ENABLED
-  #ifdef HAVE_PTHREAD_H
-    #include <pthread.h>
-    #define HAVE_POSIX_THREADS
-  #elif defined(_WIN32)
+  #ifdef _WIN32
     #define WIN32_LEAN_AND_MEAN
+    #ifdef _WIN32_WINNT
+      #undef _WIN32_WINNT
+    #endif
+    #define _WIN32_WINNT 0x0600
     #include <windows.h>
     #define HAVE_WIN32_THREADS
+  #else
+    #include <pthread.h>
+    #define HAVE_POSIX_THREADS
   #endif
 #endif
 
@@ -27,9 +31,31 @@ struct _xmlMutex {
 #endif
 };
 
+/*
+ * xmlRMutex are reentrant mutual exception locks
+ */
+struct _xmlRMutex {
+#ifdef HAVE_POSIX_THREADS
+    pthread_mutex_t lock;
+    unsigned int held;
+    unsigned int waiters;
+    pthread_t tid;
+    pthread_cond_t cv;
+#elif defined HAVE_WIN32_THREADS
+    CRITICAL_SECTION cs;
+#else
+    int empty;
+#endif
+};
+
 XML_HIDDEN void
 xmlInitMutex(xmlMutexPtr mutex);
 XML_HIDDEN void
 xmlCleanupMutex(xmlMutexPtr mutex);
 
+XML_HIDDEN void
+xmlInitRMutex(xmlRMutexPtr mutex);
+XML_HIDDEN void
+xmlCleanupRMutex(xmlRMutexPtr mutex);
+
 #endif /* XML_THREADS_H_PRIVATE__ */
diff --git a/include/private/tree.h b/include/private/tree.h
index 2d651d53..131e80c6 100644
--- a/include/private/tree.h
+++ b/include/private/tree.h
@@ -1,13 +1,8 @@
 #ifndef XML_TREE_H_PRIVATE__
 #define XML_TREE_H_PRIVATE__
 
-/*
- * Internal variable indicating if a callback has been registered for
- * node creation/destruction. It avoids spending a lot of time in locking
- * function while checking if the callback exists.
- */
 XML_HIDDEN extern int
-__xmlRegisterCallbacks;
+xmlRegisterCallbacks;
 
 XML_HIDDEN int
 xmlSearchNsSafe(xmlNodePtr node, const xmlChar *href, xmlNsPtr *out);
diff --git a/include/wsockcompat.h b/include/wsockcompat.h
index 141de0c6..a9af26b1 100644
--- a/include/wsockcompat.h
+++ b/include/wsockcompat.h
@@ -30,10 +30,6 @@
 #endif
 #endif
 
-#ifndef XML_SOCKLEN_T
-#define XML_SOCKLEN_T int
-#endif
-
 #ifndef ECONNRESET
 #define ECONNRESET WSAECONNRESET
 #endif
diff --git a/iso8859x.inc b/iso8859x.inc
new file mode 100644
index 00000000..f8d6b310
--- /dev/null
+++ b/iso8859x.inc
@@ -0,0 +1,730 @@
+/************************************************************************
+ * Lookup tables for ISO-8859-2..ISO-8859-16 transcoding                *
+ ************************************************************************/
+
+static const unsigned short xmlunicodetable_ISO8859_2 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7,
+    0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
+    0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7,
+    0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
+    0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
+    0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
+    0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
+    0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
+    0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
+    0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
+    0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
+    0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_2 [48 + 6 * 64] = {
+    "\x00\x00\x01\x05\x02\x04\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\x00"
+    "\xb0\x00\x00\x00\xb4\x00\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xc3\xe3\xa1\xb1\xc6\xe6\x00\x00\x00\x00\xc8\xe8\xcf\xef"
+    "\xd0\xf0\x00\x00\x00\x00\x00\x00\xca\xea\xcc\xec\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc5\xe5\x00\x00\xa5\xb5\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\xa2\xff\x00\xb2\x00\xbd\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\xa3\xb3\xd1\xf1\x00\x00\xd2\xf2\x00\x00\x00\x00\x00\x00\x00"
+    "\xd5\xf5\x00\x00\xc0\xe0\x00\x00\xd8\xf8\xa6\xb6\x00\x00\xaa\xba"
+    "\xa9\xb9\xde\xfe\xab\xbb\x00\x00\x00\x00\x00\x00\x00\x00\xd9\xf9"
+    "\xdb\xfb\x00\x00\x00\x00\x00\x00\x00\xac\xbc\xaf\xbf\xae\xbe\x00"
+    "\x00\xc1\xc2\x00\xc4\x00\x00\xc7\x00\xc9\x00\xcb\x00\xcd\xce\x00"
+    "\x00\x00\x00\xd3\xd4\x00\xd6\xd7\x00\x00\xda\x00\xdc\xdd\x00\xdf"
+    "\x00\xe1\xe2\x00\xe4\x00\x00\xe7\x00\xe9\x00\xeb\x00\xed\xee\x00"
+    "\x00\x00\x00\xf3\xf4\x00\xf6\xf7\x00\x00\xfa\x00\xfc\xfd\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_3 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4, 0x0000, 0x0124, 0x00a7,
+    0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0x0000, 0x017b,
+    0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7,
+    0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd, 0x0000, 0x017c,
+    0x00c0, 0x00c1, 0x00c2, 0x0000, 0x00c4, 0x010a, 0x0108, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x0000, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7,
+    0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x0000, 0x00e4, 0x010b, 0x0109, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x0000, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7,
+    0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_3 [48 + 7 * 64] = {
+    "\x04\x00\x01\x06\x02\x05\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\xa3\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\x00"
+    "\xb0\x00\xb2\xb3\xb4\xb5\x00\xb7\xb8\x00\x00\x00\x00\xbd\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\xc6\xe6\xc5\xe5\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd8\xf8\xab\xbb"
+    "\xd5\xf5\x00\x00\xa6\xb6\xa1\xb1\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xa9\xb9\x00\x00\xac\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\xa2\xff\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xfe\xaa\xba"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdd\xfd\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xaf\xbf\x00\x00\x00"
+    "\xc0\xc1\xc2\x00\xc4\x00\x00\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\x00\xd1\xd2\xd3\xd4\x00\xd6\xd7\x00\xd9\xda\xdb\xdc\x00\x00\xdf"
+    "\xe0\xe1\xe2\x00\xe4\x00\x00\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\x00\xf1\xf2\xf3\xf4\x00\xf6\xf7\x00\xf9\xfa\xfb\xfc\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_4 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7,
+    0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af,
+    0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7,
+    0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,
+    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,
+    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,
+    0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,
+    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,
+    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,
+    0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_4 [48 + 6 * 64] = {
+    "\x00\x00\x01\x05\x02\x03\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\xa4\x00\x00\xa7\xa8\x00\x00\x00\x00\xad\x00\xaf"
+    "\xb0\x00\x00\x00\xb4\x00\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
+    "\xc0\xe0\x00\x00\xa1\xb1\x00\x00\x00\x00\x00\x00\xc8\xe8\x00\x00"
+    "\xd0\xf0\xaa\xba\x00\x00\xcc\xec\xca\xea\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xab\xbb\x00\x00\x00\x00\xa5\xb5\xcf\xef\x00\x00\xc7\xe7"
+    "\x00\x00\x00\x00\x00\x00\xd3\xf3\xa2\x00\x00\xa6\xb6\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\xd1\xf1\x00\x00\x00\xbd\xbf\xd2\xf2\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\xa3\xb3\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xa9\xb9\x00\x00\x00\x00\xac\xbc\xdd\xfd\xde\xfe\x00\x00\x00\x00"
+    "\x00\x00\xd9\xf9\x00\x00\x00\x00\x00\x00\x00\x00\x00\xae\xbe\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\xb2\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\x00\x00\xc9\x00\xcb\x00\xcd\xce\x00"
+    "\x00\x00\x00\x00\xd4\xd5\xd6\xd7\xd8\x00\xda\xdb\xdc\x00\x00\xdf"
+    "\x00\xe1\xe2\xe3\xe4\xe5\xe6\x00\x00\xe9\x00\xeb\x00\xed\xee\x00"
+    "\x00\x00\x00\x00\xf4\xf5\xf6\xf7\xf8\x00\xfa\xfb\xfc\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_5 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407,
+    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 0x040f,
+    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
+    0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f,
+    0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
+    0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f,
+    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
+    0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f,
+    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
+    0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f,
+    0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
+    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x00a7, 0x045e, 0x045f,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_5 [48 + 6 * 64] = {
+    "\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x02\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\x00\x00\x00\xfd\x00\x00\x00\x00\x00\xad\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\x00\xae\xaf"
+    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\x00\xfe\xff"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_6 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0000, 0x0000, 0x0000, 0x00a4, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x060c, 0x00ad, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x061b, 0x0000, 0x0000, 0x0000, 0x061f,
+    0x0000, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
+    0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f,
+    0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637,
+    0x0638, 0x0639, 0x063a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647,
+    0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f,
+    0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_6 [48 + 5 * 64] = {
+    "\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x04\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\xa4\x00\x00\x00\x00\x00\x00\x00\x00\xad\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbb\x00\x00\x00\xbf"
+    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\x00\x00\x00\x00\x00"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\xf0\xf1\xf2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_7 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x2018, 0x2019, 0x00a3, 0x0000, 0x0000, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x0000, 0x00ab, 0x00ac, 0x00ad, 0x0000, 0x2015,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 0x0386, 0x00b7,
+    0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 0x00bd, 0x038e, 0x038f,
+    0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
+    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
+    0x03a0, 0x03a1, 0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
+    0x03a8, 0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af,
+    0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
+    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
+    0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
+    0x03c8, 0x03c9, 0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0x0000,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_7 [48 + 7 * 64] = {
+    "\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x06"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\xa3\x00\x00\xa6\xa7\xa8\xa9\x00\xab\xac\xad\x00\x00"
+    "\xb0\xb1\xb2\xb3\x00\x00\x00\xb7\x00\x00\x00\xbb\x00\xbd\x00\x00"
+    "\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\xaf\x00\x00\xa1\xa2\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\xb4\xb5\xb6\x00\xb8\xb9\xba\x00\xbc\x00\xbe\xbf"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\xd0\xd1\x00\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_8 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0000, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017,
+    0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7,
+    0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df,
+    0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7,
+    0x05e8, 0x05e9, 0x05ea, 0x0000, 0x0000, 0x200e, 0x200f, 0x0000,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_8 [48 + 7 * 64] = {
+    "\x02\x00\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\x00\xab\xac\xad\xae\xaf"
+    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\x00\xbb\xbc\xbd\xbe\x00"
+    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\xaa\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\xba\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfd\xfe"
+    "\x00\x00\x00\x00\x00\x00\x00\xdf\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_9 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x011e, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0131, 0x015f, 0x00ff,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_9 [48 + 5 * 64] = {
+    "\x00\x00\x01\x02\x03\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\x00\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\x00\x00\xdf"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\x00\x00\xff"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xf0"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xdd\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xfe"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_10 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7,
+    0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 0x014a,
+    0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 0x0137, 0x00b7,
+    0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 0x2015, 0x016b, 0x014b,
+    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,
+    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x0145, 0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168,
+    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,
+    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x0169,
+    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x0138,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_10 [48 + 7 * 64] = {
+    "\x00\x00\x01\x06\x02\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\x00\x00\x00\xa7\x00\x00\x00\x00\x00\xad\x00\x00"
+    "\xb0\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xc0\xe0\x00\x00\xa1\xb1\x00\x00\x00\x00\x00\x00\xc8\xe8\x00\x00"
+    "\xa9\xb9\xa2\xb2\x00\x00\xcc\xec\xca\xea\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xa3\xb3\x00\x00\x00\x00\xa5\xb5\xa4\xb4\x00\x00\xc7\xe7"
+    "\x00\x00\x00\x00\x00\x00\xa6\xb6\xff\x00\x00\xa8\xb8\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\xd1\xf1\x00\x00\x00\xaf\xbf\xd2\xf2\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xaa\xba\x00\x00\x00\x00\xab\xbb\xd7\xf7\xae\xbe\x00\x00\x00\x00"
+    "\x00\x00\xd9\xf9\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\xbc\x00"
+    "\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\xbd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\xc1\xc2\xc3\xc4\xc5\xc6\x00\x00\xc9\x00\xcb\x00\xcd\xce\xcf"
+    "\xd0\x00\x00\xd3\xd4\xd5\xd6\x00\xd8\x00\xda\xdb\xdc\xdd\xde\xdf"
+    "\x00\xe1\xe2\xe3\xe4\xe5\xe6\x00\x00\xe9\x00\xeb\x00\xed\xee\xef"
+    "\xf0\x00\x00\xf3\xf4\xf5\xf6\x00\xf8\x00\xfa\xfb\xfc\xfd\xfe\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_11 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07,
+    0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f,
+    0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17,
+    0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f,
+    0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27,
+    0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f,
+    0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37,
+    0x0e38, 0x0e39, 0x0e3a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0e3f,
+    0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47,
+    0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f,
+    0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57,
+    0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0x0000, 0x0000, 0x0000, 0x0000,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_11 [48 + 6 * 64] = {
+    "\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x05\x00\x00\x00\x00\x00\x00"
+    "\x00\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\x00\x00\x00\x00\xdf"
+    "\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_13 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7,
+    0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00c6,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 0x00b6, 0x00b7,
+    0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00e6,
+    0x0104, 0x012e, 0x0100, 0x0106, 0x00c4, 0x00c5, 0x0118, 0x0112,
+    0x010c, 0x00c9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012a, 0x013b,
+    0x0160, 0x0143, 0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7,
+    0x0172, 0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df,
+    0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 0x0113,
+    0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 0x012b, 0x013c,
+    0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 0x00f5, 0x00f6, 0x00f7,
+    0x0173, 0x0142, 0x015b, 0x016b, 0x00fc, 0x017c, 0x017e, 0x2019,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_13 [48 + 7 * 64] = {
+    "\x00\x00\x01\x04\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\xa2\xa3\xa4\x00\xa6\xa7\x00\xa9\x00\xab\xac\xad\xae\x00"
+    "\xb0\xb1\xb2\xb3\x00\xb5\xb6\xb7\x00\xb9\x00\xbb\xbc\xbd\xbe\x00"
+    "\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xb4\xa1\xa5\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\xc4\xc5\xaf\x00\x00\xc9\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\xd3\x00\xd5\xd6\xd7\xa8\x00\x00\x00\xdc\x00\x00\xdf"
+    "\x00\x00\x00\x00\xe4\xe5\xbf\x00\x00\xe9\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\xf3\x00\xf5\xf6\xf7\xb8\x00\x00\x00\xfc\x00\x00\x00"
+    "\x00\xd9\xf9\xd1\xf1\xd2\xf2\x00\x00\x00\x00\x00\xd4\xf4\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\xaa\xba\x00\x00\xda\xfa\x00\x00\x00\x00"
+    "\xd0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xfb\x00\x00\x00\x00"
+    "\x00\x00\xd8\xf8\x00\x00\x00\x00\x00\xca\xea\xdd\xfd\xde\xfe\x00"
+    "\xc2\xe2\x00\x00\xc0\xe0\xc3\xe3\x00\x00\x00\x00\xc8\xe8\x00\x00"
+    "\x00\x00\xc7\xe7\x00\x00\xcb\xeb\xc6\xe6\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xcc\xec\x00\x00\x00\x00\x00\x00\xce\xee\x00\x00\xc1\xe1"
+    "\x00\x00\x00\x00\x00\x00\xcd\xed\x00\x00\x00\xcf\xef\x00\x00\x00"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_14 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7,
+    0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 0x0178,
+    0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 0x00b6, 0x1e56,
+    0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 0x1e84, 0x1e85, 0x1e61,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x0174, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x1e6b,
+    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x0177, 0x00ff,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_14 [48 + 10 * 64] = {
+    "\x00\x00\x01\x09\x04\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\xa3\x00\x00\x00\xa7\x00\xa9\x00\x00\x00\xad\xae\x00"
+    "\x00\x00\x00\x00\x00\x00\xb6\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x03\x08\x05\x06\x00\x00\x00\x00"
+    "\x00\x00\xa1\xa2\x00\x00\x00\x00\x00\x00\xa6\xab\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb0\xb1"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\xa5\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xb2\xb3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xa8\xb8\xaa\xba\xbd\xbe\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xac\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\xd0\xf0\xde\xfe\xaf\x00\x00\x00\x00\x00\x00\x00"
+    "\xb4\xb5\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\xb7\xb9\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xbb\xbf\x00\x00\x00\x00\x00\x00\x00\x00\xd7\xf7\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\x00\xd1\xd2\xd3\xd4\xd5\xd6\x00\xd8\xd9\xda\xdb\xdc\xdd\x00\xdf"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\x00\xf1\xf2\xf3\xf4\xf5\xf6\x00\xf8\xf9\xfa\xfb\xfc\xfd\x00\xff"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_15 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7,
+    0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 0x00b6, 0x00b7,
+    0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 0x0153, 0x0178, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_15 [48 + 6 * 64] = {
+    "\x00\x00\x01\x05\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\xa1\xa2\xa3\x00\xa5\x00\xa7\x00\xa9\xaa\xab\xac\xad\xae\xaf"
+    "\xb0\xb1\xb2\xb3\x00\xb5\xb6\xb7\x00\xb9\xba\xbb\x00\x00\x00\xbf"
+    "\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\xbc\xbd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xa6\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\xbe\x00\x00\x00\x00\xb4\xb8\x00"
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
+};
+
+static const unsigned short xmlunicodetable_ISO8859_16 [128] = {
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7,
+    0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 0x017b,
+    0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 0x00b6, 0x00b7,
+    0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 0x0153, 0x0178, 0x017c,
+    0x00c0, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0106, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x0110, 0x0143, 0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a,
+    0x0170, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x015b,
+    0x0171, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0119, 0x021b, 0x00ff,
+};
+
+static const unsigned char xmltranscodetable_ISO8859_16 [48 + 9 * 64] = {
+    "\x00\x00\x01\x08\x02\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\x00\x00\x00\x00\x00\x00\xa7\x00\xa9\x00\xab\x00\xad\x00\x00"
+    "\xb0\xb1\x00\x00\x00\x00\xb6\xb7\x00\x00\x00\xbb\x00\x00\x00\x00"
+    "\x00\x00\xc3\xe3\xa1\xa2\xc5\xe5\x00\x00\x00\x00\xb2\xb9\x00\x00"
+    "\xd0\xf0\x00\x00\x00\x00\x00\x00\xdd\xfd\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\xa3\xb3\xd1\xf1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xd5\xf5\xbc\xbd\x00\x00\x00\x00\x00\x00\xd7\xf7\x00\x00\x00\x00"
+    "\xa6\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xd8\xf8\x00\x00\x00\x00\x00\x00\xbe\xac\xae\xaf\xbf\xb4\xb8\x00"
+    "\x06\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb5\xa5\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\xaa\xba\xde\xfe\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\xc0\xc1\xc2\x00\xc4\x00\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+    "\x00\x00\xd2\xd3\xd4\x00\xd6\x00\x00\xd9\xda\xdb\xdc\x00\x00\xdf"
+    "\xe0\xe1\xe2\x00\xe4\x00\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+    "\x00\x00\xf2\xf3\xf4\x00\xf6\x00\x00\xf9\xfa\xfb\xfc\x00\x00\xff"
+};
+
diff --git a/legacy.c b/legacy.c
index 69a71bb2..14777e05 100644
--- a/legacy.c
+++ b/legacy.c
@@ -14,13 +14,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include <libxml/tree.h>
-#include <libxml/entities.h>
-#include <libxml/SAX.h>
-#include <libxml/parserInternals.h>
-#include <libxml/HTMLparser.h>
-
-void xmlUpgradeOldNs(xmlDocPtr doc);
+#include <libxml/parser.h>
 
 /************************************************************************
  *									*
@@ -29,1333 +23,500 @@ void xmlUpgradeOldNs(xmlDocPtr doc);
  ************************************************************************/
 
 #ifdef LIBXML_HTML_ENABLED
-xmlChar *htmlDecodeEntities(htmlParserCtxtPtr ctxt, int len, xmlChar end,
-                            xmlChar end2, xmlChar end3);
-
-/**
- * htmlDecodeEntities:
- * @ctxt:  the parser context
- * @len:  the len to decode (in bytes !), -1 for no size limit
- * @end:  an end marker xmlChar, 0 if none
- * @end2:  an end marker xmlChar, 0 if none
- * @end3:  an end marker xmlChar, 0 if none
- *
- * Substitute the HTML entities by their value
- *
- * DEPRECATED !!!!
- *
- * Returns A newly allocated string with the substitution done. The caller
- *      must deallocate it !
- */
+XMLPUBFUN xmlChar *
+htmlDecodeEntities(void *ctxt, int len, xmlChar end, xmlChar end2,
+                   xmlChar end3);
+
 xmlChar *
-htmlDecodeEntities(htmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                   int len ATTRIBUTE_UNUSED, xmlChar end ATTRIBUTE_UNUSED,
-                   xmlChar end2 ATTRIBUTE_UNUSED,
-                   xmlChar end3 ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "htmlDecodeEntities() deprecated function reached\n");
-        deprecated = 1;
-    }
+htmlDecodeEntities(void *ctxt ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED,
+                   xmlChar end ATTRIBUTE_UNUSED, xmlChar end2 ATTRIBUTE_UNUSED,
+                   xmlChar end3 ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 #endif
 
-/**
- * xmlInitializePredefinedEntities:
- *
- * Set up the predefined entities.
- * Deprecated call
+/*
+ * entities.h
  */
+
+XMLPUBFUN void
+xmlInitializePredefinedEntities(void);
+
 void
-xmlInitializePredefinedEntities(void)
-{
+xmlInitializePredefinedEntities(void) {
 }
 
-/**
- * xmlCleanupPredefinedEntities:
- *
- * Cleanup up the predefined entities table.
- * Deprecated call
- */
+XMLPUBFUN void
+xmlCleanupPredefinedEntities(void);
+
 void
-xmlCleanupPredefinedEntities(void)
-{
-}
-
-static const char* const xmlFeaturesList[] = {
-    "validate",
-    "load subset",
-    "keep blanks",
-    "disable SAX",
-    "fetch external entities",
-    "substitute entities",
-    "gather line info",
-    "user data",
-    "is html",
-    "is standalone",
-    "stop parser",
-    "document",
-    "is well formed",
-    "is valid",
-    "SAX block",
-    "SAX function internalSubset",
-    "SAX function isStandalone",
-    "SAX function hasInternalSubset",
-    "SAX function hasExternalSubset",
-    "SAX function resolveEntity",
-    "SAX function getEntity",
-    "SAX function entityDecl",
-    "SAX function notationDecl",
-    "SAX function attributeDecl",
-    "SAX function elementDecl",
-    "SAX function unparsedEntityDecl",
-    "SAX function setDocumentLocator",
-    "SAX function startDocument",
-    "SAX function endDocument",
-    "SAX function startElement",
-    "SAX function endElement",
-    "SAX function reference",
-    "SAX function characters",
-    "SAX function ignorableWhitespace",
-    "SAX function processingInstruction",
-    "SAX function comment",
-    "SAX function warning",
-    "SAX function error",
-    "SAX function fatalError",
-    "SAX function getParameterEntity",
-    "SAX function cdataBlock",
-    "SAX function externalSubset",
-};
-
-/**
- * xmlGetFeaturesList:
- * @len:  the length of the features name array (input/output)
- * @result:  an array of string to be filled with the features name.
- *
- * Copy at most *@len feature names into the @result array
+xmlCleanupPredefinedEntities(void) {
+}
+
+XMLPUBFUN const xmlChar *
+xmlEncodeEntities(void *doc, const xmlChar *input);
+
+const xmlChar *
+xmlEncodeEntities(void *doc ATTRIBUTE_UNUSED,
+                  const xmlChar *input ATTRIBUTE_UNUSED) {
+    return (NULL);
+}
+
+/*
+ * parser.h
  *
- * Returns -1 in case or error, or the total number of features,
- *            len is updated with the number of strings copied,
- *            strings must not be deallocated
+ * Headers are public for now.
  */
+
 int
-xmlGetFeaturesList(int *len, const char **result)
-{
-    int ret, i;
-
-    ret = sizeof(xmlFeaturesList) / sizeof(xmlFeaturesList[0]);
-    if ((len == NULL) || (result == NULL))
-        return (ret);
-    if ((*len < 0) || (*len >= 1000))
-        return (-1);
-    if (*len > ret)
-        *len = ret;
-    for (i = 0; i < *len; i++)
-        result[i] = xmlFeaturesList[i];
-    return (ret);
-}
-
-/**
- * xmlGetFeature:
- * @ctxt:  an XML/HTML parser context
- * @name:  the feature name
- * @result:  location to store the result
- *
- * Read the current value of one feature of this parser instance
- *
- * Returns -1 in case or error, 0 otherwise
- */
+xmlGetFeaturesList(int *len, const char **result ATTRIBUTE_UNUSED) {
+    *len = 0;
+    return(0);
+}
+
 int
-xmlGetFeature(xmlParserCtxtPtr ctxt, const char *name, void *result)
-{
-    if ((ctxt == NULL) || (name == NULL) || (result == NULL))
-        return (-1);
-
-    if (!strcmp(name, "validate")) {
-        *((int *) result) = ctxt->validate;
-    } else if (!strcmp(name, "keep blanks")) {
-        *((int *) result) = ctxt->keepBlanks;
-    } else if (!strcmp(name, "disable SAX")) {
-        *((int *) result) = ctxt->disableSAX;
-    } else if (!strcmp(name, "fetch external entities")) {
-        *((int *) result) = ctxt->loadsubset;
-    } else if (!strcmp(name, "substitute entities")) {
-        *((int *) result) = ctxt->replaceEntities;
-    } else if (!strcmp(name, "gather line info")) {
-        *((int *) result) = ctxt->record_info;
-    } else if (!strcmp(name, "user data")) {
-        *((void **) result) = ctxt->userData;
-    } else if (!strcmp(name, "is html")) {
-        *((int *) result) = ctxt->html;
-    } else if (!strcmp(name, "is standalone")) {
-        *((int *) result) = ctxt->standalone;
-    } else if (!strcmp(name, "document")) {
-        *((xmlDocPtr *) result) = ctxt->myDoc;
-    } else if (!strcmp(name, "is well formed")) {
-        *((int *) result) = ctxt->wellFormed;
-    } else if (!strcmp(name, "is valid")) {
-        *((int *) result) = ctxt->valid;
-    } else if (!strcmp(name, "SAX block")) {
-        *((xmlSAXHandlerPtr *) result) = ctxt->sax;
-    } else if (!strcmp(name, "SAX function internalSubset")) {
-        *((internalSubsetSAXFunc *) result) = ctxt->sax->internalSubset;
-    } else if (!strcmp(name, "SAX function isStandalone")) {
-        *((isStandaloneSAXFunc *) result) = ctxt->sax->isStandalone;
-    } else if (!strcmp(name, "SAX function hasInternalSubset")) {
-        *((hasInternalSubsetSAXFunc *) result) =
-            ctxt->sax->hasInternalSubset;
-    } else if (!strcmp(name, "SAX function hasExternalSubset")) {
-        *((hasExternalSubsetSAXFunc *) result) =
-            ctxt->sax->hasExternalSubset;
-    } else if (!strcmp(name, "SAX function resolveEntity")) {
-        *((resolveEntitySAXFunc *) result) = ctxt->sax->resolveEntity;
-    } else if (!strcmp(name, "SAX function getEntity")) {
-        *((getEntitySAXFunc *) result) = ctxt->sax->getEntity;
-    } else if (!strcmp(name, "SAX function entityDecl")) {
-        *((entityDeclSAXFunc *) result) = ctxt->sax->entityDecl;
-    } else if (!strcmp(name, "SAX function notationDecl")) {
-        *((notationDeclSAXFunc *) result) = ctxt->sax->notationDecl;
-    } else if (!strcmp(name, "SAX function attributeDecl")) {
-        *((attributeDeclSAXFunc *) result) = ctxt->sax->attributeDecl;
-    } else if (!strcmp(name, "SAX function elementDecl")) {
-        *((elementDeclSAXFunc *) result) = ctxt->sax->elementDecl;
-    } else if (!strcmp(name, "SAX function unparsedEntityDecl")) {
-        *((unparsedEntityDeclSAXFunc *) result) =
-            ctxt->sax->unparsedEntityDecl;
-    } else if (!strcmp(name, "SAX function setDocumentLocator")) {
-        *((setDocumentLocatorSAXFunc *) result) =
-            ctxt->sax->setDocumentLocator;
-    } else if (!strcmp(name, "SAX function startDocument")) {
-        *((startDocumentSAXFunc *) result) = ctxt->sax->startDocument;
-    } else if (!strcmp(name, "SAX function endDocument")) {
-        *((endDocumentSAXFunc *) result) = ctxt->sax->endDocument;
-    } else if (!strcmp(name, "SAX function startElement")) {
-        *((startElementSAXFunc *) result) = ctxt->sax->startElement;
-    } else if (!strcmp(name, "SAX function endElement")) {
-        *((endElementSAXFunc *) result) = ctxt->sax->endElement;
-    } else if (!strcmp(name, "SAX function reference")) {
-        *((referenceSAXFunc *) result) = ctxt->sax->reference;
-    } else if (!strcmp(name, "SAX function characters")) {
-        *((charactersSAXFunc *) result) = ctxt->sax->characters;
-    } else if (!strcmp(name, "SAX function ignorableWhitespace")) {
-        *((ignorableWhitespaceSAXFunc *) result) =
-            ctxt->sax->ignorableWhitespace;
-    } else if (!strcmp(name, "SAX function processingInstruction")) {
-        *((processingInstructionSAXFunc *) result) =
-            ctxt->sax->processingInstruction;
-    } else if (!strcmp(name, "SAX function comment")) {
-        *((commentSAXFunc *) result) = ctxt->sax->comment;
-    } else if (!strcmp(name, "SAX function warning")) {
-        *((warningSAXFunc *) result) = ctxt->sax->warning;
-    } else if (!strcmp(name, "SAX function error")) {
-        *((errorSAXFunc *) result) = ctxt->sax->error;
-    } else if (!strcmp(name, "SAX function fatalError")) {
-        *((fatalErrorSAXFunc *) result) = ctxt->sax->fatalError;
-    } else if (!strcmp(name, "SAX function getParameterEntity")) {
-        *((getParameterEntitySAXFunc *) result) =
-            ctxt->sax->getParameterEntity;
-    } else if (!strcmp(name, "SAX function cdataBlock")) {
-        *((cdataBlockSAXFunc *) result) = ctxt->sax->cdataBlock;
-    } else if (!strcmp(name, "SAX function externalSubset")) {
-        *((externalSubsetSAXFunc *) result) = ctxt->sax->externalSubset;
-    } else {
-        return (-1);
-    }
-    return (0);
+xmlGetFeature(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
+              const char *name ATTRIBUTE_UNUSED,
+              void *result ATTRIBUTE_UNUSED) {
+    return(-1);
 }
 
-/**
- * xmlSetFeature:
- * @ctxt:  an XML/HTML parser context
- * @name:  the feature name
- * @value:  pointer to the location of the new value
- *
- * Change the current value of one feature of this parser instance
- *
- * Returns -1 in case or error, 0 otherwise
- */
 int
-xmlSetFeature(xmlParserCtxtPtr ctxt, const char *name, void *value)
-{
-    if ((ctxt == NULL) || (name == NULL) || (value == NULL))
-        return (-1);
-
-    if (!strcmp(name, "validate")) {
-        int newvalidate = *((int *) value);
-
-        if ((!ctxt->validate) && (newvalidate != 0)) {
-            if (ctxt->vctxt.warning == NULL)
-                ctxt->vctxt.warning = xmlParserValidityWarning;
-            if (ctxt->vctxt.error == NULL)
-                ctxt->vctxt.error = xmlParserValidityError;
-            ctxt->vctxt.nodeMax = 0;
-        }
-        ctxt->validate = newvalidate;
-    } else if (!strcmp(name, "keep blanks")) {
-        ctxt->keepBlanks = *((int *) value);
-    } else if (!strcmp(name, "disable SAX")) {
-        ctxt->disableSAX = *((int *) value);
-    } else if (!strcmp(name, "fetch external entities")) {
-        ctxt->loadsubset = *((int *) value);
-    } else if (!strcmp(name, "substitute entities")) {
-        ctxt->replaceEntities = *((int *) value);
-    } else if (!strcmp(name, "gather line info")) {
-        ctxt->record_info = *((int *) value);
-    } else if (!strcmp(name, "user data")) {
-        ctxt->userData = *((void **) value);
-    } else if (!strcmp(name, "is html")) {
-        ctxt->html = *((int *) value);
-    } else if (!strcmp(name, "is standalone")) {
-        ctxt->standalone = *((int *) value);
-    } else if (!strcmp(name, "document")) {
-        ctxt->myDoc = *((xmlDocPtr *) value);
-    } else if (!strcmp(name, "is well formed")) {
-        ctxt->wellFormed = *((int *) value);
-    } else if (!strcmp(name, "is valid")) {
-        ctxt->valid = *((int *) value);
-    } else if (!strcmp(name, "SAX block")) {
-        ctxt->sax = *((xmlSAXHandlerPtr *) value);
-    } else if (!strcmp(name, "SAX function internalSubset")) {
-        ctxt->sax->internalSubset = *((internalSubsetSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function isStandalone")) {
-        ctxt->sax->isStandalone = *((isStandaloneSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function hasInternalSubset")) {
-        ctxt->sax->hasInternalSubset =
-            *((hasInternalSubsetSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function hasExternalSubset")) {
-        ctxt->sax->hasExternalSubset =
-            *((hasExternalSubsetSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function resolveEntity")) {
-        ctxt->sax->resolveEntity = *((resolveEntitySAXFunc *) value);
-    } else if (!strcmp(name, "SAX function getEntity")) {
-        ctxt->sax->getEntity = *((getEntitySAXFunc *) value);
-    } else if (!strcmp(name, "SAX function entityDecl")) {
-        ctxt->sax->entityDecl = *((entityDeclSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function notationDecl")) {
-        ctxt->sax->notationDecl = *((notationDeclSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function attributeDecl")) {
-        ctxt->sax->attributeDecl = *((attributeDeclSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function elementDecl")) {
-        ctxt->sax->elementDecl = *((elementDeclSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function unparsedEntityDecl")) {
-        ctxt->sax->unparsedEntityDecl =
-            *((unparsedEntityDeclSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function setDocumentLocator")) {
-        ctxt->sax->setDocumentLocator =
-            *((setDocumentLocatorSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function startDocument")) {
-        ctxt->sax->startDocument = *((startDocumentSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function endDocument")) {
-        ctxt->sax->endDocument = *((endDocumentSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function startElement")) {
-        ctxt->sax->startElement = *((startElementSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function endElement")) {
-        ctxt->sax->endElement = *((endElementSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function reference")) {
-        ctxt->sax->reference = *((referenceSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function characters")) {
-        ctxt->sax->characters = *((charactersSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function ignorableWhitespace")) {
-        ctxt->sax->ignorableWhitespace =
-            *((ignorableWhitespaceSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function processingInstruction")) {
-        ctxt->sax->processingInstruction =
-            *((processingInstructionSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function comment")) {
-        ctxt->sax->comment = *((commentSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function warning")) {
-        ctxt->sax->warning = *((warningSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function error")) {
-        ctxt->sax->error = *((errorSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function fatalError")) {
-        ctxt->sax->fatalError = *((fatalErrorSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function getParameterEntity")) {
-        ctxt->sax->getParameterEntity =
-            *((getParameterEntitySAXFunc *) value);
-    } else if (!strcmp(name, "SAX function cdataBlock")) {
-        ctxt->sax->cdataBlock = *((cdataBlockSAXFunc *) value);
-    } else if (!strcmp(name, "SAX function externalSubset")) {
-        ctxt->sax->externalSubset = *((externalSubsetSAXFunc *) value);
-    } else {
-        return (-1);
-    }
-    return (0);
+xmlSetFeature(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
+              const char *name ATTRIBUTE_UNUSED,
+              void *value ATTRIBUTE_UNUSED) {
+    return(-1);
 }
 
-/**
- * xmlDecodeEntities:
- * @ctxt:  the parser context
- * @len:  the len to decode (in bytes !), -1 for no size limit
- * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
- * @end:  an end marker xmlChar, 0 if none
- * @end2:  an end marker xmlChar, 0 if none
- * @end3:  an end marker xmlChar, 0 if none
- *
- * This function is deprecated, we now always process entities content
- * through xmlStringDecodeEntities
- *
- * TODO: remove it in next major release.
- *
- * [67] Reference ::= EntityRef | CharRef
- *
- * [69] PEReference ::= '%' Name ';'
- *
- * Returns A newly allocated string with the substitution done. The caller
- *      must deallocate it !
+/*
+ * parserInternals.h
  */
+
+XMLPUBFUN xmlChar *
+xmlDecodeEntities(void *ctxt, int len, int what, xmlChar end, xmlChar end2,
+                  xmlChar end3);
+
 xmlChar *
-xmlDecodeEntities(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                  int len ATTRIBUTE_UNUSED, int what ATTRIBUTE_UNUSED,
-                  xmlChar end ATTRIBUTE_UNUSED,
+xmlDecodeEntities(void *ctxt ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED,
+                  int what ATTRIBUTE_UNUSED, xmlChar end ATTRIBUTE_UNUSED,
                   xmlChar end2 ATTRIBUTE_UNUSED,
-                  xmlChar end3 ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlDecodeEntities() deprecated function reached\n");
-        deprecated = 1;
-    }
+                  xmlChar end3 ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlNamespaceParseNCName:
- * @ctxt:  an XML parser context
- *
- * parse an XML namespace name.
- *
- * TODO: this seems not in use anymore, the namespace handling is done on
- *       top of the SAX interfaces, i.e. not on raw input.
- *
- * [NS 3] NCName ::= (Letter | '_') (NCNameChar)*
- *
- * [NS 4] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |
- *                       CombiningChar | Extender
- *
- * Returns the namespace name or NULL
- */
+XMLPUBFUN xmlChar *
+xmlNamespaceParseNCName(void *ctxt);
 
 xmlChar *
-xmlNamespaceParseNCName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlNamespaceParseNCName() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlNamespaceParseNCName(void *ctxt ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlNamespaceParseQName:
- * @ctxt:  an XML parser context
- * @prefix:  a xmlChar **
- *
- * TODO: this seems not in use anymore, the namespace handling is done on
- *       top of the SAX interfaces, i.e. not on raw input.
- *
- * parse an XML qualified name
- *
- * [NS 5] QName ::= (Prefix ':')? LocalPart
- *
- * [NS 6] Prefix ::= NCName
- *
- * [NS 7] LocalPart ::= NCName
- *
- * Returns the local part, and prefix is updated
- *   to get the Prefix if any.
- */
+XMLPUBFUN xmlChar *
+xmlNamespaceParseQName(void *ctxt, xmlChar **prefix);
 
 xmlChar *
-xmlNamespaceParseQName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                       xmlChar ** prefix ATTRIBUTE_UNUSED)
-{
-
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlNamespaceParseQName() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlNamespaceParseQName(void *ctxt ATTRIBUTE_UNUSED,
+                       xmlChar **prefix ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlNamespaceParseNSDef:
- * @ctxt:  an XML parser context
- *
- * parse a namespace prefix declaration
- *
- * TODO: this seems not in use anymore, the namespace handling is done on
- *       top of the SAX interfaces, i.e. not on raw input.
- *
- * [NS 1] NSDef ::= PrefixDef Eq SystemLiteral
- *
- * [NS 2] PrefixDef ::= 'xmlns' (':' NCName)?
- *
- * Returns the namespace name
- */
+XMLPUBFUN xmlChar *
+xmlNamespaceParseNSDef(void *ctxt);
 
 xmlChar *
-xmlNamespaceParseNSDef(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlNamespaceParseNSDef() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlNamespaceParseNSDef(void *ctxt ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlParseQuotedString:
- * @ctxt:  an XML parser context
- *
- * Parse and return a string between quotes or doublequotes
- *
- * TODO: Deprecated, to  be removed at next drop of binary compatibility
- *
- * Returns the string parser or NULL.
- */
+XMLPUBFUN xmlChar *
+xmlParseQuotedString(void *ctxt);
+
 xmlChar *
-xmlParseQuotedString(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlParseQuotedString() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlParseQuotedString(void *ctxt ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlParseNamespace:
- * @ctxt:  an XML parser context
- *
- * xmlParseNamespace: parse specific PI '<?namespace ...' constructs.
- *
- * This is what the older xml-name Working Draft specified, a bunch of
- * other stuff may still rely on it, so support is still here as
- * if it was declared on the root of the Tree:-(
- *
- * TODO: remove from library
- *
- * To be removed at next drop of binary compatibility
- */
+XMLPUBFUN void
+xmlParseNamespace(void *ctxt);
 
 void
-xmlParseNamespace(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlParseNamespace() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlParseNamespace(void *ctxt ATTRIBUTE_UNUSED) {
 }
 
-/**
- * xmlScanName:
- * @ctxt:  an XML parser context
- *
- * Trickery: parse an XML name but without consuming the input flow
- * Needed for rollback cases. Used only when parsing entities references.
- *
- * TODO: seems deprecated now, only used in the default part of
- *       xmlParserHandleReference
- *
- * [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
- *                  CombiningChar | Extender
- *
- * [5] Name ::= (Letter | '_' | ':') (NameChar)*
- *
- * [6] Names ::= Name (S Name)*
- *
- * Returns the Name parsed or NULL
- */
+XMLPUBFUN xmlChar *
+xmlScanName(void *ctxt);
 
 xmlChar *
-xmlScanName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlScanName() deprecated function reached\n");
-        deprecated = 1;
-    }
+xmlScanName(void *ctxt ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlParserHandleReference:
- * @ctxt:  the parser context
- *
- * TODO: Remove, now deprecated ... the test is done directly in the
- *       content parsing
- * routines.
- *
- * [67] Reference ::= EntityRef | CharRef
- *
- * [68] EntityRef ::= '&' Name ';'
- *
- * [ WFC: Entity Declared ]
- * the Name given in the entity reference must match that in an entity
- * declaration, except that well-formed documents need not declare any
- * of the following entities: amp, lt, gt, apos, quot.
- *
- * [ WFC: Parsed Entity ]
- * An entity reference must not contain the name of an unparsed entity
- *
- * [66] CharRef ::= '&#' [0-9]+ ';' |
- *                  '&#x' [0-9a-fA-F]+ ';'
- *
- * A PEReference may have been detected in the current input stream
- * the handling is done accordingly to
- *      http://www.w3.org/TR/REC-xml#entproc
- */
+XMLPUBFUN void
+xmlParserHandleReference(void *ctxt);
+
 void
-xmlParserHandleReference(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
+xmlParserHandleReference(void *ctxt ATTRIBUTE_UNUSED) {
+}
 
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlParserHandleReference() deprecated function reached\n");
-        deprecated = 1;
-    }
+XMLPUBFUN void
+xmlHandleEntity(void *ctxt, void *entity);
 
-    return;
+void
+xmlHandleEntity(void *ctxt ATTRIBUTE_UNUSED, void *entity ATTRIBUTE_UNUSED) {
 }
 
-/**
- * xmlHandleEntity:
- * @ctxt:  an XML parser context
- * @entity:  an XML entity pointer.
- *
- * Default handling of defined entities, when should we define a new input
- * stream ? When do we just handle that as a set of chars ?
- *
- * OBSOLETE: to be removed at some point.
- */
+typedef	void
+(*xmlEntityReferenceFunc)(void *ent, void *firstNode, void *lastNode);
+
+XMLPUBFUN void
+xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func);
 
 void
-xmlHandleEntity(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                xmlEntityPtr entity ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlHandleEntity() deprecated function reached\n");
-        deprecated = 1;
-    }
-}
-
-/**
- * xmlNewGlobalNs:
- * @doc:  the document carrying the namespace
- * @href:  the URI associated
- * @prefix:  the prefix for the namespace
- *
- * Creation of a Namespace, the old way using PI and without scoping
- *   DEPRECATED !!!
- * Returns NULL this functionality had been removed
- */
-xmlNsPtr
-xmlNewGlobalNs(xmlDocPtr doc ATTRIBUTE_UNUSED,
-               const xmlChar * href ATTRIBUTE_UNUSED,
-               const xmlChar * prefix ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
-
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlNewGlobalNs() deprecated function reached\n");
-        deprecated = 1;
-    }
-    return (NULL);
+xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func ATTRIBUTE_UNUSED) {
 }
 
-/**
- * xmlUpgradeOldNs:
- * @doc:  a document pointer
- *
- * Upgrade old style Namespaces (PI) and move them to the root of the document.
- * DEPRECATED
+/*
+ * tree.h
  */
-void
-xmlUpgradeOldNs(xmlDocPtr doc ATTRIBUTE_UNUSED)
-{
-    static int deprecated = 0;
 
-    if (!deprecated) {
-        fprintf(stderr,
-                        "xmlUpgradeOldNs() deprecated function reached\n");
-        deprecated = 1;
-    }
-}
+XMLPUBFUN void *
+xmlNewGlobalNs(void *doc, const xmlChar *href, const xmlChar *prefix);
 
-/**
- * xmlEncodeEntities:
- * @doc:  the document containing the string
- * @input:  A string to convert to XML.
- *
- * TODO: remove xmlEncodeEntities, once we are not afraid of breaking binary
- *       compatibility
- *
- * People must migrate their code to xmlEncodeEntitiesReentrant !
- * This routine will issue a warning when encountered.
- *
- * Returns NULL
- */
-const xmlChar *
-xmlEncodeEntities(xmlDocPtr doc ATTRIBUTE_UNUSED,
-                  const xmlChar * input ATTRIBUTE_UNUSED)
-{
-    static int warning = 1;
-
-    if (warning) {
-        fprintf(stderr,
-                        "Deprecated API xmlEncodeEntities() used\n");
-        fprintf(stderr,
-                        "   change code to use xmlEncodeEntitiesReentrant()\n");
-        warning = 0;
-    }
+void *
+xmlNewGlobalNs(void *doc ATTRIBUTE_UNUSED,
+               const xmlChar *href ATTRIBUTE_UNUSED,
+               const xmlChar *prefix ATTRIBUTE_UNUSED) {
     return (NULL);
 }
 
-/**
- * xmlSetEntityReferenceFunc:
- * @func: A valid function
- *
- * Set the function to call call back when a xml reference has been made
- */
+XMLPUBFUN void
+xmlUpgradeOldNs(void *doc);
+
 void
-xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func ATTRIBUTE_UNUSED)
-{
+xmlUpgradeOldNs(void *doc ATTRIBUTE_UNUSED) {
 }
 
-/************************************************************************
- *									*
- *		Old set of SAXv1 functions				*
- *									*
- ************************************************************************/
-static int deprecated_v1_msg = 0;
+/*
+ * SAX.h
+ */
 
-#define DEPRECATED(n)						\
-    if (deprecated_v1_msg == 0)					\
-	fprintf(stderr,			\
-	  "Use of deprecated SAXv1 function %s\n", n);		\
-    deprecated_v1_msg++;
+XMLPUBFUN const xmlChar *
+getPublicId(void *ctx);
 
-/**
- * getPublicId:
- * @ctx: the user data (XML parser context)
- *
- * Provides the public ID e.g. "-//SGMLSOURCE//DTD DEMO//EN"
- * DEPRECATED: use xmlSAX2GetPublicId()
- *
- * Returns a xmlChar *
- */
 const xmlChar *
-getPublicId(void *ctx)
-{
-    DEPRECATED("getPublicId")
-        return (xmlSAX2GetPublicId(ctx));
+getPublicId(void *ctx ATTRIBUTE_UNUSED){
+    return(NULL);
 }
 
-/**
- * getSystemId:
- * @ctx: the user data (XML parser context)
- *
- * Provides the system ID, basically URL or filename e.g.
- * http://www.sgmlsource.com/dtds/memo.dtd
- * DEPRECATED: use xmlSAX2GetSystemId()
- *
- * Returns a xmlChar *
- */
+XMLPUBFUN const xmlChar *
+getSystemId(void *ctx);
+
 const xmlChar *
-getSystemId(void *ctx)
-{
-    DEPRECATED("getSystemId")
-        return (xmlSAX2GetSystemId(ctx));
+getSystemId(void *ctx ATTRIBUTE_UNUSED) {
+    return(NULL);
 }
 
-/**
- * getLineNumber:
- * @ctx: the user data (XML parser context)
- *
- * Provide the line number of the current parsing point.
- * DEPRECATED: use xmlSAX2GetLineNumber()
- *
- * Returns an int
- */
+XMLPUBFUN int
+getLineNumber(void *ctx);
+
 int
-getLineNumber(void *ctx)
-{
-    DEPRECATED("getLineNumber")
-        return (xmlSAX2GetLineNumber(ctx));
+getLineNumber(void *ctx ATTRIBUTE_UNUSED) {
+    return(0);
 }
 
-/**
- * getColumnNumber:
- * @ctx: the user data (XML parser context)
- *
- * Provide the column number of the current parsing point.
- * DEPRECATED: use xmlSAX2GetColumnNumber()
- *
- * Returns an int
- */
+XMLPUBFUN int
+getColumnNumber(void *ctx);
+
 int
-getColumnNumber(void *ctx)
-{
-    DEPRECATED("getColumnNumber")
-        return (xmlSAX2GetColumnNumber(ctx));
+getColumnNumber(void *ctx ATTRIBUTE_UNUSED) {
+    return(0);
 }
 
-/**
- * isStandalone:
- * @ctx: the user data (XML parser context)
- *
- * Is this document tagged standalone ?
- * DEPRECATED: use xmlSAX2IsStandalone()
- *
- * Returns 1 if true
- */
+XMLPUBFUN int
+isStandalone(void *ctx);
+
 int
-isStandalone(void *ctx)
-{
-    DEPRECATED("isStandalone")
-        return (xmlSAX2IsStandalone(ctx));
+isStandalone(void *ctx ATTRIBUTE_UNUSED) {
+    return(0);
 }
 
-/**
- * hasInternalSubset:
- * @ctx: the user data (XML parser context)
- *
- * Does this document has an internal subset
- * DEPRECATED: use xmlSAX2HasInternalSubset()
- *
- * Returns 1 if true
- */
+XMLPUBFUN int
+hasInternalSubset(void *ctx);
+
 int
-hasInternalSubset(void *ctx)
-{
-    DEPRECATED("hasInternalSubset")
-        return (xmlSAX2HasInternalSubset(ctx));
+hasInternalSubset(void *ctx ATTRIBUTE_UNUSED) {
+    return(0);
 }
 
-/**
- * hasExternalSubset:
- * @ctx: the user data (XML parser context)
- *
- * Does this document has an external subset
- * DEPRECATED: use xmlSAX2HasExternalSubset()
- *
- * Returns 1 if true
- */
+XMLPUBFUN int
+hasExternalSubset(void *ctx);
+
 int
-hasExternalSubset(void *ctx)
-{
-    DEPRECATED("hasExternalSubset")
-        return (xmlSAX2HasExternalSubset(ctx));
-}
-
-/**
- * internalSubset:
- * @ctx:  the user data (XML parser context)
- * @name:  the root element name
- * @ExternalID:  the external ID
- * @SystemID:  the SYSTEM ID (e.g. filename or URL)
- *
- * Callback on internal subset declaration.
- * DEPRECATED: use xmlSAX2InternalSubset()
- */
+hasExternalSubset(void *ctx ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN void
+internalSubset(void *ctx, const xmlChar *name,
+               const xmlChar *ExternalID, const xmlChar *SystemID);
+
 void
-internalSubset(void *ctx, const xmlChar * name,
-               const xmlChar * ExternalID, const xmlChar * SystemID)
-{
-    DEPRECATED("internalSubset")
-        xmlSAX2InternalSubset(ctx, name, ExternalID, SystemID);
-}
-
-/**
- * externalSubset:
- * @ctx: the user data (XML parser context)
- * @name:  the root element name
- * @ExternalID:  the external ID
- * @SystemID:  the SYSTEM ID (e.g. filename or URL)
- *
- * Callback on external subset declaration.
- * DEPRECATED: use xmlSAX2ExternalSubset()
- */
+internalSubset(void *ctx ATTRIBUTE_UNUSED,
+               const xmlChar *name ATTRIBUTE_UNUSED,
+               const xmlChar *ExternalID ATTRIBUTE_UNUSED,
+               const xmlChar *SystemID ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+externalSubset(void *ctx, const xmlChar *name,
+               const xmlChar *ExternalID, const xmlChar *SystemID);
+
 void
-externalSubset(void *ctx, const xmlChar * name,
-               const xmlChar * ExternalID, const xmlChar * SystemID)
-{
-    DEPRECATED("externalSubset")
-        xmlSAX2ExternalSubset(ctx, name, ExternalID, SystemID);
-}
-
-/**
- * resolveEntity:
- * @ctx: the user data (XML parser context)
- * @publicId: The public ID of the entity
- * @systemId: The system ID of the entity
- *
- * The entity loader, to control the loading of external entities,
- * the application can either:
- *    - override this resolveEntity() callback in the SAX block
- *    - or better use the xmlSetExternalEntityLoader() function to
- *      set up it's own entity resolution routine
- * DEPRECATED: use xmlSAX2ResolveEntity()
- *
- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
- */
-xmlParserInputPtr
+externalSubset(void *ctx ATTRIBUTE_UNUSED,
+               const xmlChar *name ATTRIBUTE_UNUSED,
+               const xmlChar *ExternalID ATTRIBUTE_UNUSED,
+               const xmlChar *SystemID ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void *
 resolveEntity(void *ctx, const xmlChar * publicId,
-              const xmlChar * systemId)
-{
-    DEPRECATED("resolveEntity")
-        return (xmlSAX2ResolveEntity(ctx, publicId, systemId));
+              const xmlChar * systemId);
+
+void *
+resolveEntity(void *ctx ATTRIBUTE_UNUSED,
+              const xmlChar * publicId ATTRIBUTE_UNUSED,
+              const xmlChar * systemId ATTRIBUTE_UNUSED) {
+    return(NULL);
 }
 
-/**
- * getEntity:
- * @ctx: the user data (XML parser context)
- * @name: The entity name
- *
- * Get an entity by name
- * DEPRECATED: use xmlSAX2GetEntity()
- *
- * Returns the xmlEntityPtr if found.
- */
-xmlEntityPtr
-getEntity(void *ctx, const xmlChar * name)
-{
-    DEPRECATED("getEntity")
-        return (xmlSAX2GetEntity(ctx, name));
+XMLPUBFUN void *
+getEntity(void *ctx, const xmlChar *name);
+
+void *
+getEntity(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED) {
+    return(NULL);
 }
 
-/**
- * getParameterEntity:
- * @ctx: the user data (XML parser context)
- * @name: The entity name
- *
- * Get a parameter entity by name
- * DEPRECATED: use xmlSAX2GetParameterEntity()
- *
- * Returns the xmlEntityPtr if found.
- */
-xmlEntityPtr
-getParameterEntity(void *ctx, const xmlChar * name)
-{
-    DEPRECATED("getParameterEntity")
-        return (xmlSAX2GetParameterEntity(ctx, name));
-}
-
-
-/**
- * entityDecl:
- * @ctx: the user data (XML parser context)
- * @name:  the entity name
- * @type:  the entity type
- * @publicId: The public ID of the entity
- * @systemId: The system ID of the entity
- * @content: the entity value (without processing).
- *
- * An entity definition has been parsed
- * DEPRECATED: use xmlSAX2EntityDecl()
- */
+XMLPUBFUN void *
+getParameterEntity(void *ctx, const xmlChar *name);
+
+void *
+getParameterEntity(void *ctx ATTRIBUTE_UNUSED,
+                   const xmlChar *name ATTRIBUTE_UNUSED) {
+    return(NULL);
+}
+
+XMLPUBFUN void
+entityDecl(void *ctx, const xmlChar *name, int type,
+           const xmlChar *publicId, const xmlChar *systemId,
+           xmlChar *content);
+
 void
-entityDecl(void *ctx, const xmlChar * name, int type,
-           const xmlChar * publicId, const xmlChar * systemId,
-           xmlChar * content)
-{
-    DEPRECATED("entityDecl")
-        xmlSAX2EntityDecl(ctx, name, type, publicId, systemId, content);
-}
-
-/**
- * attributeDecl:
- * @ctx: the user data (XML parser context)
- * @elem:  the name of the element
- * @fullname:  the attribute name
- * @type:  the attribute type
- * @def:  the type of default value
- * @defaultValue: the attribute default value
- * @tree:  the tree of enumerated value set
- *
- * An attribute definition has been parsed
- * DEPRECATED: use xmlSAX2AttributeDecl()
- */
+entityDecl(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED,
+           int type ATTRIBUTE_UNUSED, const xmlChar *publicId ATTRIBUTE_UNUSED,
+           const xmlChar *systemId ATTRIBUTE_UNUSED,
+           xmlChar *content ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+attributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
+              int type, int def, const xmlChar *defaultValue, void *tree);
+
 void
-attributeDecl(void *ctx, const xmlChar * elem, const xmlChar * fullname,
-              int type, int def, const xmlChar * defaultValue,
-              xmlEnumerationPtr tree)
-{
-    DEPRECATED("attributeDecl")
-        xmlSAX2AttributeDecl(ctx, elem, fullname, type, def, defaultValue,
-                             tree);
-}
-
-/**
- * elementDecl:
- * @ctx: the user data (XML parser context)
- * @name:  the element name
- * @type:  the element type
- * @content: the element value tree
- *
- * An element definition has been parsed
- * DEPRECATED: use xmlSAX2ElementDecl()
- */
+attributeDecl(void *ctx ATTRIBUTE_UNUSED,
+              const xmlChar *elem ATTRIBUTE_UNUSED,
+              const xmlChar *fullname ATTRIBUTE_UNUSED,
+              int type ATTRIBUTE_UNUSED, int def ATTRIBUTE_UNUSED,
+              const xmlChar *defaultValue ATTRIBUTE_UNUSED,
+              void *tree ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+elementDecl(void *ctx, const xmlChar *name, int type, void *content);
+
 void
-elementDecl(void *ctx, const xmlChar * name, int type,
-            xmlElementContentPtr content)
-{
-    DEPRECATED("elementDecl")
-        xmlSAX2ElementDecl(ctx, name, type, content);
-}
-
-/**
- * notationDecl:
- * @ctx: the user data (XML parser context)
- * @name: The name of the notation
- * @publicId: The public ID of the entity
- * @systemId: The system ID of the entity
- *
- * What to do when a notation declaration has been parsed.
- * DEPRECATED: use xmlSAX2NotationDecl()
- */
+elementDecl(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED,
+            int type ATTRIBUTE_UNUSED, void *content ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+notationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId,
+             const xmlChar *systemId);
+
 void
-notationDecl(void *ctx, const xmlChar * name,
-             const xmlChar * publicId, const xmlChar * systemId)
-{
-    DEPRECATED("notationDecl")
-        xmlSAX2NotationDecl(ctx, name, publicId, systemId);
-}
-
-/**
- * unparsedEntityDecl:
- * @ctx: the user data (XML parser context)
- * @name: The name of the entity
- * @publicId: The public ID of the entity
- * @systemId: The system ID of the entity
- * @notationName: the name of the notation
- *
- * What to do when an unparsed entity declaration is parsed
- * DEPRECATED: use xmlSAX2UnparsedEntityDecl()
- */
+notationDecl(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED,
+             const xmlChar *publicId ATTRIBUTE_UNUSED,
+             const xmlChar *systemId ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+unparsedEntityDecl(void *ctx, const xmlChar *name, const xmlChar *publicId,
+                   const xmlChar *systemId, const xmlChar *notationName);
+
 void
-unparsedEntityDecl(void *ctx, const xmlChar * name,
-                   const xmlChar * publicId, const xmlChar * systemId,
-                   const xmlChar * notationName)
-{
-    DEPRECATED("unparsedEntityDecl")
-        xmlSAX2UnparsedEntityDecl(ctx, name, publicId, systemId,
-                                  notationName);
-}
-
-/**
- * setDocumentLocator:
- * @ctx: the user data (XML parser context)
- * @loc: A SAX Locator
- *
- * Receive the document locator at startup, actually xmlDefaultSAXLocator
- * Everything is available on the context, so this is useless in our case.
- * DEPRECATED
- */
+unparsedEntityDecl(void *ctx ATTRIBUTE_UNUSED,
+                   const xmlChar *name ATTRIBUTE_UNUSED,
+                   const xmlChar *publicId ATTRIBUTE_UNUSED,
+                   const xmlChar *systemId ATTRIBUTE_UNUSED,
+                   const xmlChar *notationName ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+setDocumentLocator(void *ctx, void *loc);
+
 void
-setDocumentLocator(void *ctx ATTRIBUTE_UNUSED,
-                   xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("setDocumentLocator")
+setDocumentLocator(void *ctx ATTRIBUTE_UNUSED, void *loc ATTRIBUTE_UNUSED) {
 }
 
-/**
- * startDocument:
- * @ctx: the user data (XML parser context)
- *
- * called when the document start being processed.
- * DEPRECATED: use xmlSAX2StartDocument()
- */
+XMLPUBFUN void
+startDocument(void *ctx);
+
 void
-startDocument(void *ctx)
-{
-   /* don't be too painful for glade users */
-   /*  DEPRECATED("startDocument") */
-        xmlSAX2StartDocument(ctx);
+startDocument(void *ctx ATTRIBUTE_UNUSED) {
 }
 
-/**
- * endDocument:
- * @ctx: the user data (XML parser context)
- *
- * called when the document end has been detected.
- * DEPRECATED: use xmlSAX2EndDocument()
- */
+XMLPUBFUN void
+endDocument(void *ctx);
+
 void
-endDocument(void *ctx)
-{
-    DEPRECATED("endDocument")
-        xmlSAX2EndDocument(ctx);
+endDocument(void *ctx ATTRIBUTE_UNUSED) {
 }
 
-/**
- * attribute:
- * @ctx: the user data (XML parser context)
- * @fullname:  The attribute name, including namespace prefix
- * @value:  The attribute value
- *
- * Handle an attribute that has been read by the parser.
- * The default handling is to convert the attribute into an
- * DOM subtree and past it in a new xmlAttr element added to
- * the element.
- * DEPRECATED: use xmlSAX2Attribute()
- */
+XMLPUBFUN void
+attribute(void *ctx, const xmlChar *fullname, const xmlChar *value);
+
 void
-attribute(void *ctx ATTRIBUTE_UNUSED,
-          const xmlChar * fullname ATTRIBUTE_UNUSED,
-          const xmlChar * value ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("attribute")
-}
-
-/**
- * startElement:
- * @ctx: the user data (XML parser context)
- * @fullname:  The element name, including namespace prefix
- * @atts:  An array of name/value attributes pairs, NULL terminated
- *
- * called when an opening tag has been processed.
- * DEPRECATED: use xmlSAX2StartElement()
- */
+attribute(void *ctx ATTRIBUTE_UNUSED, const xmlChar *fullname ATTRIBUTE_UNUSED,
+          const xmlChar *value ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+startElement(void *ctx, const xmlChar *fullname, const xmlChar **atts);
+
 void
-startElement(void *ctx, const xmlChar * fullname, const xmlChar ** atts)
-{
+startElement(void *ctx ATTRIBUTE_UNUSED,
+             const xmlChar *fullname ATTRIBUTE_UNUSED,
+             const xmlChar **atts ATTRIBUTE_UNUSED) {
     xmlSAX2StartElement(ctx, fullname, atts);
 }
 
-/**
- * endElement:
- * @ctx: the user data (XML parser context)
- * @name:  The element name
- *
- * called when the end of an element has been detected.
- * DEPRECATED: use xmlSAX2EndElement()
- */
+XMLPUBFUN void
+endElement(void *ctx, const xmlChar *name);
+
 void
-endElement(void *ctx, const xmlChar * name ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("endElement")
-    xmlSAX2EndElement(ctx, name);
+endElement(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED) {
 }
 
-/**
- * reference:
- * @ctx: the user data (XML parser context)
- * @name:  The entity name
- *
- * called when an entity reference is detected.
- * DEPRECATED: use xmlSAX2Reference()
- */
+XMLPUBFUN void
+reference(void *ctx, const xmlChar *name);
+
 void
-reference(void *ctx, const xmlChar * name)
-{
-    DEPRECATED("reference")
-        xmlSAX2Reference(ctx, name);
+reference(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name ATTRIBUTE_UNUSED) {
 }
 
-/**
- * characters:
- * @ctx: the user data (XML parser context)
- * @ch:  a xmlChar string
- * @len: the number of xmlChar
- *
- * receiving some chars from the parser.
- * DEPRECATED: use xmlSAX2Characters()
- */
+XMLPUBFUN void
+characters(void *ctx, const xmlChar *ch, int len);
+
 void
-characters(void *ctx, const xmlChar * ch, int len)
-{
-    DEPRECATED("characters")
-        xmlSAX2Characters(ctx, ch, len);
+characters(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch ATTRIBUTE_UNUSED,
+           int len ATTRIBUTE_UNUSED) {
 }
 
-/**
- * ignorableWhitespace:
- * @ctx: the user data (XML parser context)
- * @ch:  a xmlChar string
- * @len: the number of xmlChar
- *
- * receiving some ignorable whitespaces from the parser.
- * UNUSED: by default the DOM building will use characters
- * DEPRECATED: use xmlSAX2IgnorableWhitespace()
- */
+XMLPUBFUN void
+ignorableWhitespace(void *ctx, const xmlChar *ch, int len);
+
 void
 ignorableWhitespace(void *ctx ATTRIBUTE_UNUSED,
-                    const xmlChar * ch ATTRIBUTE_UNUSED,
-                    int len ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("ignorableWhitespace")
+                    const xmlChar *ch ATTRIBUTE_UNUSED,
+                    int len ATTRIBUTE_UNUSED) {
 }
 
-/**
- * processingInstruction:
- * @ctx: the user data (XML parser context)
- * @target:  the target name
- * @data: the PI data's
- *
- * A processing instruction has been parsed.
- * DEPRECATED: use xmlSAX2ProcessingInstruction()
- */
+XMLPUBFUN void
+processingInstruction(void *ctx, const xmlChar *target, const xmlChar *data);
+
 void
-processingInstruction(void *ctx, const xmlChar * target,
-                      const xmlChar * data)
-{
-    DEPRECATED("processingInstruction")
-        xmlSAX2ProcessingInstruction(ctx, target, data);
-}
-
-/**
- * globalNamespace:
- * @ctx: the user data (XML parser context)
- * @href:  the namespace associated URN
- * @prefix: the namespace prefix
- *
- * An old global namespace has been parsed.
- * DEPRECATED
- */
+processingInstruction(void *ctx ATTRIBUTE_UNUSED,
+                      const xmlChar *target ATTRIBUTE_UNUSED,
+                      const xmlChar *data ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+globalNamespace(void *ctx, const xmlChar *href, const xmlChar *prefix);
+
 void
 globalNamespace(void *ctx ATTRIBUTE_UNUSED,
-                const xmlChar * href ATTRIBUTE_UNUSED,
-                const xmlChar * prefix ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("globalNamespace")
+                const xmlChar *href ATTRIBUTE_UNUSED,
+                const xmlChar *prefix ATTRIBUTE_UNUSED) {
 }
 
-/**
- * setNamespace:
- * @ctx: the user data (XML parser context)
- * @name:  the namespace prefix
- *
- * Set the current element namespace.
- * DEPRECATED
- */
+XMLPUBFUN void
+setNamespace(void *ctx, const xmlChar *name);
 
 void
 setNamespace(void *ctx ATTRIBUTE_UNUSED,
-             const xmlChar * name ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("setNamespace")
+             const xmlChar *name ATTRIBUTE_UNUSED) {
 }
 
-/**
- * getNamespace:
- * @ctx: the user data (XML parser context)
- *
- * Get the current element namespace.
- * DEPRECATED
- *
- * Returns the xmlNsPtr or NULL if none
- */
+XMLPUBFUN void *
+getNamespace(void *ctx);
 
-xmlNsPtr
-getNamespace(void *ctx ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("getNamespace")
-        return (NULL);
+void *
+getNamespace(void *ctx ATTRIBUTE_UNUSED) {
+    return (NULL);
 }
 
-/**
- * checkNamespace:
- * @ctx: the user data (XML parser context)
- * @namespace: the namespace to check against
- *
- * Check that the current element namespace is the same as the
- * one read upon parsing.
- * DEPRECATED
- *
- * Returns 1 if true 0 otherwise
- */
+XMLPUBFUN int
+checkNamespace(void *ctx, xmlChar *namespace);
 
 int
 checkNamespace(void *ctx ATTRIBUTE_UNUSED,
-               xmlChar * namespace ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("checkNamespace")
-        return (0);
+               xmlChar *namespace ATTRIBUTE_UNUSED) {
+    return (0);
 }
 
-/**
- * namespaceDecl:
- * @ctx: the user data (XML parser context)
- * @href:  the namespace associated URN
- * @prefix: the namespace prefix
- *
- * A namespace has been parsed.
- * DEPRECATED
- */
+XMLPUBFUN void
+namespaceDecl(void *ctx, const xmlChar *href, const xmlChar *prefix);
+
 void
-namespaceDecl(void *ctx ATTRIBUTE_UNUSED,
-              const xmlChar * href ATTRIBUTE_UNUSED,
-              const xmlChar * prefix ATTRIBUTE_UNUSED)
-{
-    DEPRECATED("namespaceDecl")
+namespaceDecl(void *ctx ATTRIBUTE_UNUSED, const xmlChar *href ATTRIBUTE_UNUSED,
+              const xmlChar *prefix ATTRIBUTE_UNUSED) {
 }
 
-/**
- * comment:
- * @ctx: the user data (XML parser context)
- * @value:  the comment content
- *
- * A comment has been parsed.
- * DEPRECATED: use xmlSAX2Comment()
- */
+XMLPUBFUN void
+comment(void *ctx, const xmlChar *value);
+
 void
-comment(void *ctx, const xmlChar * value)
-{
-    DEPRECATED("comment")
-        xmlSAX2Comment(ctx, value);
+comment(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value ATTRIBUTE_UNUSED) {
 }
 
-/**
- * cdataBlock:
- * @ctx: the user data (XML parser context)
- * @value:  The pcdata content
- * @len:  the block length
- *
- * called when a pcdata block has been parsed
- * DEPRECATED: use xmlSAX2CDataBlock()
- */
+XMLPUBFUN void
+cdataBlock(void *ctx, const xmlChar *value, int len);
+
 void
-cdataBlock(void *ctx, const xmlChar * value, int len)
-{
-    DEPRECATED("cdataBlock")
-        xmlSAX2CDataBlock(ctx, value, len);
+cdataBlock(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value ATTRIBUTE_UNUSED,
+           int len ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+initxmlDefaultSAXHandler(void *hdlr, int warning);
+
+void
+initxmlDefaultSAXHandler(void *hdlr ATTRIBUTE_UNUSED,
+                         int warning ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+inithtmlDefaultSAXHandler(void *hdlr);
+
+void
+inithtmlDefaultSAXHandler(void *hdlr ATTRIBUTE_UNUSED) {
 }
 
 /*
  * nanoftp.h
  */
 
-/** DOC_DISABLE */
-
 #ifdef _WIN32
   #include <winsock2.h>
 #else
@@ -1591,14 +752,10 @@ xmlIOFTPClose(void *context ATTRIBUTE_UNUSED) {
     return(-1);
 }
 
-/** DOC_ENABLE */
-
 /*
  * xpointer.h
  */
 
-/** DOC_DISABLE */
-
 XMLPUBFUN void *
 xmlXPtrNewRange(void *start, int startindex,
                 void *end, int endindex);
@@ -1753,7 +910,164 @@ xmlXPtrRangeToFunction(void *ctxt ATTRIBUTE_UNUSED,
                        int nargs ATTRIBUTE_UNUSED) {
 }
 
-/** DOC_ENABLE */
+/*
+ * xmllint shell functions formerly in debugXML.h
+ */
+
+XMLPUBFUN void
+xmlLsOneNode(FILE *output, xmlNodePtr node);
+
+void
+xmlLsOneNode(FILE *output ATTRIBUTE_UNUSED, xmlNodePtr node ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN int
+xmlLsCountNode(xmlNodePtr node);
+
+int
+xmlLsCountNode(xmlNodePtr node ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN const char *
+xmlBoolToText(int boolval);
+
+const char *
+xmlBoolToText(int boolval) {
+    if (boolval)
+        return("True");
+    else
+        return("False");
+}
+
+#ifdef LIBXML_XPATH_ENABLED
+XMLPUBFUN void
+xmlShellPrintXPathError(int errorType, const char *arg);
+
+void
+xmlShellPrintXPathError(int errorType ATTRIBUTE_UNUSED,
+                        const char *arg ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN void
+xmlShellPrintXPathResult(void *list);
+
+void
+xmlShellPrintXPathResult(void *list ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN int
+xmlShellList(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellList(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+             void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellBase(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellBase(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+             void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellDir(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellDir(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+            void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellLoad(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellLoad(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+             void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void
+xmlShellPrintNode(void *node);
+
+void
+xmlShellPrintNode(void *ctxt ATTRIBUTE_UNUSED) {
+}
+
+XMLPUBFUN int
+xmlShellCat(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellCat(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+            void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellWrite(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellWrite(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+              void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellSave(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellSave(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+             void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+#ifdef LIBXML_VALID_ENABLED
+XMLPUBFUN int
+xmlShellValidate(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellValidate(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+                 void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+#endif /* LIBXML_VALID_ENABLED */
+
+XMLPUBFUN int
+xmlShellDu(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellDu(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+           void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+XMLPUBFUN int
+xmlShellPwd(void *ctxt, char *arg, void *node, void *node2);
+
+int
+xmlShellPwd(void *ctxt ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED,
+            void *node ATTRIBUTE_UNUSED, void *node2 ATTRIBUTE_UNUSED) {
+    return(0);
+}
+
+typedef char * (*xmlShellReadlineFunc)(char *prompt);
+
+XMLPUBFUN void
+xmlShell(void *doc, char *filename, xmlShellReadlineFunc input, void *output);
+
+void
+xmlShell(void *doc ATTRIBUTE_UNUSED, char *filename ATTRIBUTE_UNUSED,
+         xmlShellReadlineFunc input ATTRIBUTE_UNUSED,
+         void *output ATTRIBUTE_UNUSED) {
+}
+#endif /* LIBXML_XPATH_ENABLED */
 
 #endif /* LIBXML_LEGACY_ENABLED */
 
diff --git a/libxml-2.0-uninstalled.pc.in b/libxml-2.0-uninstalled.pc.in
deleted file mode 100644
index a7b81fa7..00000000
--- a/libxml-2.0-uninstalled.pc.in
+++ /dev/null
@@ -1,12 +0,0 @@
-prefix=
-exec_prefix=
-libdir=${pcfiledir}
-includedir=${pcfiledir}/include
-modules=@WITH_MODULES@
-
-Name: libXML
-Version: @VERSION@
-Description: libXML library version2.
-Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@
-Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@
-Cflags: @XML_INCLUDEDIR@ @XML_CFLAGS@
diff --git a/libxml-2.0.pc.in b/libxml-2.0.pc.in
index 6d7b62ff..07a75885 100644
--- a/libxml-2.0.pc.in
+++ b/libxml-2.0.pc.in
@@ -8,5 +8,5 @@ Name: libXML
 Version: @VERSION@
 Description: libXML library version2.
 Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@
-Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@
-Cflags: @XML_INCLUDEDIR@ @XML_CFLAGS@
+Libs: @XML_LIBDIR@ @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@
+Cflags: @XML_INCLUDEDIR@ @XML_PC_CFLAGS_PRIVATE@ @XML_STATIC_CFLAGS@
diff --git a/libxml.h b/libxml.h
index d94677b5..6065d822 100644
--- a/libxml.h
+++ b/libxml.h
@@ -47,6 +47,16 @@
   #define XML_HIDDEN
 #endif
 
+#if __GNUC__ * 100 + __GNUC_MINOR__ >= 207 || defined(__clang__)
+  #define ATTRIBUTE_UNUSED __attribute__((unused))
+#else
+  #define ATTRIBUTE_UNUSED
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_DESTRUCTOR
+  #define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))
+#endif
+
 #if defined(__clang__) || \
     (defined(__GNUC__) && (__GNUC__ >= 8) && !defined(__EDG__))
   #define ATTRIBUTE_NO_SANITIZE(arg) __attribute__((no_sanitize(arg)))
diff --git a/libxml.m4 b/libxml.m4
index 27ad84d4..4c031a5b 100644
--- a/libxml.m4
+++ b/libxml.m4
@@ -1,6 +1,8 @@
 dnl AM_PATH_XML2([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
 dnl Test for XML, and define XML_CPPFLAGS and XML_LIBS
 dnl
+dnl Deprecated and unmaintained. Use pkg-config or xslt-config.
+dnl
 AC_DEFUN([AM_PATH_XML2],[
   m4_warn([obsolete], [AM_PATH_XML2 is deprecated, use PKG_CHECK_MODULES instead])
   AC_REQUIRE([PKG_PROG_PKG_CONFIG])
diff --git a/list.c b/list.c
index 20df26c8..dce97905 100644
--- a/list.c
+++ b/list.c
@@ -188,13 +188,15 @@ xmlListPtr
 xmlListCreate(xmlListDeallocator deallocator, xmlListDataCompare compare)
 {
     xmlListPtr l;
-    if (NULL == (l = (xmlListPtr )xmlMalloc( sizeof(xmlList))))
+    l = (xmlListPtr)xmlMalloc(sizeof(xmlList));
+    if (l == NULL)
         return (NULL);
     /* Initialize the list to NULL */
     memset(l, 0, sizeof(xmlList));
 
     /* Add the sentinel */
-    if (NULL ==(l->sentinel = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink)))) {
+    l->sentinel = (xmlLinkPtr)xmlMalloc(sizeof(xmlLink));
+    if (l->sentinel == NULL) {
 	xmlFree(l);
         return (NULL);
     }
@@ -565,7 +567,8 @@ xmlListPushBack(xmlListPtr l, void *data)
         return(0);
     lkPlace = l->sentinel->prev;
     /* Add the new link */
-    if (NULL ==(lkNew = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink))))
+    lkNew = (xmlLinkPtr)xmlMalloc(sizeof(xmlLink));
+    if (lkNew == NULL)
         return (0);
     lkNew->data = data;
     lkNew->next = lkPlace->next;
@@ -638,12 +641,12 @@ xmlListSort(xmlListPtr l)
      * an insert. This is slow...
      */
 
-    if (NULL ==(lTemp = xmlListDup(l)))
+    lTemp = xmlListDup(l);
+    if (lTemp == NULL)
         return;
     xmlListClear(l);
     xmlListMerge(l, lTemp);
     xmlListDelete(lTemp);
-    return;
 }
 
 /**
@@ -724,7 +727,8 @@ xmlListDup(xmlListPtr old)
      * set it to be the old list for the time being whilst I work out
      * the answer
      */
-    if (NULL ==(cur = xmlListCreate(NULL, old->linkCompare)))
+    cur = xmlListCreate(NULL, old->linkCompare);
+    if (cur == NULL)
         return (NULL);
     if (0 != xmlListCopy(cur, old))
         return NULL;
diff --git a/m4/ac_try_compile2.m4 b/m4/ac_try_compile2.m4
deleted file mode 100644
index 7ad8630a..00000000
--- a/m4/ac_try_compile2.m4
+++ /dev/null
@@ -1,28 +0,0 @@
-dnl Like AC_TRY_EVAL but also errors out if the compiler generates
-dnl _any_ output. Some compilers might issue warnings which we want
-dnl to catch.
-AC_DEFUN([AC_TRY_EVAL2],
-[{ (eval echo configure:__oline__: \"[$]$1\") 1>&AS_MESSAGE_LOG_FD; dnl
-(eval [$]$1) 2>&AS_MESSAGE_LOG_FD; _out=`eval [$]$1 2>&1` && test "x$_out" = x; }])
-
-dnl Like AC_TRY_COMPILE but calls AC_TRY_EVAL2 instead of AC_TRY_EVAL
-AC_DEFUN([AC_TRY_COMPILE2],
-[cat > conftest.$ac_ext <<EOF
-[#]line __oline__ "configure"
-#include "confdefs.h"
-[$1]
-int main(void) {
-[$2]
-; return 0; }
-EOF
-if AC_TRY_EVAL2(ac_compile); then
-  ifelse([$3], , :, [rm -rf conftest*
-  $3])
-else
-  echo "configure: failed program was:" >&AS_MESSAGE_LOG_FD
-  cat conftest.$ac_ext >&AS_MESSAGE_LOG_FD
-ifelse([$4], , , [  rm -rf conftest*
-  $4
-])dnl
-fi
-rm -f conftest*])
diff --git a/m4/ax_gcc_func_attribute.m4 b/m4/ax_gcc_func_attribute.m4
new file mode 100644
index 00000000..fa4e089d
--- /dev/null
+++ b/m4/ax_gcc_func_attribute.m4
@@ -0,0 +1,242 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
+#
+# DESCRIPTION
+#
+#   This macro checks if the compiler supports one of GCC's function
+#   attributes; many other compilers also provide function attributes with
+#   the same syntax. Compiler warnings are used to detect supported
+#   attributes as unsupported ones are ignored by default so quieting
+#   warnings when using this macro will yield false positives.
+#
+#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
+#
+#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
+#
+#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
+#   variable.
+#
+#   The macro currently supports the following function attributes:
+#
+#    alias
+#    aligned
+#    alloc_size
+#    always_inline
+#    artificial
+#    cold
+#    const
+#    constructor
+#    constructor_priority for constructor attribute with priority
+#    deprecated
+#    destructor
+#    dllexport
+#    dllimport
+#    error
+#    externally_visible
+#    fallthrough
+#    flatten
+#    format
+#    format_arg
+#    gnu_format
+#    gnu_inline
+#    hot
+#    ifunc
+#    leaf
+#    malloc
+#    noclone
+#    noinline
+#    nonnull
+#    noreturn
+#    nothrow
+#    optimize
+#    pure
+#    sentinel
+#    sentinel_position
+#    unused
+#    used
+#    visibility
+#    warning
+#    warn_unused_result
+#    weak
+#    weakref
+#
+#   Unsupported function attributes will be tested with a prototype
+#   returning an int and not accepting any arguments and the result of the
+#   check might be wrong or meaningless so use with care.
+#
+# LICENSE
+#
+#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 13
+
+AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
+    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
+
+    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            m4_case([$1],
+                [alias], [
+                    int foo( void ) { return 0; }
+                    int bar( void ) __attribute__(($1("foo")));
+                ],
+                [aligned], [
+                    int foo( void ) __attribute__(($1(32)));
+                ],
+                [alloc_size], [
+                    void *foo(int a) __attribute__(($1(1)));
+                ],
+                [always_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [artificial], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [cold], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [const], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [constructor_priority], [
+                    int foo( void ) __attribute__((__constructor__(65535/2)));
+                ],
+                [constructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [deprecated], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [destructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [dllexport], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [dllimport], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [error], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [externally_visible], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [fallthrough], [
+                    void foo( int x ) {switch (x) { case 1: __attribute__(($1)); case 2: break ; }};
+                ],
+                [flatten], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [format], [
+                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
+                ],
+                [gnu_format], [
+                    int foo(const char *p, ...) __attribute__((format(gnu_printf, 1, 2)));
+                ],
+                [format_arg], [
+                    char *foo(const char *p) __attribute__(($1(1)));
+                ],
+                [gnu_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [hot], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [ifunc], [
+                    int my_foo( void ) { return 0; }
+                    static int (*resolve_foo(void))(void) { return my_foo; }
+                    int foo( void ) __attribute__(($1("resolve_foo")));
+                ],
+                [leaf], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [malloc], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [noclone], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [noinline], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [nonnull], [
+                    int foo(char *p) __attribute__(($1(1)));
+                ],
+                [noreturn], [
+                    void foo( void ) __attribute__(($1));
+                ],
+                [nothrow], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [optimize], [
+                    __attribute__(($1(3))) int foo( void ) { return 0; }
+                ],
+                [pure], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [sentinel], [
+                    int foo(void *p, ...) __attribute__(($1));
+                ],
+                [sentinel_position], [
+                    int foo(void *p, ...) __attribute__(($1(1)));
+                ],
+                [returns_nonnull], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [unused], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [used], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [visibility], [
+                    int foo_def( void ) __attribute__(($1("default")));
+                    int foo_hid( void ) __attribute__(($1("hidden")));
+                    int foo_int( void ) __attribute__(($1("internal")));
+                    int foo_pro( void ) __attribute__(($1("protected")));
+                ],
+                [warning], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [warn_unused_result], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weak], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weakref], [
+                    static int foo( void ) { return 0; }
+                    static int bar( void ) __attribute__(($1("foo")));
+                ],
+                [
+                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
+                 int foo( void ) __attribute__(($1));
+                ]
+            )], [])
+            ],
+            dnl GCC doesn't exit with an error if an unknown attribute is
+            dnl provided but only outputs a warning, so accept the attribute
+            dnl only if no warning were issued.
+            [AS_IF([grep -- -Wattributes conftest.err],
+                [AS_VAR_SET([ac_var], [no])],
+                [AS_VAR_SET([ac_var], [yes])])],
+            [AS_VAR_SET([ac_var], [no])])
+    ])
+
+    AS_IF([test yes = AS_VAR_GET([ac_var])],
+        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
+            [Define to 1 if the system has the `$1' function attribute])], [])
+
+    AS_VAR_POPDEF([ac_var])
+])
diff --git a/meson.build b/meson.build
index 5d2622f7..7b5880e3 100644
--- a/meson.build
+++ b/meson.build
@@ -1,17 +1,17 @@
 project(
     'libxml2',
     'c',
-    version: '2.13.0',
+    version: files('VERSION'),
     license: 'MIT',
     default_options: ['buildtype=debug', 'warning_level=3'],
     meson_version: '>= 0.61',
 )
 
 v_array = meson.project_version().split('.')
-v_maj = v_array[0]
-v_min = v_array[1]
-v_mic = v_array[2]
-v_nbr = v_maj.to_int() * 10000 + v_min.to_int() * 100 + v_mic.to_int()
+v_maj = v_array[0].to_int()
+v_min = v_array[1].to_int()
+v_mic = v_array[2].to_int()
+v_nbr = v_maj * 10000 + v_min * 100 + v_mic
 v_extra = ''
 r = run_command('git', 'describe', check: false)
 if (r.returncode() == 0)
@@ -53,170 +53,130 @@ endif
 cc = meson.get_compiler('c')
 
 # options
-want_c14n = get_option('c14n')
-want_catalog = get_option('catalog')
-want_debug = get_option('debuging')
-want_history = get_option('history')
-want_html = get_option('html')
-want_http = get_option('http')
-want_ipv6 = get_option('ipv6')
-want_iso8859x = get_option('iso8859x')
-want_legacy = get_option('legacy')
-want_output = get_option('output')
-want_pattern = get_option('pattern')
-want_push = get_option('push')
-want_python = get_option('python')
-want_reader = get_option('reader')
-want_readline = get_option('readline')
-want_regexps = get_option('regexps')
-want_sax1 = get_option('sax1')
-want_schemas = get_option('schemas')
-want_schematron = get_option('schematron')
-want_thread_alloc = get_option('thread-alloc')
-want_tls = get_option('tls')
-want_tree = get_option('tree')
-want_valid = get_option('valid')
-want_writer = get_option('writer')
-want_xinclude = get_option('xinclude')
-want_xpath = get_option('xpath')
-want_xptr = get_option('xptr')
-
-# TODO: Options should be three-valued: "yes", "no", default
-
-# TODO: Legacy defaults
-
-# hard dependencies on options
-
-if want_c14n == true
-    if want_output == false
-        message('-Dc14n=true overrides -Doutput')
-    endif
-    want_output = true
-    if want_xpath == false
-        message('-Dc14n=true overrides -Dxpath')
-    endif
-    want_xpath = true
-endif
 
-if want_schemas == true
-    if want_pattern == false
-        message('-Dschemas=true overrides -Dpattern')
-    endif
-    want_pattern = true
-    if want_regexps == false
-        message('-Dschemas=true overrides -Dregexps')
-    endif
-    want_regexps = true
-endif
+# disabled by default
+want_icu = get_option('icu').enabled()
+want_legacy = get_option('legacy').enabled()
+want_thread_alloc = get_option('thread-alloc').enabled()
+want_tls = get_option('tls').enabled()
 
-if want_schematron == true
-    if want_pattern == false
-        message('-Dschematron=true overrides -Dpattern')
-    endif
-    want_pattern = true
-    if want_tree == false
-        message('-Dschematron=true overrides -Dtree')
-    endif
-    want_tree = true
-    if want_xpath == false
-        message('-Dschematron=true overrides -Dxpath')
-    endif
-    want_xpath = true
-endif
+# default depends on minimum option
 
-if want_reader == true
-    if want_push == false
-        message('-Dreader=true overrides -Dpush')
-    endif
-    want_push = true
-    if want_tree == false
-        message('-Dreader=true overrides -Dtree')
-    endif
-    want_tree = true
-endif
+want_minimum = get_option('minimum')
 
-if want_writer == true
-    if want_output == false
-        message('-Dwriter=true overrides -Doutput')
-    endif
-    want_output = true
-    if want_push == false
-        message('-Dwriter=true overrides -Dpush')
-    endif
-    want_push = true
-endif
+feature = get_option('catalog')
+want_catalog = want_minimum ? feature.enabled() : feature.allowed()
 
-if want_xinclude == true
-    if want_xpath == false
-        message('-Dxinclude=true overrides -Dxpath')
-    endif
-    want_xpath = true
-endif
+feature = get_option('debugging')
+want_debug = want_minimum ? feature.enabled() : feature.allowed()
 
-if want_xptr == true
-    if want_xpath == false
-        message('-Dxptr=true overrides -Dxpath')
-    endif
-    want_xpath = true
-endif
+feature = get_option('html')
+want_html = want_minimum ? feature.enabled() : feature.allowed()
 
-# minimum dependencies
-
-if get_option('minimum')
-    # TODO: This is should allow other options
-    want_c14n = false
-    want_catalog = false
-    want_debug = false
-    want_history = false
-    want_html = false
-    want_http = false
-    want_ipv6 = false
-    want_iso8859x = false
-    want_output = false
-    want_pattern = false
-    want_push = false
-    want_python = false
-    want_reader = false
-    want_readline = false
-    want_regexps = false
-    want_sax1 = false
-    want_schemas = false
-    want_schematron = false
-    want_thread_alloc = false
-    want_tree = false
-    want_valid = false
-    want_writer = false
-    want_xinclude = false
-    want_xpath = false
-    want_xptr = false
-else
-    # Disable dependent modules
-    if want_output == false
-        want_c14n = false
-        want_writer = false
-    endif
-    if want_pattern == false
-        want_schemas = false
-        want_schematron = false
-    endif
-    if want_push == false
-        want_reader = false
-        want_writer = false
-    endif
-    if want_regexps == false
-        want_schemas = false
-    endif
-    if want_tree == false
-        want_reader = false
-        want_schematron = false
-    endif
-    if want_xpath == false
-        want_c14n = false
-        want_schematron = false
-        want_xinclude = false
-        want_xptr = false
-    endif
-endif
+feature = get_option('iconv')
+want_iconv = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('iso8859x')
+want_iso8859x = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('python')
+want_python = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('modules')
+want_modules = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('sax1')
+want_sax1 = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('threads')
+want_threads = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('valid')
+want_valid = want_minimum ? feature.enabled() : feature.allowed()
+
+# default depends on legacy option
+
+feature = get_option('http')
+want_http = want_legacy ? feature.allowed() : feature.enabled()
+
+feature = get_option('lzma')
+want_lzma = want_legacy ? feature.allowed() : feature.enabled()
+
+feature = get_option('zlib')
+want_zlib = want_legacy ? feature.allowed() : feature.enabled()
+
+# dependencies
+
+feature = get_option('output')
+want_output = not want_minimum \
+    or get_option('c14n').enabled() \
+    or get_option('writer').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('pattern')
+want_pattern = not want_minimum \
+    or get_option('schemas').enabled() \
+    or get_option('schematron').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('regexps')
+want_regexps = not want_minimum \
+    or get_option('schemas').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('push')
+want_push = not want_minimum \
+    or get_option('reader').enabled() \
+    or get_option('writer').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('readline')
+want_readline = get_option('history').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('xpath')
+want_xpath = not want_minimum \
+    or get_option('c14n').enabled() \
+    or get_option('schematron').enabled() \
+    or get_option('xinclude').enabled() \
+    or get_option('xptr').enabled() ? \
+    feature.allowed() : feature.enabled()
+
+feature = get_option('c14n') \
+    .require(want_output, error_message: 'c14n requires output') \
+    .require(want_xpath, error_message: 'c14n requires xpath')
+want_c14n = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('history') \
+    .require(want_readline, error_message: 'history requires readline')
+want_history = feature.enabled()
+
+feature = get_option('reader') \
+    .require(want_push, error_message: 'reader requires push')
+want_reader = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('schemas') \
+    .require(want_pattern, error_message: 'schemas requires pattern') \
+    .require(want_regexps, error_message: 'schemas requires regexps')
+want_schemas = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('schematron') \
+    .require(want_pattern, error_message: 'schematron requires pattern') \
+    .require(want_xpath, error_message: 'schematron requires xpath')
+want_schematron = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('writer') \
+    .require(want_output, error_message: 'writer requires output') \
+    .require(want_push, error_message: 'writer requires push')
+want_writer = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('xinclude') \
+    .require(want_xpath, error_message: 'xinclude requires xpath')
+want_xinclude = want_minimum ? feature.enabled() : feature.allowed()
+
+feature = get_option('xptr') \
+    .require(want_xpath, error_message: 'xptr requires xpath')
+want_xptr = want_minimum ? feature.enabled() : feature.allowed()
 
 cflags_try = []
 
@@ -231,6 +191,7 @@ if cc.get_argument_syntax() == 'gcc'
         '-Wmissing-prototypes',
         '-Wno-long-long',
         '-Wno-format-extra-args',
+        '-Wno-array-bounds',
     ]
 
     if host_machine.cpu_family() == 'alpha'
@@ -257,7 +218,6 @@ endforeach
 #
 # [X] config.h.in
 # [X] include/libxml/xmlversion.h.in
-# [N] libxml-2.0-uninstalled.pc.in
 # [X] libxml-2.0.pc.in
 # [X] libxml2-config.cmake.in
 # [X] python/setup.py.in
@@ -274,44 +234,27 @@ config_h.set_quoted('LOCALEDIR', dir_locale)
 
 # header files
 xml_check_headers = [
-    'stdint.h',
-    'fcntl.h',
-    'unistd.h',
-    'sys/stat.h',
-    'sys/mman.h',
-    'sys/socket.h',
-    'netinet/in.h',
-    'arpa/inet.h',
-    'netdb.h',
-    'sys/select.h',
-    'poll.h',
-    'sys/time.h',
-    'sys/timeb.h',
-    'dl.h',
-    'dlfcn.h',
-    'glob.h',
+    [ 'stdint.h', true ],
+    [ 'poll.h', want_http ],
 ]
 
 foreach header : xml_check_headers
-    if cc.has_header(header)
-        config_h.set10('HAVE_' + header.underscorify().to_upper(), true)
+    if header[1] and cc.has_header(header[0])
+        config_h.set10('HAVE_' + header[0].underscorify().to_upper(), true)
     endif
 endforeach
 
 # library functions
 xml_check_functions = [
     # fct             | header
-    ['gettimeofday', 'sys/time.h'],
-    ['ftime', 'sys/timeb.h'],
-    ['stat', 'sys/stat.h'],
+    ['getentropy', 'sys/random.h'],
+    ['glob', 'glob.h'],
     ['mmap', 'sys/mman.h'],
-    ['munmap', 'sys/mman.h'],
 ]
 
 foreach function : xml_check_functions
-    if cc.has_header_symbol(function[1], function[0])
-        config_h.set10('HAVE_' + function[0].to_upper(), true)
-    endif
+    config_h.set10('HAVE_DECL_' + function[0].underscorify().to_upper(),
+                   cc.has_header_symbol(function[1], function[0]))
 endforeach
 
 # library
@@ -331,53 +274,18 @@ if sys_windows == false
 endif
 
 ### thread local storage
-support_tls = true
-if want_tls == true
-    tls_src = '''
-#include <threads.h>
-int main()
-{
-    _Thread_local int v;
-    return 0;
-}
-    '''
-    res = cc.compiles(tls_src, name: '_Thread_local')
-    if res == true
-        config_h.set('XML_THREAD_LOCAL', '_Thread_local')
-    else
-        tls_src = '''
-int main()
-{
-    __thread int v;
-    return 0;
-}
-        '''
-        res = cc.compiles(tls_src, name: '__thread')
-        if res == true
-            config_h.set('XML_THREAD_LOCAL', '__thread')
-        else
-            tls_src = '''
-int main()
-{
-    __declspec(thread) int v;
-    return 0;
-}
-            '''
-            res = cc.compiles(tls_src, name: '__declspec(thread)')
-            if res == true
-                config_h.set('XML_THREAD_LOCAL', '__declspec(thread)')
-            else
-                want_tls = false
-                support_tls = false
-            endif
+if want_tls
+    foreach t : ['_Thread_local', '__thread', '__declspec(thread)']
+        if cc.compiles('@0@ int v;'.format(t))
+            config_h.set('XML_THREAD_LOCAL', t)
+            break
         endif
-    endif
+    endforeach
 endif
 
 ### __attribute__((destructor))
 if cc.has_function_attribute('destructor')
-    config_h.set10('HAVE_ATTRIBUTE_DESTRUCTOR', true)
-    config_h.set('ATTRIBUTE_DESTRUCTOR', '__attribute__((destructor))')
+    config_h.set10('HAVE_FUNC_ATTRIBUTE_DESTRUCTOR', true)
 endif
 
 ### DSO support
@@ -389,67 +297,39 @@ else
     module_extension = '.so'
 endif
 
-dl_dep = dependency('', required: false)
-if not get_option('minimum')
-    if host_machine.system() != 'windows'
-        if meson.version().version_compare('>=0.62')
-            dl_dep = dependency('dl', required: get_option('modules'))
-        else
-            dl_dep = cc.find_library('dl', required: get_option('modules'))
-        endif
-        if dl_dep.found()
-            config_h.set10('HAVE_DLOPEN', true)
-            xml_deps += dl_dep
-        endif
-    elif get_option('modules').allowed()
-        dl_dep = declare_dependency()
+if want_modules and host_machine.system() != 'windows'
+    if meson.version().version_compare('>=0.62')
+        dl_dep = dependency('dl', required: false)
+    else
+        dl_dep = cc.find_library('dl', required: false)
+    endif
+    if dl_dep.found()
+        config_h.set10('HAVE_DLOPEN', true)
+        xml_deps += dl_dep
     endif
 endif
 
 ### threads
-threads_dep = dependency('', required: false)
-if not get_option('minimum')
-    if host_machine.system() != 'windows'
-        threads_dep = dependency('threads', required: get_option('threads'))
-        if threads_dep.found()
-            config_h.set10('HAVE_PTHREAD_H', true)
-            xml_deps += threads_dep
-        endif
-    elif get_option('threads').allowed()
-        threads_dep = declare_dependency()
-    endif
+if want_threads
+    threads_dep = dependency('threads')
+    xml_deps += threads_dep
+else
+    threads_dep = dependency('', required: false)
 endif
 
-want_thread_alloc = threads_dep.found()
-
 ### xmllint shell history
 xmllint_deps = []
-if want_history == true and want_readline == true
-    termlib_lib = ['ncurses', 'curses', 'termcap', 'terminfo', 'termlib']
-
-    foreach tl : termlib_lib
-        termlib_dep = cc.find_library(tl)
-        if (
-            termlib_dep.found()
-            and cc.has_function('tputs', dependencies: termlib_dep)
-        )
-            xmllint_deps += termlib_dep
-            config_h.set10('HAVE_LIB' + tl.underscorify().to_upper(), true)
-            break
-        endif
-    endforeach
 
-    history_dep = dependency('history', required: false)
-    if history_dep.found()
-        xmllint_deps += history_dep
-        config_h.set10('HAVE_LIBHISTORY', true)
-    endif
+if want_readline
+    readline_dep = dependency('readline')
+    config_h.set('HAVE_LIBREADLINE', true)
+    xmllint_deps += readline_dep
+endif
 
-    readline_dep = dependency('readline', required: false)
-    if readline_dep.found()
-        xmllint_deps += readline_dep
-        config_h.set10('HAVE_LIBREADLINE', true)
-    endif
+if want_history
+    history_dep = dependency('history')
+    config_h.set('HAVE_LIBHISTORY', true)
+    xmllint_deps += history_dep
 endif
 
 ### crypto
@@ -461,140 +341,52 @@ endif
 ### inet
 if want_http == true
     if sys_windows == true
-        ws2_dep = cc.find_library('ws2_32', required: true)
-        xml_deps += ws2_dep
+        net_dep = cc.find_library('ws2_32', required: true)
+        xml_deps += net_dep
     else
+        net_dep = dependency('', required: false)
         has_in_libc = cc.has_function('gethostbyname')
         if has_in_libc == false
-            nsl_dep = cc.find_library('nsl', required: true)
-            if nsl_dep.found()
+            net_dep = cc.find_library('nsl', required: true)
+            if net_dep.found()
                 has_in_nsl = cc.has_function(
                     'gethostbyname',
-                    dependencies: nsl_dep,
+                    dependencies: net_dep,
                     required: false,
                 )
                 if has_in_nsl == true
-                    xml_deps += nsl_dep
+                    xml_deps += net_dep
                 endif
             endif
         endif
     endif
-
-    ### socket length
-    socklen_src = '''
-#include <stddef.h>
-#ifdef _WIN32
-  #include <ws2tcpip.h>
-#else
-  #include <sys/socket.h>
-#endif
-int main()
-{
-    (void)getsockopt (1, 1, 1, NULL, (socklen_t *)NULL);
-    return 0;
-}
-    '''
-    res = cc.compiles(socklen_src, name: 'socket length as socklen_t')
-    if res == true
-        config_h.set('XML_SOCKLEN_T', 'socklen_t')
-    else
-        socklen_src = '''
-#include <stddef.h>
-#include <sys/socket.h>
-int main()
-{
-    (void)getsockopt (1, 1, 1, NULL, (size_t *)NULL);
-    return 0;
-}
-        '''
-        res = cc.compiles(socklen_src, name: 'socket length as size_t')
-        if res == true
-            config_h.set('XML_SOCKLEN_T', 'size_t')
-        else
-            socklen_src = '''
-#include <stddef.h>
-#include <sys/socket.h>
-int main()
-{
-    (void)getsockopt (1, 1, 1, NULL, (int *)NULL);
-    return 0;
-}
-            '''
-            res = cc.compiles(socklen_src, name: 'socket length as int')
-            if res == false
-                message('could not determine socket length type, use int')
-            endif
-            config_h.set('XML_SOCKLEN_T', 'int')
-        endif
-    endif
-
-    if want_ipv6 == true
-        ### IPV6 on Windows has been supported since Windows XP SP1 (around 2003)
-        ### see:
-        ### https://learn.microsoft.com/en-us/windows/win32/winsock/ipv6-support-2
-        ### nevertheless, we check it like autotools
-        ipv6_src = '''
-#ifdef _WIN32
-#include <winsock2.h>
-#else
-#include <sys/socket.h>
-#ifdef HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#endif
-int main()
-{
-    struct sockaddr_storage ss;
-    socket(AF_INET6, SOCK_STREAM, 0);
-    getaddrinfo(0, 0, 0, 0);
-    return 0;
-}
-        '''
-        res = cc.compiles(ipv6_src, name: 'support for IPV6')
-        if res == true
-            config_h.set10('SUPPORT_IP6', true)
-        endif
-    endif
 endif
 
 ### zlib
-if not get_option('minimum')
-    zlib_dep = dependency('zlib', required: get_option('zlib'))
-else
-    zlib_dep = dependency('', required: false)
+if want_zlib
+    xml_deps += dependency('zlib')
 endif
-xml_deps += zlib_dep
 
 ### lzma
-if not get_option('minimum')
-    lzma_dep = dependency('liblzma', required: get_option('lzma'))
-else
-    lzma_dep = dependency('', required: false)
-endif
-xml_deps += lzma_dep
-
-### iconv
-if not get_option('minimum')
-    iconv_dep = dependency('iconv', required: get_option('iconv'))
-else
-    iconv_dep = dependency('', required: false)
-endif
-xml_deps += iconv_dep
-
-if not iconv_dep.found() and want_iso8859x == false
-    want_iso8859x = false
-else
-    want_iso8859x = true
+if want_lzma
+    xml_deps += dependency('liblzma')
 endif
 
 # icu
-icu_dep = dependency('icu-i18n', method: 'pkg-config', required: get_option('icu'))
-if icu_dep.found()
-    def_var = icu_dep.get_variable(pkgconfig: 'DEFS')
-    config_dir += include_directories(def_var)
+if want_icu
+    icu_dep = dependency('icu-i18n', method: 'pkg-config')
+    defs = icu_dep.get_variable(pkgconfig: 'DEFS')
+    if cc.has_argument(defs)
+        libxml2_cflags += defs
+    endif
     xml_deps += icu_dep
 endif
 
+### iconv
+if want_iconv
+    xml_deps += dependency('iconv')
+endif
+
 subdir('include/libxml')
 
 # Set config_h after all subdirs and dependencies have set values
@@ -632,13 +424,12 @@ xml_opt_src = [
     [want_html, ['HTMLparser.c', 'HTMLtree.c']],
     [want_http, ['nanohttp.c']],
     [want_legacy, ['legacy.c']],
-    [lzma_dep.found(), ['xzlib.c']],
-    [dl_dep.found(), ['xmlmodule.c']],
+    [want_lzma, ['xzlib.c']],
+    [want_modules, ['xmlmodule.c']],
     [want_output, ['xmlsave.c']],
     [want_pattern, ['pattern.c']],
     [want_reader, ['xmlreader.c']],
     [want_regexps, ['xmlregexp.c', 'xmlunicode.c']],
-    [want_sax1, ['SAX.c']],
     [want_schemas, ['relaxng.c', 'xmlschemas.c', 'xmlschemastypes.c']],
     [want_schemas and not want_xpath, ['xpath.c']],
     [want_schematron, ['schematron.c']],
@@ -662,6 +453,7 @@ foreach file : xml_opt_src
     endif
 endforeach
 
+v_min_compat = 0
 xml_lib = library(
     'xml2',
     files(xml_src),
@@ -670,6 +462,7 @@ xml_lib = library(
     include_directories: config_dir,
     install: true,
     version: meson.project_version(),
+    soversion: v_maj + v_min_compat,
 )
 
 dep_inc = include_directories('include')
@@ -681,7 +474,7 @@ meson.override_dependency('libxml-2.0', xml_dep)
 
 executable(
     'xmllint',
-    files('xmllint.c'),
+    files('xmllint.c', 'shell.c'),
     dependencies: [xml_dep, xmllint_deps],
     include_directories: config_dir,
     install: true,
@@ -709,26 +502,25 @@ testdso_mod = shared_module(
 
 ## tests
 
-checks = [
-    'runsuite',
-    'runtest',
-    'runxmlconf',
+checks = {
+    'runsuite': [],
+    'runtest': threads_dep,
+    'runxmlconf': [],
 # Disabled for now, see #694
-#    'testModule',
-    'testThreads',
-    'testapi',
-    'testchar',
-    'testdict',
-    'testlimits',
-    'testparser',
-    'testrecurse',
-]
+#    'testModule': [],
+    'testapi': [],
+    'testchar': [],
+    'testdict': [],
+    'testlimits': [],
+    'testparser': [],
+    'testrecurse': [],
+}
 
-foreach check : checks
+foreach check, deps : checks
     exe = executable(
         check,
         files(check + '.c'),
-        dependencies: [threads_dep, xml_dep],
+        dependencies: [deps, xml_dep],
         include_directories: config_dir,
     )
     if check != 'testlimits'
@@ -752,7 +544,8 @@ pkgmod.generate(
     description: 'libXML library version2.',
     filebase: 'libxml-2.0',
     name: 'libXML',
-    variables: 'modules=' + dl_dep.found().to_string('1', '0'),
+    subdirs:  [meson.project_name()],
+    variables: 'modules=' + want_modules.to_string('1', '0'),
 )
 
 ## libxml2-config.cmake file
@@ -762,12 +555,12 @@ config_cmake.set('LIBXML_MAJOR_VERSION', v_maj)
 config_cmake.set('LIBXML_MINOR_VERSION', v_min)
 config_cmake.set('LIBXML_MICRO_VERSION', v_mic)
 config_cmake.set('VERSION', meson.project_version())
-config_cmake.set('WITH_ICONV', iconv_dep.found().to_int().to_string())
-config_cmake.set('WITH_ICU', icu_dep.found().to_int().to_string())
-config_cmake.set('WITH_LZMA', lzma_dep.found().to_int().to_string())
-config_cmake.set('WITH_MODULES', dl_dep.found().to_int().to_string())
-config_cmake.set('WITH_THREADS', threads_dep.found().to_int().to_string())
-config_cmake.set('WITH_ZLIB', zlib_dep.found().to_int().to_string())
+config_cmake.set('WITH_ICONV', want_iconv.to_int().to_string())
+config_cmake.set('WITH_ICU', want_icu.to_int().to_string())
+config_cmake.set('WITH_LZMA', want_lzma.to_int().to_string())
+config_cmake.set('WITH_MODULES', want_modules.to_int().to_string())
+config_cmake.set('WITH_THREADS', want_threads.to_int().to_string())
+config_cmake.set('WITH_ZLIB', want_zlib.to_int().to_string())
 config_cmake.set('XML_CFLAGS', xml_cflags)
 configure_file(
     input: 'libxml2-config.cmake.in',
@@ -776,17 +569,6 @@ configure_file(
     install_dir: dir_lib / 'cmake' / 'libxml2',
 )
 
-install_data(files('libxml.m4'), install_dir: dir_data / 'aclocal')
-
-if support_tls == false
-    message('===============================================================')
-    message('WARNING: Your C compiler appears to not support thread-local')
-    message('storage. Future versions of libxml2 will require this feature')
-    message('for multi-threading.')
-    message('===============================================================\n',
-    )
-endif
-
 # summary
 
 summary(
@@ -798,13 +580,12 @@ summary(
         'history': want_history,
         'html': want_html,
         'http': want_http,
-        'iconv': iconv_dep.found(),
-        'icu': icu_dep.found(),
-        'ipv6': want_ipv6,
+        'iconv': want_iconv,
+        'icu': want_icu,
         'iso8859x': want_iso8859x,
         'legacy': want_legacy,
-        'lzma': lzma_dep.found(),
-        'modules': dl_dep.found(),
+        'lzma': want_lzma,
+        'modules': want_modules,
         'output': want_output,
         'pattern': want_pattern,
         'push': want_push,
@@ -815,16 +596,15 @@ summary(
         'sax1': want_sax1,
         'schemas': want_schemas,
         'schematron': want_schematron,
-        'threads': threads_dep.found(),
+        'threads': want_threads,
         'thread-alloc': want_thread_alloc,
         'tls': want_tls,
-        'tree': want_tree,
         'valid': want_valid,
         'writer': want_writer,
         'xinclude': want_xinclude,
         'xpath': want_xpath,
         'xptr': want_xptr,
-        'zlib': zlib_dep.found(),
+        'zlib': want_zlib,
     },
     section: 'Configuration Options Summary:',
 )
diff --git a/meson_options.txt b/meson_options.txt
index c45fbbe9..1137aef6 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -8,7 +8,6 @@
 # [X] http
 # [X] iconv
 # [X] icu         - not minimum
-# [X] ipv6
 # [X] iso8859x
 # [X] legacy
 # [X] lzma
@@ -26,7 +25,6 @@
 # [X] threads
 # [X] thread-alloc
 # [X] tls
-# [X] tree
 # [X] valid
 # [X] writer
 # [X] xinclude
@@ -35,43 +33,34 @@
 # [X] zlib
 
 # [X] minimum
-# [X] ipv6
-
-# TODO: Options should be three-valued: "yes", "no", default
 
 option('c14n',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Canonical XML 1.0 support'
 )
 
 option('catalog',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'XML Catalogs support'
 )
 
-option('debuging',
-  type: 'boolean',
-  value: true,
+option('debugging',
+  type: 'feature',
   description: 'Debugging module and shell'
 )
 
 option('history',
-  type: 'boolean',
-  value: false,
+  type: 'feature',
   description: 'History support for shell'
 )
 
 option('html',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'HTML parser'
 )
 
 option('http',
-  type: 'boolean',
-  value: false,
+  type: 'feature',
   description: 'HTTP support'
 )
 
@@ -83,24 +72,18 @@ option('iconv',
 
 option('icu',
   type: 'feature',
+  value: 'disabled',
   description: 'ICU support'
 )
 
-option('ipv6',
-  type: 'boolean',
-  value: true,
-  description: 'Compilation of IPv6 code'
-)
-
 option('iso8859x',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'ISO-8859-X support if no iconv'
 )
 
 option('legacy',
-  type: 'boolean',
-  value: false,
+  type: 'feature',
+  value: 'disabled',
   description: 'Maximum ABI compatibility'
 )
 
@@ -115,62 +98,52 @@ option('modules',
 )
 
 option('output',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Serialization support'
 )
 
 option('pattern',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'xmlPattern selection interface'
 )
 
 option('push',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'push parser interfaces'
 )
 
 option('python',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Python bindings'
 )
 
 option('reader',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'xmlReader parsing interface'
 )
 
 option('readline',
-  type: 'boolean',
-  value: true,
-  description: 'use readline in DIR (for shell history)'
+  type: 'feature',
+  description: 'use readline for shell history'
 )
 
 option('regexps',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Regular expressions support'
 )
 
 option('sax1',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Older SAX1 interface'
 )
 
 option('schemas',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'XML Schemas 1.0 and RELAX NG support'
 )
 
 option('schematron',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'Schematron support'
 )
 
@@ -180,50 +153,39 @@ option('threads',
 )
 
 option('thread-alloc',
-  type: 'boolean',
-  value: false,
+  type: 'feature',
+  value: 'disabled',
   description: 'per-thread malloc hooks'
 )
 
 option('tls',
-  type: 'boolean',
-  value: false,
+  type: 'feature',
+  value: 'disabled',
   description: 'thread-local storage'
 )
 
-option('tree',
-  type: 'boolean',
-  value: true,
-  description: 'DOM like tree manipulation APIs'
-)
-
 option('valid',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'DTD validation support'
 )
 
 option('writer',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'xmlWriter serialization interface'
 )
 
 option('xinclude',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'XInclude 1.0 support'
 )
 
 option('xpath',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'XPath 1.0 support'
 )
 
 option('xptr',
-  type: 'boolean',
-  value: true,
+  type: 'feature',
   description: 'XPointer support'
 )
 
@@ -235,5 +197,5 @@ option('zlib',
 option('minimum',
   type: 'boolean',
   value: false,
-  description: 'build a minimally sized library (default=false)'
+  description: 'build a minimally sized library'
 )
diff --git a/nanohttp.c b/nanohttp.c
index fcc4dad5..f8c5bdb9 100644
--- a/nanohttp.c
+++ b/nanohttp.c
@@ -20,48 +20,36 @@
 #include <stdlib.h>
 #include <errno.h>
 
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#elif defined (_WIN32)
+#include <fcntl.h>
+
+#ifdef _WIN32
+
 #include <io.h>
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#ifdef HAVE_ARPA_INET_H
-#include <arpa/inet.h>
-#endif
-#ifdef HAVE_NETDB_H
+#include <wsockcompat.h>
+#define XML_SOCKLEN_T int
+
+#else /* _WIN32 */
+
 #include <netdb.h>
-#endif
-#ifdef HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-#ifdef HAVE_SYS_TIME_H
+#include <netinet/in.h>
+#include <sys/socket.h>
 #include <sys/time.h>
-#endif
-#ifndef HAVE_POLL_H
-#ifdef HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif
+#include <unistd.h>
+
+#ifdef HAVE_POLL_H
+  #include <poll.h>
 #else
-#include <poll.h>
-#endif
-#ifdef LIBXML_ZLIB_ENABLED
-#include <zlib.h>
+  #include <sys/select.h>
 #endif
 
+/* This can be disabled if you don't have getaddrinfo */
+#define SUPPORT_IP6
+#define XML_SOCKLEN_T socklen_t
 
-#ifdef VMS
-#include <stropts>
-#define XML_SOCKLEN_T unsigned int
-#endif
+#endif /* _WIN32 */
 
-#if defined(_WIN32)
-#include <wsockcompat.h>
+#ifdef LIBXML_ZLIB_ENABLED
+#include <zlib.h>
 #endif
 
 #include <libxml/xmlerror.h>
@@ -82,18 +70,9 @@
 #define INVALID_SOCKET (-1)
 #endif
 
-#ifndef XML_SOCKLEN_T
-#define XML_SOCKLEN_T unsigned int
-#endif
-
 #define GETHOSTBYNAME_ARG_CAST (char *)
 #define SEND_ARG2_CAST (char *)
 
-#ifdef STANDALONE
-#define xmlStrncasecmp(a, b, n) strncasecmp((char *)a, (char *)b, n)
-#define xmlStrcasecmpi(a, b) strcasecmp((char *)a, (char *)b)
-#endif
-
 #define XML_NANO_HTTP_MAX_REDIR	10
 
 #define XML_NANO_HTTP_CHUNK	4096
@@ -504,7 +483,7 @@ xmlNanoHTTPRecv(xmlNanoHTTPCtxtPtr ctxt)
 
     while (ctxt->state & XML_NANO_HTTP_READ) {
         if (ctxt->in == NULL) {
-            ctxt->in = (char *) xmlMallocAtomic(65000);
+            ctxt->in = xmlMalloc(65000);
             if (ctxt->in == NULL) {
                 xmlHTTPErrMemory();
                 ctxt->last = -1;
@@ -1064,7 +1043,7 @@ xmlNanoHTTPConnectHost(const char *host, int port)
  * extraction code. it work on Linux, if it work on your platform
  * and one want to enable it, send me the defined(foobar) needed
  */
-#if defined(HAVE_NETDB_H) && defined(HOST_NOT_FOUND) && defined(__linux__)
+#if defined(HOST_NOT_FOUND) && defined(__linux__)
 	    const char *h_err_txt = "";
 
 	    switch (h_errno) {
@@ -1278,7 +1257,8 @@ xmlNanoHTTPHostnameMatch(const char *pattern, const char *hostname) {
 
     for (; idx_pattern >= 0 && idx_hostname >= 0; 
            --idx_pattern, --idx_hostname) {
-	if (tolower(pattern_start[idx_pattern]) != tolower(hostname[idx_hostname]))
+	if (tolower((unsigned char)pattern_start[idx_pattern]) !=
+            tolower((unsigned char)hostname[idx_hostname]))
 	    break;
     }
 
@@ -1310,7 +1290,7 @@ xmlNanoHTTPBypassProxy(const char *hostname) {
     env = cpy;
 
     /* The remainder of the function is basically a tokenizing: */
-    while (isspace(*env))
+    while (isspace((unsigned char)*env))
     	++env;
     if (*env == '\0') {
     	xmlFree(cpy);
@@ -1331,7 +1311,7 @@ xmlNanoHTTPBypassProxy(const char *hostname) {
 	    return 1;
 	}
 
-	while (isspace(*env))
+	while (isspace((unsigned char)*env))
 	    ++env;
 	p = env;
     }
@@ -1445,7 +1425,7 @@ retry:
 	else
 	    blen += 11;
     }
-    bp = (char*)xmlMallocAtomic(blen);
+    bp = xmlMalloc(blen);
     if ( bp == NULL ) {
         xmlNanoHTTPFreeCtxt( ctxt );
 	xmlHTTPErrMemory();
@@ -1824,33 +1804,4 @@ xmlNanoHTTPFetchContent( void * ctx, char ** ptr, int * len ) {
     return ( rc );
 }
 
-#ifdef STANDALONE
-int main(int argc, char **argv) {
-    char *contentType = NULL;
-
-    if (argv[1] != NULL) {
-	if (argv[2] != NULL)
-	    xmlNanoHTTPFetch(argv[1], argv[2], &contentType);
-        else
-	    xmlNanoHTTPFetch(argv[1], "-", &contentType);
-	if (contentType != NULL) xmlFree(contentType);
-    } else {
-        fprintf(stderr,
-		"%s: minimal HTTP GET implementation\n", argv[0]);
-        fprintf(stderr,
-		"\tusage %s [ URL [ filename ] ]\n", argv[0]);
-    }
-    xmlNanoHTTPCleanup();
-    return(0);
-}
-#endif /* STANDALONE */
-#else /* !LIBXML_HTTP_ENABLED */
-#ifdef STANDALONE
-#include <stdio.h>
-int main(int argc, char **argv) {
-    fprintf(stderr,
-	    "%s : HTTP support not compiled in\n", argv[0]);
-    return(0);
-}
-#endif /* STANDALONE */
 #endif /* LIBXML_HTTP_ENABLED */
diff --git a/parser.c b/parser.c
index f1f002b8..58cefc7a 100644
--- a/parser.c
+++ b/parser.c
@@ -20,7 +20,7 @@
  * different ranges of character are actually implanted either in
  * parserInternals.h or parserInternals.c
  * The DOM tree build is realized from the default SAX callbacks in
- * the module SAX.c.
+ * the module SAX2.c.
  * The routines doing the validation checks are in valid.c and called either
  * from the SAX callbacks or as standalone functions using a preparsed
  * document.
@@ -79,6 +79,10 @@
 #define URI_HASH_EMPTY  0xD943A04E
 #define URI_HASH_XML    0xF0451F02
 
+#ifndef STDIN_FILENO
+  #define STDIN_FILENO 0
+#endif
+
 struct _xmlStartTag {
     const xmlChar *prefix;
     const xmlChar *URI;
@@ -523,11 +527,7 @@ xmlHasFeature(xmlFeature feature)
 	    return(0);
 #endif
         case XML_WITH_TREE:
-#ifdef LIBXML_TREE_ENABLED
             return(1);
-#else
-            return(0);
-#endif
         case XML_WITH_OUTPUT:
 #ifdef LIBXML_OUTPUT_ENABLED
             return(1);
@@ -643,7 +643,7 @@ xmlHasFeature(xmlFeature feature)
             return(0);
 #endif
         case XML_WITH_AUTOMATA:
-#ifdef LIBXML_AUTOMATA_ENABLED
+#ifdef LIBXML_REGEXP_ENABLED
             return(1);
 #else
             return(0);
@@ -973,6 +973,11 @@ xmlCtxtInitializeLate(xmlParserCtxtPtr ctxt) {
 		(ctxt->str_xml_ns == NULL)) {
         xmlErrMemory(ctxt);
     }
+
+    xmlDictSetLimit(ctxt->dict,
+                    (ctxt->options & XML_PARSE_HUGE) ?
+                        0 :
+                        XML_MAX_DICTIONARY_LIMIT);
 }
 
 typedef struct {
@@ -1154,7 +1159,6 @@ xmlAddDefAttrs(xmlParserCtxtPtr ctxt,
 
 mem_error:
     xmlErrMemory(ctxt);
-    return;
 }
 
 /**
@@ -1185,7 +1189,6 @@ xmlAddSpecialAttr(xmlParserCtxtPtr ctxt,
 
 mem_error:
     xmlErrMemory(ctxt);
-    return;
 }
 
 /**
@@ -1224,7 +1227,6 @@ xmlCleanSpecialAttr(xmlParserCtxtPtr ctxt)
         xmlHashFree(ctxt->attsSpecial, NULL);
         ctxt->attsSpecial = NULL;
     }
-    return;
 }
 
 /**
@@ -1930,8 +1932,11 @@ mem_error:
 int
 inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
 {
+    char *directory = NULL;
+
     if ((ctxt == NULL) || (value == NULL))
         return(-1);
+
     if (ctxt->inputNr >= ctxt->inputMax) {
         size_t newSize = ctxt->inputMax * 2;
         xmlParserInputPtr *tmp;
@@ -1945,9 +1950,36 @@ inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
         ctxt->inputTab = tmp;
         ctxt->inputMax = newSize;
     }
+
+    if ((ctxt->inputNr == 0) && (value->filename != NULL)) {
+        directory = xmlParserGetDirectory(value->filename);
+        if (directory == NULL) {
+            xmlErrMemory(ctxt);
+            return(-1);
+        }
+    }
+
+    if (ctxt->input_id >= INT_MAX) {
+        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT, "Input ID overflow\n");
+        return(-1);
+    }
+
     ctxt->inputTab[ctxt->inputNr] = value;
     ctxt->input = value;
-    return (ctxt->inputNr++);
+
+    if (ctxt->inputNr == 0) {
+        xmlFree(ctxt->directory);
+        ctxt->directory = directory;
+    }
+
+    /*
+     * Internally, the input ID is only used to detect parameter entity
+     * boundaries. But there are entity loaders in downstream code that
+     * detect the main document by checking for "input_id == 1".
+     */
+    value->id = ctxt->input_id++;
+
+    return(ctxt->inputNr++);
 }
 /**
  * inputPop:
@@ -2253,8 +2285,6 @@ static int spacePop(xmlParserCtxtPtr ctxt) {
  *   NEXT    Skip to the next character, this does the proper decoding
  *           in UTF-8 mode. It also pop-up unfinished entities on the fly.
  *   NEXTL(l) Skip the current unicode character of l xmlChars long.
- *   CUR_CHAR(l) returns the current unicode character (int), set l
- *           to the number of xmlChars used for the encoding [0-5].
  *   CUR_SCHAR  same but operate on a string instead of the context
  *   COPY_BUF  copy the current unicode char to the target buffer, increment
  *            the index
@@ -2334,13 +2364,22 @@ static int spacePop(xmlParserCtxtPtr ctxt) {
     ctxt->input->cur += l;				\
   } while (0)
 
-#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
 #define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
 
 #define COPY_BUF(b, i, v)						\
     if (v < 0x80) b[i++] = v;						\
     else i += xmlCopyCharMultiByte(&b[i],v)
 
+static int
+xmlCurrentCharRecover(xmlParserCtxtPtr ctxt, int *len) {
+    int c = xmlCurrentChar(ctxt, len);
+
+    if (c == XML_INVALID_CHAR)
+        c = 0xFFFD; /* replacement character */
+
+    return(c);
+}
+
 /**
  * xmlSkipBlankChars:
  * @ctxt:  the XML parser context
@@ -2542,7 +2581,8 @@ xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 	return(-1);
     }
     ret = inputPush(ctxt, input);
-    GROW;
+    if (ret >= 0)
+        GROW;
     return(ret);
 }
 
@@ -2945,6 +2985,8 @@ static int areBlanks(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
  * @name:  an XML parser context
  * @prefixOut:  a xmlChar **
  *
+ * DEPRECATED: Don't use.
+ *
  * parse an UTF8 encoded XML qualified name string
  *
  * [NS 5] QName ::= (Prefix ':')? LocalPart
@@ -2989,7 +3031,7 @@ xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefixOut) {
 	 */
 	max = len * 2;
 
-	buffer = (xmlChar *) xmlMallocAtomic(max);
+	buffer = xmlMalloc(max);
 	if (buffer == NULL) {
 	    xmlErrMemory(ctxt);
 	    return(NULL);
@@ -3076,7 +3118,7 @@ xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefixOut) {
 	     */
 	    max = len * 2;
 
-	    buffer = (xmlChar *) xmlMallocAtomic(max);
+	    buffer = xmlMalloc(max);
 	    if (buffer == NULL) {
 	        xmlErrMemory(ctxt);
                 xmlFree(prefix);
@@ -3224,7 +3266,7 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
     /*
      * Handler for more complex cases
      */
-    c = CUR_CHAR(l);
+    c = xmlCurrentChar(ctxt, &l);
     if ((ctxt->options & XML_PARSE_OLD10) == 0) {
         /*
 	 * Use the new checks of production [4] [4a] amd [5] of the
@@ -3250,7 +3292,7 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	}
 	len += l;
 	NEXTL(l);
-	c = CUR_CHAR(l);
+	c = xmlCurrentChar(ctxt, &l);
 	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
 	       (((c >= 'a') && (c <= 'z')) ||
 	        ((c >= 'A') && (c <= 'Z')) ||
@@ -3275,7 +3317,7 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
             if (len <= INT_MAX - l)
 	        len += l;
 	    NEXTL(l);
-	    c = CUR_CHAR(l);
+	    c = xmlCurrentChar(ctxt, &l);
 	}
     } else {
 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
@@ -3285,7 +3327,7 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	}
 	len += l;
 	NEXTL(l);
-	c = CUR_CHAR(l);
+	c = xmlCurrentChar(ctxt, &l);
 
 	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
 	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
@@ -3296,7 +3338,7 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
             if (len <= INT_MAX - l)
 	        len += l;
 	    NEXTL(l);
-	    c = CUR_CHAR(l);
+	    c = xmlCurrentChar(ctxt, &l);
 	}
     }
     if (len > maxLength) {
@@ -3400,7 +3442,7 @@ xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
      * Handler for more complex cases
      */
     startPosition = CUR_PTR - BASE_PTR;
-    c = CUR_CHAR(l);
+    c = xmlCurrentChar(ctxt, &l);
     if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
 	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
 	return(ret);
@@ -3411,7 +3453,7 @@ xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
         if (len <= INT_MAX - l)
 	    len += l;
 	NEXTL(l);
-	c = CUR_CHAR(l);
+	c = xmlCurrentChar(ctxt, &l);
     }
     if (len > maxLength) {
         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
@@ -3573,7 +3615,7 @@ xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {
 	    xmlChar *buffer;
 	    int max = len * 2;
 
-	    buffer = (xmlChar *) xmlMallocAtomic(max);
+	    buffer = xmlMalloc(max);
 	    if (buffer == NULL) {
 	        xmlErrMemory(ctxt);
 		return(NULL);
@@ -3642,12 +3684,12 @@ xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
                     XML_MAX_TEXT_LENGTH :
                     XML_MAX_NAME_LENGTH;
 
-    c = CUR_CHAR(l);
+    c = xmlCurrentChar(ctxt, &l);
 
     while (xmlIsNameChar(ctxt, c)) {
 	COPY_BUF(buf, len, c);
 	NEXTL(l);
-	c = CUR_CHAR(l);
+	c = xmlCurrentChar(ctxt, &l);
 	if (len >= XML_MAX_NAMELEN) {
 	    /*
 	     * Okay someone managed to make a huge token, so he's ready to pay
@@ -3656,7 +3698,7 @@ xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 	    xmlChar *buffer;
 	    int max = len * 2;
 
-	    buffer = (xmlChar *) xmlMallocAtomic(max);
+	    buffer = xmlMalloc(max);
 	    if (buffer == NULL) {
 	        xmlErrMemory(ctxt);
 		return(NULL);
@@ -3682,7 +3724,7 @@ xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
                     return(NULL);
                 }
 		NEXTL(l);
-		c = CUR_CHAR(l);
+		c = xmlCurrentChar(ctxt, &l);
 	    }
 	    buffer[len] = 0;
 	    return(buffer);
@@ -3847,8 +3889,6 @@ xmlExpandPEsInEntityValue(xmlParserCtxtPtr ctxt, xmlSBuf *buf,
 
     if (chunk < str)
         xmlSBufAddString(buf, chunk, str - chunk);
-
-    return;
 }
 
 /**
@@ -4203,8 +4243,6 @@ xmlExpandEntityInAttValue(xmlParserCtxtPtr ctxt, xmlSBuf *buf,
 
     if (chunkSize > 0)
         xmlSBufAddString(buf, str - chunkSize, chunkSize);
-
-    return;
 }
 
 /**
@@ -4399,8 +4437,8 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *attlen, int *alloc,
 
             if ((val == '&') && (!replaceEntities)) {
                 /*
-                 * The reparsing will be done in xmlStringGetNodeList()
-                 * called by the attribute() function in SAX.c
+                 * The reparsing will be done in xmlNodeParseContent()
+                 * called from SAX2.c
                  */
                 xmlSBufAddCString(&buf, "&#38;", 5);
                 inSpace = 0;
@@ -4579,12 +4617,12 @@ xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
 	return(NULL);
     }
 
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
         xmlErrMemory(ctxt);
 	return(NULL);
     }
-    cur = CUR_CHAR(l);
+    cur = xmlCurrentCharRecover(ctxt, &l);
     while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */
 	if (len + 5 >= size) {
 	    xmlChar *tmp;
@@ -4605,7 +4643,7 @@ xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
             return(NULL);
         }
 	NEXTL(l);
-	cur = CUR_CHAR(l);
+	cur = xmlCurrentCharRecover(ctxt, &l);
     }
     buf[len] = 0;
     if (!IS_CHAR(cur)) {
@@ -4650,7 +4688,7 @@ xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 	return(NULL);
     }
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
 	xmlErrMemory(ctxt);
 	return(NULL);
@@ -4898,7 +4936,7 @@ xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
     int nbchar = 0;
     int cur, l;
 
-    cur = CUR_CHAR(l);
+    cur = xmlCurrentCharRecover(ctxt, &l);
     while ((cur != '<') && /* checked */
            (cur != '&') &&
 	   (IS_CHAR(cur))) {
@@ -4931,7 +4969,7 @@ xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 	    nbchar = 0;
             SHRINK;
 	}
-	cur = CUR_CHAR(l);
+	cur = xmlCurrentCharRecover(ctxt, &l);
     }
     if (nbchar != 0) {
         buf[nbchar] = 0;
@@ -5088,13 +5126,13 @@ xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
     if (buf == NULL) {
         len = 0;
 	size = XML_PARSER_BUFFER_SIZE;
-	buf = (xmlChar *) xmlMallocAtomic(size);
+	buf = xmlMalloc(size);
 	if (buf == NULL) {
 	    xmlErrMemory(ctxt);
 	    return;
 	}
     }
-    q = CUR_CHAR(ql);
+    q = xmlCurrentCharRecover(ctxt, &ql);
     if (q == 0)
         goto not_terminated;
     if (!IS_CHAR(q)) {
@@ -5105,7 +5143,7 @@ xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 	return;
     }
     NEXTL(ql);
-    r = CUR_CHAR(rl);
+    r = xmlCurrentCharRecover(ctxt, &rl);
     if (r == 0)
         goto not_terminated;
     if (!IS_CHAR(r)) {
@@ -5116,7 +5154,7 @@ xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 	return;
     }
     NEXTL(rl);
-    cur = CUR_CHAR(l);
+    cur = xmlCurrentCharRecover(ctxt, &l);
     if (cur == 0)
         goto not_terminated;
     while (IS_CHAR(cur) && /* checked */
@@ -5153,7 +5191,7 @@ xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 	rl = l;
 
 	NEXTL(l);
-	cur = CUR_CHAR(l);
+	cur = xmlCurrentCharRecover(ctxt, &l);
 
     }
     buf[len] = 0;
@@ -5176,7 +5214,6 @@ not_terminated:
     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 			 "Comment not terminated\n", NULL);
     xmlFree(buf);
-    return;
 }
 
 /**
@@ -5253,7 +5290,7 @@ get_more:
                     size = nbchar + 1;
                 else
                     size = XML_PARSER_BUFFER_SIZE + nbchar;
-                buf = (xmlChar *) xmlMallocAtomic(size);
+                buf = xmlMalloc(size);
                 if (buf == NULL) {
                     xmlErrMemory(ctxt);
                     return;
@@ -5330,7 +5367,6 @@ get_more:
 	}
     } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
     xmlParseCommentComplex(ctxt, buf, len, size);
-    return;
 }
 
 
@@ -5498,7 +5534,7 @@ xmlParsePI(xmlParserCtxtPtr ctxt) {
 		                                     target, NULL);
 		return;
 	    }
-	    buf = (xmlChar *) xmlMallocAtomic(size);
+	    buf = xmlMalloc(size);
 	    if (buf == NULL) {
 		xmlErrMemory(ctxt);
 		return;
@@ -5507,7 +5543,7 @@ xmlParsePI(xmlParserCtxtPtr ctxt) {
 		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 			  "ParsePI: PI %s space expected\n", target);
 	    }
-	    cur = CUR_CHAR(l);
+	    cur = xmlCurrentCharRecover(ctxt, &l);
 	    while (IS_CHAR(cur) && /* checked */
 		   ((cur != '?') || (NXT(1) != '>'))) {
 		if (len + 5 >= size) {
@@ -5530,7 +5566,7 @@ xmlParsePI(xmlParserCtxtPtr ctxt) {
                     return;
                 }
 		NEXTL(l);
-		cur = CUR_CHAR(l);
+		cur = xmlCurrentCharRecover(ctxt, &l);
 	    }
 	    buf[len] = 0;
 	    if (cur != '?') {
@@ -5543,13 +5579,14 @@ xmlParsePI(xmlParserCtxtPtr ctxt) {
 		if ((ctxt->inSubset == 0) &&
 		    (xmlStrEqual(target, XML_CATALOG_PI))) {
 		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
-		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
-			(allow == XML_CATA_ALLOW_ALL))
+
+		    if (((ctxt->options & XML_PARSE_NO_CATALOG_PI) == 0) &&
+                        ((allow == XML_CATA_ALLOW_DOCUMENT) ||
+			 (allow == XML_CATA_ALLOW_ALL)))
 			xmlParseCatalogPI(ctxt, buf);
 		}
 #endif
 
-
 		/*
 		 * SAX: PI detected.
 		 */
@@ -7354,6 +7391,14 @@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 	return;
     }
 
+    /*
+     * Some users try to parse entities on their own and used to set
+     * the renamed "checked" member. Fix the flags to cover this
+     * case.
+     */
+    if (((ent->flags & XML_ENT_PARSED) == 0) && (ent->children != NULL))
+        ent->flags |= XML_ENT_PARSED;
+
     /*
      * The first reference to the entity trigger a parsing phase
      * where the ent->children is filled with the result from
@@ -7553,7 +7598,7 @@ xmlHandleUndeclaredEntity(xmlParserCtxtPtr ctxt, const xmlChar *name) {
          */
         xmlValidityError(ctxt, XML_ERR_UNDECLARED_ENTITY,
                          "Entity '%s' not defined\n", name, NULL);
-    } else if ((ctxt->loadsubset) ||
+    } else if ((ctxt->loadsubset & ~XML_SKIP_IDS) ||
                ((ctxt->replaceEntities) &&
                 ((ctxt->options & XML_PARSE_NO_XXE) == 0))) {
         /*
@@ -7576,7 +7621,7 @@ xmlHandleUndeclaredEntity(xmlParserCtxtPtr ctxt, const xmlChar *name) {
 
 static xmlEntityPtr
 xmlLookupGeneralEntity(xmlParserCtxtPtr ctxt, const xmlChar *name, int inAttr) {
-    xmlEntityPtr ent;
+    xmlEntityPtr ent = NULL;
 
     /*
      * Predefined entities override any extra definition
@@ -7844,20 +7889,12 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
                 return;
             }
 
-            if (ctxt->input_id >= INT_MAX) {
-                xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,
-                            "Input ID overflow\n");
-                return;
-            }
-
 	    input = xmlNewEntityInputStream(ctxt, entity);
 	    if (xmlPushInput(ctxt, input) < 0) {
                 xmlFreeInputStream(input);
 		return;
             }
 
-            input->id = ++ctxt->input_id;
-
             entity->flags |= XML_ENT_EXPANDING;
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
@@ -7931,7 +7968,10 @@ xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 
     xmlBufResetInput(input->buf->buffer, input);
 
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        goto error;
+    }
 
     xmlDetectEncoding(ctxt);
 
@@ -7965,13 +8005,17 @@ xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
     }
 
     length = xmlBufUse(input->buf->buffer);
-    content = xmlBufDetach(input->buf->buffer);
-
     if (length > INT_MAX) {
         xmlErrMemory(ctxt);
         goto error;
     }
 
+    content = xmlStrndup(xmlBufContent(input->buf->buffer), length);
+    if (content == NULL) {
+        xmlErrMemory(ctxt);
+        goto error;
+    }
+
     for (i = 0; i < length; ) {
         int clen = length - i;
         int c = xmlGetUTF8Char(content + i, &clen);
@@ -8546,7 +8590,6 @@ xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {
 
     namePop(ctxt);
     spacePop(ctxt);
-    return;
 }
 
 /**
@@ -9333,8 +9376,8 @@ next_attr:
 	if (defaults != NULL) {
 	    for (i = 0; i < defaults->nbAttrs; i++) {
                 xmlDefAttr *attr = &defaults->attrs[i];
-                const xmlChar *nsuri;
-                unsigned hashValue, uriHashValue;
+                const xmlChar *nsuri = NULL;
+                unsigned hashValue, uriHashValue = 0;
                 int res;
 
 	        attname = attr->name.name;
@@ -9575,20 +9618,20 @@ xmlParseCDSect(xmlParserCtxtPtr ctxt) {
         return;
     SKIP(6);
 
-    r = CUR_CHAR(rl);
+    r = xmlCurrentCharRecover(ctxt, &rl);
     if (!IS_CHAR(r)) {
 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
         goto out;
     }
     NEXTL(rl);
-    s = CUR_CHAR(sl);
+    s = xmlCurrentCharRecover(ctxt, &sl);
     if (!IS_CHAR(s)) {
 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
         goto out;
     }
     NEXTL(sl);
-    cur = CUR_CHAR(l);
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    cur = xmlCurrentCharRecover(ctxt, &l);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
 	xmlErrMemory(ctxt);
         goto out;
@@ -9617,7 +9660,7 @@ xmlParseCDSect(xmlParserCtxtPtr ctxt) {
 	s = cur;
 	sl = l;
 	NEXTL(l);
-	cur = CUR_CHAR(l);
+	cur = xmlCurrentCharRecover(ctxt, &l);
     }
     buf[len] = 0;
     if (cur != '>') {
@@ -9752,7 +9795,7 @@ xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
  *
  * Parse XML element content. This is useful if you're only interested
  * in custom SAX callbacks. If you want a node list, use
- * xmlParseInNodeContext.
+ * xmlCtxtParseContent.
  */
 void
 xmlParseContent(xmlParserCtxtPtr ctxt) {
@@ -9993,7 +10036,7 @@ xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
     int size = 10;
     xmlChar cur;
 
-    buf = (xmlChar *) xmlMallocAtomic(size);
+    buf = xmlMalloc(size);
     if (buf == NULL) {
 	xmlErrMemory(ctxt);
 	return(NULL);
@@ -10108,7 +10151,7 @@ xmlParseEncName(xmlParserCtxtPtr ctxt) {
     cur = CUR;
     if (((cur >= 'a') && (cur <= 'z')) ||
         ((cur >= 'A') && (cur <= 'Z'))) {
-	buf = (xmlChar *) xmlMallocAtomic(size);
+	buf = xmlMalloc(size);
 	if (buf == NULL) {
 	    xmlErrMemory(ctxt);
 	    return(NULL);
@@ -10414,6 +10457,38 @@ xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
     }
 }
 
+/**
+ * xmlCtxtGetVersion:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the version from the XML declaration.
+ */
+const xmlChar *
+xmlCtxtGetVersion(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(NULL);
+
+    return(ctxt->version);
+}
+
+/**
+ * xmlCtxtGetStandalone:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the value from the standalone document declaration.
+ */
+int
+xmlCtxtGetStandalone(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(0);
+
+    return(ctxt->standalone);
+}
+
 /**
  * xmlParseMisc:
  * @ctxt:  an XML parser context
@@ -10496,12 +10571,9 @@ xmlParseDocument(xmlParserCtxtPtr ctxt) {
      */
     xmlCtxtInitializeLate(ctxt);
 
-    /*
-     * Document locator is unused. Only for backward compatibility.
-     */
     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {
-        xmlSAXLocator copy = xmlDefaultSAXLocator;
-        ctxt->sax->setDocumentLocator(ctxt->userData, &copy);
+        ctxt->sax->setDocumentLocator(ctxt->userData,
+                (xmlSAXLocator *) &xmlDefaultSAXLocator);
     }
 
     xmlDetectEncoding(ctxt);
@@ -10626,12 +10698,9 @@ xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {
 
     xmlCtxtInitializeLate(ctxt);
 
-    /*
-     * Document locator is unused. Only for backward compatibility.
-     */
     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {
-        xmlSAXLocator copy = xmlDefaultSAXLocator;
-        ctxt->sax->setDocumentLocator(ctxt->userData, &copy);
+        ctxt->sax->setDocumentLocator(ctxt->userData,
+                (xmlSAXLocator *) &xmlDefaultSAXLocator);
     }
 
     xmlDetectEncoding(ctxt);
@@ -10944,74 +11013,6 @@ xmlParseLookupInternalSubset(xmlParserCtxtPtr ctxt) {
     return(0);
 }
 
-/**
- * xmlCheckCdataPush:
- * @cur: pointer to the block of characters
- * @len: length of the block in bytes
- * @complete: 1 if complete CDATA block is passed in, 0 if partial block
- *
- * Check that the block of characters is okay as SCdata content [20]
- *
- * Returns the number of bytes to pass if okay, a negative index where an
- *         UTF-8 error occurred otherwise
- */
-static int
-xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
-    int ix;
-    unsigned char c;
-    int codepoint;
-
-    if ((utf == NULL) || (len <= 0))
-        return(0);
-
-    for (ix = 0; ix < len;) {      /* string is 0-terminated */
-        c = utf[ix];
-        if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */
-	    if (c >= 0x20)
-		ix++;
-	    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))
-	        ix++;
-	    else
-	        return(-ix);
-	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */
-	    if (ix + 2 > len) return(complete ? -ix : ix);
-	    if ((utf[ix+1] & 0xc0 ) != 0x80)
-	        return(-ix);
-	    codepoint = (utf[ix] & 0x1f) << 6;
-	    codepoint |= utf[ix+1] & 0x3f;
-	    if (!xmlIsCharQ(codepoint))
-	        return(-ix);
-	    ix += 2;
-	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */
-	    if (ix + 3 > len) return(complete ? -ix : ix);
-	    if (((utf[ix+1] & 0xc0) != 0x80) ||
-	        ((utf[ix+2] & 0xc0) != 0x80))
-		    return(-ix);
-	    codepoint = (utf[ix] & 0xf) << 12;
-	    codepoint |= (utf[ix+1] & 0x3f) << 6;
-	    codepoint |= utf[ix+2] & 0x3f;
-	    if (!xmlIsCharQ(codepoint))
-	        return(-ix);
-	    ix += 3;
-	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */
-	    if (ix + 4 > len) return(complete ? -ix : ix);
-	    if (((utf[ix+1] & 0xc0) != 0x80) ||
-	        ((utf[ix+2] & 0xc0) != 0x80) ||
-		((utf[ix+3] & 0xc0) != 0x80))
-		    return(-ix);
-	    codepoint = (utf[ix] & 0x7) << 18;
-	    codepoint |= (utf[ix+1] & 0x3f) << 12;
-	    codepoint |= (utf[ix+2] & 0x3f) << 6;
-	    codepoint |= utf[ix+3] & 0x3f;
-	    if (!xmlIsCharQ(codepoint))
-	        return(-ix);
-	    ix += 4;
-	} else				/* unknown encoding */
-	    return(-ix);
-      }
-      return(ix);
-}
-
 /**
  * xmlParseTryOrFinish:
  * @ctxt:  an XML parser context
@@ -11095,8 +11096,8 @@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
 		    }
 		}
                 if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {
-                    xmlSAXLocator copy = xmlDefaultSAXLocator;
-                    ctxt->sax->setDocumentLocator(ctxt->userData, &copy);
+                    ctxt->sax->setDocumentLocator(ctxt->userData,
+                            (xmlSAXLocator *) &xmlDefaultSAXLocator);
                 }
                 if ((ctxt->sax) && (ctxt->sax->startDocument) &&
                     (!ctxt->disableSAX))
@@ -11239,8 +11240,12 @@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
                                 (ctxt->input->cur[6] == 'T') &&
                                 (ctxt->input->cur[7] == 'A') &&
                                 (ctxt->input->cur[8] == '[')) {
-                                SKIP(9);
+                                if ((!terminate) &&
+                                    (!xmlParseLookupString(ctxt, 9, "]]>", 3)))
+                                    goto done;
                                 ctxt->instate = XML_PARSER_CDATA_SECTION;
+                                xmlParseCDSect(ctxt);
+                                ctxt->instate = XML_PARSER_CONTENT;
                                 break;
                             }
                         }
@@ -11292,89 +11297,6 @@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
 		    ctxt->instate = XML_PARSER_CONTENT;
 		}
 		break;
-            case XML_PARSER_CDATA_SECTION: {
-	        /*
-		 * The Push mode need to have the SAX callback for
-		 * cdataBlock merge back contiguous callbacks.
-		 */
-		const xmlChar *term;
-
-                if (terminate) {
-                    /*
-                     * Don't call xmlParseLookupString. If 'terminate'
-                     * is set, checkIndex is invalid.
-                     */
-                    term = BAD_CAST strstr((const char *) ctxt->input->cur,
-                                           "]]>");
-                } else {
-		    term = xmlParseLookupString(ctxt, 0, "]]>", 3);
-                }
-
-		if (term == NULL) {
-		    int tmp, size;
-
-                    if (terminate) {
-                        /* Unfinished CDATA section */
-                        size = ctxt->input->end - ctxt->input->cur;
-                    } else {
-                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)
-                            goto done;
-                        ctxt->checkIndex = 0;
-                        /* XXX: Why don't we pass the full buffer? */
-                        size = XML_PARSER_BIG_BUFFER_SIZE;
-                    }
-                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);
-                    if (tmp <= 0) {
-                        tmp = -tmp;
-                        ctxt->input->cur += tmp;
-                        goto encoding_error;
-                    }
-                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
-                        if (ctxt->sax->cdataBlock != NULL)
-                            ctxt->sax->cdataBlock(ctxt->userData,
-                                                  ctxt->input->cur, tmp);
-                        else if (ctxt->sax->characters != NULL)
-                            ctxt->sax->characters(ctxt->userData,
-                                                  ctxt->input->cur, tmp);
-                    }
-                    SKIPL(tmp);
-		} else {
-                    int base = term - CUR_PTR;
-		    int tmp;
-
-		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);
-		    if ((tmp < 0) || (tmp != base)) {
-			tmp = -tmp;
-			ctxt->input->cur += tmp;
-			goto encoding_error;
-		    }
-		    if ((ctxt->sax != NULL) && (base == 0) &&
-		        (ctxt->sax->cdataBlock != NULL) &&
-		        (!ctxt->disableSAX)) {
-			/*
-			 * Special case to provide identical behaviour
-			 * between pull and push parsers on enpty CDATA
-			 * sections
-			 */
-			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&
-			     (!strncmp((const char *)&ctxt->input->cur[-9],
-			               "<![CDATA[", 9)))
-			     ctxt->sax->cdataBlock(ctxt->userData,
-			                           BAD_CAST "", 0);
-		    } else if ((ctxt->sax != NULL) && (base > 0) &&
-			(!ctxt->disableSAX)) {
-			if (ctxt->sax->cdataBlock != NULL)
-			    ctxt->sax->cdataBlock(ctxt->userData,
-						  ctxt->input->cur, base);
-			else if (ctxt->sax->characters != NULL)
-			    ctxt->sax->characters(ctxt->userData,
-						  ctxt->input->cur, base);
-		    }
-		    SKIPL(base + 3);
-		    ctxt->instate = XML_PARSER_CONTENT;
-		}
-		break;
-	    }
             case XML_PARSER_MISC:
             case XML_PARSER_PROLOG:
             case XML_PARSER_EPILOG:
@@ -11477,13 +11399,6 @@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
     }
 done:
     return(ret);
-encoding_error:
-    /* Only report the first error */
-    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
-        xmlCtxtErrIO(ctxt, XML_ERR_INVALID_ENCODING, NULL);
-        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
-    }
-    return(0);
 }
 
 /**
@@ -11513,14 +11428,18 @@ xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
               int terminate) {
     size_t curBase;
     size_t maxLength;
+    size_t pos;
     int end_in_lf = 0;
+    int res;
 
     if ((ctxt == NULL) || (size < 0))
         return(XML_ERR_ARGUMENT);
+    if ((chunk == NULL) && (size > 0))
+        return(XML_ERR_ARGUMENT);
+    if ((ctxt->input == NULL) || (ctxt->input->buf == NULL))
+        return(XML_ERR_ARGUMENT);
     if (ctxt->disableSAX != 0)
         return(ctxt->errNo);
-    if (ctxt->input == NULL)
-        return(XML_ERR_INTERNAL_ERROR);
 
     ctxt->input->flags |= XML_INPUT_PROGRESSIVE;
     if (ctxt->instate == XML_PARSER_START)
@@ -11531,18 +11450,17 @@ xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
 	size--;
     }
 
-    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
-        (ctxt->input->buf != NULL))  {
-	size_t pos = ctxt->input->cur - ctxt->input->base;
-	int res;
-
-	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
-        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
-	if (res < 0) {
-            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);
-	    xmlHaltParser(ctxt);
-	    return(ctxt->errNo);
-	}
+    /*
+     * Also push an empty chunk to make sure that the raw buffer
+     * will be flushed if there is an encoder.
+     */
+    pos = ctxt->input->cur - ctxt->input->base;
+    res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
+    xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
+    if (res < 0) {
+        xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);
+        xmlHaltParser(ctxt);
+        return(ctxt->errNo);
     }
 
     xmlParseTryOrFinish(ctxt, terminate);
@@ -11557,14 +11475,11 @@ xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
         xmlHaltParser(ctxt);
     }
 
-    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
+    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX != 0))
         return(ctxt->errNo);
 
-    if ((end_in_lf == 1) && (ctxt->input != NULL) &&
-        (ctxt->input->buf != NULL)) {
-	size_t pos = ctxt->input->cur - ctxt->input->base;
-        int res;
-
+    if (end_in_lf == 1) {
+	pos = ctxt->input->cur - ctxt->input->base;
 	res = xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
 	xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
         if (res < 0) {
@@ -11591,8 +11506,7 @@ xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
                 xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
                                "Start tag expected, '<' not found\n");
             }
-        } else if ((ctxt->input->buf != NULL) &&
-                   (ctxt->input->buf->encoder != NULL) &&
+        } else if ((ctxt->input->buf->encoder != NULL) &&
                    (ctxt->input->buf->error == 0) &&
                    (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
             xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
@@ -11648,12 +11562,16 @@ xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
     ctxt->options &= ~XML_PARSE_NODICT;
     ctxt->dictNames = 1;
 
-    input = xmlInputCreatePush(filename, chunk, size);
+    input = xmlNewPushInput(filename, chunk, size);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -11702,12 +11620,17 @@ xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
 	return(NULL);
 
     encoding = xmlGetCharEncodingName(enc);
-    input = xmlNewInputIO(ctxt, NULL, ioread, ioclose, ioctx, encoding, 0);
+    input = xmlCtxtNewInputFromIO(ctxt, NULL, ioread, ioclose, ioctx,
+                                  encoding, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
         return (NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -11762,6 +11685,7 @@ xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input,
      * plug some encoding conversion routines here.
      */
     if (xmlPushInput(ctxt, pinput) < 0) {
+        xmlFreeInputStream(pinput);
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
@@ -11863,6 +11787,7 @@ xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID,
      * plug some encoding conversion routines here.
      */
     if (xmlPushInput(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
 	xmlFreeParserCtxt(ctxt);
 	if (systemIdCanonic != NULL)
 	    xmlFree(systemIdCanonic);
@@ -11944,8 +11869,8 @@ xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {
  ************************************************************************/
 
 static xmlNodePtr
-xmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
-                    int hasTextDecl, int buildTree) {
+xmlCtxtParseContentInternal(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
+                            int hasTextDecl, int buildTree) {
     xmlNodePtr root = NULL;
     xmlNodePtr list = NULL;
     xmlChar *rootName = BAD_CAST "#root";
@@ -12000,17 +11925,13 @@ xmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
             xmlNodePtr cur;
 
             /*
-             * Return the newly created nodeset after unlinking it from
-             * its pseudo parent.
+             * Unlink newly created node list.
              */
-            cur = root->children;
-            list = cur;
-            while (cur != NULL) {
-                cur->parent = NULL;
-                cur = cur->next;
-            }
+            list = root->children;
             root->children = NULL;
             root->last = NULL;
+            for (cur = list; cur != NULL; cur = cur->next)
+                cur->parent = NULL;
         }
     }
 
@@ -12087,7 +12008,7 @@ xmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {
      *
      * This initiates a recursive call chain:
      *
-     * - xmlCtxtParseContent
+     * - xmlCtxtParseContentInternal
      * - xmlParseContentInternal
      * - xmlParseReference
      * - xmlCtxtParseEntity
@@ -12101,7 +12022,7 @@ xmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {
 
     ent->flags |= XML_ENT_EXPANDING;
 
-    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);
+    list = xmlCtxtParseContentInternal(ctxt, input, isExternal, buildTree);
 
     ent->flags &= ~XML_ENT_EXPANDING;
 
@@ -12176,7 +12097,7 @@ xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctxt, const xmlChar *URL,
 
     xmlCtxtInitializeLate(ctxt);
 
-    list = xmlCtxtParseContent(ctxt, input, /* hasTextDecl */ 1, 1);
+    list = xmlCtxtParseContentInternal(ctxt, input, /* hasTextDecl */ 1, 1);
     if (listOut != NULL)
         *listOut = list;
     else
@@ -12262,203 +12183,231 @@ xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax,
 #endif /* LIBXML_SAX1_ENABLED */
 
 /**
- * xmlParseInNodeContext:
- * @node:  the context node
- * @data:  the input string
- * @datalen:  the input string length in bytes
- * @options:  a combination of xmlParserOption
- * @lst:  the return value for the set of parsed nodes
+ * xmlCtxtParseContent:
+ * @ctxt:  parser context
+ * @input:  parser input
+ * @node:  target node or document
+ * @hasTextDecl:  whether to parse text declaration
  *
- * Parse a well-balanced chunk of an XML document
- * within the context (DTD, namespaces, etc ...) of the given node.
+ * Parse a well-balanced chunk of XML matching the 'content' production.
  *
- * The allowed sequence for the data is a Well Balanced Chunk defined by
- * the content production in the XML grammar:
+ * Namespaces in scope of @node and entities of @node's document are
+ * recognized. When validating, the DTD of @node's document is used.
  *
- * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
+ * Always consumes @input even in error case.
  *
- * Returns XML_ERR_OK if the chunk is well balanced, and the parser
- * error code otherwise
+ * Available since 2.14.0.
+ *
+ * Returns a node list or NULL in case of error.
  */
-xmlParserErrors
-xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen,
-                      int options, xmlNodePtr *lst) {
-    xmlParserCtxtPtr ctxt;
-    xmlDocPtr doc = NULL;
-    xmlNodePtr fake, cur;
+xmlNodePtr
+xmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
+                    xmlNodePtr node, int hasTextDecl) {
+    xmlDocPtr doc;
+    xmlNodePtr cur, list = NULL;
     int nsnr = 0;
+    xmlDictPtr oldDict;
+    int oldOptions, oldDictNames, oldLoadSubset;
 
-    xmlParserErrors ret = XML_ERR_OK;
+    if ((ctxt == NULL) || (input == NULL) || (node == NULL)) {
+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);
+        goto exit;
+    }
+
+    doc = node->doc;
+    if (doc == NULL) {
+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);
+        goto exit;
+    }
 
-    /*
-     * check all input parameters, grab the document
-     */
-    if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen < 0))
-        return(XML_ERR_ARGUMENT);
     switch (node->type) {
         case XML_ELEMENT_NODE:
+        case XML_DOCUMENT_NODE:
+        case XML_HTML_DOCUMENT_NODE:
+            break;
+
         case XML_ATTRIBUTE_NODE:
         case XML_TEXT_NODE:
         case XML_CDATA_SECTION_NODE:
         case XML_ENTITY_REF_NODE:
         case XML_PI_NODE:
         case XML_COMMENT_NODE:
-        case XML_DOCUMENT_NODE:
-        case XML_HTML_DOCUMENT_NODE:
-	    break;
-	default:
-	    return(XML_ERR_INTERNAL_ERROR);
-
-    }
-    while ((node != NULL) && (node->type != XML_ELEMENT_NODE) &&
-           (node->type != XML_DOCUMENT_NODE) &&
-	   (node->type != XML_HTML_DOCUMENT_NODE))
-	node = node->parent;
-    if (node == NULL)
-	return(XML_ERR_INTERNAL_ERROR);
-    if (node->type == XML_ELEMENT_NODE)
-	doc = node->doc;
-    else
-        doc = (xmlDocPtr) node;
-    if (doc == NULL)
-	return(XML_ERR_INTERNAL_ERROR);
+            for (cur = node->parent; cur != NULL; cur = node->parent) {
+                if ((cur->type == XML_ELEMENT_NODE) ||
+                    (cur->type == XML_DOCUMENT_NODE) ||
+                    (cur->type == XML_HTML_DOCUMENT_NODE)) {
+                    node = cur;
+                    break;
+                }
+            }
+            break;
 
-    /*
-     * allocate a context and set-up everything not related to the
-     * node position in the tree
-     */
-    if (doc->type == XML_DOCUMENT_NODE)
-	ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);
-#ifdef LIBXML_HTML_ENABLED
-    else if (doc->type == XML_HTML_DOCUMENT_NODE) {
-	ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);
-        /*
-         * When parsing in context, it makes no sense to add implied
-         * elements like html/body/etc...
-         */
-        options |= HTML_PARSE_NOIMPLIED;
+        default:
+            xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);
+            goto exit;
     }
-#endif
+
+#ifdef LIBXML_HTML_ENABLED
+    if (ctxt->html)
+        htmlCtxtReset(ctxt);
     else
-        return(XML_ERR_INTERNAL_ERROR);
+#endif
+        xmlCtxtReset(ctxt);
 
-    if (ctxt == NULL)
-        return(XML_ERR_NO_MEMORY);
+    oldDict = ctxt->dict;
+    oldOptions = ctxt->options;
+    oldDictNames = ctxt->dictNames;
+    oldLoadSubset = ctxt->loadsubset;
 
     /*
      * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.
-     * We need a dictionary for xmlCtxtInitializeLate, so if there's no doc dict
-     * we must wait until the last moment to free the original one.
      */
     if (doc->dict != NULL) {
-        if (ctxt->dict != NULL)
-	    xmlDictFree(ctxt->dict);
-	ctxt->dict = doc->dict;
+        ctxt->dict = doc->dict;
     } else {
-        options |= XML_PARSE_NODICT;
+        ctxt->options |= XML_PARSE_NODICT;
         ctxt->dictNames = 0;
     }
 
-    if (doc->encoding != NULL)
-        xmlSwitchEncodingName(ctxt, (const char *) doc->encoding);
+    /*
+     * Disable IDs
+     */
+    ctxt->loadsubset |= XML_SKIP_IDS;
 
-    xmlCtxtUseOptions(ctxt, options);
-    xmlCtxtInitializeLate(ctxt);
     ctxt->myDoc = doc;
-    /* parsing in context, i.e. as within existing content */
-    ctxt->input_id = 2;
 
-    /*
-     * TODO: Use xmlCtxtParseContent
-     */
+#ifdef LIBXML_HTML_ENABLED
+    if (ctxt->html) {
+        /*
+         * When parsing in context, it makes no sense to add implied
+         * elements like html/body/etc...
+         */
+        ctxt->options |= HTML_PARSE_NOIMPLIED;
 
-    fake = xmlNewDocComment(node->doc, NULL);
-    if (fake == NULL) {
-        xmlFreeParserCtxt(ctxt);
-	return(XML_ERR_NO_MEMORY);
-    }
-    xmlAddChild(node, fake);
+        list = htmlCtxtParseContentInternal(ctxt, input);
+    } else
+#endif
+    {
+        xmlCtxtInitializeLate(ctxt);
 
-    if (node->type == XML_ELEMENT_NODE)
-	nodePush(ctxt, node);
+        /*
+         * This hack lowers the error level of undeclared entities
+         * from XML_ERR_FATAL (well-formedness error) to XML_ERR_ERROR
+         * or XML_ERR_WARNING.
+         */
+        ctxt->hasExternalSubset = 1;
 
-    if ((ctxt->html == 0) && (node->type == XML_ELEMENT_NODE)) {
-	/*
-	 * initialize the SAX2 namespaces stack
-	 */
-	cur = node;
-	while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {
-	    xmlNsPtr ns = cur->nsDef;
+        /*
+         * initialize the SAX2 namespaces stack
+         */
+        cur = node;
+        while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {
+            xmlNsPtr ns = cur->nsDef;
             xmlHashedString hprefix, huri;
 
-	    while (ns != NULL) {
+            while (ns != NULL) {
                 hprefix = xmlDictLookupHashed(ctxt->dict, ns->prefix, -1);
                 huri = xmlDictLookupHashed(ctxt->dict, ns->href, -1);
                 if (xmlParserNsPush(ctxt, &hprefix, &huri, ns, 1) > 0)
                     nsnr++;
-		ns = ns->next;
-	    }
-	    cur = cur->parent;
-	}
-    }
+                ns = ns->next;
+            }
+            cur = cur->parent;
+        }
 
-    if ((ctxt->validate) || (ctxt->replaceEntities != 0)) {
-	/*
-	 * ID/IDREF registration will be done in xmlValidateElement below
-	 */
-	ctxt->loadsubset |= XML_SKIP_IDS;
+        list = xmlCtxtParseContentInternal(ctxt, input, hasTextDecl, 1);
+
+        if (nsnr > 0)
+            xmlParserNsPop(ctxt, nsnr);
     }
 
-#ifdef LIBXML_HTML_ENABLED
-    if (doc->type == XML_HTML_DOCUMENT_NODE)
-        __htmlParseContent(ctxt);
-    else
-#endif
-	xmlParseContentInternal(ctxt);
+    ctxt->dict = oldDict;
+    ctxt->options = oldOptions;
+    ctxt->dictNames = oldDictNames;
+    ctxt->loadsubset = oldLoadSubset;
+    ctxt->myDoc = NULL;
+    ctxt->node = NULL;
 
-    if (ctxt->input->cur < ctxt->input->end)
-	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
+exit:
+    xmlFreeInputStream(input);
+    return(list);
+}
 
-    xmlParserNsPop(ctxt, nsnr);
+/**
+ * xmlParseInNodeContext:
+ * @node:  the context node
+ * @data:  the input string
+ * @datalen:  the input string length in bytes
+ * @options:  a combination of xmlParserOption
+ * @listOut:  the return value for the set of parsed nodes
+ *
+ * Parse a well-balanced chunk of an XML document
+ * within the context (DTD, namespaces, etc ...) of the given node.
+ *
+ * The allowed sequence for the data is a Well Balanced Chunk defined by
+ * the content production in the XML grammar:
+ *
+ * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
+ *
+ * This function assumes the encoding of @node's document which is
+ * typically not what you want. A better alternative is
+ * xmlCtxtParseContent.
+ *
+ * Returns XML_ERR_OK if the chunk is well balanced, and the parser
+ * error code otherwise
+ */
+xmlParserErrors
+xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen,
+                      int options, xmlNodePtr *listOut) {
+    xmlParserCtxtPtr ctxt;
+    xmlParserInputPtr input;
+    xmlDocPtr doc;
+    xmlNodePtr list;
+    xmlParserErrors ret;
 
-    if ((ctxt->wellFormed) ||
-        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {
-        ret = XML_ERR_OK;
-    } else {
-	ret = (xmlParserErrors) ctxt->errNo;
-    }
+    if (listOut == NULL)
+        return(XML_ERR_INTERNAL_ERROR);
+    *listOut = NULL;
 
-    /*
-     * Return the newly created nodeset after unlinking it from
-     * the pseudo sibling.
-     */
+    if ((node == NULL) || (data == NULL) || (datalen < 0))
+        return(XML_ERR_INTERNAL_ERROR);
 
-    cur = fake->next;
-    fake->next = NULL;
-    node->last = fake;
+    doc = node->doc;
+    if (doc == NULL)
+        return(XML_ERR_INTERNAL_ERROR);
 
-    if (cur != NULL) {
-	cur->prev = NULL;
+#ifdef LIBXML_HTML_ENABLED
+    if (doc->type == XML_HTML_DOCUMENT_NODE) {
+        ctxt = htmlNewParserCtxt();
     }
+    else
+#endif
+        ctxt = xmlNewParserCtxt();
 
-    *lst = cur;
+    if (ctxt == NULL)
+        return(XML_ERR_NO_MEMORY);
 
-    while (cur != NULL) {
-	cur->parent = NULL;
-	cur = cur->next;
+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, data, datalen,
+                                      (const char *) doc->encoding,
+                                      XML_INPUT_BUF_STATIC);
+    if (input == NULL) {
+        xmlFreeParserCtxt(ctxt);
+        return(XML_ERR_NO_MEMORY);
     }
 
-    xmlUnlinkNode(fake);
-    xmlFreeNode(fake);
+    xmlCtxtUseOptions(ctxt, options);
 
+    list = xmlCtxtParseContent(ctxt, input, node, /* hasTextDecl */ 0);
 
-    if (ret != XML_ERR_OK) {
-        xmlFreeNodeList(*lst);
-	*lst = NULL;
+    if (list == NULL) {
+        ret = ctxt->errNo;
+        if (ret == XML_ERR_ARGUMENT)
+            ret = XML_ERR_INTERNAL_ERROR;
+    } else {
+        ret = XML_ERR_OK;
+        *listOut = list;
     }
 
-    if (doc->dict != NULL)
-        ctxt->dict = NULL;
     xmlFreeParserCtxt(ctxt);
 
     return(ret);
@@ -12518,17 +12467,23 @@ xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
     }
 
     input = xmlNewStringInputStream(ctxt, string);
-    if (input == NULL)
-        return(ctxt->errNo);
+    if (input == NULL) {
+        ret = ctxt->errNo;
+        goto error;
+    }
 
-    list = xmlCtxtParseContent(ctxt, input, /* hasTextDecl */ 0, 1);
+    list = xmlCtxtParseContentInternal(ctxt, input, /* hasTextDecl */ 0, 1);
     if (listOut != NULL)
         *listOut = list;
     else
         xmlFreeNodeList(list);
 
-    ret = ctxt->errNo;
+    if (!ctxt->wellFormed)
+        ret = ctxt->errNo;
+    else
+        ret = XML_ERR_OK;
 
+error:
     xmlFreeInputStream(input);
     xmlFreeParserCtxt(ctxt);
     return(ret);
@@ -12641,8 +12596,10 @@ xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID,
     if (input == NULL)
         goto error;
 
-    if (inputPush(ctxt, input) < 0)
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
         goto error;
+    }
 
     xmlFree(uri);
     return(ctxt);
@@ -12690,7 +12647,11 @@ xmlCreateURLParserCtxt(const char *filename, int options)
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -12754,7 +12715,10 @@ xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename,
         ctxt->recovery = 1;
     }
 
-    input = xmlNewInputURL(ctxt, filename, NULL, NULL, 0);
+    if ((filename != NULL) && (filename[0] == '-') && (filename[1] == 0))
+        input = xmlCtxtNewInputFromFd(ctxt, filename, STDIN_FILENO, NULL, 0);
+    else
+        input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, NULL, 0);
 
     ret = xmlCtxtParseDocument(ctxt, input);
 
@@ -12864,10 +12828,12 @@ xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar* buffer,
 
     xmlClearParserCtxt(ctxt);
 
-    input = xmlNewInputString(ctxt, filename, (const char *) buffer, NULL, 0);
+    input = xmlCtxtNewInputFromString(ctxt, filename, (const char *) buffer,
+                                      NULL, 0);
     if (input == NULL)
         return;
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0)
+        xmlFreeInputStream(input);
 }
 
 /**
@@ -12949,12 +12915,16 @@ xmlCreateMemoryParserCtxt(const char *buffer, int size) {
     if (ctxt == NULL)
 	return(NULL);
 
-    input = xmlNewInputMemory(ctxt, NULL, buffer, size, NULL, 0);
+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, buffer, size, NULL, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -13003,8 +12973,8 @@ xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,
         ctxt->recovery = 1;
     }
 
-    input = xmlNewInputMemory(ctxt, NULL, buffer, size, NULL,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, buffer, size, NULL,
+                                      XML_INPUT_BUF_STATIC);
 
     ret = xmlCtxtParseDocument(ctxt, input);
 
@@ -13135,12 +13105,16 @@ xmlCreateDocParserCtxt(const xmlChar *str) {
     if (ctxt == NULL)
 	return(NULL);
 
-    input = xmlNewInputString(ctxt, NULL, (const char *) str, NULL, 0);
+    input = xmlCtxtNewInputFromString(ctxt, NULL, (const char *) str, NULL, 0);
     if (input == NULL) {
 	xmlFreeParserCtxt(ctxt);
 	return(NULL);
     }
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        xmlFreeParserCtxt(ctxt);
+        return(NULL);
+    }
 
     return(ctxt);
 }
@@ -13277,6 +13251,12 @@ xmlCtxtReset(xmlParserCtxtPtr ctxt)
     ctxt->extSubURI = NULL;
     DICT_FREE(ctxt->extSubSystem);
     ctxt->extSubSystem = NULL;
+
+    if (ctxt->directory != NULL) {
+        xmlFree(ctxt->directory);
+        ctxt->directory = NULL;
+    }
+
     if (ctxt->myDoc != NULL)
         xmlFreeDoc(ctxt->myDoc);
     ctxt->myDoc = NULL;
@@ -13291,11 +13271,6 @@ xmlCtxtReset(xmlParserCtxtPtr ctxt)
     ctxt->nsWellFormed = 1;
     ctxt->disableSAX = 0;
     ctxt->valid = 1;
-#if 0
-    ctxt->vctxt.userData = ctxt;
-    ctxt->vctxt.error = xmlParserValidityError;
-    ctxt->vctxt.warning = xmlParserValidityWarning;
-#endif
     ctxt->record_info = 0;
     ctxt->checkIndex = 0;
     ctxt->endCheckState = 0;
@@ -13349,11 +13324,14 @@ xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk,
 
     xmlCtxtReset(ctxt);
 
-    input = xmlInputCreatePush(filename, chunk, size);
+    input = xmlNewPushInput(filename, chunk, size);
     if (input == NULL)
         return(1);
 
-    inputPush(ctxt, input);
+    if (inputPush(ctxt, input) < 0) {
+        xmlFreeInputStream(input);
+        return(1);
+    }
 
     if (encoding != NULL)
         xmlSwitchEncodingName(ctxt, encoding);
@@ -13496,6 +13474,8 @@ xmlCtxtSetOptionsInternal(xmlParserCtxtPtr ctxt, int options, int keepMask)
  *
  * Disables loading of external DTDs or entities.
  *
+ * Available since 2.13.0.
+ *
  * XML_PARSE_NOERROR
  *
  * Disable error and warning reports to the error handlers.
@@ -13598,6 +13578,18 @@ xmlCtxtSetOptionsInternal(xmlParserCtxtPtr ctxt, int options, int keepMask)
  *
  * Available since 2.14.0.
  *
+ * XML_PARSE_NO_SYS_CATALOG
+ *
+ * Disables the global system XML catalog.
+ *
+ * Available since 2.14.0.
+ *
+ * XML_PARSE_NO_CATALOG_PI
+ *
+ * Ignore XML catalog processing instructions.
+ *
+ * Available since 2.14.0.
+ *
  * Returns 0 in case of success, the set of unknown or unimplemented options
  *         in case of error.
  */
@@ -13607,6 +13599,25 @@ xmlCtxtSetOptions(xmlParserCtxtPtr ctxt, int options)
     return(xmlCtxtSetOptionsInternal(ctxt, options, 0));
 }
 
+/**
+ * xmlCtxtGetOptions:
+ * @ctxt: an XML parser context
+ *
+ * Get the current options of the parser context.
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the current options set in the parser context, or -1 if ctxt is NULL.
+ */
+int
+xmlCtxtGetOptions(xmlParserCtxtPtr ctxt)
+{
+    if (ctxt == NULL)
+        return(-1);
+
+    return(ctxt->options);
+}
+
 /**
  * xmlCtxtUseOptions:
  * @ctxt: an XML parser context
@@ -13752,8 +13763,8 @@ xmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding,
 
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputString(ctxt, URL, (const char *) cur, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) cur, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     doc = xmlCtxtParseDocument(ctxt, input);
 
@@ -13787,7 +13798,16 @@ xmlReadFile(const char *filename, const char *encoding, int options)
 
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);
+    /*
+     * Backward compatibility for users of command line utilities like
+     * xmlstarlet expecting "-" to mean stdin. This is dangerous and
+     * should be removed at some point.
+     */
+    if ((filename != NULL) && (filename[0] == '-') && (filename[1] == 0))
+        input = xmlCtxtNewInputFromFd(ctxt, filename, STDIN_FILENO,
+                                      encoding, 0);
+    else
+        input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);
 
     doc = xmlCtxtParseDocument(ctxt, input);
 
@@ -13827,8 +13847,8 @@ xmlReadMemory(const char *buffer, int size, const char *url,
 
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     doc = xmlCtxtParseDocument(ctxt, input);
 
@@ -13865,7 +13885,7 @@ xmlReadFd(int fd, const char *URL, const char *encoding, int options)
 
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputFd(ctxt, URL, fd, encoding, 0);
+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);
 
     doc = xmlCtxtParseDocument(ctxt, input);
 
@@ -13902,7 +13922,8 @@ xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
 
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);
+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,
+                                  encoding, 0);
 
     doc = xmlCtxtParseDocument(ctxt, input);
 
@@ -13939,8 +13960,8 @@ xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *str,
     xmlCtxtReset(ctxt);
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputString(ctxt, URL, (const char *) str, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) str, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     return(xmlCtxtParseDocument(ctxt, input));
 }
@@ -13969,7 +13990,7 @@ xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename,
     xmlCtxtReset(ctxt);
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);
+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);
 
     return(xmlCtxtParseDocument(ctxt, input));
 }
@@ -14005,8 +14026,8 @@ xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,
     xmlCtxtReset(ctxt);
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputMemory(ctxt, URL, buffer, size, encoding,
-                              XML_INPUT_BUF_STATIC);
+    input = xmlCtxtNewInputFromMemory(ctxt, URL, buffer, size, encoding,
+                                      XML_INPUT_BUF_STATIC);
 
     return(xmlCtxtParseDocument(ctxt, input));
 }
@@ -14043,7 +14064,7 @@ xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd,
     xmlCtxtReset(ctxt);
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputFd(ctxt, URL, fd, encoding, 0);
+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);
 
     return(xmlCtxtParseDocument(ctxt, input));
 }
@@ -14082,7 +14103,8 @@ xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
     xmlCtxtReset(ctxt);
     xmlCtxtUseOptions(ctxt, options);
 
-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);
+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,
+                                  encoding, 0);
 
     return(xmlCtxtParseDocument(ctxt, input));
 }
diff --git a/parserInternals.c b/parserInternals.c
index 6c6c82f8..a6ddf502 100644
--- a/parserInternals.c
+++ b/parserInternals.c
@@ -71,11 +71,11 @@ xmlCheckVersion(int version) {
     xmlInitParser();
 
     if ((myversion / 10000) != (version / 10000)) {
-	fprintf(stderr,
+	xmlPrintErrorMessage(
 		"Fatal: program compiled against libxml %d using libxml %d\n",
 		(version / 10000), (myversion / 10000));
     } else if ((myversion / 100) < (version / 100)) {
-	fprintf(stderr,
+	xmlPrintErrorMessage(
 		"Warning: program compiled against libxml %d using older %d\n",
 		(version / 100), (myversion / 100));
     }
@@ -121,6 +121,46 @@ xmlCtxtSetErrorHandler(xmlParserCtxtPtr ctxt, xmlStructuredErrorFunc handler,
     ctxt->errorCtxt = data;
 }
 
+/**
+ * xmlCtxtGetLastError:
+ * @ctx:  an XML parser context
+ *
+ * Get the last parsing error registered.
+ *
+ * Returns NULL if no error occurred or a pointer to the error
+ */
+const xmlError *
+xmlCtxtGetLastError(void *ctx)
+{
+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
+
+    if (ctxt == NULL)
+        return (NULL);
+    if (ctxt->lastError.code == XML_ERR_OK)
+        return (NULL);
+    return (&ctxt->lastError);
+}
+
+/**
+ * xmlCtxtResetLastError:
+ * @ctx:  an XML parser context
+ *
+ * Cleanup the last global error registered. For parsing error
+ * this does not change the well-formedness result.
+ */
+void
+xmlCtxtResetLastError(void *ctx)
+{
+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
+
+    if (ctxt == NULL)
+        return;
+    ctxt->errNo = XML_ERR_OK;
+    if (ctxt->lastError.code == XML_ERR_OK)
+        return;
+    xmlResetError(&ctxt->lastError);
+}
+
 /**
  * xmlCtxtErrMemory:
  * @ctxt:  an XML parser context
@@ -179,19 +219,20 @@ xmlCtxtErrIO(xmlParserCtxtPtr ctxt, int code, const char *uri)
     if (ctxt == NULL)
         return;
 
-    /*
-     * Don't report a well-formedness error if an external entity could
-     * not be found. We assume that inputNr is zero for the document
-     * entity which is somewhat fragile.
-     */
-    if ((ctxt->inputNr > 0) &&
-        ((code == XML_IO_ENOENT) ||
-         (code == XML_IO_NETWORK_ATTEMPT) ||
+    if (((code == XML_IO_ENOENT) ||
          (code == XML_IO_UNKNOWN))) {
+        /*
+         * Only report a warning if a file could not be found. This should
+         * only be done for external entities, but the external entity loader
+         * of xsltproc can try multiple paths and assumes that ENOENT doesn't
+         * raise an error and aborts parsing.
+         */
         if (ctxt->validate == 0)
             level = XML_ERR_WARNING;
         else
             level = XML_ERR_ERROR;
+    } else if (code == XML_IO_NETWORK_ATTEMPT) {
+        level = XML_ERR_ERROR;
     } else {
         level = XML_ERR_FATAL;
     }
@@ -213,6 +254,36 @@ xmlCtxtErrIO(xmlParserCtxtPtr ctxt, int code, const char *uri)
                msg, str1, str2);
 }
 
+static int
+xmlCtxtIsCatastrophicError(xmlParserCtxtPtr ctxt) {
+    int fatal = 0;
+    int code;
+
+    if (ctxt == NULL)
+        return(1);
+
+    if (ctxt->lastError.level != XML_ERR_FATAL)
+        return(0);
+
+    code = ctxt->lastError.code;
+
+    switch (code) {
+        case XML_ERR_NO_MEMORY:
+        case XML_ERR_RESOURCE_LIMIT:
+        case XML_ERR_SYSTEM:
+        case XML_ERR_ARGUMENT:
+        case XML_ERR_INTERNAL_ERROR:
+            fatal = 1;
+            break;
+        default:
+            if ((code >= 1500) && (code <= 1599))
+                fatal = 1;
+            break;
+    }
+
+    return(fatal);
+}
+
 /**
  * xmlCtxtVErr:
  * @ctxt:  a parser context
@@ -248,16 +319,21 @@ xmlCtxtVErr(xmlParserCtxtPtr ctxt, xmlNodePtr node, xmlErrorDomain domain,
         return;
     }
 
+    if (ctxt == NULL)
+        return;
+
     if (PARSER_STOPPED(ctxt))
 	return;
 
     if (level == XML_ERR_WARNING) {
         if (ctxt->nbWarnings >= XML_MAX_ERRORS)
-            return;
+            goto done;
         ctxt->nbWarnings += 1;
     } else {
-        if (ctxt->nbErrors >= XML_MAX_ERRORS)
-            return;
+        /* Report at least one fatal error. */
+        if ((ctxt->nbErrors >= XML_MAX_ERRORS) &&
+            ((level < XML_ERR_FATAL) || (ctxt->wellFormed == 0)))
+            goto done;
         ctxt->nbErrors += 1;
     }
 
@@ -308,15 +384,17 @@ xmlCtxtVErr(xmlParserCtxtPtr ctxt, xmlNodePtr node, xmlErrorDomain domain,
         return;
     }
 
+done:
     if (level >= XML_ERR_ERROR)
         ctxt->errNo = code;
     if (level == XML_ERR_FATAL) {
         ctxt->wellFormed = 0;
-        if (ctxt->recovery == 0)
+
+        if (xmlCtxtIsCatastrophicError(ctxt))
+            ctxt->disableSAX = 2; /* stop parser */
+        else if (ctxt->recovery == 0)
             ctxt->disableSAX = 1;
     }
-
-    return;
 }
 
 /**
@@ -349,6 +427,42 @@ xmlCtxtErr(xmlParserCtxtPtr ctxt, xmlNodePtr node, xmlErrorDomain domain,
     va_end(ap);
 }
 
+/**
+ * xmlCtxtGetStatus:
+ * @ctxt:  an XML parser context
+ *
+ * Get well-formedness and validation status after parsing. Also
+ * reports catastrophic errors which are not related to parsing
+ * like out-of-memory, I/O or other errors.
+ *
+ * Available since 2.14.0.
+ *
+ * Returns a bitmask of XML_STATUS_* flags ORed together.
+ */
+int
+xmlCtxtGetStatus(xmlParserCtxt *ctxt) {
+    int bits = 0;
+
+    if (xmlCtxtIsCatastrophicError(ctxt)) {
+        bits |= XML_STATUS_CATASTROPHIC_ERROR |
+                XML_STATUS_NOT_WELL_FORMED |
+                XML_STATUS_NOT_NS_WELL_FORMED;
+        if ((ctxt != NULL) && (ctxt->validate))
+            bits |= XML_STATUS_DTD_VALIDATION_FAILED;
+
+        return(bits);
+    }
+
+    if (!ctxt->wellFormed)
+        bits |= XML_STATUS_NOT_WELL_FORMED;
+    if (!ctxt->nsWellFormed)
+        bits |= XML_STATUS_NOT_NS_WELL_FORMED;
+    if ((ctxt->validate) && (!ctxt->valid))
+        bits |= XML_STATUS_DTD_VALIDATION_FAILED;
+
+    return(bits);
+}
+
 /**
  * xmlFatalErr:
  * @ctxt:  an XML parser context
@@ -361,20 +475,14 @@ void
 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors code, const char *info)
 {
     const char *errmsg;
-    xmlErrorLevel level;
-
-    if (code == XML_ERR_UNSUPPORTED_ENCODING)
-        level = XML_ERR_WARNING;
-    else
-        level = XML_ERR_FATAL;
 
     errmsg = xmlErrString(code);
 
     if (info == NULL) {
-        xmlCtxtErr(ctxt, NULL, XML_FROM_PARSER, code, level,
+        xmlCtxtErr(ctxt, NULL, XML_FROM_PARSER, code, XML_ERR_FATAL,
                    NULL, NULL, NULL, 0, "%s\n", errmsg);
     } else {
-        xmlCtxtErr(ctxt, NULL, XML_FROM_PARSER, code, level,
+        xmlCtxtErr(ctxt, NULL, XML_FROM_PARSER, code, XML_ERR_FATAL,
                    (const xmlChar *) info, NULL, NULL, 0,
                    "%s: %s\n", errmsg, info);
     }
@@ -384,6 +492,8 @@ xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors code, const char *info)
  * xmlIsLetter:
  * @c:  an unicode character (int)
  *
+ * DEPRECATED: Internal function, don't use.
+ *
  * Check whether the character is allowed by the production
  * [84] Letter ::= BaseChar | Ideographic
  *
@@ -539,35 +649,27 @@ void
 xmlParserShrink(xmlParserCtxtPtr ctxt) {
     xmlParserInputPtr in = ctxt->input;
     xmlParserInputBufferPtr buf = in->buf;
-    size_t used;
+    size_t used, res;
 
     if (buf == NULL)
         return;
-    /* Don't shrink pull parser memory buffers. */
-    if ((!PARSER_PROGRESSIVE(ctxt)) &&
-        (buf->encoder == NULL) &&
-        (buf->readcallback == NULL))
-        return;
 
     used = in->cur - in->base;
-    /*
-     * Do not shrink on large buffers whose only a tiny fraction
-     * was consumed
-     */
-    if (used > INPUT_CHUNK) {
-	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
 
-	if (res > 0) {
+    if (used > LINE_LEN) {
+        res = xmlBufShrink(buf->buffer, used - LINE_LEN);
+
+        if (res > 0) {
             used -= res;
             if ((res > ULONG_MAX) ||
                 (in->consumed > ULONG_MAX - (unsigned long)res))
                 in->consumed = ULONG_MAX;
             else
                 in->consumed += res;
-	}
-    }
+        }
 
-    xmlBufUpdateInput(buf->buffer, in, used);
+        xmlBufUpdateInput(buf->buffer, in, used);
+    }
 }
 
 /**
@@ -590,11 +692,8 @@ xmlParserInputShrink(xmlParserInputPtr in) {
     if (in->buf->buffer == NULL) return;
 
     used = in->cur - in->base;
-    /*
-     * Do not shrink on large buffers whose only a tiny fraction
-     * was consumed
-     */
-    if (used > INPUT_CHUNK) {
+
+    if (used > LINE_LEN) {
 	ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);
 	if (ret > 0) {
             used -= ret;
@@ -604,22 +703,9 @@ xmlParserInputShrink(xmlParserInputPtr in) {
             else
                 in->consumed += ret;
 	}
-    }
 
-    if (xmlBufUse(in->buf->buffer) <= INPUT_CHUNK) {
-        xmlParserInputBufferRead(in->buf, 2 * INPUT_CHUNK);
+        xmlBufUpdateInput(in->buf->buffer, in, used);
     }
-
-    in->base = xmlBufContent(in->buf->buffer);
-    if (in->base == NULL) {
-        /* TODO: raise error */
-        in->base = BAD_CAST "";
-        in->cur = in->base;
-        in->end = in->base;
-        return;
-    }
-    in->cur = in->base + used;
-    in->end = xmlBufEnd(in->buf->buffer);
 }
 
 /************************************************************************
@@ -722,7 +808,6 @@ encoding_error:
         ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
     }
     ctxt->input->cur++;
-    return;
 }
 
 /**
@@ -858,7 +943,7 @@ encoding_error:
         ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
     }
     *len = 1;
-    return(0xFFFD); /* U+FFFD Replacement Character */
+    return(XML_INVALID_CHAR);
 
 incomplete_sequence:
     /*
@@ -929,8 +1014,7 @@ xmlCopyCharMultiByte(xmlChar *out, int val) {
 	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
 	else {
 #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            fprintf(stderr, "xmlCopyCharMultiByte: codepoint out of range\n");
-            abort();
+            xmlAbort("xmlCopyCharMultiByte: codepoint out of range\n");
 #endif
 	    return(0);
 	}
@@ -948,6 +1032,8 @@ xmlCopyCharMultiByte(xmlChar *out, int val) {
  * @out:  pointer to an array of xmlChar
  * @val:  the char value
  *
+ * DEPRECATED: Don't use.
+ *
  * append the char value in the array
  *
  * Returns the number of xmlChar written
@@ -970,9 +1056,34 @@ xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
  *									*
  ************************************************************************/
 
+/**
+ * xmlCtxtSetCharEncConvImpl:
+ * @ctxt:  parser context
+ * @impl:  callback
+ * @vctxt:  user data
+ *
+ * Installs a custom implementation to convert between character
+ * encodings.
+ *
+ * This bypasses legacy feature like global encoding handlers or
+ * encoding aliases.
+ *
+ * Available since 2.14.0.
+ */
+void
+xmlCtxtSetCharEncConvImpl(xmlParserCtxtPtr ctxt, xmlCharEncConvImpl impl,
+                          void *vctxt) {
+    if (ctxt == NULL)
+        return;
+
+    ctxt->convImpl = impl;
+    ctxt->convCtxt = vctxt;
+}
+
 static int
-xmlDetectEBCDIC(xmlParserInputPtr input, xmlCharEncodingHandlerPtr *hout) {
+xmlDetectEBCDIC(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr *hout) {
     xmlChar out[200];
+    xmlParserInputPtr input = ctxt->input;
     xmlCharEncodingHandlerPtr handler;
     int inlen, outlen, res, i;
 
@@ -980,9 +1091,10 @@ xmlDetectEBCDIC(xmlParserInputPtr input, xmlCharEncodingHandlerPtr *hout) {
 
     /*
      * To detect the EBCDIC code page, we convert the first 200 bytes
-     * to EBCDIC-US and try to find the encoding declaration.
+     * to IBM037 (EBCDIC-US) and try to find the encoding declaration.
      */
-    res = xmlLookupCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC, &handler);
+    res = xmlCreateCharEncodingHandler("IBM037", /* output */ 0,
+            ctxt->convImpl, ctxt->convCtxt, &handler);
     if (res != 0)
         return(res);
     outlen = sizeof(out) - 1;
@@ -1025,8 +1137,9 @@ xmlDetectEBCDIC(xmlParserInputPtr input, xmlCharEncodingHandlerPtr *hout) {
                 break;
             out[i] = 0;
             xmlCharEncCloseFunc(handler);
-            res = xmlOpenCharEncodingHandler((char *) out + start,
-                                             /* output */ 0, &handler);
+            res = xmlCreateCharEncodingHandler((char *) out + start,
+                    /* output */ 0, ctxt->convImpl, ctxt->convCtxt,
+                    &handler);
             if (res != 0)
                 return(res);
             *hout = handler;
@@ -1039,7 +1152,8 @@ done:
      * Encoding handlers are stateful, so we have to recreate them.
      */
     xmlCharEncCloseFunc(handler);
-    res = xmlLookupCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC, &handler);
+    res = xmlCreateCharEncodingHandler("IBM037", /* output */ 0,
+            ctxt->convImpl, ctxt->convCtxt, &handler);
     if (res != 0)
         return(res);
     *hout = handler;
@@ -1069,28 +1183,13 @@ xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
     if ((ctxt == NULL) || (ctxt->input == NULL))
         return(-1);
 
-    switch (enc) {
-	case XML_CHAR_ENCODING_NONE:
-	case XML_CHAR_ENCODING_UTF8:
-        case XML_CHAR_ENCODING_ASCII:
-            res = 0;
-            break;
-        case XML_CHAR_ENCODING_EBCDIC:
-            res = xmlDetectEBCDIC(ctxt->input, &handler);
-            break;
-        default:
-            res = xmlLookupCharEncodingHandler(enc, &handler);
-            break;
-    }
-
+    res = xmlLookupCharEncodingHandler(enc, &handler);
     if (res != 0) {
-        const char *name = xmlGetCharEncodingName(enc);
-
-        xmlFatalErr(ctxt, res, (name ? name : "<null>"));
+        xmlFatalErr(ctxt, res, NULL);
         return(-1);
     }
 
-    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);
+    ret = xmlSwitchToEncoding(ctxt, handler);
 
     if ((ret >= 0) && (enc == XML_CHAR_ENCODING_NONE)) {
         ctxt->input->flags &= ~XML_INPUT_HAS_ENCODING;
@@ -1101,7 +1200,7 @@ xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
 
 /**
  * xmlSwitchInputEncodingName:
- * @ctxt:  the parser context, only for error reporting
+ * @ctxt:  the parser context
  * @input:  the input strea,
  * @encoding:  the encoding name
  *
@@ -1116,13 +1215,24 @@ xmlSwitchInputEncodingName(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
     if (encoding == NULL)
         return(-1);
 
-    res = xmlOpenCharEncodingHandler(encoding, /* output */ 0, &handler);
-    if (res != 0) {
+    res = xmlCreateCharEncodingHandler(encoding, /* output */ 0,
+            ctxt->convImpl, ctxt->convCtxt, &handler);
+    if (res == XML_ERR_UNSUPPORTED_ENCODING) {
+        xmlWarningMsg(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
+                      "Unsupported encoding: %s\n", BAD_CAST encoding, NULL);
+        return(-1);
+    } else if (res != XML_ERR_OK) {
         xmlFatalErr(ctxt, res, encoding);
         return(-1);
     }
 
-    return(xmlSwitchInputEncoding(ctxt, input, handler));
+    res  = xmlInputSetEncodingHandler(input, handler);
+    if (res != XML_ERR_OK) {
+        xmlCtxtErrIO(ctxt, res, NULL);
+        return(-1);
+    }
+
+    return(0);
 }
 
 /**
@@ -1159,11 +1269,12 @@ xmlSwitchEncodingName(xmlParserCtxtPtr ctxt, const char *encoding) {
  *
  * Returns an xmlParserErrors code.
  */
-static int
+int
 xmlInputSetEncodingHandler(xmlParserInputPtr input,
                            xmlCharEncodingHandlerPtr handler) {
-    int nbchars;
     xmlParserInputBufferPtr in;
+    xmlBufPtr buf;
+    int code = XML_ERR_OK;
 
     if ((input == NULL) || (input->buf == NULL)) {
         xmlCharEncCloseFunc(handler);
@@ -1200,64 +1311,42 @@ xmlInputSetEncodingHandler(xmlParserInputPtr input,
         return(XML_ERR_OK);
     }
 
+    buf = xmlBufCreate(XML_IO_BUFFER_SIZE);
+    if (buf == NULL) {
+        xmlCharEncCloseFunc(handler);
+        return(XML_ERR_NO_MEMORY);
+    }
+
     in->encoder = handler;
+    in->raw = in->buffer;
+    in->buffer = buf;
 
     /*
      * Is there already some content down the pipe to convert ?
      */
-    if (xmlBufIsEmpty(in->buffer) == 0) {
-        xmlBufPtr buf;
+    if (input->end > input->base) {
         size_t processed;
-
-        buf = xmlBufCreate();
-        if (buf == NULL)
-            return(XML_ERR_NO_MEMORY);
+        size_t nbchars;
+        int res;
 
         /*
          * Shrink the current input buffer.
          * Move it as the raw buffer and create a new input buffer
          */
         processed = input->cur - input->base;
-        xmlBufShrink(in->buffer, processed);
+        xmlBufShrink(in->raw, processed);
         input->consumed += processed;
-        in->raw = in->buffer;
-        in->buffer = buf;
         in->rawconsumed = processed;
 
-        nbchars = xmlCharEncInput(in);
-        xmlBufResetInput(in->buffer, input);
-        if (nbchars < 0)
-            return(in->error);
+        nbchars = 4000 /* MINLEN */;
+        res = xmlCharEncInput(in, &nbchars);
+        if (res < 0)
+            code = in->error;
     }
 
-    return(XML_ERR_OK);
-}
+    xmlBufResetInput(in->buffer, input);
 
-/**
- * xmlInputSetEncoding:
- * @input:  the input stream
- * @encoding:  the encoding name
- *
- * Use specified encoding to decode input data. This overrides the
- * encoding found in the XML declaration.
- *
- * Available since 2.14.0.
- *
- * Returns an xmlParserErrors code.
- */
-int
-xmlInputSetEncoding(xmlParserInputPtr input, const char *encoding) {
-    xmlCharEncodingHandlerPtr handler;
-    int res;
-
-    if (encoding == NULL)
-        return(XML_ERR_ARGUMENT);
-
-    res = xmlOpenCharEncodingHandler(encoding, /* output */ 0, &handler);
-    if (res != 0)
-        return(res);
-
-    return(xmlInputSetEncodingHandler(input, handler));
+    return(code);
 }
 
 /**
@@ -1300,9 +1389,18 @@ xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
 int
 xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)
 {
+    int code;
+
     if (ctxt == NULL)
         return(-1);
-    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
+
+    code = xmlInputSetEncodingHandler(ctxt->input, handler);
+    if (code != XML_ERR_OK) {
+        xmlCtxtErrIO(ctxt, code, NULL);
+        return(-1);
+    }
+
+    return(0);
 }
 
 /**
@@ -1402,7 +1500,20 @@ xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 
     if (enc != XML_CHAR_ENCODING_NONE) {
         ctxt->input->flags |= autoFlag;
-        xmlSwitchEncoding(ctxt, enc);
+
+        if (enc == XML_CHAR_ENCODING_EBCDIC) {
+            xmlCharEncodingHandlerPtr handler;
+            int res;
+
+            res = xmlDetectEBCDIC(ctxt, &handler);
+            if (res != XML_ERR_OK) {
+                xmlFatalErr(ctxt, res, "detecting EBCDIC\n");
+            } else {
+                xmlSwitchToEncoding(ctxt, handler);
+            }
+        } else {
+            xmlSwitchEncoding(ctxt, enc);
+        }
     }
 }
 
@@ -1422,7 +1533,29 @@ void
 xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
     if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
         ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
-        xmlSwitchEncodingName(ctxt, (const char *) encoding);
+        xmlCharEncodingHandlerPtr handler;
+        int res;
+
+        /*
+         * xmlSwitchEncodingName treats unsupported encodings as
+         * warnings, but we want it to be an error in an encoding
+         * declaration.
+         */
+        res = xmlCreateCharEncodingHandler((const char *) encoding,
+                /* output */ 0, ctxt->convImpl, ctxt->convCtxt, &handler);
+        if (res != XML_ERR_OK) {
+            xmlFatalErr(ctxt, res, (const char *) encoding);
+            xmlFree(encoding);
+            return;
+        }
+
+        res  = xmlInputSetEncodingHandler(ctxt->input, handler);
+        if (res != XML_ERR_OK) {
+            xmlCtxtErrIO(ctxt, res, NULL);
+            xmlFree(encoding);
+            return;
+        }
+
         ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
     } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
         static const char *allowedUTF8[] = {
@@ -1481,6 +1614,23 @@ xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
     ctxt->encoding = encoding;
 }
 
+/**
+ * xmlCtxtGetDeclaredEncoding:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the encoding from the encoding declaration. This can differ
+ * from the actual encoding.
+ */
+const xmlChar *
+xmlCtxtGetDeclaredEncoding(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(NULL);
+
+    return(ctxt->encoding);
+}
+
 /**
  * xmlGetActualEncoding:
  * @ctxt:  the parser context
@@ -1534,6 +1684,8 @@ xmlFreeInputStream(xmlParserInputPtr input) {
  * xmlNewInputStream:
  * @ctxt:  an XML parser context
  *
+ * DEPRECATED: Use xmlNewInputFromUrl or similar functions.
+ *
  * Create a new input stream structure.
  *
  * Returns the new input stream or NULL
@@ -1555,7 +1707,7 @@ xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 }
 
 /**
- * xmlNewInputURL:
+ * xmlCtxtNewInputFromUrl:
  * @ctxt:  parser context
  * @url:  filename or URL
  * @publicId:  publid ID from doctype (optional)
@@ -1568,8 +1720,9 @@ xmlNewInputStream(xmlParserCtxtPtr ctxt) {
  * Returns a new parser input.
  */
 xmlParserInputPtr
-xmlNewInputURL(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,
-               const char *encoding, int flags ATTRIBUTE_UNUSED) {
+xmlCtxtNewInputFromUrl(xmlParserCtxtPtr ctxt, const char *url,
+                       const char *publicId, const char *encoding,
+                       int flags ATTRIBUTE_UNUSED) {
     xmlParserInputPtr input;
 
     if ((ctxt == NULL) || (url == NULL))
@@ -1622,7 +1775,7 @@ xmlNewInputInternal(xmlParserInputBufferPtr buf, const char *filename) {
 }
 
 /**
- * xmlInputCreateMemory:
+ * xmlNewInputFromMemory:
  * @url:  base URL (optional)
  * @mem:  pointer to char array
  * @size:  size of array
@@ -1646,8 +1799,8 @@ xmlNewInputInternal(xmlParserInputBufferPtr buf, const char *filename) {
  * Returns a new parser input or NULL if a memory allocation failed.
  */
 xmlParserInputPtr
-xmlInputCreateMemory(const char *url, const void *mem, size_t size,
-                     int flags) {
+xmlNewInputFromMemory(const char *url, const void *mem, size_t size,
+                      int flags) {
     xmlParserInputBufferPtr buf;
 
     if (mem == NULL)
@@ -1661,7 +1814,7 @@ xmlInputCreateMemory(const char *url, const void *mem, size_t size,
 }
 
 /**
- * xmlNewInputMemory:
+ * xmlCtxtNewInputFromMemory:
  * @ctxt:  parser context
  * @url:  base URL (optional)
  * @mem:  pointer to char array
@@ -1672,15 +1825,15 @@ xmlInputCreateMemory(const char *url, const void *mem, size_t size,
  * Returns a new parser input or NULL in case of error.
  */
 xmlParserInputPtr
-xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,
-                  const void *mem, size_t size,
-                  const char *encoding, int flags) {
+xmlCtxtNewInputFromMemory(xmlParserCtxtPtr ctxt, const char *url,
+                          const void *mem, size_t size,
+                          const char *encoding, int flags) {
     xmlParserInputPtr input;
 
     if ((ctxt == NULL) || (mem == NULL))
 	return(NULL);
 
-    input = xmlInputCreateMemory(url, mem, size, flags);
+    input = xmlNewInputFromMemory(url, mem, size, flags);
     if (input == NULL) {
         xmlCtxtErrMemory(ctxt);
         return(NULL);
@@ -1693,7 +1846,7 @@ xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,
 }
 
 /**
- * xmlInputCreateString:
+ * xmlNewInputFromString:
  * @url:  base URL (optional)
  * @str:  zero-terminated string
  * @flags:  optimization hints
@@ -1712,7 +1865,7 @@ xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,
  * Returns a new parser input or NULL if a memory allocation failed.
  */
 xmlParserInputPtr
-xmlInputCreateString(const char *url, const char *str, int flags) {
+xmlNewInputFromString(const char *url, const char *str, int flags) {
     xmlParserInputBufferPtr buf;
 
     if (str == NULL)
@@ -1726,7 +1879,7 @@ xmlInputCreateString(const char *url, const char *str, int flags) {
 }
 
 /**
- * xmlNewInputString:
+ * xmlCtxtNewInputFromString:
  * @ctxt:  parser context
  * @url:  base URL (optional)
  * @str:  zero-terminated string
@@ -1736,14 +1889,14 @@ xmlInputCreateString(const char *url, const char *str, int flags) {
  * Returns a new parser input.
  */
 xmlParserInputPtr
-xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url,
-                  const char *str, const char *encoding, int flags) {
+xmlCtxtNewInputFromString(xmlParserCtxtPtr ctxt, const char *url,
+                          const char *str, const char *encoding, int flags) {
     xmlParserInputPtr input;
 
     if ((ctxt == NULL) || (str == NULL))
 	return(NULL);
 
-    input = xmlInputCreateString(url, str, flags);
+    input = xmlNewInputFromString(url, str, flags);
     if (input == NULL) {
         xmlCtxtErrMemory(ctxt);
         return(NULL);
@@ -1756,7 +1909,7 @@ xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url,
 }
 
 /**
- * xmlInputCreateFd:
+ * xmlNewInputFromFd:
  * @url:  base URL (optional)
  * @fd:  file descriptor
  * @flags:  unused, pass 0
@@ -1773,7 +1926,7 @@ xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url,
  * Returns a new parser input or NULL if a memory allocation failed.
  */
 xmlParserInputPtr
-xmlInputCreateFd(const char *url, int fd, int flags ATTRIBUTE_UNUSED) {
+xmlNewInputFromFd(const char *url, int fd, int flags ATTRIBUTE_UNUSED) {
     xmlParserInputBufferPtr buf;
 
     if (fd < 0)
@@ -1787,7 +1940,7 @@ xmlInputCreateFd(const char *url, int fd, int flags ATTRIBUTE_UNUSED) {
 }
 
 /**
- * xmlNewInputFd:
+ * xmlCtxtNewInputFromFd:
  * @ctxt:  parser context
  * @url:  base URL (optional)
  * @fd:  file descriptor
@@ -1797,14 +1950,14 @@ xmlInputCreateFd(const char *url, int fd, int flags ATTRIBUTE_UNUSED) {
  * Returns a new parser input.
  */
 xmlParserInputPtr
-xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *url,
-              int fd, const char *encoding, int flags) {
+xmlCtxtNewInputFromFd(xmlParserCtxtPtr ctxt, const char *url,
+                      int fd, const char *encoding, int flags) {
     xmlParserInputPtr input;
 
     if ((ctxt == NULL) || (fd < 0))
 	return(NULL);
 
-    input = xmlInputCreateFd(url, fd, flags);
+    input = xmlNewInputFromFd(url, fd, flags);
     if (input == NULL) {
 	xmlCtxtErrMemory(ctxt);
         return(NULL);
@@ -1817,7 +1970,7 @@ xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *url,
 }
 
 /**
- * xmlInputCreateIO:
+ * xmlNewInputFromIO:
  * @url:  base URL (optional)
  * @ioRead:  read callback
  * @ioClose:  close callback (optional)
@@ -1843,9 +1996,9 @@ xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *url,
  * Returns a new parser input or NULL if a memory allocation failed.
  */
 xmlParserInputPtr
-xmlInputCreateIO(const char *url, xmlInputReadCallback ioRead,
-                 xmlInputCloseCallback ioClose, void *ioCtxt,
-                 int flags ATTRIBUTE_UNUSED) {
+xmlNewInputFromIO(const char *url, xmlInputReadCallback ioRead,
+                  xmlInputCloseCallback ioClose, void *ioCtxt,
+                  int flags ATTRIBUTE_UNUSED) {
     xmlParserInputBufferPtr buf;
 
     if (ioRead == NULL)
@@ -1866,7 +2019,7 @@ xmlInputCreateIO(const char *url, xmlInputReadCallback ioRead,
 }
 
 /**
- * xmlNewInputIO:
+ * xmlCtxtNewInputFromIO:
  * @ctxt:  parser context
  * @url:  base URL (optional)
  * @ioRead:  read callback
@@ -1878,15 +2031,16 @@ xmlInputCreateIO(const char *url, xmlInputReadCallback ioRead,
  * Returns a new parser input.
  */
 xmlParserInputPtr
-xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,
-              xmlInputReadCallback ioRead, xmlInputCloseCallback ioClose,
-              void *ioCtxt, const char *encoding, int flags) {
+xmlCtxtNewInputFromIO(xmlParserCtxtPtr ctxt, const char *url,
+                      xmlInputReadCallback ioRead,
+                      xmlInputCloseCallback ioClose,
+                      void *ioCtxt, const char *encoding, int flags) {
     xmlParserInputPtr input;
 
     if ((ctxt == NULL) || (ioRead == NULL))
 	return(NULL);
 
-    input = xmlInputCreateIO(url, ioRead, ioClose, ioCtxt, flags);
+    input = xmlNewInputFromIO(url, ioRead, ioClose, ioCtxt, flags);
     if (input == NULL) {
         xmlCtxtErrMemory(ctxt);
         return(NULL);
@@ -1899,7 +2053,7 @@ xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,
 }
 
 /**
- * xmlInputCreatePush:
+ * xmlNewPushInput:
  * @url:  base URL (optional)
  * @chunk:  pointer to char array
  * @size:  size of array
@@ -1909,7 +2063,7 @@ xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,
  * Returns a new parser input or NULL if a memory allocation failed.
  */
 xmlParserInputPtr
-xmlInputCreatePush(const char *url, const char *chunk, int size) {
+xmlNewPushInput(const char *url, const char *chunk, int size) {
     xmlParserInputBufferPtr buf;
     xmlParserInputPtr input;
 
@@ -1954,7 +2108,7 @@ xmlNewIOInputStream(xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr buf,
     xmlParserInputPtr input;
     const char *encoding;
 
-    if (buf == NULL)
+    if ((ctxt == NULL) || (buf == NULL))
         return(NULL);
 
     input = xmlNewInputInternal(buf, NULL);
@@ -1989,8 +2143,8 @@ xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {
 	return(NULL);
 
     if (ent->content != NULL) {
-        input = xmlNewInputString(ctxt, NULL, (const char *) ent->content,
-                                  NULL, XML_INPUT_BUF_STATIC);
+        input = xmlCtxtNewInputFromString(ctxt, NULL,
+                (const char *) ent->content, NULL, XML_INPUT_BUF_STATIC);
     } else if (ent->URI != NULL) {
         xmlResourceType rtype;
 
@@ -2018,13 +2172,16 @@ xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {
  * @ctxt:  an XML parser context
  * @buffer:  an memory buffer
  *
+ * DEPRECATED: Use xmlNewInputFromString.
+ *
  * Create a new input stream based on a memory buffer.
  *
  * Returns the new input stream
  */
 xmlParserInputPtr
 xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer) {
-    return(xmlNewInputString(ctxt, NULL, (const char *) buffer, NULL, 0));
+    return(xmlCtxtNewInputFromString(ctxt, NULL, (const char *) buffer,
+                                     NULL, 0));
 }
 
 
@@ -2053,6 +2210,8 @@ xmlResolveResourceFromCatalog(const char *URL, const char *ID,
                               xmlParserCtxtPtr ctxt) {
     xmlChar *resource = NULL;
     xmlCatalogAllow pref;
+    int allowLocal = 0;
+    int allowGlobal = 0;
 
     /*
      * If the resource doesn't exists as a file,
@@ -2060,13 +2219,22 @@ xmlResolveResourceFromCatalog(const char *URL, const char *ID,
      */
     pref = xmlCatalogGetDefaults();
 
+    if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&
+        ((pref == XML_CATA_ALLOW_ALL) ||
+         (pref == XML_CATA_ALLOW_DOCUMENT)))
+        allowLocal = 1;
+
+    if (((ctxt == NULL) ||
+         ((ctxt->options & XML_PARSE_NO_SYS_CATALOG) == 0)) &&
+        ((pref == XML_CATA_ALLOW_ALL) ||
+         (pref == XML_CATA_ALLOW_GLOBAL)))
+        allowGlobal = 1;
+
     if ((pref != XML_CATA_ALLOW_NONE) && (!xmlNoNetExists(URL))) {
 	/*
 	 * Do a local lookup
 	 */
-	if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&
-	    ((pref == XML_CATA_ALLOW_ALL) ||
-	     (pref == XML_CATA_ALLOW_DOCUMENT))) {
+        if (allowLocal) {
 	    resource = xmlCatalogLocalResolve(ctxt->catalogs,
 					      (const xmlChar *)ID,
 					      (const xmlChar *)URL);
@@ -2074,9 +2242,7 @@ xmlResolveResourceFromCatalog(const char *URL, const char *ID,
 	/*
 	 * Try a global lookup
 	 */
-	if ((resource == NULL) &&
-	    ((pref == XML_CATA_ALLOW_ALL) ||
-	     (pref == XML_CATA_ALLOW_GLOBAL))) {
+	if ((resource == NULL) && (allowGlobal)) {
 	    resource = xmlCatalogResolve((const xmlChar *)ID,
 					 (const xmlChar *)URL);
 	}
@@ -2089,14 +2255,10 @@ xmlResolveResourceFromCatalog(const char *URL, const char *ID,
 	if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {
 	    xmlChar *tmp = NULL;
 
-	    if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&
-		((pref == XML_CATA_ALLOW_ALL) ||
-		 (pref == XML_CATA_ALLOW_DOCUMENT))) {
+	    if (allowLocal) {
 		tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);
 	    }
-	    if ((tmp == NULL) &&
-		((pref == XML_CATA_ALLOW_ALL) ||
-	         (pref == XML_CATA_ALLOW_GLOBAL))) {
+	    if ((tmp == NULL) && (allowGlobal)) {
 		tmp = xmlCatalogResolveURI(resource);
 	    }
 
@@ -2112,6 +2274,53 @@ xmlResolveResourceFromCatalog(const char *URL, const char *ID,
 
 #endif
 
+#ifdef LIBXML_HTTP_ENABLED
+static int
+xmlCheckHTTPInputInternal(xmlParserInputPtr input) {
+    const char *encoding;
+    const char *redir;
+    const char *mime;
+    int code;
+
+    if ((input == NULL) || (input->buf == NULL) ||
+        (input->buf->readcallback != xmlIOHTTPRead) ||
+        (input->buf->context == NULL))
+        return(XML_ERR_OK);
+
+    code = xmlNanoHTTPReturnCode(input->buf->context);
+    if (code >= 400) {
+        /* fatal error */
+        return(XML_IO_LOAD_ERROR);
+    }
+
+    mime = xmlNanoHTTPMimeType(input->buf->context);
+    if ((xmlStrstr(BAD_CAST mime, BAD_CAST "/xml")) ||
+        (xmlStrstr(BAD_CAST mime, BAD_CAST "+xml"))) {
+        encoding = xmlNanoHTTPEncoding(input->buf->context);
+        if (encoding != NULL) {
+            xmlCharEncodingHandlerPtr handler;
+            int res;
+
+            res = xmlOpenCharEncodingHandler(encoding, /* output */ 0,
+                                             &handler);
+            if (res == 0)
+                xmlInputSetEncodingHandler(input, handler);
+        }
+    }
+
+    redir = xmlNanoHTTPRedir(input->buf->context);
+    if (redir != NULL) {
+        if (input->filename != NULL)
+            xmlFree((xmlChar *) input->filename);
+        input->filename = xmlMemStrdup(redir);
+        if (input->filename == NULL)
+            return(XML_ERR_NO_MEMORY);
+    }
+
+    return(XML_ERR_OK);
+}
+#endif /* LIBXML_HTTP_ENABLED */
+
 /**
  * xmlCheckHTTPInput:
  * @ctxt: an XML parser context
@@ -2132,50 +2341,25 @@ xmlCheckHTTPInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr ret) {
     (void) ctxt;
 
 #ifdef LIBXML_HTTP_ENABLED
-    if ((ret != NULL) && (ret->buf != NULL) &&
-        (ret->buf->readcallback == xmlIOHTTPRead) &&
-        (ret->buf->context != NULL)) {
-        const char *encoding;
-        const char *redir;
-        const char *mime;
-        int code;
+    {
+        int code = xmlCheckHTTPInputInternal(ret);
 
-        code = xmlNanoHTTPReturnCode(ret->buf->context);
-        if (code >= 400) {
-            /* fatal error */
-	    if (ret->filename != NULL)
+        if (code != XML_ERR_OK) {
+            if (ret->filename != NULL)
                 xmlCtxtErrIO(ctxt, XML_IO_LOAD_ERROR, ret->filename);
-	    else
+            else
                 xmlCtxtErrIO(ctxt, XML_IO_LOAD_ERROR, "<null>");
             xmlFreeInputStream(ret);
-            ret = NULL;
-        } else {
-
-            mime = xmlNanoHTTPMimeType(ret->buf->context);
-            if ((xmlStrstr(BAD_CAST mime, BAD_CAST "/xml")) ||
-                (xmlStrstr(BAD_CAST mime, BAD_CAST "+xml"))) {
-                encoding = xmlNanoHTTPEncoding(ret->buf->context);
-                if (encoding != NULL)
-                    xmlSwitchEncodingName(ctxt, encoding);
-#if 0
-            } else if (xmlStrstr(BAD_CAST mime, BAD_CAST "html")) {
-#endif
-            }
-            redir = xmlNanoHTTPRedir(ret->buf->context);
-            if (redir != NULL) {
-                if (ret->filename != NULL)
-                    xmlFree((xmlChar *) ret->filename);
-                ret->filename =
-                    (char *) xmlStrdup((const xmlChar *) redir);
-            }
+            return(NULL);
         }
     }
 #endif
+
     return(ret);
 }
 
 /**
- * xmlInputCreateUrl:
+ * xmlNewInputFromUrl:
  * @filename:  the filename to use as entity
  * @flags:  XML_INPUT flags
  * @out:  pointer to new parser input
@@ -2186,12 +2370,24 @@ xmlCheckHTTPInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr ret) {
  *
  * The flag XML_INPUT_NETWORK allows network access.
  *
+ * The following resource loaders will be called if they were
+ * registered (in order of precedence):
+ *
+ * - the per-thread xmlParserInputBufferCreateFilenameFunc set with
+ *   xmlParserInputBufferCreateFilenameDefault (deprecated)
+ * - the default loader which will return
+ *   - the result from a matching global input callback set with
+ *     xmlRegisterInputCallbacks (deprecated)
+ *   - a HTTP resource if support is compiled in.
+ *   - a file opened from the filesystem, with automatic detection
+ *     of compressed files if support is compiled in.
+ *
  * Available since 2.14.0.
  *
  * Returns an xmlParserErrors code.
  */
 int
-xmlInputCreateUrl(const char *filename, int flags, xmlParserInputPtr *out) {
+xmlNewInputFromUrl(const char *filename, int flags, xmlParserInputPtr *out) {
     xmlParserInputBufferPtr buf;
     xmlParserInputPtr input;
     int code = XML_ERR_OK;
@@ -2218,7 +2414,13 @@ xmlInputCreateUrl(const char *filename, int flags, xmlParserInputPtr *out) {
     if (input == NULL)
 	return(XML_ERR_NO_MEMORY);
 
-    /*input = xmlCheckHTTPInput(ctxt, input);*/
+#ifdef LIBXML_HTTP_ENABLED
+    code = xmlCheckHTTPInputInternal(input);
+    if (code != XML_ERR_OK) {
+        xmlFreeInputStream(input);
+        return(code);
+    }
+#endif
 
     *out = input;
     return(XML_ERR_OK);
@@ -2229,6 +2431,8 @@ xmlInputCreateUrl(const char *filename, int flags, xmlParserInputPtr *out) {
  * @ctxt:  an XML parser context
  * @filename:  the filename to use as entity
  *
+ * DEPRECATED: Use xmlNewInputFromUrl.
+ *
  * Create a new input stream based on a file or an URL.
  *
  * Returns the new input stream or NULL in case of error
@@ -2247,14 +2451,12 @@ xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename) {
     if ((ctxt->options & XML_PARSE_NONET) == 0)
         flags |= XML_INPUT_NETWORK;
 
-    code = xmlInputCreateUrl(filename, flags, &input);
+    code = xmlNewInputFromUrl(filename, flags, &input);
     if (code != XML_ERR_OK) {
         xmlCtxtErrIO(ctxt, code, filename);
         return(NULL);
     }
 
-    input = xmlCheckHTTPInput(ctxt, input);
-
     return(input);
 }
 
@@ -2406,20 +2608,29 @@ xmlLoadResource(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,
         return(NULL);
 
     if ((ctxt != NULL) && (ctxt->resourceLoader != NULL)) {
+        char *resource = NULL;
         int flags = 0;
         int code;
 
+#ifdef LIBXML_CATALOG_ENABLED
+        resource = (char *) xmlResolveResourceFromCatalog(url, publicId, ctxt);
+        if (resource != NULL)
+            url = resource;
+#endif
+
         if ((ctxt->options & XML_PARSE_NO_UNZIP) == 0)
             flags |= XML_INPUT_UNZIP;
         if ((ctxt->options & XML_PARSE_NONET) == 0)
             flags |= XML_INPUT_NETWORK;
 
-        code = ctxt->resourceLoader(ctxt->resourceCtxt, url, publicId, flags,
-                                    type, &ret);
+        code = ctxt->resourceLoader(ctxt->resourceCtxt, url, publicId, type,
+                                    flags, &ret);
         if (code != XML_ERR_OK) {
             xmlCtxtErrIO(ctxt, code, url);
-            return(NULL);
+            ret = NULL;
         }
+        if (resource != NULL)
+            xmlFree(resource);
         return(ret);
     }
 
@@ -2447,17 +2658,20 @@ xmlLoadResource(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,
  * @ID is an optional XML public ID, typically from a doctype
  * declaration. It is used for catalog lookups.
  *
- * The following resource loaders will be called if they were
- * registered (in order of precedence):
+ * If catalog lookup is enabled (default is yes) and URL or ID are
+ * found in system or local XML catalogs, URL is replaced with the
+ * result. Then the following resource loaders will be called if
+ * they were registered (in order of precedence):
  *
  * - the resource loader set with xmlCtxtSetResourceLoader
  * - the global external entity loader set with
- *   xmlSetExternalEntityLoader
+ *   xmlSetExternalEntityLoader (without catalog resolution,
+ *   deprecated)
  * - the per-thread xmlParserInputBufferCreateFilenameFunc set with
- *   xmlParserInputBufferCreateFilenameDefault
+ *   xmlParserInputBufferCreateFilenameDefault (deprecated)
  * - the default loader which will return
  *   - the result from a matching global input callback set with
- *     xmlRegisterInputCallbacks
+ *     xmlRegisterInputCallbacks (deprecated)
  *   - a HTTP resource if support is compiled in.
  *   - a file opened from the filesystem, with automatic detection
  *     of compressed files if support is compiled in.
@@ -2492,6 +2706,11 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
                      void *userData)
 {
     xmlParserInputPtr input;
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    size_t initialNodeTabSize = 1;
+#else
+    size_t initialNodeTabSize = 10;
+#endif
 
     if (ctxt == NULL)
         return(-1);
@@ -2500,7 +2719,6 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
 	ctxt->dict = xmlDictCreate();
     if (ctxt->dict == NULL)
 	return(-1);
-    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
 
     if (ctxt->sax == NULL)
 	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
@@ -2524,9 +2742,14 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
     ctxt->atts = NULL;
     /* Allocate the Input stack */
     if (ctxt->inputTab == NULL) {
-	ctxt->inputTab = (xmlParserInputPtr *)
-		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
-	ctxt->inputMax = 5;
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+        size_t initialSize = 1;
+#else
+        size_t initialSize = 5;
+#endif
+
+	ctxt->inputTab = xmlMalloc(initialSize * sizeof(xmlParserInputPtr));
+	ctxt->inputMax = initialSize;
     }
     if (ctxt->inputTab == NULL)
 	return(-1);
@@ -2546,8 +2769,8 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
 
     /* Allocate the Node stack */
     if (ctxt->nodeTab == NULL) {
-	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
-	ctxt->nodeMax = 10;
+	ctxt->nodeTab = xmlMalloc(initialNodeTabSize * sizeof(xmlNodePtr));
+	ctxt->nodeMax = initialNodeTabSize;
     }
     if (ctxt->nodeTab == NULL)
 	return(-1);
@@ -2556,8 +2779,8 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
 
     /* Allocate the Name stack */
     if (ctxt->nameTab == NULL) {
-	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
-	ctxt->nameMax = 10;
+	ctxt->nameTab = xmlMalloc(initialNodeTabSize * sizeof(xmlChar *));
+	ctxt->nameMax = initialNodeTabSize;
     }
     if (ctxt->nameTab == NULL)
 	return(-1);
@@ -2566,13 +2789,12 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
 
     /* Allocate the space stack */
     if (ctxt->spaceTab == NULL) {
-	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
-	ctxt->spaceMax = 10;
+	ctxt->spaceTab = xmlMalloc(initialNodeTabSize * sizeof(int));
+	ctxt->spaceMax = initialNodeTabSize;
     }
     if (ctxt->spaceTab == NULL)
 	return(-1);
     ctxt->spaceNr = 1;
-    ctxt->spaceMax = 10;
     ctxt->spaceTab[0] = -1;
     ctxt->space = &ctxt->spaceTab[0];
     ctxt->myDoc = NULL;
@@ -2691,6 +2913,7 @@ xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
     if (ctxt->sax != NULL)
 #endif /* LIBXML_SAX1_ENABLED */
         xmlFree(ctxt->sax);
+    if (ctxt->directory != NULL) xmlFree(ctxt->directory);
     if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
     if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
@@ -2791,6 +3014,110 @@ xmlNewSAXParserCtxt(const xmlSAXHandler *sax, void *userData)
     return(ctxt);
 }
 
+/**
+ * xmlCtxtGetPrivate:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the private application data.
+ */
+void *
+xmlCtxtGetPrivate(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(NULL);
+
+    return(ctxt->_private);
+}
+
+/**
+ * xmlCtxtSetPrivate:
+ * ctxt:  parser context
+ * priv:  private application data
+ *
+ * Available since 2.14.0.
+ *
+ * Set the private application data.
+ */
+void
+xmlCtxtSetPrivate(xmlParserCtxtPtr ctxt, void *priv) {
+    if (ctxt == NULL)
+        return;
+
+    ctxt->_private = priv;
+}
+
+/**
+ * xmlCtxtGetCatalogs:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the local catalogs.
+ */
+void *
+xmlCtxtGetCatalogs(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(NULL);
+
+    return(ctxt->catalogs);
+}
+
+/**
+ * xmlCtxtSetCatalogs:
+ * ctxt:  parser context
+ * catalogs:  catalogs pointer
+ *
+ * Available since 2.14.0.
+ *
+ * Set the local catalogs.
+ */
+void
+xmlCtxtSetCatalogs(xmlParserCtxtPtr ctxt, void *catalogs) {
+    if (ctxt == NULL)
+        return;
+
+    ctxt->catalogs = catalogs;
+}
+
+/**
+ * xmlCtxtGetDict:
+ * ctxt:  parser context
+ *
+ * Available since 2.14.0.
+ *
+ * Returns the dictionary.
+ */
+xmlDictPtr
+xmlCtxtGetDict(xmlParserCtxtPtr ctxt) {
+    if (ctxt == NULL)
+        return(NULL);
+
+    return(ctxt->dict);
+}
+
+/**
+ * xmlCtxtSetDict:
+ * ctxt:  parser context
+ * dict:  dictionary
+ *
+ * Available since 2.14.0.
+ *
+ * Set the dictionary. This should only be done immediately after
+ * creating a parser context.
+ */
+void
+xmlCtxtSetDict(xmlParserCtxtPtr ctxt, xmlDictPtr dict) {
+    if (ctxt == NULL)
+        return;
+
+    if (ctxt->dict != NULL)
+        xmlDictFree(ctxt->dict);
+
+    xmlDictReference(dict);
+    ctxt->dict = dict;
+}
+
 /************************************************************************
  *									*
  *		Handling of node information				*
diff --git a/pattern.c b/pattern.c
index 23b52744..ea4d5a45 100644
--- a/pattern.c
+++ b/pattern.c
@@ -367,35 +367,6 @@ xmlPatternAdd(xmlPatParserContextPtr ctxt, xmlPatternPtr comp,
     return (0);
 }
 
-#if 0
-/**
- * xsltSwapTopPattern:
- * @comp:  the compiled match expression
- *
- * reverse the two top steps.
- */
-static void
-xsltSwapTopPattern(xmlPatternPtr comp) {
-    int i;
-    int j = comp->nbStep - 1;
-
-    if (j > 0) {
-	register const xmlChar *tmp;
-	register xmlPatOp op;
-	i = j - 1;
-	tmp = comp->steps[i].value;
-	comp->steps[i].value = comp->steps[j].value;
-	comp->steps[j].value = tmp;
-	tmp = comp->steps[i].value2;
-	comp->steps[i].value2 = comp->steps[j].value2;
-	comp->steps[j].value2 = tmp;
-	op = comp->steps[i].op;
-	comp->steps[i].op = comp->steps[j].op;
-	comp->steps[j].op = op;
-    }
-}
-#endif
-
 /**
  * xmlReversePattern:
  * @comp:  the compiled match expression
@@ -462,16 +433,11 @@ xmlReversePattern(xmlPatternPtr comp) {
 
 static int
 xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {
-    if ((states->states == NULL) || (states->maxstates <= 0)) {
-        states->maxstates = 4;
-	states->nbstates = 0;
-	states->states = xmlMalloc(4 * sizeof(xmlStepState));
-    }
-    else if (states->maxstates <= states->nbstates) {
+    if (states->maxstates <= states->nbstates) {
+        size_t newSize = states->maxstates ? states->maxstates * 2 : 4;
         xmlStepState *tmp;
 
-	tmp = (xmlStepStatePtr) xmlRealloc(states->states,
-			       2 * states->maxstates * sizeof(xmlStepState));
+	tmp = xmlRealloc(states->states, newSize * sizeof(tmp[0]));
 	if (tmp == NULL)
 	    return(-1);
 	states->states = tmp;
@@ -479,9 +445,6 @@ xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {
     }
     states->states[states->nbstates].step = step;
     states->states[states->nbstates++].node = node;
-#if 0
-    fprintf(stderr, "Push: %d, %s\n", step, node->name);
-#endif
     return(0);
 }
 
@@ -685,9 +648,6 @@ rollback:
     states.nbstates--;
     i = states.states[states.nbstates].step;
     node = states.states[states.nbstates].node;
-#if 0
-    fprintf(stderr, "Pop: %d, %s\n", i, node->name);
-#endif
     goto restart;
 }
 
@@ -713,73 +673,6 @@ rollback:
 #define PUSH(op, val, val2)						\
     if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
 
-#if 0
-/**
- * xmlPatScanLiteral:
- * @ctxt:  the XPath Parser context
- *
- * Parse an XPath Literal:
- *
- * [29] Literal ::= '"' [^"]* '"'
- *                | "'" [^']* "'"
- *
- * Returns the Literal parsed or NULL
- */
-
-static xmlChar *
-xmlPatScanLiteral(xmlPatParserContextPtr ctxt) {
-    const xmlChar *q, *cur;
-    xmlChar *ret = NULL;
-    int val, len;
-
-    SKIP_BLANKS;
-    if (CUR == '"') {
-        NEXT;
-	cur = q = CUR_PTR;
-	val = xmlStringCurrentChar(NULL, cur, &len);
-	while ((IS_CHAR(val)) && (val != '"')) {
-	    cur += len;
-	    val = xmlStringCurrentChar(NULL, cur, &len);
-	}
-	if (!IS_CHAR(val)) {
-	    ctxt->error = 1;
-	    return(NULL);
-	} else {
-	    if (ctxt->dict)
-		ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
-	    else
-		ret = xmlStrndup(q, cur - q);
-        }
-	cur += len;
-	CUR_PTR = cur;
-    } else if (CUR == '\'') {
-        NEXT;
-	cur = q = CUR_PTR;
-	val = xmlStringCurrentChar(NULL, cur, &len);
-	while ((IS_CHAR(val)) && (val != '\'')) {
-	    cur += len;
-	    val = xmlStringCurrentChar(NULL, cur, &len);
-	}
-	if (!IS_CHAR(val)) {
-	    ctxt->error = 1;
-	    return(NULL);
-	} else {
-	    if (ctxt->dict)
-		ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
-	    else
-		ret = xmlStrndup(q, cur - q);
-        }
-	cur += len;
-	CUR_PTR = cur;
-    } else {
-	/* XP_ERROR(XPATH_START_LITERAL_ERROR); */
-	ctxt->error = 1;
-	return(NULL);
-    }
-    return(ret);
-}
-#endif
-
 /**
  * xmlPatScanName:
  * @ctxt:  the XPath Parser context
@@ -863,32 +756,6 @@ xmlPatScanNCName(xmlPatParserContextPtr ctxt) {
     return(ret);
 }
 
-#if 0
-/**
- * xmlPatScanQName:
- * @ctxt:  the XPath Parser context
- * @prefix:  the place to store the prefix
- *
- * Parse a qualified name
- *
- * Returns the Name parsed or NULL
- */
-
-static xmlChar *
-xmlPatScanQName(xmlPatParserContextPtr ctxt, xmlChar **prefix) {
-    xmlChar *ret = NULL;
-
-    *prefix = NULL;
-    ret = xmlPatScanNCName(ctxt);
-    if (CUR == ':') {
-        *prefix = ret;
-	NEXT;
-	ret = xmlPatScanNCName(ctxt);
-    }
-    return(ret);
-}
-#endif
-
 /**
  * xmlCompileAttributeTest:
  * @ctxt:  the compilation context
@@ -1400,7 +1267,6 @@ error_unfinished:
     ctxt->error = 1;
     ERROR5(NULL, NULL, NULL,
 	"Unfinished expression '%s'.\n", ctxt->base);
-    return;
 }
 
 /************************************************************************
@@ -1951,22 +1817,6 @@ xmlStreamPushInternal(xmlStreamCtxtPtr stream,
 	    {
 		match = 1;
 	    }
-#if 0
-/*
-* TODO: Pointer comparison won't work, since not guaranteed that the given
-*  values are in the same dict; especially if it's the namespace name,
-*  normally coming from ns->href. We need a namespace dict mechanism !
-*/
-	    } else if (comp->dict) {
-		if (step.name == NULL) {
-		    if (step.ns == NULL)
-			match = 1;
-		    else
-			match = (step.ns == ns);
-		} else {
-		    match = ((step.name == name) && (step.ns == ns));
-		}
-#endif /* if 0 ------------------------------------------------------- */
 	    if (match) {
 		final = step.flags & XML_STREAM_STEP_FINAL;
                 if (final) {
diff --git a/post_update.sh b/post_update.sh
index 127dc257..6981ca6b 100755
--- a/post_update.sh
+++ b/post_update.sh
@@ -2,11 +2,6 @@
 
 set -e
 
-if [[ "${TARGET_PRODUCT}" != "aosp_x86" ]]; then
-  echo "Please run 'aosp_x86-trunk_staging-eng' first." >&2
-  exit 1
-fi
-
 T="${ANDROID_BUILD_TOP}"
 cd $(dirname "$0")
 
diff --git a/python/drv_libxml2.py b/python/drv_libxml2.py
index 71b1c67d..363c6f81 100644
--- a/python/drv_libxml2.py
+++ b/python/drv_libxml2.py
@@ -146,7 +146,10 @@ class LibXml2Reader(xmlreader.XMLReader):
                 reader = libxml2.newTextReaderFilename(source)
             else:
                 source = saxutils.prepare_input_source(source)
-                input = libxml2.inputBuffer(source.getByteStream())
+                stream = source.getCharacterStream()
+                if stream is None:
+                    stream = source.getByteStream()
+                input = libxml2.inputBuffer(stream)
                 reader = input.newTextReader(source.getSystemId())
             reader.SetErrorHandler(self._errorHandler,None)
             # configure reader
diff --git a/python/generator.py b/python/generator.py
index c83cd6b4..2d6abacf 100755
--- a/python/generator.py
+++ b/python/generator.py
@@ -299,36 +299,28 @@ deprecated_funcs = {
     'namePush': True,
     'nodePop': True,
     'nodePush': True,
+    'xmlByteConsumed': True,
     'xmlCheckFilename': True,
     'xmlCheckLanguageID': True,
     'xmlCleanupCharEncodingHandlers': True,
     'xmlCleanupGlobals': True,
+    'xmlCopyChar': True,
     'xmlDefaultSAXHandlerInit': True,
-    'xmlDecodeEntities': True,
     'xmlDictCleanup': True,
-    'xmlEncodeEntities': True,
     'xmlFileMatch': True,
     'xmlGetCompressMode': True,
-    'xmlHandleEntity': True,
     'xmlInitCharEncodingHandlers': True,
     'xmlInitGlobals': True,
     'xmlInitializeDict': True,
-    'xmlInitializePredefinedEntities': True,
     'xmlIOFTPMatch': True,
     'xmlIOHTTPMatch': True,
+    'xmlIsLetter': True,
     'xmlIsRef': True,
     'xmlKeepBlanksDefault': True,
     'xmlLineNumbersDefault': True,
-    'xmlNamespaceParseNCName': True,
-    'xmlNamespaceParseNSDef': True,
-    'xmlNanoFTPCleanup': True,
-    'xmlNanoFTPInit': True,
-    'xmlNanoFTPProxy': True,
-    'xmlNanoFTPScanProxy': True,
     'xmlNanoHTTPCleanup': True,
     'xmlNanoHTTPInit': True,
     'xmlNanoHTTPScanProxy': True,
-    'xmlNewGlobalNs': True,
     'xmlNextChar': True,
     'xmlNormalizeWindowsPath': True,
     'xmlParseAttValue': True,
@@ -349,14 +341,12 @@ deprecated_funcs = {
     'xmlParseMarkupDecl': True,
     'xmlParseMisc': True,
     'xmlParseName': True,
-    'xmlParseNamespace': True,
     'xmlParseNmtoken': True,
     'xmlParseNotationDecl': True,
     'xmlParsePEReference': True,
     'xmlParsePI': True,
     'xmlParsePITarget': True,
     'xmlParsePubidLiteral': True,
-    'xmlParseQuotedString': True,
     'xmlParseReference': True,
     'xmlParseSDDecl': True,
     'xmlParseStartTag': True,
@@ -366,7 +356,9 @@ deprecated_funcs = {
     'xmlParseVersionNum': True,
     'xmlParseXMLDecl': True,
     'xmlParserHandlePEReference': True,
-    'xmlParserHandleReference': True,
+    'xmlParserInputBufferGrow': True,
+    'xmlParserInputBufferPush': True,
+    'xmlParserInputBufferRead': True,
     'xmlParserSetLineNumbers': True,
     'xmlParserSetLoadSubset': True,
     'xmlParserSetPedantic': True,
@@ -381,7 +373,6 @@ deprecated_funcs = {
     'xmlRelaxNGInitTypes': True,
     'xmlRemoveRef': True,
     'xmlSAXDefaultVersion': True,
-    'xmlScanName': True,
     'xmlSchemaCleanupTypes': True,
     'xmlSchemaInitTypes': True,
     'xmlSetCompressMode': True,
diff --git a/python/libxml.c b/python/libxml.c
index 6897aa52..f6e0fb4f 100644
--- a/python/libxml.c
+++ b/python/libxml.c
@@ -1568,20 +1568,34 @@ typedef struct
 typedef xmlParserCtxtPyCtxt *xmlParserCtxtPyCtxtPtr;
 
 static void
-libxml_xmlParserCtxtGenericErrorFuncHandler(void *ctx, int severity, char *str) 
+libxml_xmlParserCtxtErrorHandler(void *ctx, const xmlError *error)
 {
     PyObject *list;
     PyObject *result;
     xmlParserCtxtPtr ctxt;
     xmlParserCtxtPyCtxtPtr pyCtxt;
+    int severity;
     
     ctxt = (xmlParserCtxtPtr)ctx;
     pyCtxt = (xmlParserCtxtPyCtxtPtr)ctxt->_private;
 
+    if ((error->domain == XML_FROM_VALID) ||
+        (error->domain == XML_FROM_DTD)) {
+        if (error->level == XML_ERR_WARNING)
+            severity = XML_PARSER_SEVERITY_VALIDITY_WARNING;
+        else
+            severity = XML_PARSER_SEVERITY_VALIDITY_ERROR;
+    } else {
+        if (error->level == XML_ERR_WARNING)
+            severity = XML_PARSER_SEVERITY_WARNING;
+        else
+            severity = XML_PARSER_SEVERITY_ERROR;
+    }
+
     list = PyTuple_New(4);
     PyTuple_SetItem(list, 0, pyCtxt->arg);
     Py_XINCREF(pyCtxt->arg);
-    PyTuple_SetItem(list, 1, libxml_charPtrWrap(str));
+    PyTuple_SetItem(list, 1, libxml_constcharPtrWrap(error->message));
     PyTuple_SetItem(list, 2, libxml_intWrap(severity));
     PyTuple_SetItem(list, 3, Py_None);
     Py_INCREF(Py_None);
@@ -1595,46 +1609,6 @@ libxml_xmlParserCtxtGenericErrorFuncHandler(void *ctx, int severity, char *str)
     Py_XDECREF(result);
 }
 
-static void 
-libxml_xmlParserCtxtErrorFuncHandler(void *ctx, const char *msg, ...) 
-{
-    va_list ap;
-
-    va_start(ap, msg);
-    libxml_xmlParserCtxtGenericErrorFuncHandler(ctx,XML_PARSER_SEVERITY_ERROR,libxml_buildMessage(msg,ap));
-    va_end(ap);
-}
-
-static void 
-libxml_xmlParserCtxtWarningFuncHandler(void *ctx, const char *msg, ...) 
-{
-    va_list ap;
-
-    va_start(ap, msg);
-    libxml_xmlParserCtxtGenericErrorFuncHandler(ctx,XML_PARSER_SEVERITY_WARNING,libxml_buildMessage(msg,ap));
-    va_end(ap);
-}
-
-static void 
-libxml_xmlParserCtxtValidityErrorFuncHandler(void *ctx, const char *msg, ...) 
-{
-    va_list ap;
-
-    va_start(ap, msg);
-    libxml_xmlParserCtxtGenericErrorFuncHandler(ctx,XML_PARSER_SEVERITY_VALIDITY_ERROR,libxml_buildMessage(msg,ap));
-    va_end(ap);
-}
-
-static void 
-libxml_xmlParserCtxtValidityWarningFuncHandler(void *ctx, const char *msg, ...) 
-{
-    va_list ap;
-
-    va_start(ap, msg);
-    libxml_xmlParserCtxtGenericErrorFuncHandler(ctx,XML_PARSER_SEVERITY_VALIDITY_WARNING,libxml_buildMessage(msg,ap));
-    va_end(ap);
-}
-
 static PyObject *
 libxml_xmlParserCtxtSetErrorHandler(ATTRIBUTE_UNUSED PyObject *self, PyObject *args) 
 {
@@ -1670,16 +1644,10 @@ libxml_xmlParserCtxtSetErrorHandler(ATTRIBUTE_UNUSED PyObject *self, PyObject *a
     pyCtxt->arg = pyobj_arg;
 
     if (pyobj_f != Py_None) {
-	ctxt->sax->error = libxml_xmlParserCtxtErrorFuncHandler;
-	ctxt->sax->warning = libxml_xmlParserCtxtWarningFuncHandler;
-	ctxt->vctxt.error = libxml_xmlParserCtxtValidityErrorFuncHandler;
-	ctxt->vctxt.warning = libxml_xmlParserCtxtValidityWarningFuncHandler;
+        xmlCtxtSetErrorHandler(ctxt, libxml_xmlParserCtxtErrorHandler, ctxt);
     }
     else {
-	ctxt->sax->error = xmlParserError;
-	ctxt->vctxt.error = xmlParserValidityError;
-	ctxt->sax->warning = xmlParserWarning;
-	ctxt->vctxt.warning = xmlParserValidityWarning;
+        xmlCtxtSetErrorHandler(ctxt, NULL, NULL);
     }
 
     py_retval = libxml_intWrap(1);
@@ -2899,7 +2867,8 @@ libxml_addLocalCatalog(ATTRIBUTE_UNUSED PyObject * self, PyObject * args)
     ctxt = (xmlParserCtxtPtr) PyparserCtxt_Get(pyobj_ctxt);
 
     if (URL != NULL) {
-	ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);
+        void *catalogs = xmlCtxtGetCatalogs(ctxt);
+        xmlCtxtSetCatalogs(ctxt, xmlCatalogAddLocal(catalogs, URL));
     }
 
     Py_INCREF(Py_None);
diff --git a/python/libxml_wrap.h b/python/libxml_wrap.h
index 23a31d69..1908b26f 100644
--- a/python/libxml_wrap.h
+++ b/python/libxml_wrap.h
@@ -50,7 +50,7 @@
  * Repeated here since the definition is not available when
  * compiled outside the libxml2 build tree.
  */
-#ifdef __GNUC__
+#if defined(__GNUC__) || defined(__clang__)
 #ifdef ATTRIBUTE_UNUSED
 #undef ATTRIBUTE_UNUSED
 #endif
diff --git a/python/meson.build b/python/meson.build
index 633dc922..d5a39fd3 100644
--- a/python/meson.build
+++ b/python/meson.build
@@ -20,11 +20,11 @@ if py.found() == true
     setup_py = configuration_data()
     setup_py.set('prefix', get_option('prefix'))
     setup_py.set('LIBXML_VERSION', meson.project_version())
-    setup_py.set('WITH_ICONV', iconv_dep.found().to_int())
-    setup_py.set('WITH_ICU', icu_dep.found().to_int())
-    setup_py.set('WITH_LZMA', lzma_dep.found().to_int())
-    setup_py.set('WITH_ZLIB', zlib_dep.found().to_int())
-    setup_py.set('WITH_THREADS', threads_dep.found().to_int())
+    setup_py.set('WITH_ICONV', want_iconv.to_int())
+    setup_py.set('WITH_ICU', want_icu.to_int())
+    setup_py.set('WITH_LZMA', want_lzma.to_int())
+    setup_py.set('WITH_ZLIB', want_zlib.to_int())
+    setup_py.set('WITH_THREADS', want_threads.to_int())
     configure_file(
         input: 'setup.py.in',
         output: 'setup.py',
diff --git a/python/tests/error.py b/python/tests/error.py
index 6c8da999..6668b729 100755
--- a/python/tests/error.py
+++ b/python/tests/error.py
@@ -10,7 +10,7 @@ import libxml2
 # Memory debug specific
 libxml2.debugMemory(1)
 
-expect='--> I/O --> error : --> failed to load "missing.xml": No such file or directory\n'
+expect='--> I/O --> warning : --> failed to load "missing.xml": No such file or directory\n'
 err=""
 def callback(ctx, str):
      global err
diff --git a/python/tests/input_callback.py b/python/tests/input_callback.py
index 35a51695..c4c8e40f 100755
--- a/python/tests/input_callback.py
+++ b/python/tests/input_callback.py
@@ -90,7 +90,7 @@ run_test(desc="Loading entity without custom callback",
         docpath=startURL, catalog=None,
         exp_status="not loaded", exp_err=[
             (-1, "I/O "),
-            (-1, "error : "),
+            (-1, "warning : "),
             (-1, "failed to load \"py://strings/xml/sample.xml\": No such file or directory\n")
             ])
 
@@ -99,7 +99,7 @@ libxml2.registerInputCallback(my_input_cb)
 run_test(desc="Loading entity with custom callback",
         docpath=startURL, catalog=None,
         exp_status="loaded", exp_err=[
-            (  3, 'failed to load "http://example.com/dtds/sample.dtd": Attempt to load network entity\n'),
+            (  4, 'failed to load "http://example.com/dtds/sample.dtd": Attempt to load network entity\n'),
             (  4, "Entity 'sample.entity' not defined\n")
             ])
 
@@ -121,7 +121,7 @@ run_test(desc="Retry loading document after unregistering callback",
         docpath=startURL, catalog=catURL,
         exp_status="not loaded", exp_err=[
             (-1, "I/O "),
-            (-1, "error : "),
+            (-1, "warning : "),
             (-1, "failed to load \"py://strings/xml/sample.xml\": No such file or directory\n")
             ])
 
@@ -141,7 +141,7 @@ run_test(desc="Loading using standard i/o after unregistering all callbacks",
         docpath="tst.xml", catalog=None,
         exp_status="not loaded", exp_err=[
             (-1, "I/O "),
-            (-1, "error : "),
+            (-1, "warning : "),
             (-1, "failed to load \"tst.xml\": No such file or directory\n")
             ])
 
diff --git a/python/tests/tstLastError.py b/python/tests/tstLastError.py
index 35f5eb3d..a0799950 100755
--- a/python/tests/tstLastError.py
+++ b/python/tests/tstLastError.py
@@ -60,7 +60,7 @@ class TestCase(unittest.TestCase):
                         domain=libxml2.XML_FROM_IO,
                         code=libxml2.XML_IO_ENOENT,
                         message='failed to load "dummy.xml": No such file or directory\n',
-                        level=libxml2.XML_ERR_FATAL,
+                        level=libxml2.XML_ERR_WARNING,
                         file=None,
                         line=0)
 
diff --git a/relaxng.c b/relaxng.c
index 6838d566..d452fcea 100644
--- a/relaxng.c
+++ b/relaxng.c
@@ -491,10 +491,10 @@ xmlRngPErr(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node, int error,
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, NULL, node,
-                          XML_FROM_RELAXNGP, error, XML_ERR_ERROR, NULL, 0,
-                          (const char *) str1, (const char *) str2, NULL, 0, 0,
-                          msg, str1, str2);
+    res = xmlRaiseError(schannel, channel, data, NULL, node,
+                        XML_FROM_RELAXNGP, error, XML_ERR_ERROR, NULL, 0,
+                        (const char *) str1, (const char *) str2, NULL, 0, 0,
+                        msg, str1, str2);
     if (res < 0)
         xmlRngPErrMemory(ctxt);
 }
@@ -533,10 +533,10 @@ xmlRngVErr(xmlRelaxNGValidCtxtPtr ctxt, xmlNodePtr node, int error,
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, NULL, node,
-                          XML_FROM_RELAXNGV, error, XML_ERR_ERROR, NULL, 0,
-                          (const char *) str1, (const char *) str2, NULL, 0, 0,
-                          msg, str1, str2);
+    res = xmlRaiseError(schannel, channel, data, NULL, node,
+                        XML_FROM_RELAXNGV, error, XML_ERR_ERROR, NULL, 0,
+                        (const char *) str1, (const char *) str2, NULL, 0, 0,
+                        msg, str1, str2);
     if (res < 0)
         xmlRngVErrMemory(ctxt);
 }
@@ -3169,9 +3169,9 @@ xmlRelaxNGCompile(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGDefinePtr def)
         case XML_RELAXNG_LIST:
         case XML_RELAXNG_PARAM:
         case XML_RELAXNG_VALUE:
-            /* This should not happen and generate an internal error */
-            fprintf(stderr, "RNG internal error trying to compile %s\n",
-                    xmlRelaxNGDefName(def));
+            xmlRngPErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                       "RNG internal error trying to compile %s\n",
+                       BAD_CAST xmlRelaxNGDefName(def), NULL);
             break;
     }
     return (ret);
@@ -7859,19 +7859,22 @@ xmlRelaxNGValidateCompiledCallback(xmlRegExecCtxtPtr exec ATTRIBUTE_UNUSED,
     int ret;
 
     if (ctxt == NULL) {
-        fprintf(stderr, "callback on %s missing context\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s missing context\n", token, NULL);
         return;
     }
     if (define == NULL) {
         if (token[0] == '#')
             return;
-        fprintf(stderr, "callback on %s missing define\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s missing define\n", token, NULL);
         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))
             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
         return;
     }
     if (define->type != XML_RELAXNG_ELEMENT) {
-        fprintf(stderr, "callback on %s define is not element\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s define is not element\n", token, NULL);
         if (ctxt->errNo == XML_RELAXNG_OK)
             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
         return;
@@ -8065,7 +8068,8 @@ xmlRelaxNGValidateProgressiveCallback(xmlRegExecCtxtPtr exec
     int ret = 0, oldflags;
 
     if (ctxt == NULL) {
-        fprintf(stderr, "callback on %s missing context\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s missing context\n", token, NULL);
         return;
     }
     node = ctxt->pnode;
@@ -8073,14 +8077,16 @@ xmlRelaxNGValidateProgressiveCallback(xmlRegExecCtxtPtr exec
     if (define == NULL) {
         if (token[0] == '#')
             return;
-        fprintf(stderr, "callback on %s missing define\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s missing define\n", token, NULL);
         if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))
             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
         ctxt->pstate = -1;
         return;
     }
     if (define->type != XML_RELAXNG_ELEMENT) {
-        fprintf(stderr, "callback on %s define is not element\n", token);
+        xmlRngVErr(ctxt, NULL, XML_ERR_INTERNAL_ERROR,
+                   "callback on %s define is not element\n", token, NULL);
         if (ctxt->errNo == XML_RELAXNG_OK)
             ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;
         ctxt->pstate = -1;
@@ -8420,7 +8426,7 @@ xmlRelaxNGNormalize(xmlRelaxNGValidCtxtPtr ctxt, const xmlChar * str)
         tmp++;
     len = tmp - str;
 
-    ret = (xmlChar *) xmlMallocAtomic(len + 1);
+    ret = xmlMalloc(len + 1);
     if (ret == NULL) {
         xmlRngVErrMemory(ctxt);
         return (NULL);
@@ -10674,7 +10680,6 @@ xmlRelaxNGCleanPSVI(xmlNodePtr node) {
 	    }
 	} while (cur != NULL);
     }
-    return;
 }
 /************************************************************************
  *									*
diff --git a/result/XInclude/fallback.xml.err b/result/XInclude/fallback.xml.err
index fa6b9e1a..3239da07 100644
--- a/result/XInclude/fallback.xml.err
+++ b/result/XInclude/fallback.xml.err
@@ -1 +1 @@
-I/O error : failed to load "test/XInclude/docs/something.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/something.xml": No such file or directory
diff --git a/result/XInclude/fallback2.xml.err b/result/XInclude/fallback2.xml.err
index d405ac20..288ed212 100644
--- a/result/XInclude/fallback2.xml.err
+++ b/result/XInclude/fallback2.xml.err
@@ -1,2 +1,2 @@
-I/O error : failed to load "test/XInclude/docs/b.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/c.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/b.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/c.xml": No such file or directory
diff --git a/result/XInclude/fallback4.xml.err b/result/XInclude/fallback4.xml.err
index e27a7e6f..25156776 100644
--- a/result/XInclude/fallback4.xml.err
+++ b/result/XInclude/fallback4.xml.err
@@ -1 +1 @@
-I/O error : failed to load "test/XInclude/docs/c.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/c.xml": No such file or directory
diff --git a/result/XInclude/fallback5.xml.err b/result/XInclude/fallback5.xml.err
index 4ec1892d..f30bc697 100644
--- a/result/XInclude/fallback5.xml.err
+++ b/result/XInclude/fallback5.xml.err
@@ -1,16 +1,16 @@
-I/O error : failed to load "test/XInclude/docs/a01.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a02.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a03.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a04.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a05.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a06.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a07.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a08.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a09.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a10.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a11.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a12.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a13.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a14.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a15.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/a16.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a01.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a02.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a03.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a04.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a05.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a06.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a07.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a08.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a09.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a10.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a11.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a12.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a13.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a14.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a15.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/a16.xml": No such file or directory
diff --git a/result/XInclude/fallback6.xml b/result/XInclude/fallback6.xml
index 2b5d4116..b6e11d73 100644
--- a/result/XInclude/fallback6.xml
+++ b/result/XInclude/fallback6.xml
@@ -1 +1,4 @@
 <?xml version="1.0"?>
+<doc>
+    
+</doc>
diff --git a/result/XInclude/fallback6.xml.err b/result/XInclude/fallback6.xml.err
index d405ac20..288ed212 100644
--- a/result/XInclude/fallback6.xml.err
+++ b/result/XInclude/fallback6.xml.err
@@ -1,2 +1,2 @@
-I/O error : failed to load "test/XInclude/docs/b.xml": No such file or directory
-I/O error : failed to load "test/XInclude/docs/c.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/b.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/docs/c.xml": No such file or directory
diff --git a/result/XInclude/fallback6.xml.rdr b/result/XInclude/fallback6.xml.rdr
new file mode 100644
index 00000000..375f1672
--- /dev/null
+++ b/result/XInclude/fallback6.xml.rdr
@@ -0,0 +1,6 @@
+0 1 doc 0 0
+1 14 #text 0 1 
+    
+1 14 #text 0 1 
+
+0 15 doc 0 0
diff --git a/result/XInclude/fallback7.xml.err b/result/XInclude/fallback7.xml.err
index 3861279f..5acd3ccc 100644
--- a/result/XInclude/fallback7.xml.err
+++ b/result/XInclude/fallback7.xml.err
@@ -1 +1 @@
-I/O error : failed to load "test/XInclude/without-reader/404.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/without-reader/404.xml": No such file or directory
diff --git a/result/XInclude/fallback8.xml b/result/XInclude/fallback8.xml
new file mode 100644
index 00000000..1b2508f8
--- /dev/null
+++ b/result/XInclude/fallback8.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0"?>
+<doc>
+    text not found
+</doc>
diff --git a/result/XInclude/fallback8.xml.err b/result/XInclude/fallback8.xml.err
new file mode 100644
index 00000000..4327677f
--- /dev/null
+++ b/result/XInclude/fallback8.xml.err
@@ -0,0 +1 @@
+I/O warning : failed to load "test/XInclude/docs/404.txt": No such file or directory
diff --git a/result/XInclude/fallback8.xml.rdr b/result/XInclude/fallback8.xml.rdr
new file mode 100644
index 00000000..f99d17e8
--- /dev/null
+++ b/result/XInclude/fallback8.xml.rdr
@@ -0,0 +1,7 @@
+0 1 doc 0 0
+1 14 #text 0 1 
+    
+1 3 #text 0 1 text not found
+1 14 #text 0 1 
+
+0 15 doc 0 0
diff --git a/result/XInclude/issue733.xml b/result/XInclude/issue733.xml
new file mode 100644
index 00000000..808ec42a
--- /dev/null
+++ b/result/XInclude/issue733.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0"?>
+<!DOCTYPE reference>
+<reference xmlns:xi="http://www.w3.org/2001/XInclude">
+    <para id="a" xml:base="../ents/issue733-1.xml">Content 1</para>
+    <para id="a" xml:base="../ents/issue733-2.xml">Content 2</para>
+    
+</reference>
diff --git a/result/XInclude/issue733.xml.rdr b/result/XInclude/issue733.xml.rdr
new file mode 100644
index 00000000..6cd9e6bf
--- /dev/null
+++ b/result/XInclude/issue733.xml.rdr
@@ -0,0 +1,16 @@
+0 1 reference 0 0
+1 14 #text 0 1 
+    
+1 1 para 0 0
+2 3 #text 0 1 Content 1
+1 15 para 0 0
+1 14 #text 0 1 
+    
+1 1 para 0 0
+2 3 #text 0 1 Content 2
+1 15 para 0 0
+1 14 #text 0 1 
+    
+1 14 #text 0 1 
+
+0 15 reference 0 0
diff --git a/result/XInclude/ns1.xml.err b/result/XInclude/ns1.xml.err
index ef202341..d750bc3d 100644
--- a/result/XInclude/ns1.xml.err
+++ b/result/XInclude/ns1.xml.err
@@ -1 +1 @@
-I/O error : failed to load "test/XInclude/without-reader/b.xml": No such file or directory
+I/O warning : failed to load "test/XInclude/without-reader/b.xml": No such file or directory
diff --git a/result/adjacent-cdata.xml b/result/adjacent-cdata.xml
new file mode 100644
index 00000000..fada9eee
--- /dev/null
+++ b/result/adjacent-cdata.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0"?>
+<doc><![CDATA[abc]]><![CDATA[def]]><![CDATA[ghi]]></doc>
diff --git a/result/adjacent-cdata.xml.rde b/result/adjacent-cdata.xml.rde
new file mode 100644
index 00000000..026949e0
--- /dev/null
+++ b/result/adjacent-cdata.xml.rde
@@ -0,0 +1,5 @@
+0 1 doc 0 0
+1 4 #cdata-section 0 1 abc
+1 4 #cdata-section 0 1 def
+1 4 #cdata-section 0 1 ghi
+0 15 doc 0 0
diff --git a/result/adjacent-cdata.xml.rdr b/result/adjacent-cdata.xml.rdr
new file mode 100644
index 00000000..026949e0
--- /dev/null
+++ b/result/adjacent-cdata.xml.rdr
@@ -0,0 +1,5 @@
+0 1 doc 0 0
+1 4 #cdata-section 0 1 abc
+1 4 #cdata-section 0 1 def
+1 4 #cdata-section 0 1 ghi
+0 15 doc 0 0
diff --git a/result/adjacent-cdata.xml.sax b/result/adjacent-cdata.xml.sax
new file mode 100644
index 00000000..c7806da7
--- /dev/null
+++ b/result/adjacent-cdata.xml.sax
@@ -0,0 +1,8 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElement(doc)
+SAX.pcdata(abc, 3)
+SAX.pcdata(def, 3)
+SAX.pcdata(ghi, 3)
+SAX.endElement(doc)
+SAX.endDocument()
diff --git a/result/adjacent-cdata.xml.sax2 b/result/adjacent-cdata.xml.sax2
new file mode 100644
index 00000000..56b4b3b7
--- /dev/null
+++ b/result/adjacent-cdata.xml.sax2
@@ -0,0 +1,8 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElementNs(doc, NULL, NULL, 0, 0, 0)
+SAX.pcdata(abc, 3)
+SAX.pcdata(def, 3)
+SAX.pcdata(ghi, 3)
+SAX.endElementNs(doc, NULL, NULL)
+SAX.endDocument()
diff --git a/result/errors/unsupported-encoding.xml.ent b/result/errors/unsupported-encoding.xml.ent
new file mode 100644
index 00000000..a275ec19
--- /dev/null
+++ b/result/errors/unsupported-encoding.xml.ent
@@ -0,0 +1,3 @@
+./test/errors/unsupported-encoding.xml:1: parser error : Unsupported encoding: unsupported-encoding
+<?xml version="1.0" encoding="unsupported-encoding"?>
+                                                   ^
diff --git a/result/errors/unsupported-encoding.xml.err b/result/errors/unsupported-encoding.xml.err
new file mode 100644
index 00000000..a275ec19
--- /dev/null
+++ b/result/errors/unsupported-encoding.xml.err
@@ -0,0 +1,3 @@
+./test/errors/unsupported-encoding.xml:1: parser error : Unsupported encoding: unsupported-encoding
+<?xml version="1.0" encoding="unsupported-encoding"?>
+                                                   ^
diff --git a/result/errors/unsupported-encoding.xml.str b/result/errors/unsupported-encoding.xml.str
new file mode 100644
index 00000000..1f06d608
--- /dev/null
+++ b/result/errors/unsupported-encoding.xml.str
@@ -0,0 +1,4 @@
+./test/errors/unsupported-encoding.xml:1: parser error : Unsupported encoding: unsupported-encoding
+<?xml version="1.0" encoding="unsupported-encoding"?>
+                                                   ^
+./test/errors/unsupported-encoding.xml : failed to parse
diff --git a/result/intsubset2.xml b/result/intsubset2.xml
index b1039553..af5ddef4 100644
--- a/result/intsubset2.xml
+++ b/result/intsubset2.xml
@@ -1,4 +1,13 @@
 <?xml version="1.0"?>
+<!--
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+-->
 <!DOCTYPE kanjidic2 [
 <!-- Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/result/intsubset2.xml.rde b/result/intsubset2.xml.rde
index d27e245e..d32947c5 100644
--- a/result/intsubset2.xml.rde
+++ b/result/intsubset2.xml.rde
@@ -1,3 +1,12 @@
+0 8 #comment 0 1 
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+
 0 10 kanjidic2 0 0
 0 1 kanjidic2 0 0
 1 14 #text 0 1 
diff --git a/result/intsubset2.xml.rdr b/result/intsubset2.xml.rdr
index d27e245e..d32947c5 100644
--- a/result/intsubset2.xml.rdr
+++ b/result/intsubset2.xml.rdr
@@ -1,3 +1,12 @@
+0 8 #comment 0 1 
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+
 0 10 kanjidic2 0 0
 0 1 kanjidic2 0 0
 1 14 #text 0 1 
diff --git a/result/intsubset2.xml.sax b/result/intsubset2.xml.sax
index b4d7bf46..59112681 100644
--- a/result/intsubset2.xml.sax
+++ b/result/intsubset2.xml.sax
@@ -1,5 +1,14 @@
 SAX.setDocumentLocator()
 SAX.startDocument()
+SAX.comment(
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+)
 SAX.internalSubset(kanjidic2, , )
 SAX.comment( Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/result/intsubset2.xml.sax2 b/result/intsubset2.xml.sax2
index 55587017..2184e56f 100644
--- a/result/intsubset2.xml.sax2
+++ b/result/intsubset2.xml.sax2
@@ -1,5 +1,14 @@
 SAX.setDocumentLocator()
 SAX.startDocument()
+SAX.comment(
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+)
 SAX.internalSubset(kanjidic2, , )
 SAX.comment( Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/result/iso-8859-5.xml b/result/iso-8859-5.xml
new file mode 100644
index 00000000..e6e8b7a8
--- /dev/null
+++ b/result/iso-8859-5.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="ISO-8859-5"?>
+<doc></doc>
diff --git a/result/iso-8859-5.xml.rde b/result/iso-8859-5.xml.rde
new file mode 100644
index 00000000..d235adb5
--- /dev/null
+++ b/result/iso-8859-5.xml.rde
@@ -0,0 +1,3 @@
+0 1 doc 0 0
+1 3 #text 0 1 
+0 15 doc 0 0
diff --git a/result/iso-8859-5.xml.rdr b/result/iso-8859-5.xml.rdr
new file mode 100644
index 00000000..d235adb5
--- /dev/null
+++ b/result/iso-8859-5.xml.rdr
@@ -0,0 +1,3 @@
+0 1 doc 0 0
+1 3 #text 0 1 
+0 15 doc 0 0
diff --git a/result/iso-8859-5.xml.sax b/result/iso-8859-5.xml.sax
new file mode 100644
index 00000000..f91b6827
--- /dev/null
+++ b/result/iso-8859-5.xml.sax
@@ -0,0 +1,6 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElement(doc)
+SAX.characters(, 257)
+SAX.endElement(doc)
+SAX.endDocument()
diff --git a/result/iso-8859-5.xml.sax2 b/result/iso-8859-5.xml.sax2
new file mode 100644
index 00000000..e95bf5ad
--- /dev/null
+++ b/result/iso-8859-5.xml.sax2
@@ -0,0 +1,6 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElementNs(doc, NULL, NULL, 0, 0, 0)
+SAX.characters(, 257)
+SAX.endElementNs(doc, NULL, NULL)
+SAX.endDocument()
diff --git a/result/noent/adjacent-cdata.xml b/result/noent/adjacent-cdata.xml
new file mode 100644
index 00000000..fada9eee
--- /dev/null
+++ b/result/noent/adjacent-cdata.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0"?>
+<doc><![CDATA[abc]]><![CDATA[def]]><![CDATA[ghi]]></doc>
diff --git a/result/noent/adjacent-cdata.xml.sax2 b/result/noent/adjacent-cdata.xml.sax2
new file mode 100644
index 00000000..56b4b3b7
--- /dev/null
+++ b/result/noent/adjacent-cdata.xml.sax2
@@ -0,0 +1,8 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElementNs(doc, NULL, NULL, 0, 0, 0)
+SAX.pcdata(abc, 3)
+SAX.pcdata(def, 3)
+SAX.pcdata(ghi, 3)
+SAX.endElementNs(doc, NULL, NULL)
+SAX.endDocument()
diff --git a/result/noent/intsubset2.xml b/result/noent/intsubset2.xml
index b1039553..af5ddef4 100644
--- a/result/noent/intsubset2.xml
+++ b/result/noent/intsubset2.xml
@@ -1,4 +1,13 @@
 <?xml version="1.0"?>
+<!--
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+-->
 <!DOCTYPE kanjidic2 [
 <!-- Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/result/noent/intsubset2.xml.sax2 b/result/noent/intsubset2.xml.sax2
index 55587017..2184e56f 100644
--- a/result/noent/intsubset2.xml.sax2
+++ b/result/noent/intsubset2.xml.sax2
@@ -1,5 +1,14 @@
 SAX.setDocumentLocator()
 SAX.startDocument()
+SAX.comment(
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+)
 SAX.internalSubset(kanjidic2, , )
 SAX.comment( Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/result/noent/iso-8859-5.xml b/result/noent/iso-8859-5.xml
new file mode 100644
index 00000000..e6e8b7a8
--- /dev/null
+++ b/result/noent/iso-8859-5.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="ISO-8859-5"?>
+<doc></doc>
diff --git a/result/noent/iso-8859-5.xml.sax2 b/result/noent/iso-8859-5.xml.sax2
new file mode 100644
index 00000000..e95bf5ad
--- /dev/null
+++ b/result/noent/iso-8859-5.xml.sax2
@@ -0,0 +1,6 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElementNs(doc, NULL, NULL, 0, 0, 0)
+SAX.characters(, 257)
+SAX.endElementNs(doc, NULL, NULL)
+SAX.endDocument()
diff --git a/result/schemas/570702_0_0 b/result/schemas/570702_0_0.err
similarity index 100%
rename from result/schemas/570702_0_0
rename to result/schemas/570702_0_0.err
diff --git a/result/schemas/579746_0_0 b/result/schemas/579746_0_0.err
similarity index 100%
rename from result/schemas/579746_0_0
rename to result/schemas/579746_0_0.err
diff --git a/result/schemas/579746_0_1 b/result/schemas/579746_0_1.err
similarity index 100%
rename from result/schemas/579746_0_1
rename to result/schemas/579746_0_1.err
diff --git a/result/schemas/579746_0_2 b/result/schemas/579746_0_2.err
similarity index 100%
rename from result/schemas/579746_0_2
rename to result/schemas/579746_0_2.err
diff --git a/result/schemas/579746_0_3 b/result/schemas/579746_0_3
deleted file mode 100644
index cf06bc53..00000000
--- a/result/schemas/579746_0_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/579746_3.xml fails to validate
diff --git a/result/schemas/579746_0_3.err b/result/schemas/579746_0_3.err
index 5b544ba6..1d3a4a5b 100644
--- a/result/schemas/579746_0_3.err
+++ b/result/schemas/579746_0_3.err
@@ -1 +1,2 @@
 ./test/schemas/579746_3.xml:5: Schemas validity error : Element 'customer': This element is not expected.
+./test/schemas/579746_3.xml fails to validate
diff --git a/result/schemas/579746_0_4 b/result/schemas/579746_0_4.err
similarity index 100%
rename from result/schemas/579746_0_4
rename to result/schemas/579746_0_4.err
diff --git a/result/schemas/579746_0_5 b/result/schemas/579746_0_5
deleted file mode 100644
index 91738e4e..00000000
--- a/result/schemas/579746_0_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/579746_5.xml fails to validate
diff --git a/result/schemas/579746_0_5.err b/result/schemas/579746_0_5.err
index e71f94bb..f9499d41 100644
--- a/result/schemas/579746_0_5.err
+++ b/result/schemas/579746_0_5.err
@@ -1 +1,2 @@
 ./test/schemas/579746_5.xml:5: Schemas validity error : Element 'comment': This element is not expected.
+./test/schemas/579746_5.xml fails to validate
diff --git a/result/schemas/579746_1_0 b/result/schemas/579746_1_0.err
similarity index 100%
rename from result/schemas/579746_1_0
rename to result/schemas/579746_1_0.err
diff --git a/result/schemas/579746_1_1 b/result/schemas/579746_1_1.err
similarity index 100%
rename from result/schemas/579746_1_1
rename to result/schemas/579746_1_1.err
diff --git a/result/schemas/579746_1_2 b/result/schemas/579746_1_2.err
similarity index 100%
rename from result/schemas/579746_1_2
rename to result/schemas/579746_1_2.err
diff --git a/result/schemas/579746_1_3 b/result/schemas/579746_1_3
deleted file mode 100644
index cf06bc53..00000000
--- a/result/schemas/579746_1_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/579746_3.xml fails to validate
diff --git a/result/schemas/579746_1_3.err b/result/schemas/579746_1_3.err
index 5b544ba6..1d3a4a5b 100644
--- a/result/schemas/579746_1_3.err
+++ b/result/schemas/579746_1_3.err
@@ -1 +1,2 @@
 ./test/schemas/579746_3.xml:5: Schemas validity error : Element 'customer': This element is not expected.
+./test/schemas/579746_3.xml fails to validate
diff --git a/result/schemas/579746_1_4 b/result/schemas/579746_1_4.err
similarity index 100%
rename from result/schemas/579746_1_4
rename to result/schemas/579746_1_4.err
diff --git a/result/schemas/579746_1_5 b/result/schemas/579746_1_5
deleted file mode 100644
index 91738e4e..00000000
--- a/result/schemas/579746_1_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/579746_5.xml fails to validate
diff --git a/result/schemas/579746_1_5.err b/result/schemas/579746_1_5.err
index e71f94bb..f9499d41 100644
--- a/result/schemas/579746_1_5.err
+++ b/result/schemas/579746_1_5.err
@@ -1 +1,2 @@
 ./test/schemas/579746_5.xml:5: Schemas validity error : Element 'comment': This element is not expected.
+./test/schemas/579746_5.xml fails to validate
diff --git a/result/schemas/582887_0_0 b/result/schemas/582887_0_0.err
similarity index 100%
rename from result/schemas/582887_0_0
rename to result/schemas/582887_0_0.err
diff --git a/result/schemas/582906-1_0_0 b/result/schemas/582906-1_0_0.err
similarity index 100%
rename from result/schemas/582906-1_0_0
rename to result/schemas/582906-1_0_0.err
diff --git a/result/schemas/all1_0_0 b/result/schemas/all1_0_0.err
similarity index 100%
rename from result/schemas/all1_0_0
rename to result/schemas/all1_0_0.err
diff --git a/result/schemas/all_0_0 b/result/schemas/all_0_0.err
similarity index 100%
rename from result/schemas/all_0_0
rename to result/schemas/all_0_0.err
diff --git a/result/schemas/all_0_1 b/result/schemas/all_0_1.err
similarity index 100%
rename from result/schemas/all_0_1
rename to result/schemas/all_0_1.err
diff --git a/result/schemas/all_0_2 b/result/schemas/all_0_2.err
similarity index 100%
rename from result/schemas/all_0_2
rename to result/schemas/all_0_2.err
diff --git a/result/schemas/all_0_3 b/result/schemas/all_0_3
deleted file mode 100644
index 55a2a4da..00000000
--- a/result/schemas/all_0_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_3.xml fails to validate
diff --git a/result/schemas/all_0_3.err b/result/schemas/all_0_3.err
index 1d422a5f..4408f28c 100644
--- a/result/schemas/all_0_3.err
+++ b/result/schemas/all_0_3.err
@@ -1 +1,2 @@
 ./test/schemas/all_3.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is ( c ).
+./test/schemas/all_3.xml fails to validate
diff --git a/result/schemas/all_0_4 b/result/schemas/all_0_4
deleted file mode 100644
index cdd8824b..00000000
--- a/result/schemas/all_0_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_4.xml fails to validate
diff --git a/result/schemas/all_0_4.err b/result/schemas/all_0_4.err
index 94065392..02a733de 100644
--- a/result/schemas/all_0_4.err
+++ b/result/schemas/all_0_4.err
@@ -1 +1,2 @@
 ./test/schemas/all_4.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( a, b, c ).
+./test/schemas/all_4.xml fails to validate
diff --git a/result/schemas/all_0_5 b/result/schemas/all_0_5
deleted file mode 100644
index f939f657..00000000
--- a/result/schemas/all_0_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_0_5.err b/result/schemas/all_0_5.err
index 183c3094..db31ad50 100644
--- a/result/schemas/all_0_5.err
+++ b/result/schemas/all_0_5.err
@@ -1 +1,2 @@
 ./test/schemas/all_5.xml:1: Schemas validity error : Element 'a': This element is not expected. Expected is ( c ).
+./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_0_6 b/result/schemas/all_0_6
deleted file mode 100644
index c3705c75..00000000
--- a/result/schemas/all_0_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_6.xml fails to validate
diff --git a/result/schemas/all_0_6.err b/result/schemas/all_0_6.err
index 7a74825e..11ce1c30 100644
--- a/result/schemas/all_0_6.err
+++ b/result/schemas/all_0_6.err
@@ -1 +1,2 @@
 ./test/schemas/all_6.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( b, c ).
+./test/schemas/all_6.xml fails to validate
diff --git a/result/schemas/all_0_7 b/result/schemas/all_0_7
deleted file mode 100644
index d144d2de..00000000
--- a/result/schemas/all_0_7
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_7.xml fails to validate
diff --git a/result/schemas/all_0_7.err b/result/schemas/all_0_7.err
index 2f4c53f1..64a9c28b 100644
--- a/result/schemas/all_0_7.err
+++ b/result/schemas/all_0_7.err
@@ -1 +1,2 @@
 ./test/schemas/all_7.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is ( c ).
+./test/schemas/all_7.xml fails to validate
diff --git a/result/schemas/all_1_0 b/result/schemas/all_1_0.err
similarity index 100%
rename from result/schemas/all_1_0
rename to result/schemas/all_1_0.err
diff --git a/result/schemas/all_1_1 b/result/schemas/all_1_1.err
similarity index 100%
rename from result/schemas/all_1_1
rename to result/schemas/all_1_1.err
diff --git a/result/schemas/all_1_2 b/result/schemas/all_1_2.err
similarity index 100%
rename from result/schemas/all_1_2
rename to result/schemas/all_1_2.err
diff --git a/result/schemas/all_1_3 b/result/schemas/all_1_3
deleted file mode 100644
index 55a2a4da..00000000
--- a/result/schemas/all_1_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_3.xml fails to validate
diff --git a/result/schemas/all_1_3.err b/result/schemas/all_1_3.err
index 1d422a5f..4408f28c 100644
--- a/result/schemas/all_1_3.err
+++ b/result/schemas/all_1_3.err
@@ -1 +1,2 @@
 ./test/schemas/all_3.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is ( c ).
+./test/schemas/all_3.xml fails to validate
diff --git a/result/schemas/all_1_4 b/result/schemas/all_1_4.err
similarity index 100%
rename from result/schemas/all_1_4
rename to result/schemas/all_1_4.err
diff --git a/result/schemas/all_1_5 b/result/schemas/all_1_5
deleted file mode 100644
index f939f657..00000000
--- a/result/schemas/all_1_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_1_5.err b/result/schemas/all_1_5.err
index 183c3094..db31ad50 100644
--- a/result/schemas/all_1_5.err
+++ b/result/schemas/all_1_5.err
@@ -1 +1,2 @@
 ./test/schemas/all_5.xml:1: Schemas validity error : Element 'a': This element is not expected. Expected is ( c ).
+./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_1_6 b/result/schemas/all_1_6
deleted file mode 100644
index c3705c75..00000000
--- a/result/schemas/all_1_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_6.xml fails to validate
diff --git a/result/schemas/all_1_6.err b/result/schemas/all_1_6.err
index 7a74825e..11ce1c30 100644
--- a/result/schemas/all_1_6.err
+++ b/result/schemas/all_1_6.err
@@ -1 +1,2 @@
 ./test/schemas/all_6.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( b, c ).
+./test/schemas/all_6.xml fails to validate
diff --git a/result/schemas/all_1_7 b/result/schemas/all_1_7
deleted file mode 100644
index d144d2de..00000000
--- a/result/schemas/all_1_7
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_7.xml fails to validate
diff --git a/result/schemas/all_1_7.err b/result/schemas/all_1_7.err
index 2f4c53f1..64a9c28b 100644
--- a/result/schemas/all_1_7.err
+++ b/result/schemas/all_1_7.err
@@ -1 +1,2 @@
 ./test/schemas/all_7.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is ( c ).
+./test/schemas/all_7.xml fails to validate
diff --git a/result/schemas/all_2_0 b/result/schemas/all_2_0
deleted file mode 100644
index 77066e03..00000000
--- a/result/schemas/all_2_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_0.xml fails to validate
diff --git a/result/schemas/all_2_0.err b/result/schemas/all_2_0.err
index bf439446..378cb7da 100644
--- a/result/schemas/all_2_0.err
+++ b/result/schemas/all_2_0.err
@@ -1 +1,2 @@
 ./test/schemas/all_0.xml:1: Schemas validity error : Element 'c': This element is not expected.
+./test/schemas/all_0.xml fails to validate
diff --git a/result/schemas/all_2_1 b/result/schemas/all_2_1
deleted file mode 100644
index cbda1fe8..00000000
--- a/result/schemas/all_2_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_1.xml fails to validate
diff --git a/result/schemas/all_2_1.err b/result/schemas/all_2_1.err
index fc12152e..27d90c85 100644
--- a/result/schemas/all_2_1.err
+++ b/result/schemas/all_2_1.err
@@ -1 +1,2 @@
 ./test/schemas/all_1.xml:1: Schemas validity error : Element 'c': This element is not expected. Expected is ( a ).
+./test/schemas/all_1.xml fails to validate
diff --git a/result/schemas/all_2_2 b/result/schemas/all_2_2
deleted file mode 100644
index 27db6438..00000000
--- a/result/schemas/all_2_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_2.xml fails to validate
diff --git a/result/schemas/all_2_2.err b/result/schemas/all_2_2.err
index 8e56a78b..77dd52da 100644
--- a/result/schemas/all_2_2.err
+++ b/result/schemas/all_2_2.err
@@ -1 +1,2 @@
 ./test/schemas/all_2.xml:1: Schemas validity error : Element 'c': This element is not expected.
+./test/schemas/all_2.xml fails to validate
diff --git a/result/schemas/all_2_3 b/result/schemas/all_2_3.err
similarity index 100%
rename from result/schemas/all_2_3
rename to result/schemas/all_2_3.err
diff --git a/result/schemas/all_2_4 b/result/schemas/all_2_4
deleted file mode 100644
index cdd8824b..00000000
--- a/result/schemas/all_2_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_4.xml fails to validate
diff --git a/result/schemas/all_2_4.err b/result/schemas/all_2_4.err
index 717e0428..75b09cdd 100644
--- a/result/schemas/all_2_4.err
+++ b/result/schemas/all_2_4.err
@@ -1 +1,2 @@
 ./test/schemas/all_4.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( a, b ).
+./test/schemas/all_4.xml fails to validate
diff --git a/result/schemas/all_2_5 b/result/schemas/all_2_5
deleted file mode 100644
index f939f657..00000000
--- a/result/schemas/all_2_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_2_5.err b/result/schemas/all_2_5.err
index 42ea79a2..6bcea2aa 100644
--- a/result/schemas/all_2_5.err
+++ b/result/schemas/all_2_5.err
@@ -1 +1,2 @@
 ./test/schemas/all_5.xml:1: Schemas validity error : Element 'a': This element is not expected.
+./test/schemas/all_5.xml fails to validate
diff --git a/result/schemas/all_2_6 b/result/schemas/all_2_6.err
similarity index 100%
rename from result/schemas/all_2_6
rename to result/schemas/all_2_6.err
diff --git a/result/schemas/all_2_7 b/result/schemas/all_2_7.err
similarity index 100%
rename from result/schemas/all_2_7
rename to result/schemas/all_2_7.err
diff --git a/result/schemas/allsg_0_0 b/result/schemas/allsg_0_0.err
similarity index 100%
rename from result/schemas/allsg_0_0
rename to result/schemas/allsg_0_0.err
diff --git a/result/schemas/allsg_0_1 b/result/schemas/allsg_0_1.err
similarity index 100%
rename from result/schemas/allsg_0_1
rename to result/schemas/allsg_0_1.err
diff --git a/result/schemas/allsg_0_2 b/result/schemas/allsg_0_2.err
similarity index 100%
rename from result/schemas/allsg_0_2
rename to result/schemas/allsg_0_2.err
diff --git a/result/schemas/allsg_0_3 b/result/schemas/allsg_0_3
deleted file mode 100644
index f98152b4..00000000
--- a/result/schemas/allsg_0_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/allsg_3.xml fails to validate
diff --git a/result/schemas/allsg_0_3.err b/result/schemas/allsg_0_3.err
index 57dd594b..f2d3011b 100644
--- a/result/schemas/allsg_0_3.err
+++ b/result/schemas/allsg_0_3.err
@@ -1 +1,2 @@
 ./test/schemas/allsg_3.xml:6: Schemas validity error : Element '{urn:test:foo}gm-B-1': This element is not expected. Expected is one of ( {urn:test:foo}gh-A, {urn:test:foo}gm-A-1, {urn:test:foo}gm-A-2 ).
+./test/schemas/allsg_3.xml fails to validate
diff --git a/result/schemas/allsg_0_4 b/result/schemas/allsg_0_4
deleted file mode 100644
index 3fe69c1c..00000000
--- a/result/schemas/allsg_0_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/allsg_4.xml fails to validate
diff --git a/result/schemas/allsg_0_4.err b/result/schemas/allsg_0_4.err
index 558f9846..9e400c7e 100644
--- a/result/schemas/allsg_0_4.err
+++ b/result/schemas/allsg_0_4.err
@@ -1 +1,2 @@
 ./test/schemas/allsg_4.xml:6: Schemas validity error : Element '{urn:test:foo}gm-A-1': This element is not expected. Expected is one of ( {urn:test:foo}gh-B, {urn:test:foo}gm-B-1, {urn:test:foo}gm-B-2 ).
+./test/schemas/allsg_4.xml fails to validate
diff --git a/result/schemas/allsg_0_5 b/result/schemas/allsg_0_5
deleted file mode 100644
index 2689cf0f..00000000
--- a/result/schemas/allsg_0_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/allsg_5.xml fails to validate
diff --git a/result/schemas/allsg_0_5.err b/result/schemas/allsg_0_5.err
index f428fd64..f6b9dfcf 100644
--- a/result/schemas/allsg_0_5.err
+++ b/result/schemas/allsg_0_5.err
@@ -1 +1,2 @@
 ./test/schemas/allsg_5.xml:7: Schemas validity error : Element '{urn:test:foo}gm-B-2': This element is not expected.
+./test/schemas/allsg_5.xml fails to validate
diff --git a/result/schemas/any1_0_0 b/result/schemas/any1_0_0.err
similarity index 100%
rename from result/schemas/any1_0_0
rename to result/schemas/any1_0_0.err
diff --git a/result/schemas/any2_0_0 b/result/schemas/any2_0_0.err
similarity index 100%
rename from result/schemas/any2_0_0
rename to result/schemas/any2_0_0.err
diff --git a/result/schemas/any3_0_0 b/result/schemas/any3_0_0
deleted file mode 100644
index 568af4f2..00000000
--- a/result/schemas/any3_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any3_0.xml fails to validate
diff --git a/result/schemas/any3_0_0.err b/result/schemas/any3_0_0.err
index ee4ca24b..ff3811c2 100644
--- a/result/schemas/any3_0_0.err
+++ b/result/schemas/any3_0_0.err
@@ -1 +1,2 @@
 ./test/schemas/any3_0.xml:12: Schemas validity error : Element 'bar.A': This element is not expected. Expected is ( ##other{http://FOO}* ).
+./test/schemas/any3_0.xml fails to validate
diff --git a/result/schemas/any5_0_0 b/result/schemas/any5_0_0
deleted file mode 100644
index 910f8bbd..00000000
--- a/result/schemas/any5_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_0.xml fails to validate
diff --git a/result/schemas/any5_0_0.err b/result/schemas/any5_0_0.err
index 72b39a9e..36a02fc2 100644
--- a/result/schemas/any5_0_0.err
+++ b/result/schemas/any5_0_0.err
@@ -1 +1,2 @@
 ./test/schemas/any5_0.xml:6: Schemas validity error : Element '{urn:test:foo}boo': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any5_0.xml fails to validate
diff --git a/result/schemas/any5_0_1 b/result/schemas/any5_0_1
deleted file mode 100644
index 5e2c461d..00000000
--- a/result/schemas/any5_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_1.xml fails to validate
diff --git a/result/schemas/any5_0_1.err b/result/schemas/any5_0_1.err
index 52c53a84..2e3c48fa 100644
--- a/result/schemas/any5_0_1.err
+++ b/result/schemas/any5_0_1.err
@@ -1 +1,2 @@
 ./test/schemas/any5_1.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected.
+./test/schemas/any5_1.xml fails to validate
diff --git a/result/schemas/any5_0_2 b/result/schemas/any5_0_2
deleted file mode 100644
index b049478c..00000000
--- a/result/schemas/any5_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_2.xml fails to validate
diff --git a/result/schemas/any5_0_2.err b/result/schemas/any5_0_2.err
index cd23a02e..1b548035 100644
--- a/result/schemas/any5_0_2.err
+++ b/result/schemas/any5_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/any5_2.xml:7: Schemas validity error : Element '{urn:test:foo}boo': This element is not expected.
+./test/schemas/any5_2.xml fails to validate
diff --git a/result/schemas/any5_0_3 b/result/schemas/any5_0_3.err
similarity index 100%
rename from result/schemas/any5_0_3
rename to result/schemas/any5_0_3.err
diff --git a/result/schemas/any5_0_4 b/result/schemas/any5_0_4
deleted file mode 100644
index 0a4bce06..00000000
--- a/result/schemas/any5_0_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_4.xml fails to validate
diff --git a/result/schemas/any5_0_4.err b/result/schemas/any5_0_4.err
index 6ec962c0..bd23cb27 100644
--- a/result/schemas/any5_0_4.err
+++ b/result/schemas/any5_0_4.err
@@ -1 +1,2 @@
 ./test/schemas/any5_4.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected.
+./test/schemas/any5_4.xml fails to validate
diff --git a/result/schemas/any5_0_5 b/result/schemas/any5_0_5
deleted file mode 100644
index 6c15d25d..00000000
--- a/result/schemas/any5_0_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_5.xml fails to validate
diff --git a/result/schemas/any5_0_5.err b/result/schemas/any5_0_5.err
index e777721a..cee4a50d 100644
--- a/result/schemas/any5_0_5.err
+++ b/result/schemas/any5_0_5.err
@@ -1 +1,2 @@
 ./test/schemas/any5_5.xml:11: Schemas validity error : Element '{urn:test:foo}boo': This element is not expected.
+./test/schemas/any5_5.xml fails to validate
diff --git a/result/schemas/any5_0_6 b/result/schemas/any5_0_6
deleted file mode 100644
index c9df5626..00000000
--- a/result/schemas/any5_0_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_6.xml fails to validate
diff --git a/result/schemas/any5_0_6.err b/result/schemas/any5_0_6.err
index 4998a4ef..aba22d1e 100644
--- a/result/schemas/any5_0_6.err
+++ b/result/schemas/any5_0_6.err
@@ -1 +1,2 @@
 ./test/schemas/any5_6.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected.
+./test/schemas/any5_6.xml fails to validate
diff --git a/result/schemas/any5_1_0 b/result/schemas/any5_1_0
deleted file mode 100644
index 910f8bbd..00000000
--- a/result/schemas/any5_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_0.xml fails to validate
diff --git a/result/schemas/any5_1_0.err b/result/schemas/any5_1_0.err
index 72b39a9e..36a02fc2 100644
--- a/result/schemas/any5_1_0.err
+++ b/result/schemas/any5_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/any5_0.xml:6: Schemas validity error : Element '{urn:test:foo}boo': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any5_0.xml fails to validate
diff --git a/result/schemas/any5_1_1 b/result/schemas/any5_1_1
deleted file mode 100644
index 5e2c461d..00000000
--- a/result/schemas/any5_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_1.xml fails to validate
diff --git a/result/schemas/any5_1_1.err b/result/schemas/any5_1_1.err
index 9a17c9ea..c3210785 100644
--- a/result/schemas/any5_1_1.err
+++ b/result/schemas/any5_1_1.err
@@ -1 +1,2 @@
 ./test/schemas/any5_1.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected. Expected is ( {urn:test:foo}boo ).
+./test/schemas/any5_1.xml fails to validate
diff --git a/result/schemas/any5_1_2 b/result/schemas/any5_1_2.err
similarity index 100%
rename from result/schemas/any5_1_2
rename to result/schemas/any5_1_2.err
diff --git a/result/schemas/any5_1_3 b/result/schemas/any5_1_3
deleted file mode 100644
index f114a670..00000000
--- a/result/schemas/any5_1_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_3.xml fails to validate
diff --git a/result/schemas/any5_1_3.err b/result/schemas/any5_1_3.err
index f823ee37..60dfdd0b 100644
--- a/result/schemas/any5_1_3.err
+++ b/result/schemas/any5_1_3.err
@@ -1 +1,2 @@
 ./test/schemas/any5_3.xml:4: Schemas validity error : Element '{urn:test:foo}foo': Missing child element(s).
+./test/schemas/any5_3.xml fails to validate
diff --git a/result/schemas/any5_1_4 b/result/schemas/any5_1_4
deleted file mode 100644
index 0a4bce06..00000000
--- a/result/schemas/any5_1_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_4.xml fails to validate
diff --git a/result/schemas/any5_1_4.err b/result/schemas/any5_1_4.err
index 9f02329a..feb367c6 100644
--- a/result/schemas/any5_1_4.err
+++ b/result/schemas/any5_1_4.err
@@ -1 +1,2 @@
 ./test/schemas/any5_4.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected. Expected is ( {urn:test:foo}boo ).
+./test/schemas/any5_4.xml fails to validate
diff --git a/result/schemas/any5_1_5 b/result/schemas/any5_1_5.err
similarity index 100%
rename from result/schemas/any5_1_5
rename to result/schemas/any5_1_5.err
diff --git a/result/schemas/any5_1_6 b/result/schemas/any5_1_6
deleted file mode 100644
index c9df5626..00000000
--- a/result/schemas/any5_1_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any5_6.xml fails to validate
diff --git a/result/schemas/any5_1_6.err b/result/schemas/any5_1_6.err
index e090bc35..978fdde3 100644
--- a/result/schemas/any5_1_6.err
+++ b/result/schemas/any5_1_6.err
@@ -1 +1,2 @@
 ./test/schemas/any5_6.xml:11: Schemas validity error : Element '{urn:test:bar}boo': This element is not expected. Expected is ( {urn:test:foo}boo ).
+./test/schemas/any5_6.xml fails to validate
diff --git a/result/schemas/any6_1_0 b/result/schemas/any6_1_0.err
similarity index 100%
rename from result/schemas/any6_1_0
rename to result/schemas/any6_1_0.err
diff --git a/result/schemas/any6_2_0 b/result/schemas/any6_2_0.err
similarity index 100%
rename from result/schemas/any6_2_0
rename to result/schemas/any6_2_0.err
diff --git a/result/schemas/any7_1_0 b/result/schemas/any7_1_0
deleted file mode 100644
index cfd9dccb..00000000
--- a/result/schemas/any7_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any7_0.xml fails to validate
diff --git a/result/schemas/any7_1_0.err b/result/schemas/any7_1_0.err
index 208c8a6f..0d73e8ab 100644
--- a/result/schemas/any7_1_0.err
+++ b/result/schemas/any7_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/any7_0.xml:18: Schemas validity error : Element 'moo': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any7_0.xml fails to validate
diff --git a/result/schemas/any7_1_1 b/result/schemas/any7_1_1
deleted file mode 100644
index 2a6f5d7d..00000000
--- a/result/schemas/any7_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any7_1.xml fails to validate
diff --git a/result/schemas/any7_1_1.err b/result/schemas/any7_1_1.err
index 440d6a58..13543f06 100644
--- a/result/schemas/any7_1_1.err
+++ b/result/schemas/any7_1_1.err
@@ -1 +1,2 @@
 ./test/schemas/any7_1.xml:17: Schemas validity error : Element '{urn:test:foo}bar': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any7_1.xml fails to validate
diff --git a/result/schemas/any7_1_2 b/result/schemas/any7_1_2.err
similarity index 100%
rename from result/schemas/any7_1_2
rename to result/schemas/any7_1_2.err
diff --git a/result/schemas/any7_2_0 b/result/schemas/any7_2_0
deleted file mode 100644
index cfd9dccb..00000000
--- a/result/schemas/any7_2_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any7_0.xml fails to validate
diff --git a/result/schemas/any7_2_0.err b/result/schemas/any7_2_0.err
index 208c8a6f..0d73e8ab 100644
--- a/result/schemas/any7_2_0.err
+++ b/result/schemas/any7_2_0.err
@@ -1 +1,2 @@
 ./test/schemas/any7_0.xml:18: Schemas validity error : Element 'moo': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any7_0.xml fails to validate
diff --git a/result/schemas/any7_2_1 b/result/schemas/any7_2_1
deleted file mode 100644
index 2a6f5d7d..00000000
--- a/result/schemas/any7_2_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/any7_1.xml fails to validate
diff --git a/result/schemas/any7_2_1.err b/result/schemas/any7_2_1.err
index 440d6a58..13543f06 100644
--- a/result/schemas/any7_2_1.err
+++ b/result/schemas/any7_2_1.err
@@ -1 +1,2 @@
 ./test/schemas/any7_1.xml:17: Schemas validity error : Element '{urn:test:foo}bar': This element is not expected. Expected is ( ##other{urn:test:foo}* ).
+./test/schemas/any7_1.xml fails to validate
diff --git a/result/schemas/any7_2_2 b/result/schemas/any7_2_2.err
similarity index 100%
rename from result/schemas/any7_2_2
rename to result/schemas/any7_2_2.err
diff --git a/result/schemas/any8_1_0 b/result/schemas/any8_1_0.err
similarity index 100%
rename from result/schemas/any8_1_0
rename to result/schemas/any8_1_0.err
diff --git a/result/schemas/anyAttr-derive-errors1_0_0 b/result/schemas/anyAttr-derive-errors1_0_0.err
similarity index 100%
rename from result/schemas/anyAttr-derive-errors1_0_0
rename to result/schemas/anyAttr-derive-errors1_0_0.err
diff --git a/result/schemas/anyAttr-derive1_0_0 b/result/schemas/anyAttr-derive1_0_0.err
similarity index 100%
rename from result/schemas/anyAttr-derive1_0_0
rename to result/schemas/anyAttr-derive1_0_0.err
diff --git a/result/schemas/anyAttr-derive2_0_0 b/result/schemas/anyAttr-derive2_0_0.err
similarity index 100%
rename from result/schemas/anyAttr-derive2_0_0
rename to result/schemas/anyAttr-derive2_0_0.err
diff --git a/result/schemas/anyAttr-processContents-err1_0_0 b/result/schemas/anyAttr-processContents-err1_0_0
deleted file mode 100644
index 43e77aac..00000000
--- a/result/schemas/anyAttr-processContents-err1_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/anyAttr-processContents-err1_0.xml fails to validate
diff --git a/result/schemas/anyAttr-processContents-err1_0_0.err b/result/schemas/anyAttr-processContents-err1_0_0.err
index f1a6023b..66b7ec8c 100644
--- a/result/schemas/anyAttr-processContents-err1_0_0.err
+++ b/result/schemas/anyAttr-processContents-err1_0_0.err
@@ -1,2 +1,3 @@
 ./test/schemas/anyAttr-processContents-err1_0.xml:8: Schemas validity error : Element '{http://FOO}elem.lax', attribute '{http://FOO}bar': 'o o' is not a valid value of the atomic type 'xs:language'.
 ./test/schemas/anyAttr-processContents-err1_0.xml:9: Schemas validity error : Element '{http://FOO}elem.strict', attribute '{http://FOO}barB': No matching global attribute declaration available, but demanded by the strict wildcard.
+./test/schemas/anyAttr-processContents-err1_0.xml fails to validate
diff --git a/result/schemas/anyAttr-processContents1_0_0 b/result/schemas/anyAttr-processContents1_0_0.err
similarity index 100%
rename from result/schemas/anyAttr-processContents1_0_0
rename to result/schemas/anyAttr-processContents1_0_0.err
diff --git a/result/schemas/anyAttr1_0_0 b/result/schemas/anyAttr1_0_0.err
similarity index 100%
rename from result/schemas/anyAttr1_0_0
rename to result/schemas/anyAttr1_0_0.err
diff --git a/result/schemas/attr0_0_0 b/result/schemas/attr0_0_0.err
similarity index 100%
rename from result/schemas/attr0_0_0
rename to result/schemas/attr0_0_0.err
diff --git a/result/schemas/attruse_0_0 b/result/schemas/attruse_0_0.err
similarity index 100%
rename from result/schemas/attruse_0_0
rename to result/schemas/attruse_0_0.err
diff --git a/result/schemas/attruse_0_1 b/result/schemas/attruse_0_1
deleted file mode 100644
index dd23d0ba..00000000
--- a/result/schemas/attruse_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/attruse_0_1.xml fails to validate
diff --git a/result/schemas/attruse_0_1.err b/result/schemas/attruse_0_1.err
index 6795f8f2..7814b2db 100644
--- a/result/schemas/attruse_0_1.err
+++ b/result/schemas/attruse_0_1.err
@@ -1 +1,2 @@
 ./test/schemas/attruse_0_1.xml:3: Schemas validity error : Element 'barA': The attribute 'attr' is required but missing.
+./test/schemas/attruse_0_1.xml fails to validate
diff --git a/result/schemas/attruse_0_2 b/result/schemas/attruse_0_2
deleted file mode 100644
index 0ea33018..00000000
--- a/result/schemas/attruse_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/attruse_0_2.xml fails to validate
diff --git a/result/schemas/attruse_0_2.err b/result/schemas/attruse_0_2.err
index d09a2ae9..e4f5419a 100644
--- a/result/schemas/attruse_0_2.err
+++ b/result/schemas/attruse_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/attruse_0_2.xml:6: Schemas validity error : Element 'barC', attribute 'attr': The attribute 'attr' is not allowed.
+./test/schemas/attruse_0_2.xml fails to validate
diff --git a/result/schemas/bug141312_0_0 b/result/schemas/bug141312_0_0.err
similarity index 100%
rename from result/schemas/bug141312_0_0
rename to result/schemas/bug141312_0_0.err
diff --git a/result/schemas/bug141333_0_0 b/result/schemas/bug141333_0_0.err
similarity index 100%
rename from result/schemas/bug141333_0_0
rename to result/schemas/bug141333_0_0.err
diff --git a/result/schemas/bug143951_0_0 b/result/schemas/bug143951_0_0.err
similarity index 100%
rename from result/schemas/bug143951_0_0
rename to result/schemas/bug143951_0_0.err
diff --git a/result/schemas/bug145246_0_0 b/result/schemas/bug145246_0_0.err
similarity index 100%
rename from result/schemas/bug145246_0_0
rename to result/schemas/bug145246_0_0.err
diff --git a/result/schemas/bug152470_1_1 b/result/schemas/bug152470_1_1.err
similarity index 100%
rename from result/schemas/bug152470_1_1
rename to result/schemas/bug152470_1_1.err
diff --git a/result/schemas/bug167754_0_0 b/result/schemas/bug167754_0_0.err
similarity index 100%
rename from result/schemas/bug167754_0_0
rename to result/schemas/bug167754_0_0.err
diff --git a/result/schemas/bug303566_1_1 b/result/schemas/bug303566_1_1
deleted file mode 100644
index 8092bf0c..00000000
--- a/result/schemas/bug303566_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/bug303566_1.xml fails to validate
diff --git a/result/schemas/bug303566_1_1.err b/result/schemas/bug303566_1_1.err
index 91569815..ad50e067 100644
--- a/result/schemas/bug303566_1_1.err
+++ b/result/schemas/bug303566_1_1.err
@@ -1 +1,2 @@
 ./test/schemas/bug303566_1.xml:9: Schemas validity error : Element 'Part': No match found for key-sequence ['B'] of keyref 'PartRefCountryDummy'.
+./test/schemas/bug303566_1.xml fails to validate
diff --git a/result/schemas/bug306806_1_0 b/result/schemas/bug306806_1_0.err
similarity index 100%
rename from result/schemas/bug306806_1_0
rename to result/schemas/bug306806_1_0.err
diff --git a/result/schemas/bug309338_1_0 b/result/schemas/bug309338_1_0.err
similarity index 100%
rename from result/schemas/bug309338_1_0
rename to result/schemas/bug309338_1_0.err
diff --git a/result/schemas/bug310264_0_0 b/result/schemas/bug310264_0_0.err
similarity index 100%
rename from result/schemas/bug310264_0_0
rename to result/schemas/bug310264_0_0.err
diff --git a/result/schemas/bug312957_1_0 b/result/schemas/bug312957_1_0
deleted file mode 100644
index 1ec62695..00000000
--- a/result/schemas/bug312957_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/bug312957_0.xml fails to validate
diff --git a/result/schemas/bug312957_1_0.err b/result/schemas/bug312957_1_0.err
index 40e58ff9..390dd85d 100644
--- a/result/schemas/bug312957_1_0.err
+++ b/result/schemas/bug312957_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/bug312957_0.xml:10: Schemas validity error : Element 'sister': No match found for key-sequence ['annie'] of keyref 'sibling_key_ref'.
+./test/schemas/bug312957_0.xml fails to validate
diff --git a/result/schemas/bug313982_0_0 b/result/schemas/bug313982_0_0.err
similarity index 100%
rename from result/schemas/bug313982_0_0
rename to result/schemas/bug313982_0_0.err
diff --git a/result/schemas/bug321475_1_0 b/result/schemas/bug321475_1_0.err
similarity index 100%
rename from result/schemas/bug321475_1_0
rename to result/schemas/bug321475_1_0.err
diff --git a/result/schemas/bug322411_1_0 b/result/schemas/bug322411_1_0.err
similarity index 100%
rename from result/schemas/bug322411_1_0
rename to result/schemas/bug322411_1_0.err
diff --git a/result/schemas/bug323510_1_0 b/result/schemas/bug323510_1_0
deleted file mode 100644
index c33d685d..00000000
--- a/result/schemas/bug323510_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/bug323510_0.xml fails to validate
diff --git a/result/schemas/bug323510_1_0.err b/result/schemas/bug323510_1_0.err
index 0488ef81..84192934 100644
--- a/result/schemas/bug323510_1_0.err
+++ b/result/schemas/bug323510_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/bug323510_0.xml:2: Schemas validity error : Element 'foo': Missing child element(s). Expected is ( bar ).
+./test/schemas/bug323510_0.xml fails to validate
diff --git a/result/schemas/bug455953_0_0 b/result/schemas/bug455953_0_0.err
similarity index 100%
rename from result/schemas/bug455953_0_0
rename to result/schemas/bug455953_0_0.err
diff --git a/result/schemas/changelog093_1_0 b/result/schemas/changelog093_1_0
deleted file mode 100644
index 13f83ef7..00000000
--- a/result/schemas/changelog093_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/changelog093_0.xml fails to validate
diff --git a/result/schemas/changelog093_1_0.err b/result/schemas/changelog093_1_0.err
index 344a156f..d031e1c5 100644
--- a/result/schemas/changelog093_1_0.err
+++ b/result/schemas/changelog093_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/changelog093_0.xml:7: Schemas validity error : Element '{http://www.blackperl.com/XML/ChangeLog}description': Duplicate key-sequence ['PL'] in unique identity-constraint '{http://www.blackperl.com/XML/ChangeLog}changelogDescriptionLangConstraint'.
+./test/schemas/changelog093_0.xml fails to validate
diff --git a/result/schemas/choice_0_0 b/result/schemas/choice_0_0.err
similarity index 100%
rename from result/schemas/choice_0_0
rename to result/schemas/choice_0_0.err
diff --git a/result/schemas/choice_0_1 b/result/schemas/choice_0_1.err
similarity index 100%
rename from result/schemas/choice_0_1
rename to result/schemas/choice_0_1.err
diff --git a/result/schemas/choice_0_2 b/result/schemas/choice_0_2
deleted file mode 100644
index 40713158..00000000
--- a/result/schemas/choice_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_2.xml fails to validate
diff --git a/result/schemas/choice_0_2.err b/result/schemas/choice_0_2.err
index 37344b1b..1b294c5a 100644
--- a/result/schemas/choice_0_2.err
+++ b/result/schemas/choice_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/choice_2.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_2.xml fails to validate
diff --git a/result/schemas/choice_0_3 b/result/schemas/choice_0_3
deleted file mode 100644
index bef604b9..00000000
--- a/result/schemas/choice_0_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_3.xml fails to validate
diff --git a/result/schemas/choice_0_3.err b/result/schemas/choice_0_3.err
index 57d3728a..c6e06819 100644
--- a/result/schemas/choice_0_3.err
+++ b/result/schemas/choice_0_3.err
@@ -1 +1,2 @@
 ./test/schemas/choice_3.xml:3: Schemas validity error : Element 'a': This element is not expected.
+./test/schemas/choice_3.xml fails to validate
diff --git a/result/schemas/choice_0_4 b/result/schemas/choice_0_4
deleted file mode 100644
index 0643e3b2..00000000
--- a/result/schemas/choice_0_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_4.xml fails to validate
diff --git a/result/schemas/choice_0_4.err b/result/schemas/choice_0_4.err
index 273f170e..ea063ccf 100644
--- a/result/schemas/choice_0_4.err
+++ b/result/schemas/choice_0_4.err
@@ -1 +1,2 @@
 ./test/schemas/choice_4.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( a, b ).
+./test/schemas/choice_4.xml fails to validate
diff --git a/result/schemas/choice_0_5 b/result/schemas/choice_0_5
deleted file mode 100644
index acaaddd8..00000000
--- a/result/schemas/choice_0_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_5.xml fails to validate
diff --git a/result/schemas/choice_0_5.err b/result/schemas/choice_0_5.err
index 3a0f40ac..ef8b0aa1 100644
--- a/result/schemas/choice_0_5.err
+++ b/result/schemas/choice_0_5.err
@@ -1 +1,2 @@
 ./test/schemas/choice_5.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_5.xml fails to validate
diff --git a/result/schemas/choice_0_6 b/result/schemas/choice_0_6
deleted file mode 100644
index ee4ceaef..00000000
--- a/result/schemas/choice_0_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/choice_0_6.err b/result/schemas/choice_0_6.err
index 270c1fff..0e8157c5 100644
--- a/result/schemas/choice_0_6.err
+++ b/result/schemas/choice_0_6.err
@@ -1 +1,2 @@
 ./test/schemas/choice_6.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/choice_1_0 b/result/schemas/choice_1_0.err
similarity index 100%
rename from result/schemas/choice_1_0
rename to result/schemas/choice_1_0.err
diff --git a/result/schemas/choice_1_1 b/result/schemas/choice_1_1.err
similarity index 100%
rename from result/schemas/choice_1_1
rename to result/schemas/choice_1_1.err
diff --git a/result/schemas/choice_1_2 b/result/schemas/choice_1_2
deleted file mode 100644
index 40713158..00000000
--- a/result/schemas/choice_1_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_2.xml fails to validate
diff --git a/result/schemas/choice_1_2.err b/result/schemas/choice_1_2.err
index 37344b1b..1b294c5a 100644
--- a/result/schemas/choice_1_2.err
+++ b/result/schemas/choice_1_2.err
@@ -1 +1,2 @@
 ./test/schemas/choice_2.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_2.xml fails to validate
diff --git a/result/schemas/choice_1_3 b/result/schemas/choice_1_3
deleted file mode 100644
index bef604b9..00000000
--- a/result/schemas/choice_1_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_3.xml fails to validate
diff --git a/result/schemas/choice_1_3.err b/result/schemas/choice_1_3.err
index 57d3728a..c6e06819 100644
--- a/result/schemas/choice_1_3.err
+++ b/result/schemas/choice_1_3.err
@@ -1 +1,2 @@
 ./test/schemas/choice_3.xml:3: Schemas validity error : Element 'a': This element is not expected.
+./test/schemas/choice_3.xml fails to validate
diff --git a/result/schemas/choice_1_4 b/result/schemas/choice_1_4.err
similarity index 100%
rename from result/schemas/choice_1_4
rename to result/schemas/choice_1_4.err
diff --git a/result/schemas/choice_1_5 b/result/schemas/choice_1_5
deleted file mode 100644
index acaaddd8..00000000
--- a/result/schemas/choice_1_5
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_5.xml fails to validate
diff --git a/result/schemas/choice_1_5.err b/result/schemas/choice_1_5.err
index 3a0f40ac..ef8b0aa1 100644
--- a/result/schemas/choice_1_5.err
+++ b/result/schemas/choice_1_5.err
@@ -1 +1,2 @@
 ./test/schemas/choice_5.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_5.xml fails to validate
diff --git a/result/schemas/choice_1_6 b/result/schemas/choice_1_6
deleted file mode 100644
index ee4ceaef..00000000
--- a/result/schemas/choice_1_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/choice_1_6.err b/result/schemas/choice_1_6.err
index 270c1fff..0e8157c5 100644
--- a/result/schemas/choice_1_6.err
+++ b/result/schemas/choice_1_6.err
@@ -1 +1,2 @@
 ./test/schemas/choice_6.xml:3: Schemas validity error : Element 'b': This element is not expected.
+./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/choice_2_0 b/result/schemas/choice_2_0.err
similarity index 100%
rename from result/schemas/choice_2_0
rename to result/schemas/choice_2_0.err
diff --git a/result/schemas/choice_2_1 b/result/schemas/choice_2_1.err
similarity index 100%
rename from result/schemas/choice_2_1
rename to result/schemas/choice_2_1.err
diff --git a/result/schemas/choice_2_2 b/result/schemas/choice_2_2.err
similarity index 100%
rename from result/schemas/choice_2_2
rename to result/schemas/choice_2_2.err
diff --git a/result/schemas/choice_2_3 b/result/schemas/choice_2_3.err
similarity index 100%
rename from result/schemas/choice_2_3
rename to result/schemas/choice_2_3.err
diff --git a/result/schemas/choice_2_4 b/result/schemas/choice_2_4
deleted file mode 100644
index 0643e3b2..00000000
--- a/result/schemas/choice_2_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_4.xml fails to validate
diff --git a/result/schemas/choice_2_4.err b/result/schemas/choice_2_4.err
index 273f170e..ea063ccf 100644
--- a/result/schemas/choice_2_4.err
+++ b/result/schemas/choice_2_4.err
@@ -1 +1,2 @@
 ./test/schemas/choice_4.xml:1: Schemas validity error : Element 'doc': Missing child element(s). Expected is one of ( a, b ).
+./test/schemas/choice_4.xml fails to validate
diff --git a/result/schemas/choice_2_5 b/result/schemas/choice_2_5.err
similarity index 100%
rename from result/schemas/choice_2_5
rename to result/schemas/choice_2_5.err
diff --git a/result/schemas/choice_2_6 b/result/schemas/choice_2_6
deleted file mode 100644
index ee4ceaef..00000000
--- a/result/schemas/choice_2_6
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/choice_2_6.err b/result/schemas/choice_2_6.err
index b6ae4a73..091db7b0 100644
--- a/result/schemas/choice_2_6.err
+++ b/result/schemas/choice_2_6.err
@@ -1 +1,2 @@
 ./test/schemas/choice_6.xml:5: Schemas validity error : Element 'a': This element is not expected.
+./test/schemas/choice_6.xml fails to validate
diff --git a/result/schemas/complex-type-extension_0_0 b/result/schemas/complex-type-extension_0_0.err
similarity index 100%
rename from result/schemas/complex-type-extension_0_0
rename to result/schemas/complex-type-extension_0_0.err
diff --git a/result/schemas/cos-ct-extends-1-3_0_0 b/result/schemas/cos-ct-extends-1-3_0_0.err
similarity index 100%
rename from result/schemas/cos-ct-extends-1-3_0_0
rename to result/schemas/cos-ct-extends-1-3_0_0.err
diff --git a/result/schemas/cos-st-restricts-1-2-err_0_0 b/result/schemas/cos-st-restricts-1-2-err_0_0
deleted file mode 100644
index dc342539..00000000
--- a/result/schemas/cos-st-restricts-1-2-err_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/cos-st-restricts-1-2-err_0.xml fails to validate
diff --git a/result/schemas/cos-st-restricts-1-2-err_0_0.err b/result/schemas/cos-st-restricts-1-2-err_0_0.err
index 32e389b2..36a94ae8 100644
--- a/result/schemas/cos-st-restricts-1-2-err_0_0.err
+++ b/result/schemas/cos-st-restricts-1-2-err_0_0.err
@@ -1,2 +1,3 @@
 ./test/schemas/cos-st-restricts-1-2-err_0.xml:3: Schemas validity error : Element '{http://FOO}foo': [facet 'length'] The value has a length of '2'; this differs from the allowed length of '3'.
 ./test/schemas/cos-st-restricts-1-2-err_0.xml:3: Schemas validity error : Element '{http://FOO}foo': '1 2' is not a valid value of the list type '{http://FOO}type.A'.
+./test/schemas/cos-st-restricts-1-2-err_0.xml fails to validate
diff --git a/result/schemas/ct-sc-nobase_0_0 b/result/schemas/ct-sc-nobase_0_0.err
similarity index 100%
rename from result/schemas/ct-sc-nobase_0_0
rename to result/schemas/ct-sc-nobase_0_0.err
diff --git a/result/schemas/date_0_0 b/result/schemas/date_0_0.err
similarity index 100%
rename from result/schemas/date_0_0
rename to result/schemas/date_0_0.err
diff --git a/result/schemas/decimal-1_1_0 b/result/schemas/decimal-1_1_0
deleted file mode 100644
index 041b31d5..00000000
--- a/result/schemas/decimal-1_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/decimal-1_0.xml fails to validate
diff --git a/result/schemas/decimal-1_1_0.err b/result/schemas/decimal-1_1_0.err
index 62ca9de1..54064207 100644
--- a/result/schemas/decimal-1_1_0.err
+++ b/result/schemas/decimal-1_1_0.err
@@ -6,3 +6,4 @@
 ./test/schemas/decimal-1_0.xml:21: Schemas validity error : Element 'val': '+ 1' is not a valid value of the atomic type 'myDecimal'.
 ./test/schemas/decimal-1_0.xml:22: Schemas validity error : Element 'val': '+ 0' is not a valid value of the atomic type 'myDecimal'.
 ./test/schemas/decimal-1_0.xml:23: Schemas validity error : Element 'val': '- 0' is not a valid value of the atomic type 'myDecimal'.
+./test/schemas/decimal-1_0.xml fails to validate
diff --git a/result/schemas/decimal-2_1_0 b/result/schemas/decimal-2_1_0
deleted file mode 100644
index f68ca92c..00000000
--- a/result/schemas/decimal-2_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/decimal-2_0.xml fails to validate
diff --git a/result/schemas/decimal-2_1_0.err b/result/schemas/decimal-2_1_0.err
index 89dcb2d7..58825a32 100644
--- a/result/schemas/decimal-2_1_0.err
+++ b/result/schemas/decimal-2_1_0.err
@@ -1,2 +1,3 @@
 ./test/schemas/decimal-2_0.xml:12: Schemas validity error : Element 'val': [facet 'minInclusive'] The value '-0.1' is less than the minimum value allowed ('0').
 ./test/schemas/decimal-2_0.xml:13: Schemas validity error : Element 'val': [facet 'minInclusive'] The value '-1' is less than the minimum value allowed ('0').
+./test/schemas/decimal-2_0.xml fails to validate
diff --git a/result/schemas/decimal-3_1_0 b/result/schemas/decimal-3_1_0
deleted file mode 100644
index 5601535c..00000000
--- a/result/schemas/decimal-3_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/decimal-3_0.xml fails to validate
diff --git a/result/schemas/decimal-3_1_0.err b/result/schemas/decimal-3_1_0.err
index 64be5538..aa9ab813 100644
--- a/result/schemas/decimal-3_1_0.err
+++ b/result/schemas/decimal-3_1_0.err
@@ -2,3 +2,4 @@
 ./test/schemas/decimal-3_0.xml:13: Schemas validity error : Element 'val': [facet 'totalDigits'] The value '0.023' has more digits than are allowed ('2').
 ./test/schemas/decimal-3_0.xml:14: Schemas validity error : Element 'val': [facet 'totalDigits'] The value '123' has more digits than are allowed ('2').
 ./test/schemas/decimal-3_0.xml:15: Schemas validity error : Element 'val': [facet 'totalDigits'] The value '12.3' has more digits than are allowed ('2').
+./test/schemas/decimal-3_0.xml fails to validate
diff --git a/result/schemas/derivation-ok-extension_0_0 b/result/schemas/derivation-ok-extension_0_0
deleted file mode 100644
index 09473656..00000000
--- a/result/schemas/derivation-ok-extension_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/derivation-ok-extension_0.xml validates
diff --git a/result/schemas/derivation-ok-extension_0_0.err b/result/schemas/derivation-ok-extension_0_0.err
index 13142327..a8caaf8d 100644
--- a/result/schemas/derivation-ok-extension_0_0.err
+++ b/result/schemas/derivation-ok-extension_0_0.err
@@ -1 +1,2 @@
 ./test/schemas/derivation-ok-extension_0.xsd:10: element attribute: Schemas parser warning : Element '{http://www.w3.org/2001/XMLSchema}attribute': Skipping attribute use prohibition, since it is pointless when extending a type.
+./test/schemas/derivation-ok-extension_0.xml validates
diff --git a/result/schemas/derivation-restriction-anyAttr_0_0 b/result/schemas/derivation-restriction-anyAttr_0_0.err
similarity index 100%
rename from result/schemas/derivation-restriction-anyAttr_0_0
rename to result/schemas/derivation-restriction-anyAttr_0_0.err
diff --git a/result/schemas/dur_0_0 b/result/schemas/dur_0_0.err
similarity index 100%
rename from result/schemas/dur_0_0
rename to result/schemas/dur_0_0.err
diff --git a/result/schemas/elem0_0_0 b/result/schemas/elem0_0_0.err
similarity index 100%
rename from result/schemas/elem0_0_0
rename to result/schemas/elem0_0_0.err
diff --git a/result/schemas/empty-value_1_0 b/result/schemas/empty-value_1_0.err
similarity index 100%
rename from result/schemas/empty-value_1_0
rename to result/schemas/empty-value_1_0.err
diff --git a/result/schemas/empty-value_1_1 b/result/schemas/empty-value_1_1.err
similarity index 100%
rename from result/schemas/empty-value_1_1
rename to result/schemas/empty-value_1_1.err
diff --git a/result/schemas/empty_0_0 b/result/schemas/empty_0_0.err
similarity index 100%
rename from result/schemas/empty_0_0
rename to result/schemas/empty_0_0.err
diff --git a/result/schemas/empty_1_0 b/result/schemas/empty_1_0.err
similarity index 100%
rename from result/schemas/empty_1_0
rename to result/schemas/empty_1_0.err
diff --git a/result/schemas/extension0_0_0 b/result/schemas/extension0_0_0.err
similarity index 100%
rename from result/schemas/extension0_0_0
rename to result/schemas/extension0_0_0.err
diff --git a/result/schemas/extension1_0_0 b/result/schemas/extension1_0_0.err
similarity index 100%
rename from result/schemas/extension1_0_0
rename to result/schemas/extension1_0_0.err
diff --git a/result/schemas/extension1_0_1 b/result/schemas/extension1_0_1
deleted file mode 100644
index 4a47b862..00000000
--- a/result/schemas/extension1_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/extension1_1.xml fails to validate
diff --git a/result/schemas/extension1_0_1.err b/result/schemas/extension1_0_1.err
index 25e93f7d..7f9e0428 100644
--- a/result/schemas/extension1_0_1.err
+++ b/result/schemas/extension1_0_1.err
@@ -1 +1,2 @@
 ./test/schemas/extension1_1.xml:1: Schemas validity error : Element 'title', attribute 'langue': The attribute 'langue' is not allowed.
+./test/schemas/extension1_1.xml fails to validate
diff --git a/result/schemas/extension1_0_2 b/result/schemas/extension1_0_2
deleted file mode 100644
index fc8eccc8..00000000
--- a/result/schemas/extension1_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/extension1_2.xml fails to validate
diff --git a/result/schemas/extension1_0_2.err b/result/schemas/extension1_0_2.err
index 2268f38e..8c2e0717 100644
--- a/result/schemas/extension1_0_2.err
+++ b/result/schemas/extension1_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/extension1_2.xml:1: Schemas validity error : Element 'title': Element content is not allowed, because the content type is a simple type definition.
+./test/schemas/extension1_2.xml fails to validate
diff --git a/result/schemas/extension2_1_0 b/result/schemas/extension2_1_0.err
similarity index 100%
rename from result/schemas/extension2_1_0
rename to result/schemas/extension2_1_0.err
diff --git a/result/schemas/facet-unionST-err1_0_0 b/result/schemas/facet-unionST-err1_0_0
deleted file mode 100644
index baf8280f..00000000
--- a/result/schemas/facet-unionST-err1_0_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/facet-unionST-err1_0.xml fails to validate
diff --git a/result/schemas/facet-unionST-err1_0_0.err b/result/schemas/facet-unionST-err1_0_0.err
index dbaa113f..e2fa5f97 100644
--- a/result/schemas/facet-unionST-err1_0_0.err
+++ b/result/schemas/facet-unionST-err1_0_0.err
@@ -1 +1,2 @@
 ./test/schemas/facet-unionST-err1_0.xml:3: Schemas validity error : Element '{http://FOO}foo': 'tiny' is not a valid value of the union type '{http://FOO}fooType.B'.
+./test/schemas/facet-unionST-err1_0.xml fails to validate
diff --git a/result/schemas/facet-whiteSpace_0_0 b/result/schemas/facet-whiteSpace_0_0.err
similarity index 100%
rename from result/schemas/facet-whiteSpace_0_0
rename to result/schemas/facet-whiteSpace_0_0.err
diff --git a/result/schemas/group0_0_0 b/result/schemas/group0_0_0.err
similarity index 100%
rename from result/schemas/group0_0_0
rename to result/schemas/group0_0_0.err
diff --git a/result/schemas/hexbinary_0_0 b/result/schemas/hexbinary_0_0.err
similarity index 100%
rename from result/schemas/hexbinary_0_0
rename to result/schemas/hexbinary_0_0.err
diff --git a/result/schemas/hexbinary_0_1 b/result/schemas/hexbinary_0_1
deleted file mode 100644
index 37b10d1a..00000000
--- a/result/schemas/hexbinary_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/hexbinary_1.xml fails to validate
diff --git a/result/schemas/hexbinary_0_1.err b/result/schemas/hexbinary_0_1.err
index 15ce34d7..04f14a01 100644
--- a/result/schemas/hexbinary_0_1.err
+++ b/result/schemas/hexbinary_0_1.err
@@ -5,3 +5,4 @@
 ./test/schemas/hexbinary_1.xml:11: Schemas validity error : Element 'hex2': [facet 'maxLength'] The value has a length of '9'; this exceeds the allowed maximum length of '8'.
 ./test/schemas/hexbinary_1.xml:13: Schemas validity error : Element 'hex3': [facet 'length'] The value has a length of '1'; this differs from the allowed length of '2'.
 ./test/schemas/hexbinary_1.xml:14: Schemas validity error : Element 'hex3': [facet 'length'] The value has a length of '3'; this differs from the allowed length of '2'.
+./test/schemas/hexbinary_1.xml fails to validate
diff --git a/result/schemas/idc-keyref-err1_1_0 b/result/schemas/idc-keyref-err1_1_0
deleted file mode 100644
index d4333a94..00000000
--- a/result/schemas/idc-keyref-err1_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/idc-keyref-err1_0.xml fails to validate
diff --git a/result/schemas/idc-keyref-err1_1_0.err b/result/schemas/idc-keyref-err1_1_0.err
index 8e9cb20d..32a6a0dc 100644
--- a/result/schemas/idc-keyref-err1_1_0.err
+++ b/result/schemas/idc-keyref-err1_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/idc-keyref-err1_0.xml:12: Schemas validity error : Element '{urn:test:foo}Ref': No match found for key-sequence ['L4'] of keyref '{urn:test:foo}LinkKeyRef'.
+./test/schemas/idc-keyref-err1_0.xml fails to validate
diff --git a/result/schemas/import0_0_0 b/result/schemas/import0_0_0.err
similarity index 100%
rename from result/schemas/import0_0_0
rename to result/schemas/import0_0_0.err
diff --git a/result/schemas/import1_0_0.err b/result/schemas/import1_0_0.err
index aafb6107..f780244a 100644
--- a/result/schemas/import1_0_0.err
+++ b/result/schemas/import1_0_0.err
@@ -1,4 +1,4 @@
-I/O error : failed to load "test/schemas/import1_0bc.imp": No such file or directory
+I/O warning : failed to load "test/schemas/import1_0bc.imp": No such file or directory
 ./test/schemas/import1_0.xsd:11: element import: Schemas parser warning : Element '{http://www.w3.org/2001/XMLSchema}import': Failed to locate a schema at location 'test/schemas/import1_0bc.imp'. Skipping the import.
 ./test/schemas/import1_0.xsd:16: element import: Schemas parser warning : Element '{http://www.w3.org/2001/XMLSchema}import': Skipping import of schema located at 'test/schemas/import1_0b.imp' for the namespace 'http://BAR', since this namespace was already imported with the schema located at 'test/schemas/import1_0.imp'.
 ./test/schemas/import1_0.xsd:26: element element: Schemas parser error : Element '{http://www.w3.org/2001/XMLSchema}element', attribute 'ref': The QName value '{http://BAR}bar.B' does not resolve to a(n) element declaration.
diff --git a/result/schemas/import2_0_0 b/result/schemas/import2_0_0.err
similarity index 100%
rename from result/schemas/import2_0_0
rename to result/schemas/import2_0_0.err
diff --git a/result/schemas/include1_0_0 b/result/schemas/include1_0_0.err
similarity index 100%
rename from result/schemas/include1_0_0
rename to result/schemas/include1_0_0.err
diff --git a/result/schemas/include2_0_0 b/result/schemas/include2_0_0.err
similarity index 100%
rename from result/schemas/include2_0_0
rename to result/schemas/include2_0_0.err
diff --git a/result/schemas/issue303_0_0 b/result/schemas/issue303_0_0.err
similarity index 100%
rename from result/schemas/issue303_0_0
rename to result/schemas/issue303_0_0.err
diff --git a/result/schemas/issue40_0_0 b/result/schemas/issue40_0_0.err
similarity index 100%
rename from result/schemas/issue40_0_0
rename to result/schemas/issue40_0_0.err
diff --git a/result/schemas/item_0_0 b/result/schemas/item_0_0.err
similarity index 100%
rename from result/schemas/item_0_0
rename to result/schemas/item_0_0.err
diff --git a/result/schemas/item_1_0 b/result/schemas/item_1_0.err
similarity index 100%
rename from result/schemas/item_1_0
rename to result/schemas/item_1_0.err
diff --git a/result/schemas/length1_0_0 b/result/schemas/length1_0_0.err
similarity index 100%
rename from result/schemas/length1_0_0
rename to result/schemas/length1_0_0.err
diff --git a/result/schemas/length2_0_0 b/result/schemas/length2_0_0.err
similarity index 100%
rename from result/schemas/length2_0_0
rename to result/schemas/length2_0_0.err
diff --git a/result/schemas/list0_0_0 b/result/schemas/list0_0_0.err
similarity index 100%
rename from result/schemas/list0_0_0
rename to result/schemas/list0_0_0.err
diff --git a/result/schemas/list0_0_1 b/result/schemas/list0_0_1
deleted file mode 100644
index da757f63..00000000
--- a/result/schemas/list0_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/list0_1.xml fails to validate
diff --git a/result/schemas/list0_0_1.err b/result/schemas/list0_0_1.err
index 8d25f8ad..6d77f750 100644
--- a/result/schemas/list0_0_1.err
+++ b/result/schemas/list0_0_1.err
@@ -1 +1,2 @@
 ./test/schemas/list0_1.xml:1: Schemas validity error : Element 'test': Missing child element(s). Expected is ( string ).
+./test/schemas/list0_1.xml fails to validate
diff --git a/result/schemas/list0_0_2 b/result/schemas/list0_0_2.err
similarity index 100%
rename from result/schemas/list0_0_2
rename to result/schemas/list0_0_2.err
diff --git a/result/schemas/list0_1_0 b/result/schemas/list0_1_0
deleted file mode 100644
index 2cf98061..00000000
--- a/result/schemas/list0_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/list0_0.xml fails to validate
diff --git a/result/schemas/list0_1_0.err b/result/schemas/list0_1_0.err
index ae915c42..77e43684 100644
--- a/result/schemas/list0_1_0.err
+++ b/result/schemas/list0_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/list0_0.xml:5: Schemas validity error : Element 'string': This element is not expected.
+./test/schemas/list0_0.xml fails to validate
diff --git a/result/schemas/list0_1_1 b/result/schemas/list0_1_1
deleted file mode 100644
index da757f63..00000000
--- a/result/schemas/list0_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/list0_1.xml fails to validate
diff --git a/result/schemas/list0_1_1.err b/result/schemas/list0_1_1.err
index 8d25f8ad..6d77f750 100644
--- a/result/schemas/list0_1_1.err
+++ b/result/schemas/list0_1_1.err
@@ -1 +1,2 @@
 ./test/schemas/list0_1.xml:1: Schemas validity error : Element 'test': Missing child element(s). Expected is ( string ).
+./test/schemas/list0_1.xml fails to validate
diff --git a/result/schemas/list0_1_2 b/result/schemas/list0_1_2.err
similarity index 100%
rename from result/schemas/list0_1_2
rename to result/schemas/list0_1_2.err
diff --git a/result/schemas/mixed0_0_0 b/result/schemas/mixed0_0_0.err
similarity index 100%
rename from result/schemas/mixed0_0_0
rename to result/schemas/mixed0_0_0.err
diff --git a/result/schemas/mixed1_0_0 b/result/schemas/mixed1_0_0.err
similarity index 100%
rename from result/schemas/mixed1_0_0
rename to result/schemas/mixed1_0_0.err
diff --git a/result/schemas/ns0_0_0 b/result/schemas/ns0_0_0.err
similarity index 100%
rename from result/schemas/ns0_0_0
rename to result/schemas/ns0_0_0.err
diff --git a/result/schemas/ns0_0_1 b/result/schemas/ns0_0_1.err
similarity index 100%
rename from result/schemas/ns0_0_1
rename to result/schemas/ns0_0_1.err
diff --git a/result/schemas/ns0_0_2 b/result/schemas/ns0_0_2
deleted file mode 100644
index 03e85f7d..00000000
--- a/result/schemas/ns0_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_2.xml fails to validate
diff --git a/result/schemas/ns0_0_2.err b/result/schemas/ns0_0_2.err
index 315553c1..7ba7426b 100644
--- a/result/schemas/ns0_0_2.err
+++ b/result/schemas/ns0_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_2.xml:1: Schemas validity error : Element 'foo': No matching global declaration available for the validation root.
+./test/schemas/ns0_2.xml fails to validate
diff --git a/result/schemas/ns0_0_3 b/result/schemas/ns0_0_3
deleted file mode 100644
index 473206c8..00000000
--- a/result/schemas/ns0_0_3
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_3.xml fails to validate
diff --git a/result/schemas/ns0_0_3.err b/result/schemas/ns0_0_3.err
index 7953234c..c7c8d73f 100644
--- a/result/schemas/ns0_0_3.err
+++ b/result/schemas/ns0_0_3.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_3.xml:1: Schemas validity error : Element '{http://example.com/xsd/ns}foo', attribute '{http://example.com/xsd/ns}id': The attribute '{http://example.com/xsd/ns}id' is not allowed.
+./test/schemas/ns0_3.xml fails to validate
diff --git a/result/schemas/ns0_0_4 b/result/schemas/ns0_0_4
deleted file mode 100644
index f10f45eb..00000000
--- a/result/schemas/ns0_0_4
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_4.xml fails to validate
diff --git a/result/schemas/ns0_0_4.err b/result/schemas/ns0_0_4.err
index f491e145..dbdf51f7 100644
--- a/result/schemas/ns0_0_4.err
+++ b/result/schemas/ns0_0_4.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_4.xml:2: Schemas validity error : Element '{http://example.com/xsd/ns}foo', attribute '{http://example.com/xsd/ns}id': The attribute '{http://example.com/xsd/ns}id' is not allowed.
+./test/schemas/ns0_4.xml fails to validate
diff --git a/result/schemas/ns0_1_0 b/result/schemas/ns0_1_0
deleted file mode 100644
index 9ba04716..00000000
--- a/result/schemas/ns0_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_0.xml fails to validate
diff --git a/result/schemas/ns0_1_0.err b/result/schemas/ns0_1_0.err
index 3a24c8ca..1a1a84c5 100644
--- a/result/schemas/ns0_1_0.err
+++ b/result/schemas/ns0_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_0.xml:1: Schemas validity error : Element '{http://example.com/xsd/ns}foo', attribute 'id': The attribute 'id' is not allowed.
+./test/schemas/ns0_0.xml fails to validate
diff --git a/result/schemas/ns0_1_1 b/result/schemas/ns0_1_1
deleted file mode 100644
index 9f464de2..00000000
--- a/result/schemas/ns0_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_1.xml fails to validate
diff --git a/result/schemas/ns0_1_1.err b/result/schemas/ns0_1_1.err
index 6c259ad5..04aa22c3 100644
--- a/result/schemas/ns0_1_1.err
+++ b/result/schemas/ns0_1_1.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_1.xml:1: Schemas validity error : Element '{http://example.com/xsd/ns}foo', attribute 'id': The attribute 'id' is not allowed.
+./test/schemas/ns0_1.xml fails to validate
diff --git a/result/schemas/ns0_1_2 b/result/schemas/ns0_1_2
deleted file mode 100644
index 03e85f7d..00000000
--- a/result/schemas/ns0_1_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/ns0_2.xml fails to validate
diff --git a/result/schemas/ns0_1_2.err b/result/schemas/ns0_1_2.err
index 315553c1..7ba7426b 100644
--- a/result/schemas/ns0_1_2.err
+++ b/result/schemas/ns0_1_2.err
@@ -1 +1,2 @@
 ./test/schemas/ns0_2.xml:1: Schemas validity error : Element 'foo': No matching global declaration available for the validation root.
+./test/schemas/ns0_2.xml fails to validate
diff --git a/result/schemas/ns0_1_3 b/result/schemas/ns0_1_3.err
similarity index 100%
rename from result/schemas/ns0_1_3
rename to result/schemas/ns0_1_3.err
diff --git a/result/schemas/ns0_1_4 b/result/schemas/ns0_1_4.err
similarity index 100%
rename from result/schemas/ns0_1_4
rename to result/schemas/ns0_1_4.err
diff --git a/result/schemas/ns1_0_0 b/result/schemas/ns1_0_0.err
similarity index 100%
rename from result/schemas/ns1_0_0
rename to result/schemas/ns1_0_0.err
diff --git a/result/schemas/ns2_0_0 b/result/schemas/ns2_0_0.err
similarity index 100%
rename from result/schemas/ns2_0_0
rename to result/schemas/ns2_0_0.err
diff --git a/result/schemas/nvdcve_0_0 b/result/schemas/nvdcve_0_0.err
similarity index 100%
rename from result/schemas/nvdcve_0_0
rename to result/schemas/nvdcve_0_0.err
diff --git a/result/schemas/po0_0_0 b/result/schemas/po0_0_0.err
similarity index 100%
rename from result/schemas/po0_0_0
rename to result/schemas/po0_0_0.err
diff --git a/result/schemas/po1_0_0 b/result/schemas/po1_0_0.err
similarity index 100%
rename from result/schemas/po1_0_0
rename to result/schemas/po1_0_0.err
diff --git a/result/schemas/poschargrp0_0_0 b/result/schemas/poschargrp0_0_0.err
similarity index 100%
rename from result/schemas/poschargrp0_0_0
rename to result/schemas/poschargrp0_0_0.err
diff --git a/result/schemas/regexp-char-ref_0_0 b/result/schemas/regexp-char-ref_0_0.err
similarity index 100%
rename from result/schemas/regexp-char-ref_0_0
rename to result/schemas/regexp-char-ref_0_0.err
diff --git a/result/schemas/regexp-char-ref_1_0 b/result/schemas/regexp-char-ref_1_0.err
similarity index 100%
rename from result/schemas/regexp-char-ref_1_0
rename to result/schemas/regexp-char-ref_1_0.err
diff --git a/result/schemas/restrict-CT-attr-ref_0_0 b/result/schemas/restrict-CT-attr-ref_0_0.err
similarity index 100%
rename from result/schemas/restrict-CT-attr-ref_0_0
rename to result/schemas/restrict-CT-attr-ref_0_0.err
diff --git a/result/schemas/restriction-enum-1_1_0 b/result/schemas/restriction-enum-1_1_0
deleted file mode 100644
index 68e26cfb..00000000
--- a/result/schemas/restriction-enum-1_1_0
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/restriction-enum-1_0.xml fails to validate
diff --git a/result/schemas/restriction-enum-1_1_0.err b/result/schemas/restriction-enum-1_1_0.err
index c6ab50d5..719aca14 100644
--- a/result/schemas/restriction-enum-1_1_0.err
+++ b/result/schemas/restriction-enum-1_1_0.err
@@ -1 +1,2 @@
 ./test/schemas/restriction-enum-1_0.xml:7: Schemas validity error : Element 'foo': [facet 'enumeration'] The value 'c' is not an element of the set {'a', 'b', 'd'}.
+./test/schemas/restriction-enum-1_0.xml fails to validate
diff --git a/result/schemas/restriction0_0_0 b/result/schemas/restriction0_0_0.err
similarity index 100%
rename from result/schemas/restriction0_0_0
rename to result/schemas/restriction0_0_0.err
diff --git a/result/schemas/seq-dubl-elem1_0_0 b/result/schemas/seq-dubl-elem1_0_0.err
similarity index 100%
rename from result/schemas/seq-dubl-elem1_0_0
rename to result/schemas/seq-dubl-elem1_0_0.err
diff --git a/result/schemas/seq0_0_0 b/result/schemas/seq0_0_0.err
similarity index 100%
rename from result/schemas/seq0_0_0
rename to result/schemas/seq0_0_0.err
diff --git a/result/schemas/subst-group-1_0_1 b/result/schemas/subst-group-1_0_1.err
similarity index 100%
rename from result/schemas/subst-group-1_0_1
rename to result/schemas/subst-group-1_0_1.err
diff --git a/result/schemas/union2_1_1 b/result/schemas/union2_1_1
deleted file mode 100644
index 0d4ee15b..00000000
--- a/result/schemas/union2_1_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/union2_1.xml fails to validate
diff --git a/result/schemas/union2_1_1.err b/result/schemas/union2_1_1.err
index 9fffc2cf..26fed53e 100644
--- a/result/schemas/union2_1_1.err
+++ b/result/schemas/union2_1_1.err
@@ -1,3 +1,4 @@
 ./test/schemas/union2_1.xml:4: Schemas validity error : Element '{urn:test:foo}ELEMENTS': '
 	5
 ' is not a valid value of the local union type.
+./test/schemas/union2_1.xml fails to validate
diff --git a/result/schemas/union_0_0 b/result/schemas/union_0_0.err
similarity index 100%
rename from result/schemas/union_0_0
rename to result/schemas/union_0_0.err
diff --git a/result/schemas/vdv-first0_0_0 b/result/schemas/vdv-first0_0_0.err
similarity index 100%
rename from result/schemas/vdv-first0_0_0
rename to result/schemas/vdv-first0_0_0.err
diff --git a/result/schemas/vdv-first1_0_0 b/result/schemas/vdv-first1_0_0.err
similarity index 100%
rename from result/schemas/vdv-first1_0_0
rename to result/schemas/vdv-first1_0_0.err
diff --git a/result/schemas/vdv-first2_0_0 b/result/schemas/vdv-first2_0_0.err
similarity index 100%
rename from result/schemas/vdv-first2_0_0
rename to result/schemas/vdv-first2_0_0.err
diff --git a/result/schemas/vdv-first3_0_0 b/result/schemas/vdv-first3_0_0.err
similarity index 100%
rename from result/schemas/vdv-first3_0_0
rename to result/schemas/vdv-first3_0_0.err
diff --git a/result/schemas/vdv-first4_0_0 b/result/schemas/vdv-first4_0_0.err
similarity index 100%
rename from result/schemas/vdv-first4_0_0
rename to result/schemas/vdv-first4_0_0.err
diff --git a/result/schemas/vdv-first4_0_1 b/result/schemas/vdv-first4_0_1
deleted file mode 100644
index 19a7ac14..00000000
--- a/result/schemas/vdv-first4_0_1
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/vdv-first4_1.xml fails to validate
diff --git a/result/schemas/vdv-first4_0_1.err b/result/schemas/vdv-first4_0_1.err
index 4a176469..f2727767 100644
--- a/result/schemas/vdv-first4_0_1.err
+++ b/result/schemas/vdv-first4_0_1.err
@@ -1 +1,2 @@
 ./test/schemas/vdv-first4_1.xml:14: Schemas validity error : Element 'born': '196T6-08-22' is not a valid value of the atomic type 'date'.
+./test/schemas/vdv-first4_1.xml fails to validate
diff --git a/result/schemas/vdv-first4_0_2 b/result/schemas/vdv-first4_0_2
deleted file mode 100644
index fb59b67d..00000000
--- a/result/schemas/vdv-first4_0_2
+++ /dev/null
@@ -1 +0,0 @@
-./test/schemas/vdv-first4_2.xml fails to validate
diff --git a/result/schemas/vdv-first4_0_2.err b/result/schemas/vdv-first4_0_2.err
index fe405f76..07733d28 100644
--- a/result/schemas/vdv-first4_0_2.err
+++ b/result/schemas/vdv-first4_0_2.err
@@ -1 +1,2 @@
 ./test/schemas/vdv-first4_2.xml:24: Schemas validity error : Element 'born': [facet 'pattern'] The value '2000-01-20Z' is not accepted by the pattern '[^:Z]*'.
+./test/schemas/vdv-first4_2.xml fails to validate
diff --git a/result/schemas/vdv-first5_0_0 b/result/schemas/vdv-first5_0_0.err
similarity index 100%
rename from result/schemas/vdv-first5_0_0
rename to result/schemas/vdv-first5_0_0.err
diff --git a/result/schemas/xsd-list-itemType_0_0 b/result/schemas/xsd-list-itemType_0_0.err
similarity index 100%
rename from result/schemas/xsd-list-itemType_0_0
rename to result/schemas/xsd-list-itemType_0_0.err
diff --git a/result/schemas/xsd-simpleType-varieties_0_0 b/result/schemas/xsd-simpleType-varieties_0_0.err
similarity index 100%
rename from result/schemas/xsd-simpleType-varieties_0_0
rename to result/schemas/xsd-simpleType-varieties_0_0.err
diff --git a/result/schematron/zvon10_0 b/result/schematron/zvon10_0
deleted file mode 100644
index 9aae4b1e..00000000
--- a/result/schematron/zvon10_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB/>
-</AAA>
diff --git a/result/schematron/zvon10_0.err b/result/schematron/zvon10_0.err
index 524ecd89..f96d8822 100644
--- a/result/schematron/zvon10_0.err
+++ b/result/schematron/zvon10_0.err
@@ -1,5 +1,3 @@
-Pattern: Open model
-/AAA line 1:  CCC element is not present
-Pattern: Closed model
-/AAA line 1:  CCC element is not present
+./test/schematron/zvon10_0.xml:1: element AAA: schematron error : /AAA line 1:  CCC element is not present
+./test/schematron/zvon10_0.xml:1: element AAA: schematron error : /AAA line 1:  CCC element is not present
 ./test/schematron/zvon10_0.xml fails to validate
diff --git a/result/schematron/zvon10_1 b/result/schematron/zvon10_1
deleted file mode 100644
index d82353ae..00000000
--- a/result/schematron/zvon10_1
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB/>
-     <DDD/>
-</AAA>
diff --git a/result/schematron/zvon10_1.err b/result/schematron/zvon10_1.err
index 9bc361c3..b7a2835a 100644
--- a/result/schematron/zvon10_1.err
+++ b/result/schematron/zvon10_1.err
@@ -1,6 +1,4 @@
-Pattern: Open model
-/AAA line 1:  CCC element is not present
-Pattern: Closed model
-/AAA line 1:  CCC element is not present
-/AAA line 1: There is an extra element
+./test/schematron/zvon10_1.xml:1: element AAA: schematron error : /AAA line 1:  CCC element is not present
+./test/schematron/zvon10_1.xml:1: element AAA: schematron error : /AAA line 1:  CCC element is not present
+./test/schematron/zvon10_1.xml:1: element AAA: schematron error : /AAA line 1: There is an extra element
 ./test/schematron/zvon10_1.xml fails to validate
diff --git a/result/schematron/zvon11_0 b/result/schematron/zvon11_0
deleted file mode 100644
index 49c80056..00000000
--- a/result/schematron/zvon11_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB aaa="A" bbb="B"/>
-</AAA>
diff --git a/result/schematron/zvon11_0.err b/result/schematron/zvon11_0.err
index ab4aa742..12d673c6 100644
--- a/result/schematron/zvon11_0.err
+++ b/result/schematron/zvon11_0.err
@@ -1,2 +1 @@
-Pattern: Attributes present
 ./test/schematron/zvon11_0.xml validates
diff --git a/result/schematron/zvon11_1 b/result/schematron/zvon11_1
deleted file mode 100644
index a5328e0f..00000000
--- a/result/schematron/zvon11_1
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB bbb="B"/>
-</AAA>
diff --git a/result/schematron/zvon11_1.err b/result/schematron/zvon11_1.err
index c1ae2433..c3e55fcc 100644
--- a/result/schematron/zvon11_1.err
+++ b/result/schematron/zvon11_1.err
@@ -1,3 +1,2 @@
-Pattern: Attributes present
-/AAA/BBB line 2: The element must not have an isolated bbb attribute
+./test/schematron/zvon11_1.xml:2: element BBB: schematron error : /AAA/BBB line 2: The element must not have an isolated bbb attribute
 ./test/schematron/zvon11_1.xml fails to validate
diff --git a/result/schematron/zvon11_2 b/result/schematron/zvon11_2
deleted file mode 100644
index 673a7afd..00000000
--- a/result/schematron/zvon11_2
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB aaa="A"/>
-</AAA>
diff --git a/result/schematron/zvon11_2.err b/result/schematron/zvon11_2.err
index 35117f7f..edb96302 100644
--- a/result/schematron/zvon11_2.err
+++ b/result/schematron/zvon11_2.err
@@ -1,3 +1,2 @@
-Pattern: Attributes present
-/AAA/BBB line 2: The element must not have an isolated aaa attribute
+./test/schematron/zvon11_2.xml:2: element BBB: schematron error : /AAA/BBB line 2: The element must not have an isolated aaa attribute
 ./test/schematron/zvon11_2.xml fails to validate
diff --git a/result/schematron/zvon11_3 b/result/schematron/zvon11_3
deleted file mode 100644
index 9aae4b1e..00000000
--- a/result/schematron/zvon11_3
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB/>
-</AAA>
diff --git a/result/schematron/zvon11_3.err b/result/schematron/zvon11_3.err
index 18517e58..637c19b8 100644
--- a/result/schematron/zvon11_3.err
+++ b/result/schematron/zvon11_3.err
@@ -1,2 +1 @@
-Pattern: Attributes present
 ./test/schematron/zvon11_3.xml validates
diff --git a/result/schematron/zvon12_0 b/result/schematron/zvon12_0
deleted file mode 100644
index 72208046..00000000
--- a/result/schematron/zvon12_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB bbb="C"/>
-</AAA>
diff --git a/result/schematron/zvon12_0.err b/result/schematron/zvon12_0.err
index c7e9ed25..74d0e0c8 100644
--- a/result/schematron/zvon12_0.err
+++ b/result/schematron/zvon12_0.err
@@ -1,3 +1,2 @@
-Pattern: Number of characters in an abbreviation
-/AAA/BBB line 2: There is not enough letters in the abbreviation
+./test/schematron/zvon12_0.xml:2: element BBB: schematron error : /AAA/BBB line 2: There is not enough letters in the abbreviation
 ./test/schematron/zvon12_0.xml fails to validate
diff --git a/result/schematron/zvon12_1 b/result/schematron/zvon12_1
deleted file mode 100644
index 362de34e..00000000
--- a/result/schematron/zvon12_1
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB bbb="CZ"/>
-</AAA>
diff --git a/result/schematron/zvon12_1.err b/result/schematron/zvon12_1.err
index 486c0bea..24ca7913 100644
--- a/result/schematron/zvon12_1.err
+++ b/result/schematron/zvon12_1.err
@@ -1,2 +1 @@
-Pattern: Number of characters in an abbreviation
 ./test/schematron/zvon12_1.xml validates
diff --git a/result/schematron/zvon12_2 b/result/schematron/zvon12_2
deleted file mode 100644
index bbbf7c7f..00000000
--- a/result/schematron/zvon12_2
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB bbb="CZCZ"/>
-</AAA>
diff --git a/result/schematron/zvon12_2.err b/result/schematron/zvon12_2.err
index 5edaf307..a2870c6f 100644
--- a/result/schematron/zvon12_2.err
+++ b/result/schematron/zvon12_2.err
@@ -1,3 +1,2 @@
-Pattern: Number of characters in an abbreviation
-/AAA/BBB line 2: There is too much letters in the abbreviation
+./test/schematron/zvon12_2.xml:2: element BBB: schematron error : /AAA/BBB line 2: There is too much letters in the abbreviation
 ./test/schematron/zvon12_2.xml fails to validate
diff --git a/result/schematron/zvon13_0 b/result/schematron/zvon13_0
deleted file mode 100644
index e1295c37..00000000
--- a/result/schematron/zvon13_0
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0"?>
-<Total>
-     <Percent>20</Percent>
-     <Percent>30</Percent>
-     <Percent>10</Percent>
-     <Percent>50</Percent>          
-</Total>
diff --git a/result/schematron/zvon13_0.err b/result/schematron/zvon13_0.err
index ed98cb3d..355f0d06 100644
--- a/result/schematron/zvon13_0.err
+++ b/result/schematron/zvon13_0.err
@@ -1,3 +1,2 @@
-Pattern: Sum equals 100%.
-/Total line 1: The values do not sum to 100%. 
+./test/schematron/zvon13_0.xml:1: element Total: schematron error : /Total line 1: The values do not sum to 100%. 
 ./test/schematron/zvon13_0.xml fails to validate
diff --git a/result/schematron/zvon13_1 b/result/schematron/zvon13_1
deleted file mode 100644
index 401e919b..00000000
--- a/result/schematron/zvon13_1
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0"?>
-<Total>
-     <Percent>20</Percent>
-     <Percent>10</Percent>
-     <Percent>50</Percent>          
-</Total>
diff --git a/result/schematron/zvon13_1.err b/result/schematron/zvon13_1.err
index e0f02c2a..e0b97457 100644
--- a/result/schematron/zvon13_1.err
+++ b/result/schematron/zvon13_1.err
@@ -1,3 +1,2 @@
-Pattern: Sum equals 100%.
-/Total line 1: The values do not sum to 100%. 
+./test/schematron/zvon13_1.xml:1: element Total: schematron error : /Total line 1: The values do not sum to 100%. 
 ./test/schematron/zvon13_1.xml fails to validate
diff --git a/result/schematron/zvon13_2 b/result/schematron/zvon13_2
deleted file mode 100644
index cb1df2ed..00000000
--- a/result/schematron/zvon13_2
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0"?>
-<Total>
-     <Percent>20</Percent>
-     <Percent>30</Percent>
-     <Percent>50</Percent>          
-</Total>
diff --git a/result/schematron/zvon13_2.err b/result/schematron/zvon13_2.err
index dfab61f9..bc8ec2d4 100644
--- a/result/schematron/zvon13_2.err
+++ b/result/schematron/zvon13_2.err
@@ -1,2 +1 @@
-Pattern: Sum equals 100%.
 ./test/schematron/zvon13_2.xml validates
diff --git a/result/schematron/zvon14_0 b/result/schematron/zvon14_0
deleted file mode 100644
index c72e0c28..00000000
--- a/result/schematron/zvon14_0
+++ /dev/null
@@ -1,13 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC/>
-     </BBB>
-     <CCC/>
-     <DDD>
-          <CCC/>
-          <EEE>
-               <CCC/>
-          </EEE>
-     </DDD>
-</AAA>
diff --git a/result/schematron/zvon14_0.err b/result/schematron/zvon14_0.err
index 60155da7..68d9ce7f 100644
--- a/result/schematron/zvon14_0.err
+++ b/result/schematron/zvon14_0.err
@@ -1,4 +1,3 @@
-Pattern: a child of selected elements
-/AAA/CCC line 5: Element CCC must not be a child of element AAA 
-/AAA/DDD/EEE/CCC line 9: Element CCC must not be a child of element EEE 
+./test/schematron/zvon14_0.xml:5: element CCC: schematron error : /AAA/CCC line 5: Element CCC must not be a child of element AAA 
+./test/schematron/zvon14_0.xml:9: element CCC: schematron error : /AAA/DDD/EEE/CCC line 9: Element CCC must not be a child of element EEE 
 ./test/schematron/zvon14_0.xml fails to validate
diff --git a/result/schematron/zvon15_0 b/result/schematron/zvon15_0
deleted file mode 100644
index 56500fe8..00000000
--- a/result/schematron/zvon15_0
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0"?>
-<AAA name="aaa">
-<BBB id="bbb"/>
-<CCC color="ccc"/>
-</AAA>
diff --git a/result/schematron/zvon15_0.err b/result/schematron/zvon15_0.err
index 52348897..c6ecda26 100644
--- a/result/schematron/zvon15_0.err
+++ b/result/schematron/zvon15_0.err
@@ -1,4 +1,3 @@
-Pattern: id is the only permited attribute name
-/AAA line 1: Attribute name is forbidden in element AAA 
-/AAA/CCC line 3: Attribute color is forbidden in element CCC 
+./test/schematron/zvon15_0.xml:1: element AAA: schematron error : /AAA line 1: Attribute name is forbidden in element AAA 
+./test/schematron/zvon15_0.xml:3: element CCC: schematron error : /AAA/CCC line 3: Attribute color is forbidden in element CCC 
 ./test/schematron/zvon15_0.xml fails to validate
diff --git a/result/schematron/zvon1_0 b/result/schematron/zvon1_0
deleted file mode 100644
index 9aae4b1e..00000000
--- a/result/schematron/zvon1_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB/>
-</AAA>
diff --git a/result/schematron/zvon1_0.err b/result/schematron/zvon1_0.err
index 0d421844..19f95cc3 100644
--- a/result/schematron/zvon1_0.err
+++ b/result/schematron/zvon1_0.err
@@ -1,8 +1,5 @@
-Pattern: Print both cases
-/AAA line 1: BBB element is present.
-/AAA line 1: AAA misses attribute name.
-Pattern: Print positive result only
-/AAA line 1: BBB element is present.
-Pattern: Print negative result only
-/AAA line 1: AAA misses attribute name.
+./test/schematron/zvon1_0.xml:1: element AAA: schematron error : /AAA line 1: BBB element is present.
+./test/schematron/zvon1_0.xml:1: element AAA: schematron error : /AAA line 1: AAA misses attribute name.
+./test/schematron/zvon1_0.xml:1: element AAA: schematron error : /AAA line 1: BBB element is present.
+./test/schematron/zvon1_0.xml:1: element AAA: schematron error : /AAA line 1: AAA misses attribute name.
 ./test/schematron/zvon1_0.xml fails to validate
diff --git a/result/schematron/zvon1_1 b/result/schematron/zvon1_1
deleted file mode 100644
index 0a06953a..00000000
--- a/result/schematron/zvon1_1
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <CCC/>
-</AAA>
diff --git a/result/schematron/zvon1_1.err b/result/schematron/zvon1_1.err
index 70ee87a7..f5548c93 100644
--- a/result/schematron/zvon1_1.err
+++ b/result/schematron/zvon1_1.err
@@ -1,8 +1,5 @@
-Pattern: Print both cases
-/AAA line 1: BBB element is missing.
-/AAA line 1: AAA misses attribute name.
-Pattern: Print positive result only
-Pattern: Print negative result only
-/AAA line 1: BBB element is missing.
-/AAA line 1: AAA misses attribute name.
+./test/schematron/zvon1_1.xml:1: element AAA: schematron error : /AAA line 1: BBB element is missing.
+./test/schematron/zvon1_1.xml:1: element AAA: schematron error : /AAA line 1: AAA misses attribute name.
+./test/schematron/zvon1_1.xml:1: element AAA: schematron error : /AAA line 1: BBB element is missing.
+./test/schematron/zvon1_1.xml:1: element AAA: schematron error : /AAA line 1: AAA misses attribute name.
 ./test/schematron/zvon1_1.xml fails to validate
diff --git a/result/schematron/zvon2_0 b/result/schematron/zvon2_0
deleted file mode 100644
index 695bc8f1..00000000
--- a/result/schematron/zvon2_0
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>bbbb</BBB>
-     <CCC>cccc</CCC>
-</AAA>
diff --git a/result/schematron/zvon2_0.err b/result/schematron/zvon2_0.err
index f4e4a7f5..7c791711 100644
--- a/result/schematron/zvon2_0.err
+++ b/result/schematron/zvon2_0.err
@@ -1,2 +1 @@
-Pattern: Character @ forbidden
 ./test/schematron/zvon2_0.xml validates
diff --git a/result/schematron/zvon2_1 b/result/schematron/zvon2_1
deleted file mode 100644
index 2af2cd0f..00000000
--- a/result/schematron/zvon2_1
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>bbbb@bbb.com</BBB>
-     <CCC>ccc@ccc.com</CCC>
-</AAA>
diff --git a/result/schematron/zvon2_1.err b/result/schematron/zvon2_1.err
index 28f3e99e..ca4d0fd4 100644
--- a/result/schematron/zvon2_1.err
+++ b/result/schematron/zvon2_1.err
@@ -1,5 +1,4 @@
-Pattern: Character @ forbidden
-/AAA line 1: Text in element AAA must not contain character @ 
-/AAA/BBB line 2: Text in element BBB must not contain character @ 
-/AAA/CCC line 3: Text in element CCC must not contain character @ 
+./test/schematron/zvon2_1.xml:1: element AAA: schematron error : /AAA line 1: Text in element AAA must not contain character @ 
+./test/schematron/zvon2_1.xml:2: element BBB: schematron error : /AAA/BBB line 2: Text in element BBB must not contain character @ 
+./test/schematron/zvon2_1.xml:3: element CCC: schematron error : /AAA/CCC line 3: Text in element CCC must not contain character @ 
 ./test/schematron/zvon2_1.xml fails to validate
diff --git a/result/schematron/zvon2_2 b/result/schematron/zvon2_2
deleted file mode 100644
index 585cf0c3..00000000
--- a/result/schematron/zvon2_2
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>bbbb</BBB>
-     <CCC>cccc</CCC>
-     aaa@aaa.net
-</AAA>
diff --git a/result/schematron/zvon2_2.err b/result/schematron/zvon2_2.err
index 40dc7ca9..38669f1d 100644
--- a/result/schematron/zvon2_2.err
+++ b/result/schematron/zvon2_2.err
@@ -1,3 +1,2 @@
-Pattern: Character @ forbidden
-/AAA line 1: Text in element AAA must not contain character @ 
+./test/schematron/zvon2_2.xml:1: element AAA: schematron error : /AAA line 1: Text in element AAA must not contain character @ 
 ./test/schematron/zvon2_2.xml fails to validate
diff --git a/result/schematron/zvon3_0 b/result/schematron/zvon3_0
deleted file mode 100644
index a8a6ed77..00000000
--- a/result/schematron/zvon3_0
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC/>
-          <CCC/>
-     </BBB>
-     <CCC name="c1"/>
-     <CCC name="c2"/>
-</AAA>
diff --git a/result/schematron/zvon3_0.err b/result/schematron/zvon3_0.err
index 419e7291..7028b739 100644
--- a/result/schematron/zvon3_0.err
+++ b/result/schematron/zvon3_0.err
@@ -1,6 +1,5 @@
-Pattern: Attribute test
-/AAA/BBB/CCC[1] line 3: attribute name is not present
-/AAA/BBB/CCC[2] line 4: attribute name is not present
-/AAA/CCC[1] line 6: attribute name is present
-/AAA/CCC[2] line 7: attribute name is present
+./test/schematron/zvon3_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC[1] line 3: attribute name is not present
+./test/schematron/zvon3_0.xml:4: element CCC: schematron error : /AAA/BBB/CCC[2] line 4: attribute name is not present
+./test/schematron/zvon3_0.xml:6: element CCC: schematron error : /AAA/CCC[1] line 6: attribute name is present
+./test/schematron/zvon3_0.xml:7: element CCC: schematron error : /AAA/CCC[2] line 7: attribute name is present
 ./test/schematron/zvon3_0.xml fails to validate
diff --git a/result/schematron/zvon4_0 b/result/schematron/zvon4_0
deleted file mode 100644
index b1e694e5..00000000
--- a/result/schematron/zvon4_0
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC/>
-          <CCC/>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon4_0.err b/result/schematron/zvon4_0.err
index 6aa6b2b5..9032c55e 100644
--- a/result/schematron/zvon4_0.err
+++ b/result/schematron/zvon4_0.err
@@ -1,3 +1,2 @@
-Pattern: Root test
-/AAA line 1: Root element is AAA
+./test/schematron/zvon4_0.xml:1: element AAA: schematron error : /AAA line 1: Root element is AAA
 ./test/schematron/zvon4_0.xml fails to validate
diff --git a/result/schematron/zvon4_1 b/result/schematron/zvon4_1
deleted file mode 100644
index 6b1facc6..00000000
--- a/result/schematron/zvon4_1
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0"?>
-<XXX>
-     <BBB>
-          <CCC/>
-          <CCC/>
-     </BBB>
-</XXX>
diff --git a/result/schematron/zvon4_1.err b/result/schematron/zvon4_1.err
index 4ad324f9..aacdd3aa 100644
--- a/result/schematron/zvon4_1.err
+++ b/result/schematron/zvon4_1.err
@@ -1,3 +1,2 @@
-Pattern: Root test
-/XXX line 1: Root element is XXX, not AAA 
+./test/schematron/zvon4_1.xml:1: element XXX: schematron error : /XXX line 1: Root element is XXX, not AAA 
 ./test/schematron/zvon4_1.xml fails to validate
diff --git a/result/schematron/zvon5_0 b/result/schematron/zvon5_0
deleted file mode 100644
index d763505b..00000000
--- a/result/schematron/zvon5_0
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC/>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon5_0.err b/result/schematron/zvon5_0.err
index 91ef5f28..50183299 100644
--- a/result/schematron/zvon5_0.err
+++ b/result/schematron/zvon5_0.err
@@ -1,7 +1,6 @@
-Pattern: Select empty elements CCC
-/AAA/BBB/CCC line 3: Source contains an empty element CCC 
-/AAA/BBB/CCC line 3: [1]An element CCC does not contain any text
-/AAA/BBB/CCC line 3: [2]An element CCC does not contain any text
-/AAA/BBB/CCC line 3: [1]An element CCC does not contain any child element
-/AAA/BBB/CCC line 3: [2]An element CCC does not contain any child element
+./test/schematron/zvon5_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: Source contains an empty element CCC 
+./test/schematron/zvon5_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [1]An element CCC does not contain any text
+./test/schematron/zvon5_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [2]An element CCC does not contain any text
+./test/schematron/zvon5_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [1]An element CCC does not contain any child element
+./test/schematron/zvon5_0.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [2]An element CCC does not contain any child element
 ./test/schematron/zvon5_0.xml fails to validate
diff --git a/result/schematron/zvon5_1 b/result/schematron/zvon5_1
deleted file mode 100644
index c76b7562..00000000
--- a/result/schematron/zvon5_1
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC>I am CCC element</CCC>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon5_1.err b/result/schematron/zvon5_1.err
index f4ce6d41..ad6f2fc1 100644
--- a/result/schematron/zvon5_1.err
+++ b/result/schematron/zvon5_1.err
@@ -1,5 +1,4 @@
-Pattern: Select empty elements CCC
-/AAA/BBB/CCC line 3: Source contains an empty element CCC 
-/AAA/BBB/CCC line 3: [1]An element CCC does not contain any child element
-/AAA/BBB/CCC line 3: [2]An element CCC does not contain any child element
+./test/schematron/zvon5_1.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: Source contains an empty element CCC 
+./test/schematron/zvon5_1.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [1]An element CCC does not contain any child element
+./test/schematron/zvon5_1.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [2]An element CCC does not contain any child element
 ./test/schematron/zvon5_1.xml fails to validate
diff --git a/result/schematron/zvon5_2 b/result/schematron/zvon5_2
deleted file mode 100644
index ddc11fe3..00000000
--- a/result/schematron/zvon5_2
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <BBB>
-          <CCC>
-               <DDD/>
-          </CCC>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon5_2.err b/result/schematron/zvon5_2.err
index 8c69e79f..03f07967 100644
--- a/result/schematron/zvon5_2.err
+++ b/result/schematron/zvon5_2.err
@@ -1,5 +1,4 @@
-Pattern: Select empty elements CCC
-/AAA/BBB/CCC line 3: Source contains an empty element CCC 
-/AAA/BBB/CCC line 3: [1]An element CCC does not contain any text
-/AAA/BBB/CCC line 3: [2]An element CCC does not contain any text
+./test/schematron/zvon5_2.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: Source contains an empty element CCC 
+./test/schematron/zvon5_2.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [1]An element CCC does not contain any text
+./test/schematron/zvon5_2.xml:3: element CCC: schematron error : /AAA/BBB/CCC line 3: [2]An element CCC does not contain any text
 ./test/schematron/zvon5_2.xml fails to validate
diff --git a/result/schematron/zvon6_0 b/result/schematron/zvon6_0
deleted file mode 100644
index 65397651..00000000
--- a/result/schematron/zvon6_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-aaa
-</AAA>
diff --git a/result/schematron/zvon6_0.err b/result/schematron/zvon6_0.err
index 5cc3b372..0a3428b7 100644
--- a/result/schematron/zvon6_0.err
+++ b/result/schematron/zvon6_0.err
@@ -1,3 +1,2 @@
-Pattern: Predefined values
-/AAA line 1: O.K.
+./test/schematron/zvon6_0.xml:1: element AAA: schematron error : /AAA line 1: O.K.
 ./test/schematron/zvon6_0.xml fails to validate
diff --git a/result/schematron/zvon6_1 b/result/schematron/zvon6_1
deleted file mode 100644
index e0c2e73c..00000000
--- a/result/schematron/zvon6_1
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-          bbb
-</AAA>
diff --git a/result/schematron/zvon6_1.err b/result/schematron/zvon6_1.err
index 8b728d41..c0b5f137 100644
--- a/result/schematron/zvon6_1.err
+++ b/result/schematron/zvon6_1.err
@@ -1,3 +1,2 @@
-Pattern: Predefined values
-/AAA line 1: O.K.
+./test/schematron/zvon6_1.xml:1: element AAA: schematron error : /AAA line 1: O.K.
 ./test/schematron/zvon6_1.xml fails to validate
diff --git a/result/schematron/zvon6_2 b/result/schematron/zvon6_2
deleted file mode 100644
index edc24a97..00000000
--- a/result/schematron/zvon6_2
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-  ccc
-</AAA>
diff --git a/result/schematron/zvon6_2.err b/result/schematron/zvon6_2.err
index 18689342..9bcc3232 100644
--- a/result/schematron/zvon6_2.err
+++ b/result/schematron/zvon6_2.err
@@ -1,3 +1,2 @@
-Pattern: Predefined values
-/AAA line 1: The AAA value is not permitted.
+./test/schematron/zvon6_2.xml:1: element AAA: schematron error : /AAA line 1: The AAA value is not permitted.
 ./test/schematron/zvon6_2.xml fails to validate
diff --git a/result/schematron/zvon7_0 b/result/schematron/zvon7_0
deleted file mode 100644
index 65397651..00000000
--- a/result/schematron/zvon7_0
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-aaa
-</AAA>
diff --git a/result/schematron/zvon7_0.err b/result/schematron/zvon7_0.err
index df427d68..74cd995a 100644
--- a/result/schematron/zvon7_0.err
+++ b/result/schematron/zvon7_0.err
@@ -1,3 +1,2 @@
-Pattern: Test integer
-/AAA line 1: The AAA value is not an integer.
+./test/schematron/zvon7_0.xml:1: element AAA: schematron error : /AAA line 1: The AAA value is not an integer.
 ./test/schematron/zvon7_0.xml fails to validate
diff --git a/result/schematron/zvon7_1 b/result/schematron/zvon7_1
deleted file mode 100644
index 0a4007ac..00000000
--- a/result/schematron/zvon7_1
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
- 12.234
-</AAA>
diff --git a/result/schematron/zvon7_1.err b/result/schematron/zvon7_1.err
index aa1e0a15..ac6bfa43 100644
--- a/result/schematron/zvon7_1.err
+++ b/result/schematron/zvon7_1.err
@@ -1,3 +1,2 @@
-Pattern: Test integer
-/AAA line 1: The AAA value is not an integer.
+./test/schematron/zvon7_1.xml:1: element AAA: schematron error : /AAA line 1: The AAA value is not an integer.
 ./test/schematron/zvon7_1.xml fails to validate
diff --git a/result/schematron/zvon7_2 b/result/schematron/zvon7_2
deleted file mode 100644
index 8eb45e30..00000000
--- a/result/schematron/zvon7_2
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-45
-</AAA>
diff --git a/result/schematron/zvon7_2.err b/result/schematron/zvon7_2.err
index abf8cc7e..b0d06d7c 100644
--- a/result/schematron/zvon7_2.err
+++ b/result/schematron/zvon7_2.err
@@ -1,3 +1,2 @@
-Pattern: Test integer
-/AAA line 1: O.K.
+./test/schematron/zvon7_2.xml:1: element AAA: schematron error : /AAA line 1: O.K.
 ./test/schematron/zvon7_2.xml fails to validate
diff --git a/result/schematron/zvon7_3 b/result/schematron/zvon7_3
deleted file mode 100644
index 35089dd2..00000000
--- a/result/schematron/zvon7_3
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-0
-</AAA>
diff --git a/result/schematron/zvon7_3.err b/result/schematron/zvon7_3.err
index 5b4b59fe..07e36664 100644
--- a/result/schematron/zvon7_3.err
+++ b/result/schematron/zvon7_3.err
@@ -1,3 +1,2 @@
-Pattern: Test integer
-/AAA line 1: O.K.
+./test/schematron/zvon7_3.xml:1: element AAA: schematron error : /AAA line 1: O.K.
 ./test/schematron/zvon7_3.xml fails to validate
diff --git a/result/schematron/zvon7_4 b/result/schematron/zvon7_4
deleted file mode 100644
index 0739eb4d..00000000
--- a/result/schematron/zvon7_4
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
--45
-</AAA>
diff --git a/result/schematron/zvon7_4.err b/result/schematron/zvon7_4.err
index de1ee894..e754afbe 100644
--- a/result/schematron/zvon7_4.err
+++ b/result/schematron/zvon7_4.err
@@ -1,3 +1,2 @@
-Pattern: Test integer
-/AAA line 1: O.K.
+./test/schematron/zvon7_4.xml:1: element AAA: schematron error : /AAA line 1: O.K.
 ./test/schematron/zvon7_4.xml fails to validate
diff --git a/result/schematron/zvon8_0 b/result/schematron/zvon8_0
deleted file mode 100644
index 1932cd04..00000000
--- a/result/schematron/zvon8_0
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0"?>
-<XXX>
-     <BBB/>
-     <BBB/>
-     <AAA/>
-     <BBB/>
-     <AAA/>
-     <AAA/>
-</XXX>
diff --git a/result/schematron/zvon8_0.err b/result/schematron/zvon8_0.err
index 085e1dee..006dbe76 100644
--- a/result/schematron/zvon8_0.err
+++ b/result/schematron/zvon8_0.err
@@ -1,3 +1,2 @@
-Pattern: Test count
-/XXX line 1: O.K.
+./test/schematron/zvon8_0.xml:1: element XXX: schematron error : /XXX line 1: O.K.
 ./test/schematron/zvon8_0.xml fails to validate
diff --git a/result/schematron/zvon8_1 b/result/schematron/zvon8_1
deleted file mode 100644
index 93e5cfdf..00000000
--- a/result/schematron/zvon8_1
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<XXX>
-     <BBB/>
-     <AAA/>
-     <BBB/>
-     <AAA/>
-     <AAA/>
-</XXX>
diff --git a/result/schematron/zvon8_1.err b/result/schematron/zvon8_1.err
index ae07d059..7ce3306b 100644
--- a/result/schematron/zvon8_1.err
+++ b/result/schematron/zvon8_1.err
@@ -1,3 +1,2 @@
-Pattern: Test count
-/XXX line 1: Some BBB are missing
+./test/schematron/zvon8_1.xml:1: element XXX: schematron error : /XXX line 1: Some BBB are missing
 ./test/schematron/zvon8_1.xml fails to validate
diff --git a/result/schematron/zvon8_2 b/result/schematron/zvon8_2
deleted file mode 100644
index 4eea77ba..00000000
--- a/result/schematron/zvon8_2
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<XXX>
-     <BBB/>
-     <BBB/>
-     <AAA/>
-     <BBB/>
-     <AAA/>
-</XXX>
diff --git a/result/schematron/zvon8_2.err b/result/schematron/zvon8_2.err
index 37e8432c..009a4f8e 100644
--- a/result/schematron/zvon8_2.err
+++ b/result/schematron/zvon8_2.err
@@ -1,3 +1,2 @@
-Pattern: Test count
-/XXX line 1: Some AAA are missing
+./test/schematron/zvon8_2.xml:1: element XXX: schematron error : /XXX line 1: Some AAA are missing
 ./test/schematron/zvon8_2.xml fails to validate
diff --git a/result/schematron/zvon9_0 b/result/schematron/zvon9_0
deleted file mode 100644
index 1f254ec2..00000000
--- a/result/schematron/zvon9_0
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <CCC/>
-     <CCC/>
-     <BBB>
-          <CCC id="Q1"/>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon9_0.err b/result/schematron/zvon9_0.err
index a39ceebe..c17642f1 100644
--- a/result/schematron/zvon9_0.err
+++ b/result/schematron/zvon9_0.err
@@ -1,2 +1 @@
-Pattern: Test attribute
 ./test/schematron/zvon9_0.xml validates
diff --git a/result/schematron/zvon9_1 b/result/schematron/zvon9_1
deleted file mode 100644
index 0dc0df72..00000000
--- a/result/schematron/zvon9_1
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <CCC id="Q2"/>
-     <CCC/>
-     <BBB>
-          <CCC id="Q1"/>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon9_1.err b/result/schematron/zvon9_1.err
index 44c6f67f..11e8d5dc 100644
--- a/result/schematron/zvon9_1.err
+++ b/result/schematron/zvon9_1.err
@@ -1,3 +1,2 @@
-Pattern: Test attribute
-/AAA/CCC[1] line 2: Attribute id is used in wrong context
+./test/schematron/zvon9_1.xml:2: element CCC: schematron error : /AAA/CCC[1] line 2: Attribute id is used in wrong context
 ./test/schematron/zvon9_1.xml fails to validate
diff --git a/result/schematron/zvon9_2 b/result/schematron/zvon9_2
deleted file mode 100644
index b9218fc9..00000000
--- a/result/schematron/zvon9_2
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<AAA>
-     <CCC/>
-     <CCC/>
-     <BBB>
-          <CCC/>
-     </BBB>
-</AAA>
diff --git a/result/schematron/zvon9_2.err b/result/schematron/zvon9_2.err
index 20b08844..2c4bdf27 100644
--- a/result/schematron/zvon9_2.err
+++ b/result/schematron/zvon9_2.err
@@ -1,3 +1,2 @@
-Pattern: Test attribute
-/AAA/BBB/CCC line 5: Attribute id is missing
+./test/schematron/zvon9_2.xml:5: element CCC: schematron error : /AAA/BBB/CCC line 5: Attribute id is missing
 ./test/schematron/zvon9_2.xml fails to validate
diff --git a/result/xmlid/id_tst4.xml b/result/xmlid/id_tst4.xml
index 188d2312..33ee896d 100644
--- a/result/xmlid/id_tst4.xml
+++ b/result/xmlid/id_tst4.xml
@@ -1,6 +1,6 @@
 Object is a Node Set :
 Set contains 1 nodes:
-1  ELEMENT err
+1  ELEMENT foo
     ATTRIBUTE id
       TEXT
         content=bar
diff --git a/rngparser.c b/rngparser.c
deleted file mode 100644
index 799a60e6..00000000
--- a/rngparser.c
+++ /dev/null
@@ -1,1588 +0,0 @@
-/**
- * rngparser.c: parser for the Relax-NG compact syntax.
- *
- * Based on:
- *   RELAX NG Compact Syntax
- *   Committee Specification 21 November 2002
- *   http://www.oasis-open.org/committees/relax-ng/compact-20021121.html
- *
- * See Copyright for the status of this software.
- *
- * Daniel Veillard <veillard@redhat.com>
- */
-
-#include <string.h>
-
-#include <libxml/parser.h>
-#include <libxml/parserInternals.h>
-#include <libxml/relaxng.h>
-#include <libxml/dict.h>
-
-#define MAX_TOKEN 10
-
-typedef enum {
-    CRNG_NONE = 0,
-    CRNG_OP = 1,
-    CRNG_KEYWORD,
-    CRNG_IDENTIFIER,
-    CRNG_LITERAL_SEGMENT,
-    CRNG_CNAME,
-    CRNG_QNAME,
-    CRNG_NSNAME,
-    CRNG_DOCUMENTATION
-} xmlCRNGTokType;
-
-typedef enum {
-    CRNG_OKAY = 0,
-    CRNG_MEMORY_ERROR,
-    CRNG_INVALID_CHAR_ERROR,
-    CRNG_END_ERROR,
-    CRNG_ENCODING_ERROR
-} xmlCRNGError;
-
-typedef enum {
-    XML_CRNG_ERROR = -1,
-    XML_CRNG_OK = 0,
-    XML_CRNG_EOF = 1
-} xmlCRelaxNGParserState;
-
-typedef struct _token _token;
-typedef _token *tokenPtr;
-struct _token {
-    xmlCRNGTokType toktype;
-    int toklen;
-    const xmlChar *token;
-    const xmlChar *prefix;
-};
-
-typedef struct _xmlCRelaxNGParserCtxt xmlCRelaxNGParserCtxt;
-typedef xmlCRelaxNGParserCtxt *xmlCRelaxNGParserCtxtPtr;
-struct _xmlCRelaxNGParserCtxt {
-    void *userData;			/* user specific data block */
-    xmlRelaxNGValidityErrorFunc error;	/* the callback in case of errors */
-    xmlRelaxNGValidityWarningFunc warning;/* the callback in case of warning */
-    xmlRelaxNGValidErr err;
-
-    const xmlChar *compact;
-    const xmlChar *end;
-    const xmlChar *cur;
-    int isElem;
-    int lineno;
-    const xmlChar *linestart;
-    const char *filename;
-
-    int  nbTokens;
-    int  firstToken;
-    _token tokens[MAX_TOKEN];
-    int  totalToken;
-
-    xmlCRelaxNGParserState state;
-
-    int            nbErrors;
-
-    xmlDocPtr      res;			/* the result */
-    xmlNodePtr     ins;			/* the current insertion node */
-
-    xmlNsPtr       nsDef;
-    tokenPtr token;
-
-    xmlHashTablePtr namespaces;
-    xmlHashTablePtr datatypes;
-
-    /*
-     * dictionary and keywords
-     */
-    xmlDictPtr     dict;
-    const xmlChar *key_attribute;
-    const xmlChar *key_default;
-    const xmlChar *key_datatypes;
-    const xmlChar *key_div;
-    const xmlChar *key_element;
-    const xmlChar *key_empty;
-    const xmlChar *key_external;
-    const xmlChar *key_grammar;
-    const xmlChar *key_include;
-    const xmlChar *key_inherit;
-    const xmlChar *key_list;
-    const xmlChar *key_mixed;
-    const xmlChar *key_namespace;
-    const xmlChar *key_notAllowed;
-    const xmlChar *key_parent;
-    const xmlChar *key_start;
-    const xmlChar *key_string;
-    const xmlChar *key_text;
-    const xmlChar *key_token;
-    const xmlChar *key_equal;
-    const xmlChar *key_orequal;
-    const xmlChar *key_andequal;
-    const xmlChar *key_combine;
-    const xmlChar *key_or;
-    const xmlChar *key_comma;
-    const xmlChar *key_and;
-    const xmlChar *key_choice;
-    const xmlChar *key_group;
-    const xmlChar *key_interleave;
-    const xmlChar *key_ref;
-    const xmlChar *key_define;
-
-    /* results */
-    xmlDocPtr doc;	/* the resulting doc */
-    xmlNodePtr insert;	/* the insertion point */
-    xmlAttrPtr attrs;   /* pending attributes */
-};
-
-static const xmlChar *xmlCRelaxNGInherit = BAD_CAST "Inherit string";
-static const xmlChar *xmlCRelaxNGDefault = BAD_CAST "Default string";
-
-#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
-/**
- * IS_BLANK:
- * @c:  an UNICODE value (int)
- *
- * Macro to check the following production in the XML spec:
- *
- * [3] S ::= (#x20 | #x9 | #xD | #xA)+
- */
-#ifndef IS_BLANK
-#define IS_BLANK(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) ||	\
-                     ((c) == 0x0D))
-#endif
-#define IS_SEPARATOR(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) || \
-                     ((c) == 0x0D) || (c == '#'))
-
-#define CRNG_ERROR0(X)							\
-    { xmlCRNGErr(ctxt, X, NULL); return(0); }
-#define CRNG_ERROR(X)							\
-    { xmlCRNGErr(ctxt, X, NULL); }
-
-#define CRNG_MEM_ERROR0()						\
-    { xmlCRNGErr(ctxt, CRNG_MEMORY_ERROR, NULL); return(0); }
-#define CRNG_MEM_ERROR()						\
-    { xmlCRNGErr(ctxt, CRNG_MEMORY_ERROR, NULL); }
-
-#define ERROR(str) xmlCRNGErr(ctxt, 0, str);
-
-static void
-xmlCRNGErr(xmlCRelaxNGParserCtxtPtr ctxt, int err_no, const char *err_msg) {
-    const xmlChar *cur;
-    xmlChar buffer[150];
-    int i, l;
-
-    if (ctxt != NULL) {
-        if (ctxt->filename != NULL)
-	    fprintf(stderr, "%s:%d ", ctxt->filename, ctxt->lineno);
-    }
-    if (err_msg != NULL) {
-	fprintf(stderr, "error: %s\n", err_msg);
-    } else if (err_no != 0)
-	fprintf(stderr, "error %d\n", err_no);
-    cur = ctxt->cur;
-    while ((*cur != '\n') && (*cur != '\r') && (ctxt->cur - cur < 80)) cur--;
-    l = ctxt->cur - cur;
-    cur++;
-    for (i = 0; i < 100;i++) {
-        if ((*cur == '\n') || (*cur == '\r')) break;
-        buffer[i] = *cur++;
-    }
-    buffer[i] = 0;
-    fprintf(stderr, "%s\n", buffer);
-    for (i = 0; i < l;i++) buffer[i] = ' ';
-    buffer[i++] = '^';
-    buffer[i++] = 0;
-    fprintf(stderr, "%s\n", buffer);
-}
-
-/**
- * IS_OP
- * @c:  an UNICODE value (int)
- *
- * Macro to check for operator value
- */
-#ifndef IS_OP
-#define IS_OP(c) (((c) == ',') || ((c) == '&') || ((c) == '|') ||	\
-		  ((c) == '?') || ((c) == '-') || ((c) == '*') ||	\
-		  ((c) == '{') || ((c) == '}') || ((c) == '(') ||	\
-		  ((c) == ')') || ((c) == '+') || ((c) == '=') ||	\
-		  ((c) == ':'))
-#endif
-
-static int
-xmlCRNGIsKeyword(xmlCRelaxNGParserCtxtPtr ctxt, const xmlChar *str) {
-    if ((str == ctxt->key_attribute) ||
-        (str == ctxt->key_default) ||
-        (str == ctxt->key_datatypes) ||
-        (str == ctxt->key_div) ||
-        (str == ctxt->key_element) ||
-        (str == ctxt->key_empty) ||
-        (str == ctxt->key_external) ||
-        (str == ctxt->key_grammar) ||
-        (str == ctxt->key_include) ||
-        (str == ctxt->key_inherit) ||
-        (str == ctxt->key_list) ||
-        (str == ctxt->key_mixed) ||
-        (str == ctxt->key_namespace) ||
-        (str == ctxt->key_notAllowed) ||
-        (str == ctxt->key_parent) ||
-        (str == ctxt->key_start) ||
-        (str == ctxt->key_string) ||
-        (str == ctxt->key_text) ||
-        (str == ctxt->key_token))
-	return(1);
-    return(0);
-
-}
-
-/*
- * xmlCRNGNextToken:
- * ctxt:  a compact RNG parser context
- *
- * Scan the schema to get the next token
- *
- * Return 0 if success and -1 in case of error
- */
-
-static int
-xmlCRNGNextToken(xmlCRelaxNGParserCtxtPtr ctxt) {
-    const xmlChar *cur;
-    tokenPtr token;
-
-    if (ctxt == NULL) return(-1);
-    if (ctxt->nbTokens >= MAX_TOKEN) return(-1);
-    token = &(ctxt->tokens[(ctxt->firstToken + ctxt->nbTokens) % MAX_TOKEN]);
-    token->toktype = CRNG_NONE;
-
-    if (ctxt->cur == NULL) {
-        ctxt->cur = ctxt->compact;
-    }
-retry:
-    if (ctxt->cur >= ctxt->end) {
-	ctxt->state = XML_CRNG_EOF;
-	return(-1);
-    }
-    while ((ctxt->cur < ctxt->end) &&
-           (IS_BLANK(*ctxt->cur))) ctxt->cur++;
-    if (ctxt->cur >= ctxt->end) {
-	ctxt->state = XML_CRNG_EOF;
-	return(-1);
-    }
-    if (*ctxt->cur == '#') {
-        cur = ctxt->cur;
-	cur++;
-	while ((cur < ctxt->end) && (*cur != '\n') && (*cur != '\r'))
-	    cur++;
-        ctxt->cur = cur;
-	goto retry;
-    } else if (*ctxt->cur == '"') {
-        /* string, check for '"""' */
-	ctxt->cur++;
-	if (ctxt->cur >= ctxt->end) goto eof;
-	cur = ctxt->cur;
-        if ((ctxt->end - ctxt->end > 2) &&
-	    (*cur == '"') && (cur[1] == '"')) {
-	    /* TODO */
-	} else {
-	    while ((cur < ctxt->end) && (*cur != '"')) cur++;
-	    if (cur >= ctxt->end) goto eof;
-	    token->toklen = cur - ctxt->cur;
-	    token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);
-	    token->toktype = CRNG_LITERAL_SEGMENT;
-	    token->prefix = NULL;
-	    cur++;
-	    ctxt->cur = cur;
-	}
-    } else if (*ctxt->cur == '\'') {
-        /* string, check for "'''" */
-	/* TODO */
-    } else if ((IS_OP(*ctxt->cur)) || (*ctxt->cur == ':')) {
-        cur = ctxt->cur;
-	cur++;
-	if ((cur < ctxt->end) &&
-	    (((*cur == '=') &&
-	      ((*ctxt->cur == '|') || (*ctxt->cur == '&'))) ||
-	     ((*cur == '*') && (*ctxt->cur == ':')))) {
-	    token->toklen = 2;
-	} else {
-	    token->toklen = 1;
-	}
-	token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);
-	token->toktype = CRNG_OP;
-	token->prefix = NULL;
-	ctxt->cur += token->toklen;
-    } else {
-        int escape = 0;
-
-        cur = ctxt->cur;
-        if (*cur == '\\') {
-	    escape = 1;
-	    cur++;
-	    ctxt->cur++;
-	}
-	while ((cur < ctxt->end) &&
-	       (!(IS_SEPARATOR(*cur))) && (!(IS_OP(*cur)))) cur++;
-
-	token->toklen = cur - ctxt->cur;
-	token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);
-	token->prefix = NULL;
-	ctxt->cur = cur;
-	if ((escape == 0) && (xmlCRNGIsKeyword(ctxt, token->token)))
-	    token->toktype = CRNG_KEYWORD;
-	else {
-	    token->toktype = CRNG_IDENTIFIER;
-	}
-	if (*ctxt->cur == ':') {
-	    ctxt->cur++;
-	    if (*ctxt->cur == '*') {
-		ctxt->cur++;
-		token->toktype = CRNG_NSNAME;
-	    } else {
-	        cur = ctxt->cur;
-		while ((cur < ctxt->end) &&
-		       (!(IS_SEPARATOR(*cur))) && (!(IS_OP(*cur)))) cur++;
-		token->prefix = token->token;
-		token->toklen = cur - ctxt->cur;
-		token->token = xmlDictLookup(ctxt->dict, ctxt->cur,
-		                             token->toklen);
-		ctxt->cur = cur;
-		if (xmlValidateNCName(token->token, 0) == 0)
-		    token->toktype = CRNG_QNAME;
-		else {
-		    /* TODO: sounds like an error ! */
-		    token->toktype = CRNG_IDENTIFIER;
-		}
-	    }
-	}
-    }
-    ctxt->nbTokens++;
-    return(0);
-eof:
-    ctxt->state = XML_CRNG_EOF;
-    CRNG_ERROR(CRNG_END_ERROR);
-    return(-1);
-}
-
-/**
- * xmlParseCRNGGetToken:
- * @ctxt: a compact RNG parser context
- * @no: the number of the token from 1 for the first one
- *      and 2, 3 ... for read-ahead
- *
- * Token reading interface
- *
- * returns a pointer to the new token, or NULL in case of error or EOF
- */
-static tokenPtr
-xmlParseCRNGGetToken(xmlCRelaxNGParserCtxtPtr ctxt, int no) {
-    tokenPtr ret;
-    int res;
-
-    if ((no <= 0) || (no >= MAX_TOKEN)) return(NULL);
-    no--;
-    while (ctxt->nbTokens <= no) {
-        res = xmlCRNGNextToken(ctxt);
-	if (res < 0)
-	    return(NULL);
-    }
-    ret = &(ctxt->tokens[(ctxt->firstToken + no) % MAX_TOKEN]);
-    return(ret);
-}
-
-/**
- * xmlParseCRNGDropTokens:
- * @ctxt: a compact RNG parser context
- * @nr: the number of token marked as read
- *
- * mark a number of token as read and consumed.
- *
- * Returns -1 in case of error and 0 otherwise
- */
-static int
-xmlParseCRNGDropTokens(xmlCRelaxNGParserCtxtPtr ctxt, int nr) {
-    if ((nr <= 0) || (nr >= MAX_TOKEN)) return(-1);
-    while ((ctxt->nbTokens >0) && (nr > 0)) {
-        ctxt->firstToken++;
-	nr--;
-	ctxt->nbTokens--;
-	ctxt->totalToken++;
-	if (ctxt->totalToken == 384)
-	    fprintf(stderr, "found\n");
-    }
-    ctxt->firstToken = ctxt->firstToken % MAX_TOKEN;
-    return(0);
-}
-
-static void
-xmlParseCRNGTokenize(xmlCRelaxNGParserCtxtPtr ctxt) {
-    tokenPtr token;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    while (token != NULL) {
-        switch (token->toktype) {
-            case CRNG_NONE: printf("none"); break;
-            case CRNG_OP: printf("op"); break;
-            case CRNG_KEYWORD: printf("keyword"); break;
-            case CRNG_IDENTIFIER: printf("identifier"); break;
-            case CRNG_LITERAL_SEGMENT: printf("literal"); break;
-            case CRNG_CNAME: printf("cname"); break;
-            case CRNG_QNAME: printf("qname"); break;
-            case CRNG_NSNAME: printf("nsname"); break;
-            case CRNG_DOCUMENTATION: printf("doc"); break;
-	}
-        printf(":%s\n", token->token);
-	xmlParseCRNGDropTokens(ctxt, 1);
-	token = xmlParseCRNGGetToken(ctxt, 1);
-    }
-}
-
-/**
- * xmlParseCRNG_attribute:
- * @ctxt: a compact RNG parser context
- * @name: the attribute name
- * @ns: the attribute namespace
- * @value: the attribute value
- *
- * implements attribute of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_attribute(xmlCRelaxNGParserCtxtPtr ctxt,
-                       const xmlChar *name,
-                       xmlNsPtr ns,
-		       const xmlChar *value)
-{
-    xmlAttrPtr attr;
-
-    attr = xmlNewNsPropEatName(NULL, ns, (xmlChar *) name, value);
-    if (attr == NULL) CRNG_MEM_ERROR0();
-    attr->next = ctxt->attrs;
-    if (ctxt->attrs != NULL)
-        ctxt->attrs->prev = attr;
-    ctxt->attrs = attr;
-    return(0);
-}
-
-/**
- * xmlParseCRNG_bindPrefix:
- * @ctxt: a compact RNG parser context
- * @prefix: the namespace prefix or NULL
- * @namespace: the namespace name
- *
- * implements bindPrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_bindPrefix(xmlCRelaxNGParserCtxtPtr ctxt,
-                        const xmlChar *prefix,
-			const xmlChar *namespace)
-{
-    int ret;
-
-    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))  &&
-        (!xmlStrEqual(namespace, XML_XML_NAMESPACE))) {
-	ERROR("The \"xml\" prefix must be bound to \"http://www.w3.org/XML/1998/namespace\"");
-	return(-1);
-    } else if ((xmlStrEqual(namespace, XML_XML_NAMESPACE)) &&
-               (!xmlStrEqual(prefix, BAD_CAST "xml"))) {
-	ERROR("The \"http://www.w3.org/XML/1998/namespace\" name must be bound to \"xml\" prefix");
-	return(-1);
-    }
-    if (ctxt->namespaces == NULL)
-        ctxt->namespaces = xmlHashCreate(10);
-    if (ctxt->namespaces == NULL) {
-        ERROR("Failed to create namespace hash table");
-	return(-1);
-    }
-    if (prefix == NULL)
-        ret = xmlHashAddEntry(ctxt->namespaces, xmlCRelaxNGDefault,
-	                      (void *) namespace);
-    else
-        ret = xmlHashAddEntry(ctxt->namespaces, prefix,
-	                      (void *) namespace);
-    if (ret < 0) {
-        if (prefix == NULL) {
-	    ERROR("Redefinition of default namespace");
-	} else {
-	    ERROR("Redefinition of namespace");
-	}
-	return(-1);
-    }
-
-    return(0);
-}
-
-/**
- * xmlParseCRNG_bindDatatypePrefix:
- * @ctxt: a compact RNG parser context
- * @prefix: the datatype prefix
- * @namespace: the datatype identifier
- *
- * implements bindDatatypePrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_bindDatatypePrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                                const xmlChar *prefix,
-			        const xmlChar *namespace)
-{
-    int ret;
-
-    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xsd"))  &&
-        (!xmlStrEqual(namespace,
-		  BAD_CAST "http://www.w3.org/2001/XMLSchema-datatypes"))) {
-	ERROR("The \"xsd\" prefix must be bound to \"http://www.w3.org/2001/XMLSchema-datatypes\"");
-	return(-1);
-    }
-    if (ctxt->datatypes == NULL)
-        ctxt->datatypes = xmlHashCreate(10);
-    if (ctxt->datatypes == NULL) {
-        ERROR("Failed to create namespace hash table");
-	return(-1);
-    }
-    ret = xmlHashAddEntry(ctxt->datatypes, prefix,
-                          (void *) namespace);
-    if (ret < 0) {
-	ERROR("Redefinition of datatype");
-	return(-1);
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_lookupPrefix:
- * @ctxt: a compact RNG parser context
- * @prefix: the namespace prefix or NULL
- *
- * implements lookupPrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns the prefix in case of success or NULL in case of error
- */
-static const xmlChar *
-xmlParseCRNG_lookupPrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                        const xmlChar *prefix)
-{
-    const xmlChar *ret;
-
-    if (prefix == NULL)
-        ret = xmlHashLookup(ctxt->namespaces, xmlCRelaxNGDefault);
-    else
-        ret = xmlHashLookup(ctxt->namespaces, prefix);
-    return(ret);
-}
-
-/**
- * xmlParseCRNG_lookupDatatypePrefix:
- * @ctxt: a compact RNG parser context
- * @prefix: the namespace prefix or NULL
- *
- * implements lookupDatatypePrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns the prefix in case of success or NULL in case of error
- */
-static const xmlChar *
-xmlParseCRNG_lookupDatatypePrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                        const xmlChar *prefix)
-{
-    const xmlChar *ret;
-    ret = xmlHashLookup(ctxt->datatypes, prefix);
-    return(ret);
-}
-
-/**
- * xmlParseCRNG_datatypeAttributes:
- * @ctxt: a compact RNG parser context
- * @prefix: the namespace prefix or NULL
- *
- * implements lookupPrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns the prefix in case of success or NULL in case of error
- */
-static xmlAttrPtr
-xmlParseCRNG_datatypeAttributes(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,
-                        const xmlChar *library, const xmlChar *type)
-{
-    xmlAttrPtr lib, typ;
-
-    lib = xmlNewNsProp(NULL, NULL, BAD_CAST "datatypeLibrary", library);
-    if (lib == NULL) {
-        CRNG_MEM_ERROR();
-	return(NULL);
-    }
-    typ = xmlNewNsProp(NULL, NULL, BAD_CAST "type", type);
-    if (typ == NULL) {
-        CRNG_MEM_ERROR();
-	return(lib);
-    }
-    lib->next = typ;
-
-    return(lib);
-}
-
-/**
- * xmlParseCRNG_XXX:
- * @ctxt: a compact RNG parser context
- *
- * Parse XXX of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_XXX(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    return(0);
-}
-
-static int xmlParseCRNG_pattern(xmlCRelaxNGParserCtxtPtr ctxt);
-static int xmlParseCRNG_nameClass(xmlCRelaxNGParserCtxtPtr ctxt);
-
-/**
- * xmlParseCRNG_params:
- * @ctxt: a compact RNG parser context
- *
- * Parse params of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_params(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    /* TODO */
-    return(0);
-}
-
-/**
- * xmlParseCRNG_exceptNameClass:
- * @ctxt: a compact RNG parser context
- *
- * Parse exceptNameClass of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_exceptNameClass(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    tokenPtr token;
-    xmlNodePtr insert = ctxt->insert, cur;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if ((token->toktype == CRNG_OP) &&
-        (token->token[0] == '-') && (token->token[1] == 0)) {
-	xmlParseCRNGDropTokens(ctxt, 1);
-	cur = xmlNewNode(NULL, BAD_CAST "except");
-	if (cur == NULL) CRNG_MEM_ERROR0();
-	if (ctxt->insert != NULL)
-	    xmlAddChild(ctxt->insert, cur);
-	ctxt->insert = cur;
-	xmlParseCRNG_nameClass(ctxt);
-    }
-    ctxt->insert = insert;
-    return(0);
-}
-
-/**
- * xmlParseCRNG_innerNameClass:
- * @ctxt: a compact RNG parser context
- *
- * Parse innerNameClass of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_innerNameClass(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-    xmlNodePtr cur;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token->toktype == CRNG_OP) {
-        if ((token->token[0] == '(') && (token->token[1] == 0)) {
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    xmlParseCRNG_nameClass(ctxt);
-	    token = xmlParseCRNGGetToken(ctxt, 1);
-	    if ((token->toktype != CRNG_OP) ||
-	        (token->token[0] != ')') || (token->token[1] != 0)) {
-		ERROR("Expecting \")\" here");
-	    }
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	} else if ((token->token[0] == '*') && (token->token[1] == 0)) {
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    cur = xmlNewNode(NULL, BAD_CAST "anyName");
-	    if (cur == NULL) CRNG_MEM_ERROR0();
-	    if (ctxt->insert != NULL)
-		xmlAddChild(ctxt->insert, cur);
-	    ctxt->insert = cur;
-	    xmlParseCRNG_exceptNameClass(ctxt);
-	} else {
-	    /* TODO */
-	}
-    } else if ((token->toktype == CRNG_IDENTIFIER) ||
-               (token->toktype == CRNG_KEYWORD)) {
-	cur = xmlNewNode(NULL, BAD_CAST "name");
-	if (cur == NULL) CRNG_MEM_ERROR0();
-	if (ctxt->isElem) {
-	    xmlSetProp(cur, BAD_CAST "ns",
-	               xmlParseCRNG_lookupPrefix(ctxt, NULL));
-	} else {
-	    xmlSetProp(cur, BAD_CAST "ns", BAD_CAST "");
-	}
-	xmlNodeAddContent(cur, token->token);
-	if (ctxt->insert != NULL)
-	    xmlAddChild(ctxt->insert, cur);
-	ctxt->insert = cur;
-	xmlParseCRNGDropTokens(ctxt, 1);
-    } else if (token->toktype == CRNG_CNAME) {
-        /* TODO */
-    } else if (token->toktype == CRNG_NSNAME) {
-	cur = xmlNewNode(NULL, BAD_CAST "nsName");
-	if (cur == NULL) CRNG_MEM_ERROR0();
-        xmlSetProp(cur, BAD_CAST "ns",
-	           xmlParseCRNG_lookupPrefix(ctxt, token->token));
-	if (ctxt->insert != NULL)
-	    xmlAddChild(ctxt->insert, cur);
-	ctxt->insert = cur;
-	xmlParseCRNGDropTokens(ctxt, 1);
-	xmlParseCRNG_exceptNameClass(ctxt);
-    } else {
-        /* TODO: probably an error */
-    }
-
-    return(0);
-}
-
-/**
- * xmlParseCRNG_nameClass:
- * @ctxt: a compact RNG parser context
- *
- * Parse nameClass of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_nameClass(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-    xmlNodePtr insert = ctxt->insert, last, choice;
-
-    ctxt->insert = NULL;
-    xmlParseCRNG_innerNameClass(ctxt);
-    last = ctxt->insert;
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    while ((token->toktype == CRNG_OP) &&
-        (token->token[0] == '|') && (token->token[1] == 0)) {
-	choice = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_choice);
-	xmlParseCRNGDropTokens(ctxt, 1);
-	if (choice == NULL) CRNG_MEM_ERROR0();
-	ctxt->insert = NULL;
-	xmlParseCRNG_innerNameClass(ctxt);
-	xmlAddChild(choice, last);
-	xmlAddChild(choice, ctxt->insert);
-	last = choice;
-	token = xmlParseCRNGGetToken(ctxt, 1);
-    }
-    xmlAddChild(insert, last);
-
-    ctxt->insert = insert;
-    return(0);
-}
-
-/**
- * xmlParseCRNG_patternBlock:
- * @ctxt: a compact RNG parser context
- *
- * Parse a pattern block of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_patternBlock(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if ((token->toktype != CRNG_OP) ||
-	(token->token[0] != '{') || (token->token[1] != 0)) {
-	ERROR("Expecting \"{\" here");
-    }
-    xmlParseCRNGDropTokens(ctxt, 1);
-    xmlParseCRNG_pattern(ctxt);
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if ((token->toktype != CRNG_OP) ||
-	(token->token[0] != '}') || (token->token[1] != 0)) {
-	ERROR("Expecting \"}\" here");
-    }
-    xmlParseCRNGDropTokens(ctxt, 1);
-    return(0);
-}
-
-/**
- * xmlParseCRNG_datatype:
- * @ctxt: a compact RNG parser context
- *
- * Parse datatype of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_datatype(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    tokenPtr token;
-    xmlAttrPtr attrs = NULL;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token->toktype == CRNG_KEYWORD) {
-	if (token->token == ctxt->key_string) {
-	    attrs = xmlParseCRNG_datatypeAttributes(ctxt, BAD_CAST "",
-	                                            token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	} else if (token->token == ctxt->key_token) {
-	    attrs = xmlParseCRNG_datatypeAttributes(ctxt, BAD_CAST "",
-	                                            token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	} else {
-	    /* TODO: probably an error */
-	}
-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {
-	ctxt->insert = xmlNewNode(NULL, BAD_CAST "value");
-	xmlParseCRNGDropTokens(ctxt, 1);
-	if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	xmlNodeAddContent(ctxt->insert, token->token);
-    } else if (token->toktype == CRNG_QNAME) {
-	attrs = xmlParseCRNG_datatypeAttributes(ctxt,
-	            xmlParseCRNG_lookupDatatypePrefix(ctxt, token->prefix),
-		    token->token);
-    } else {
-        /* TODO */
-    }
-    if (attrs != NULL) {
-	token = xmlParseCRNGGetToken(ctxt, 1);
-	if (token->toktype == CRNG_LITERAL_SEGMENT) {
-	    ctxt->insert = xmlNewNode(NULL, BAD_CAST "value");
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) {
-	        xmlFreePropList(attrs);
-		CRNG_MEM_ERROR0();
-	    }
-	    ctxt->insert->properties = attrs;
-	    xmlNodeAddContent(ctxt->insert, token->token);
-	} else if ((token->toktype == CRNG_OP) &&
-	           (token->token[0] == '{') && (token->token[0] == 0)) {
-	    ctxt->insert = xmlNewNode(NULL, BAD_CAST "data");
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) {
-	        xmlFreePropList(attrs);
-		CRNG_MEM_ERROR0();
-	    }
-	    ctxt->insert->properties = attrs;
-	    xmlParseCRNG_params(ctxt);
-        } else {
-	    ctxt->insert = xmlNewNode(NULL, BAD_CAST "data");
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) {
-	        xmlFreePropList(attrs);
-		CRNG_MEM_ERROR0();
-	    }
-	    ctxt->insert->properties = attrs;
-	    xmlNodeAddContent(ctxt->insert, token->token);
-	}
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_primary:
- * @ctxt: a compact RNG parser context
- *
- * Parse primary of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_primary(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    tokenPtr token;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token == NULL)
-        return(0);
-    if (token->toktype == CRNG_KEYWORD) {
-        if (token->token == ctxt->key_element) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    ctxt->isElem = 1;
-	    xmlParseCRNG_nameClass(ctxt);
-	    xmlParseCRNG_patternBlock(ctxt);
-	} else if (token->token == ctxt->key_attribute) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    ctxt->isElem = 0;
-	    xmlParseCRNG_nameClass(ctxt);
-	    xmlParseCRNG_patternBlock(ctxt);
-	} else if (token->token == ctxt->key_mixed) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    xmlParseCRNG_patternBlock(ctxt);
-	} else if (token->token == ctxt->key_list) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    xmlParseCRNG_patternBlock(ctxt);
-	} else if (token->token == ctxt->key_empty) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	} else if (token->token == ctxt->key_notAllowed) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	} else if (token->token == ctxt->key_text) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	} else if (token->token == ctxt->key_parent) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    /* TODO */
-	} else if (token->token == ctxt->key_grammar) {
-	    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    /* TODO */
-	} else if (token->token == ctxt->key_external) {
-	    ctxt->insert = xmlNewNode(NULL, BAD_CAST "externalRef");
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	    /* TODO */
-	} else {
-	   /* TODO */
-	}
-    } else if (token->toktype == CRNG_IDENTIFIER) {
-	ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_ref);
-	if (ctxt->insert == NULL) CRNG_MEM_ERROR0();
-	xmlSetProp(ctxt->insert, BAD_CAST "name", token->token);
-	xmlParseCRNGDropTokens(ctxt, 1);
-    } else if (token->toktype == CRNG_QNAME) {
-        xmlParseCRNG_datatype(ctxt);
-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {
-        xmlParseCRNG_datatype(ctxt);
-    } else if ((token->toktype == CRNG_OP) &&
-               (token->token[0] == '(') && (token->token[1] == 0)) {
-	xmlParseCRNGDropTokens(ctxt, 1);
-	xmlParseCRNG_pattern(ctxt);
-	token = xmlParseCRNGGetToken(ctxt, 1);
-	if ((token->toktype != CRNG_OP) ||
-	    (token->token[0] != ')') || (token->token[1] != 0)) {
-	    ERROR("Expecting \")\" here");
-	}
-	xmlParseCRNGDropTokens(ctxt, 1);
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_particle:
- * @ctxt: a compact RNG parser context
- *
- * Parse particle of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_particle(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-    xmlNodePtr insert = ctxt->insert, res, tmp = NULL;
-
-    ctxt->insert = NULL;
-    xmlParseCRNG_primary(ctxt);
-    res = ctxt->insert;
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if ((token != NULL) && (token->toktype == CRNG_OP)) {
-        if ((token->token[0] == '*') && (token->token[1] == 0)) {
-	    tmp = xmlNewNode(NULL, BAD_CAST "zeroOrMore");
-	    if (tmp == NULL) CRNG_MEM_ERROR0();
-	} else if ((token->token[0] == '+') && (token->token[1] == 0)) {
-	    tmp = xmlNewNode(NULL, BAD_CAST "oneOrMore");
-	    if (tmp == NULL) CRNG_MEM_ERROR0();
-	} else if ((token->token[0] == '?') && (token->token[1] == 0)) {
-	    tmp = xmlNewNode(NULL, BAD_CAST "optional");
-	    if (tmp == NULL) CRNG_MEM_ERROR0();
-	}
-	if (tmp != NULL) {
-	    xmlAddChild(tmp, res);
-	    res = tmp;
-	    xmlParseCRNGDropTokens(ctxt, 1);
-	}
-    }
-    if (insert != NULL) {
-        xmlAddChild(insert, res);
-	ctxt->insert = insert;
-    } else
-        ctxt->insert = res;
-    return(0);
-}
-
-/**
- * xmlParseCRNG_pattern:
- * @ctxt: a compact RNG parser context
- *
- * Parse pattern of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_pattern(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-    xmlNodePtr insert = ctxt->insert, prev, grp;
-
-    ctxt->insert = NULL;
-    xmlParseCRNG_particle(ctxt);
-    prev = ctxt->insert;
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    while ((prev != NULL) && (token != NULL) && (token->toktype == CRNG_OP)) {
-        if (token->token == ctxt->key_or) {
-	    grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_choice);
-	    if (grp == NULL) CRNG_MEM_ERROR0();
-	} else if (token->token == ctxt->key_and) {
-	    grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_interleave);
-	    if (grp == NULL) CRNG_MEM_ERROR0();
-	} else if (token->token == ctxt->key_comma) {
-	    grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_group);
-	    if (grp == NULL) CRNG_MEM_ERROR0();
-	} else
-	   break;
-	xmlParseCRNGDropTokens(ctxt, 1);
-        ctxt->insert = NULL;
-	xmlParseCRNG_particle(ctxt);
-	xmlAddChild(grp, prev);
-	xmlAddChild(grp, ctxt->insert);
-	prev = grp;
-	token = xmlParseCRNGGetToken(ctxt, 1);
-    }
-    if (insert != NULL) {
-	xmlAddChild(insert, prev);
-	ctxt->insert = insert;
-    } else {
-	ctxt->insert = prev;
-    }
-
-    return(0);
-}
-
-/**
- * xmlParseCRNG_component:
- * @ctxt: a compact RNG parser context
- *
- * Parse component of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_component(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token, tok2;
-    xmlNodePtr insert = ctxt->insert;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token == NULL)
-        return(0);
-    if (token->toktype == CRNG_KEYWORD) {
-        if (token->token == ctxt->key_start) {
-	    xmlNodePtr start;
-
-	    start = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_start);
-	    if (start == NULL) CRNG_MEM_ERROR0();
-	    if (ctxt->insert != NULL)
-	        xmlAddChild(ctxt->insert, start);
-	    ctxt->insert = start;
-            xmlParseCRNGDropTokens(ctxt, 1);
-	    token = xmlParseCRNGGetToken(ctxt, 1);
-
-            if ((token->toktype == CRNG_OP) &&
-	        (token->token == ctxt->key_equal)) {
-	    } else if ((token->toktype == CRNG_OP) &&
-	               (token->token == ctxt->key_orequal)) {
-		xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,
-		                       BAD_CAST "choice");
-	    } else if ((token->toktype == CRNG_OP) &&
-	               (token->token == ctxt->key_andequal)) {
-		xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,
-		                       BAD_CAST "interleave");
-	    } else {
-	        ERROR("expecting \"=\" or \"&=\" or \"|=\" here")
-		return(-1);
-	    }
-	    start->properties = ctxt->attrs;
-	    ctxt->attrs = NULL;
-            xmlParseCRNGDropTokens(ctxt, 1);
-	    xmlParseCRNG_pattern(ctxt);
-
-	} else if (token->token == ctxt->key_include) {
-	    /* TODO */
-	} else if (token->token == ctxt->key_div) {
-	    /* TODO */
-	} else {
-	    return(-1);
-	}
-    } else if (token->toktype == CRNG_IDENTIFIER) {
-        xmlNodePtr define;
-	const xmlChar *identifier;
-
-        identifier = token->token;
-	tok2 = xmlParseCRNGGetToken(ctxt, 2);
-	if ((tok2->toktype == CRNG_OP) &&
-	    (tok2->token == ctxt->key_equal)) {
-	} else if ((tok2->toktype == CRNG_OP) &&
-		   (tok2->token == ctxt->key_orequal)) {
-	    xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,
-				   BAD_CAST "choice");
-	} else if ((tok2->toktype == CRNG_OP) &&
-		   (tok2->token == ctxt->key_andequal)) {
-	    xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,
-				   BAD_CAST "interleave");
-	} else {
-	    ERROR("expecting \"=\" or \"&=\" or \"|=\" here")
-	    return(-1);
-	}
-	xmlParseCRNGDropTokens(ctxt, 2);
-
-	define = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_define);
-	if (define == NULL) CRNG_MEM_ERROR0();
-	define->properties = ctxt->attrs;
-	ctxt->attrs = NULL;
-	xmlSetProp(define, BAD_CAST "name", identifier);
-	if (ctxt->insert != NULL)
-	    xmlAddChild(ctxt->insert, define);
-	ctxt->insert = define;
-	xmlParseCRNG_pattern(ctxt);
-    } else {
-	return(-1);
-    }
-    ctxt->insert = insert;
-    return(0);
-}
-
-/**
- * xmlParseCRNG_grammar:
- * @ctxt: a compact RNG parser context
- *
- * Parse grammar of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_grammar(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)
-{
-    tokenPtr token;
-    int ret;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    while (token != NULL) {
-        ret = xmlParseCRNG_component(ctxt);
-	if (ret != 0)
-	    break;
-	token = xmlParseCRNGGetToken(ctxt, 1);
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_topLevelBody:
- * @ctxt: a compact RNG parser context
- *
- * Parse topLevelBody of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_topLevelBody(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token, tok2;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token->toktype == CRNG_KEYWORD) {
-        if ((token->token == ctxt->key_start) ||
-	    (token->token == ctxt->key_include) ||
-	    (token->token == ctxt->key_div)) {
-	    xmlNodePtr grammar;
-
-	    grammar = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_grammar);
-	    if (grammar == NULL) CRNG_MEM_ERROR0();
-	    xmlDocSetRootElement(ctxt->doc, grammar);
-	    ctxt->insert = grammar;
-
-	    xmlParseCRNG_grammar(ctxt);
-	} else {
-	    xmlParseCRNG_pattern(ctxt);
-	}
-    } else {
-        tok2 = xmlParseCRNGGetToken(ctxt, 2);
-	if ((tok2->toktype == CRNG_OP) &&
-	    ((tok2->token == ctxt->key_equal) ||
-	     (tok2->token == ctxt->key_orequal) ||
-	     (tok2->token == ctxt->key_andequal))) {
-	    xmlNodePtr grammar;
-
-	    grammar = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_grammar);
-	    if (grammar == NULL) CRNG_MEM_ERROR0();
-	    xmlDocSetRootElement(ctxt->doc, grammar);
-	    ctxt->insert = grammar;
-
-	    xmlParseCRNG_grammar(ctxt);
-	} else {
-	    xmlParseCRNG_pattern(ctxt);
-	}
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_namespacePrefix:
- * @ctxt: a compact RNG parser context
- *
- * Parse namespacePrefix of the RELAX NG Compact Syntax Appendix A
- *
- * Returns the prefix or NULL in case of error
- */
-static const xmlChar *
-xmlParseCRNG_namespacePrefix(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-    const xmlChar *prefix = NULL;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token->toktype == CRNG_IDENTIFIER) {
-        prefix = token->token;
-    } else if (token->toktype == CRNG_OP) {
-	if ((token->token[0] == '=') && (token->token[1] == 0))
-	    return(NULL);
-        prefix = token->token;
-    } else {
-	ERROR("Expecting a namespace prefix");
-	return(NULL);
-    }
-    xmlParseCRNGDropTokens(ctxt, 1);
-
-    if (xmlStrEqual(prefix, BAD_CAST "xmlns")) {
-	ERROR("Namespace prefix \"xmlns\" is forbidden");
-    }
-    return(prefix);
-}
-
-/**
- * xmlParseCRNG_decl:
- * @ctxt: a compact RNG parser context
- *
- * Parse decl of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_decl(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    const xmlChar *prefix = NULL;
-    const xmlChar *namespace = NULL;
-    tokenPtr token;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    if (token->toktype != CRNG_KEYWORD) return(-1);
-    if (token->token == ctxt->key_default) {
-        xmlParseCRNGDropTokens(ctxt, 1);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype != CRNG_KEYWORD) ||
-	    (token->token != ctxt->key_namespace)) {
-	    ERROR("Expecting keyword \"namespace\" after \"default\"");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-	prefix = xmlParseCRNG_namespacePrefix(ctxt);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype != CRNG_OP) ||
-	    (token->token[0] != '=') || (token->token[1] != 0)) {
-	    ERROR("Expecting keyword \"=\" here");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype == CRNG_KEYWORD) &&
-	    (token->token == ctxt->key_inherit)) {
-	    namespace = xmlCRelaxNGInherit;
-	} else if (token->toktype == CRNG_LITERAL_SEGMENT) {
-	    namespace = token->token;
-	} else {
-	    ERROR("Expecting an URI or \"inherit\" value");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        if (namespace != NULL) {
-	    if (prefix != NULL)
-		xmlParseCRNG_bindPrefix(ctxt, prefix, namespace);
-            xmlParseCRNG_bindPrefix(ctxt, NULL, namespace);
-	}
-    } else if (token->token == ctxt->key_namespace) {
-        xmlParseCRNGDropTokens(ctxt, 1);
-	prefix = xmlParseCRNG_namespacePrefix(ctxt);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype != CRNG_OP) ||
-	    (token->token[0] != '=') || (token->token[1] != 0)) {
-	    ERROR("Expecting keyword \"=\" here");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype == CRNG_KEYWORD) &&
-	    (token->token == ctxt->key_inherit)) {
-	    namespace = xmlCRelaxNGInherit;
-	} else if (token->toktype == CRNG_LITERAL_SEGMENT) {
-	    namespace = token->token;
-	} else {
-	    ERROR("Expecting an URI or \"inherit\" value");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        if (namespace != NULL)
-	    xmlParseCRNG_bindPrefix(ctxt, prefix, namespace);
-    } else if (token->token == ctxt->key_datatypes) {
-        xmlParseCRNGDropTokens(ctxt, 1);
-
-        token = xmlParseCRNGGetToken(ctxt, 1);
-	if ((token->toktype != CRNG_KEYWORD) &&
-	    (token->toktype != CRNG_IDENTIFIER)) {
-	    ERROR("Expecting a datatype prefix identifier here");
-	} else
-	    prefix = token->token;
-        xmlParseCRNGDropTokens(ctxt, 1);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-        if ((token->toktype != CRNG_OP) ||
-	    (token->token[0] != '=') || (token->token[1] != 0)) {
-	    ERROR("Expecting keyword \"=\" here");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        token = xmlParseCRNGGetToken(ctxt, 1);
-	if (token->toktype == CRNG_LITERAL_SEGMENT) {
-	    namespace = token->token;
-	} else {
-	    ERROR("Expecting a literal value for the datatype identifier");
-	}
-        xmlParseCRNGDropTokens(ctxt, 1);
-        if ((namespace != NULL) && (prefix != NULL))
-	    xmlParseCRNG_bindDatatypePrefix(ctxt, prefix, namespace);
-    }
-
-    return(0);
-}
-
-/**
- * xmlParseCRNG_preamble:
- * @ctxt: a compact RNG parser context
- *
- * Parse preamble of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_preamble(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    tokenPtr token;
-
-    token = xmlParseCRNGGetToken(ctxt, 1);
-    while (token != NULL) {
-	if (token == NULL) return(-1);
-	if ((token->toktype == CRNG_KEYWORD) &&
-	    ((token->token == ctxt->key_default) ||
-	     (token->token == ctxt->key_namespace) ||
-	     (token->token == ctxt->key_datatypes))) {
-	    xmlParseCRNG_decl(ctxt);
-	} else
-	    break;
-	token = xmlParseCRNGGetToken(ctxt, 1);
-    }
-    return(0);
-}
-
-/**
- * xmlParseCRNG_topLevel:
- * @ctxt: a compact RNG parser context
- *
- * Parse topLevel of the RELAX NG Compact Syntax Appendix A
- *
- * Returns 0 in case of success and -1 in case of error
- */
-static int
-xmlParseCRNG_topLevel(xmlCRelaxNGParserCtxtPtr ctxt)
-{
-    xmlParseCRNG_preamble(ctxt);
-    xmlParseCRNG_topLevelBody(ctxt);
-    return(0);
-}
-
-/**
- * xmlConvertCRNG:
- * @schemas:  pointer to the text of the compact schemas
- * @len:  length of the schemas in bytes (or 0)
- * @encoding:  encoding indicated by the context or NULL
- *
- * Compiles the schemas into the equivalent Relax-NG XML structure
- *
- * Returns the xmlDocPtr resulting from the compilation or
- *         NULL in case of error
- */
-xmlDocPtr
-xmlConvertCRNG(const char *schemas, int len, const char *encoding) {
-    struct _xmlCRelaxNGParserCtxt ctxt;
-    xmlDocPtr ret = NULL;
-
-    if (schemas == NULL) return(NULL);
-    if (len <= 5) len = xmlStrlen((const unsigned char *) schemas);
-    if (len <= 0) return(NULL);
-
-    memset(&ctxt, 0, sizeof(ctxt));
-    ctxt.compact = (const unsigned char *) schemas;
-    ctxt.cur = (const unsigned char *) schemas;
-    ctxt.end = (const unsigned char *) &schemas[len];
-    ctxt.dict = xmlDictCreate();
-    if (ctxt.dict == NULL)
-        return(NULL);
-    ctxt.doc = xmlNewDoc(NULL);
-    if (ctxt.doc == NULL) {
-	xmlDictFree(ctxt.dict);
-	return(NULL);
-    }
-    ctxt.doc->dict = ctxt.dict;
-    xmlDictReference(ctxt.dict);
-
-    ctxt.nbTokens = 0;
-    ctxt.firstToken = 0;
-    ctxt.key_attribute = xmlDictLookup(ctxt.dict, BAD_CAST "attribute", -1);
-    ctxt.key_default = xmlDictLookup(ctxt.dict, BAD_CAST "default", -1);
-    ctxt.key_datatypes = xmlDictLookup(ctxt.dict, BAD_CAST "datatypes", -1);
-    ctxt.key_div = xmlDictLookup(ctxt.dict, BAD_CAST "div", -1);
-    ctxt.key_element = xmlDictLookup(ctxt.dict, BAD_CAST "element", -1);
-    ctxt.key_empty = xmlDictLookup(ctxt.dict, BAD_CAST "empty", -1);
-    ctxt.key_external = xmlDictLookup(ctxt.dict, BAD_CAST "external", -1);
-    ctxt.key_grammar = xmlDictLookup(ctxt.dict, BAD_CAST "grammar", -1);
-    ctxt.key_include = xmlDictLookup(ctxt.dict, BAD_CAST "include", -1);
-    ctxt.key_inherit = xmlDictLookup(ctxt.dict, BAD_CAST "inherit", -1);
-    ctxt.key_list = xmlDictLookup(ctxt.dict, BAD_CAST "list", -1);
-    ctxt.key_mixed = xmlDictLookup(ctxt.dict, BAD_CAST "mixed", -1);
-    ctxt.key_namespace = xmlDictLookup(ctxt.dict, BAD_CAST "namespace", -1);
-    ctxt.key_notAllowed = xmlDictLookup(ctxt.dict, BAD_CAST "notAllowed", -1);
-    ctxt.key_parent = xmlDictLookup(ctxt.dict, BAD_CAST "parent", -1);
-    ctxt.key_start = xmlDictLookup(ctxt.dict, BAD_CAST "start", -1);
-    ctxt.key_string = xmlDictLookup(ctxt.dict, BAD_CAST "string", -1);
-    ctxt.key_text = xmlDictLookup(ctxt.dict, BAD_CAST "text", -1);
-    ctxt.key_token = xmlDictLookup(ctxt.dict, BAD_CAST "token", -1);
-    ctxt.key_equal = xmlDictLookup(ctxt.dict, BAD_CAST "=", 1);
-    ctxt.key_orequal = xmlDictLookup(ctxt.dict, BAD_CAST "|=", 2);
-    ctxt.key_andequal = xmlDictLookup(ctxt.dict, BAD_CAST "&=", 2);
-    ctxt.key_combine = xmlDictLookup(ctxt.dict, BAD_CAST "&=", 2);
-    ctxt.key_or = xmlDictLookup(ctxt.dict, BAD_CAST "|", 1);
-    ctxt.key_comma = xmlDictLookup(ctxt.dict, BAD_CAST ",", 1);
-    ctxt.key_and = xmlDictLookup(ctxt.dict, BAD_CAST "&", 1);
-    ctxt.key_choice = xmlDictLookup(ctxt.dict, BAD_CAST "choice", -1);
-    ctxt.key_group = xmlDictLookup(ctxt.dict, BAD_CAST "group", -1);
-    ctxt.key_interleave = xmlDictLookup(ctxt.dict, BAD_CAST "interleave", -1);
-    ctxt.key_ref = xmlDictLookup(ctxt.dict, BAD_CAST "ref", 3);
-    ctxt.key_define = xmlDictLookup(ctxt.dict, BAD_CAST "define", 6);
-
-    /* xmlConvertCRNGTokenize(&ctxt); */
-    xmlConvertCRNG_topLevel(&ctxt);
-
-    xmlDictFree(ctxt.dict);
-
-    ret = ctxt.doc;
-    return(ret);
-}
-
-/**
- * xmlConvertCRNGFile:
- * @URL: URL or filename for the resource
- * @encoding:  encoding indicated by the context or NULL
- *
- * Compiles the schemas into the equivalent Relax-NG XML structure
- *
- * Returns the xmlDocPtr resulting from the compilation or
- *         NULL in case of error
- */
-xmlDocPtr
-xmlConvertCRNGFile(const char *URL, const char *encoding) {
-}
-
-#ifdef STANDALONE
-const xmlChar *schemas =
-"# RELAX NG XML syntax specified in compact syntax.\n\
-\n\
-default namespace rng = \"http://relaxng.org/ns/structure/1.0\"\n\
-namespace local = \"\"\n\
-datatypes xsd = \"http://www.w3.org/2001/XMLSchema-datatypes\"\n\
-\n\
-start = pattern\n\
-\n\
-pattern =\n\
-  element element { (nameQName | nameClass), (common & pattern+) }\n\
-  | element attribute { (nameQName | nameClass), (common & pattern?) }\n\
-  | element group|interleave|choice|optional\n\
-            |zeroOrMore|oneOrMore|list|mixed { common & pattern+ }\n\
-  | element ref|parentRef { nameNCName, common }\n\
-  | element empty|notAllowed|text { common }\n\
-  | element data { type, param*, (common & exceptPattern?) }\n\
-  | element value { commonAttributes, type?, xsd:string }\n\
-  | element externalRef { href, common }\n\
-  | element grammar { common & grammarContent* }\n\
-\n\
-param = element param { commonAttributes, nameNCName, xsd:string }\n\
-\n\
-exceptPattern = element except { common & pattern+ }\n\
-\n\
-grammarContent =\n\
-  definition\n\
-  | element div { common & grammarContent* }\n\
-  | element include { href, (common & includeContent*) }\n\
-\n\
-includeContent =\n\
-  definition\n\
-  | element div { common & includeContent* }\n\
-\n\
-definition =\n\
-  element start { combine?, (common & pattern+) }\n\
-  | element define { nameNCName, combine?, (common & pattern+) }\n\
-\n\
-combine = attribute combine { \"choice\" | \"interleave\" }\n\
-\n\
-nameClass =\n\
-  element name { commonAttributes, xsd:QName }\n\
-  | element anyName { common & exceptNameClass? }\n\
-  | element nsName { common & exceptNameClass? }\n\
-  | element choice { common & nameClass+ }\n\
-\n\
-exceptNameClass = element except { common & nameClass+ }\n\
-\n\
-nameQName = attribute name { xsd:QName }\n\
-nameNCName = attribute name { xsd:NCName }\n\
-href = attribute href { xsd:anyURI }\n\
-type = attribute type { xsd:NCName }\n\
-\n\
-common = commonAttributes, foreignElement*\n\
-\n\
-commonAttributes =\n\
-  attribute ns { xsd:string }?,\n\
-  attribute datatypeLibrary { xsd:anyURI }?,\n\
-  foreignAttribute*\n\
-\n\
-foreignElement = element * - rng:* { (anyAttribute | text | anyElement)* }\n\
-foreignAttribute = attribute * - (rng:*|local:*) { text }\n\
-anyElement = element * { (anyAttribute | text | anyElement)* }\n\
-anyAttribute = attribute * { text }\n\
-";
-
-int main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {
-    xmlDocPtr res;
-
-    res = xmlConvertCRNG(schemas, -1);
-    if (res != NULL) {
-        xmlDocFormatDump(stdout, res, 1);
-	xmlFreeDoc(res);
-    }
-    return(0);
-}
-#endif
diff --git a/runsuite.c b/runsuite.c
index 257b9210..c92b818e 100644
--- a/runsuite.c
+++ b/runsuite.c
@@ -6,7 +6,7 @@
  * daniel@veillard.com
  */
 
-#include "config.h"
+#include "libxml.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -122,14 +122,14 @@ testResourceLoader(void *vctxt ATTRIBUTE_UNUSED, const char *URL,
 
     for (i = 0; i < nb_entities; i++) {
         if (!strcmp(testEntitiesName[i], URL)) {
-	    *out = xmlInputCreateString(testEntitiesName[i],
+	    *out = xmlNewInputFromString(testEntitiesName[i],
                                         testEntitiesValue[i],
                                         XML_INPUT_BUF_STATIC);
 	    return(XML_ERR_OK);
 	}
     }
 
-    return(xmlInputCreateUrl(URL, 0, out));
+    return(xmlNewInputFromUrl(URL, 0, out));
 }
 
 /*
@@ -1010,7 +1010,7 @@ main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {
     int ret = 0;
     int old_errors, old_tests, old_leaks, expected_errors;
 
-    logfile = fopen(LOGFILE, "w");
+    logfile = fopen(LOGFILE, "wb");
     if (logfile == NULL) {
         fprintf(stderr,
 	        "Could not open the log file, running in verbose mode\n");
diff --git a/runtest.c b/runtest.c
index f3945dc3..e1456bb4 100644
--- a/runtest.c
+++ b/runtest.c
@@ -16,21 +16,24 @@
 
 #include "libxml.h"
 #include <stdio.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#elif defined (_WIN32)
-#include <io.h>
-#endif
 #include <stdlib.h>
 #include <string.h>
-#include <sys/stat.h>
+
 #include <fcntl.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+  #include <io.h>
+#else
+  #include <unistd.h>
+#endif
 
 #include <libxml/parser.h>
 #include <libxml/parserInternals.h>
 #include <libxml/tree.h>
 #include <libxml/uri.h>
 #include <libxml/encoding.h>
+#include <libxml/xmlsave.h>
 
 #ifdef LIBXML_OUTPUT_ENABLED
 #ifdef LIBXML_READER_ENABLED
@@ -55,6 +58,10 @@
 #include <libxml/xmlschemastypes.h>
 #endif
 
+#ifdef LIBXML_SCHEMATRON_ENABLED
+#include <libxml/schematron.h>
+#endif
+
 #ifdef LIBXML_PATTERN_ENABLED
 #include <libxml/pattern.h>
 #endif
@@ -71,6 +78,9 @@
 #if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)
 #include <libxml/threads.h>
 #include <libxml/parser.h>
+#endif
+
+#ifdef LIBXML_CATALOG_ENABLED
 #include <libxml/catalog.h>
 #endif
 
@@ -199,9 +209,35 @@ static void globfree(glob_t *pglob) {
     }
 }
 
-#else
+#elif HAVE_DECL_GLOB
+
 #include <glob.h>
-#endif
+
+#else /* _WIN32, HAVE_DECL_GLOB */
+
+#define GLOB_DOOFFS 0
+
+typedef struct {
+      size_t gl_pathc;    /* Count of paths matched so far  */
+      char **gl_pathv;    /* List of matched pathnames.  */
+      size_t gl_offs;     /* Slots to reserve in 'gl_pathv'.  */
+} glob_t;
+
+static int
+glob(const char *pattern ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED,
+     int errfunc(const char *epath, int eerrno) ATTRIBUTE_UNUSED,
+     glob_t *pglob) {
+    pglob->gl_pathc = 0;
+    pglob->gl_pathv = NULL;
+
+    return(0);
+}
+
+static void
+globfree(glob_t *pglob ATTRIBUTE_UNUSED) {
+}
+
+#endif /* _WIN32, HAVE_DECL_GLOB */
 
 /************************************************************************
  *									*
@@ -266,13 +302,16 @@ initializeLibxml2(void) {
     xmlInitParser();
     xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);
 #ifdef LIBXML_CATALOG_ENABLED
+    /*
+     * Disable system catalog which could cause lazy memory allocations
+     * resulting in false positive memory leaks.
+     */
 #ifdef _WIN32
     putenv("XML_CATALOG_FILES=");
 #else
     setenv("XML_CATALOG_FILES", "", 1);
 #endif
     xmlInitializeCatalog();
-    xmlCatalogSetDefaults(XML_CATA_ALLOW_NONE);
 #endif
 #ifdef LIBXML_SCHEMAS_ENABLED
     xmlSchemaInitTypes();
@@ -474,7 +513,8 @@ static int loadMem(const char *filename, const char **mem, int *size) {
     base = malloc(info.st_size + 1);
     if (base == NULL)
 	return(-1);
-    if ((fd = open(filename, RD_FLAGS)) < 0) {
+    fd = open(filename, RD_FLAGS);
+    if (fd  < 0) {
         free(base);
 	return(-1);
     }
@@ -2047,6 +2087,78 @@ pushBoundaryTest(const char *filename, const char *result,
 }
 #endif
 
+static char *
+dumpNodeList(xmlNodePtr list) {
+    xmlBufferPtr buffer;
+    xmlSaveCtxtPtr save;
+    xmlNodePtr cur;
+    char *ret;
+
+    buffer = xmlBufferCreate();
+    save = xmlSaveToBuffer(buffer, "UTF-8", 0);
+    for (cur = list; cur != NULL; cur = cur->next)
+        xmlSaveTree(save, cur);
+    xmlSaveClose(save);
+
+    ret = (char *) xmlBufferDetach(buffer);
+    xmlBufferFree(buffer);
+    return(ret);
+}
+
+static int
+testParseContent(xmlParserCtxtPtr ctxt, xmlDocPtr doc, const char *filename) {
+    xmlParserInputPtr input;
+    xmlNodePtr root = NULL, list;
+    char *content, *roundTrip;
+    int ret = 0;
+
+    if (ctxt->html) {
+        xmlNodePtr cur;
+
+        if (doc == NULL || doc->children == NULL)
+            return 0;
+        for (cur = doc->children->children; cur != NULL; cur = cur->next) {
+            if (xmlStrEqual(cur->name, BAD_CAST "body")) {
+                root = cur;
+                break;
+            }
+        }
+    } else {
+        root = xmlDocGetRootElement(doc);
+    }
+    if (root == NULL)
+        return 0;
+
+    content = dumpNodeList(root->children);
+
+    input = xmlNewInputFromString(NULL, content, XML_INPUT_BUF_STATIC);
+    list = xmlCtxtParseContent(ctxt, input, root, 0);
+    roundTrip = dumpNodeList(list);
+    if (strcmp(content, roundTrip) != 0) {
+        fprintf(stderr, "xmlCtxtParseContent failed for %s\n", filename);
+        ret = -1;
+    }
+    xmlFree(roundTrip);
+    xmlFreeNodeList(list);
+
+    /* xmlParseInNodeContext uses the document's encoding. */
+    xmlFree((xmlChar *) doc->encoding);
+    doc->encoding = (const xmlChar *) xmlStrdup(BAD_CAST "UTF-8");
+    xmlParseInNodeContext(root, content, strlen(content),
+                          ctxt->options | XML_PARSE_NOERROR,
+                          &list);
+    roundTrip = dumpNodeList(list);
+    if (strcmp(content, roundTrip) != 0) {
+        fprintf(stderr, "xmlParseInNodeContext failed for %s\n", filename);
+        ret = -1;
+    }
+    xmlFree(roundTrip);
+    xmlFreeNodeList(list);
+
+    xmlFree(content);
+    return(ret);
+}
+
 /**
  * memParseTest:
  * @filename: the file to parse
@@ -2062,10 +2174,14 @@ pushBoundaryTest(const char *filename, const char *result,
 static int
 memParseTest(const char *filename, const char *result,
              const char *err ATTRIBUTE_UNUSED,
-	     int options ATTRIBUTE_UNUSED) {
+	     int options) {
+    xmlParserCtxtPtr ctxt;
     xmlDocPtr doc;
     const char *base;
     int size, res;
+    int ret = 0;
+
+    options |= XML_PARSE_NOWARNING;
 
     nb_tests++;
     /*
@@ -2076,22 +2192,26 @@ memParseTest(const char *filename, const char *result,
 	return(-1);
     }
 
-    doc = xmlReadMemory(base, size, filename, NULL, XML_PARSE_NOWARNING);
+    ctxt = xmlNewParserCtxt();
+    doc = xmlCtxtReadMemory(ctxt, base, size, filename, NULL, options);
     unloadMem(base);
     if (doc == NULL) {
         return(1);
     }
     xmlDocDumpMemory(doc, (xmlChar **) &base, &size);
-    xmlFreeDoc(doc);
     res = compareFileMem(result, base, size);
     if ((base == NULL) || (res != 0)) {
-	if (base != NULL)
-	    xmlFree((char *)base);
         fprintf(stderr, "Result for %s failed in %s\n", filename, result);
-	return(-1);
+	ret = -1;
     }
+
+    if (testParseContent(ctxt, doc, filename) < 0)
+	ret = -1;
+
+    xmlFreeDoc(doc);
+    xmlFreeParserCtxt(ctxt);
     xmlFree((char *)base);
-    return(0);
+    return(ret);
 }
 
 /**
@@ -2168,8 +2288,8 @@ errParseTest(const char *filename, const char *result, const char *err,
              int options) {
     xmlParserCtxtPtr ctxt;
     xmlDocPtr doc;
-    const char *base = NULL;
     int size, res = 0;
+    int ret = 0;
 
     nb_tests++;
 #ifdef LIBXML_HTML_ENABLED
@@ -2177,14 +2297,12 @@ errParseTest(const char *filename, const char *result, const char *err,
         ctxt = htmlNewParserCtxt();
         xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);
         doc = htmlCtxtReadFile(ctxt, filename, NULL, options);
-        htmlFreeParserCtxt(ctxt);
     } else
 #endif
     {
         ctxt = xmlNewParserCtxt();
         xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);
 	doc = xmlCtxtReadFile(ctxt, filename, NULL, options);
-        xmlFreeParserCtxt(ctxt);
 #ifdef LIBXML_XINCLUDE_ENABLED
         if (options & XML_PARSE_XINCLUDE) {
             xmlXIncludeCtxtPtr xinc = NULL;
@@ -2202,40 +2320,45 @@ errParseTest(const char *filename, const char *result, const char *err,
 #endif
     }
     if (result) {
+        xmlChar *base = NULL;
+
 	if (doc == NULL) {
-	    base = "";
+	    base = xmlStrdup(BAD_CAST "");
 	    size = 0;
 	} else {
 #ifdef LIBXML_HTML_ENABLED
 	    if (options & XML_PARSE_HTML) {
-		htmlDocDumpMemory(doc, (xmlChar **) &base, &size);
+		htmlDocDumpMemory(doc, &base, &size);
 	    } else
 #endif
-	    xmlDocDumpMemory(doc, (xmlChar **) &base, &size);
+	    xmlDocDumpMemory(doc, &base, &size);
 	}
-	res = compareFileMem(result, base, size);
-    }
-    if (doc != NULL) {
-	if (base != NULL)
-	    xmlFree((char *)base);
-	xmlFreeDoc(doc);
+	res = compareFileMem(result, (char *) base, size);
+	xmlFree(base);
     }
+
     if (res != 0) {
         fprintf(stderr, "Result for %s failed in %s\n", filename, result);
-        return(-1);
-    }
-    if (err != NULL) {
+        ret = -1;
+    } else if (err != NULL) {
 	res = compareFileMem(err, testErrors, testErrorsSize);
 	if (res != 0) {
 	    fprintf(stderr, "Error for %s failed\n", filename);
-	    return(-1);
+	    ret = -1;
 	}
     } else if (options & XML_PARSE_DTDVALID) {
-        if (testErrorsSize != 0)
+        if (testErrorsSize != 0) {
 	    fprintf(stderr, "Validation for %s failed\n", filename);
+            ret = -1;
+        }
     }
 
-    return(0);
+    if (testParseContent(ctxt, doc, filename) < 0)
+	ret = -1;
+
+    xmlFreeDoc(doc);
+    xmlFreeParserCtxt(ctxt);
+    return(ret);
 }
 
 #if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_HTML_ENABLED)
@@ -3169,29 +3292,19 @@ uriPathTest(const char *filename ATTRIBUTE_UNUSED,
 static int
 schemasOneTest(const char *sch,
                const char *filename,
-               const char *result,
                const char *err,
 	       int options,
 	       xmlSchemaPtr schemas) {
     int ret = 0;
     int i;
-    char *temp;
     int parseErrorsSize = testErrorsSize;
 
-    temp = resultFilename(result, temp_directory, ".res");
-    if (temp == NULL) {
-        fprintf(stderr, "Out of memory\n");
-        fatalError();
-        return(-1);
-    }
-
     /*
      * Test both memory and streaming validation.
      */
     for (i = 0; i < 2; i++) {
         xmlSchemaValidCtxtPtr ctxt;
         int validResult = 0;
-        FILE *schemasOutput;
 
         testErrorsSize = parseErrorsSize;
         testErrors[parseErrorsSize] = 0;
@@ -3203,13 +3316,6 @@ schemasOneTest(const char *sch,
         xmlSchemaSetValidStructuredErrors(ctxt, testStructuredErrorHandler,
                                           NULL);
 
-        schemasOutput = fopen(temp, "wb");
-        if (schemasOutput == NULL) {
-            fprintf(stderr, "failed to open output file %s\n", temp);
-            free(temp);
-            return(-1);
-        }
-
         if (i == 0) {
             xmlDocPtr doc;
 
@@ -3225,20 +3331,12 @@ schemasOneTest(const char *sch,
         }
 
         if (validResult == 0) {
-            fprintf(schemasOutput, "%s validates\n", filename);
+            testErrorHandler(NULL, "%s validates\n", filename);
         } else if (validResult > 0) {
-            fprintf(schemasOutput, "%s fails to validate\n", filename);
+            testErrorHandler(NULL, "%s fails to validate\n", filename);
         } else {
-            fprintf(schemasOutput, "%s validation generated an internal error\n",
-                   filename);
-        }
-        fclose(schemasOutput);
-
-        if (result) {
-            if (compareFiles(temp, result)) {
-                fprintf(stderr, "Result for %s on %s failed\n", filename, sch);
-                ret = 1;
-            }
+            testErrorHandler(NULL, "%s validation generated an internal "
+                             "error\n", filename);
         }
 
         xmlSchemaFreeValidCtxt(ctxt);
@@ -3248,11 +3346,8 @@ done:
             fprintf(stderr, "Error for %s on %s failed\n", filename, sch);
             ret = 1;
         }
-
-        unlink(temp);
     }
 
-    free(temp);
     return(ret);
 }
 /**
@@ -3280,7 +3375,6 @@ schemasTest(const char *filename,
     int parseErrorsSize;
     char pattern[500];
     char prefix[500];
-    char result[500];
     char err[500];
     glob_t globbuf;
     size_t i;
@@ -3330,10 +3424,6 @@ schemasTest(const char *filename,
 	len = strlen(base2);
 	if ((len > 6) && (base2[len - 6] == '_')) {
 	    count = base2[len - 5];
-	    ret = snprintf(result, 499, "result/schemas/%s_%c",
-		     prefix, count);
-            if (ret >= 499)
-	        result[499] = 0;
 	    ret = snprintf(err, 499, "result/schemas/%s_%c.err",
 		     prefix, count);
             if (ret >= 499)
@@ -3344,8 +3434,7 @@ schemasTest(const char *filename,
 	}
 
         nb_tests++;
-        ret = schemasOneTest(filename, instance, result, err,
-                             options, schemas);
+        ret = schemasOneTest(filename, instance, err, options, schemas);
         if (ret != 0)
             res = ret;
     }
@@ -3363,14 +3452,11 @@ schemasTest(const char *filename,
 static int
 rngOneTest(const char *sch,
                const char *filename,
-               const char *result,
 	       int options,
 	       xmlRelaxNGPtr schemas) {
     xmlDocPtr doc;
     xmlRelaxNGValidCtxtPtr ctxt;
     int ret = 0;
-    char *temp;
-    FILE *schemasOutput;
 
     doc = xmlReadFile(filename, NULL, options);
     if (doc == NULL) {
@@ -3378,19 +3464,6 @@ rngOneTest(const char *sch,
 	return(-1);
     }
 
-    temp = resultFilename(result, temp_directory, ".res");
-    if (temp == NULL) {
-        fprintf(stderr, "Out of memory\n");
-        fatalError();
-    }
-    schemasOutput = fopen(temp, "wb");
-    if (schemasOutput == NULL) {
-	fprintf(stderr, "failed to open output file %s\n", temp);
-	xmlFreeDoc(doc);
-        free(temp);
-	return(-1);
-    }
-
     ctxt = xmlRelaxNGNewValidCtxt(schemas);
     xmlRelaxNGSetValidStructuredErrors(ctxt, testStructuredErrorHandler, NULL);
     ret = xmlRelaxNGValidateDoc(ctxt, doc);
@@ -3402,22 +3475,10 @@ rngOneTest(const char *sch,
 	testErrorHandler(NULL, "%s validation generated an internal error\n",
 	       filename);
     }
-    fclose(schemasOutput);
-    ret = 0;
-    if (result) {
-	if (compareFiles(temp, result)) {
-	    fprintf(stderr, "Result for %s on %s failed\n", filename, sch);
-	    ret = 1;
-	}
-    }
-    if (temp != NULL) {
-        unlink(temp);
-        free(temp);
-    }
 
     xmlRelaxNGFreeValidCtxt(ctxt);
     xmlFreeDoc(doc);
-    return(ret);
+    return(0);
 }
 /**
  * rngTest:
@@ -3443,7 +3504,6 @@ rngTest(const char *filename,
     int parseErrorsSize;
     char pattern[500];
     char prefix[500];
-    char result[500];
     char err[500];
     glob_t globbuf;
     size_t i;
@@ -3485,10 +3545,6 @@ rngTest(const char *filename,
 	len = strlen(base2);
 	if ((len > 6) && (base2[len - 6] == '_')) {
 	    count = base2[len - 5];
-	    res = snprintf(result, 499, "result/relaxng/%s_%c",
-		     prefix, count);
-            if (res >= 499)
-	        result[499] = 0;
 	    res = snprintf(err, 499, "result/relaxng/%s_%c.err",
 		     prefix, count);
             if (res >= 499)
@@ -3499,7 +3555,7 @@ rngTest(const char *filename,
 	}
 	if (schemas != NULL) {
 	    nb_tests++;
-	    res = rngOneTest(filename, instance, result, options, schemas);
+	    res = rngOneTest(filename, instance, options, schemas);
 	    if (res != 0)
 		ret = res;
 	}
@@ -3617,6 +3673,131 @@ rngStreamTest(const char *filename,
 
 #endif
 
+/************************************************************************
+ *									*
+ *			Schematron tests				*
+ *									*
+ ************************************************************************/
+
+#ifdef LIBXML_SCHEMATRON_ENABLED
+static int
+schematronOneTest(const char *sch, const char *filename, int options,
+                  xmlSchematronPtr schematron) {
+    xmlDocPtr doc;
+    xmlSchematronValidCtxtPtr ctxt;
+    int ret;
+
+    doc = xmlReadFile(filename, NULL, options);
+    if (doc == NULL) {
+        fprintf(stderr, "failed to parse instance %s for %s\n", filename, sch);
+	return(-1);
+    }
+
+    ctxt = xmlSchematronNewValidCtxt(schematron, XML_SCHEMATRON_OUT_ERROR);
+    xmlSchematronSetValidStructuredErrors(ctxt, testStructuredErrorHandler,
+                                          NULL);
+    ret = xmlSchematronValidateDoc(ctxt, doc);
+    if (ret == 0) {
+	testErrorHandler(NULL, "%s validates\n", filename);
+    } else if (ret > 0) {
+	testErrorHandler(NULL, "%s fails to validate\n", filename);
+    } else {
+	testErrorHandler(NULL, "%s validation generated an internal error\n",
+	       filename);
+    }
+
+    xmlSchematronFreeValidCtxt(ctxt);
+    xmlFreeDoc(doc);
+    return(0);
+}
+
+/**
+ * schematronTest:
+ * @filename: the schemas file
+ * @result: the file with expected result
+ * @err: the file with error messages
+ *
+ * Returns 0 in case of success, an error code otherwise
+ */
+static int
+schematronTest(const char *filename,
+               const char *resul ATTRIBUTE_UNUSED,
+               const char *errr ATTRIBUTE_UNUSED,
+               int options) {
+    const char *base = baseFilename(filename);
+    const char *base2;
+    const char *instance;
+    xmlSchematronParserCtxtPtr pctxt;
+    xmlSchematronPtr schematron;
+    int res = 0, len, ret = 0;
+    int parseErrorsSize;
+    char pattern[500];
+    char prefix[500];
+    char err[500];
+    glob_t globbuf;
+    size_t i;
+    char count = 0;
+
+    pctxt = xmlSchematronNewParserCtxt(filename);
+    schematron = xmlSchematronParse(pctxt);
+    xmlSchematronFreeParserCtxt(pctxt);
+    if (schematron == NULL)
+        testErrorHandler(NULL, "Schematron schema %s failed to compile\n",
+                         filename);
+    parseErrorsSize = testErrorsSize;
+
+    /*
+     * most of the mess is about the output filenames generated by the Makefile
+     */
+    len = strlen(base);
+    if ((len > 499) || (len < 5)) {
+        xmlSchematronFree(schematron);
+	return(-1);
+    }
+    len -= 4; /* remove trailing .sct */
+    memcpy(prefix, base, len);
+    prefix[len] = 0;
+
+    if (snprintf(pattern, 499, "./test/schematron/%s_?.xml", prefix) >= 499)
+        pattern[499] = 0;
+
+    globbuf.gl_offs = 0;
+    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);
+    for (i = 0;i < globbuf.gl_pathc;i++) {
+        testErrorsSize = parseErrorsSize;
+        testErrors[parseErrorsSize] = 0;
+        instance = globbuf.gl_pathv[i];
+	base2 = baseFilename(instance);
+	len = strlen(base2);
+	if ((len > 6) && (base2[len - 6] == '_')) {
+	    count = base2[len - 5];
+	    res = snprintf(err, 499, "result/schematron/%s_%c.err",
+		     prefix, count);
+            if (res >= 499)
+	        err[499] = 0;
+	} else {
+	    fprintf(stderr, "don't know how to process %s\n", instance);
+	    continue;
+	}
+	if (schematron != NULL) {
+	    nb_tests++;
+	    res = schematronOneTest(filename, instance, options, schematron);
+	    if (res != 0)
+		ret = res;
+	}
+        if (compareFileMem(err, testErrors, testErrorsSize)) {
+            fprintf(stderr, "Error for %s on %s failed\n", instance,
+                    filename);
+            ret = 1;
+        }
+    }
+    globfree(&globbuf);
+    xmlSchematronFree(schematron);
+
+    return(ret);
+}
+#endif /* LIBXML_SCHEMATRON_ENABLED */
+
 #ifdef LIBXML_PATTERN_ENABLED
 #ifdef LIBXML_READER_ENABLED
 /************************************************************************
@@ -4143,9 +4324,6 @@ c14n11WithoutCommentTest(const char *filename,
  *									*
  ************************************************************************/
 
-/*
- * mostly a cut and paste from testThreads.c
- */
 #define	MAX_ARGC	20
 
 typedef struct {
@@ -4174,6 +4352,12 @@ thread_specific_data(void *private_data)
     const char *filename = params->filename;
     int okay = 1;
 
+    if (xmlCheckThreadLocalStorage() != 0) {
+        printf("xmlCheckThreadLocalStorage failed\n");
+        params->okay = 0;
+        return(NULL);
+    }
+
 #ifdef LIBXML_THREAD_ALLOC_ENABLED
     xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);
 #endif
@@ -4262,7 +4446,7 @@ testThread(void)
     return (res);
 }
 
-#elif defined HAVE_PTHREAD_H
+#else
 #include <pthread.h>
 
 static pthread_t tid[MAX_ARGC];
@@ -4311,28 +4495,13 @@ testThread(void)
     }
     return (res);
 }
-
-#else
-static int
-testThread(void)
-{
-    fprintf(stderr,
-            "Specific platform thread support not detected\n");
-    return (-1);
-}
 #endif
 static int
 threadsTest(const char *filename ATTRIBUTE_UNUSED,
 	    const char *resul ATTRIBUTE_UNUSED,
 	    const char *err ATTRIBUTE_UNUSED,
 	    int options ATTRIBUTE_UNUSED) {
-    int ret;
-
-    xmlCatalogSetDefaults(XML_CATA_ALLOW_ALL);
-    ret = testThread();
-    xmlCatalogSetDefaults(XML_CATA_ALLOW_NONE);
-
-    return(ret);
+    return(testThread());
 }
 #endif
 
@@ -4452,9 +4621,6 @@ done:
     return(res);
 }
 
-#endif /* LIBXML_REGEXPS_ENABLED */
-
-#ifdef LIBXML_AUTOMATA_ENABLED
 /************************************************************************
  *									*
  *			Automata tests					*
@@ -4691,7 +4857,7 @@ automataTest(const char *filename, const char *result,
     return(res);
 }
 
-#endif /* LIBXML_AUTOMATA_ENABLED */
+#endif /* LIBXML_REGEXP_ENABLED */
 
 /************************************************************************
  *									*
@@ -4866,6 +5032,11 @@ testDesc testDescriptions[] = {
       XML_PARSE_DTDATTR | XML_PARSE_NOENT },
 #endif
 #endif
+#if defined(LIBXML_SCHEMATRON_ENABLED)
+    { "Schematron regression tests" ,
+      schematronTest, "./test/schematron/*.sct", NULL, NULL, NULL,
+      0 },
+#endif
 #ifdef LIBXML_PATTERN_ENABLED
 #ifdef LIBXML_READER_ENABLED
     { "Pattern regression tests" ,
@@ -4899,8 +5070,6 @@ testDesc testDescriptions[] = {
     { "Regexp regression tests" ,
       regexpTest, "./test/regexp/*", "result/regexp/", "", ".err",
       0 },
-#endif
-#if defined(LIBXML_AUTOMATA_ENABLED)
     { "Automata regression tests" ,
       automataTest, "./test/automata/*", "result/automata/", "", NULL,
       0 },
@@ -4959,6 +5128,11 @@ launchTests(testDescPtr tst) {
                 ((eucJpHandler == NULL) &&
                  (strstr(globbuf.gl_pathv[i], "icu_parse_test") != NULL)))
                 continue;
+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \
+    !defined(LIBXML_ISO8859X_ENABLED)
+            if (strstr(globbuf.gl_pathv[i], "iso-8859-5") != NULL)
+                continue;
+#endif
 	    if (tst->suffix != NULL) {
 		result = resultFilename(globbuf.gl_pathv[i], tst->out,
 					tst->suffix);
diff --git a/runxmlconf.c b/runxmlconf.c
index dfbbf6b7..62401e8e 100644
--- a/runxmlconf.c
+++ b/runxmlconf.c
@@ -6,7 +6,7 @@
  * daniel@veillard.com
  */
 
-#include "config.h"
+#include "libxml.h"
 #include <stdio.h>
 #include <libxml/xmlversion.h>
 
@@ -545,7 +545,7 @@ main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {
     int ret = 0;
     int old_errors, old_tests, old_leaks;
 
-    logfile = fopen(LOGFILE, "w");
+    logfile = fopen(LOGFILE, "wb");
     if (logfile == NULL) {
         fprintf(stderr,
 	        "Could not open the log file, running in verbose mode\n");
diff --git a/schematron.c b/schematron.c
index d5e81ecf..21e9956b 100644
--- a/schematron.c
+++ b/schematron.c
@@ -271,10 +271,10 @@ xmlSchematronPErr(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr node, int error,
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, ctxt, node,
-                          XML_FROM_SCHEMASP, error, XML_ERR_ERROR, NULL, 0,
-                          (const char *) str1, (const char *) str2, NULL, 0, 0,
-                          msg, str1, str2);
+    res = xmlRaiseError(schannel, channel, data, ctxt, node,
+                        XML_FROM_SCHEMASP, error, XML_ERR_ERROR, NULL, 0,
+                        (const char *) str1, (const char *) str2, NULL, 0, 0,
+                        msg, str1, str2);
     if (res < 0)
         xmlSchematronPErrMemory(ctxt);
 }
@@ -328,10 +328,10 @@ xmlSchematronVErr(xmlSchematronValidCtxtPtr ctxt, int error,
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, ctxt, NULL,
-                          XML_FROM_SCHEMASV, error, XML_ERR_ERROR, NULL, 0,
-                          (const char *) str1, NULL, NULL, 0, 0,
-                          msg, str1);
+    res = xmlRaiseError(schannel, channel, data, ctxt, NULL,
+                        XML_FROM_SCHEMASV, error, XML_ERR_ERROR, NULL, 0,
+                        (const char *) str1, NULL, NULL, 0, 0,
+                        msg, str1);
     if (res < 0)
         xmlSchematronVErrMemory(ctxt);
 }
@@ -951,7 +951,6 @@ xmlSchematronParseTestReportMsg(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr con)
             xmlFree(select);
         }
         child = child->next;
-        continue;
     }
 }
 
@@ -1049,7 +1048,7 @@ xmlSchematronParseRule(xmlSchematronParserCtxtPtr ctxt,
                 return;
             }
 
-            let = (xmlSchematronLetPtr) malloc(sizeof(xmlSchematronLet));
+            let = (xmlSchematronLetPtr) xmlMalloc(sizeof(xmlSchematronLet));
             let->name = name;
             let->comp = var_comp;
             let->next = NULL;
@@ -1450,7 +1449,7 @@ xmlSchematronReportOutput(xmlSchematronValidCtxtPtr ctxt ATTRIBUTE_UNUSED,
                           xmlNodePtr cur ATTRIBUTE_UNUSED,
                           const char *msg) {
     /* TODO */
-    fprintf(stderr, "%s", msg);
+    xmlPrintErrorMessage("%s", msg);
 }
 
 /**
@@ -1648,17 +1647,17 @@ xmlSchematronReportSuccess(xmlSchematronValidCtxtPtr ctxt,
             data = xmlGenericErrorContext;
         }
 
-        res = __xmlRaiseError(schannel, channel, data, NULL, cur,
-                              XML_FROM_SCHEMATRONV,
-                              (test->type == XML_SCHEMATRON_ASSERT) ?
-                                  XML_SCHEMATRONV_ASSERT :
-                                  XML_SCHEMATRONV_REPORT,
-                              XML_ERR_ERROR, NULL, line,
-                              (pattern == NULL) ?
-                                  NULL :
-                                  (const char *) pattern->name,
-                              (const char *) path, (const char *) report, 0, 0,
-                              "%s", msg);
+        res = xmlRaiseError(schannel, channel, data, NULL, cur,
+                            XML_FROM_SCHEMATRONV,
+                            (test->type == XML_SCHEMATRON_ASSERT) ?
+                                XML_SCHEMATRONV_ASSERT :
+                                XML_SCHEMATRONV_REPORT,
+                            XML_ERR_ERROR, NULL, line,
+                            (pattern == NULL) ?
+                                NULL :
+                                (const char *) pattern->name,
+                            (const char *) path, (const char *) report, 0, 0,
+                            "%s", msg);
         if (res < 0)
             xmlSchematronVErrMemory(ctxt);
     } else {
@@ -2047,47 +2046,4 @@ xmlSchematronValidateDoc(xmlSchematronValidCtxtPtr ctxt, xmlDocPtr instance)
     return(ctxt->nberrors);
 }
 
-#ifdef STANDALONE
-int
-main(void)
-{
-    int ret;
-    xmlDocPtr instance;
-    xmlSchematronParserCtxtPtr pctxt;
-    xmlSchematronValidCtxtPtr vctxt;
-    xmlSchematronPtr schema = NULL;
-
-    pctxt = xmlSchematronNewParserCtxt("tst.sct");
-    if (pctxt == NULL) {
-        fprintf(stderr, "failed to build schematron parser\n");
-    } else {
-        schema = xmlSchematronParse(pctxt);
-        if (schema == NULL) {
-            fprintf(stderr, "failed to compile schematron\n");
-        }
-        xmlSchematronFreeParserCtxt(pctxt);
-    }
-    instance = xmlReadFile("tst.sct", NULL,
-                           XML_PARSE_NOENT | XML_PARSE_NOCDATA);
-    if (instance == NULL) {
-        fprintf(stderr, "failed to parse instance\n");
-    }
-    if ((schema != NULL) && (instance != NULL)) {
-        vctxt = xmlSchematronNewValidCtxt(schema);
-        if (vctxt == NULL) {
-            fprintf(stderr, "failed to build schematron validator\n");
-        } else {
-            ret = xmlSchematronValidateDoc(vctxt, instance);
-            xmlSchematronFreeValidCtxt(vctxt);
-        }
-    }
-    xmlSchematronFree(schema);
-    xmlFreeDoc(instance);
-
-    xmlCleanupParser();
-
-    return (0);
-}
-#endif
-
 #endif /* LIBXML_SCHEMATRON_ENABLED */
diff --git a/shell.c b/shell.c
new file mode 100644
index 00000000..a1572b28
--- /dev/null
+++ b/shell.c
@@ -0,0 +1,1629 @@
+/*
+ * shell.c: The xmllint shell
+ *
+ * See Copyright for the status of this software.
+ *
+ * Daniel Veillard <daniel@veillard.com>
+ */
+
+#include "libxml.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _WIN32
+  #include <io.h>
+#else
+  #include <unistd.h>
+#endif
+
+#ifdef HAVE_LIBREADLINE
+#include <readline/readline.h>
+#ifdef HAVE_LIBHISTORY
+#include <readline/history.h>
+#endif
+#endif
+
+#include <libxml/debugXML.h>
+#include <libxml/HTMLtree.h>
+#include <libxml/parser.h>
+#include <libxml/uri.h>
+#include <libxml/xpath.h>
+#include <libxml/xpathInternals.h>
+#ifdef LIBXML_SCHEMAS_ENABLED
+#include <libxml/relaxng.h>
+#endif
+
+#include "private/shell.h"
+
+#ifndef STDIN_FILENO
+  #define STDIN_FILENO 0
+#endif
+
+/*
+ * TODO: Improvement/cleanups for the XML shell
+ *     - allow to shell out an editor on a subpart
+ *     - cleanup function registrations (with help) and calling
+ *     - provide registration routines
+ */
+
+typedef struct _xmllintShellCtxt xmllintShellCtxt;
+typedef xmllintShellCtxt *xmllintShellCtxtPtr;
+struct _xmllintShellCtxt {
+    char *filename;
+    xmlDocPtr doc;
+    xmlNodePtr node;
+#ifdef LIBXML_XPATH_ENABLED
+    xmlXPathContextPtr pctxt;
+#endif
+    int loaded;
+    FILE *output;
+};
+
+/**
+ * xmllintLsCountNode:
+ * @node:  the node to count
+ *
+ * Count the children of @node.
+ *
+ * Returns the number of children of @node.
+ */
+static int
+xmllintLsCountNode(xmlNodePtr node) {
+    int ret = 0;
+    xmlNodePtr list = NULL;
+
+    if (node == NULL)
+	return(0);
+
+    switch (node->type) {
+	case XML_ELEMENT_NODE:
+	    list = node->children;
+	    break;
+	case XML_DOCUMENT_NODE:
+	case XML_HTML_DOCUMENT_NODE:
+	    list = ((xmlDocPtr) node)->children;
+	    break;
+	case XML_ATTRIBUTE_NODE:
+	    list = ((xmlAttrPtr) node)->children;
+	    break;
+	case XML_TEXT_NODE:
+	case XML_CDATA_SECTION_NODE:
+	case XML_PI_NODE:
+	case XML_COMMENT_NODE:
+	    if (node->content != NULL) {
+		ret = xmlStrlen(node->content);
+            }
+	    break;
+	case XML_ENTITY_REF_NODE:
+	case XML_DOCUMENT_TYPE_NODE:
+	case XML_ENTITY_NODE:
+	case XML_DOCUMENT_FRAG_NODE:
+	case XML_NOTATION_NODE:
+	case XML_DTD_NODE:
+        case XML_ELEMENT_DECL:
+        case XML_ATTRIBUTE_DECL:
+        case XML_ENTITY_DECL:
+	case XML_NAMESPACE_DECL:
+	case XML_XINCLUDE_START:
+	case XML_XINCLUDE_END:
+	    ret = 1;
+	    break;
+    }
+    for (;list != NULL;ret++)
+        list = list->next;
+    return(ret);
+}
+
+/**
+ * xmllintLsOneNode:
+ * @output:  the FILE * for the output
+ * @node:  the node to dump
+ *
+ * Dump to @output the type and name of @node.
+ */
+static void
+xmllintLsOneNode(FILE *output, xmlNodePtr node) {
+    if (output == NULL) return;
+    if (node == NULL) {
+	fprintf(output, "NULL\n");
+	return;
+    }
+    switch (node->type) {
+	case XML_ELEMENT_NODE:
+	    fprintf(output, "-");
+	    break;
+	case XML_ATTRIBUTE_NODE:
+	    fprintf(output, "a");
+	    break;
+	case XML_TEXT_NODE:
+	    fprintf(output, "t");
+	    break;
+	case XML_CDATA_SECTION_NODE:
+	    fprintf(output, "C");
+	    break;
+	case XML_ENTITY_REF_NODE:
+	    fprintf(output, "e");
+	    break;
+	case XML_ENTITY_NODE:
+	    fprintf(output, "E");
+	    break;
+	case XML_PI_NODE:
+	    fprintf(output, "p");
+	    break;
+	case XML_COMMENT_NODE:
+	    fprintf(output, "c");
+	    break;
+	case XML_DOCUMENT_NODE:
+	    fprintf(output, "d");
+	    break;
+	case XML_HTML_DOCUMENT_NODE:
+	    fprintf(output, "h");
+	    break;
+	case XML_DOCUMENT_TYPE_NODE:
+	    fprintf(output, "T");
+	    break;
+	case XML_DOCUMENT_FRAG_NODE:
+	    fprintf(output, "F");
+	    break;
+	case XML_NOTATION_NODE:
+	    fprintf(output, "N");
+	    break;
+	case XML_NAMESPACE_DECL:
+	    fprintf(output, "n");
+	    break;
+	default:
+	    fprintf(output, "?");
+    }
+    if (node->type != XML_NAMESPACE_DECL) {
+	if (node->properties != NULL)
+	    fprintf(output, "a");
+	else
+	    fprintf(output, "-");
+	if (node->nsDef != NULL)
+	    fprintf(output, "n");
+	else
+	    fprintf(output, "-");
+    }
+
+    fprintf(output, " %8d ", xmllintLsCountNode(node));
+
+    switch (node->type) {
+	case XML_ELEMENT_NODE:
+	    if (node->name != NULL) {
+                if ((node->ns != NULL) && (node->ns->prefix != NULL))
+                    fprintf(output, "%s:", node->ns->prefix);
+		fprintf(output, "%s", (const char *) node->name);
+            }
+	    break;
+	case XML_ATTRIBUTE_NODE:
+	    if (node->name != NULL)
+		fprintf(output, "%s", (const char *) node->name);
+	    break;
+	case XML_TEXT_NODE:
+#ifdef LIBXML_DEBUG_ENABLED
+	    if (node->content != NULL) {
+		xmlDebugDumpString(output, node->content);
+            }
+#endif
+	    break;
+	case XML_CDATA_SECTION_NODE:
+	    break;
+	case XML_ENTITY_REF_NODE:
+	    if (node->name != NULL)
+		fprintf(output, "%s", (const char *) node->name);
+	    break;
+	case XML_ENTITY_NODE:
+	    if (node->name != NULL)
+		fprintf(output, "%s", (const char *) node->name);
+	    break;
+	case XML_PI_NODE:
+	    if (node->name != NULL)
+		fprintf(output, "%s", (const char *) node->name);
+	    break;
+	case XML_COMMENT_NODE:
+	    break;
+	case XML_DOCUMENT_NODE:
+	    break;
+	case XML_HTML_DOCUMENT_NODE:
+	    break;
+	case XML_DOCUMENT_TYPE_NODE:
+	    break;
+	case XML_DOCUMENT_FRAG_NODE:
+	    break;
+	case XML_NOTATION_NODE:
+	    break;
+	case XML_NAMESPACE_DECL: {
+	    xmlNsPtr ns = (xmlNsPtr) node;
+
+	    if (ns->prefix == NULL)
+		fprintf(output, "default -> %s", (char *)ns->href);
+	    else
+		fprintf(output, "%s -> %s", (char *)ns->prefix,
+			(char *)ns->href);
+	    break;
+	}
+	default:
+	    if (node->name != NULL)
+		fprintf(output, "%s", (const char *) node->name);
+    }
+    fprintf(output, "\n");
+}
+
+/**
+ * xmllintShellList:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "ls"
+ * Does an Unix like listing of the given node (like a directory)
+ *
+ * Returns 0
+ */
+static int
+xmllintShellList(xmllintShellCtxtPtr ctxt,
+             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
+             xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlNodePtr cur;
+    if (!ctxt)
+        return (0);
+    if (node == NULL) {
+	fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+    if ((node->type == XML_DOCUMENT_NODE) ||
+        (node->type == XML_HTML_DOCUMENT_NODE)) {
+        cur = ((xmlDocPtr) node)->children;
+    } else if (node->type == XML_NAMESPACE_DECL) {
+        xmllintLsOneNode(ctxt->output, node);
+        return (0);
+    } else if (node->children != NULL) {
+        cur = node->children;
+    } else {
+        xmllintLsOneNode(ctxt->output, node);
+        return (0);
+    }
+    while (cur != NULL) {
+        xmllintLsOneNode(ctxt->output, cur);
+        cur = cur->next;
+    }
+    return (0);
+}
+
+/**
+ * xmllintShellBase:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "base"
+ * dumps the current XML base of the node
+ *
+ * Returns 0
+ */
+static int
+xmllintShellBase(xmllintShellCtxtPtr ctxt,
+             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
+             xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlChar *base;
+    if (!ctxt)
+        return 0;
+    if (node == NULL) {
+	fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+
+    base = xmlNodeGetBase(node->doc, node);
+
+    if (base == NULL) {
+        fprintf(ctxt->output, " No base found !!!\n");
+    } else {
+        fprintf(ctxt->output, "%s\n", base);
+        xmlFree(base);
+    }
+    return (0);
+}
+
+/**
+ * xmllintShellSetBase:
+ * @ctxt:  the shell context
+ * @arg:  the new base
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "setbase"
+ * change the current XML base of the node
+ *
+ * Returns 0
+ */
+static int
+xmllintShellSetBase(xmllintShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
+             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
+             xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlNodeSetBase(node, (xmlChar*) arg);
+    return (0);
+}
+
+#ifdef LIBXML_XPATH_ENABLED
+/**
+ * xmllintShellRegisterNamespace:
+ * @ctxt:  the shell context
+ * @arg:  a string in prefix=nsuri format
+ * @node:  unused
+ * @node2:  unused
+ *
+ * Implements the XML shell function "setns"
+ * register/unregister a prefix=namespace pair
+ * on the XPath context
+ *
+ * Returns 0 on success and a negative value otherwise.
+ */
+static int
+xmllintShellRegisterNamespace(xmllintShellCtxtPtr ctxt, char *arg,
+      xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlChar* nsListDup;
+    xmlChar* prefix;
+    xmlChar* href;
+    xmlChar* next;
+
+    nsListDup = xmlStrdup((xmlChar *) arg);
+    next = nsListDup;
+    while(next != NULL) {
+	/* skip spaces */
+	/*while((*next) == ' ') next++;*/
+	if((*next) == '\0') break;
+
+	/* find prefix */
+	prefix = next;
+	next = (xmlChar*)xmlStrchr(next, '=');
+	if(next == NULL) {
+	    fprintf(ctxt->output, "setns: prefix=[nsuri] required\n");
+	    xmlFree(nsListDup);
+	    return(-1);
+	}
+	*(next++) = '\0';
+
+	/* find href */
+	href = next;
+	next = (xmlChar*)xmlStrchr(next, ' ');
+	if(next != NULL) {
+	    *(next++) = '\0';
+	}
+
+	/* do register namespace */
+	if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {
+	    fprintf(ctxt->output,"Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", prefix, href);
+	    xmlFree(nsListDup);
+	    return(-1);
+	}
+    }
+
+    xmlFree(nsListDup);
+    return(0);
+}
+/**
+ * xmllintShellRegisterRootNamespaces:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @node:  the root element
+ * @node2:  unused
+ *
+ * Implements the XML shell function "setrootns"
+ * which registers all namespaces declarations found on the root element.
+ *
+ * Returns 0 on success and a negative value otherwise.
+ */
+static int
+xmllintShellRegisterRootNamespaces(xmllintShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,
+      xmlNodePtr root, xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlNsPtr ns;
+
+    if ((root == NULL) || (root->type != XML_ELEMENT_NODE) ||
+        (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))
+	return(-1);
+    ns = root->nsDef;
+    while (ns != NULL) {
+        if (ns->prefix == NULL)
+	    xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST "defaultns", ns->href);
+	else
+	    xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);
+        ns = ns->next;
+    }
+    return(0);
+}
+#endif
+
+/**
+ * xmllintShellGrep:
+ * @ctxt:  the shell context
+ * @arg:  the string or regular expression to find
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "grep"
+ * dumps information about the node (namespace, attributes, content).
+ *
+ * Returns 0
+ */
+static int
+xmllintShellGrep(xmllintShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
+            char *arg, xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    if (!ctxt)
+        return (0);
+    if (node == NULL)
+	return (0);
+    if (arg == NULL)
+	return (0);
+#ifdef LIBXML_REGEXP_ENABLED
+    if ((xmlStrchr((xmlChar *) arg, '?')) ||
+	(xmlStrchr((xmlChar *) arg, '*')) ||
+	(xmlStrchr((xmlChar *) arg, '.')) ||
+	(xmlStrchr((xmlChar *) arg, '['))) {
+    }
+#endif
+    while (node != NULL) {
+        if (node->type == XML_COMMENT_NODE) {
+	    if (xmlStrstr(node->content, (xmlChar *) arg)) {
+		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node));
+                xmllintShellList(ctxt, NULL, node, NULL);
+	    }
+        } else if (node->type == XML_TEXT_NODE) {
+	    if (xmlStrstr(node->content, (xmlChar *) arg)) {
+		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node->parent));
+                xmllintShellList(ctxt, NULL, node->parent, NULL);
+	    }
+        }
+
+        /*
+         * Browse the full subtree, deep first
+         */
+
+        if ((node->type == XML_DOCUMENT_NODE) ||
+            (node->type == XML_HTML_DOCUMENT_NODE)) {
+            node = ((xmlDocPtr) node)->children;
+        } else if ((node->children != NULL)
+                   && (node->type != XML_ENTITY_REF_NODE)) {
+            /* deep first */
+            node = node->children;
+        } else if (node->next != NULL) {
+            /* then siblings */
+            node = node->next;
+        } else {
+            /* go up to parents->next if needed */
+            while (node != NULL) {
+                if (node->parent != NULL) {
+                    node = node->parent;
+                }
+                if (node->next != NULL) {
+                    node = node->next;
+                    break;
+                }
+                if (node->parent == NULL) {
+                    node = NULL;
+                    break;
+                }
+            }
+	}
+    }
+    return (0);
+}
+
+/**
+ * xmllintShellDir:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "dir"
+ * dumps information about the node (namespace, attributes, content).
+ *
+ * Returns 0
+ */
+static int
+xmllintShellDir(xmllintShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
+            char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,
+            xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    if (!ctxt)
+        return (0);
+    if (node == NULL) {
+	fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+#ifdef LIBXML_DEBUG_ENABLED
+    if ((node->type == XML_DOCUMENT_NODE) ||
+        (node->type == XML_HTML_DOCUMENT_NODE)) {
+        xmlDebugDumpDocumentHead(ctxt->output, (xmlDocPtr) node);
+    } else if (node->type == XML_ATTRIBUTE_NODE) {
+        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr) node, 0);
+    } else {
+        xmlDebugDumpOneNode(ctxt->output, node, 0);
+    }
+#endif
+    return (0);
+}
+
+/**
+ * xmllintShellSetContent:
+ * @ctxt:  the shell context
+ * @value:  the content as a string
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "dir"
+ * dumps information about the node (namespace, attributes, content).
+ *
+ * Returns 0
+ */
+static int
+xmllintShellSetContent(xmllintShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
+            char *value, xmlNodePtr node,
+            xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlNodePtr results;
+    xmlParserErrors ret;
+
+    if (!ctxt)
+        return (0);
+    if (node == NULL) {
+	fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+    if (value == NULL) {
+        fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+
+    ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);
+    if (ret == XML_ERR_OK) {
+	if (node->children != NULL) {
+	    xmlFreeNodeList(node->children);
+	    node->children = NULL;
+	    node->last = NULL;
+	}
+	xmlAddChildList(node, results);
+    } else {
+        fprintf(ctxt->output, "failed to parse content\n");
+    }
+    return (0);
+}
+
+#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+static void
+xmllintShellPrintf(void *ctx, const char *msg, ...) {
+    xmllintShellCtxtPtr sctxt = ctx;
+    va_list ap;
+
+    va_start(ap, msg);
+    vfprintf(sctxt->output, msg, ap);
+    va_end(ap);
+}
+#endif /* defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+/**
+ * xmllintShellRNGValidate:
+ * @ctxt:  the shell context
+ * @schemas:  the path to the Relax-NG schemas
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "relaxng"
+ * validating the instance against a Relax-NG schemas
+ *
+ * Returns 0
+ */
+static int
+xmllintShellRNGValidate(xmllintShellCtxtPtr sctxt, char *schemas,
+            xmlNodePtr node ATTRIBUTE_UNUSED,
+	    xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlRelaxNGPtr relaxngschemas;
+    xmlRelaxNGParserCtxtPtr ctxt;
+    xmlRelaxNGValidCtxtPtr vctxt;
+    int ret;
+
+    ctxt = xmlRelaxNGNewParserCtxt(schemas);
+    xmlRelaxNGSetParserErrors(ctxt, xmllintShellPrintf, xmllintShellPrintf, sctxt);
+    relaxngschemas = xmlRelaxNGParse(ctxt);
+    xmlRelaxNGFreeParserCtxt(ctxt);
+    if (relaxngschemas == NULL) {
+	fprintf(sctxt->output,
+		"Relax-NG schema %s failed to compile\n", schemas);
+	return(-1);
+    }
+    vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);
+    xmlRelaxNGSetValidErrors(vctxt, xmllintShellPrintf, xmllintShellPrintf, sctxt);
+    ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);
+    if (ret == 0) {
+	fprintf(sctxt->output, "%s validates\n", sctxt->filename);
+    } else if (ret > 0) {
+	fprintf(sctxt->output, "%s fails to validate\n", sctxt->filename);
+    } else {
+	fprintf(sctxt->output, "%s validation generated an internal error\n",
+	       sctxt->filename);
+    }
+    xmlRelaxNGFreeValidCtxt(vctxt);
+    if (relaxngschemas != NULL)
+	xmlRelaxNGFree(relaxngschemas);
+    return(0);
+}
+#endif
+
+#ifdef LIBXML_OUTPUT_ENABLED
+/**
+ * xmllintShellCat:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "cat"
+ * dumps the serialization node content (XML or HTML).
+ *
+ * Returns 0
+ */
+static int
+xmllintShellCat(xmllintShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,
+            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    if (!ctxt)
+        return (0);
+    if (node == NULL) {
+	fprintf(ctxt->output, "NULL\n");
+	return (0);
+    }
+    if (ctxt->doc->type == XML_HTML_DOCUMENT_NODE) {
+#ifdef LIBXML_HTML_ENABLED
+        if (node->type == XML_HTML_DOCUMENT_NODE)
+            htmlDocDump(ctxt->output, (htmlDocPtr) node);
+        else
+            htmlNodeDumpFile(ctxt->output, ctxt->doc, node);
+#else
+        if (node->type == XML_DOCUMENT_NODE)
+            xmlDocDump(ctxt->output, (xmlDocPtr) node);
+        else
+            xmlElemDump(ctxt->output, ctxt->doc, node);
+#endif /* LIBXML_HTML_ENABLED */
+    } else {
+        if (node->type == XML_DOCUMENT_NODE)
+            xmlDocDump(ctxt->output, (xmlDocPtr) node);
+        else
+            xmlElemDump(ctxt->output, ctxt->doc, node);
+    }
+    fprintf(ctxt->output, "\n");
+    return (0);
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+/**
+ * xmllintShellLoad:
+ * @ctxt:  the shell context
+ * @filename:  the file name
+ * @node:  unused
+ * @node2:  unused
+ *
+ * Implements the XML shell function "load"
+ * loads a new document specified by the filename
+ *
+ * Returns 0 or -1 if loading failed
+ */
+static int
+xmllintShellLoad(xmllintShellCtxtPtr ctxt, char *filename,
+             xmlNodePtr node ATTRIBUTE_UNUSED,
+             xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlDocPtr doc;
+    int html = 0;
+
+    if ((ctxt == NULL) || (filename == NULL)) return(-1);
+    if (ctxt->doc != NULL)
+        html = (ctxt->doc->type == XML_HTML_DOCUMENT_NODE);
+
+    if (html) {
+#ifdef LIBXML_HTML_ENABLED
+        doc = htmlParseFile(filename, NULL);
+#else
+        fprintf(ctxt->output, "HTML support not compiled in\n");
+        doc = NULL;
+#endif /* LIBXML_HTML_ENABLED */
+    } else {
+        doc = xmlReadFile(filename,NULL,0);
+    }
+    if (doc != NULL) {
+        if (ctxt->loaded == 1) {
+            xmlFreeDoc(ctxt->doc);
+        }
+        ctxt->loaded = 1;
+#ifdef LIBXML_XPATH_ENABLED
+        xmlXPathFreeContext(ctxt->pctxt);
+#endif /* LIBXML_XPATH_ENABLED */
+        xmlFree(ctxt->filename);
+        ctxt->doc = doc;
+        ctxt->node = (xmlNodePtr) doc;
+#ifdef LIBXML_XPATH_ENABLED
+        ctxt->pctxt = xmlXPathNewContext(doc);
+#endif /* LIBXML_XPATH_ENABLED */
+        ctxt->filename = (char *) xmlCanonicPath((xmlChar *) filename);
+    } else
+        return (-1);
+    return (0);
+}
+
+#ifdef LIBXML_OUTPUT_ENABLED
+/**
+ * xmllintShellWrite:
+ * @ctxt:  the shell context
+ * @filename:  the file name
+ * @node:  a node in the tree
+ * @node2:  unused
+ *
+ * Implements the XML shell function "write"
+ * Write the current node to the filename, it saves the serialization
+ * of the subtree under the @node specified
+ *
+ * Returns 0 or -1 in case of error
+ */
+static int
+xmllintShellWrite(xmllintShellCtxtPtr ctxt, char *filename, xmlNodePtr node,
+              xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    if (node == NULL)
+        return (-1);
+    if ((filename == NULL) || (filename[0] == 0)) {
+        return (-1);
+    }
+    switch (node->type) {
+        case XML_DOCUMENT_NODE:
+            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
+                fprintf(ctxt->output,
+                                "Failed to write to %s\n", filename);
+                return (-1);
+            }
+            break;
+        case XML_HTML_DOCUMENT_NODE:
+#ifdef LIBXML_HTML_ENABLED
+            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {
+                fprintf(ctxt->output,
+                                "Failed to write to %s\n", filename);
+                return (-1);
+            }
+#else
+            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
+                fprintf(ctxt->output,
+                                "Failed to write to %s\n", filename);
+                return (-1);
+            }
+#endif /* LIBXML_HTML_ENABLED */
+            break;
+        default:{
+                FILE *f;
+
+                f = fopen((char *) filename, "wb");
+                if (f == NULL) {
+                    fprintf(ctxt->output,
+                                    "Failed to write to %s\n", filename);
+                    return (-1);
+                }
+                xmlElemDump(f, ctxt->doc, node);
+                fclose(f);
+            }
+    }
+    return (0);
+}
+
+/**
+ * xmllintShellSave:
+ * @ctxt:  the shell context
+ * @filename:  the file name (optional)
+ * @node:  unused
+ * @node2:  unused
+ *
+ * Implements the XML shell function "save"
+ * Write the current document to the filename, or it's original name
+ *
+ * Returns 0 or -1 in case of error
+ */
+static int
+xmllintShellSave(xmllintShellCtxtPtr ctxt, char *filename,
+             xmlNodePtr node ATTRIBUTE_UNUSED,
+             xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    if ((ctxt == NULL) || (ctxt->doc == NULL))
+        return (-1);
+    if ((filename == NULL) || (filename[0] == 0))
+        filename = ctxt->filename;
+    if (filename == NULL)
+        return (-1);
+    switch (ctxt->doc->type) {
+        case XML_DOCUMENT_NODE:
+            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
+                fprintf(ctxt->output,
+                                "Failed to save to %s\n", filename);
+            }
+            break;
+        case XML_HTML_DOCUMENT_NODE:
+#ifdef LIBXML_HTML_ENABLED
+            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {
+                fprintf(ctxt->output,
+                                "Failed to save to %s\n", filename);
+            }
+#else
+            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
+                fprintf(ctxt->output,
+                                "Failed to save to %s\n", filename);
+            }
+#endif /* LIBXML_HTML_ENABLED */
+            break;
+        default:
+            fprintf(ctxt->output,
+	    "To save to subparts of a document use the 'write' command\n");
+            return (-1);
+
+    }
+    return (0);
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+#ifdef LIBXML_VALID_ENABLED
+/**
+ * xmllintShellValidate:
+ * @ctxt:  the shell context
+ * @dtd:  the DTD URI (optional)
+ * @node:  unused
+ * @node2:  unused
+ *
+ * Implements the XML shell function "validate"
+ * Validate the document, if a DTD path is provided, then the validation
+ * is done against the given DTD.
+ *
+ * Returns 0 or -1 in case of error
+ */
+static int
+xmllintShellValidate(xmllintShellCtxtPtr ctxt, char *dtd,
+                 xmlNodePtr node ATTRIBUTE_UNUSED,
+                 xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlValidCtxt vctxt;
+    int res = -1;
+
+    if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);
+    memset(&vctxt, 0, sizeof(vctxt));
+    vctxt.error = xmllintShellPrintf;
+    vctxt.warning = xmllintShellPrintf;
+    vctxt.userData = ctxt;
+
+    if ((dtd == NULL) || (dtd[0] == 0)) {
+        res = xmlValidateDocument(&vctxt, ctxt->doc);
+    } else {
+        xmlDtdPtr subset;
+
+        subset = xmlParseDTD(NULL, (xmlChar *) dtd);
+        if (subset != NULL) {
+            res = xmlValidateDtd(&vctxt, ctxt->doc, subset);
+
+            xmlFreeDtd(subset);
+        }
+    }
+    return (res);
+}
+#endif /* LIBXML_VALID_ENABLED */
+
+/**
+ * xmllintShellDu:
+ * @ctxt:  the shell context
+ * @arg:  unused
+ * @tree:  a node defining a subtree
+ * @node2:  unused
+ *
+ * Implements the XML shell function "du"
+ * show the structure of the subtree under node @tree
+ * If @tree is null, the command works on the current node.
+ *
+ * Returns 0 or -1 in case of error
+ */
+static int
+xmllintShellDu(xmllintShellCtxtPtr ctxt,
+           char *arg ATTRIBUTE_UNUSED, xmlNodePtr tree,
+           xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlNodePtr node;
+    int indent = 0, i;
+
+    if (!ctxt)
+	return (-1);
+
+    if (tree == NULL)
+        return (-1);
+    node = tree;
+    while (node != NULL) {
+        if ((node->type == XML_DOCUMENT_NODE) ||
+            (node->type == XML_HTML_DOCUMENT_NODE)) {
+            fprintf(ctxt->output, "/\n");
+        } else if (node->type == XML_ELEMENT_NODE) {
+            for (i = 0; i < indent; i++)
+                fprintf(ctxt->output, "  ");
+            if ((node->ns) && (node->ns->prefix))
+                fprintf(ctxt->output, "%s:", node->ns->prefix);
+            fprintf(ctxt->output, "%s\n", node->name);
+        } else {
+        }
+
+        /*
+         * Browse the full subtree, deep first
+         */
+
+        if ((node->type == XML_DOCUMENT_NODE) ||
+            (node->type == XML_HTML_DOCUMENT_NODE)) {
+            node = ((xmlDocPtr) node)->children;
+        } else if ((node->children != NULL)
+                   && (node->type != XML_ENTITY_REF_NODE)) {
+            /* deep first */
+            node = node->children;
+            indent++;
+        } else if ((node != tree) && (node->next != NULL)) {
+            /* then siblings */
+            node = node->next;
+        } else if (node != tree) {
+            /* go up to parents->next if needed */
+            while (node != tree) {
+                if (node->parent != NULL) {
+                    node = node->parent;
+                    indent--;
+                }
+                if ((node != tree) && (node->next != NULL)) {
+                    node = node->next;
+                    break;
+                }
+                if (node->parent == NULL) {
+                    node = NULL;
+                    break;
+                }
+                if (node == tree) {
+                    node = NULL;
+                    break;
+                }
+            }
+            /* exit condition */
+            if (node == tree)
+                node = NULL;
+        } else
+            node = NULL;
+    }
+    return (0);
+}
+
+/**
+ * xmllintShellPwd:
+ * @ctxt:  the shell context
+ * @buffer:  the output buffer
+ * @node:  a node
+ * @node2:  unused
+ *
+ * Implements the XML shell function "pwd"
+ * Show the full path from the root to the node, if needed building
+ * thumblers when similar elements exists at a given ancestor level.
+ * The output is compatible with XPath commands.
+ *
+ * Returns 0 or -1 in case of error
+ */
+static int
+xmllintShellPwd(xmllintShellCtxtPtr ctxt ATTRIBUTE_UNUSED, char *buffer,
+            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)
+{
+    xmlChar *path;
+
+    if ((node == NULL) || (buffer == NULL))
+        return (-1);
+
+    path = xmlGetNodePath(node);
+    if (path == NULL)
+	return (-1);
+
+    /*
+     * This test prevents buffer overflow, because this routine
+     * is only called by xmllintShell, in which the second argument is
+     * 500 chars long.
+     * It is a dirty hack before a cleaner solution is found.
+     * Documentation should mention that the second argument must
+     * be at least 500 chars long, and could be stripped if too long.
+     */
+    snprintf(buffer, 499, "%s", path);
+    buffer[499] = '0';
+    xmlFree(path);
+
+    return (0);
+}
+
+/**
+ * xmllintShellReadline:
+ * @prompt:  the prompt value
+ *
+ * Read a string
+ *
+ * Returns a pointer to it or NULL on EOF the caller is expected to
+ *     free the returned string.
+ */
+static char *
+xmllintShellReadline(char *prompt) {
+    char buf[501];
+    char *ret;
+    int len;
+
+#ifdef HAVE_LIBREADLINE
+    if (isatty(STDIN_FILENO)) {
+        char *line_read;
+
+        /* Get a line from the user. */
+        line_read = readline (prompt);
+
+#ifdef HAVE_LIBHISTORY
+        /* If the line has any text in it, save it on the history. */
+        if (line_read && *line_read)
+           add_history (line_read);
+#endif
+
+        return (line_read);
+    }
+#endif
+
+    if (prompt != NULL)
+       fprintf(stdout, "%s", prompt);
+    fflush(stdout);
+    if (!fgets(buf, 500, stdin))
+        return(NULL);
+    buf[500] = 0;
+    len = strlen(buf);
+    ret = (char *) malloc(len + 1);
+    if (ret != NULL) {
+       memcpy (ret, buf, len + 1);
+    }
+    return(ret);
+}
+
+/**
+ * xmllintShell:
+ * @doc:  the initial document
+ * @filename:  the output buffer
+ * @input:  the line reading function
+ * @output:  the output FILE*, defaults to stdout if NULL
+ *
+ * Implements the XML shell
+ * This allow to load, validate, view, modify and save a document
+ * using a environment similar to a UNIX commandline.
+ */
+void
+xmllintShell(xmlDocPtr doc, const char *filename, FILE * output)
+{
+    char prompt[500] = "/ > ";
+    char *cmdline = NULL, *cur;
+    char command[100];
+    char arg[400];
+    int i;
+    xmllintShellCtxtPtr ctxt;
+#ifdef LIBXML_XPATH_ENABLED
+    xmlXPathObjectPtr list;
+#endif
+
+    if (doc == NULL)
+        return;
+    if (filename == NULL)
+        return;
+    if (output == NULL)
+        output = stdout;
+    ctxt = (xmllintShellCtxtPtr) xmlMalloc(sizeof(xmllintShellCtxt));
+    if (ctxt == NULL)
+        return;
+    ctxt->loaded = 0;
+    ctxt->doc = doc;
+    ctxt->output = output;
+    ctxt->filename = (char *) xmlStrdup((xmlChar *) filename);
+    ctxt->node = (xmlNodePtr) ctxt->doc;
+
+#ifdef LIBXML_XPATH_ENABLED
+    ctxt->pctxt = xmlXPathNewContext(ctxt->doc);
+    if (ctxt->pctxt == NULL) {
+        xmlFree(ctxt);
+        return;
+    }
+#endif /* LIBXML_XPATH_ENABLED */
+    while (1) {
+        if (ctxt->node == (xmlNodePtr) ctxt->doc)
+            snprintf(prompt, sizeof(prompt), "%s > ", "/");
+        else if ((ctxt->node != NULL) && (ctxt->node->name) &&
+                 (ctxt->node->ns) && (ctxt->node->ns->prefix))
+            snprintf(prompt, sizeof(prompt), "%s:%s > ",
+                     (ctxt->node->ns->prefix), ctxt->node->name);
+        else if ((ctxt->node != NULL) && (ctxt->node->name))
+            snprintf(prompt, sizeof(prompt), "%s > ", ctxt->node->name);
+        else
+            snprintf(prompt, sizeof(prompt), "? > ");
+        prompt[sizeof(prompt) - 1] = 0;
+
+        /*
+         * Get a new command line
+         */
+        cmdline = xmllintShellReadline(prompt);
+        if (cmdline == NULL)
+            break;
+
+        /*
+         * Parse the command itself
+         */
+        cur = cmdline;
+        while ((*cur == ' ') || (*cur == '\t'))
+            cur++;
+        i = 0;
+        while ((*cur != ' ') && (*cur != '\t') &&
+               (*cur != '\n') && (*cur != '\r')) {
+            if (*cur == 0)
+                break;
+            command[i++] = *cur++;
+        }
+        command[i] = 0;
+        if (i == 0)
+            continue;
+
+        /*
+         * Parse the argument
+         */
+        while ((*cur == ' ') || (*cur == '\t'))
+            cur++;
+        i = 0;
+        while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {
+            if (*cur == 0)
+                break;
+            arg[i++] = *cur++;
+        }
+        arg[i] = 0;
+
+        /*
+         * start interpreting the command
+         */
+        if (!strcmp(command, "exit"))
+            break;
+        if (!strcmp(command, "quit"))
+            break;
+        if (!strcmp(command, "bye"))
+            break;
+		if (!strcmp(command, "help")) {
+		  fprintf(ctxt->output, "\tbase         display XML base of the node\n");
+		  fprintf(ctxt->output, "\tsetbase URI  change the XML base of the node\n");
+		  fprintf(ctxt->output, "\tbye          leave shell\n");
+		  fprintf(ctxt->output, "\tcat [node]   display node or current node\n");
+		  fprintf(ctxt->output, "\tcd [path]    change directory to path or to root\n");
+		  fprintf(ctxt->output, "\tdir [path]   dumps information about the node (namespace, attributes, content)\n");
+		  fprintf(ctxt->output, "\tdu [path]    show the structure of the subtree under path or the current node\n");
+		  fprintf(ctxt->output, "\texit         leave shell\n");
+		  fprintf(ctxt->output, "\thelp         display this help\n");
+		  fprintf(ctxt->output, "\tfree         display memory usage\n");
+		  fprintf(ctxt->output, "\tload [name]  load a new document with name\n");
+		  fprintf(ctxt->output, "\tls [path]    list contents of path or the current directory\n");
+		  fprintf(ctxt->output, "\tset xml_fragment replace the current node content with the fragment parsed in context\n");
+#ifdef LIBXML_XPATH_ENABLED
+		  fprintf(ctxt->output, "\txpath expr   evaluate the XPath expression in that context and print the result\n");
+		  fprintf(ctxt->output, "\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n");
+		  fprintf(ctxt->output, "\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n");
+		  fprintf(ctxt->output, "\tsetrootns    register all namespace found on the root element\n");
+		  fprintf(ctxt->output, "\t             the default namespace if any uses 'defaultns' prefix\n");
+#endif /* LIBXML_XPATH_ENABLED */
+		  fprintf(ctxt->output, "\tpwd          display current working directory\n");
+		  fprintf(ctxt->output, "\twhereis      display absolute path of [path] or current working directory\n");
+		  fprintf(ctxt->output, "\tquit         leave shell\n");
+#ifdef LIBXML_OUTPUT_ENABLED
+		  fprintf(ctxt->output, "\tsave [name]  save this document to name or the original name\n");
+		  fprintf(ctxt->output, "\twrite [name] write the current node to the filename\n");
+#endif /* LIBXML_OUTPUT_ENABLED */
+#ifdef LIBXML_VALID_ENABLED
+		  fprintf(ctxt->output, "\tvalidate     check the document for errors\n");
+#endif /* LIBXML_VALID_ENABLED */
+#ifdef LIBXML_SCHEMAS_ENABLED
+		  fprintf(ctxt->output, "\trelaxng rng  validate the document against the Relax-NG schemas\n");
+#endif
+		  fprintf(ctxt->output, "\tgrep string  search for a string in the subtree\n");
+#ifdef LIBXML_VALID_ENABLED
+        } else if (!strcmp(command, "validate")) {
+            xmllintShellValidate(ctxt, arg, NULL, NULL);
+#endif /* LIBXML_VALID_ENABLED */
+        } else if (!strcmp(command, "load")) {
+            xmllintShellLoad(ctxt, arg, NULL, NULL);
+#ifdef LIBXML_SCHEMAS_ENABLED
+        } else if (!strcmp(command, "relaxng")) {
+            xmllintShellRNGValidate(ctxt, arg, NULL, NULL);
+#endif
+#ifdef LIBXML_OUTPUT_ENABLED
+        } else if (!strcmp(command, "save")) {
+            xmllintShellSave(ctxt, arg, NULL, NULL);
+        } else if (!strcmp(command, "write")) {
+	    if (arg[0] == 0)
+		fprintf(ctxt->output,
+                        "Write command requires a filename argument\n");
+	    else
+		xmllintShellWrite(ctxt, arg, ctxt->node, NULL);
+#endif /* LIBXML_OUTPUT_ENABLED */
+        } else if (!strcmp(command, "grep")) {
+            xmllintShellGrep(ctxt, arg, ctxt->node, NULL);
+        } else if (!strcmp(command, "pwd")) {
+            char dir[500];
+
+            if (!xmllintShellPwd(ctxt, dir, ctxt->node, NULL))
+                fprintf(ctxt->output, "%s\n", dir);
+        } else if (!strcmp(command, "du")) {
+            if (arg[0] == 0) {
+                xmllintShellDu(ctxt, NULL, ctxt->node, NULL);
+            } else {
+#ifdef LIBXML_XPATH_ENABLED
+                ctxt->pctxt->node = ctxt->node;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+                if (list != NULL) {
+                    switch (list->type) {
+                        case XPATH_UNDEFINED:
+                            fprintf(ctxt->output,
+                                            "%s: no such node\n", arg);
+                            break;
+                        case XPATH_NODESET:{
+                            int indx;
+
+                            if (list->nodesetval == NULL)
+                                break;
+
+                            for (indx = 0;
+                                 indx < list->nodesetval->nodeNr;
+                                 indx++)
+                                xmllintShellDu(ctxt, NULL,
+                                           list->nodesetval->
+                                           nodeTab[indx], NULL);
+                            break;
+                        }
+                        case XPATH_BOOLEAN:
+                            fprintf(ctxt->output,
+                                            "%s is a Boolean\n", arg);
+                            break;
+                        case XPATH_NUMBER:
+                            fprintf(ctxt->output,
+                                            "%s is a number\n", arg);
+                            break;
+                        case XPATH_STRING:
+                            fprintf(ctxt->output,
+                                            "%s is a string\n", arg);
+                            break;
+                        case XPATH_USERS:
+                            fprintf(ctxt->output,
+                                            "%s is user-defined\n", arg);
+                            break;
+                        case XPATH_XSLT_TREE:
+                            fprintf(ctxt->output,
+                                            "%s is an XSLT value tree\n",
+                                            arg);
+                            break;
+                    }
+                    xmlXPathFreeObject(list);
+                } else {
+                    fprintf(ctxt->output,
+                                    "%s: no such node\n", arg);
+                }
+                ctxt->pctxt->node = NULL;
+#endif /* LIBXML_XPATH_ENABLED */
+            }
+        } else if (!strcmp(command, "base")) {
+            xmllintShellBase(ctxt, NULL, ctxt->node, NULL);
+        } else if (!strcmp(command, "set")) {
+	    xmllintShellSetContent(ctxt, arg, ctxt->node, NULL);
+#ifdef LIBXML_XPATH_ENABLED
+        } else if (!strcmp(command, "setns")) {
+            if (arg[0] == 0) {
+		fprintf(ctxt->output,
+				"setns: prefix=[nsuri] required\n");
+            } else {
+                xmllintShellRegisterNamespace(ctxt, arg, NULL, NULL);
+            }
+        } else if (!strcmp(command, "setrootns")) {
+	    xmlNodePtr root;
+
+	    root = xmlDocGetRootElement(ctxt->doc);
+	    xmllintShellRegisterRootNamespaces(ctxt, NULL, root, NULL);
+#ifdef LIBXML_DEBUG_ENABLED
+        } else if (!strcmp(command, "xpath")) {
+            if (arg[0] == 0) {
+		fprintf(ctxt->output,
+				"xpath: expression required\n");
+	    } else {
+                ctxt->pctxt->node = ctxt->node;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+		xmlXPathDebugDumpObject(ctxt->output, list, 0);
+		xmlXPathFreeObject(list);
+	    }
+#endif /* LIBXML_DEBUG_ENABLED */
+#endif /* LIBXML_XPATH_ENABLED */
+        } else if (!strcmp(command, "setbase")) {
+            xmllintShellSetBase(ctxt, arg, ctxt->node, NULL);
+        } else if ((!strcmp(command, "ls")) || (!strcmp(command, "dir"))) {
+            int dir = (!strcmp(command, "dir"));
+
+            if (arg[0] == 0) {
+                if (dir)
+                    xmllintShellDir(ctxt, NULL, ctxt->node, NULL);
+                else
+                    xmllintShellList(ctxt, NULL, ctxt->node, NULL);
+            } else {
+#ifdef LIBXML_XPATH_ENABLED
+                ctxt->pctxt->node = ctxt->node;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+                if (list != NULL) {
+                    switch (list->type) {
+                        case XPATH_UNDEFINED:
+                            fprintf(ctxt->output,
+                                            "%s: no such node\n", arg);
+                            break;
+                        case XPATH_NODESET:{
+                                int indx;
+
+				if (list->nodesetval == NULL)
+				    break;
+
+                                for (indx = 0;
+                                     indx < list->nodesetval->nodeNr;
+                                     indx++) {
+                                    if (dir)
+                                        xmllintShellDir(ctxt, NULL,
+                                                    list->nodesetval->
+                                                    nodeTab[indx], NULL);
+                                    else
+                                        xmllintShellList(ctxt, NULL,
+                                                     list->nodesetval->
+                                                     nodeTab[indx], NULL);
+                                }
+                                break;
+                            }
+                        case XPATH_BOOLEAN:
+                            fprintf(ctxt->output,
+                                            "%s is a Boolean\n", arg);
+                            break;
+                        case XPATH_NUMBER:
+                            fprintf(ctxt->output,
+                                            "%s is a number\n", arg);
+                            break;
+                        case XPATH_STRING:
+                            fprintf(ctxt->output,
+                                            "%s is a string\n", arg);
+                            break;
+                        case XPATH_USERS:
+                            fprintf(ctxt->output,
+                                            "%s is user-defined\n", arg);
+                            break;
+                        case XPATH_XSLT_TREE:
+                            fprintf(ctxt->output,
+                                            "%s is an XSLT value tree\n",
+                                            arg);
+                            break;
+                    }
+                    xmlXPathFreeObject(list);
+                } else {
+                    fprintf(ctxt->output,
+                                    "%s: no such node\n", arg);
+                }
+                ctxt->pctxt->node = NULL;
+#endif /* LIBXML_XPATH_ENABLED */
+            }
+        } else if (!strcmp(command, "whereis")) {
+            char dir[500];
+
+            if (arg[0] == 0) {
+                if (!xmllintShellPwd(ctxt, dir, ctxt->node, NULL))
+                    fprintf(ctxt->output, "%s\n", dir);
+            } else {
+#ifdef LIBXML_XPATH_ENABLED
+                ctxt->pctxt->node = ctxt->node;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+                if (list != NULL) {
+                    switch (list->type) {
+                        case XPATH_UNDEFINED:
+                            fprintf(ctxt->output,
+                                            "%s: no such node\n", arg);
+                            break;
+                        case XPATH_NODESET:{
+                                int indx;
+
+				if (list->nodesetval == NULL)
+				    break;
+
+                                for (indx = 0;
+                                     indx < list->nodesetval->nodeNr;
+                                     indx++) {
+                                    if (!xmllintShellPwd(ctxt, dir, list->nodesetval->
+                                                     nodeTab[indx], NULL))
+                                        fprintf(ctxt->output, "%s\n", dir);
+                                }
+                                break;
+                            }
+                        case XPATH_BOOLEAN:
+                            fprintf(ctxt->output,
+                                            "%s is a Boolean\n", arg);
+                            break;
+                        case XPATH_NUMBER:
+                            fprintf(ctxt->output,
+                                            "%s is a number\n", arg);
+                            break;
+                        case XPATH_STRING:
+                            fprintf(ctxt->output,
+                                            "%s is a string\n", arg);
+                            break;
+                        case XPATH_USERS:
+                            fprintf(ctxt->output,
+                                            "%s is user-defined\n", arg);
+                            break;
+                        case XPATH_XSLT_TREE:
+                            fprintf(ctxt->output,
+                                            "%s is an XSLT value tree\n",
+                                            arg);
+                            break;
+                    }
+                    xmlXPathFreeObject(list);
+                } else {
+                    fprintf(ctxt->output,
+                                    "%s: no such node\n", arg);
+                }
+                ctxt->pctxt->node = NULL;
+#endif /* LIBXML_XPATH_ENABLED */
+            }
+        } else if (!strcmp(command, "cd")) {
+            if (arg[0] == 0) {
+                ctxt->node = (xmlNodePtr) ctxt->doc;
+            } else {
+#ifdef LIBXML_XPATH_ENABLED
+                int l;
+
+                ctxt->pctxt->node = ctxt->node;
+		l = strlen(arg);
+		if ((l >= 2) && (arg[l - 1] == '/'))
+		    arg[l - 1] = 0;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+                if (list != NULL) {
+                    switch (list->type) {
+                        case XPATH_UNDEFINED:
+                            fprintf(ctxt->output,
+                                            "%s: no such node\n", arg);
+                            break;
+                        case XPATH_NODESET:
+                            if (list->nodesetval != NULL) {
+				if (list->nodesetval->nodeNr == 1) {
+				    ctxt->node = list->nodesetval->nodeTab[0];
+				    if ((ctxt->node != NULL) &&
+				        (ctxt->node->type ==
+					 XML_NAMESPACE_DECL)) {
+					fprintf(ctxt->output,
+						    "cannot cd to namespace\n");
+					ctxt->node = NULL;
+				    }
+				} else
+				    fprintf(ctxt->output,
+						    "%s is a %d Node Set\n",
+						    arg,
+						    list->nodesetval->nodeNr);
+                            } else
+                                fprintf(ctxt->output,
+                                                "%s is an empty Node Set\n",
+                                                arg);
+                            break;
+                        case XPATH_BOOLEAN:
+                            fprintf(ctxt->output,
+                                            "%s is a Boolean\n", arg);
+                            break;
+                        case XPATH_NUMBER:
+                            fprintf(ctxt->output,
+                                            "%s is a number\n", arg);
+                            break;
+                        case XPATH_STRING:
+                            fprintf(ctxt->output,
+                                            "%s is a string\n", arg);
+                            break;
+                        case XPATH_USERS:
+                            fprintf(ctxt->output,
+                                            "%s is user-defined\n", arg);
+                            break;
+                        case XPATH_XSLT_TREE:
+                            fprintf(ctxt->output,
+                                            "%s is an XSLT value tree\n",
+                                            arg);
+                            break;
+                    }
+                    xmlXPathFreeObject(list);
+                } else {
+                    fprintf(ctxt->output,
+                                    "%s: no such node\n", arg);
+                }
+                ctxt->pctxt->node = NULL;
+#endif /* LIBXML_XPATH_ENABLED */
+            }
+#ifdef LIBXML_OUTPUT_ENABLED
+        } else if (!strcmp(command, "cat")) {
+            if (arg[0] == 0) {
+                xmllintShellCat(ctxt, NULL, ctxt->node, NULL);
+            } else {
+#ifdef LIBXML_XPATH_ENABLED
+                ctxt->pctxt->node = ctxt->node;
+                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);
+                if (list != NULL) {
+                    switch (list->type) {
+                        case XPATH_UNDEFINED:
+                            fprintf(ctxt->output,
+                                            "%s: no such node\n", arg);
+                            break;
+                        case XPATH_NODESET:{
+                                int indx;
+
+				if (list->nodesetval == NULL)
+				    break;
+
+                                for (indx = 0;
+                                     indx < list->nodesetval->nodeNr;
+                                     indx++) {
+                                    if (i > 0)
+                                        fprintf(ctxt->output, " -------\n");
+                                    xmllintShellCat(ctxt, NULL,
+                                                list->nodesetval->
+                                                nodeTab[indx], NULL);
+                                }
+                                break;
+                            }
+                        case XPATH_BOOLEAN:
+                            fprintf(ctxt->output,
+                                            "%s is a Boolean\n", arg);
+                            break;
+                        case XPATH_NUMBER:
+                            fprintf(ctxt->output,
+                                            "%s is a number\n", arg);
+                            break;
+                        case XPATH_STRING:
+                            fprintf(ctxt->output,
+                                            "%s is a string\n", arg);
+                            break;
+                        case XPATH_USERS:
+                            fprintf(ctxt->output,
+                                            "%s is user-defined\n", arg);
+                            break;
+                        case XPATH_XSLT_TREE:
+                            fprintf(ctxt->output,
+                                            "%s is an XSLT value tree\n",
+                                            arg);
+                            break;
+                    }
+                    xmlXPathFreeObject(list);
+                } else {
+                    fprintf(ctxt->output,
+                                    "%s: no such node\n", arg);
+                }
+                ctxt->pctxt->node = NULL;
+#endif /* LIBXML_XPATH_ENABLED */
+            }
+#endif /* LIBXML_OUTPUT_ENABLED */
+        } else {
+            fprintf(ctxt->output,
+                            "Unknown command %s\n", command);
+        }
+        free(cmdline);          /* not xmlFree here ! */
+	cmdline = NULL;
+    }
+#ifdef LIBXML_XPATH_ENABLED
+    xmlXPathFreeContext(ctxt->pctxt);
+#endif /* LIBXML_XPATH_ENABLED */
+    if (ctxt->loaded) {
+        xmlFreeDoc(ctxt->doc);
+    }
+    if (ctxt->filename != NULL)
+        xmlFree(ctxt->filename);
+    xmlFree(ctxt);
+    if (cmdline != NULL)
+        free(cmdline);          /* not xmlFree here ! */
+}
diff --git a/test/XInclude/docs/fallback6.xml b/test/XInclude/docs/fallback6.xml
index fd00a03f..cb12ff96 100644
--- a/test/XInclude/docs/fallback6.xml
+++ b/test/XInclude/docs/fallback6.xml
@@ -1,6 +1,8 @@
 <?xml version="1.0"?>
-<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="b.xml">
-    <xi:fallback><xi:include href="c.xml">
-        <xi:fallback/>
-    </xi:include></xi:fallback>
-</xi:include>
+<doc>
+    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="b.xml">
+        <xi:fallback><xi:include href="c.xml">
+            <xi:fallback/>
+        </xi:include></xi:fallback>
+    </xi:include>
+</doc>
diff --git a/test/XInclude/docs/fallback8.xml b/test/XInclude/docs/fallback8.xml
new file mode 100644
index 00000000..102ccfc0
--- /dev/null
+++ b/test/XInclude/docs/fallback8.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0"?>
+<doc>
+    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="404.txt" parse="text">
+        <xi:fallback>text not found</xi:fallback>
+    </xi:include>
+</doc>
+
diff --git a/test/XInclude/docs/issue733.xml b/test/XInclude/docs/issue733.xml
new file mode 100644
index 00000000..2fc5616a
--- /dev/null
+++ b/test/XInclude/docs/issue733.xml
@@ -0,0 +1,5 @@
+<reference xmlns:xi="http://www.w3.org/2001/XInclude">
+    <xi:include href="../ents/issue733-1.xml" xpointer="a"/>
+    <xi:include href="../ents/issue733-2.xml" xpointer="a"/>
+    <xi:include href="../ents/issue733-1.xml" xpointer="b"/>
+</reference>
diff --git a/test/XInclude/ents/issue733-1.xml b/test/XInclude/ents/issue733-1.xml
new file mode 100644
index 00000000..38729d69
--- /dev/null
+++ b/test/XInclude/ents/issue733-1.xml
@@ -0,0 +1,4 @@
+<!DOCTYPE refsect1 SYSTEM "issue733.dtd">
+<refsect1>
+    <para id="a">Content 1</para>
+</refsect1>
diff --git a/test/XInclude/ents/issue733-2.xml b/test/XInclude/ents/issue733-2.xml
new file mode 100644
index 00000000..924451bb
--- /dev/null
+++ b/test/XInclude/ents/issue733-2.xml
@@ -0,0 +1,5 @@
+<!DOCTYPE refsect1 SYSTEM "issue733.dtd">
+<refsect1>
+    <para id="a">Content 2</para>
+</refsect1>
+
diff --git a/test/XInclude/ents/issue733.dtd b/test/XInclude/ents/issue733.dtd
new file mode 100644
index 00000000..21873e1c
--- /dev/null
+++ b/test/XInclude/ents/issue733.dtd
@@ -0,0 +1 @@
+<!ATTLIST para id ID #IMPLIED>
diff --git a/test/adjacent-cdata.xml b/test/adjacent-cdata.xml
new file mode 100644
index 00000000..5859226a
--- /dev/null
+++ b/test/adjacent-cdata.xml
@@ -0,0 +1 @@
+<doc><![CDATA[abc]]><![CDATA[def]]><![CDATA[ghi]]></doc>
diff --git a/test/catalogs/test.sh b/test/catalogs/test.sh
new file mode 100755
index 00000000..697fc52d
--- /dev/null
+++ b/test/catalogs/test.sh
@@ -0,0 +1,70 @@
+#!/bin/sh
+
+set -e
+
+echo "## Catalog regression tests"
+
+if [ -n "$1" ]; then
+    xmlcatalog=$1
+else
+    xmlcatalog=./xmlcatalog
+fi
+
+exitcode=0
+
+for i in test/catalogs/*.script ; do
+    name=$(basename $i .script)
+    xml="./test/catalogs/$name.xml"
+
+    if [ -f $xml ] ; then
+        if [ ! -f result/catalogs/$name ] ; then
+            echo New test file $name
+            $xmlcatalog --shell $xml < $i 2>&1 > result/catalogs/$name
+        else
+            $xmlcatalog --shell $xml < $i 2>&1 > catalog.out
+            log=$(diff result/catalogs/$name catalog.out)
+            if [ -n "$log" ] ; then
+                echo $name result
+                echo "$log"
+                exitcode=1
+            fi
+            rm catalog.out
+        fi
+    fi
+done
+
+for i in test/catalogs/*.script ; do
+    name=$(basename $i .script)
+    sgml="./test/catalogs/$name.sgml"
+
+    if [ -f $sgml ] ; then
+        if [ ! -f result/catalogs/$name ] ; then
+            echo New test file $name
+            $xmlcatalog --shell $sgml < $i > result/catalogs/$name
+        else
+            $xmlcatalog --shell $sgml < $i > catalog.out
+            log=$(diff result/catalogs/$name catalog.out)
+            if [ -n "$log" ] ; then
+                echo $name result
+                echo "$log"
+                exitcode=1
+            fi
+            rm catalog.out
+        fi
+    fi
+done
+
+# Add and del operations on XML Catalogs
+
+$xmlcatalog --create --noout mycatalog
+$xmlcatalog --noout --add public Pubid sysid mycatalog
+$xmlcatalog --noout --add public Pubid2 sysid2 mycatalog
+$xmlcatalog --noout --add public Pubid3 sysid3 mycatalog
+diff result/catalogs/mycatalog.full mycatalog
+$xmlcatalog --noout --del sysid mycatalog
+$xmlcatalog --noout --del sysid3 mycatalog
+$xmlcatalog --noout --del sysid2 mycatalog
+diff result/catalogs/mycatalog.empty mycatalog
+rm -f mycatalog
+
+exit $exitcode
diff --git a/test/errors/unsupported-encoding.xml b/test/errors/unsupported-encoding.xml
new file mode 100644
index 00000000..8aba00e4
--- /dev/null
+++ b/test/errors/unsupported-encoding.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="unsupported-encoding"?>
+<doc/>
diff --git a/test/intsubset2.xml b/test/intsubset2.xml
index 4ae845a0..b76505e4 100644
--- a/test/intsubset2.xml
+++ b/test/intsubset2.xml
@@ -1,4 +1,13 @@
 <?xml version="1.0"?>
+<!--
+Copyright (C) Electronic Dictionary Research and Development Group
+Released under Creative Commons Attribution-ShareAlike Licence (V4.0)
+
+This file only contains the kanjidic2 DTD without the actual database.
+
+http://nihongo.monash.edu/kanjidic2/index.html
+http://www.edrdg.org/edrdg/licence.html
+-->
 <!DOCTYPE kanjidic2 [
 	<!-- Version 1.3
 	This is the DTD of the XML-format kanji file combining information from
diff --git a/test/iso-8859-5.xml b/test/iso-8859-5.xml
new file mode 100644
index 00000000..c9f9fe24
--- /dev/null
+++ b/test/iso-8859-5.xml
@@ -0,0 +1 @@
+<?xml version="1.0" encoding="ISO-8859-5"?><doc></doc>
\ No newline at end of file
diff --git a/test/scripts/test.sh b/test/scripts/test.sh
new file mode 100755
index 00000000..a9ec68a4
--- /dev/null
+++ b/test/scripts/test.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+
+set -e
+
+echo "## Scripts regression tests"
+
+if [ -n "$1" ]; then
+    xmllint=$1
+else
+    xmllint=./xmllint
+fi
+
+exitcode=0
+
+for i in test/scripts/*.script ; do
+    name=$(basename $i .script)
+    xml="./test/scripts/$name.xml"
+
+    if [ -f $xml ] ; then
+        if [ ! -f result/scripts/$name ] ; then
+            echo "New test file $name"
+
+            $xmllint --shell $xml < $i \
+                > result/scripts/$name \
+                2> result/scripts/$name.err
+        else
+            $xmllint --shell $xml < $i > shell.out 2> shell.err || true
+
+            if [ -f result/scripts/$name.err ]; then
+                resulterr="result/scripts/$name.err"
+            else
+                resulterr=/dev/null
+            fi
+
+            log=$(
+                diff -u result/scripts/$name shell.out || true;
+                diff -u $resulterr shell.err || true
+            )
+
+            if [ -n "$log" ] ; then
+                echo $name result
+                echo "$log"
+                exitcode=1
+            fi
+
+            rm shell.out shell.err
+        fi
+    fi
+done
+
+exit $exitcode
diff --git a/testModule.c b/testModule.c
index 6aea44db..00055a4c 100644
--- a/testModule.c
+++ b/testModule.c
@@ -6,6 +6,9 @@
  * joelwreed@comcast.net
  */
 
+#define XML_DEPRECATED
+
+#include "libxml.h"
 #include <stdio.h>
 #include <libxml/xmlversion.h>
 
diff --git a/testThreads.c b/testThreads.c
deleted file mode 100644
index fd1f8853..00000000
--- a/testThreads.c
+++ /dev/null
@@ -1,174 +0,0 @@
-#include "config.h"
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <libxml/parser.h>
-#include <libxml/threads.h>
-
-#if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)
-#include <libxml/catalog.h>
-#ifdef HAVE_PTHREAD_H
-#include <pthread.h>
-#elif defined(_WIN32)
-#include <windows.h>
-#endif
-#include <string.h>
-#include <assert.h>
-
-#define	MAX_ARGC	20
-#define TEST_REPEAT_COUNT 500
-#ifdef HAVE_PTHREAD_H
-static pthread_t tid[MAX_ARGC];
-#elif defined(_WIN32)
-static HANDLE tid[MAX_ARGC];
-#endif
-
-typedef struct {
-    const char *filename;
-    int okay;
-} xmlThreadParams;
-
-static const char *catalog = "test/threads/complex.xml";
-static xmlThreadParams threadParams[] = {
-    { "test/threads/abc.xml", 0 },
-    { "test/threads/acb.xml", 0 },
-    { "test/threads/bac.xml", 0 },
-    { "test/threads/bca.xml", 0 },
-    { "test/threads/cab.xml", 0 },
-    { "test/threads/cba.xml", 0 },
-    { "test/threads/invalid.xml", 0 }
-};
-static const unsigned int num_threads = sizeof(threadParams) /
-                                        sizeof(threadParams[0]);
-
-static void *
-thread_specific_data(void *private_data)
-{
-    xmlDocPtr myDoc;
-    xmlThreadParams *params = (xmlThreadParams *) private_data;
-    const char *filename = params->filename;
-    int okay = 1;
-    int options = 0;
-
-    if (xmlCheckThreadLocalStorage() != 0) {
-        printf("xmlCheckThreadLocalStorage failed\n");
-        params->okay = 0;
-        return(NULL);
-    }
-
-    if (strcmp(filename, "test/threads/invalid.xml") != 0) {
-        options |= XML_PARSE_DTDVALID;
-    }
-    myDoc = xmlReadFile(filename, NULL, options);
-    if (myDoc) {
-        xmlFreeDoc(myDoc);
-    } else {
-        printf("parse failed\n");
-	okay = 0;
-    }
-    params->okay = okay;
-    return(NULL);
-}
-
-#ifdef _WIN32
-static DWORD WINAPI
-win32_thread_specific_data(void *private_data)
-{
-    thread_specific_data(private_data);
-    return(0);
-}
-#endif
-#endif /* LIBXML_THREADS_ENABLED */
-
-int
-main(void)
-{
-    unsigned int repeat;
-    int status = 0;
-
-    (void) repeat;
-
-    xmlInitParser();
-
-    if (xmlCheckThreadLocalStorage() != 0) {
-        printf("xmlCheckThreadLocalStorage failed for main thread\n");
-        return(1);
-    }
-
-#if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)
-    for (repeat = 0;repeat < TEST_REPEAT_COUNT;repeat++) {
-        unsigned int i;
-        int ret;
-
-	xmlLoadCatalog(catalog);
-
-#ifdef HAVE_PTHREAD_H
-        memset(tid, 0xff, sizeof(*tid)*num_threads);
-
-	for (i = 0; i < num_threads; i++) {
-	    ret = pthread_create(&tid[i], NULL, thread_specific_data,
-				 (void *) &threadParams[i]);
-	    if (ret != 0) {
-		perror("pthread_create");
-		exit(1);
-	    }
-	}
-	for (i = 0; i < num_threads; i++) {
-            void *result;
-	    ret = pthread_join(tid[i], &result);
-	    if (ret != 0) {
-		perror("pthread_join");
-		exit(1);
-	    }
-	}
-#elif defined(_WIN32)
-        for (i = 0; i < num_threads; i++)
-        {
-            tid[i] = (HANDLE) -1;
-        }
-
-        for (i = 0; i < num_threads; i++)
-        {
-            DWORD useless;
-            tid[i] = CreateThread(NULL, 0,
-                win32_thread_specific_data, &threadParams[i], 0, &useless);
-            if (tid[i] == NULL)
-            {
-                perror("CreateThread");
-                exit(1);
-            }
-        }
-
-        if (WaitForMultipleObjects (num_threads, tid, TRUE, INFINITE) == WAIT_FAILED)
-            perror ("WaitForMultipleObjects failed");
-
-        for (i = 0; i < num_threads; i++)
-        {
-            DWORD exitCode;
-            ret = GetExitCodeThread (tid[i], &exitCode);
-            if (ret == 0)
-            {
-                perror("GetExitCodeThread");
-                exit(1);
-            }
-            CloseHandle (tid[i]);
-        }
-#endif /* pthreads */
-
-	xmlCatalogCleanup();
-
-	for (i = 0; i < num_threads; i++) {
-	    if (threadParams[i].okay == 0) {
-		printf("Thread %d handling %s failed\n", i,
-                       threadParams[i].filename);
-                status = 1;
-            }
-        }
-    }
-#endif /* LIBXML_THREADS_ENABLED */
-
-    xmlCleanupParser();
-
-    return (status);
-}
-
diff --git a/testapi.c b/testapi.c
index 72a29597..438acfbc 100644
--- a/testapi.c
+++ b/testapi.c
@@ -11,7 +11,7 @@
 /* Disable deprecation warnings */
 #define XML_DEPRECATED
 
-#include "config.h"
+#include "libxml.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -929,17 +929,6 @@ static void des_xmlNodeSetPtr(int no ATTRIBUTE_UNUSED, xmlNodeSetPtr val ATTRIBU
 }
 #endif
 
-#ifdef LIBXML_DEBUG_ENABLED
-#ifdef LIBXML_XPATH_ENABLED
-#define gen_nb_xmlShellCtxtPtr 1
-static xmlShellCtxtPtr gen_xmlShellCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
-    return(NULL);
-}
-static void des_xmlShellCtxtPtr(int no ATTRIBUTE_UNUSED, xmlShellCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
-}
-#endif
-#endif
-
 #ifdef LIBXML_PATTERN_ENABLED
 #define gen_nb_xmlPatternPtr 1
 static xmlPatternPtr gen_xmlPatternPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
@@ -1182,7 +1171,6 @@ static void des_xmlSchemaWhitespaceValueType(int no ATTRIBUTE_UNUSED, xmlSchemaW
 #include <libxml/xmlschemas.h>
 #include <libxml/xmlschemastypes.h>
 #include <libxml/xmlstring.h>
-#include <libxml/xmlunicode.h>
 #include <libxml/xmlwriter.h>
 #include <libxml/xpath.h>
 #include <libxml/xpathInternals.h>
@@ -1220,7 +1208,6 @@ static int test_xmlsave(void);
 static int test_xmlschemas(void);
 static int test_xmlschemastypes(void);
 static int test_xmlstring(void);
-static int test_xmlunicode(void);
 static int test_xmlwriter(void);
 static int test_xpath(void);
 static int test_xpathInternals(void);
@@ -1272,7 +1259,6 @@ testlibxml2(void)
     test_ret += test_xmlschemas();
     test_ret += test_xmlschemastypes();
     test_ret += test_xmlstring();
-    test_ret += test_xmlunicode();
     test_ret += test_xmlwriter();
     test_ret += test_xpath();
     test_ret += test_xpathInternals();
@@ -4191,7 +4177,6 @@ static int
 test_xmlSAX2EndElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 #ifdef LIBXML_SAX1_ENABLED
     int mem_base;
     void * ctx; /* the user data (XML parser context) */
@@ -4221,7 +4206,6 @@ test_xmlSAX2EndElement(void) {
     }
     }
     function_tests++;
-#endif
 #endif
 
     return(test_ret);
@@ -5121,7 +5105,6 @@ static int
 test_xmlSAX2StartElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 #ifdef LIBXML_SAX1_ENABLED
     int mem_base;
     void * ctx; /* the user data (XML parser context) */
@@ -5158,7 +5141,6 @@ test_xmlSAX2StartElement(void) {
     }
     }
     function_tests++;
-#endif
 #endif
 
     return(test_ret);
@@ -5317,7 +5299,7 @@ test_xmlSAXDefaultVersion(void) {
 #ifdef LIBXML_SAX1_ENABLED
     int mem_base;
     int ret_val;
-    int version; /* the version, 1 or 2 */
+    int version; /* the version, must be 2 */
     int n_version;
 
     for (n_version = 0;n_version < gen_nb_int;n_version++) {
@@ -7008,40 +6990,6 @@ test_chvalid(void) {
     return(test_ret);
 }
 
-static int
-test_xmlBoolToText(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_DEBUG_ENABLED)
-    int mem_base;
-    const char * ret_val;
-    int boolval; /* a bool to turn into text */
-    int n_boolval;
-
-    for (n_boolval = 0;n_boolval < gen_nb_int;n_boolval++) {
-        mem_base = xmlMemBlocks();
-        boolval = gen_int(n_boolval, 0);
-
-        ret_val = xmlBoolToText(boolval);
-        desret_const_char_ptr(ret_val);
-        call_tests++;
-        des_int(n_boolval, boolval, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlBoolToText",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_boolval);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
 static int
 test_xmlDebugCheckDocument(void) {
     int test_ret = 0;
@@ -7507,553 +7455,466 @@ test_xmlDebugDumpString(void) {
     return(test_ret);
 }
 
+static int
+test_debugXML(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing debugXML : 11 of 11 functions ...\n");
+    test_ret += test_xmlDebugCheckDocument();
+    test_ret += test_xmlDebugDumpAttr();
+    test_ret += test_xmlDebugDumpAttrList();
+    test_ret += test_xmlDebugDumpDTD();
+    test_ret += test_xmlDebugDumpDocument();
+    test_ret += test_xmlDebugDumpDocumentHead();
+    test_ret += test_xmlDebugDumpEntities();
+    test_ret += test_xmlDebugDumpNode();
+    test_ret += test_xmlDebugDumpNodeList();
+    test_ret += test_xmlDebugDumpOneNode();
+    test_ret += test_xmlDebugDumpString();
+
+    if (test_ret != 0)
+	printf("Module debugXML: %d errors\n", test_ret);
+    return(test_ret);
+}
 
 static int
-test_xmlLsCountNode(void) {
+test_xmlDictCleanup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED)
     int mem_base;
-    int ret_val;
-    xmlNodePtr node; /* the node to count */
-    int n_node;
 
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
         mem_base = xmlMemBlocks();
-        node = gen_xmlNodePtr(n_node, 0);
 
-        ret_val = xmlLsCountNode(node);
-        desret_int(ret_val);
+        xmlDictCleanup();
         call_tests++;
-        des_xmlNodePtr(n_node, node, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlLsCountNode",
+            printf("Leak of %d blocks found in xmlDictCleanup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_node);
             printf("\n");
         }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlLsOneNode(void) {
+test_xmlDictCreate(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED)
     int mem_base;
-    FILE * output; /* the FILE * for the output */
-    int n_output;
-    xmlNodePtr node; /* the node to dump */
-    int n_node;
+    xmlDictPtr ret_val;
 
-    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
         mem_base = xmlMemBlocks();
-        output = gen_debug_FILE_ptr(n_output, 0);
-        node = gen_xmlNodePtr(n_node, 1);
 
-        xmlLsOneNode(output, node);
+        ret_val = xmlDictCreate();
+        desret_xmlDictPtr(ret_val);
         call_tests++;
-        des_debug_FILE_ptr(n_output, output, 0);
-        des_xmlNodePtr(n_node, node, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlLsOneNode",
+            printf("Leak of %d blocks found in xmlDictCreate",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_output);
-            printf(" %d", n_node);
             printf("\n");
         }
-    }
-    }
     function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlShell(void) {
-    int test_ret = 0;
 
-
-    /* missing type support */
     return(test_ret);
 }
 
 
-#define gen_nb_char_ptr 1
-#define gen_char_ptr(no, nr) NULL
-#define des_char_ptr(no, val, nr)
-
 static int
-test_xmlShellBase(void) {
+test_xmlDictCreateSub(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
-    int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * arg; /* unused */
-    int n_arg;
-    xmlNodePtr node; /* a node */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    xmlDictPtr ret_val;
+    xmlDictPtr sub; /* an existing dictionary */
+    int n_sub;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_sub = 0;n_sub < gen_nb_xmlDictPtr;n_sub++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        arg = gen_char_ptr(n_arg, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        sub = gen_xmlDictPtr(n_sub, 0);
 
-        ret_val = xmlShellBase(ctxt, arg, node, node2);
-        desret_int(ret_val);
+        ret_val = xmlDictCreateSub(sub);
+        desret_xmlDictPtr(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_arg, arg, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_sub, sub, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellBase",
+            printf("Leak of %d blocks found in xmlDictCreateSub",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_arg);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_sub);
             printf("\n");
         }
     }
-    }
-    }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellCat(void) {
+test_xmlDictExists(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
-    int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * arg; /* unused */
-    int n_arg;
-    xmlNodePtr node; /* a node */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    const xmlChar * ret_val;
+    xmlDictPtr dict; /* the dictionary */
+    int n_dict;
+    const xmlChar * name; /* the name of the userdata */
+    int n_name;
+    int len; /* the length of the name, if -1 it is recomputed */
+    int n_len;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        arg = gen_char_ptr(n_arg, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        dict = gen_xmlDictPtr(n_dict, 0);
+        name = gen_const_xmlChar_ptr(n_name, 1);
+        len = gen_int(n_len, 2);
+        if ((name != NULL) &&
+            (len > xmlStrlen(BAD_CAST name)))
+            len = 0;
 
-        ret_val = xmlShellCat(ctxt, arg, node, node2);
-        desret_int(ret_val);
+        ret_val = xmlDictExists(dict, name, len);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_arg, arg, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_dict, dict, 0);
+        des_const_xmlChar_ptr(n_name, name, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellCat",
+            printf("Leak of %d blocks found in xmlDictExists",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_arg);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_dict);
+            printf(" %d", n_name);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
     }
     }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellDir(void) {
+test_xmlDictGetUsage(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlDictLookup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
-    int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * arg; /* unused */
-    int n_arg;
-    xmlNodePtr node; /* a node */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    const xmlChar * ret_val;
+    xmlDictPtr dict; /* dictionary */
+    int n_dict;
+    const xmlChar * name; /* string key */
+    int n_name;
+    int len; /* length of the key, if -1 it is recomputed */
+    int n_len;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        arg = gen_char_ptr(n_arg, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        dict = gen_xmlDictPtr(n_dict, 0);
+        name = gen_const_xmlChar_ptr(n_name, 1);
+        len = gen_int(n_len, 2);
+        if ((name != NULL) &&
+            (len > xmlStrlen(BAD_CAST name)))
+            len = 0;
 
-        ret_val = xmlShellDir(ctxt, arg, node, node2);
-        desret_int(ret_val);
+        ret_val = xmlDictLookup(dict, name, len);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_arg, arg, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_dict, dict, 0);
+        des_const_xmlChar_ptr(n_name, name, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellDir",
+            printf("Leak of %d blocks found in xmlDictLookup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_arg);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_dict);
+            printf(" %d", n_name);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
     }
     }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellDu(void) {
+test_xmlDictOwns(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * arg; /* unused */
-    int n_arg;
-    xmlNodePtr tree; /* a node defining a subtree */
-    int n_tree;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    xmlDictPtr dict; /* the dictionary */
+    int n_dict;
+    const xmlChar * str; /* the string */
+    int n_str;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
-    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        arg = gen_char_ptr(n_arg, 1);
-        tree = gen_xmlNodePtr(n_tree, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        dict = gen_xmlDictPtr(n_dict, 0);
+        str = gen_const_xmlChar_ptr(n_str, 1);
 
-        ret_val = xmlShellDu(ctxt, arg, tree, node2);
+        ret_val = xmlDictOwns(dict, str);
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_arg, arg, 1);
-        des_xmlNodePtr(n_tree, tree, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_dict, dict, 0);
+        des_const_xmlChar_ptr(n_str, str, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellDu",
+            printf("Leak of %d blocks found in xmlDictOwns",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_arg);
-            printf(" %d", n_tree);
-            printf(" %d", n_node2);
+            printf(" %d", n_dict);
+            printf(" %d", n_str);
             printf("\n");
         }
     }
     }
-    }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellList(void) {
+test_xmlDictQLookup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
-    int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * arg; /* unused */
-    int n_arg;
-    xmlNodePtr node; /* a node */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    const xmlChar * ret_val;
+    xmlDictPtr dict; /* the dictionary */
+    int n_dict;
+    const xmlChar * prefix; /* the prefix */
+    int n_prefix;
+    const xmlChar * name; /* the name */
+    int n_name;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        arg = gen_char_ptr(n_arg, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        dict = gen_xmlDictPtr(n_dict, 0);
+        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
+        name = gen_const_xmlChar_ptr(n_name, 2);
 
-        ret_val = xmlShellList(ctxt, arg, node, node2);
-        desret_int(ret_val);
+        ret_val = xmlDictQLookup(dict, prefix, name);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_arg, arg, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_dict, dict, 0);
+        des_const_xmlChar_ptr(n_prefix, prefix, 1);
+        des_const_xmlChar_ptr(n_name, name, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellList",
+            printf("Leak of %d blocks found in xmlDictQLookup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_arg);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_dict);
+            printf(" %d", n_prefix);
+            printf(" %d", n_name);
             printf("\n");
         }
     }
     }
     }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellLoad(void) {
+test_xmlDictReference(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * filename; /* the file name */
-    int n_filename;
-    xmlNodePtr node; /* unused */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    xmlDictPtr dict; /* the dictionary */
+    int n_dict;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        filename = gen_char_ptr(n_filename, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        dict = gen_xmlDictPtr(n_dict, 0);
 
-        ret_val = xmlShellLoad(ctxt, filename, node, node2);
+        ret_val = xmlDictReference(dict);
+        xmlDictFree(dict);
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_filename, filename, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_xmlDictPtr(n_dict, dict, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellLoad",
+            printf("Leak of %d blocks found in xmlDictReference",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_filename);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_dict);
             printf("\n");
         }
     }
-    }
-    }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellPrintXPathResult(void) {
+test_xmlDictSetLimit(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlDictSize(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
-    xmlXPathObjectPtr list; /* a valid result generated by an xpath evaluation */
-    int n_list;
+    int ret_val;
+    xmlDictPtr dict; /* the dictionary */
+    int n_dict;
 
-    for (n_list = 0;n_list < gen_nb_xmlXPathObjectPtr;n_list++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
         mem_base = xmlMemBlocks();
-        list = gen_xmlXPathObjectPtr(n_list, 0);
+        dict = gen_xmlDictPtr(n_dict, 0);
 
-        xmlShellPrintXPathResult(list);
+        ret_val = xmlDictSize(dict);
+        desret_int(ret_val);
         call_tests++;
-        des_xmlXPathObjectPtr(n_list, list, 0);
+        des_xmlDictPtr(n_dict, dict, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellPrintXPathResult",
+            printf("Leak of %d blocks found in xmlDictSize",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_list);
+            printf(" %d", n_dict);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellPwd(void) {
+test_xmlInitializeDict(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
     int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * buffer; /* the output buffer */
-    int n_buffer;
-    xmlNodePtr node; /* a node */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        buffer = gen_char_ptr(n_buffer, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
 
-        ret_val = xmlShellPwd(ctxt, buffer, node, node2);
+        ret_val = xmlInitializeDict();
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_buffer, buffer, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellPwd",
+            printf("Leak of %d blocks found in xmlInitializeDict",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_buffer);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
             printf("\n");
         }
-    }
-    }
-    }
-    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
+static int
+test_dict(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing dict : 10 of 13 functions ...\n");
+    test_ret += test_xmlDictCleanup();
+    test_ret += test_xmlDictCreate();
+    test_ret += test_xmlDictCreateSub();
+    test_ret += test_xmlDictExists();
+    test_ret += test_xmlDictGetUsage();
+    test_ret += test_xmlDictLookup();
+    test_ret += test_xmlDictOwns();
+    test_ret += test_xmlDictQLookup();
+    test_ret += test_xmlDictReference();
+    test_ret += test_xmlDictSetLimit();
+    test_ret += test_xmlDictSize();
+    test_ret += test_xmlInitializeDict();
+
+    if (test_ret != 0)
+	printf("Module dict: %d errors\n", test_ret);
+    return(test_ret);
+}
 
 static int
-test_xmlShellSave(void) {
+test_UTF8Toisolat1(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
+#ifdef LIBXML_OUTPUT_ENABLED
     int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * filename; /* the file name (optional) */
-    int n_filename;
-    xmlNodePtr node; /* unused */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    unsigned char * out; /* a pointer to an array of bytes to store the result */
+    int n_out;
+    int * outlen; /* the length of @out */
+    int n_outlen;
+    const unsigned char * in; /* a pointer to an array of UTF-8 chars */
+    int n_in;
+    int * inlen; /* the length of @in */
+    int n_inlen;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
+    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
+    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
+    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        filename = gen_char_ptr(n_filename, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        out = gen_unsigned_char_ptr(n_out, 0);
+        outlen = gen_int_ptr(n_outlen, 1);
+        in = gen_const_unsigned_char_ptr(n_in, 2);
+        inlen = gen_int_ptr(n_inlen, 3);
 
-        ret_val = xmlShellSave(ctxt, filename, node, node2);
+        ret_val = UTF8Toisolat1(out, outlen, in, inlen);
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_filename, filename, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_unsigned_char_ptr(n_out, out, 0);
+        des_int_ptr(n_outlen, outlen, 1);
+        des_const_unsigned_char_ptr(n_in, in, 2);
+        des_int_ptr(n_inlen, inlen, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellSave",
+            printf("Leak of %d blocks found in UTF8Toisolat1",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_filename);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_out);
+            printf(" %d", n_outlen);
+            printf(" %d", n_in);
+            printf(" %d", n_inlen);
             printf("\n");
         }
     }
@@ -8061,6 +7922,7 @@ test_xmlShellSave(void) {
     }
     }
     function_tests++;
+#endif
 #endif
 
     return(test_ret);
@@ -8068,47 +7930,46 @@ test_xmlShellSave(void) {
 
 
 static int
-test_xmlShellValidate(void) {
+test_isolat1ToUTF8(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_VALID_ENABLED)
     int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * dtd; /* the DTD URI (optional) */
-    int n_dtd;
-    xmlNodePtr node; /* unused */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    unsigned char * out; /* a pointer to an array of bytes to store the result */
+    int n_out;
+    int * outlen; /* the length of @out */
+    int n_outlen;
+    const unsigned char * in; /* a pointer to an array of ISO Latin 1 chars */
+    int n_in;
+    int * inlen; /* the length of @in */
+    int n_inlen;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_dtd = 0;n_dtd < gen_nb_char_ptr;n_dtd++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
+    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
+    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
+    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
+    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
         mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        dtd = gen_char_ptr(n_dtd, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+        out = gen_unsigned_char_ptr(n_out, 0);
+        outlen = gen_int_ptr(n_outlen, 1);
+        in = gen_const_unsigned_char_ptr(n_in, 2);
+        inlen = gen_int_ptr(n_inlen, 3);
 
-        ret_val = xmlShellValidate(ctxt, dtd, node, node2);
+        ret_val = isolat1ToUTF8(out, outlen, in, inlen);
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_dtd, dtd, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_unsigned_char_ptr(n_out, out, 0);
+        des_int_ptr(n_outlen, outlen, 1);
+        des_const_unsigned_char_ptr(n_in, in, 2);
+        des_int_ptr(n_inlen, inlen, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellValidate",
+            printf("Leak of %d blocks found in isolat1ToUTF8",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_dtd);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
+            printf(" %d", n_out);
+            printf(" %d", n_outlen);
+            printf(" %d", n_in);
+            printf(" %d", n_inlen);
             printf("\n");
         }
     }
@@ -8116,120 +7977,70 @@ test_xmlShellValidate(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlShellWrite(void) {
+test_xmlAddEncodingAlias(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
     int ret_val;
-    xmlShellCtxtPtr ctxt; /* the shell context */
-    int n_ctxt;
-    char * filename; /* the file name */
-    int n_filename;
-    xmlNodePtr node; /* a node in the tree */
-    int n_node;
-    xmlNodePtr node2; /* unused */
-    int n_node2;
+    const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
+    int n_name;
+    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
+    int n_alias;
 
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
-    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
-        filename = gen_char_ptr(n_filename, 1);
-        node = gen_xmlNodePtr(n_node, 2);
-        node2 = gen_xmlNodePtr(n_node2, 3);
+    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
+    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
+        name = gen_const_char_ptr(n_name, 0);
+        alias = gen_const_char_ptr(n_alias, 1);
 
-        ret_val = xmlShellWrite(ctxt, filename, node, node2);
+        ret_val = xmlAddEncodingAlias(name, alias);
         desret_int(ret_val);
         call_tests++;
-        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
-        des_char_ptr(n_filename, filename, 1);
-        des_xmlNodePtr(n_node, node, 2);
-        des_xmlNodePtr(n_node2, node2, 3);
+        des_const_char_ptr(n_name, name, 0);
+        des_const_char_ptr(n_alias, alias, 1);
         xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlShellWrite",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_filename);
-            printf(" %d", n_node);
-            printf(" %d", n_node2);
-            printf("\n");
-        }
-    }
-    }
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
-static int
-test_debugXML(void) {
-    int test_ret = 0;
 
-    if (quiet == 0) printf("Testing debugXML : 25 of 28 functions ...\n");
-    test_ret += test_xmlBoolToText();
-    test_ret += test_xmlDebugCheckDocument();
-    test_ret += test_xmlDebugDumpAttr();
-    test_ret += test_xmlDebugDumpAttrList();
-    test_ret += test_xmlDebugDumpDTD();
-    test_ret += test_xmlDebugDumpDocument();
-    test_ret += test_xmlDebugDumpDocumentHead();
-    test_ret += test_xmlDebugDumpEntities();
-    test_ret += test_xmlDebugDumpNode();
-    test_ret += test_xmlDebugDumpNodeList();
-    test_ret += test_xmlDebugDumpOneNode();
-    test_ret += test_xmlDebugDumpString();
-    test_ret += test_xmlLsCountNode();
-    test_ret += test_xmlLsOneNode();
-    test_ret += test_xmlShell();
-    test_ret += test_xmlShellBase();
-    test_ret += test_xmlShellCat();
-    test_ret += test_xmlShellDir();
-    test_ret += test_xmlShellDu();
-    test_ret += test_xmlShellList();
-    test_ret += test_xmlShellLoad();
-    test_ret += test_xmlShellPrintXPathResult();
-    test_ret += test_xmlShellPwd();
-    test_ret += test_xmlShellSave();
-    test_ret += test_xmlShellValidate();
-    test_ret += test_xmlShellWrite();
-
-    if (test_ret != 0)
-	printf("Module debugXML: %d errors\n", test_ret);
-    return(test_ret);
-}
+#define gen_nb_xmlCharEncodingHandler_ptr 1
+#define gen_xmlCharEncodingHandler_ptr(no, nr) NULL
+#define des_xmlCharEncodingHandler_ptr(no, val, nr)
 
 static int
-test_xmlDictCleanup(void) {
+test_xmlCharEncCloseFunc(void) {
     int test_ret = 0;
 
     int mem_base;
+    int ret_val;
+    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
+    int n_handler;
 
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
         mem_base = xmlMemBlocks();
+        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
 
-        xmlDictCleanup();
+        ret_val = xmlCharEncCloseFunc(handler);
+        desret_int(ret_val);
         call_tests++;
+        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictCleanup",
+            printf("Leak of %d blocks found in xmlCharEncCloseFunc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
+            printf(" %d", n_handler);
             printf("\n");
         }
+    }
     function_tests++;
 
     return(test_ret);
@@ -8237,24 +8048,45 @@ test_xmlDictCleanup(void) {
 
 
 static int
-test_xmlDictCreate(void) {
+test_xmlCharEncFirstLine(void) {
     int test_ret = 0;
 
     int mem_base;
-    xmlDictPtr ret_val;
+    int ret_val;
+    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
+    int n_handler;
+    xmlBufferPtr out; /* an xmlBuffer for the output. */
+    int n_out;
+    xmlBufferPtr in; /* an xmlBuffer for the input */
+    int n_in;
 
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
+    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
+    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
         mem_base = xmlMemBlocks();
+        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
+        out = gen_xmlBufferPtr(n_out, 1);
+        in = gen_xmlBufferPtr(n_in, 2);
 
-        ret_val = xmlDictCreate();
-        desret_xmlDictPtr(ret_val);
+        ret_val = xmlCharEncFirstLine(handler, out, in);
+        desret_int(ret_val);
         call_tests++;
+        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
+        des_xmlBufferPtr(n_out, out, 1);
+        des_xmlBufferPtr(n_in, in, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictCreate",
+            printf("Leak of %d blocks found in xmlCharEncFirstLine",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
+            printf(" %d", n_handler);
+            printf(" %d", n_out);
+            printf(" %d", n_in);
             printf("\n");
         }
+    }
+    }
+    }
     function_tests++;
 
     return(test_ret);
@@ -8262,31 +8094,45 @@ test_xmlDictCreate(void) {
 
 
 static int
-test_xmlDictCreateSub(void) {
+test_xmlCharEncInFunc(void) {
     int test_ret = 0;
 
     int mem_base;
-    xmlDictPtr ret_val;
-    xmlDictPtr sub; /* an existing dictionary */
-    int n_sub;
+    int ret_val;
+    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
+    int n_handler;
+    xmlBufferPtr out; /* an xmlBuffer for the output. */
+    int n_out;
+    xmlBufferPtr in; /* an xmlBuffer for the input */
+    int n_in;
 
-    for (n_sub = 0;n_sub < gen_nb_xmlDictPtr;n_sub++) {
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
+    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
+    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
         mem_base = xmlMemBlocks();
-        sub = gen_xmlDictPtr(n_sub, 0);
+        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
+        out = gen_xmlBufferPtr(n_out, 1);
+        in = gen_xmlBufferPtr(n_in, 2);
 
-        ret_val = xmlDictCreateSub(sub);
-        desret_xmlDictPtr(ret_val);
+        ret_val = xmlCharEncInFunc(handler, out, in);
+        desret_int(ret_val);
         call_tests++;
-        des_xmlDictPtr(n_sub, sub, 0);
+        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
+        des_xmlBufferPtr(n_out, out, 1);
+        des_xmlBufferPtr(n_in, in, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictCreateSub",
+            printf("Leak of %d blocks found in xmlCharEncInFunc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_sub);
+            printf(" %d", n_handler);
+            printf(" %d", n_out);
+            printf(" %d", n_in);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 
     return(test_ret);
@@ -8294,43 +8140,40 @@ test_xmlDictCreateSub(void) {
 
 
 static int
-test_xmlDictExists(void) {
+test_xmlCharEncOutFunc(void) {
     int test_ret = 0;
 
     int mem_base;
-    const xmlChar * ret_val;
-    xmlDictPtr dict; /* the dictionary */
-    int n_dict;
-    const xmlChar * name; /* the name of the userdata */
-    int n_name;
-    int len; /* the length of the name, if -1 it is recomputed */
-    int n_len;
+    int ret_val;
+    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
+    int n_handler;
+    xmlBufferPtr out; /* an xmlBuffer for the output. */
+    int n_out;
+    xmlBufferPtr in; /* an xmlBuffer for the input */
+    int n_in;
 
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
+    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
+    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
         mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
-        name = gen_const_xmlChar_ptr(n_name, 1);
-        len = gen_int(n_len, 2);
-        if ((name != NULL) &&
-            (len > xmlStrlen(BAD_CAST name)))
-            len = 0;
+        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
+        out = gen_xmlBufferPtr(n_out, 1);
+        in = gen_xmlBufferPtr(n_in, 2);
 
-        ret_val = xmlDictExists(dict, name, len);
-        desret_const_xmlChar_ptr(ret_val);
+        ret_val = xmlCharEncOutFunc(handler, out, in);
+        desret_int(ret_val);
         call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
-        des_const_xmlChar_ptr(n_name, name, 1);
-        des_int(n_len, len, 2);
+        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
+        des_xmlBufferPtr(n_out, out, 1);
+        des_xmlBufferPtr(n_in, in, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictExists",
+            printf("Leak of %d blocks found in xmlCharEncOutFunc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_dict);
-            printf(" %d", n_name);
-            printf(" %d", n_len);
+            printf(" %d", n_handler);
+            printf(" %d", n_out);
+            printf(" %d", n_in);
             printf("\n");
         }
     }
@@ -8343,58 +8186,37 @@ test_xmlDictExists(void) {
 
 
 static int
-test_xmlDictGetUsage(void) {
+test_xmlCleanupCharEncodingHandlers(void) {
     int test_ret = 0;
 
 
-    /* missing type support */
+
+        xmlCleanupCharEncodingHandlers();
+        call_tests++;
+        xmlResetLastError();
+    function_tests++;
+
     return(test_ret);
 }
 
 
 static int
-test_xmlDictLookup(void) {
+test_xmlCleanupEncodingAliases(void) {
     int test_ret = 0;
 
     int mem_base;
-    const xmlChar * ret_val;
-    xmlDictPtr dict; /* dictionary */
-    int n_dict;
-    const xmlChar * name; /* string key */
-    int n_name;
-    int len; /* length of the key, if -1 it is recomputed */
-    int n_len;
 
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
-        name = gen_const_xmlChar_ptr(n_name, 1);
-        len = gen_int(n_len, 2);
-        if ((name != NULL) &&
-            (len > xmlStrlen(BAD_CAST name)))
-            len = 0;
 
-        ret_val = xmlDictLookup(dict, name, len);
-        desret_const_xmlChar_ptr(ret_val);
+        xmlCleanupEncodingAliases();
         call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
-        des_const_xmlChar_ptr(n_name, name, 1);
-        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictLookup",
+            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_dict);
-            printf(" %d", n_name);
-            printf(" %d", n_len);
             printf("\n");
         }
-    }
-    }
-    }
     function_tests++;
 
     return(test_ret);
@@ -8402,38 +8224,41 @@ test_xmlDictLookup(void) {
 
 
 static int
-test_xmlDictOwns(void) {
+test_xmlCreateCharEncodingHandler(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlDelEncodingAlias(void) {
     int test_ret = 0;
 
     int mem_base;
     int ret_val;
-    xmlDictPtr dict; /* the dictionary */
-    int n_dict;
-    const xmlChar * str; /* the string */
-    int n_str;
+    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
+    int n_alias;
 
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
+    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
         mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
-        str = gen_const_xmlChar_ptr(n_str, 1);
+        alias = gen_const_char_ptr(n_alias, 0);
 
-        ret_val = xmlDictOwns(dict, str);
+        ret_val = xmlDelEncodingAlias(alias);
         desret_int(ret_val);
         call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
-        des_const_xmlChar_ptr(n_str, str, 1);
+        des_const_char_ptr(n_alias, alias, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictOwns",
+            printf("Leak of %d blocks found in xmlDelEncodingAlias",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_dict);
-            printf(" %d", n_str);
+            printf(" %d", n_alias);
             printf("\n");
         }
     }
-    }
     function_tests++;
 
     return(test_ret);
@@ -8441,45 +8266,38 @@ test_xmlDictOwns(void) {
 
 
 static int
-test_xmlDictQLookup(void) {
+test_xmlDetectCharEncoding(void) {
     int test_ret = 0;
 
     int mem_base;
-    const xmlChar * ret_val;
-    xmlDictPtr dict; /* the dictionary */
-    int n_dict;
-    const xmlChar * prefix; /* the prefix */
-    int n_prefix;
-    const xmlChar * name; /* the name */
-    int n_name;
+    xmlCharEncoding ret_val;
+    const unsigned char * in; /* a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant). */
+    int n_in;
+    int len; /* pointer to the length of the buffer */
+    int n_len;
 
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
-    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
+    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
-        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
-        name = gen_const_xmlChar_ptr(n_name, 2);
+        in = gen_const_unsigned_char_ptr(n_in, 0);
+        len = gen_int(n_len, 1);
 
-        ret_val = xmlDictQLookup(dict, prefix, name);
-        desret_const_xmlChar_ptr(ret_val);
+        ret_val = xmlDetectCharEncoding(in, len);
+        desret_xmlCharEncoding(ret_val);
         call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
-        des_const_xmlChar_ptr(n_prefix, prefix, 1);
-        des_const_xmlChar_ptr(n_name, name, 2);
+        des_const_unsigned_char_ptr(n_in, in, 0);
+        des_int(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictQLookup",
+            printf("Leak of %d blocks found in xmlDetectCharEncoding",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_dict);
-            printf(" %d", n_prefix);
-            printf(" %d", n_name);
+            printf(" %d", n_in);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
     }
-    }
     function_tests++;
 
     return(test_ret);
@@ -8487,40 +8305,17 @@ test_xmlDictQLookup(void) {
 
 
 static int
-test_xmlDictReference(void) {
+test_xmlFindCharEncodingHandler(void) {
     int test_ret = 0;
 
-    int mem_base;
-    int ret_val;
-    xmlDictPtr dict; /* the dictionary */
-    int n_dict;
-
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
-        mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
-
-        ret_val = xmlDictReference(dict);
-        xmlDictFree(dict);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictReference",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_dict);
-            printf("\n");
-        }
-    }
-    function_tests++;
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlDictSetLimit(void) {
+test_xmlGetCharEncodingHandler(void) {
     int test_ret = 0;
 
 
@@ -8530,28 +8325,28 @@ test_xmlDictSetLimit(void) {
 
 
 static int
-test_xmlDictSize(void) {
+test_xmlGetCharEncodingName(void) {
     int test_ret = 0;
 
     int mem_base;
-    int ret_val;
-    xmlDictPtr dict; /* the dictionary */
-    int n_dict;
+    const char * ret_val;
+    xmlCharEncoding enc; /* the encoding */
+    int n_enc;
 
-    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
         mem_base = xmlMemBlocks();
-        dict = gen_xmlDictPtr(n_dict, 0);
+        enc = gen_xmlCharEncoding(n_enc, 0);
 
-        ret_val = xmlDictSize(dict);
-        desret_int(ret_val);
+        ret_val = xmlGetCharEncodingName(enc);
+        desret_const_char_ptr(ret_val);
         call_tests++;
-        des_xmlDictPtr(n_dict, dict, 0);
+        des_xmlCharEncoding(n_enc, enc, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDictSize",
+            printf("Leak of %d blocks found in xmlGetCharEncodingName",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_dict);
+            printf(" %d", n_enc);
             printf("\n");
         }
     }
@@ -8562,184 +8357,107 @@ test_xmlDictSize(void) {
 
 
 static int
-test_xmlInitializeDict(void) {
+test_xmlGetEncodingAlias(void) {
     int test_ret = 0;
 
     int mem_base;
-    int ret_val;
+    const char * ret_val;
+    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
+    int n_alias;
 
+    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
         mem_base = xmlMemBlocks();
+        alias = gen_const_char_ptr(n_alias, 0);
 
-        ret_val = xmlInitializeDict();
-        desret_int(ret_val);
+        ret_val = xmlGetEncodingAlias(alias);
+        desret_const_char_ptr(ret_val);
         call_tests++;
+        des_const_char_ptr(n_alias, alias, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlInitializeDict",
+            printf("Leak of %d blocks found in xmlGetEncodingAlias",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
+            printf(" %d", n_alias);
             printf("\n");
         }
+    }
     function_tests++;
 
     return(test_ret);
 }
 
+
 static int
-test_dict(void) {
+test_xmlInitCharEncodingHandlers(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing dict : 10 of 13 functions ...\n");
-    test_ret += test_xmlDictCleanup();
-    test_ret += test_xmlDictCreate();
-    test_ret += test_xmlDictCreateSub();
-    test_ret += test_xmlDictExists();
-    test_ret += test_xmlDictGetUsage();
-    test_ret += test_xmlDictLookup();
-    test_ret += test_xmlDictOwns();
-    test_ret += test_xmlDictQLookup();
-    test_ret += test_xmlDictReference();
-    test_ret += test_xmlDictSetLimit();
-    test_ret += test_xmlDictSize();
-    test_ret += test_xmlInitializeDict();
 
-    if (test_ret != 0)
-	printf("Module dict: %d errors\n", test_ret);
+
+        xmlInitCharEncodingHandlers();
+        call_tests++;
+        xmlResetLastError();
+    function_tests++;
+
     return(test_ret);
 }
 
+
 static int
-test_UTF8Toisolat1(void) {
+test_xmlLookupCharEncodingHandler(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_OUTPUT_ENABLED)
-#ifdef LIBXML_OUTPUT_ENABLED
-    int mem_base;
-    int ret_val;
-    unsigned char * out; /* a pointer to an array of bytes to store the result */
-    int n_out;
-    int * outlen; /* the length of @out */
-    int n_outlen;
-    const unsigned char * in; /* a pointer to an array of UTF-8 chars */
-    int n_in;
-    int * inlen; /* the length of @in */
-    int n_inlen;
-
-    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
-    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
-    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
-    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
-        mem_base = xmlMemBlocks();
-        out = gen_unsigned_char_ptr(n_out, 0);
-        outlen = gen_int_ptr(n_outlen, 1);
-        in = gen_const_unsigned_char_ptr(n_in, 2);
-        inlen = gen_int_ptr(n_inlen, 3);
-
-        ret_val = UTF8Toisolat1(out, outlen, in, inlen);
-        desret_int(ret_val);
-        call_tests++;
-        des_unsigned_char_ptr(n_out, out, 0);
-        des_int_ptr(n_outlen, outlen, 1);
-        des_const_unsigned_char_ptr(n_in, in, 2);
-        des_int_ptr(n_inlen, inlen, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in UTF8Toisolat1",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_out);
-            printf(" %d", n_outlen);
-            printf(" %d", n_in);
-            printf(" %d", n_inlen);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_isolat1ToUTF8(void) {
+test_xmlNewCharEncodingHandler(void) {
     int test_ret = 0;
 
-    int mem_base;
-    int ret_val;
-    unsigned char * out; /* a pointer to an array of bytes to store the result */
-    int n_out;
-    int * outlen; /* the length of @out */
-    int n_outlen;
-    const unsigned char * in; /* a pointer to an array of ISO Latin 1 chars */
-    int n_in;
-    int * inlen; /* the length of @in */
-    int n_inlen;
 
-    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
-    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
-    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
-    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
-        mem_base = xmlMemBlocks();
-        out = gen_unsigned_char_ptr(n_out, 0);
-        outlen = gen_int_ptr(n_outlen, 1);
-        in = gen_const_unsigned_char_ptr(n_in, 2);
-        inlen = gen_int_ptr(n_inlen, 3);
+    /* missing type support */
+    return(test_ret);
+}
 
-        ret_val = isolat1ToUTF8(out, outlen, in, inlen);
-        desret_int(ret_val);
-        call_tests++;
-        des_unsigned_char_ptr(n_out, out, 0);
-        des_int_ptr(n_outlen, outlen, 1);
-        des_const_unsigned_char_ptr(n_in, in, 2);
-        des_int_ptr(n_inlen, inlen, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in isolat1ToUTF8",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_out);
-            printf(" %d", n_outlen);
-            printf(" %d", n_in);
-            printf(" %d", n_inlen);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
 
+static int
+test_xmlOpenCharEncodingHandler(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlAddEncodingAlias(void) {
+test_xmlParseCharEncoding(void) {
     int test_ret = 0;
 
-    int ret_val;
+    int mem_base;
+    xmlCharEncoding ret_val;
     const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
     int n_name;
-    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
-    int n_alias;
 
     for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
-    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
+        mem_base = xmlMemBlocks();
         name = gen_const_char_ptr(n_name, 0);
-        alias = gen_const_char_ptr(n_alias, 1);
 
-        ret_val = xmlAddEncodingAlias(name, alias);
-        desret_int(ret_val);
+        ret_val = xmlParseCharEncoding(name);
+        desret_xmlCharEncoding(ret_val);
         call_tests++;
         des_const_char_ptr(n_name, name, 0);
-        des_const_char_ptr(n_alias, alias, 1);
         xmlResetLastError();
-    }
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlParseCharEncoding",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_name);
+            printf("\n");
+        }
     }
     function_tests++;
 
@@ -8747,30 +8465,28 @@ test_xmlAddEncodingAlias(void) {
 }
 
 
-#define gen_nb_xmlCharEncodingHandler_ptr 1
-#define gen_xmlCharEncodingHandler_ptr(no, nr) NULL
-#define des_xmlCharEncodingHandler_ptr(no, val, nr)
+#define gen_nb_xmlCharEncodingHandlerPtr 1
+#define gen_xmlCharEncodingHandlerPtr(no, nr) NULL
+#define des_xmlCharEncodingHandlerPtr(no, val, nr)
 
 static int
-test_xmlCharEncCloseFunc(void) {
+test_xmlRegisterCharEncodingHandler(void) {
     int test_ret = 0;
 
     int mem_base;
-    int ret_val;
-    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
+    xmlCharEncodingHandlerPtr handler; /* the xmlCharEncodingHandlerPtr handler block */
     int n_handler;
 
-    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
         mem_base = xmlMemBlocks();
-        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
+        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0);
 
-        ret_val = xmlCharEncCloseFunc(handler);
-        desret_int(ret_val);
+        xmlRegisterCharEncodingHandler(handler);
         call_tests++;
-        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
+        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharEncCloseFunc",
+            printf("Leak of %d blocks found in xmlRegisterCharEncodingHandler",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
             printf(" %d", n_handler);
@@ -8782,453 +8498,11 @@ test_xmlCharEncCloseFunc(void) {
     return(test_ret);
 }
 
-
 static int
-test_xmlCharEncFirstLine(void) {
+test_encoding(void) {
     int test_ret = 0;
 
-    int mem_base;
-    int ret_val;
-    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
-    int n_handler;
-    xmlBufferPtr out; /* an xmlBuffer for the output. */
-    int n_out;
-    xmlBufferPtr in; /* an xmlBuffer for the input */
-    int n_in;
-
-    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
-    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
-    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
-        mem_base = xmlMemBlocks();
-        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
-        out = gen_xmlBufferPtr(n_out, 1);
-        in = gen_xmlBufferPtr(n_in, 2);
-
-        ret_val = xmlCharEncFirstLine(handler, out, in);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
-        des_xmlBufferPtr(n_out, out, 1);
-        des_xmlBufferPtr(n_in, in, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharEncFirstLine",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_handler);
-            printf(" %d", n_out);
-            printf(" %d", n_in);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCharEncInFunc(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
-    int n_handler;
-    xmlBufferPtr out; /* an xmlBuffer for the output. */
-    int n_out;
-    xmlBufferPtr in; /* an xmlBuffer for the input */
-    int n_in;
-
-    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
-    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
-    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
-        mem_base = xmlMemBlocks();
-        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
-        out = gen_xmlBufferPtr(n_out, 1);
-        in = gen_xmlBufferPtr(n_in, 2);
-
-        ret_val = xmlCharEncInFunc(handler, out, in);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
-        des_xmlBufferPtr(n_out, out, 1);
-        des_xmlBufferPtr(n_in, in, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharEncInFunc",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_handler);
-            printf(" %d", n_out);
-            printf(" %d", n_in);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCharEncOutFunc(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
-    int n_handler;
-    xmlBufferPtr out; /* an xmlBuffer for the output. */
-    int n_out;
-    xmlBufferPtr in; /* an xmlBuffer for the input */
-    int n_in;
-
-    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
-    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
-    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
-        mem_base = xmlMemBlocks();
-        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
-        out = gen_xmlBufferPtr(n_out, 1);
-        in = gen_xmlBufferPtr(n_in, 2);
-
-        ret_val = xmlCharEncOutFunc(handler, out, in);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
-        des_xmlBufferPtr(n_out, out, 1);
-        des_xmlBufferPtr(n_in, in, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharEncOutFunc",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_handler);
-            printf(" %d", n_out);
-            printf(" %d", n_in);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCleanupCharEncodingHandlers(void) {
-    int test_ret = 0;
-
-
-
-        xmlCleanupCharEncodingHandlers();
-        call_tests++;
-        xmlResetLastError();
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCleanupEncodingAliases(void) {
-    int test_ret = 0;
-
-    int mem_base;
-
-        mem_base = xmlMemBlocks();
-
-        xmlCleanupEncodingAliases();
-        call_tests++;
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf("\n");
-        }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlDelEncodingAlias(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
-    int n_alias;
-
-    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
-        mem_base = xmlMemBlocks();
-        alias = gen_const_char_ptr(n_alias, 0);
-
-        ret_val = xmlDelEncodingAlias(alias);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_alias, alias, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDelEncodingAlias",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_alias);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlDetectCharEncoding(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlCharEncoding ret_val;
-    const unsigned char * in; /* a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant). */
-    int n_in;
-    int len; /* pointer to the length of the buffer */
-    int n_len;
-
-    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        in = gen_const_unsigned_char_ptr(n_in, 0);
-        len = gen_int(n_len, 1);
-
-        ret_val = xmlDetectCharEncoding(in, len);
-        desret_xmlCharEncoding(ret_val);
-        call_tests++;
-        des_const_unsigned_char_ptr(n_in, in, 0);
-        des_int(n_len, len, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlDetectCharEncoding",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_in);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlFindCharEncodingHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlGetCharEncodingHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlGetCharEncodingName(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    const char * ret_val;
-    xmlCharEncoding enc; /* the encoding */
-    int n_enc;
-
-    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
-        mem_base = xmlMemBlocks();
-        enc = gen_xmlCharEncoding(n_enc, 0);
-
-        ret_val = xmlGetCharEncodingName(enc);
-        desret_const_char_ptr(ret_val);
-        call_tests++;
-        des_xmlCharEncoding(n_enc, enc, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlGetCharEncodingName",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_enc);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlGetEncodingAlias(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    const char * ret_val;
-    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
-    int n_alias;
-
-    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
-        mem_base = xmlMemBlocks();
-        alias = gen_const_char_ptr(n_alias, 0);
-
-        ret_val = xmlGetEncodingAlias(alias);
-        desret_const_char_ptr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_alias, alias, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlGetEncodingAlias",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_alias);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlInitCharEncodingHandlers(void) {
-    int test_ret = 0;
-
-
-
-        xmlInitCharEncodingHandlers();
-        call_tests++;
-        xmlResetLastError();
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlLookupCharEncodingHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlNewCharEncodingHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlOpenCharEncodingHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlParseCharEncoding(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlCharEncoding ret_val;
-    const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
-    int n_name;
-
-    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
-        mem_base = xmlMemBlocks();
-        name = gen_const_char_ptr(n_name, 0);
-
-        ret_val = xmlParseCharEncoding(name);
-        desret_xmlCharEncoding(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_name, name, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlParseCharEncoding",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_name);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-#define gen_nb_xmlCharEncodingHandlerPtr 1
-#define gen_xmlCharEncodingHandlerPtr(no, nr) NULL
-#define des_xmlCharEncodingHandlerPtr(no, val, nr)
-
-static int
-test_xmlRegisterCharEncodingHandler(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlCharEncodingHandlerPtr handler; /* the xmlCharEncodingHandlerPtr handler block */
-    int n_handler;
-
-    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
-        mem_base = xmlMemBlocks();
-        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0);
-
-        xmlRegisterCharEncodingHandler(handler);
-        call_tests++;
-        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegisterCharEncodingHandler",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_handler);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-static int
-test_encoding(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing encoding : 16 of 21 functions ...\n");
+    if (quiet == 0) printf("Testing encoding : 16 of 22 functions ...\n");
     test_ret += test_UTF8Toisolat1();
     test_ret += test_isolat1ToUTF8();
     test_ret += test_xmlAddEncodingAlias();
@@ -9238,6 +8512,7 @@ test_encoding(void) {
     test_ret += test_xmlCharEncOutFunc();
     test_ret += test_xmlCleanupCharEncodingHandlers();
     test_ret += test_xmlCleanupEncodingAliases();
+    test_ret += test_xmlCreateCharEncodingHandler();
     test_ret += test_xmlDelEncodingAlias();
     test_ret += test_xmlDetectCharEncoding();
     test_ret += test_xmlFindCharEncodingHandler();
@@ -9882,7 +9157,7 @@ static int
 test_entities(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing entities : 12 of 19 functions ...\n");
+    if (quiet == 0) printf("Testing entities : 12 of 16 functions ...\n");
     test_ret += test_xmlAddDocEntity();
     test_ret += test_xmlAddDtdEntity();
     test_ret += test_xmlAddEntity();
@@ -12556,6 +11831,287 @@ test_xmlCreatePushParserCtxt(void) {
 }
 
 
+static int
+test_xmlCtxtGetCatalogs(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    void * ret_val;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetCatalogs(ctxt);
+        desret_void_ptr(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetCatalogs",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtGetDeclaredEncoding(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    const xmlChar * ret_val;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetDeclaredEncoding(ctxt);
+        desret_const_xmlChar_ptr(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetDeclaredEncoding",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtGetOptions(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    int ret_val;
+    xmlParserCtxtPtr ctxt; /* an XML parser context */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetOptions(ctxt);
+        desret_int(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetOptions",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtGetPrivate(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    void * ret_val;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetPrivate(ctxt);
+        desret_void_ptr(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetPrivate",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtGetStandalone(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    int ret_val;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetStandalone(ctxt);
+        desret_int(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetStandalone",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+#define gen_nb_xmlParserCtxt_ptr 1
+#define gen_xmlParserCtxt_ptr(no, nr) NULL
+#define des_xmlParserCtxt_ptr(no, val, nr)
+
+static int
+test_xmlCtxtGetStatus(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    int ret_val;
+    xmlParserCtxt * ctxt; /* an XML parser context */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxt_ptr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxt_ptr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetStatus(ctxt);
+        desret_int(ret_val);
+        call_tests++;
+        des_xmlParserCtxt_ptr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetStatus",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtGetVersion(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    const xmlChar * ret_val;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+
+        ret_val = xmlCtxtGetVersion(ctxt);
+        desret_const_xmlChar_ptr(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtGetVersion",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf("\n");
+        }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtParseContent(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlNodePtr ret_val;
+    xmlParserCtxtPtr ctxt; /* parser context */
+    int n_ctxt;
+    xmlParserInputPtr input; /* parser input */
+    int n_input;
+    xmlNodePtr node; /* target node or document */
+    int n_node;
+    int hasTextDecl; /* whether to parse text declaration */
+    int n_hasTextDecl;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
+    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
+    for (n_hasTextDecl = 0;n_hasTextDecl < gen_nb_int;n_hasTextDecl++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+        input = gen_xmlParserInputPtr(n_input, 1);
+        node = gen_xmlNodePtr(n_node, 2);
+        hasTextDecl = gen_int(n_hasTextDecl, 3);
+
+        ret_val = xmlCtxtParseContent(ctxt, input, node, hasTextDecl);
+        desret_xmlNodePtr(ret_val);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlParserInputPtr(n_input, input, 1);
+        des_xmlNodePtr(n_node, node, 2);
+        des_int(n_hasTextDecl, hasTextDecl, 3);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtParseContent",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf(" %d", n_input);
+            printf(" %d", n_node);
+            printf(" %d", n_hasTextDecl);
+            printf("\n");
+        }
+    }
+    }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
 static int
 test_xmlCtxtParseDocument(void) {
     int test_ret = 0;
@@ -12871,6 +12427,90 @@ test_xmlCtxtResetPush(void) {
 }
 
 
+static int
+test_xmlCtxtSetCatalogs(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+    void * catalogs; /*  */
+    int n_catalogs;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+        catalogs = gen_void_ptr(n_catalogs, 1);
+
+        xmlCtxtSetCatalogs(ctxt, catalogs);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        des_void_ptr(n_catalogs, catalogs, 1);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtSetCatalogs",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf(" %d", n_catalogs);
+            printf("\n");
+        }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtSetCharEncConvImpl(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtSetDict(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+    xmlDictPtr dict; /*  */
+    int n_dict;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+        dict = gen_xmlDictPtr(n_dict, 1);
+
+        xmlCtxtSetDict(ctxt, dict);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlDictPtr(n_dict, dict, 1);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtSetDict",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf(" %d", n_dict);
+            printf("\n");
+        }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
 static int
 test_xmlCtxtSetErrorHandler(void) {
     int test_ret = 0;
@@ -12930,6 +12570,53 @@ test_xmlCtxtSetOptions(void) {
 }
 
 
+static int
+test_xmlCtxtSetPrivate(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlParserCtxtPtr ctxt; /*  */
+    int n_ctxt;
+    void * priv; /*  */
+    int n_priv;
+
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
+    for (n_priv = 0;n_priv < gen_nb_void_ptr;n_priv++) {
+        mem_base = xmlMemBlocks();
+        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
+        priv = gen_void_ptr(n_priv, 1);
+
+        xmlCtxtSetPrivate(ctxt, priv);
+        call_tests++;
+        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
+        des_void_ptr(n_priv, priv, 1);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlCtxtSetPrivate",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_ctxt);
+            printf(" %d", n_priv);
+            printf("\n");
+        }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlCtxtSetResourceLoader(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
 static int
 test_xmlCtxtUseOptions(void) {
     int test_ret = 0;
@@ -13159,6 +12846,45 @@ test_xmlInitParserCtxt(void) {
 }
 
 
+static int
+test_xmlInputSetEncodingHandler(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    int ret_val;
+    xmlParserInputPtr input; /* the input stream */
+    int n_input;
+    xmlCharEncodingHandlerPtr handler; /* the encoding handler */
+    int n_handler;
+
+    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
+    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
+        mem_base = xmlMemBlocks();
+        input = gen_xmlParserInputPtr(n_input, 0);
+        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 1);
+
+        ret_val = xmlInputSetEncodingHandler(input, handler);
+        desret_int(ret_val);
+        call_tests++;
+        des_xmlParserInputPtr(n_input, input, 0);
+        des_xmlCharEncodingHandlerPtr(n_handler, handler, 1);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlInputSetEncodingHandler",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_input);
+            printf(" %d", n_handler);
+            printf("\n");
+        }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
 static int
 test_xmlKeepBlanksDefault(void) {
     int test_ret = 0;
@@ -13317,134 +13043,296 @@ test_xmlNewIOInputStream(void) {
 
 
 static int
-test_xmlNewParserCtxt(void) {
+test_xmlNewInputFromFd(void) {
     int test_ret = 0;
 
     int mem_base;
-    xmlParserCtxtPtr ret_val;
+    xmlParserInputPtr ret_val;
+    const char * url; /* base URL (optional) */
+    int n_url;
+    int fd; /* file descriptor */
+    int n_fd;
+    int flags; /* unused, pass 0 */
+    int n_flags;
 
+    for (n_url = 0;n_url < gen_nb_filepath;n_url++) {
+    for (n_fd = 0;n_fd < gen_nb_int;n_fd++) {
+    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
         mem_base = xmlMemBlocks();
+        url = gen_filepath(n_url, 0);
+        fd = gen_int(n_fd, 1);
+        flags = gen_int(n_flags, 2);
 
-        ret_val = xmlNewParserCtxt();
-        desret_xmlParserCtxtPtr(ret_val);
+        ret_val = xmlNewInputFromFd(url, fd, flags);
+        desret_xmlParserInputPtr(ret_val);
         call_tests++;
+        des_filepath(n_url, url, 0);
+        des_int(n_fd, fd, 1);
+        des_int(n_flags, flags, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlNewParserCtxt",
+            printf("Leak of %d blocks found in xmlNewInputFromFd",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
+            printf(" %d", n_url);
+            printf(" %d", n_fd);
+            printf(" %d", n_flags);
             printf("\n");
         }
+    }
+    }
+    }
     function_tests++;
 
     return(test_ret);
 }
 
 
-#define gen_nb_const_xmlSAXHandler_ptr 1
-#define gen_const_xmlSAXHandler_ptr(no, nr) NULL
-#define des_const_xmlSAXHandler_ptr(no, val, nr)
+static int
+test_xmlNewInputFromIO(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
 
 static int
-test_xmlNewSAXParserCtxt(void) {
+test_xmlNewInputFromMemory(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlNewInputFromString(void) {
     int test_ret = 0;
 
     int mem_base;
-    xmlParserCtxtPtr ret_val;
-    const xmlSAXHandler * sax; /* SAX handler */
-    int n_sax;
-    void * userData; /* user data */
-    int n_userData;
+    xmlParserInputPtr ret_val;
+    const char * url; /* base URL (optional) */
+    int n_url;
+    const char * str; /* zero-terminated string */
+    int n_str;
+    int flags; /* optimization hints */
+    int n_flags;
 
-    for (n_sax = 0;n_sax < gen_nb_const_xmlSAXHandler_ptr;n_sax++) {
-    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
+    for (n_url = 0;n_url < gen_nb_filepath;n_url++) {
+    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
+    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
         mem_base = xmlMemBlocks();
-        sax = gen_const_xmlSAXHandler_ptr(n_sax, 0);
-        userData = gen_userdata(n_userData, 1);
+        url = gen_filepath(n_url, 0);
+        str = gen_const_char_ptr(n_str, 1);
+        flags = gen_int(n_flags, 2);
 
-        ret_val = xmlNewSAXParserCtxt(sax, userData);
-        desret_xmlParserCtxtPtr(ret_val);
+        ret_val = xmlNewInputFromString(url, str, flags);
+        desret_xmlParserInputPtr(ret_val);
         call_tests++;
-        des_const_xmlSAXHandler_ptr(n_sax, sax, 0);
-        des_userdata(n_userData, userData, 1);
+        des_filepath(n_url, url, 0);
+        des_const_char_ptr(n_str, str, 1);
+        des_int(n_flags, flags, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlNewSAXParserCtxt",
+            printf("Leak of %d blocks found in xmlNewInputFromString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_sax);
-            printf(" %d", n_userData);
+            printf(" %d", n_url);
+            printf(" %d", n_str);
+            printf(" %d", n_flags);
             printf("\n");
         }
     }
     }
+    }
     function_tests++;
 
     return(test_ret);
 }
 
 
-#define gen_nb_xmlNodePtr_ptr 1
-#define gen_xmlNodePtr_ptr(no, nr) NULL
-#define des_xmlNodePtr_ptr(no, val, nr)
+#define gen_nb_xmlParserInputPtr_ptr 1
+#define gen_xmlParserInputPtr_ptr(no, nr) NULL
+#define des_xmlParserInputPtr_ptr(no, val, nr)
 
 static int
-test_xmlParseBalancedChunkMemory(void) {
+test_xmlNewInputFromUrl(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_SAX1_ENABLED)
-#ifdef LIBXML_SAX1_ENABLED
     int mem_base;
     int ret_val;
-    xmlDocPtr doc; /* the document the chunk pertains to (must not be NULL) */
-    int n_doc;
-    xmlSAXHandlerPtr sax; /* the SAX handler block (possibly NULL) */
-    int n_sax;
-    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
-    int n_user_data;
-    int depth; /* Used for loop detection, use 0 */
-    int n_depth;
-    const xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
-    int n_string;
-    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
-    int n_lst;
+    const char * filename; /* the filename to use as entity */
+    int n_filename;
+    int flags; /* XML_INPUT flags */
+    int n_flags;
+    xmlParserInputPtr * out; /* pointer to new parser input */
+    int n_out;
 
-    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
-    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
-    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
-    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
-    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
-    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
+    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
+    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
+    for (n_out = 0;n_out < gen_nb_xmlParserInputPtr_ptr;n_out++) {
         mem_base = xmlMemBlocks();
-        doc = gen_xmlDocPtr(n_doc, 0);
-        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
-        user_data = gen_userdata(n_user_data, 2);
-        depth = gen_int(n_depth, 3);
-        string = gen_const_xmlChar_ptr(n_string, 4);
-        lst = gen_xmlNodePtr_ptr(n_lst, 5);
-        
-#ifdef LIBXML_SAX1_ENABLED
-        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
-#endif
-
+        filename = gen_filepath(n_filename, 0);
+        flags = gen_int(n_flags, 1);
+        out = gen_xmlParserInputPtr_ptr(n_out, 2);
 
-        ret_val = xmlParseBalancedChunkMemory(doc, sax, user_data, depth, string, lst);
+        ret_val = xmlNewInputFromUrl(filename, flags, out);
         desret_int(ret_val);
         call_tests++;
-        des_xmlDocPtr(n_doc, doc, 0);
-        des_xmlSAXHandlerPtr(n_sax, sax, 1);
-        des_userdata(n_user_data, user_data, 2);
-        des_int(n_depth, depth, 3);
-        des_const_xmlChar_ptr(n_string, string, 4);
-        des_xmlNodePtr_ptr(n_lst, lst, 5);
+        des_filepath(n_filename, filename, 0);
+        des_int(n_flags, flags, 1);
+        des_xmlParserInputPtr_ptr(n_out, out, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlParseBalancedChunkMemory",
+            printf("Leak of %d blocks found in xmlNewInputFromUrl",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_doc);
-            printf(" %d", n_sax);
-            printf(" %d", n_user_data);
+            printf(" %d", n_filename);
+            printf(" %d", n_flags);
+            printf(" %d", n_out);
+            printf("\n");
+        }
+    }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+static int
+test_xmlNewParserCtxt(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlParserCtxtPtr ret_val;
+
+        mem_base = xmlMemBlocks();
+
+        ret_val = xmlNewParserCtxt();
+        desret_xmlParserCtxtPtr(ret_val);
+        call_tests++;
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlNewParserCtxt",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf("\n");
+        }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+#define gen_nb_const_xmlSAXHandler_ptr 1
+#define gen_const_xmlSAXHandler_ptr(no, nr) NULL
+#define des_const_xmlSAXHandler_ptr(no, val, nr)
+
+static int
+test_xmlNewSAXParserCtxt(void) {
+    int test_ret = 0;
+
+    int mem_base;
+    xmlParserCtxtPtr ret_val;
+    const xmlSAXHandler * sax; /* SAX handler */
+    int n_sax;
+    void * userData; /* user data */
+    int n_userData;
+
+    for (n_sax = 0;n_sax < gen_nb_const_xmlSAXHandler_ptr;n_sax++) {
+    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
+        mem_base = xmlMemBlocks();
+        sax = gen_const_xmlSAXHandler_ptr(n_sax, 0);
+        userData = gen_userdata(n_userData, 1);
+
+        ret_val = xmlNewSAXParserCtxt(sax, userData);
+        desret_xmlParserCtxtPtr(ret_val);
+        call_tests++;
+        des_const_xmlSAXHandler_ptr(n_sax, sax, 0);
+        des_userdata(n_userData, userData, 1);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlNewSAXParserCtxt",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_sax);
+            printf(" %d", n_userData);
+            printf("\n");
+        }
+    }
+    }
+    function_tests++;
+
+    return(test_ret);
+}
+
+
+#define gen_nb_xmlNodePtr_ptr 1
+#define gen_xmlNodePtr_ptr(no, nr) NULL
+#define des_xmlNodePtr_ptr(no, val, nr)
+
+static int
+test_xmlParseBalancedChunkMemory(void) {
+    int test_ret = 0;
+
+#if defined(LIBXML_SAX1_ENABLED)
+#ifdef LIBXML_SAX1_ENABLED
+    int mem_base;
+    int ret_val;
+    xmlDocPtr doc; /* the document the chunk pertains to (must not be NULL) */
+    int n_doc;
+    xmlSAXHandlerPtr sax; /* the SAX handler block (possibly NULL) */
+    int n_sax;
+    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
+    int n_user_data;
+    int depth; /* Used for loop detection, use 0 */
+    int n_depth;
+    const xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
+    int n_string;
+    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
+    int n_lst;
+
+    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
+    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
+    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
+    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
+    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
+    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
+        mem_base = xmlMemBlocks();
+        doc = gen_xmlDocPtr(n_doc, 0);
+        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
+        user_data = gen_userdata(n_user_data, 2);
+        depth = gen_int(n_depth, 3);
+        string = gen_const_xmlChar_ptr(n_string, 4);
+        lst = gen_xmlNodePtr_ptr(n_lst, 5);
+        
+#ifdef LIBXML_SAX1_ENABLED
+        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
+#endif
+
+
+        ret_val = xmlParseBalancedChunkMemory(doc, sax, user_data, depth, string, lst);
+        desret_int(ret_val);
+        call_tests++;
+        des_xmlDocPtr(n_doc, doc, 0);
+        des_xmlSAXHandlerPtr(n_sax, sax, 1);
+        des_userdata(n_user_data, user_data, 2);
+        des_int(n_depth, depth, 3);
+        des_const_xmlChar_ptr(n_string, string, 4);
+        des_xmlNodePtr_ptr(n_lst, lst, 5);
+        xmlResetLastError();
+        if (mem_base != xmlMemBlocks()) {
+            printf("Leak of %d blocks found in xmlParseBalancedChunkMemory",
+	           xmlMemBlocks() - mem_base);
+	    test_ret++;
+            printf(" %d", n_doc);
+            printf(" %d", n_sax);
+            printf(" %d", n_user_data);
             printf(" %d", n_depth);
             printf(" %d", n_string);
             printf(" %d", n_lst);
@@ -13968,29 +13856,29 @@ test_xmlParseInNodeContext(void) {
     int n_datalen;
     int options; /* a combination of xmlParserOption */
     int n_options;
-    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
-    int n_lst;
+    xmlNodePtr * listOut; /* the return value for the set of parsed nodes */
+    int n_listOut;
 
     for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
     for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
     for (n_datalen = 0;n_datalen < gen_nb_int;n_datalen++) {
     for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
-    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
+    for (n_listOut = 0;n_listOut < gen_nb_xmlNodePtr_ptr;n_listOut++) {
         mem_base = xmlMemBlocks();
         node = gen_xmlNodePtr(n_node, 0);
         data = gen_const_char_ptr(n_data, 1);
         datalen = gen_int(n_datalen, 2);
         options = gen_parseroptions(n_options, 3);
-        lst = gen_xmlNodePtr_ptr(n_lst, 4);
+        listOut = gen_xmlNodePtr_ptr(n_listOut, 4);
 
-        ret_val = xmlParseInNodeContext(node, data, datalen, options, lst);
+        ret_val = xmlParseInNodeContext(node, data, datalen, options, listOut);
         desret_xmlParserErrors(ret_val);
         call_tests++;
         des_xmlNodePtr(n_node, node, 0);
         des_const_char_ptr(n_data, data, 1);
         des_int(n_datalen, datalen, 2);
         des_parseroptions(n_options, options, 3);
-        des_xmlNodePtr_ptr(n_lst, lst, 4);
+        des_xmlNodePtr_ptr(n_listOut, listOut, 4);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
             printf("Leak of %d blocks found in xmlParseInNodeContext",
@@ -14000,7 +13888,7 @@ test_xmlParseInNodeContext(void) {
             printf(" %d", n_data);
             printf(" %d", n_datalen);
             printf(" %d", n_options);
-            printf(" %d", n_lst);
+            printf(" %d", n_listOut);
             printf("\n");
         }
     }
@@ -15447,22 +15335,35 @@ static int
 test_parser(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing parser : 71 of 85 functions ...\n");
+    if (quiet == 0) printf("Testing parser : 86 of 102 functions ...\n");
     test_ret += test_xmlByteConsumed();
     test_ret += test_xmlCleanupGlobals();
     test_ret += test_xmlClearNodeInfoSeq();
     test_ret += test_xmlClearParserCtxt();
     test_ret += test_xmlCreateDocParserCtxt();
     test_ret += test_xmlCreatePushParserCtxt();
+    test_ret += test_xmlCtxtGetCatalogs();
+    test_ret += test_xmlCtxtGetDeclaredEncoding();
+    test_ret += test_xmlCtxtGetOptions();
+    test_ret += test_xmlCtxtGetPrivate();
+    test_ret += test_xmlCtxtGetStandalone();
+    test_ret += test_xmlCtxtGetStatus();
+    test_ret += test_xmlCtxtGetVersion();
+    test_ret += test_xmlCtxtParseContent();
     test_ret += test_xmlCtxtParseDocument();
     test_ret += test_xmlCtxtReadDoc();
     test_ret += test_xmlCtxtReadFile();
     test_ret += test_xmlCtxtReadMemory();
     test_ret += test_xmlCtxtReset();
     test_ret += test_xmlCtxtResetPush();
+    test_ret += test_xmlCtxtSetCatalogs();
+    test_ret += test_xmlCtxtSetCharEncConvImpl();
+    test_ret += test_xmlCtxtSetDict();
     test_ret += test_xmlCtxtSetErrorHandler();
     test_ret += test_xmlCtxtSetMaxAmplification();
     test_ret += test_xmlCtxtSetOptions();
+    test_ret += test_xmlCtxtSetPrivate();
+    test_ret += test_xmlCtxtSetResourceLoader();
     test_ret += test_xmlCtxtUseOptions();
     test_ret += test_xmlGetExternalEntityLoader();
     test_ret += test_xmlHasFeature();
@@ -15471,10 +15372,16 @@ test_parser(void) {
     test_ret += test_xmlInitNodeInfoSeq();
     test_ret += test_xmlInitParser();
     test_ret += test_xmlInitParserCtxt();
+    test_ret += test_xmlInputSetEncodingHandler();
     test_ret += test_xmlKeepBlanksDefault();
     test_ret += test_xmlLineNumbersDefault();
     test_ret += test_xmlLoadExternalEntity();
     test_ret += test_xmlNewIOInputStream();
+    test_ret += test_xmlNewInputFromFd();
+    test_ret += test_xmlNewInputFromIO();
+    test_ret += test_xmlNewInputFromMemory();
+    test_ret += test_xmlNewInputFromString();
+    test_ret += test_xmlNewInputFromUrl();
     test_ret += test_xmlNewParserCtxt();
     test_ret += test_xmlNewSAXParserCtxt();
     test_ret += test_xmlParseBalancedChunkMemory();
@@ -16399,16 +16306,6 @@ test_xmlPushInput(void) {
 }
 
 
-static int
-test_xmlSetEntityReferenceFunc(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
 static int
 test_xmlSplitQName(void) {
     int test_ret = 0;
@@ -16811,7 +16708,7 @@ static int
 test_parserInternals(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing parserInternals : 32 of 89 functions ...\n");
+    if (quiet == 0) printf("Testing parserInternals : 32 of 79 functions ...\n");
     test_ret += test_inputPop();
     test_ret += test_inputPush();
     test_ret += test_namePop();
@@ -16836,7 +16733,6 @@ test_parserInternals(void) {
     test_ret += test_xmlParserInputShrink();
     test_ret += test_xmlPopInput();
     test_ret += test_xmlPushInput();
-    test_ret += test_xmlSetEntityReferenceFunc();
     test_ret += test_xmlSplitQName();
     test_ret += test_xmlStringCurrentChar();
     test_ret += test_xmlStringDecodeEntities();
@@ -17768,6 +17664,16 @@ test_xmlRelaxNGSetParserStructuredErrors(void) {
 }
 
 
+static int
+test_xmlRelaxNGSetResourceLoader(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
 static int
 test_xmlRelaxNGSetValidErrors(void) {
     int test_ret = 0;
@@ -18068,7 +17974,7 @@ static int
 test_relaxng(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing relaxng : 14 of 24 functions ...\n");
+    if (quiet == 0) printf("Testing relaxng : 14 of 25 functions ...\n");
     test_ret += test_xmlRelaxNGDump();
     test_ret += test_xmlRelaxNGDumpTree();
     test_ret += test_xmlRelaxNGGetParserErrors();
@@ -18081,6 +17987,7 @@ test_relaxng(void) {
     test_ret += test_xmlRelaxNGParse();
     test_ret += test_xmlRelaxNGSetParserErrors();
     test_ret += test_xmlRelaxNGSetParserStructuredErrors();
+    test_ret += test_xmlRelaxNGSetResourceLoader();
     test_ret += test_xmlRelaxNGSetValidErrors();
     test_ret += test_xmlRelaxNGSetValidStructuredErrors();
     test_ret += test_xmlRelaxNGValidateDoc();
@@ -18354,7 +18261,6 @@ static int
 test_xmlAddPrevSibling(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr next; /* the target node */
@@ -18386,7 +18292,6 @@ test_xmlAddPrevSibling(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -19312,7 +19217,6 @@ static int
 test_xmlChildElementCount(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     unsigned long ret_val;
     xmlNodePtr parent; /* the parent node */
@@ -19336,7 +19240,6 @@ test_xmlChildElementCount(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -19346,7 +19249,6 @@ static int
 test_xmlCopyDoc(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     xmlDocPtr ret_val;
     xmlDocPtr doc; /* the document */
@@ -19377,7 +19279,6 @@ test_xmlCopyDoc(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -19387,7 +19288,6 @@ static int
 test_xmlCopyDtd(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlDtdPtr ret_val;
     xmlDtdPtr dtd; /* the DTD */
@@ -19411,7 +19311,6 @@ test_xmlCopyDtd(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -20379,7 +20278,6 @@ static int
 test_xmlDocSetRootElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlDocPtr doc; /* the document */
@@ -20411,7 +20309,6 @@ test_xmlDocSetRootElement(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -20467,7 +20364,6 @@ static int
 test_xmlFirstElementChild(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr parent; /* the parent node */
@@ -20491,7 +20387,6 @@ test_xmlFirstElementChild(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -20718,7 +20613,6 @@ static int
 test_xmlGetNodePath(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
     int mem_base;
     xmlChar * ret_val;
     const xmlNode * node; /* a node */
@@ -20742,7 +20636,6 @@ test_xmlGetNodePath(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -21013,7 +20906,6 @@ static int
 test_xmlLastElementChild(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr parent; /* the parent node */
@@ -21037,7 +20929,6 @@ test_xmlLastElementChild(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -21135,8 +21026,6 @@ static int
 test_xmlNewChild(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr parent; /* the parent node */
@@ -21181,8 +21070,6 @@ test_xmlNewChild(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -21295,7 +21182,6 @@ static int
 test_xmlNewDocFragment(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlDocPtr doc; /* the target document (optional) */
@@ -21319,7 +21205,6 @@ test_xmlNewDocFragment(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -21527,8 +21412,6 @@ static int
 test_xmlNewDocRawNode(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     xmlNodePtr ret_val;
     xmlDocPtr doc; /* the target document */
@@ -21573,8 +21456,6 @@ test_xmlNewDocRawNode(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -21995,8 +21876,6 @@ static int
 test_xmlNewProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     xmlAttrPtr ret_val;
     xmlNodePtr node; /* the parent node (optional) */
@@ -22034,8 +21913,6 @@ test_xmlNewProp(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -22116,8 +21993,6 @@ static int
 test_xmlNewTextChild(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr parent; /* the parent node */
@@ -22162,8 +22037,6 @@ test_xmlNewTextChild(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -22215,7 +22088,6 @@ static int
 test_xmlNextElementSibling(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr node; /* the current node */
@@ -22239,7 +22111,6 @@ test_xmlNextElementSibling(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -22771,7 +22642,6 @@ static int
 test_xmlNodeListGetRawString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlChar * ret_val;
     const xmlDoc * doc; /* a document (optional) */
@@ -22809,7 +22679,6 @@ test_xmlNodeListGetRawString(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -22865,7 +22734,6 @@ static int
 test_xmlNodeSetBase(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr cur; /* the node being changed */
@@ -22896,7 +22764,6 @@ test_xmlNodeSetBase(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -22945,7 +22812,6 @@ static int
 test_xmlNodeSetContentLen(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr cur; /* the node being modified */
@@ -22986,7 +22852,6 @@ test_xmlNodeSetContentLen(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -22996,7 +22861,6 @@ static int
 test_xmlNodeSetLang(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr cur; /* the node being changed */
@@ -23027,7 +22891,6 @@ test_xmlNodeSetLang(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23037,7 +22900,6 @@ static int
 test_xmlNodeSetName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr cur; /* the node being changed */
     int n_cur;
@@ -23066,7 +22928,6 @@ test_xmlNodeSetName(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23076,7 +22937,6 @@ static int
 test_xmlNodeSetSpacePreserve(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr cur; /* the node being changed */
@@ -23107,7 +22967,6 @@ test_xmlNodeSetSpacePreserve(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23117,7 +22976,6 @@ static int
 test_xmlPreviousElementSibling(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr node; /* the current node */
@@ -23141,7 +22999,6 @@ test_xmlPreviousElementSibling(void) {
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23151,8 +23008,6 @@ static int
 test_xmlReconciliateNs(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     int ret_val;
     xmlDocPtr doc; /* the document */
@@ -23183,8 +23038,6 @@ test_xmlReconciliateNs(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -23237,7 +23090,6 @@ static int
 test_xmlReplaceNode(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
     int mem_base;
     xmlNodePtr ret_val;
     xmlNodePtr old; /* the old node */
@@ -23275,7 +23127,6 @@ test_xmlReplaceNode(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23808,7 +23659,6 @@ static int
 test_xmlSetNsProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
     int mem_base;
     xmlAttrPtr ret_val;
     xmlNodePtr node; /* the node */
@@ -23853,7 +23703,6 @@ test_xmlSetNsProp(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -23863,7 +23712,6 @@ static int
 test_xmlSetProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
     int mem_base;
     xmlAttrPtr ret_val;
     xmlNodePtr node; /* the node */
@@ -23901,7 +23749,6 @@ test_xmlSetProp(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -24253,7 +24100,6 @@ static int
 test_xmlUnsetNsProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr node; /* the node */
@@ -24291,7 +24137,6 @@ test_xmlUnsetNsProp(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -24301,7 +24146,6 @@ static int
 test_xmlUnsetProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
     xmlNodePtr node; /* the node */
@@ -24332,7 +24176,6 @@ test_xmlUnsetProp(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -24342,7 +24185,6 @@ static int
 test_xmlValidateNCName(void) {
     int test_ret = 0;
 
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     int ret_val;
     const xmlChar * value; /* the value to check */
@@ -24373,7 +24215,6 @@ test_xmlValidateNCName(void) {
     }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
@@ -24383,8 +24224,6 @@ static int
 test_xmlValidateNMToken(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     int ret_val;
     const xmlChar * value; /* the value to check */
@@ -24415,8 +24254,6 @@ test_xmlValidateNMToken(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -24426,8 +24263,6 @@ static int
 test_xmlValidateName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     int ret_val;
     const xmlChar * value; /* the value to check */
@@ -24458,8 +24293,6 @@ test_xmlValidateName(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -24469,8 +24302,6 @@ static int
 test_xmlValidateQName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-#ifdef LIBXML_TREE_ENABLED
     int mem_base;
     int ret_val;
     const xmlChar * value; /* the value to check */
@@ -24501,8 +24332,6 @@ test_xmlValidateQName(void) {
     }
     }
     function_tests++;
-#endif
-#endif
 
     return(test_ret);
 }
@@ -24511,7 +24340,7 @@ static int
 test_tree(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing tree : 146 of 173 functions ...\n");
+    if (quiet == 0) printf("Testing tree : 146 of 172 functions ...\n");
     test_ret += test_xmlAddChild();
     test_ret += test_xmlAddChildList();
     test_ret += test_xmlAddNextSibling();
@@ -24888,6 +24717,10 @@ test_xmlCreateURI(void) {
 }
 
 
+#define gen_nb_char_ptr 1
+#define gen_char_ptr(no, nr) NULL
+#define des_char_ptr(no, val, nr)
+
 static int
 test_xmlNormalizeURIPath(void) {
     int test_ret = 0;
@@ -27298,7 +27131,7 @@ static int
 test_xmlValidateNotationUse(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#if defined(LIBXML_VALID_ENABLED)
     int mem_base;
     int ret_val;
     xmlValidCtxtPtr ctxt; /* the validation context */
@@ -28183,11 +28016,21 @@ test_xmlXIncludeSetFlags(void) {
     return(test_ret);
 }
 
+
+static int
+test_xmlXIncludeSetResourceLoader(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
 static int
 test_xinclude(void) {
     int test_ret = 0;
 
-    if (quiet == 0) printf("Testing xinclude : 9 of 12 functions ...\n");
+    if (quiet == 0) printf("Testing xinclude : 9 of 13 functions ...\n");
     test_ret += test_xmlXIncludeGetLastError();
     test_ret += test_xmlXIncludeNewContext();
     test_ret += test_xmlXIncludeProcess();
@@ -28199,6 +28042,7 @@ test_xinclude(void) {
     test_ret += test_xmlXIncludeProcessTreeFlagsData();
     test_ret += test_xmlXIncludeSetErrorHandler();
     test_ret += test_xmlXIncludeSetFlags();
+    test_ret += test_xmlXIncludeSetResourceLoader();
 
     if (test_ret != 0)
 	printf("Module xinclude: %d errors\n", test_ret);
@@ -29714,7 +29558,7 @@ static int
 test_xmlAutomataIsDeterminist(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
     xmlAutomataPtr am; /* an automata */
@@ -29788,7 +29632,7 @@ static int
 test_xmlAutomataNewCounter(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
     xmlAutomataPtr am; /* an automata */
@@ -29923,7 +29767,7 @@ static int
 test_xmlAutomataSetFinalState(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
     xmlAutomataPtr am; /* an automata */
@@ -30976,7010 +30820,195 @@ test_xmlTextReaderAttributeCount(void) {
     int test_ret = 0;
 
 #if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderAttributeCount(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderBaseUri(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderBaseUri(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderByteConsumed(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    long ret_val;
-    xmlTextReaderPtr reader; /* an XML reader */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderByteConsumed(reader);
-        desret_long(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderByteConsumed",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderClose(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderClose(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderClose",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstBaseUri(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstBaseUri(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstEncoding(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstEncoding(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstLocalName(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstLocalName(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstName(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstName(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstName",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstNamespaceUri(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstNamespaceUri(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstPrefix(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstPrefix(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstString(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * str; /* the string to intern. */
-    int n_str;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        str = gen_const_xmlChar_ptr(n_str, 1);
-
-        ret_val = xmlTextReaderConstString(reader, str);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_str, str, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstString",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_str);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstValue(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstValue(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstValue",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstXmlLang(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstXmlLang(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderConstXmlVersion(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderConstXmlVersion(reader);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderCurrentDoc(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlDocPtr ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderCurrentDoc(reader);
-        desret_xmlDocPtr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderCurrentNode(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlNodePtr ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderCurrentNode(reader);
-        desret_xmlNodePtr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderDepth(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderDepth(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderDepth",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderExpand(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlNodePtr ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderExpand(reader);
-        desret_xmlNodePtr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderExpand",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetAttribute(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * name; /* the qualified name of the attribute. */
-    int n_name;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        name = gen_const_xmlChar_ptr(n_name, 1);
-
-        ret_val = xmlTextReaderGetAttribute(reader, name);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_name, name, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_name);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetAttributeNo(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    int no; /* the zero-based index of the attribute relative to the containing element */
-    int n_no;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_no = 0;n_no < gen_nb_int;n_no++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        no = gen_int(n_no, 1);
-
-        ret_val = xmlTextReaderGetAttributeNo(reader, no);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_int(n_no, no, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_no);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetAttributeNs(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * localName; /* the local name of the attribute. */
-    int n_localName;
-    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
-    int n_namespaceURI;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
-    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        localName = gen_const_xmlChar_ptr(n_localName, 1);
-        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
-
-        ret_val = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_localName, localName, 1);
-        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_localName);
-            printf(" %d", n_namespaceURI);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-#ifdef LIBXML_READER_ENABLED
-
-#define gen_nb_xmlTextReaderErrorFunc_ptr 1
-#define gen_xmlTextReaderErrorFunc_ptr(no, nr) NULL
-#define des_xmlTextReaderErrorFunc_ptr(no, val, nr)
-#endif
-
-
-static int
-test_xmlTextReaderGetErrorHandler(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    xmlTextReaderErrorFunc * f; /* the callback function or NULL is no callback has been registered */
-    int n_f;
-    void ** arg; /* a user argument */
-    int n_arg;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_f = 0;n_f < gen_nb_xmlTextReaderErrorFunc_ptr;n_f++) {
-    for (n_arg = 0;n_arg < gen_nb_void_ptr_ptr;n_arg++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1);
-        arg = gen_void_ptr_ptr(n_arg, 2);
-
-        xmlTextReaderGetErrorHandler(reader, f, arg);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_xmlTextReaderErrorFunc_ptr(n_f, f, 1);
-        des_void_ptr_ptr(n_arg, arg, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetErrorHandler",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_f);
-            printf(" %d", n_arg);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetLastError(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetParserColumnNumber(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the user data (XML reader context) */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderGetParserColumnNumber(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetParserColumnNumber",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetParserLineNumber(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the user data (XML reader context) */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderGetParserLineNumber(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetParserLineNumber",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetParserProp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    int prop; /* the xmlParserProperties to get */
-    int n_prop;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        prop = gen_int(n_prop, 1);
-
-        ret_val = xmlTextReaderGetParserProp(reader, prop);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_int(n_prop, prop, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_prop);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderGetRemainder(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlParserInputBufferPtr ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderGetRemainder(reader);
-        desret_xmlParserInputBufferPtr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderGetRemainder",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderHasAttributes(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderHasAttributes(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderHasValue(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderHasValue(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderHasValue",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderIsDefault(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderIsDefault(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderIsEmptyElement(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderIsEmptyElement(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderIsNamespaceDecl(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderIsNamespaceDecl(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderIsValid(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderIsValid(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderIsValid",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderLocalName(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderLocalName(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderLocalName",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-#ifdef LIBXML_READER_ENABLED
-
-#define gen_nb_xmlTextReaderLocatorPtr 1
-#define gen_xmlTextReaderLocatorPtr(no, nr) NULL
-#define des_xmlTextReaderLocatorPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlTextReaderLocatorBaseURI(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
-    int n_locator;
-
-    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
-        mem_base = xmlMemBlocks();
-        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
-
-        ret_val = xmlTextReaderLocatorBaseURI(locator);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderLocatorBaseURI",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_locator);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderLocatorLineNumber(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
-    int n_locator;
-
-    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
-        mem_base = xmlMemBlocks();
-        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
-
-        ret_val = xmlTextReaderLocatorLineNumber(locator);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderLocatorLineNumber",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_locator);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderLookupNamespace(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * prefix; /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
-    int n_prefix;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
-
-        ret_val = xmlTextReaderLookupNamespace(reader, prefix);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_prefix, prefix, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_prefix);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToAttribute(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * name; /* the qualified name of the attribute. */
-    int n_name;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        name = gen_const_xmlChar_ptr(n_name, 1);
-
-        ret_val = xmlTextReaderMoveToAttribute(reader, name);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_name, name, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_name);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToAttributeNo(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    int no; /* the zero-based index of the attribute relative to the containing element. */
-    int n_no;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_no = 0;n_no < gen_nb_int;n_no++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        no = gen_int(n_no, 1);
-
-        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_int(n_no, no, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_no);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToAttributeNs(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * localName; /* the local name of the attribute. */
-    int n_localName;
-    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
-    int n_namespaceURI;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
-    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        localName = gen_const_xmlChar_ptr(n_localName, 1);
-        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
-
-        ret_val = xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_localName, localName, 1);
-        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_localName);
-            printf(" %d", n_namespaceURI);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToElement(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderMoveToElement(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToFirstAttribute(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderMoveToNextAttribute(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderMoveToNextAttribute(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderName(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderName(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderName",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderNamespaceUri(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderNamespaceUri(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderNext(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderNext(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderNext",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderNextSibling(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderNextSibling(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderNodeType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderNodeType(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderNodeType",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderNormalization(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderNormalization(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderNormalization",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderPrefix(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderPrefix(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderPrefix",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderPreserve(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlNodePtr ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderPreserve(reader);
-        desret_xmlNodePtr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderPreserve",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderPreservePattern(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)
-#ifdef LIBXML_PATTERN_ENABLED
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const xmlChar * pattern; /* an XPath subset pattern */
-    int n_pattern;
-    const xmlChar ** namespaces; /* the prefix definitions, array of [URI, prefix] or NULL */
-    int n_namespaces;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_pattern = 0;n_pattern < gen_nb_const_xmlChar_ptr;n_pattern++) {
-    for (n_namespaces = 0;n_namespaces < gen_nb_const_xmlChar_ptr_ptr;n_namespaces++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        pattern = gen_const_xmlChar_ptr(n_pattern, 1);
-        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 2);
-
-        ret_val = xmlTextReaderPreservePattern(reader, pattern, namespaces);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_xmlChar_ptr(n_pattern, pattern, 1);
-        des_const_xmlChar_ptr_ptr(n_namespaces, namespaces, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderPreservePattern",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_pattern);
-            printf(" %d", n_namespaces);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderQuoteChar(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderQuoteChar(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderRead(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderRead(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderRead",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderReadAttributeValue(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderReadAttributeValue(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderReadState(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderReadState(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderReadState",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderRelaxNGSetSchema(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    xmlRelaxNGPtr schema; /* a precompiled RelaxNG schema */
-    int n_schema;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        schema = gen_xmlRelaxNGPtr(n_schema, 1);
-
-        ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_xmlRelaxNGPtr(n_schema, schema, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_schema);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderRelaxNGValidate(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const char * rng; /* the path to a RelaxNG schema or NULL */
-    int n_rng;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_rng = 0;n_rng < gen_nb_const_char_ptr;n_rng++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        rng = gen_const_char_ptr(n_rng, 1);
-
-        ret_val = xmlTextReaderRelaxNGValidate(reader, rng);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_char_ptr(n_rng, rng, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_rng);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderRelaxNGValidateCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG schema validation context or NULL */
-    int n_ctxt;
-    int options; /* options (not used yet) */
-    int n_options;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
-    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 1);
-        options = gen_parseroptions(n_options, 2);
-
-        ret_val = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 1);
-        des_parseroptions(n_options, options, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidateCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_ctxt);
-            printf(" %d", n_options);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSchemaValidate(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    const char * xsd; /* the path to a W3C XSD schema or NULL */
-    int n_xsd;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_xsd = 0;n_xsd < gen_nb_const_char_ptr;n_xsd++) {
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        xsd = gen_const_char_ptr(n_xsd, 1);
-
-        ret_val = xmlTextReaderSchemaValidate(reader, xsd);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_const_char_ptr(n_xsd, xsd, 1);
-        xmlResetLastError();
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSchemaValidateCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    xmlSchemaValidCtxtPtr ctxt; /* the XML Schema validation context or NULL */
-    int n_ctxt;
-    int options; /* options (not used yet) */
-    int n_options;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 1);
-        options = gen_parseroptions(n_options, 2);
-
-        ret_val = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 1);
-        des_parseroptions(n_options, options, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderSchemaValidateCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_ctxt);
-            printf(" %d", n_options);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetErrorHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetMaxAmplification(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetParserProp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    int prop; /* the xmlParserProperties to set */
-    int n_prop;
-    int value; /* usually 0 or 1 to (de)activate it */
-    int n_value;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
-    for (n_value = 0;n_value < gen_nb_int;n_value++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        prop = gen_int(n_prop, 1);
-        value = gen_int(n_value, 2);
-
-        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_int(n_prop, prop, 1);
-        des_int(n_value, value, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_prop);
-            printf(" %d", n_value);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetSchema(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-    xmlSchemaPtr schema; /* a precompiled Schema schema */
-    int n_schema;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        schema = gen_xmlSchemaPtr(n_schema, 1);
-
-        ret_val = xmlTextReaderSetSchema(reader, schema);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_xmlSchemaPtr(n_schema, schema, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderSetSchema",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_schema);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetStructuredErrorHandler(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderSetup(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* an XML reader */
-    int n_reader;
-    xmlParserInputBufferPtr input; /* xmlParserInputBufferPtr used to feed the reader, will be destroyed with it. */
-    int n_input;
-    const char * URL; /* the base URL to use for the document */
-    int n_URL;
-    const char * encoding; /* the document encoding, or NULL */
-    int n_encoding;
-    int options; /* a combination of xmlParserOption */
-    int n_options;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
-    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
-    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
-    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-        input = gen_xmlParserInputBufferPtr(n_input, 1);
-        URL = gen_filepath(n_URL, 2);
-        encoding = gen_const_char_ptr(n_encoding, 3);
-        options = gen_parseroptions(n_options, 4);
-
-        ret_val = xmlTextReaderSetup(reader, input, URL, encoding, options);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        des_filepath(n_URL, URL, 2);
-        des_const_char_ptr(n_encoding, encoding, 3);
-        des_parseroptions(n_options, options, 4);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderSetup",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf(" %d", n_input);
-            printf(" %d", n_URL);
-            printf(" %d", n_encoding);
-            printf(" %d", n_options);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderStandalone(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderStandalone(reader);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderStandalone",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderValue(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderValue(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderValue",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlTextReaderXmlLang(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_READER_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
-    int n_reader;
-
-    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
-        mem_base = xmlMemBlocks();
-        reader = gen_xmlTextReaderPtr(n_reader, 0);
-
-        ret_val = xmlTextReaderXmlLang(reader);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlTextReaderPtr(n_reader, reader, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_reader);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-static int
-test_xmlreader(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlreader : 76 of 88 functions ...\n");
-    test_ret += test_xmlNewTextReader();
-    test_ret += test_xmlNewTextReaderFilename();
-    test_ret += test_xmlReaderForDoc();
-    test_ret += test_xmlReaderForFile();
-    test_ret += test_xmlReaderForMemory();
-    test_ret += test_xmlReaderNewDoc();
-    test_ret += test_xmlReaderNewFile();
-    test_ret += test_xmlReaderNewMemory();
-    test_ret += test_xmlReaderNewWalker();
-    test_ret += test_xmlReaderWalker();
-    test_ret += test_xmlTextReaderAttributeCount();
-    test_ret += test_xmlTextReaderBaseUri();
-    test_ret += test_xmlTextReaderByteConsumed();
-    test_ret += test_xmlTextReaderClose();
-    test_ret += test_xmlTextReaderConstBaseUri();
-    test_ret += test_xmlTextReaderConstEncoding();
-    test_ret += test_xmlTextReaderConstLocalName();
-    test_ret += test_xmlTextReaderConstName();
-    test_ret += test_xmlTextReaderConstNamespaceUri();
-    test_ret += test_xmlTextReaderConstPrefix();
-    test_ret += test_xmlTextReaderConstString();
-    test_ret += test_xmlTextReaderConstValue();
-    test_ret += test_xmlTextReaderConstXmlLang();
-    test_ret += test_xmlTextReaderConstXmlVersion();
-    test_ret += test_xmlTextReaderCurrentDoc();
-    test_ret += test_xmlTextReaderCurrentNode();
-    test_ret += test_xmlTextReaderDepth();
-    test_ret += test_xmlTextReaderExpand();
-    test_ret += test_xmlTextReaderGetAttribute();
-    test_ret += test_xmlTextReaderGetAttributeNo();
-    test_ret += test_xmlTextReaderGetAttributeNs();
-    test_ret += test_xmlTextReaderGetErrorHandler();
-    test_ret += test_xmlTextReaderGetLastError();
-    test_ret += test_xmlTextReaderGetParserColumnNumber();
-    test_ret += test_xmlTextReaderGetParserLineNumber();
-    test_ret += test_xmlTextReaderGetParserProp();
-    test_ret += test_xmlTextReaderGetRemainder();
-    test_ret += test_xmlTextReaderHasAttributes();
-    test_ret += test_xmlTextReaderHasValue();
-    test_ret += test_xmlTextReaderIsDefault();
-    test_ret += test_xmlTextReaderIsEmptyElement();
-    test_ret += test_xmlTextReaderIsNamespaceDecl();
-    test_ret += test_xmlTextReaderIsValid();
-    test_ret += test_xmlTextReaderLocalName();
-    test_ret += test_xmlTextReaderLocatorBaseURI();
-    test_ret += test_xmlTextReaderLocatorLineNumber();
-    test_ret += test_xmlTextReaderLookupNamespace();
-    test_ret += test_xmlTextReaderMoveToAttribute();
-    test_ret += test_xmlTextReaderMoveToAttributeNo();
-    test_ret += test_xmlTextReaderMoveToAttributeNs();
-    test_ret += test_xmlTextReaderMoveToElement();
-    test_ret += test_xmlTextReaderMoveToFirstAttribute();
-    test_ret += test_xmlTextReaderMoveToNextAttribute();
-    test_ret += test_xmlTextReaderName();
-    test_ret += test_xmlTextReaderNamespaceUri();
-    test_ret += test_xmlTextReaderNext();
-    test_ret += test_xmlTextReaderNextSibling();
-    test_ret += test_xmlTextReaderNodeType();
-    test_ret += test_xmlTextReaderNormalization();
-    test_ret += test_xmlTextReaderPrefix();
-    test_ret += test_xmlTextReaderPreserve();
-    test_ret += test_xmlTextReaderPreservePattern();
-    test_ret += test_xmlTextReaderQuoteChar();
-    test_ret += test_xmlTextReaderRead();
-    test_ret += test_xmlTextReaderReadAttributeValue();
-    test_ret += test_xmlTextReaderReadState();
-    test_ret += test_xmlTextReaderRelaxNGSetSchema();
-    test_ret += test_xmlTextReaderRelaxNGValidate();
-    test_ret += test_xmlTextReaderRelaxNGValidateCtxt();
-    test_ret += test_xmlTextReaderSchemaValidate();
-    test_ret += test_xmlTextReaderSchemaValidateCtxt();
-    test_ret += test_xmlTextReaderSetErrorHandler();
-    test_ret += test_xmlTextReaderSetMaxAmplification();
-    test_ret += test_xmlTextReaderSetParserProp();
-    test_ret += test_xmlTextReaderSetSchema();
-    test_ret += test_xmlTextReaderSetStructuredErrorHandler();
-    test_ret += test_xmlTextReaderSetup();
-    test_ret += test_xmlTextReaderStandalone();
-    test_ret += test_xmlTextReaderValue();
-    test_ret += test_xmlTextReaderXmlLang();
-
-    if (test_ret != 0)
-	printf("Module xmlreader: %d errors\n", test_ret);
-    return(test_ret);
-}
-
-static int
-test_xmlExpCtxtNbCons(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpCtxtPtr ctxt; /* an expression context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlExpCtxtNbCons(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpCtxtNbCons",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpCtxtNbNodes(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpCtxtPtr ctxt; /* an expression context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlExpCtxtNbNodes(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpCtxtNbNodes",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpDump(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    xmlBufferPtr buf; /* a buffer to receive the output */
-    int n_buf;
-    xmlExpNodePtr expr; /* the compiled expression */
-    int n_expr;
-
-    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
-    for (n_expr = 0;n_expr < gen_nb_xmlExpNodePtr;n_expr++) {
-        mem_base = xmlMemBlocks();
-        buf = gen_xmlBufferPtr(n_buf, 0);
-        expr = gen_xmlExpNodePtr(n_expr, 1);
-
-        xmlExpDump(buf, expr);
-        call_tests++;
-        des_xmlBufferPtr(n_buf, buf, 0);
-        des_xmlExpNodePtr(n_expr, expr, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpDump",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_buf);
-            printf(" %d", n_expr);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpExpDerive(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpGetLanguage(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpCtxtPtr ctxt; /* the expression context */
-    int n_ctxt;
-    xmlExpNodePtr exp; /* the expression */
-    int n_exp;
-    const xmlChar ** langList; /* where to store the tokens */
-    int n_langList;
-    int len; /* the allocated length of @list */
-    int n_len;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
-    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
-    for (n_langList = 0;n_langList < gen_nb_const_xmlChar_ptr_ptr;n_langList++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
-        exp = gen_xmlExpNodePtr(n_exp, 1);
-        langList = gen_const_xmlChar_ptr_ptr(n_langList, 2);
-        len = gen_int(n_len, 3);
-
-        ret_val = xmlExpGetLanguage(ctxt, exp, langList, len);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlExpNodePtr(n_exp, exp, 1);
-        des_const_xmlChar_ptr_ptr(n_langList, langList, 2);
-        des_int(n_len, len, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpGetLanguage",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_exp);
-            printf(" %d", n_langList);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpGetStart(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpCtxtPtr ctxt; /* the expression context */
-    int n_ctxt;
-    xmlExpNodePtr exp; /* the expression */
-    int n_exp;
-    const xmlChar ** tokList; /* where to store the tokens */
-    int n_tokList;
-    int len; /* the allocated length of @list */
-    int n_len;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
-    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
-    for (n_tokList = 0;n_tokList < gen_nb_const_xmlChar_ptr_ptr;n_tokList++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
-        exp = gen_xmlExpNodePtr(n_exp, 1);
-        tokList = gen_const_xmlChar_ptr_ptr(n_tokList, 2);
-        len = gen_int(n_len, 3);
-
-        ret_val = xmlExpGetStart(ctxt, exp, tokList, len);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlExpNodePtr(n_exp, exp, 1);
-        des_const_xmlChar_ptr_ptr(n_tokList, tokList, 2);
-        des_int(n_len, len, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpGetStart",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_exp);
-            printf(" %d", n_tokList);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpIsNillable(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpNodePtr exp; /* the expression */
-    int n_exp;
-
-    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
-        mem_base = xmlMemBlocks();
-        exp = gen_xmlExpNodePtr(n_exp, 0);
-
-        ret_val = xmlExpIsNillable(exp);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpNodePtr(n_exp, exp, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpIsNillable",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exp);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpMaxToken(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpNodePtr expr; /* a compiled expression */
-    int n_expr;
-
-    for (n_expr = 0;n_expr < gen_nb_xmlExpNodePtr;n_expr++) {
-        mem_base = xmlMemBlocks();
-        expr = gen_xmlExpNodePtr(n_expr, 0);
-
-        ret_val = xmlExpMaxToken(expr);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpNodePtr(n_expr, expr, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpMaxToken",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_expr);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpNewAtom(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpNewCtxt(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpNewOr(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpNewRange(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpNewSeq(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpParse(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpRef(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    xmlExpNodePtr exp; /* the expression */
-    int n_exp;
-
-    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
-        mem_base = xmlMemBlocks();
-        exp = gen_xmlExpNodePtr(n_exp, 0);
-
-        xmlExpRef(exp);
-        call_tests++;
-        des_xmlExpNodePtr(n_exp, exp, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpRef",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exp);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpStringDerive(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlExpSubsume(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlExpCtxtPtr ctxt; /* the expressions context */
-    int n_ctxt;
-    xmlExpNodePtr exp; /* the englobing expression */
-    int n_exp;
-    xmlExpNodePtr sub; /* the subexpression */
-    int n_sub;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
-    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
-    for (n_sub = 0;n_sub < gen_nb_xmlExpNodePtr;n_sub++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
-        exp = gen_xmlExpNodePtr(n_exp, 1);
-        sub = gen_xmlExpNodePtr(n_sub, 2);
-
-        ret_val = xmlExpSubsume(ctxt, exp, sub);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlExpNodePtr(n_exp, exp, 1);
-        des_xmlExpNodePtr(n_sub, sub, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlExpSubsume",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_exp);
-            printf(" %d", n_sub);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-#ifdef LIBXML_REGEXP_ENABLED
-
-#define gen_nb_xmlRegExecCtxtPtr 1
-#define gen_xmlRegExecCtxtPtr(no, nr) NULL
-#define des_xmlRegExecCtxtPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlRegExecErrInfo(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegExecCtxtPtr exec; /* a regexp execution context generating an error */
-    int n_exec;
-    const xmlChar ** string; /* return value for the error string */
-    int n_string;
-    int * nbval; /* pointer to the number of accepted values IN/OUT */
-    int n_nbval;
-    int * nbneg; /* return number of negative transitions */
-    int n_nbneg;
-    xmlChar ** values; /* pointer to the array of acceptable values */
-    int n_values;
-    int * terminal; /* return value if this was a terminal state */
-    int n_terminal;
-
-    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
-    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr_ptr;n_string++) {
-    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
-    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
-    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
-    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
-        mem_base = xmlMemBlocks();
-        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
-        string = gen_const_xmlChar_ptr_ptr(n_string, 1);
-        nbval = gen_int_ptr(n_nbval, 2);
-        nbneg = gen_int_ptr(n_nbneg, 3);
-        values = gen_xmlChar_ptr_ptr(n_values, 4);
-        terminal = gen_int_ptr(n_terminal, 5);
-
-        ret_val = xmlRegExecErrInfo(exec, string, nbval, nbneg, values, terminal);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
-        des_const_xmlChar_ptr_ptr(n_string, string, 1);
-        des_int_ptr(n_nbval, nbval, 2);
-        des_int_ptr(n_nbneg, nbneg, 3);
-        des_xmlChar_ptr_ptr(n_values, values, 4);
-        des_int_ptr(n_terminal, terminal, 5);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegExecErrInfo",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exec);
-            printf(" %d", n_string);
-            printf(" %d", n_nbval);
-            printf(" %d", n_nbneg);
-            printf(" %d", n_values);
-            printf(" %d", n_terminal);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegExecNextValues(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegExecCtxtPtr exec; /* a regexp execution context */
-    int n_exec;
-    int * nbval; /* pointer to the number of accepted values IN/OUT */
-    int n_nbval;
-    int * nbneg; /* return number of negative transitions */
-    int n_nbneg;
-    xmlChar ** values; /* pointer to the array of acceptable values */
-    int n_values;
-    int * terminal; /* return value if this was a terminal state */
-    int n_terminal;
-
-    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
-    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
-    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
-    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
-    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
-        mem_base = xmlMemBlocks();
-        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
-        nbval = gen_int_ptr(n_nbval, 1);
-        nbneg = gen_int_ptr(n_nbneg, 2);
-        values = gen_xmlChar_ptr_ptr(n_values, 3);
-        terminal = gen_int_ptr(n_terminal, 4);
-
-        ret_val = xmlRegExecNextValues(exec, nbval, nbneg, values, terminal);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
-        des_int_ptr(n_nbval, nbval, 1);
-        des_int_ptr(n_nbneg, nbneg, 2);
-        des_xmlChar_ptr_ptr(n_values, values, 3);
-        des_int_ptr(n_terminal, terminal, 4);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegExecNextValues",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exec);
-            printf(" %d", n_nbval);
-            printf(" %d", n_nbneg);
-            printf(" %d", n_values);
-            printf(" %d", n_terminal);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegExecPushString(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
-    int n_exec;
-    const xmlChar * value; /* a string token input */
-    int n_value;
-    void * data; /* data associated to the token to reuse in callbacks */
-    int n_data;
-
-    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
-        mem_base = xmlMemBlocks();
-        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        data = gen_userdata(n_data, 2);
-
-        ret_val = xmlRegExecPushString(exec, value, data);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_userdata(n_data, data, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegExecPushString",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exec);
-            printf(" %d", n_value);
-            printf(" %d", n_data);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegExecPushString2(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
-    int n_exec;
-    const xmlChar * value; /* the first string token input */
-    int n_value;
-    const xmlChar * value2; /* the second string token input */
-    int n_value2;
-    void * data; /* data associated to the token to reuse in callbacks */
-    int n_data;
-
-    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_value2 = 0;n_value2 < gen_nb_const_xmlChar_ptr;n_value2++) {
-    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
-        mem_base = xmlMemBlocks();
-        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        value2 = gen_const_xmlChar_ptr(n_value2, 2);
-        data = gen_userdata(n_data, 3);
-
-        ret_val = xmlRegExecPushString2(exec, value, value2, data);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_const_xmlChar_ptr(n_value2, value2, 2);
-        des_userdata(n_data, data, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegExecPushString2",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_exec);
-            printf(" %d", n_value);
-            printf(" %d", n_value2);
-            printf(" %d", n_data);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegNewExecCtxt(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegexpCompile(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-#ifdef LIBXML_REGEXP_ENABLED
-
-#define gen_nb_xmlRegexpPtr 1
-#define gen_xmlRegexpPtr(no, nr) NULL
-#define des_xmlRegexpPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlRegexpExec(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegexpPtr comp; /* the compiled regular expression */
-    int n_comp;
-    const xmlChar * content; /* the value to check against the regular expression */
-    int n_content;
-
-    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
-    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
-        mem_base = xmlMemBlocks();
-        comp = gen_xmlRegexpPtr(n_comp, 0);
-        content = gen_const_xmlChar_ptr(n_content, 1);
-
-        ret_val = xmlRegexpExec(comp, content);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegexpPtr(n_comp, comp, 0);
-        des_const_xmlChar_ptr(n_content, content, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegexpExec",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_comp);
-            printf(" %d", n_content);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegexpIsDeterminist(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlRegexpPtr comp; /* the compiled regular expression */
-    int n_comp;
-
-    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
-        mem_base = xmlMemBlocks();
-        comp = gen_xmlRegexpPtr(n_comp, 0);
-
-        ret_val = xmlRegexpIsDeterminist(comp);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlRegexpPtr(n_comp, comp, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegexpIsDeterminist",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_comp);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlRegexpPrint(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_REGEXP_ENABLED)
-    int mem_base;
-    FILE * output; /* the file for the output debug */
-    int n_output;
-    xmlRegexpPtr regexp; /* the compiled regexp */
-    int n_regexp;
-
-    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
-    for (n_regexp = 0;n_regexp < gen_nb_xmlRegexpPtr;n_regexp++) {
-        mem_base = xmlMemBlocks();
-        output = gen_FILE_ptr(n_output, 0);
-        regexp = gen_xmlRegexpPtr(n_regexp, 1);
-
-        xmlRegexpPrint(output, regexp);
-        call_tests++;
-        des_FILE_ptr(n_output, output, 0);
-        des_xmlRegexpPtr(n_regexp, regexp, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlRegexpPrint",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_output);
-            printf(" %d", n_regexp);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-static int
-test_xmlregexp(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlregexp : 16 of 30 functions ...\n");
-    test_ret += test_xmlExpCtxtNbCons();
-    test_ret += test_xmlExpCtxtNbNodes();
-    test_ret += test_xmlExpDump();
-    test_ret += test_xmlExpExpDerive();
-    test_ret += test_xmlExpGetLanguage();
-    test_ret += test_xmlExpGetStart();
-    test_ret += test_xmlExpIsNillable();
-    test_ret += test_xmlExpMaxToken();
-    test_ret += test_xmlExpNewAtom();
-    test_ret += test_xmlExpNewCtxt();
-    test_ret += test_xmlExpNewOr();
-    test_ret += test_xmlExpNewRange();
-    test_ret += test_xmlExpNewSeq();
-    test_ret += test_xmlExpParse();
-    test_ret += test_xmlExpRef();
-    test_ret += test_xmlExpStringDerive();
-    test_ret += test_xmlExpSubsume();
-    test_ret += test_xmlRegExecErrInfo();
-    test_ret += test_xmlRegExecNextValues();
-    test_ret += test_xmlRegExecPushString();
-    test_ret += test_xmlRegExecPushString2();
-    test_ret += test_xmlRegNewExecCtxt();
-    test_ret += test_xmlRegexpCompile();
-    test_ret += test_xmlRegexpExec();
-    test_ret += test_xmlRegexpIsDeterminist();
-    test_ret += test_xmlRegexpPrint();
-
-    if (test_ret != 0)
-	printf("Module xmlregexp: %d errors\n", test_ret);
-    return(test_ret);
-}
-#ifdef LIBXML_OUTPUT_ENABLED
-
-#define gen_nb_xmlSaveCtxtPtr 1
-#define gen_xmlSaveCtxtPtr(no, nr) NULL
-#define des_xmlSaveCtxtPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSaveClose(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSaveCtxtPtr ctxt; /* a document saving context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSaveClose(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSaveClose",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveDoc(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    long ret_val;
-    xmlSaveCtxtPtr ctxt; /* a document saving context */
-    int n_ctxt;
-    xmlDocPtr doc; /* a document */
-    int n_doc;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
-    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
-        doc = gen_xmlDocPtr(n_doc, 1);
-
-        ret_val = xmlSaveDoc(ctxt, doc);
-        desret_long(ret_val);
-        call_tests++;
-        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlDocPtr(n_doc, doc, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSaveDoc",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_doc);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveFinish(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSaveCtxtPtr ctxt; /* a document saving context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSaveFinish(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSaveFinish",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveFlush(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSaveCtxtPtr ctxt; /* a document saving context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSaveFlush(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSaveFlush",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveSetAttrEscape(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveSetEscape(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveToBuffer(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveToFd(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveToFilename(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSaveTree(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    long ret_val;
-    xmlSaveCtxtPtr ctxt; /* a document saving context */
-    int n_ctxt;
-    xmlNodePtr cur; /* the top node of the subtree to save */
-    int n_cur;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
-    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
-        cur = gen_xmlNodePtr(n_cur, 1);
-
-        ret_val = xmlSaveTree(ctxt, cur);
-        desret_long(ret_val);
-        call_tests++;
-        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlNodePtr(n_cur, cur, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSaveTree",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_cur);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlThrDefIndentTreeOutput(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    int ret_val;
-    int v; /*  */
-    int n_v;
-
-    for (n_v = 0;n_v < gen_nb_int;n_v++) {
-        mem_base = xmlMemBlocks();
-        v = gen_int(n_v, 0);
-
-        ret_val = xmlThrDefIndentTreeOutput(v);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_v, v, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlThrDefIndentTreeOutput",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_v);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlThrDefSaveNoEmptyTags(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    int ret_val;
-    int v; /*  */
-    int n_v;
-
-    for (n_v = 0;n_v < gen_nb_int;n_v++) {
-        mem_base = xmlMemBlocks();
-        v = gen_int(n_v, 0);
-
-        ret_val = xmlThrDefSaveNoEmptyTags(v);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_v, v, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlThrDefSaveNoEmptyTags",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_v);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlThrDefTreeIndentString(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    const char * ret_val;
-    const char * v; /*  */
-    int n_v;
-
-    for (n_v = 0;n_v < gen_nb_const_char_ptr;n_v++) {
-        mem_base = xmlMemBlocks();
-        v = gen_const_char_ptr(n_v, 0);
-
-        ret_val = xmlThrDefTreeIndentString(v);
-        desret_const_char_ptr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_v, v, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlThrDefTreeIndentString",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_v);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-static int
-test_xmlsave(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlsave : 8 of 14 functions ...\n");
-    test_ret += test_xmlSaveClose();
-    test_ret += test_xmlSaveDoc();
-    test_ret += test_xmlSaveFinish();
-    test_ret += test_xmlSaveFlush();
-    test_ret += test_xmlSaveSetAttrEscape();
-    test_ret += test_xmlSaveSetEscape();
-    test_ret += test_xmlSaveToBuffer();
-    test_ret += test_xmlSaveToFd();
-    test_ret += test_xmlSaveToFilename();
-    test_ret += test_xmlSaveTree();
-    test_ret += test_xmlThrDefIndentTreeOutput();
-    test_ret += test_xmlThrDefSaveNoEmptyTags();
-    test_ret += test_xmlThrDefTreeIndentString();
-
-    if (test_ret != 0)
-	printf("Module xmlsave: %d errors\n", test_ret);
-    return(test_ret);
-}
-
-static int
-test_xmlSchemaDump(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
-    int mem_base;
-    FILE * output; /* the file output */
-    int n_output;
-    xmlSchemaPtr schema; /* a schema structure */
-    int n_schema;
-
-    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
-    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
-        mem_base = xmlMemBlocks();
-        output = gen_FILE_ptr(n_output, 0);
-        schema = gen_xmlSchemaPtr(n_schema, 1);
-
-        xmlSchemaDump(output, schema);
-        call_tests++;
-        des_FILE_ptr(n_output, output, 0);
-        des_xmlSchemaPtr(n_schema, schema, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaDump",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_output);
-            printf(" %d", n_schema);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaParserCtxtPtr 1
-#define gen_xmlSchemaParserCtxtPtr(no, nr) NULL
-#define des_xmlSchemaParserCtxtPtr(no, val, nr)
-#endif
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaValidityErrorFunc_ptr 1
-#define gen_xmlSchemaValidityErrorFunc_ptr(no, nr) NULL
-#define des_xmlSchemaValidityErrorFunc_ptr(no, val, nr)
-#endif
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaValidityWarningFunc_ptr 1
-#define gen_xmlSchemaValidityWarningFunc_ptr(no, nr) NULL
-#define des_xmlSchemaValidityWarningFunc_ptr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSchemaGetParserErrors(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaParserCtxtPtr ctxt; /* a XMl-Schema parser context */
-    int n_ctxt;
-    xmlSchemaValidityErrorFunc * err; /* the error callback result */
-    int n_err;
-    xmlSchemaValidityWarningFunc * warn; /* the warning callback result */
-    int n_warn;
-    void ** ctx; /* contextual data for the callbacks result */
-    int n_ctx;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaParserCtxtPtr;n_ctxt++) {
-    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
-    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
-    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 0);
-        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
-        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
-        ctx = gen_void_ptr_ptr(n_ctx, 3);
-
-        ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
-        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
-        des_void_ptr_ptr(n_ctx, ctx, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetParserErrors",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_err);
-            printf(" %d", n_warn);
-            printf(" %d", n_ctx);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetValidErrors(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a XML-Schema validation context */
-    int n_ctxt;
-    xmlSchemaValidityErrorFunc * err; /* the error function result */
-    int n_err;
-    xmlSchemaValidityWarningFunc * warn; /* the warning function result */
-    int n_warn;
-    void ** ctx; /* the functions context result */
-    int n_ctx;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
-    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
-    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
-        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
-        ctx = gen_void_ptr_ptr(n_ctx, 3);
-
-        ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
-        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
-        des_void_ptr_ptr(n_ctx, ctx, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetValidErrors",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_err);
-            printf(" %d", n_warn);
-            printf(" %d", n_ctx);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaIsValid(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* the schema validation context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSchemaIsValid(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaIsValid",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewDocParserCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaParserCtxtPtr ret_val;
-    xmlDocPtr doc; /* a preparsed document tree */
-    int n_doc;
-
-    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
-        mem_base = xmlMemBlocks();
-        doc = gen_xmlDocPtr(n_doc, 0);
-
-        ret_val = xmlSchemaNewDocParserCtxt(doc);
-        desret_xmlSchemaParserCtxtPtr(ret_val);
-        call_tests++;
-        des_xmlDocPtr(n_doc, doc, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaNewDocParserCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_doc);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewMemParserCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaParserCtxtPtr ret_val;
-    const char * buffer; /* a pointer to a char array containing the schemas */
-    int n_buffer;
-    int size; /* the size of the array */
-    int n_size;
-
-    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
-    for (n_size = 0;n_size < gen_nb_int;n_size++) {
-        mem_base = xmlMemBlocks();
-        buffer = gen_const_char_ptr(n_buffer, 0);
-        size = gen_int(n_size, 1);
-        if ((buffer != NULL) &&
-            (size > xmlStrlen(BAD_CAST buffer)))
-            size = 0;
-
-        ret_val = xmlSchemaNewMemParserCtxt(buffer, size);
-        desret_xmlSchemaParserCtxtPtr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_buffer, buffer, 0);
-        des_int(n_size, size, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaNewMemParserCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_buffer);
-            printf(" %d", n_size);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewParserCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaParserCtxtPtr ret_val;
-    const char * URL; /* the location of the schema */
-    int n_URL;
-
-    for (n_URL = 0;n_URL < gen_nb_const_char_ptr;n_URL++) {
-        mem_base = xmlMemBlocks();
-        URL = gen_const_char_ptr(n_URL, 0);
-
-        ret_val = xmlSchemaNewParserCtxt(URL);
-        desret_xmlSchemaParserCtxtPtr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_URL, URL, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaNewParserCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_URL);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewValidCtxt(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaParse(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSAXPlug(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaSAXPlugPtr 1
-#define gen_xmlSchemaSAXPlugPtr(no, nr) NULL
-#define des_xmlSchemaSAXPlugPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSchemaSAXUnplug(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaSAXPlugPtr plug; /* a data structure returned by xmlSchemaSAXPlug */
-    int n_plug;
-
-    for (n_plug = 0;n_plug < gen_nb_xmlSchemaSAXPlugPtr;n_plug++) {
-        mem_base = xmlMemBlocks();
-        plug = gen_xmlSchemaSAXPlugPtr(n_plug, 0);
-
-        ret_val = xmlSchemaSAXUnplug(plug);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaSAXPlugPtr(n_plug, plug, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaSAXUnplug",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_plug);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSetParserErrors(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSetParserStructuredErrors(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSetValidErrors(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSetValidOptions(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-    int options; /* a combination of xmlSchemaValidOption */
-    int n_options;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_options = 0;n_options < gen_nb_int;n_options++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        options = gen_int(n_options, 1);
-
-        ret_val = xmlSchemaSetValidOptions(ctxt, options);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_int(n_options, options, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaSetValidOptions",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_options);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaSetValidStructuredErrors(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidCtxtGetOptions(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSchemaValidCtxtGetOptions(ctxt);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetOptions",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidCtxtGetParserCtxt(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlParserCtxtPtr ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-
-        ret_val = xmlSchemaValidCtxtGetParserCtxt(ctxt);
-        desret_xmlParserCtxtPtr(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetParserCtxt",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateDoc(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-    xmlDocPtr doc; /* a parsed document tree */
-    int n_doc;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        doc = gen_xmlDocPtr(n_doc, 1);
-
-        ret_val = xmlSchemaValidateDoc(ctxt, doc);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlDocPtr(n_doc, doc, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateDoc",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_doc);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateFile(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-    const char * filename; /* the URI of the instance */
-    int n_filename;
-    int options; /* a future set of options, currently unused */
-    int n_options;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
-    for (n_options = 0;n_options < gen_nb_int;n_options++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        filename = gen_filepath(n_filename, 1);
-        options = gen_int(n_options, 2);
-
-        ret_val = xmlSchemaValidateFile(ctxt, filename, options);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_filepath(n_filename, filename, 1);
-        des_int(n_options, options, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateFile",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_filename);
-            printf(" %d", n_options);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateOneElement(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-    xmlNodePtr elem; /* an element node */
-    int n_elem;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        elem = gen_xmlNodePtr(n_elem, 1);
-
-        ret_val = xmlSchemaValidateOneElement(ctxt, elem);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlNodePtr(n_elem, elem, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateOneElement",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_elem);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateSetFilename(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaValidCtxtPtr vctxt; /* the schema validation context */
-    int n_vctxt;
-    const char * filename; /* the file name */
-    int n_filename;
-
-    for (n_vctxt = 0;n_vctxt < gen_nb_xmlSchemaValidCtxtPtr;n_vctxt++) {
-    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
-        mem_base = xmlMemBlocks();
-        vctxt = gen_xmlSchemaValidCtxtPtr(n_vctxt, 0);
-        filename = gen_filepath(n_filename, 1);
-
-        xmlSchemaValidateSetFilename(vctxt, filename);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_vctxt, vctxt, 0);
-        des_filepath(n_filename, filename, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateSetFilename",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_vctxt);
-            printf(" %d", n_filename);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateSetLocator(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateStream(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
-    int n_ctxt;
-    xmlParserInputBufferPtr input; /* the input to use for reading the data */
-    int n_input;
-    xmlCharEncoding enc; /* an optional encoding information */
-    int n_enc;
-    xmlSAXHandlerPtr sax; /* a SAX handler for the resulting events */
-    int n_sax;
-    void * user_data; /* the context to provide to the SAX handler. */
-    int n_user_data;
-
-    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
-    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
-    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
-    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
-    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
-        mem_base = xmlMemBlocks();
-        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
-        input = gen_xmlParserInputBufferPtr(n_input, 1);
-        enc = gen_xmlCharEncoding(n_enc, 2);
-        sax = gen_xmlSAXHandlerPtr(n_sax, 3);
-        user_data = gen_userdata(n_user_data, 4);
-
-        ret_val = xmlSchemaValidateStream(ctxt, input, enc, sax, user_data);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
-        des_xmlParserInputBufferPtr(n_input, input, 1);
-        des_xmlCharEncoding(n_enc, enc, 2);
-        des_xmlSAXHandlerPtr(n_sax, sax, 3);
-        des_userdata(n_user_data, user_data, 4);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateStream",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_ctxt);
-            printf(" %d", n_input);
-            printf(" %d", n_enc);
-            printf(" %d", n_sax);
-            printf(" %d", n_user_data);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-static int
-test_xmlschemas(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlschemas : 16 of 27 functions ...\n");
-    test_ret += test_xmlSchemaDump();
-    test_ret += test_xmlSchemaGetParserErrors();
-    test_ret += test_xmlSchemaGetValidErrors();
-    test_ret += test_xmlSchemaIsValid();
-    test_ret += test_xmlSchemaNewDocParserCtxt();
-    test_ret += test_xmlSchemaNewMemParserCtxt();
-    test_ret += test_xmlSchemaNewParserCtxt();
-    test_ret += test_xmlSchemaNewValidCtxt();
-    test_ret += test_xmlSchemaParse();
-    test_ret += test_xmlSchemaSAXPlug();
-    test_ret += test_xmlSchemaSAXUnplug();
-    test_ret += test_xmlSchemaSetParserErrors();
-    test_ret += test_xmlSchemaSetParserStructuredErrors();
-    test_ret += test_xmlSchemaSetValidErrors();
-    test_ret += test_xmlSchemaSetValidOptions();
-    test_ret += test_xmlSchemaSetValidStructuredErrors();
-    test_ret += test_xmlSchemaValidCtxtGetOptions();
-    test_ret += test_xmlSchemaValidCtxtGetParserCtxt();
-    test_ret += test_xmlSchemaValidateDoc();
-    test_ret += test_xmlSchemaValidateFile();
-    test_ret += test_xmlSchemaValidateOneElement();
-    test_ret += test_xmlSchemaValidateSetFilename();
-    test_ret += test_xmlSchemaValidateSetLocator();
-    test_ret += test_xmlSchemaValidateStream();
-
-    if (test_ret != 0)
-	printf("Module xmlschemas: %d errors\n", test_ret);
-    return(test_ret);
-}
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaFacetPtr 1
-#define gen_xmlSchemaFacetPtr(no, nr) NULL
-#define des_xmlSchemaFacetPtr(no, val, nr)
-#endif
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaTypePtr 1
-#define gen_xmlSchemaTypePtr(no, nr) NULL
-#define des_xmlSchemaTypePtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSchemaCheckFacet(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaFacetPtr facet; /* the facet */
-    int n_facet;
-    xmlSchemaTypePtr typeDecl; /* the schema type definition */
-    int n_typeDecl;
-    xmlSchemaParserCtxtPtr pctxt; /* the schema parser context or NULL */
-    int n_pctxt;
-    const xmlChar * name; /* the optional name of the type */
-    int n_name;
-
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_typeDecl = 0;n_typeDecl < gen_nb_xmlSchemaTypePtr;n_typeDecl++) {
-    for (n_pctxt = 0;n_pctxt < gen_nb_xmlSchemaParserCtxtPtr;n_pctxt++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-        mem_base = xmlMemBlocks();
-        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
-        typeDecl = gen_xmlSchemaTypePtr(n_typeDecl, 1);
-        pctxt = gen_xmlSchemaParserCtxtPtr(n_pctxt, 2);
-        name = gen_const_xmlChar_ptr(n_name, 3);
-
-        ret_val = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaFacetPtr(n_facet, facet, 0);
-        des_xmlSchemaTypePtr(n_typeDecl, typeDecl, 1);
-        des_xmlSchemaParserCtxtPtr(n_pctxt, pctxt, 2);
-        des_const_xmlChar_ptr(n_name, name, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaCheckFacet",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_facet);
-            printf(" %d", n_typeDecl);
-            printf(" %d", n_pctxt);
-            printf(" %d", n_name);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaCleanupTypes(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-
-
-        xmlSchemaCleanupTypes();
-        call_tests++;
-        xmlResetLastError();
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaCollapseString(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * value; /* a value */
-    int n_value;
-
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-        mem_base = xmlMemBlocks();
-        value = gen_const_xmlChar_ptr(n_value, 0);
-
-        ret_val = xmlSchemaCollapseString(value);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_value, value, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaCollapseString",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_value);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaValPtr 1
-#define gen_xmlSchemaValPtr(no, nr) NULL
-#define des_xmlSchemaValPtr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSchemaCompareValues(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr x; /* a first value */
-    int n_x;
-    xmlSchemaValPtr y; /* a second value */
-    int n_y;
-
-    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
-    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
-        mem_base = xmlMemBlocks();
-        x = gen_xmlSchemaValPtr(n_x, 0);
-        y = gen_xmlSchemaValPtr(n_y, 1);
-
-        ret_val = xmlSchemaCompareValues(x, y);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_x, x, 0);
-        des_xmlSchemaValPtr(n_y, y, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaCompareValues",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_x);
-            printf(" %d", n_y);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaCompareValuesWhtsp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr x; /* a first value */
-    int n_x;
-    xmlSchemaWhitespaceValueType xws; /* the whitespace value of x */
-    int n_xws;
-    xmlSchemaValPtr y; /* a second value */
-    int n_y;
-    xmlSchemaWhitespaceValueType yws; /* the whitespace value of y */
-    int n_yws;
-
-    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
-    for (n_xws = 0;n_xws < gen_nb_xmlSchemaWhitespaceValueType;n_xws++) {
-    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
-    for (n_yws = 0;n_yws < gen_nb_xmlSchemaWhitespaceValueType;n_yws++) {
-        mem_base = xmlMemBlocks();
-        x = gen_xmlSchemaValPtr(n_x, 0);
-        xws = gen_xmlSchemaWhitespaceValueType(n_xws, 1);
-        y = gen_xmlSchemaValPtr(n_y, 2);
-        yws = gen_xmlSchemaWhitespaceValueType(n_yws, 3);
-
-        ret_val = xmlSchemaCompareValuesWhtsp(x, xws, y, yws);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_x, x, 0);
-        des_xmlSchemaWhitespaceValueType(n_xws, xws, 1);
-        des_xmlSchemaValPtr(n_y, y, 2);
-        des_xmlSchemaWhitespaceValueType(n_yws, yws, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaCompareValuesWhtsp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_x);
-            printf(" %d", n_xws);
-            printf(" %d", n_y);
-            printf(" %d", n_yws);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaCopyValue(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaTypePtr ret_val;
-    xmlSchemaTypePtr type; /* the built-in simple type. */
-    int n_type;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-
-        ret_val = xmlSchemaGetBuiltInListSimpleTypeItemType(type);
-        desret_xmlSchemaTypePtr(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetBuiltInListSimpleTypeItemType",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetBuiltInType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    xmlSchemaTypePtr ret_val;
-    xmlSchemaValType type; /* the type of the built in type */
-    int n_type;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaValType;n_type++) {
-        type = gen_xmlSchemaValType(n_type, 0);
-
-        ret_val = xmlSchemaGetBuiltInType(type);
-        desret_xmlSchemaTypePtr(ret_val);
-        call_tests++;
-        des_xmlSchemaValType(n_type, type, 0);
-        xmlResetLastError();
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetCanonValue(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-    const xmlChar ** retValue; /* the returned value */
-    int n_retValue;
-
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
-        mem_base = xmlMemBlocks();
-        val = gen_xmlSchemaValPtr(n_val, 0);
-        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
-
-        ret_val = xmlSchemaGetCanonValue(val, retValue);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_val, val, 0);
-        des_const_xmlChar_ptr_ptr(n_retValue, retValue, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetCanonValue",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_val);
-            printf(" %d", n_retValue);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetCanonValueWhtsp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-    const xmlChar ** retValue; /* the returned value */
-    int n_retValue;
-    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
-    int n_ws;
-
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
-    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
-        mem_base = xmlMemBlocks();
-        val = gen_xmlSchemaValPtr(n_val, 0);
-        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
-        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 2);
-
-        ret_val = xmlSchemaGetCanonValueWhtsp(val, retValue, ws);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_val, val, 0);
-        des_const_xmlChar_ptr_ptr(n_retValue, retValue, 1);
-        des_xmlSchemaWhitespaceValueType(n_ws, ws, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetCanonValueWhtsp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_val);
-            printf(" %d", n_retValue);
-            printf(" %d", n_ws);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetFacetValueAsULong(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    unsigned long ret_val;
-    xmlSchemaFacetPtr facet; /* an schemas type facet */
-    int n_facet;
-
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-        mem_base = xmlMemBlocks();
-        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
-
-        ret_val = xmlSchemaGetFacetValueAsULong(facet);
-        desret_unsigned_long(ret_val);
-        call_tests++;
-        des_xmlSchemaFacetPtr(n_facet, facet, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetFacetValueAsULong",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_facet);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetPredefinedType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaTypePtr ret_val;
-    const xmlChar * name; /* the type name */
-    int n_name;
-    const xmlChar * ns; /* the URI of the namespace usually "http://www.w3.org/2001/XMLSchema" */
-    int n_ns;
-
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
-        mem_base = xmlMemBlocks();
-        name = gen_const_xmlChar_ptr(n_name, 0);
-        ns = gen_const_xmlChar_ptr(n_ns, 1);
-
-        ret_val = xmlSchemaGetPredefinedType(name, ns);
-        desret_xmlSchemaTypePtr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_name, name, 0);
-        des_const_xmlChar_ptr(n_ns, ns, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetPredefinedType",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_name);
-            printf(" %d", n_ns);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaGetValType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlSchemaValType ret_val;
-    xmlSchemaValPtr val; /* a schemas value */
-    int n_val;
-
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-        mem_base = xmlMemBlocks();
-        val = gen_xmlSchemaValPtr(n_val, 0);
-
-        ret_val = xmlSchemaGetValType(val);
-        desret_xmlSchemaValType(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_val, val, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaGetValType",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaInitTypes(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int ret_val;
-
-
-        ret_val = xmlSchemaInitTypes();
-        desret_int(ret_val);
-        call_tests++;
-        xmlResetLastError();
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaIsBuiltInTypeFacet(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr type; /* the built-in type */
-    int n_type;
-    int facetType; /* the facet type */
-    int n_facetType;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-    for (n_facetType = 0;n_facetType < gen_nb_int;n_facetType++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-        facetType = gen_int(n_facetType, 1);
-
-        ret_val = xmlSchemaIsBuiltInTypeFacet(type, facetType);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        des_int(n_facetType, facetType, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf(" %d", n_facetType);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewFacet(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewNOTATIONValue(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewQNameValue(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaNewStringValue(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-#ifdef LIBXML_SCHEMAS_ENABLED
-
-#define gen_nb_xmlSchemaValPtr_ptr 1
-#define gen_xmlSchemaValPtr_ptr(no, nr) NULL
-#define des_xmlSchemaValPtr_ptr(no, val, nr)
-#endif
-
-
-static int
-test_xmlSchemaValPredefTypeNode(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr type; /* the predefined type */
-    int n_type;
-    const xmlChar * value; /* the value to check */
-    int n_value;
-    xmlSchemaValPtr * val; /* the return computed value */
-    int n_val;
-    xmlNodePtr node; /* the node containing the value */
-    int n_node;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
-        node = gen_xmlNodePtr(n_node, 3);
-
-        ret_val = xmlSchemaValPredefTypeNode(type, value, val, node);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_xmlSchemaValPtr_ptr(n_val, val, 2);
-        des_xmlNodePtr(n_node, node, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNode",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf(" %d", n_node);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValPredefTypeNodeNoNorm(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr type; /* the predefined type */
-    int n_type;
-    const xmlChar * value; /* the value to check */
-    int n_value;
-    xmlSchemaValPtr * val; /* the return computed value */
-    int n_val;
-    xmlNodePtr node; /* the node containing the value */
-    int n_node;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
-    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
-        node = gen_xmlNodePtr(n_node, 3);
-
-        ret_val = xmlSchemaValPredefTypeNodeNoNorm(type, value, val, node);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_xmlSchemaValPtr_ptr(n_val, val, 2);
-        des_xmlNodePtr(n_node, node, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf(" %d", n_node);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateFacet(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr base; /* the base type */
-    int n_base;
-    xmlSchemaFacetPtr facet; /* the facet to check */
-    int n_facet;
-    const xmlChar * value; /* the lexical repr of the value to validate */
-    int n_value;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-
-    for (n_base = 0;n_base < gen_nb_xmlSchemaTypePtr;n_base++) {
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-        mem_base = xmlMemBlocks();
-        base = gen_xmlSchemaTypePtr(n_base, 0);
-        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
-        value = gen_const_xmlChar_ptr(n_value, 2);
-        val = gen_xmlSchemaValPtr(n_val, 3);
-
-        ret_val = xmlSchemaValidateFacet(base, facet, value, val);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_base, base, 0);
-        des_xmlSchemaFacetPtr(n_facet, facet, 1);
-        des_const_xmlChar_ptr(n_value, value, 2);
-        des_xmlSchemaValPtr(n_val, val, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateFacet",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_base);
-            printf(" %d", n_facet);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateFacetWhtsp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaFacetPtr facet; /* the facet to check */
-    int n_facet;
-    xmlSchemaWhitespaceValueType fws; /* the whitespace type of the facet's value */
-    int n_fws;
-    xmlSchemaValType valType; /* the built-in type of the value */
-    int n_valType;
-    const xmlChar * value; /* the lexical (or normalized for pattern) repr of the value to validate */
-    int n_value;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
-    int n_ws;
-
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_fws = 0;n_fws < gen_nb_xmlSchemaWhitespaceValueType;n_fws++) {
-    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
-        mem_base = xmlMemBlocks();
-        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
-        fws = gen_xmlSchemaWhitespaceValueType(n_fws, 1);
-        valType = gen_xmlSchemaValType(n_valType, 2);
-        value = gen_const_xmlChar_ptr(n_value, 3);
-        val = gen_xmlSchemaValPtr(n_val, 4);
-        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
-
-        ret_val = xmlSchemaValidateFacetWhtsp(facet, fws, valType, value, val, ws);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaFacetPtr(n_facet, facet, 0);
-        des_xmlSchemaWhitespaceValueType(n_fws, fws, 1);
-        des_xmlSchemaValType(n_valType, valType, 2);
-        des_const_xmlChar_ptr(n_value, value, 3);
-        des_xmlSchemaValPtr(n_val, val, 4);
-        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateFacetWhtsp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_facet);
-            printf(" %d", n_fws);
-            printf(" %d", n_valType);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf(" %d", n_ws);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateLengthFacet(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr type; /* the built-in type */
-    int n_type;
-    xmlSchemaFacetPtr facet; /* the facet to check */
-    int n_facet;
-    const xmlChar * value; /* the lexical repr. of the value to be validated */
-    int n_value;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-    unsigned long * length; /* the actual length of the value */
-    int n_length;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
-        value = gen_const_xmlChar_ptr(n_value, 2);
-        val = gen_xmlSchemaValPtr(n_val, 3);
-        length = gen_unsigned_long_ptr(n_length, 4);
-
-        ret_val = xmlSchemaValidateLengthFacet(type, facet, value, val, length);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        des_xmlSchemaFacetPtr(n_facet, facet, 1);
-        des_const_xmlChar_ptr(n_value, value, 2);
-        des_xmlSchemaValPtr(n_val, val, 3);
-        des_unsigned_long_ptr(n_length, length, 4);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacet",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf(" %d", n_facet);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf(" %d", n_length);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateLengthFacetWhtsp(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaFacetPtr facet; /* the facet to check */
-    int n_facet;
-    xmlSchemaValType valType; /* the built-in type */
-    int n_valType;
-    const xmlChar * value; /* the lexical repr. of the value to be validated */
-    int n_value;
-    xmlSchemaValPtr val; /* the precomputed value */
-    int n_val;
-    unsigned long * length; /* the actual length of the value */
-    int n_length;
-    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
-    int n_ws;
-
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
-    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
-        mem_base = xmlMemBlocks();
-        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
-        valType = gen_xmlSchemaValType(n_valType, 1);
-        value = gen_const_xmlChar_ptr(n_value, 2);
-        val = gen_xmlSchemaValPtr(n_val, 3);
-        length = gen_unsigned_long_ptr(n_length, 4);
-        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
-
-        ret_val = xmlSchemaValidateLengthFacetWhtsp(facet, valType, value, val, length, ws);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaFacetPtr(n_facet, facet, 0);
-        des_xmlSchemaValType(n_valType, valType, 1);
-        des_const_xmlChar_ptr(n_value, value, 2);
-        des_xmlSchemaValPtr(n_val, val, 3);
-        des_unsigned_long_ptr(n_length, length, 4);
-        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacetWhtsp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_facet);
-            printf(" %d", n_valType);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf(" %d", n_length);
-            printf(" %d", n_ws);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidateListSimpleTypeFacet(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaFacetPtr facet; /* the facet to check */
-    int n_facet;
-    const xmlChar * value; /* the lexical repr of the value to validate */
-    int n_value;
-    unsigned long actualLen; /* the number of list items */
-    int n_actualLen;
-    unsigned long * expectedLen; /* the resulting expected number of list items */
-    int n_expectedLen;
-
-    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_actualLen = 0;n_actualLen < gen_nb_unsigned_long;n_actualLen++) {
-    for (n_expectedLen = 0;n_expectedLen < gen_nb_unsigned_long_ptr;n_expectedLen++) {
-        mem_base = xmlMemBlocks();
-        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        actualLen = gen_unsigned_long(n_actualLen, 2);
-        expectedLen = gen_unsigned_long_ptr(n_expectedLen, 3);
-
-        ret_val = xmlSchemaValidateListSimpleTypeFacet(facet, value, actualLen, expectedLen);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaFacetPtr(n_facet, facet, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_unsigned_long(n_actualLen, actualLen, 2);
-        des_unsigned_long_ptr(n_expectedLen, expectedLen, 3);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_facet);
-            printf(" %d", n_value);
-            printf(" %d", n_actualLen);
-            printf(" %d", n_expectedLen);
-            printf("\n");
-        }
-    }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValidatePredefinedType(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaTypePtr type; /* the predefined type */
-    int n_type;
-    const xmlChar * value; /* the value to check */
-    int n_value;
-    xmlSchemaValPtr * val; /* the return computed value */
-    int n_val;
-
-    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
-        mem_base = xmlMemBlocks();
-        type = gen_xmlSchemaTypePtr(n_type, 0);
-        value = gen_const_xmlChar_ptr(n_value, 1);
-        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
-
-        ret_val = xmlSchemaValidatePredefinedType(type, value, val);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaTypePtr(n_type, type, 0);
-        des_const_xmlChar_ptr(n_value, value, 1);
-        des_xmlSchemaValPtr_ptr(n_val, val, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValidatePredefinedType",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_type);
-            printf(" %d", n_value);
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValueAppend(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr prev; /* the value */
-    int n_prev;
-    xmlSchemaValPtr cur; /* the value to be appended */
-    int n_cur;
-
-    for (n_prev = 0;n_prev < gen_nb_xmlSchemaValPtr;n_prev++) {
-    for (n_cur = 0;n_cur < gen_nb_xmlSchemaValPtr;n_cur++) {
-        mem_base = xmlMemBlocks();
-        prev = gen_xmlSchemaValPtr(n_prev, 0);
-        cur = gen_xmlSchemaValPtr(n_cur, 1);
-
-        ret_val = xmlSchemaValueAppend(prev, cur);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_prev, prev, 0);
-        des_xmlSchemaValPtr(n_cur, cur, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValueAppend",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_prev);
-            printf(" %d", n_cur);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValueGetAsBoolean(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    int ret_val;
-    xmlSchemaValPtr val; /* the value */
-    int n_val;
-
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-        mem_base = xmlMemBlocks();
-        val = gen_xmlSchemaValPtr(n_val, 0);
-
-        ret_val = xmlSchemaValueGetAsBoolean(val);
-        desret_int(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_val, val, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValueGetAsBoolean",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValueGetAsString(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    const xmlChar * ret_val;
-    xmlSchemaValPtr val; /* the value */
-    int n_val;
-
-    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
-        mem_base = xmlMemBlocks();
-        val = gen_xmlSchemaValPtr(n_val, 0);
-
-        ret_val = xmlSchemaValueGetAsString(val);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_xmlSchemaValPtr(n_val, val, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaValueGetAsString",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaValueGetNext(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlSchemaWhiteSpaceReplace(void) {
-    int test_ret = 0;
-
-#if defined(LIBXML_SCHEMAS_ENABLED)
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * value; /* a value */
-    int n_value;
-
-    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
-        mem_base = xmlMemBlocks();
-        value = gen_const_xmlChar_ptr(n_value, 0);
-
-        ret_val = xmlSchemaWhiteSpaceReplace(value);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_value, value, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlSchemaWhiteSpaceReplace",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_value);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
-
-    return(test_ret);
-}
-
-static int
-test_xmlschemastypes(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlschemastypes : 26 of 34 functions ...\n");
-    test_ret += test_xmlSchemaCheckFacet();
-    test_ret += test_xmlSchemaCleanupTypes();
-    test_ret += test_xmlSchemaCollapseString();
-    test_ret += test_xmlSchemaCompareValues();
-    test_ret += test_xmlSchemaCompareValuesWhtsp();
-    test_ret += test_xmlSchemaCopyValue();
-    test_ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
-    test_ret += test_xmlSchemaGetBuiltInType();
-    test_ret += test_xmlSchemaGetCanonValue();
-    test_ret += test_xmlSchemaGetCanonValueWhtsp();
-    test_ret += test_xmlSchemaGetFacetValueAsULong();
-    test_ret += test_xmlSchemaGetPredefinedType();
-    test_ret += test_xmlSchemaGetValType();
-    test_ret += test_xmlSchemaInitTypes();
-    test_ret += test_xmlSchemaIsBuiltInTypeFacet();
-    test_ret += test_xmlSchemaNewFacet();
-    test_ret += test_xmlSchemaNewNOTATIONValue();
-    test_ret += test_xmlSchemaNewQNameValue();
-    test_ret += test_xmlSchemaNewStringValue();
-    test_ret += test_xmlSchemaValPredefTypeNode();
-    test_ret += test_xmlSchemaValPredefTypeNodeNoNorm();
-    test_ret += test_xmlSchemaValidateFacet();
-    test_ret += test_xmlSchemaValidateFacetWhtsp();
-    test_ret += test_xmlSchemaValidateLengthFacet();
-    test_ret += test_xmlSchemaValidateLengthFacetWhtsp();
-    test_ret += test_xmlSchemaValidateListSimpleTypeFacet();
-    test_ret += test_xmlSchemaValidatePredefinedType();
-    test_ret += test_xmlSchemaValueAppend();
-    test_ret += test_xmlSchemaValueGetAsBoolean();
-    test_ret += test_xmlSchemaValueGetAsString();
-    test_ret += test_xmlSchemaValueGetNext();
-    test_ret += test_xmlSchemaWhiteSpaceReplace();
-
-    if (test_ret != 0)
-	printf("Module xmlschemastypes: %d errors\n", test_ret);
-    return(test_ret);
-}
-
-static int
-test_xmlCharStrdup(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const char * cur; /* the input char * */
-    int n_cur;
-
-    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
-        mem_base = xmlMemBlocks();
-        cur = gen_const_char_ptr(n_cur, 0);
-
-        ret_val = xmlCharStrdup(cur);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_cur, cur, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharStrdup",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_cur);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCharStrndup(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const char * cur; /* the input char * */
-    int n_cur;
-    int len; /* the len of @cur */
-    int n_len;
-
-    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        cur = gen_const_char_ptr(n_cur, 0);
-        len = gen_int(n_len, 1);
-        if ((cur != NULL) &&
-            (len > xmlStrlen(BAD_CAST cur)))
-            len = 0;
-
-        ret_val = xmlCharStrndup(cur, len);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_char_ptr(n_cur, cur, 0);
-        des_int(n_len, len, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCharStrndup",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_cur);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlCheckUTF8(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const unsigned char * utf; /* Pointer to putative UTF-8 encoded string. */
-    int n_utf;
-
-    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
-        mem_base = xmlMemBlocks();
-        utf = gen_const_unsigned_char_ptr(n_utf, 0);
-
-        ret_val = xmlCheckUTF8(utf);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_unsigned_char_ptr(n_utf, utf, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlCheckUTF8",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_utf);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlGetUTF8Char(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const unsigned char * utf; /* a sequence of UTF-8 encoded bytes */
-    int n_utf;
-    int * len; /* a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence. */
-    int n_len;
-
-    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
-    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
-        mem_base = xmlMemBlocks();
-        utf = gen_const_unsigned_char_ptr(n_utf, 0);
-        len = gen_int_ptr(n_len, 1);
-
-        ret_val = xmlGetUTF8Char(utf, len);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_unsigned_char_ptr(n_utf, utf, 0);
-        des_int_ptr(n_len, len, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlGetUTF8Char",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrEqual(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str1; /* the first xmlChar * */
-    int n_str1;
-    const xmlChar * str2; /* the second xmlChar * */
-    int n_str2;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-
-        ret_val = xmlStrEqual(str1, str2);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrEqual",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrPrintf(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrQEqual(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * pref; /* the prefix of the QName */
-    int n_pref;
-    const xmlChar * name; /* the localname of the QName */
-    int n_name;
-    const xmlChar * str; /* the second xmlChar * */
-    int n_str;
-
-    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
-    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-        mem_base = xmlMemBlocks();
-        pref = gen_const_xmlChar_ptr(n_pref, 0);
-        name = gen_const_xmlChar_ptr(n_name, 1);
-        str = gen_const_xmlChar_ptr(n_str, 2);
-
-        ret_val = xmlStrQEqual(pref, name, str);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_pref, pref, 0);
-        des_const_xmlChar_ptr(n_name, name, 1);
-        des_const_xmlChar_ptr(n_str, str, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrQEqual",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_pref);
-            printf(" %d", n_name);
-            printf(" %d", n_str);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrVPrintf(void) {
-    int test_ret = 0;
-
-
-    /* missing type support */
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrcasecmp(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str1; /* the first xmlChar * */
-    int n_str1;
-    const xmlChar * str2; /* the second xmlChar * */
-    int n_str2;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-
-        ret_val = xmlStrcasecmp(str1, str2);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrcasecmp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrcasestr(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    const xmlChar * ret_val;
-    const xmlChar * str; /* the xmlChar * array (haystack) */
-    int n_str;
-    const xmlChar * val; /* the xmlChar to search (needle) */
-    int n_val;
-
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
-        mem_base = xmlMemBlocks();
-        str = gen_const_xmlChar_ptr(n_str, 0);
-        val = gen_const_xmlChar_ptr(n_val, 1);
-
-        ret_val = xmlStrcasestr(str, val);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str, str, 0);
-        des_const_xmlChar_ptr(n_val, val, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrcasestr",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str);
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrchr(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    const xmlChar * ret_val;
-    const xmlChar * str; /* the xmlChar * array */
-    int n_str;
-    xmlChar val; /* the xmlChar to search */
-    int n_val;
-
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-    for (n_val = 0;n_val < gen_nb_xmlChar;n_val++) {
-        mem_base = xmlMemBlocks();
-        str = gen_const_xmlChar_ptr(n_str, 0);
-        val = gen_xmlChar(n_val, 1);
-
-        ret_val = xmlStrchr(str, val);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str, str, 0);
-        des_xmlChar(n_val, val, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrchr",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str);
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrcmp(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str1; /* the first xmlChar * */
-    int n_str1;
-    const xmlChar * str2; /* the second xmlChar * */
-    int n_str2;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-
-        ret_val = xmlStrcmp(str1, str2);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrcmp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrdup(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * cur; /* the input xmlChar * */
-    int n_cur;
-
-    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
-        mem_base = xmlMemBlocks();
-        cur = gen_const_xmlChar_ptr(n_cur, 0);
-
-        ret_val = xmlStrdup(cur);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_cur, cur, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrdup",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_cur);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrlen(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str; /* the xmlChar * array */
-    int n_str;
-
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-        mem_base = xmlMemBlocks();
-        str = gen_const_xmlChar_ptr(n_str, 0);
-
-        ret_val = xmlStrlen(str);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str, str, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrlen",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrncasecmp(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str1; /* the first xmlChar * */
-    int n_str1;
-    const xmlChar * str2; /* the second xmlChar * */
-    int n_str2;
-    int len; /* the max comparison length */
-    int n_len;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-        len = gen_int(n_len, 2);
-        if ((str2 != NULL) &&
-            (len > xmlStrlen(BAD_CAST str2)))
-            len = 0;
-
-        ret_val = xmlStrncasecmp(str1, str2, len);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        des_int(n_len, len, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrncasecmp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrncatNew(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * str1; /* first xmlChar string */
-    int n_str1;
-    const xmlChar * str2; /* second xmlChar string */
-    int n_str2;
-    int len; /* the len of @str2 or < 0 */
-    int n_len;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-        len = gen_int(n_len, 2);
-        if ((str2 != NULL) &&
-            (len > xmlStrlen(BAD_CAST str2)))
-            len = 0;
-
-        ret_val = xmlStrncatNew(str1, str2, len);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        des_int(n_len, len, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrncatNew",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrncmp(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * str1; /* the first xmlChar * */
-    int n_str1;
-    const xmlChar * str2; /* the second xmlChar * */
-    int n_str2;
-    int len; /* the max comparison length */
-    int n_len;
-
-    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
-    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        str1 = gen_const_xmlChar_ptr(n_str1, 0);
-        str2 = gen_const_xmlChar_ptr(n_str2, 1);
-        len = gen_int(n_len, 2);
-        if ((str2 != NULL) &&
-            (len > xmlStrlen(BAD_CAST str2)))
-            len = 0;
-
-        ret_val = xmlStrncmp(str1, str2, len);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str1, str1, 0);
-        des_const_xmlChar_ptr(n_str2, str2, 1);
-        des_int(n_len, len, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrncmp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str1);
-            printf(" %d", n_str2);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrndup(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * cur; /* the input xmlChar * */
-    int n_cur;
-    int len; /* the len of @cur */
-    int n_len;
-
-    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        cur = gen_const_xmlChar_ptr(n_cur, 0);
-        len = gen_int(n_len, 1);
-        if ((cur != NULL) &&
-            (len > xmlStrlen(BAD_CAST cur)))
-            len = 0;
-
-        ret_val = xmlStrndup(cur, len);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_cur, cur, 0);
-        des_int(n_len, len, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrndup",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_cur);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrstr(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    const xmlChar * ret_val;
-    const xmlChar * str; /* the xmlChar * array (haystack) */
-    int n_str;
-    const xmlChar * val; /* the xmlChar to search (needle) */
-    int n_val;
-
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
-        mem_base = xmlMemBlocks();
-        str = gen_const_xmlChar_ptr(n_str, 0);
-        val = gen_const_xmlChar_ptr(n_val, 1);
-
-        ret_val = xmlStrstr(str, val);
-        desret_const_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str, str, 0);
-        des_const_xmlChar_ptr(n_val, val, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrstr",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str);
-            printf(" %d", n_val);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlStrsub(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * str; /* the xmlChar * array (haystack) */
-    int n_str;
-    int start; /* the index of the first char (zero based) */
-    int n_start;
-    int len; /* the length of the substring */
-    int n_len;
-
-    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
-    for (n_start = 0;n_start < gen_nb_int;n_start++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
-        mem_base = xmlMemBlocks();
-        str = gen_const_xmlChar_ptr(n_str, 0);
-        start = gen_int(n_start, 1);
-        len = gen_int(n_len, 2);
-        if ((str != NULL) &&
-            (start > xmlStrlen(BAD_CAST str)))
-            start = 0;
-        if ((str != NULL) &&
-            (len > xmlStrlen(BAD_CAST str)))
-            len = 0;
-
-        ret_val = xmlStrsub(str, start, len);
-        desret_xmlChar_ptr(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_str, str, 0);
-        des_int(n_start, start, 1);
-        des_int(n_len, len, 2);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlStrsub",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_str);
-            printf(" %d", n_start);
-            printf(" %d", n_len);
-            printf("\n");
-        }
-    }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlUTF8Charcmp(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * utf1; /* pointer to first UTF8 char */
-    int n_utf1;
-    const xmlChar * utf2; /* pointer to second UTF8 char */
-    int n_utf2;
-
-    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
-    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
-        mem_base = xmlMemBlocks();
-        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
-        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);
-
-        ret_val = xmlUTF8Charcmp(utf1, utf2);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_utf1, utf1, 0);
-        des_const_xmlChar_ptr(n_utf2, utf2, 1);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Charcmp",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_utf1);
-            printf(" %d", n_utf2);
-            printf("\n");
-        }
-    }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlUTF8Size(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * utf; /* pointer to the UTF8 character */
-    int n_utf;
-
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-        mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-
-        ret_val = xmlUTF8Size(utf);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Size",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_utf);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlUTF8Strlen(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
-    int n_utf;
-
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-        mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-
-        ret_val = xmlUTF8Strlen(utf);
-        desret_int(ret_val);
-        call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strlen",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_utf);
-            printf("\n");
-        }
-    }
-    function_tests++;
-
-    return(test_ret);
-}
-
-
-static int
-test_xmlUTF8Strloc(void) {
-    int test_ret = 0;
-
-    int mem_base;
-    int ret_val;
-    const xmlChar * utf; /* the input UTF8 * */
-    int n_utf;
-    const xmlChar * utfchar; /* the UTF8 character to be found */
-    int n_utfchar;
+    int mem_base;
+    int ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUTF8Strloc(utf, utfchar);
+        ret_val = xmlTextReaderAttributeCount(reader);
         desret_int(ret_val);
         call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        des_const_xmlChar_ptr(n_utfchar, utfchar, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strloc",
+            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_utfchar);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
+#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUTF8Strndup(void) {
+test_xmlTextReaderBaseUri(void) {
     int test_ret = 0;
 
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     xmlChar * ret_val;
-    const xmlChar * utf; /* the input UTF8 * */
-    int n_utf;
-    int len; /* the len of @utf (in chars) */
-    int n_len;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-        len = gen_int(n_len, 1);
-        if ((utf != NULL) &&
-            (len > xmlStrlen(BAD_CAST utf)))
-            len = 0;
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUTF8Strndup(utf, len);
+        ret_val = xmlTextReaderBaseUri(reader);
         desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        des_int(n_len, len, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strndup",
+            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_len);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
+#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUTF8Strpos(void) {
+test_xmlTextReaderByteConsumed(void) {
     int test_ret = 0;
 
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    const xmlChar * ret_val;
-    const xmlChar * utf; /* the input UTF8 * */
-    int n_utf;
-    int pos; /* the position of the desired UTF8 char (in chars) */
-    int n_pos;
+    long ret_val;
+    xmlTextReaderPtr reader; /* an XML reader */
+    int n_reader;
 
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-    for (n_pos = 0;n_pos < gen_nb_int;n_pos++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-        pos = gen_int(n_pos, 1);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUTF8Strpos(utf, pos);
-        desret_const_xmlChar_ptr(ret_val);
+        ret_val = xmlTextReaderByteConsumed(reader);
+        desret_long(ret_val);
         call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        des_int(n_pos, pos, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strpos",
+            printf("Leak of %d blocks found in xmlTextReaderByteConsumed",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_pos);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
+#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUTF8Strsize(void) {
+test_xmlTextReaderClose(void) {
     int test_ret = 0;
 
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
-    int n_utf;
-    int len; /* the number of characters in the array */
-    int n_len;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-        len = gen_int(n_len, 1);
-        if ((utf != NULL) &&
-            (len > xmlStrlen(BAD_CAST utf)))
-            len = 0;
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUTF8Strsize(utf, len);
+        ret_val = xmlTextReaderClose(reader);
         desret_int(ret_val);
         call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        des_int(n_len, len, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strsize",
+            printf("Leak of %d blocks found in xmlTextReaderClose",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_len);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
+#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUTF8Strsub(void) {
+test_xmlTextReaderConstBaseUri(void) {
     int test_ret = 0;
 
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    xmlChar * ret_val;
-    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
-    int n_utf;
-    int start; /* relative pos of first char */
-    int n_start;
-    int len; /* total number to copy */
-    int n_len;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
-    for (n_start = 0;n_start < gen_nb_int;n_start++) {
-    for (n_len = 0;n_len < gen_nb_int;n_len++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        utf = gen_const_xmlChar_ptr(n_utf, 0);
-        start = gen_int(n_start, 1);
-        len = gen_int(n_len, 2);
-        if ((utf != NULL) &&
-            (start > xmlStrlen(BAD_CAST utf)))
-            start = 0;
-        if ((utf != NULL) &&
-            (len > xmlStrlen(BAD_CAST utf)))
-            len = 0;
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUTF8Strsub(utf, start, len);
-        desret_xmlChar_ptr(ret_val);
+        ret_val = xmlTextReaderConstBaseUri(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_const_xmlChar_ptr(n_utf, utf, 0);
-        des_int(n_start, start, 1);
-        des_int(n_len, len, 2);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUTF8Strsub",
+            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_utf);
-            printf(" %d", n_start);
-            printf(" %d", n_len);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
-    }
     function_tests++;
+#endif
 
     return(test_ret);
 }
 
-static int
-test_xmlstring(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlstring : 26 of 30 functions ...\n");
-    test_ret += test_xmlCharStrdup();
-    test_ret += test_xmlCharStrndup();
-    test_ret += test_xmlCheckUTF8();
-    test_ret += test_xmlGetUTF8Char();
-    test_ret += test_xmlStrEqual();
-    test_ret += test_xmlStrPrintf();
-    test_ret += test_xmlStrQEqual();
-    test_ret += test_xmlStrVPrintf();
-    test_ret += test_xmlStrcasecmp();
-    test_ret += test_xmlStrcasestr();
-    test_ret += test_xmlStrchr();
-    test_ret += test_xmlStrcmp();
-    test_ret += test_xmlStrdup();
-    test_ret += test_xmlStrlen();
-    test_ret += test_xmlStrncasecmp();
-    test_ret += test_xmlStrncatNew();
-    test_ret += test_xmlStrncmp();
-    test_ret += test_xmlStrndup();
-    test_ret += test_xmlStrstr();
-    test_ret += test_xmlStrsub();
-    test_ret += test_xmlUTF8Charcmp();
-    test_ret += test_xmlUTF8Size();
-    test_ret += test_xmlUTF8Strlen();
-    test_ret += test_xmlUTF8Strloc();
-    test_ret += test_xmlUTF8Strndup();
-    test_ret += test_xmlUTF8Strpos();
-    test_ret += test_xmlUTF8Strsize();
-    test_ret += test_xmlUTF8Strsub();
-
-    if (test_ret != 0)
-	printf("Module xmlstring: %d errors\n", test_ret);
-    return(test_ret);
-}
 
 static int
-test_xmlUCSIsAegeanNumbers(void) {
+test_xmlTextReaderConstEncoding(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsAegeanNumbers(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstEncoding(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsAegeanNumbers",
+            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -37991,29 +31020,29 @@ test_xmlUCSIsAegeanNumbers(void) {
 
 
 static int
-test_xmlUCSIsAlphabeticPresentationForms(void) {
+test_xmlTextReaderConstLocalName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsAlphabeticPresentationForms(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstLocalName(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsAlphabeticPresentationForms",
+            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38025,29 +31054,29 @@ test_xmlUCSIsAlphabeticPresentationForms(void) {
 
 
 static int
-test_xmlUCSIsArabic(void) {
+test_xmlTextReaderConstName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsArabic(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstName(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsArabic",
+            printf("Leak of %d blocks found in xmlTextReaderConstName",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38059,29 +31088,29 @@ test_xmlUCSIsArabic(void) {
 
 
 static int
-test_xmlUCSIsArabicPresentationFormsA(void) {
+test_xmlTextReaderConstNamespaceUri(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsArabicPresentationFormsA(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstNamespaceUri(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsA",
+            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38093,29 +31122,29 @@ test_xmlUCSIsArabicPresentationFormsA(void) {
 
 
 static int
-test_xmlUCSIsArabicPresentationFormsB(void) {
+test_xmlTextReaderConstPrefix(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsArabicPresentationFormsB(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstPrefix(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsB",
+            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38127,32 +31156,39 @@ test_xmlUCSIsArabicPresentationFormsB(void) {
 
 
 static int
-test_xmlUCSIsArmenian(void) {
+test_xmlTextReaderConstString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * str; /* the string to intern. */
+    int n_str;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        str = gen_const_xmlChar_ptr(n_str, 1);
 
-        ret_val = xmlUCSIsArmenian(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstString(reader, str);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_str, str, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsArmenian",
+            printf("Leak of %d blocks found in xmlTextReaderConstString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_str);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -38161,29 +31197,29 @@ test_xmlUCSIsArmenian(void) {
 
 
 static int
-test_xmlUCSIsArrows(void) {
+test_xmlTextReaderConstValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsArrows(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstValue(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsArrows",
+            printf("Leak of %d blocks found in xmlTextReaderConstValue",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38195,29 +31231,29 @@ test_xmlUCSIsArrows(void) {
 
 
 static int
-test_xmlUCSIsBasicLatin(void) {
+test_xmlTextReaderConstXmlLang(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBasicLatin(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstXmlLang(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBasicLatin",
+            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38229,29 +31265,29 @@ test_xmlUCSIsBasicLatin(void) {
 
 
 static int
-test_xmlUCSIsBengali(void) {
+test_xmlTextReaderConstXmlVersion(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBengali(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderConstXmlVersion(reader);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBengali",
+            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38263,39 +31299,32 @@ test_xmlUCSIsBengali(void) {
 
 
 static int
-test_xmlUCSIsBlock(void) {
+test_xmlTextReaderCurrentDoc(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-    const char * block; /* UCS block name */
-    int n_block;
+    xmlDocPtr ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-    for (n_block = 0;n_block < gen_nb_const_char_ptr;n_block++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-        block = gen_const_char_ptr(n_block, 1);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBlock(code, block);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderCurrentDoc(reader);
+        desret_xmlDocPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
-        des_const_char_ptr(n_block, block, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBlock",
+            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
-            printf(" %d", n_block);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
 #endif
 
@@ -38304,29 +31333,29 @@ test_xmlUCSIsBlock(void) {
 
 
 static int
-test_xmlUCSIsBlockElements(void) {
+test_xmlTextReaderCurrentNode(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlNodePtr ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBlockElements(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderCurrentNode(reader);
+        desret_xmlNodePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBlockElements",
+            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38338,29 +31367,29 @@ test_xmlUCSIsBlockElements(void) {
 
 
 static int
-test_xmlUCSIsBopomofo(void) {
+test_xmlTextReaderDepth(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBopomofo(code);
+        ret_val = xmlTextReaderDepth(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBopomofo",
+            printf("Leak of %d blocks found in xmlTextReaderDepth",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38372,29 +31401,29 @@ test_xmlUCSIsBopomofo(void) {
 
 
 static int
-test_xmlUCSIsBopomofoExtended(void) {
+test_xmlTextReaderExpand(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlNodePtr ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsBopomofoExtended(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderExpand(reader);
+        desret_xmlNodePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBopomofoExtended",
+            printf("Leak of %d blocks found in xmlTextReaderExpand",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38406,32 +31435,39 @@ test_xmlUCSIsBopomofoExtended(void) {
 
 
 static int
-test_xmlUCSIsBoxDrawing(void) {
+test_xmlTextReaderGetAttribute(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * name; /* the qualified name of the attribute. */
+    int n_name;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        name = gen_const_xmlChar_ptr(n_name, 1);
 
-        ret_val = xmlUCSIsBoxDrawing(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderGetAttribute(reader, name);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_name, name, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBoxDrawing",
+            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_name);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -38440,32 +31476,39 @@ test_xmlUCSIsBoxDrawing(void) {
 
 
 static int
-test_xmlUCSIsBraillePatterns(void) {
+test_xmlTextReaderGetAttributeNo(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    int no; /* the zero-based index of the attribute relative to the containing element */
+    int n_no;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_no = 0;n_no < gen_nb_int;n_no++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        no = gen_int(n_no, 1);
 
-        ret_val = xmlUCSIsBraillePatterns(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderGetAttributeNo(reader, no);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_int(n_no, no, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBraillePatterns",
+            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_no);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -38474,66 +31517,99 @@ test_xmlUCSIsBraillePatterns(void) {
 
 
 static int
-test_xmlUCSIsBuhid(void) {
+test_xmlTextReaderGetAttributeNs(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * localName; /* the local name of the attribute. */
+    int n_localName;
+    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
+    int n_namespaceURI;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
+    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        localName = gen_const_xmlChar_ptr(n_localName, 1);
+        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
 
-        ret_val = xmlUCSIsBuhid(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_localName, localName, 1);
+        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsBuhid",
+            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_localName);
+            printf(" %d", n_namespaceURI);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
     return(test_ret);
 }
 
+#ifdef LIBXML_READER_ENABLED
+
+#define gen_nb_xmlTextReaderErrorFunc_ptr 1
+#define gen_xmlTextReaderErrorFunc_ptr(no, nr) NULL
+#define des_xmlTextReaderErrorFunc_ptr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsByzantineMusicalSymbols(void) {
+test_xmlTextReaderGetErrorHandler(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    xmlTextReaderErrorFunc * f; /* the callback function or NULL is no callback has been registered */
+    int n_f;
+    void ** arg; /* a user argument */
+    int n_arg;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_f = 0;n_f < gen_nb_xmlTextReaderErrorFunc_ptr;n_f++) {
+    for (n_arg = 0;n_arg < gen_nb_void_ptr_ptr;n_arg++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1);
+        arg = gen_void_ptr_ptr(n_arg, 2);
 
-        ret_val = xmlUCSIsByzantineMusicalSymbols(code);
-        desret_int(ret_val);
+        xmlTextReaderGetErrorHandler(reader, f, arg);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_xmlTextReaderErrorFunc_ptr(n_f, f, 1);
+        des_void_ptr_ptr(n_arg, arg, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsByzantineMusicalSymbols",
+            printf("Leak of %d blocks found in xmlTextReaderGetErrorHandler",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_f);
+            printf(" %d", n_arg);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -38542,63 +31618,39 @@ test_xmlUCSIsByzantineMusicalSymbols(void) {
 
 
 static int
-test_xmlUCSIsCJKCompatibility(void) {
+test_xmlTextReaderGetLastError(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsCJKCompatibility(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibility",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsCJKCompatibilityForms(void) {
+test_xmlTextReaderGetParserColumnNumber(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the user data (XML reader context) */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKCompatibilityForms(code);
+        ret_val = xmlTextReaderGetParserColumnNumber(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityForms",
+            printf("Leak of %d blocks found in xmlTextReaderGetParserColumnNumber",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38610,29 +31662,29 @@ test_xmlUCSIsCJKCompatibilityForms(void) {
 
 
 static int
-test_xmlUCSIsCJKCompatibilityIdeographs(void) {
+test_xmlTextReaderGetParserLineNumber(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the user data (XML reader context) */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKCompatibilityIdeographs(code);
+        ret_val = xmlTextReaderGetParserLineNumber(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographs",
+            printf("Leak of %d blocks found in xmlTextReaderGetParserLineNumber",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38644,32 +31696,39 @@ test_xmlUCSIsCJKCompatibilityIdeographs(void) {
 
 
 static int
-test_xmlUCSIsCJKCompatibilityIdeographsSupplement(void) {
+test_xmlTextReaderGetParserProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    int prop; /* the xmlParserProperties to get */
+    int n_prop;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        prop = gen_int(n_prop, 1);
 
-        ret_val = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
+        ret_val = xmlTextReaderGetParserProp(reader, prop);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_int(n_prop, prop, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographsSupplement",
+            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_prop);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -38678,29 +31737,29 @@ test_xmlUCSIsCJKCompatibilityIdeographsSupplement(void) {
 
 
 static int
-test_xmlUCSIsCJKRadicalsSupplement(void) {
+test_xmlTextReaderGetRemainder(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlParserInputBufferPtr ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKRadicalsSupplement(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderGetRemainder(reader);
+        desret_xmlParserInputBufferPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKRadicalsSupplement",
+            printf("Leak of %d blocks found in xmlTextReaderGetRemainder",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38712,29 +31771,29 @@ test_xmlUCSIsCJKRadicalsSupplement(void) {
 
 
 static int
-test_xmlUCSIsCJKSymbolsandPunctuation(void) {
+test_xmlTextReaderHasAttributes(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKSymbolsandPunctuation(code);
+        ret_val = xmlTextReaderHasAttributes(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKSymbolsandPunctuation",
+            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38746,29 +31805,29 @@ test_xmlUCSIsCJKSymbolsandPunctuation(void) {
 
 
 static int
-test_xmlUCSIsCJKUnifiedIdeographs(void) {
+test_xmlTextReaderHasValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKUnifiedIdeographs(code);
+        ret_val = xmlTextReaderHasValue(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographs",
+            printf("Leak of %d blocks found in xmlTextReaderHasValue",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38780,29 +31839,29 @@ test_xmlUCSIsCJKUnifiedIdeographs(void) {
 
 
 static int
-test_xmlUCSIsCJKUnifiedIdeographsExtensionA(void) {
+test_xmlTextReaderIsDefault(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
+        ret_val = xmlTextReaderIsDefault(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionA",
+            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38814,29 +31873,29 @@ test_xmlUCSIsCJKUnifiedIdeographsExtensionA(void) {
 
 
 static int
-test_xmlUCSIsCJKUnifiedIdeographsExtensionB(void) {
+test_xmlTextReaderIsEmptyElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
+        ret_val = xmlTextReaderIsEmptyElement(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionB",
+            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38848,39 +31907,32 @@ test_xmlUCSIsCJKUnifiedIdeographsExtensionB(void) {
 
 
 static int
-test_xmlUCSIsCat(void) {
+test_xmlTextReaderIsNamespaceDecl(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-    const char * cat; /* UCS Category name */
-    int n_cat;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-    for (n_cat = 0;n_cat < gen_nb_const_char_ptr;n_cat++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-        cat = gen_const_char_ptr(n_cat, 1);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCat(code, cat);
+        ret_val = xmlTextReaderIsNamespaceDecl(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
-        des_const_char_ptr(n_cat, cat, 1);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCat",
+            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
-            printf(" %d", n_cat);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
-    }
     function_tests++;
 #endif
 
@@ -38889,29 +31941,29 @@ test_xmlUCSIsCat(void) {
 
 
 static int
-test_xmlUCSIsCatC(void) {
+test_xmlTextReaderIsValid(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatC(code);
+        ret_val = xmlTextReaderIsValid(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatC",
+            printf("Leak of %d blocks found in xmlTextReaderIsValid",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38923,29 +31975,29 @@ test_xmlUCSIsCatC(void) {
 
 
 static int
-test_xmlUCSIsCatCc(void) {
+test_xmlTextReaderLocalName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatCc(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderLocalName(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatCc",
+            printf("Leak of %d blocks found in xmlTextReaderLocalName",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -38955,31 +32007,38 @@ test_xmlUCSIsCatCc(void) {
     return(test_ret);
 }
 
+#ifdef LIBXML_READER_ENABLED
+
+#define gen_nb_xmlTextReaderLocatorPtr 1
+#define gen_xmlTextReaderLocatorPtr(no, nr) NULL
+#define des_xmlTextReaderLocatorPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsCatCf(void) {
+test_xmlTextReaderLocatorBaseURI(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
+    int n_locator;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
 
-        ret_val = xmlUCSIsCatCf(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderLocatorBaseURI(locator);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatCf",
+            printf("Leak of %d blocks found in xmlTextReaderLocatorBaseURI",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_locator);
             printf("\n");
         }
     }
@@ -38991,29 +32050,29 @@ test_xmlUCSIsCatCf(void) {
 
 
 static int
-test_xmlUCSIsCatCo(void) {
+test_xmlTextReaderLocatorLineNumber(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
+    int n_locator;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
 
-        ret_val = xmlUCSIsCatCo(code);
+        ret_val = xmlTextReaderLocatorLineNumber(locator);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatCo",
+            printf("Leak of %d blocks found in xmlTextReaderLocatorLineNumber",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_locator);
             printf("\n");
         }
     }
@@ -39025,32 +32084,39 @@ test_xmlUCSIsCatCo(void) {
 
 
 static int
-test_xmlUCSIsCatCs(void) {
+test_xmlTextReaderLookupNamespace(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * prefix; /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
+    int n_prefix;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
 
-        ret_val = xmlUCSIsCatCs(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderLookupNamespace(reader, prefix);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_prefix, prefix, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatCs",
+            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_prefix);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -39059,32 +32125,39 @@ test_xmlUCSIsCatCs(void) {
 
 
 static int
-test_xmlUCSIsCatL(void) {
+test_xmlTextReaderMoveToAttribute(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * name; /* the qualified name of the attribute. */
+    int n_name;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        name = gen_const_xmlChar_ptr(n_name, 1);
 
-        ret_val = xmlUCSIsCatL(code);
+        ret_val = xmlTextReaderMoveToAttribute(reader, name);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_name, name, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatL",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_name);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -39093,32 +32166,39 @@ test_xmlUCSIsCatL(void) {
 
 
 static int
-test_xmlUCSIsCatLl(void) {
+test_xmlTextReaderMoveToAttributeNo(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    int no; /* the zero-based index of the attribute relative to the containing element. */
+    int n_no;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_no = 0;n_no < gen_nb_int;n_no++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        no = gen_int(n_no, 1);
 
-        ret_val = xmlUCSIsCatLl(code);
+        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_int(n_no, no, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatLl",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_no);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -39127,32 +32207,46 @@ test_xmlUCSIsCatLl(void) {
 
 
 static int
-test_xmlUCSIsCatLm(void) {
+test_xmlTextReaderMoveToAttributeNs(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * localName; /* the local name of the attribute. */
+    int n_localName;
+    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
+    int n_namespaceURI;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
+    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        localName = gen_const_xmlChar_ptr(n_localName, 1);
+        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
 
-        ret_val = xmlUCSIsCatLm(code);
+        ret_val = xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_localName, localName, 1);
+        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatLm",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_localName);
+            printf(" %d", n_namespaceURI);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -39161,29 +32255,29 @@ test_xmlUCSIsCatLm(void) {
 
 
 static int
-test_xmlUCSIsCatLo(void) {
+test_xmlTextReaderMoveToElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatLo(code);
+        ret_val = xmlTextReaderMoveToElement(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatLo",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39195,29 +32289,29 @@ test_xmlUCSIsCatLo(void) {
 
 
 static int
-test_xmlUCSIsCatLt(void) {
+test_xmlTextReaderMoveToFirstAttribute(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatLt(code);
+        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatLt",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39229,29 +32323,29 @@ test_xmlUCSIsCatLt(void) {
 
 
 static int
-test_xmlUCSIsCatLu(void) {
+test_xmlTextReaderMoveToNextAttribute(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatLu(code);
+        ret_val = xmlTextReaderMoveToNextAttribute(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatLu",
+            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39263,29 +32357,29 @@ test_xmlUCSIsCatLu(void) {
 
 
 static int
-test_xmlUCSIsCatM(void) {
+test_xmlTextReaderName(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatM(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderName(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatM",
+            printf("Leak of %d blocks found in xmlTextReaderName",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39297,29 +32391,29 @@ test_xmlUCSIsCatM(void) {
 
 
 static int
-test_xmlUCSIsCatMc(void) {
+test_xmlTextReaderNamespaceUri(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatMc(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderNamespaceUri(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatMc",
+            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39331,29 +32425,29 @@ test_xmlUCSIsCatMc(void) {
 
 
 static int
-test_xmlUCSIsCatMe(void) {
+test_xmlTextReaderNext(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatMe(code);
+        ret_val = xmlTextReaderNext(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatMe",
+            printf("Leak of %d blocks found in xmlTextReaderNext",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39365,29 +32459,29 @@ test_xmlUCSIsCatMe(void) {
 
 
 static int
-test_xmlUCSIsCatMn(void) {
+test_xmlTextReaderNextSibling(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatMn(code);
+        ret_val = xmlTextReaderNextSibling(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatMn",
+            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39399,29 +32493,29 @@ test_xmlUCSIsCatMn(void) {
 
 
 static int
-test_xmlUCSIsCatN(void) {
+test_xmlTextReaderNodeType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatN(code);
+        ret_val = xmlTextReaderNodeType(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatN",
+            printf("Leak of %d blocks found in xmlTextReaderNodeType",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39433,29 +32527,29 @@ test_xmlUCSIsCatN(void) {
 
 
 static int
-test_xmlUCSIsCatNd(void) {
+test_xmlTextReaderNormalization(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatNd(code);
+        ret_val = xmlTextReaderNormalization(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatNd",
+            printf("Leak of %d blocks found in xmlTextReaderNormalization",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39467,29 +32561,29 @@ test_xmlUCSIsCatNd(void) {
 
 
 static int
-test_xmlUCSIsCatNl(void) {
+test_xmlTextReaderPrefix(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatNl(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderPrefix(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatNl",
+            printf("Leak of %d blocks found in xmlTextReaderPrefix",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39501,29 +32595,29 @@ test_xmlUCSIsCatNl(void) {
 
 
 static int
-test_xmlUCSIsCatNo(void) {
+test_xmlTextReaderPreserve(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlNodePtr ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatNo(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderPreserve(reader);
+        desret_xmlNodePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatNo",
+            printf("Leak of %d blocks found in xmlTextReaderPreserve",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39535,33 +32629,49 @@ test_xmlUCSIsCatNo(void) {
 
 
 static int
-test_xmlUCSIsCatP(void) {
+test_xmlTextReaderPreservePattern(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)
+#ifdef LIBXML_PATTERN_ENABLED
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const xmlChar * pattern; /* an XPath subset pattern */
+    int n_pattern;
+    const xmlChar ** namespaces; /* the prefix definitions, array of [URI, prefix] or NULL */
+    int n_namespaces;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_pattern = 0;n_pattern < gen_nb_const_xmlChar_ptr;n_pattern++) {
+    for (n_namespaces = 0;n_namespaces < gen_nb_const_xmlChar_ptr_ptr;n_namespaces++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        pattern = gen_const_xmlChar_ptr(n_pattern, 1);
+        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 2);
 
-        ret_val = xmlUCSIsCatP(code);
+        ret_val = xmlTextReaderPreservePattern(reader, pattern, namespaces);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_xmlChar_ptr(n_pattern, pattern, 1);
+        des_const_xmlChar_ptr_ptr(n_namespaces, namespaces, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatP",
+            printf("Leak of %d blocks found in xmlTextReaderPreservePattern",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_pattern);
+            printf(" %d", n_namespaces);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
+#endif
 #endif
 
     return(test_ret);
@@ -39569,29 +32679,29 @@ test_xmlUCSIsCatP(void) {
 
 
 static int
-test_xmlUCSIsCatPc(void) {
+test_xmlTextReaderQuoteChar(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatPc(code);
+        ret_val = xmlTextReaderQuoteChar(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPc",
+            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39603,29 +32713,29 @@ test_xmlUCSIsCatPc(void) {
 
 
 static int
-test_xmlUCSIsCatPd(void) {
+test_xmlTextReaderRead(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatPd(code);
+        ret_val = xmlTextReaderRead(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPd",
+            printf("Leak of %d blocks found in xmlTextReaderRead",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39637,29 +32747,29 @@ test_xmlUCSIsCatPd(void) {
 
 
 static int
-test_xmlUCSIsCatPe(void) {
+test_xmlTextReaderReadAttributeValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatPe(code);
+        ret_val = xmlTextReaderReadAttributeValue(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPe",
+            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39671,29 +32781,29 @@ test_xmlUCSIsCatPe(void) {
 
 
 static int
-test_xmlUCSIsCatPf(void) {
+test_xmlTextReaderReadState(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatPf(code);
+        ret_val = xmlTextReaderReadState(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPf",
+            printf("Leak of %d blocks found in xmlTextReaderReadState",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -39705,32 +32815,39 @@ test_xmlUCSIsCatPf(void) {
 
 
 static int
-test_xmlUCSIsCatPi(void) {
+test_xmlTextReaderRelaxNGSetSchema(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    xmlRelaxNGPtr schema; /* a precompiled RelaxNG schema */
+    int n_schema;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        schema = gen_xmlRelaxNGPtr(n_schema, 1);
 
-        ret_val = xmlUCSIsCatPi(code);
+        ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_xmlRelaxNGPtr(n_schema, schema, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPi",
+            printf("Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_schema);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -39739,32 +32856,39 @@ test_xmlUCSIsCatPi(void) {
 
 
 static int
-test_xmlUCSIsCatPo(void) {
+test_xmlTextReaderRelaxNGValidate(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const char * rng; /* the path to a RelaxNG schema or NULL */
+    int n_rng;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_rng = 0;n_rng < gen_nb_const_char_ptr;n_rng++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        rng = gen_const_char_ptr(n_rng, 1);
 
-        ret_val = xmlUCSIsCatPo(code);
+        ret_val = xmlTextReaderRelaxNGValidate(reader, rng);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_char_ptr(n_rng, rng, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPo",
+            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_rng);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -39773,32 +32897,46 @@ test_xmlUCSIsCatPo(void) {
 
 
 static int
-test_xmlUCSIsCatPs(void) {
+test_xmlTextReaderRelaxNGValidateCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG schema validation context or NULL */
+    int n_ctxt;
+    int options; /* options (not used yet) */
+    int n_options;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
+    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 1);
+        options = gen_parseroptions(n_options, 2);
 
-        ret_val = xmlUCSIsCatPs(code);
+        ret_val = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 1);
+        des_parseroptions(n_options, options, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatPs",
+            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidateCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_options);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -39807,31 +32945,28 @@ test_xmlUCSIsCatPs(void) {
 
 
 static int
-test_xmlUCSIsCatS(void) {
+test_xmlTextReaderSchemaValidate(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    const char * xsd; /* the path to a W3C XSD schema or NULL */
+    int n_xsd;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_xsd = 0;n_xsd < gen_nb_const_char_ptr;n_xsd++) {
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        xsd = gen_const_char_ptr(n_xsd, 1);
 
-        ret_val = xmlUCSIsCatS(code);
+        ret_val = xmlTextReaderSchemaValidate(reader, xsd);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_const_char_ptr(n_xsd, xsd, 1);
         xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatS",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
+    }
     }
     function_tests++;
 #endif
@@ -39841,32 +32976,46 @@ test_xmlUCSIsCatS(void) {
 
 
 static int
-test_xmlUCSIsCatSc(void) {
+test_xmlTextReaderSchemaValidateCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    xmlSchemaValidCtxtPtr ctxt; /* the XML Schema validation context or NULL */
+    int n_ctxt;
+    int options; /* options (not used yet) */
+    int n_options;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 1);
+        options = gen_parseroptions(n_options, 2);
 
-        ret_val = xmlUCSIsCatSc(code);
+        ret_val = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 1);
+        des_parseroptions(n_options, options, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatSc",
+            printf("Leak of %d blocks found in xmlTextReaderSchemaValidateCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_options);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -39875,66 +33024,66 @@ test_xmlUCSIsCatSc(void) {
 
 
 static int
-test_xmlUCSIsCatSk(void) {
+test_xmlTextReaderSetErrorHandler(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
 
-        ret_val = xmlUCSIsCatSk(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatSk",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+static int
+test_xmlTextReaderSetMaxAmplification(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsCatSm(void) {
+test_xmlTextReaderSetParserProp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    int prop; /* the xmlParserProperties to set */
+    int n_prop;
+    int value; /* usually 0 or 1 to (de)activate it */
+    int n_value;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
+    for (n_value = 0;n_value < gen_nb_int;n_value++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        prop = gen_int(n_prop, 1);
+        value = gen_int(n_value, 2);
 
-        ret_val = xmlUCSIsCatSm(code);
+        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_int(n_prop, prop, 1);
+        des_int(n_value, value, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatSm",
+            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_prop);
+            printf(" %d", n_value);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -39943,66 +33092,49 @@ test_xmlUCSIsCatSm(void) {
 
 
 static int
-test_xmlUCSIsCatSo(void) {
+test_xmlTextReaderSetResourceLoader(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsCatSo(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatSo",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsCatZ(void) {
+test_xmlTextReaderSetSchema(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
+    xmlSchemaPtr schema; /* a precompiled Schema schema */
+    int n_schema;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        schema = gen_xmlSchemaPtr(n_schema, 1);
 
-        ret_val = xmlUCSIsCatZ(code);
+        ret_val = xmlTextReaderSetSchema(reader, schema);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_xmlSchemaPtr(n_schema, schema, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatZ",
+            printf("Leak of %d blocks found in xmlTextReaderSetSchema",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_schema);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40011,32 +33143,69 @@ test_xmlUCSIsCatZ(void) {
 
 
 static int
-test_xmlUCSIsCatZl(void) {
+test_xmlTextReaderSetStructuredErrorHandler(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlTextReaderSetup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* an XML reader */
+    int n_reader;
+    xmlParserInputBufferPtr input; /* xmlParserInputBufferPtr used to feed the reader, will be destroyed with it. */
+    int n_input;
+    const char * URL; /* the base URL to use for the document */
+    int n_URL;
+    const char * encoding; /* the document encoding, or NULL */
+    int n_encoding;
+    int options; /* a combination of xmlParserOption */
+    int n_options;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
+    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
+    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
+    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
+    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
+        input = gen_xmlParserInputBufferPtr(n_input, 1);
+        URL = gen_filepath(n_URL, 2);
+        encoding = gen_const_char_ptr(n_encoding, 3);
+        options = gen_parseroptions(n_options, 4);
 
-        ret_val = xmlUCSIsCatZl(code);
+        ret_val = xmlTextReaderSetup(reader, input, URL, encoding, options);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
+        des_filepath(n_URL, URL, 2);
+        des_const_char_ptr(n_encoding, encoding, 3);
+        des_parseroptions(n_options, options, 4);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatZl",
+            printf("Leak of %d blocks found in xmlTextReaderSetup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
+            printf(" %d", n_input);
+            printf(" %d", n_URL);
+            printf(" %d", n_encoding);
+            printf(" %d", n_options);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40045,29 +33214,29 @@ test_xmlUCSIsCatZl(void) {
 
 
 static int
-test_xmlUCSIsCatZp(void) {
+test_xmlTextReaderStandalone(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatZp(code);
+        ret_val = xmlTextReaderStandalone(reader);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatZp",
+            printf("Leak of %d blocks found in xmlTextReaderStandalone",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -40079,29 +33248,29 @@ test_xmlUCSIsCatZp(void) {
 
 
 static int
-test_xmlUCSIsCatZs(void) {
+test_xmlTextReaderValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCatZs(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderValue(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCatZs",
+            printf("Leak of %d blocks found in xmlTextReaderValue",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -40113,29 +33282,29 @@ test_xmlUCSIsCatZs(void) {
 
 
 static int
-test_xmlUCSIsCherokee(void) {
+test_xmlTextReaderXmlLang(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_READER_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
+    int n_reader;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        reader = gen_xmlTextReaderPtr(n_reader, 0);
 
-        ret_val = xmlUCSIsCherokee(code);
-        desret_int(ret_val);
+        ret_val = xmlTextReaderXmlLang(reader);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlTextReaderPtr(n_reader, reader, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCherokee",
+            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_reader);
             printf("\n");
         }
     }
@@ -40145,34 +33314,167 @@ test_xmlUCSIsCherokee(void) {
     return(test_ret);
 }
 
+static int
+test_xmlreader(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing xmlreader : 76 of 89 functions ...\n");
+    test_ret += test_xmlNewTextReader();
+    test_ret += test_xmlNewTextReaderFilename();
+    test_ret += test_xmlReaderForDoc();
+    test_ret += test_xmlReaderForFile();
+    test_ret += test_xmlReaderForMemory();
+    test_ret += test_xmlReaderNewDoc();
+    test_ret += test_xmlReaderNewFile();
+    test_ret += test_xmlReaderNewMemory();
+    test_ret += test_xmlReaderNewWalker();
+    test_ret += test_xmlReaderWalker();
+    test_ret += test_xmlTextReaderAttributeCount();
+    test_ret += test_xmlTextReaderBaseUri();
+    test_ret += test_xmlTextReaderByteConsumed();
+    test_ret += test_xmlTextReaderClose();
+    test_ret += test_xmlTextReaderConstBaseUri();
+    test_ret += test_xmlTextReaderConstEncoding();
+    test_ret += test_xmlTextReaderConstLocalName();
+    test_ret += test_xmlTextReaderConstName();
+    test_ret += test_xmlTextReaderConstNamespaceUri();
+    test_ret += test_xmlTextReaderConstPrefix();
+    test_ret += test_xmlTextReaderConstString();
+    test_ret += test_xmlTextReaderConstValue();
+    test_ret += test_xmlTextReaderConstXmlLang();
+    test_ret += test_xmlTextReaderConstXmlVersion();
+    test_ret += test_xmlTextReaderCurrentDoc();
+    test_ret += test_xmlTextReaderCurrentNode();
+    test_ret += test_xmlTextReaderDepth();
+    test_ret += test_xmlTextReaderExpand();
+    test_ret += test_xmlTextReaderGetAttribute();
+    test_ret += test_xmlTextReaderGetAttributeNo();
+    test_ret += test_xmlTextReaderGetAttributeNs();
+    test_ret += test_xmlTextReaderGetErrorHandler();
+    test_ret += test_xmlTextReaderGetLastError();
+    test_ret += test_xmlTextReaderGetParserColumnNumber();
+    test_ret += test_xmlTextReaderGetParserLineNumber();
+    test_ret += test_xmlTextReaderGetParserProp();
+    test_ret += test_xmlTextReaderGetRemainder();
+    test_ret += test_xmlTextReaderHasAttributes();
+    test_ret += test_xmlTextReaderHasValue();
+    test_ret += test_xmlTextReaderIsDefault();
+    test_ret += test_xmlTextReaderIsEmptyElement();
+    test_ret += test_xmlTextReaderIsNamespaceDecl();
+    test_ret += test_xmlTextReaderIsValid();
+    test_ret += test_xmlTextReaderLocalName();
+    test_ret += test_xmlTextReaderLocatorBaseURI();
+    test_ret += test_xmlTextReaderLocatorLineNumber();
+    test_ret += test_xmlTextReaderLookupNamespace();
+    test_ret += test_xmlTextReaderMoveToAttribute();
+    test_ret += test_xmlTextReaderMoveToAttributeNo();
+    test_ret += test_xmlTextReaderMoveToAttributeNs();
+    test_ret += test_xmlTextReaderMoveToElement();
+    test_ret += test_xmlTextReaderMoveToFirstAttribute();
+    test_ret += test_xmlTextReaderMoveToNextAttribute();
+    test_ret += test_xmlTextReaderName();
+    test_ret += test_xmlTextReaderNamespaceUri();
+    test_ret += test_xmlTextReaderNext();
+    test_ret += test_xmlTextReaderNextSibling();
+    test_ret += test_xmlTextReaderNodeType();
+    test_ret += test_xmlTextReaderNormalization();
+    test_ret += test_xmlTextReaderPrefix();
+    test_ret += test_xmlTextReaderPreserve();
+    test_ret += test_xmlTextReaderPreservePattern();
+    test_ret += test_xmlTextReaderQuoteChar();
+    test_ret += test_xmlTextReaderRead();
+    test_ret += test_xmlTextReaderReadAttributeValue();
+    test_ret += test_xmlTextReaderReadState();
+    test_ret += test_xmlTextReaderRelaxNGSetSchema();
+    test_ret += test_xmlTextReaderRelaxNGValidate();
+    test_ret += test_xmlTextReaderRelaxNGValidateCtxt();
+    test_ret += test_xmlTextReaderSchemaValidate();
+    test_ret += test_xmlTextReaderSchemaValidateCtxt();
+    test_ret += test_xmlTextReaderSetErrorHandler();
+    test_ret += test_xmlTextReaderSetMaxAmplification();
+    test_ret += test_xmlTextReaderSetParserProp();
+    test_ret += test_xmlTextReaderSetResourceLoader();
+    test_ret += test_xmlTextReaderSetSchema();
+    test_ret += test_xmlTextReaderSetStructuredErrorHandler();
+    test_ret += test_xmlTextReaderSetup();
+    test_ret += test_xmlTextReaderStandalone();
+    test_ret += test_xmlTextReaderValue();
+    test_ret += test_xmlTextReaderXmlLang();
+
+    if (test_ret != 0)
+	printf("Module xmlreader: %d errors\n", test_ret);
+    return(test_ret);
+}
+#ifdef LIBXML_REGEXP_ENABLED
+
+#define gen_nb_xmlRegExecCtxtPtr 1
+#define gen_xmlRegExecCtxtPtr(no, nr) NULL
+#define des_xmlRegExecCtxtPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsCombiningDiacriticalMarks(void) {
+test_xmlRegExecErrInfo(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegExecCtxtPtr exec; /* a regexp execution context generating an error */
+    int n_exec;
+    const xmlChar ** string; /* return value for the error string */
+    int n_string;
+    int * nbval; /* pointer to the number of accepted values IN/OUT */
+    int n_nbval;
+    int * nbneg; /* return number of negative transitions */
+    int n_nbneg;
+    xmlChar ** values; /* pointer to the array of acceptable values */
+    int n_values;
+    int * terminal; /* return value if this was a terminal state */
+    int n_terminal;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
+    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr_ptr;n_string++) {
+    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
+    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
+    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
+    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
+        string = gen_const_xmlChar_ptr_ptr(n_string, 1);
+        nbval = gen_int_ptr(n_nbval, 2);
+        nbneg = gen_int_ptr(n_nbneg, 3);
+        values = gen_xmlChar_ptr_ptr(n_values, 4);
+        terminal = gen_int_ptr(n_terminal, 5);
 
-        ret_val = xmlUCSIsCombiningDiacriticalMarks(code);
+        ret_val = xmlRegExecErrInfo(exec, string, nbval, nbneg, values, terminal);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
+        des_const_xmlChar_ptr_ptr(n_string, string, 1);
+        des_int_ptr(n_nbval, nbval, 2);
+        des_int_ptr(n_nbneg, nbneg, 3);
+        des_xmlChar_ptr_ptr(n_values, values, 4);
+        des_int_ptr(n_terminal, terminal, 5);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarks",
+            printf("Leak of %d blocks found in xmlRegExecErrInfo",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_exec);
+            printf(" %d", n_string);
+            printf(" %d", n_nbval);
+            printf(" %d", n_nbneg);
+            printf(" %d", n_values);
+            printf(" %d", n_terminal);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40181,32 +33483,60 @@ test_xmlUCSIsCombiningDiacriticalMarks(void) {
 
 
 static int
-test_xmlUCSIsCombiningDiacriticalMarksforSymbols(void) {
+test_xmlRegExecNextValues(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegExecCtxtPtr exec; /* a regexp execution context */
+    int n_exec;
+    int * nbval; /* pointer to the number of accepted values IN/OUT */
+    int n_nbval;
+    int * nbneg; /* return number of negative transitions */
+    int n_nbneg;
+    xmlChar ** values; /* pointer to the array of acceptable values */
+    int n_values;
+    int * terminal; /* return value if this was a terminal state */
+    int n_terminal;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
+    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
+    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
+    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
+    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
+        nbval = gen_int_ptr(n_nbval, 1);
+        nbneg = gen_int_ptr(n_nbneg, 2);
+        values = gen_xmlChar_ptr_ptr(n_values, 3);
+        terminal = gen_int_ptr(n_terminal, 4);
 
-        ret_val = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
+        ret_val = xmlRegExecNextValues(exec, nbval, nbneg, values, terminal);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
+        des_int_ptr(n_nbval, nbval, 1);
+        des_int_ptr(n_nbneg, nbneg, 2);
+        des_xmlChar_ptr_ptr(n_values, values, 3);
+        des_int_ptr(n_terminal, terminal, 4);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarksforSymbols",
+            printf("Leak of %d blocks found in xmlRegExecNextValues",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_exec);
+            printf(" %d", n_nbval);
+            printf(" %d", n_nbneg);
+            printf(" %d", n_values);
+            printf(" %d", n_terminal);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40215,32 +33545,46 @@ test_xmlUCSIsCombiningDiacriticalMarksforSymbols(void) {
 
 
 static int
-test_xmlUCSIsCombiningHalfMarks(void) {
+test_xmlRegExecPushString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
+    int n_exec;
+    const xmlChar * value; /* a string token input */
+    int n_value;
+    void * data; /* data associated to the token to reuse in callbacks */
+    int n_data;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        data = gen_userdata(n_data, 2);
 
-        ret_val = xmlUCSIsCombiningHalfMarks(code);
+        ret_val = xmlRegExecPushString(exec, value, data);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_userdata(n_data, data, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCombiningHalfMarks",
+            printf("Leak of %d blocks found in xmlRegExecPushString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_exec);
+            printf(" %d", n_value);
+            printf(" %d", n_data);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40249,32 +33593,53 @@ test_xmlUCSIsCombiningHalfMarks(void) {
 
 
 static int
-test_xmlUCSIsCombiningMarksforSymbols(void) {
+test_xmlRegExecPushString2(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
+    int n_exec;
+    const xmlChar * value; /* the first string token input */
+    int n_value;
+    const xmlChar * value2; /* the second string token input */
+    int n_value2;
+    void * data; /* data associated to the token to reuse in callbacks */
+    int n_data;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_value2 = 0;n_value2 < gen_nb_const_xmlChar_ptr;n_value2++) {
+    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        value2 = gen_const_xmlChar_ptr(n_value2, 2);
+        data = gen_userdata(n_data, 3);
 
-        ret_val = xmlUCSIsCombiningMarksforSymbols(code);
+        ret_val = xmlRegExecPushString2(exec, value, value2, data);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_const_xmlChar_ptr(n_value2, value2, 2);
+        des_userdata(n_data, data, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCombiningMarksforSymbols",
+            printf("Leak of %d blocks found in xmlRegExecPushString2",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_exec);
+            printf(" %d", n_value);
+            printf(" %d", n_value2);
+            printf(" %d", n_data);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40283,66 +33648,66 @@ test_xmlUCSIsCombiningMarksforSymbols(void) {
 
 
 static int
-test_xmlUCSIsControlPictures(void) {
+test_xmlRegNewExecCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlRegexpCompile(void) {
+    int test_ret = 0;
 
-        ret_val = xmlUCSIsControlPictures(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsControlPictures",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
+#ifdef LIBXML_REGEXP_ENABLED
+
+#define gen_nb_xmlRegexpPtr 1
+#define gen_xmlRegexpPtr(no, nr) NULL
+#define des_xmlRegexpPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsCurrencySymbols(void) {
+test_xmlRegexpExec(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegexpPtr comp; /* the compiled regular expression */
+    int n_comp;
+    const xmlChar * content; /* the value to check against the regular expression */
+    int n_content;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
+    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        comp = gen_xmlRegexpPtr(n_comp, 0);
+        content = gen_const_xmlChar_ptr(n_content, 1);
 
-        ret_val = xmlUCSIsCurrencySymbols(code);
+        ret_val = xmlRegexpExec(comp, content);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegexpPtr(n_comp, comp, 0);
+        des_const_xmlChar_ptr(n_content, content, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCurrencySymbols",
+            printf("Leak of %d blocks found in xmlRegexpExec",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_comp);
+            printf(" %d", n_content);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40351,29 +33716,29 @@ test_xmlUCSIsCurrencySymbols(void) {
 
 
 static int
-test_xmlUCSIsCypriotSyllabary(void) {
+test_xmlRegexpIsDeterminist(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlRegexpPtr comp; /* the compiled regular expression */
+    int n_comp;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        comp = gen_xmlRegexpPtr(n_comp, 0);
 
-        ret_val = xmlUCSIsCypriotSyllabary(code);
+        ret_val = xmlRegexpIsDeterminist(comp);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlRegexpPtr(n_comp, comp, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCypriotSyllabary",
+            printf("Leak of %d blocks found in xmlRegexpIsDeterminist",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_comp);
             printf("\n");
         }
     }
@@ -40385,63 +33750,94 @@ test_xmlUCSIsCypriotSyllabary(void) {
 
 
 static int
-test_xmlUCSIsCyrillic(void) {
+test_xmlRegexpPrint(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_REGEXP_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    FILE * output; /* the file for the output debug */
+    int n_output;
+    xmlRegexpPtr regexp; /* the compiled regexp */
+    int n_regexp;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
+    for (n_regexp = 0;n_regexp < gen_nb_xmlRegexpPtr;n_regexp++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        output = gen_FILE_ptr(n_output, 0);
+        regexp = gen_xmlRegexpPtr(n_regexp, 1);
 
-        ret_val = xmlUCSIsCyrillic(code);
-        desret_int(ret_val);
+        xmlRegexpPrint(output, regexp);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_FILE_ptr(n_output, output, 0);
+        des_xmlRegexpPtr(n_regexp, regexp, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCyrillic",
+            printf("Leak of %d blocks found in xmlRegexpPrint",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_output);
+            printf(" %d", n_regexp);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
     return(test_ret);
 }
 
+static int
+test_xmlregexp(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing xmlregexp : 7 of 11 functions ...\n");
+    test_ret += test_xmlRegExecErrInfo();
+    test_ret += test_xmlRegExecNextValues();
+    test_ret += test_xmlRegExecPushString();
+    test_ret += test_xmlRegExecPushString2();
+    test_ret += test_xmlRegNewExecCtxt();
+    test_ret += test_xmlRegexpCompile();
+    test_ret += test_xmlRegexpExec();
+    test_ret += test_xmlRegexpIsDeterminist();
+    test_ret += test_xmlRegexpPrint();
+
+    if (test_ret != 0)
+	printf("Module xmlregexp: %d errors\n", test_ret);
+    return(test_ret);
+}
+#ifdef LIBXML_OUTPUT_ENABLED
+
+#define gen_nb_xmlSaveCtxtPtr 1
+#define gen_xmlSaveCtxtPtr(no, nr) NULL
+#define des_xmlSaveCtxtPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsCyrillicSupplement(void) {
+test_xmlSaveClose(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSaveCtxtPtr ctxt; /* a document saving context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsCyrillicSupplement(code);
+        ret_val = xmlSaveClose(ctxt);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsCyrillicSupplement",
+            printf("Leak of %d blocks found in xmlSaveClose",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -40453,32 +33849,39 @@ test_xmlUCSIsCyrillicSupplement(void) {
 
 
 static int
-test_xmlUCSIsDeseret(void) {
+test_xmlSaveDoc(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    long ret_val;
+    xmlSaveCtxtPtr ctxt; /* a document saving context */
+    int n_ctxt;
+    xmlDocPtr doc; /* a document */
+    int n_doc;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
+    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
+        doc = gen_xmlDocPtr(n_doc, 1);
 
-        ret_val = xmlUCSIsDeseret(code);
-        desret_int(ret_val);
+        ret_val = xmlSaveDoc(ctxt, doc);
+        desret_long(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlDocPtr(n_doc, doc, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsDeseret",
+            printf("Leak of %d blocks found in xmlSaveDoc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_doc);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40487,29 +33890,29 @@ test_xmlUCSIsDeseret(void) {
 
 
 static int
-test_xmlUCSIsDevanagari(void) {
+test_xmlSaveFinish(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSaveCtxtPtr ctxt; /* a document saving context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsDevanagari(code);
+        ret_val = xmlSaveFinish(ctxt);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsDevanagari",
+            printf("Leak of %d blocks found in xmlSaveFinish",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -40521,29 +33924,29 @@ test_xmlUCSIsDevanagari(void) {
 
 
 static int
-test_xmlUCSIsDingbats(void) {
+test_xmlSaveFlush(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSaveCtxtPtr ctxt; /* a document saving context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsDingbats(code);
+        ret_val = xmlSaveFlush(ctxt);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsDingbats",
+            printf("Leak of %d blocks found in xmlSaveFlush",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -40555,66 +33958,59 @@ test_xmlUCSIsDingbats(void) {
 
 
 static int
-test_xmlUCSIsEnclosedAlphanumerics(void) {
+test_xmlSaveSetAttrEscape(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
 
-        ret_val = xmlUCSIsEnclosedAlphanumerics(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsEnclosedAlphanumerics",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+static int
+test_xmlSaveSetEscape(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsEnclosedCJKLettersandMonths(void) {
+test_xmlSaveSetIndentString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSaveCtxtPtr ctxt; /* save context */
+    int n_ctxt;
+    const char * indent; /* indent string */
+    int n_indent;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
+    for (n_indent = 0;n_indent < gen_nb_const_char_ptr;n_indent++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
+        indent = gen_const_char_ptr(n_indent, 1);
 
-        ret_val = xmlUCSIsEnclosedCJKLettersandMonths(code);
+        ret_val = xmlSaveSetIndentString(ctxt, indent);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
+        des_const_char_ptr(n_indent, indent, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsEnclosedCJKLettersandMonths",
+            printf("Leak of %d blocks found in xmlSaveSetIndentString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_indent);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40623,66 +34019,69 @@ test_xmlUCSIsEnclosedCJKLettersandMonths(void) {
 
 
 static int
-test_xmlUCSIsEthiopic(void) {
+test_xmlSaveToBuffer(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlSaveToFd(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlSaveToFilename(void) {
+    int test_ret = 0;
 
-        ret_val = xmlUCSIsEthiopic(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsEthiopic",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsGeneralPunctuation(void) {
+test_xmlSaveTree(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    long ret_val;
+    xmlSaveCtxtPtr ctxt; /* a document saving context */
+    int n_ctxt;
+    xmlNodePtr cur; /* the top node of the subtree to save */
+    int n_cur;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
+    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
+        cur = gen_xmlNodePtr(n_cur, 1);
 
-        ret_val = xmlUCSIsGeneralPunctuation(code);
-        desret_int(ret_val);
+        ret_val = xmlSaveTree(ctxt, cur);
+        desret_long(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlNodePtr(n_cur, cur, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGeneralPunctuation",
+            printf("Leak of %d blocks found in xmlSaveTree",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_cur);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40691,29 +34090,29 @@ test_xmlUCSIsGeneralPunctuation(void) {
 
 
 static int
-test_xmlUCSIsGeometricShapes(void) {
+test_xmlThrDefIndentTreeOutput(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    int v; /*  */
+    int n_v;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_v = 0;n_v < gen_nb_int;n_v++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        v = gen_int(n_v, 0);
 
-        ret_val = xmlUCSIsGeometricShapes(code);
+        ret_val = xmlThrDefIndentTreeOutput(v);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_int(n_v, v, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGeometricShapes",
+            printf("Leak of %d blocks found in xmlThrDefIndentTreeOutput",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_v);
             printf("\n");
         }
     }
@@ -40725,29 +34124,29 @@ test_xmlUCSIsGeometricShapes(void) {
 
 
 static int
-test_xmlUCSIsGeorgian(void) {
+test_xmlThrDefSaveNoEmptyTags(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    int v; /*  */
+    int n_v;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_v = 0;n_v < gen_nb_int;n_v++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        v = gen_int(n_v, 0);
 
-        ret_val = xmlUCSIsGeorgian(code);
+        ret_val = xmlThrDefSaveNoEmptyTags(v);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_int(n_v, v, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGeorgian",
+            printf("Leak of %d blocks found in xmlThrDefSaveNoEmptyTags",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_v);
             printf("\n");
         }
     }
@@ -40759,29 +34158,29 @@ test_xmlUCSIsGeorgian(void) {
 
 
 static int
-test_xmlUCSIsGothic(void) {
+test_xmlThrDefTreeIndentString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const char * ret_val;
+    const char * v; /*  */
+    int n_v;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_v = 0;n_v < gen_nb_const_char_ptr;n_v++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        v = gen_const_char_ptr(n_v, 0);
 
-        ret_val = xmlUCSIsGothic(code);
-        desret_int(ret_val);
+        ret_val = xmlThrDefTreeIndentString(v);
+        desret_const_char_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_char_ptr(n_v, v, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGothic",
+            printf("Leak of %d blocks found in xmlThrDefTreeIndentString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_v);
             printf("\n");
         }
     }
@@ -40791,68 +34190,139 @@ test_xmlUCSIsGothic(void) {
     return(test_ret);
 }
 
+static int
+test_xmlsave(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing xmlsave : 9 of 15 functions ...\n");
+    test_ret += test_xmlSaveClose();
+    test_ret += test_xmlSaveDoc();
+    test_ret += test_xmlSaveFinish();
+    test_ret += test_xmlSaveFlush();
+    test_ret += test_xmlSaveSetAttrEscape();
+    test_ret += test_xmlSaveSetEscape();
+    test_ret += test_xmlSaveSetIndentString();
+    test_ret += test_xmlSaveToBuffer();
+    test_ret += test_xmlSaveToFd();
+    test_ret += test_xmlSaveToFilename();
+    test_ret += test_xmlSaveTree();
+    test_ret += test_xmlThrDefIndentTreeOutput();
+    test_ret += test_xmlThrDefSaveNoEmptyTags();
+    test_ret += test_xmlThrDefTreeIndentString();
+
+    if (test_ret != 0)
+	printf("Module xmlsave: %d errors\n", test_ret);
+    return(test_ret);
+}
 
 static int
-test_xmlUCSIsGreek(void) {
+test_xmlSchemaDump(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    FILE * output; /* the file output */
+    int n_output;
+    xmlSchemaPtr schema; /* a schema structure */
+    int n_schema;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
+    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        output = gen_FILE_ptr(n_output, 0);
+        schema = gen_xmlSchemaPtr(n_schema, 1);
 
-        ret_val = xmlUCSIsGreek(code);
-        desret_int(ret_val);
+        xmlSchemaDump(output, schema);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_FILE_ptr(n_output, output, 0);
+        des_xmlSchemaPtr(n_schema, schema, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGreek",
+            printf("Leak of %d blocks found in xmlSchemaDump",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_output);
+            printf(" %d", n_schema);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
     return(test_ret);
 }
 
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaParserCtxtPtr 1
+#define gen_xmlSchemaParserCtxtPtr(no, nr) NULL
+#define des_xmlSchemaParserCtxtPtr(no, val, nr)
+#endif
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaValidityErrorFunc_ptr 1
+#define gen_xmlSchemaValidityErrorFunc_ptr(no, nr) NULL
+#define des_xmlSchemaValidityErrorFunc_ptr(no, val, nr)
+#endif
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaValidityWarningFunc_ptr 1
+#define gen_xmlSchemaValidityWarningFunc_ptr(no, nr) NULL
+#define des_xmlSchemaValidityWarningFunc_ptr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsGreekExtended(void) {
+test_xmlSchemaGetParserErrors(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaParserCtxtPtr ctxt; /* a XMl-Schema parser context */
+    int n_ctxt;
+    xmlSchemaValidityErrorFunc * err; /* the error callback result */
+    int n_err;
+    xmlSchemaValidityWarningFunc * warn; /* the warning callback result */
+    int n_warn;
+    void ** ctx; /* contextual data for the callbacks result */
+    int n_ctx;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaParserCtxtPtr;n_ctxt++) {
+    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
+    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
+    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 0);
+        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
+        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
+        ctx = gen_void_ptr_ptr(n_ctx, 3);
 
-        ret_val = xmlUCSIsGreekExtended(code);
+        ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
+        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
+        des_void_ptr_ptr(n_ctx, ctx, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGreekExtended",
+            printf("Leak of %d blocks found in xmlSchemaGetParserErrors",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_err);
+            printf(" %d", n_warn);
+            printf(" %d", n_ctx);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40861,32 +34331,53 @@ test_xmlUCSIsGreekExtended(void) {
 
 
 static int
-test_xmlUCSIsGreekandCoptic(void) {
+test_xmlSchemaGetValidErrors(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a XML-Schema validation context */
+    int n_ctxt;
+    xmlSchemaValidityErrorFunc * err; /* the error function result */
+    int n_err;
+    xmlSchemaValidityWarningFunc * warn; /* the warning function result */
+    int n_warn;
+    void ** ctx; /* the functions context result */
+    int n_ctx;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
+    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
+    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
+        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
+        ctx = gen_void_ptr_ptr(n_ctx, 3);
 
-        ret_val = xmlUCSIsGreekandCoptic(code);
+        ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
+        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
+        des_void_ptr_ptr(n_ctx, ctx, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGreekandCoptic",
+            printf("Leak of %d blocks found in xmlSchemaGetValidErrors",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_err);
+            printf(" %d", n_warn);
+            printf(" %d", n_ctx);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -40895,29 +34386,29 @@ test_xmlUCSIsGreekandCoptic(void) {
 
 
 static int
-test_xmlUCSIsGujarati(void) {
+test_xmlSchemaIsValid(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* the schema validation context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsGujarati(code);
+        ret_val = xmlSchemaIsValid(ctxt);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGujarati",
+            printf("Leak of %d blocks found in xmlSchemaIsValid",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -40929,29 +34420,29 @@ test_xmlUCSIsGujarati(void) {
 
 
 static int
-test_xmlUCSIsGurmukhi(void) {
+test_xmlSchemaNewDocParserCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaParserCtxtPtr ret_val;
+    xmlDocPtr doc; /* a preparsed document tree */
+    int n_doc;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        doc = gen_xmlDocPtr(n_doc, 0);
 
-        ret_val = xmlUCSIsGurmukhi(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaNewDocParserCtxt(doc);
+        desret_xmlSchemaParserCtxtPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlDocPtr(n_doc, doc, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsGurmukhi",
+            printf("Leak of %d blocks found in xmlSchemaNewDocParserCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_doc);
             printf("\n");
         }
     }
@@ -40963,32 +34454,42 @@ test_xmlUCSIsGurmukhi(void) {
 
 
 static int
-test_xmlUCSIsHalfwidthandFullwidthForms(void) {
+test_xmlSchemaNewMemParserCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaParserCtxtPtr ret_val;
+    const char * buffer; /* a pointer to a char array containing the schemas */
+    int n_buffer;
+    int size; /* the size of the array */
+    int n_size;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
+    for (n_size = 0;n_size < gen_nb_int;n_size++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        buffer = gen_const_char_ptr(n_buffer, 0);
+        size = gen_int(n_size, 1);
+        if ((buffer != NULL) &&
+            (size > xmlStrlen(BAD_CAST buffer)))
+            size = 0;
 
-        ret_val = xmlUCSIsHalfwidthandFullwidthForms(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaNewMemParserCtxt(buffer, size);
+        desret_xmlSchemaParserCtxtPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_char_ptr(n_buffer, buffer, 0);
+        des_int(n_size, size, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHalfwidthandFullwidthForms",
+            printf("Leak of %d blocks found in xmlSchemaNewMemParserCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_buffer);
+            printf(" %d", n_size);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -40997,29 +34498,29 @@ test_xmlUCSIsHalfwidthandFullwidthForms(void) {
 
 
 static int
-test_xmlUCSIsHangulCompatibilityJamo(void) {
+test_xmlSchemaNewParserCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaParserCtxtPtr ret_val;
+    const char * URL; /* the location of the schema */
+    int n_URL;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_URL = 0;n_URL < gen_nb_const_char_ptr;n_URL++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        URL = gen_const_char_ptr(n_URL, 0);
 
-        ret_val = xmlUCSIsHangulCompatibilityJamo(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaNewParserCtxt(URL);
+        desret_xmlSchemaParserCtxtPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_char_ptr(n_URL, URL, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHangulCompatibilityJamo",
+            printf("Leak of %d blocks found in xmlSchemaNewParserCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_URL);
             printf("\n");
         }
     }
@@ -41031,97 +34532,66 @@ test_xmlUCSIsHangulCompatibilityJamo(void) {
 
 
 static int
-test_xmlUCSIsHangulJamo(void) {
+test_xmlSchemaNewValidCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsHangulJamo(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHangulJamo",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsHangulSyllables(void) {
+test_xmlSchemaParse(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
+
+
+static int
+test_xmlSchemaSAXPlug(void) {
+    int test_ret = 0;
 
-        ret_val = xmlUCSIsHangulSyllables(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHangulSyllables",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaSAXPlugPtr 1
+#define gen_xmlSchemaSAXPlugPtr(no, nr) NULL
+#define des_xmlSchemaSAXPlugPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsHanunoo(void) {
+test_xmlSchemaSAXUnplug(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaSAXPlugPtr plug; /* a data structure returned by xmlSchemaSAXPlug */
+    int n_plug;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_plug = 0;n_plug < gen_nb_xmlSchemaSAXPlugPtr;n_plug++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        plug = gen_xmlSchemaSAXPlugPtr(n_plug, 0);
 
-        ret_val = xmlUCSIsHanunoo(code);
+        ret_val = xmlSchemaSAXUnplug(plug);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaSAXPlugPtr(n_plug, plug, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHanunoo",
+            printf("Leak of %d blocks found in xmlSchemaSAXUnplug",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_plug);
             printf("\n");
         }
     }
@@ -41133,100 +34603,79 @@ test_xmlUCSIsHanunoo(void) {
 
 
 static int
-test_xmlUCSIsHebrew(void) {
+test_xmlSchemaSetParserErrors(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
 
-        ret_val = xmlUCSIsHebrew(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHebrew",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+static int
+test_xmlSchemaSetParserStructuredErrors(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsHighPrivateUseSurrogates(void) {
+test_xmlSchemaSetResourceLoader(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    /* missing type support */
+    return(test_ret);
+}
 
-        ret_val = xmlUCSIsHighPrivateUseSurrogates(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHighPrivateUseSurrogates",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+static int
+test_xmlSchemaSetValidErrors(void) {
+    int test_ret = 0;
+
+
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsHighSurrogates(void) {
+test_xmlSchemaSetValidOptions(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
+    int options; /* a combination of xmlSchemaValidOption */
+    int n_options;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_options = 0;n_options < gen_nb_int;n_options++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        options = gen_int(n_options, 1);
 
-        ret_val = xmlUCSIsHighSurrogates(code);
+        ret_val = xmlSchemaSetValidOptions(ctxt, options);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_int(n_options, options, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHighSurrogates",
+            printf("Leak of %d blocks found in xmlSchemaSetValidOptions",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_options);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41235,63 +34684,39 @@ test_xmlUCSIsHighSurrogates(void) {
 
 
 static int
-test_xmlUCSIsHiragana(void) {
+test_xmlSchemaSetValidStructuredErrors(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsHiragana(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsHiragana",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsIPAExtensions(void) {
+test_xmlSchemaValidCtxtGetOptions(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsIPAExtensions(code);
+        ret_val = xmlSchemaValidCtxtGetOptions(ctxt);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsIPAExtensions",
+            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetOptions",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -41303,29 +34728,29 @@ test_xmlUCSIsIPAExtensions(void) {
 
 
 static int
-test_xmlUCSIsIdeographicDescriptionCharacters(void) {
+test_xmlSchemaValidCtxtGetParserCtxt(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlParserCtxtPtr ret_val;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
 
-        ret_val = xmlUCSIsIdeographicDescriptionCharacters(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaValidCtxtGetParserCtxt(ctxt);
+        desret_xmlParserCtxtPtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsIdeographicDescriptionCharacters",
+            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetParserCtxt",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
             printf("\n");
         }
     }
@@ -41337,32 +34762,39 @@ test_xmlUCSIsIdeographicDescriptionCharacters(void) {
 
 
 static int
-test_xmlUCSIsKanbun(void) {
+test_xmlSchemaValidateDoc(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
+    xmlDocPtr doc; /* a parsed document tree */
+    int n_doc;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        doc = gen_xmlDocPtr(n_doc, 1);
 
-        ret_val = xmlUCSIsKanbun(code);
+        ret_val = xmlSchemaValidateDoc(ctxt, doc);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlDocPtr(n_doc, doc, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKanbun",
+            printf("Leak of %d blocks found in xmlSchemaValidateDoc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_doc);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41371,32 +34803,46 @@ test_xmlUCSIsKanbun(void) {
 
 
 static int
-test_xmlUCSIsKangxiRadicals(void) {
+test_xmlSchemaValidateFile(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
+    const char * filename; /* the URI of the instance */
+    int n_filename;
+    int options; /* a future set of options, currently unused */
+    int n_options;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
+    for (n_options = 0;n_options < gen_nb_int;n_options++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        filename = gen_filepath(n_filename, 1);
+        options = gen_int(n_options, 2);
 
-        ret_val = xmlUCSIsKangxiRadicals(code);
+        ret_val = xmlSchemaValidateFile(ctxt, filename, options);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_filepath(n_filename, filename, 1);
+        des_int(n_options, options, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKangxiRadicals",
+            printf("Leak of %d blocks found in xmlSchemaValidateFile",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_filename);
+            printf(" %d", n_options);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -41405,32 +34851,39 @@ test_xmlUCSIsKangxiRadicals(void) {
 
 
 static int
-test_xmlUCSIsKannada(void) {
+test_xmlSchemaValidateOneElement(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
+    xmlNodePtr elem; /* an element node */
+    int n_elem;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        elem = gen_xmlNodePtr(n_elem, 1);
 
-        ret_val = xmlUCSIsKannada(code);
+        ret_val = xmlSchemaValidateOneElement(ctxt, elem);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlNodePtr(n_elem, elem, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKannada",
+            printf("Leak of %d blocks found in xmlSchemaValidateOneElement",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_elem);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41439,32 +34892,37 @@ test_xmlUCSIsKannada(void) {
 
 
 static int
-test_xmlUCSIsKatakana(void) {
+test_xmlSchemaValidateSetFilename(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr vctxt; /* the schema validation context */
+    int n_vctxt;
+    const char * filename; /* the file name */
+    int n_filename;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_vctxt = 0;n_vctxt < gen_nb_xmlSchemaValidCtxtPtr;n_vctxt++) {
+    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        vctxt = gen_xmlSchemaValidCtxtPtr(n_vctxt, 0);
+        filename = gen_filepath(n_filename, 1);
 
-        ret_val = xmlUCSIsKatakana(code);
-        desret_int(ret_val);
+        xmlSchemaValidateSetFilename(vctxt, filename);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_vctxt, vctxt, 0);
+        des_filepath(n_filename, filename, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKatakana",
+            printf("Leak of %d blocks found in xmlSchemaValidateSetFilename",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_vctxt);
+            printf(" %d", n_filename);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41473,134 +34931,174 @@ test_xmlUCSIsKatakana(void) {
 
 
 static int
-test_xmlUCSIsKatakanaPhoneticExtensions(void) {
+test_xmlSchemaValidateSetLocator(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsKatakanaPhoneticExtensions(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKatakanaPhoneticExtensions",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsKhmer(void) {
+test_xmlSchemaValidateStream(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
+    int n_ctxt;
+    xmlParserInputBufferPtr input; /* the input to use for reading the data */
+    int n_input;
+    xmlCharEncoding enc; /* an optional encoding information */
+    int n_enc;
+    xmlSAXHandlerPtr sax; /* a SAX handler for the resulting events */
+    int n_sax;
+    void * user_data; /* the context to provide to the SAX handler. */
+    int n_user_data;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
+    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
+    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
+    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
+    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
+        input = gen_xmlParserInputBufferPtr(n_input, 1);
+        enc = gen_xmlCharEncoding(n_enc, 2);
+        sax = gen_xmlSAXHandlerPtr(n_sax, 3);
+        user_data = gen_userdata(n_user_data, 4);
 
-        ret_val = xmlUCSIsKhmer(code);
+        ret_val = xmlSchemaValidateStream(ctxt, input, enc, sax, user_data);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
+        des_xmlParserInputBufferPtr(n_input, input, 1);
+        des_xmlCharEncoding(n_enc, enc, 2);
+        des_xmlSAXHandlerPtr(n_sax, sax, 3);
+        des_userdata(n_user_data, user_data, 4);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKhmer",
+            printf("Leak of %d blocks found in xmlSchemaValidateStream",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_ctxt);
+            printf(" %d", n_input);
+            printf(" %d", n_enc);
+            printf(" %d", n_sax);
+            printf(" %d", n_user_data);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
     return(test_ret);
 }
 
-
 static int
-test_xmlUCSIsKhmerSymbols(void) {
+test_xmlschemas(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    if (quiet == 0) printf("Testing xmlschemas : 16 of 28 functions ...\n");
+    test_ret += test_xmlSchemaDump();
+    test_ret += test_xmlSchemaGetParserErrors();
+    test_ret += test_xmlSchemaGetValidErrors();
+    test_ret += test_xmlSchemaIsValid();
+    test_ret += test_xmlSchemaNewDocParserCtxt();
+    test_ret += test_xmlSchemaNewMemParserCtxt();
+    test_ret += test_xmlSchemaNewParserCtxt();
+    test_ret += test_xmlSchemaNewValidCtxt();
+    test_ret += test_xmlSchemaParse();
+    test_ret += test_xmlSchemaSAXPlug();
+    test_ret += test_xmlSchemaSAXUnplug();
+    test_ret += test_xmlSchemaSetParserErrors();
+    test_ret += test_xmlSchemaSetParserStructuredErrors();
+    test_ret += test_xmlSchemaSetResourceLoader();
+    test_ret += test_xmlSchemaSetValidErrors();
+    test_ret += test_xmlSchemaSetValidOptions();
+    test_ret += test_xmlSchemaSetValidStructuredErrors();
+    test_ret += test_xmlSchemaValidCtxtGetOptions();
+    test_ret += test_xmlSchemaValidCtxtGetParserCtxt();
+    test_ret += test_xmlSchemaValidateDoc();
+    test_ret += test_xmlSchemaValidateFile();
+    test_ret += test_xmlSchemaValidateOneElement();
+    test_ret += test_xmlSchemaValidateSetFilename();
+    test_ret += test_xmlSchemaValidateSetLocator();
+    test_ret += test_xmlSchemaValidateStream();
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    if (test_ret != 0)
+	printf("Module xmlschemas: %d errors\n", test_ret);
+    return(test_ret);
+}
+#ifdef LIBXML_SCHEMAS_ENABLED
 
-        ret_val = xmlUCSIsKhmerSymbols(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsKhmerSymbols",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
+#define gen_nb_xmlSchemaFacetPtr 1
+#define gen_xmlSchemaFacetPtr(no, nr) NULL
+#define des_xmlSchemaFacetPtr(no, val, nr)
 #endif
 
-    return(test_ret);
-}
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaTypePtr 1
+#define gen_xmlSchemaTypePtr(no, nr) NULL
+#define des_xmlSchemaTypePtr(no, val, nr)
+#endif
 
 
 static int
-test_xmlUCSIsLao(void) {
+test_xmlSchemaCheckFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaFacetPtr facet; /* the facet */
+    int n_facet;
+    xmlSchemaTypePtr typeDecl; /* the schema type definition */
+    int n_typeDecl;
+    xmlSchemaParserCtxtPtr pctxt; /* the schema parser context or NULL */
+    int n_pctxt;
+    const xmlChar * name; /* the optional name of the type */
+    int n_name;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_typeDecl = 0;n_typeDecl < gen_nb_xmlSchemaTypePtr;n_typeDecl++) {
+    for (n_pctxt = 0;n_pctxt < gen_nb_xmlSchemaParserCtxtPtr;n_pctxt++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
+        typeDecl = gen_xmlSchemaTypePtr(n_typeDecl, 1);
+        pctxt = gen_xmlSchemaParserCtxtPtr(n_pctxt, 2);
+        name = gen_const_xmlChar_ptr(n_name, 3);
 
-        ret_val = xmlUCSIsLao(code);
+        ret_val = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 0);
+        des_xmlSchemaTypePtr(n_typeDecl, typeDecl, 1);
+        des_xmlSchemaParserCtxtPtr(n_pctxt, pctxt, 2);
+        des_const_xmlChar_ptr(n_name, name, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLao",
+            printf("Leak of %d blocks found in xmlSchemaCheckFacet",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_facet);
+            printf(" %d", n_typeDecl);
+            printf(" %d", n_pctxt);
+            printf(" %d", n_name);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -41609,32 +35107,15 @@ test_xmlUCSIsLao(void) {
 
 
 static int
-test_xmlUCSIsLatin1Supplement(void) {
+test_xmlSchemaCleanupTypes(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+#if defined(LIBXML_SCHEMAS_ENABLED)
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
 
-        ret_val = xmlUCSIsLatin1Supplement(code);
-        desret_int(ret_val);
+        xmlSchemaCleanupTypes();
         call_tests++;
-        des_int(n_code, code, 0);
         xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLatin1Supplement",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
     function_tests++;
 #endif
 
@@ -41643,29 +35124,29 @@ test_xmlUCSIsLatin1Supplement(void) {
 
 
 static int
-test_xmlUCSIsLatinExtendedA(void) {
+test_xmlSchemaCollapseString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * value; /* a value */
+    int n_value;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        value = gen_const_xmlChar_ptr(n_value, 0);
 
-        ret_val = xmlUCSIsLatinExtendedA(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaCollapseString(value);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_value, value, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedA",
+            printf("Leak of %d blocks found in xmlSchemaCollapseString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_value);
             printf("\n");
         }
     }
@@ -41675,34 +35156,48 @@ test_xmlUCSIsLatinExtendedA(void) {
     return(test_ret);
 }
 
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaValPtr 1
+#define gen_xmlSchemaValPtr(no, nr) NULL
+#define des_xmlSchemaValPtr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsLatinExtendedAdditional(void) {
+test_xmlSchemaCompareValues(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr x; /* a first value */
+    int n_x;
+    xmlSchemaValPtr y; /* a second value */
+    int n_y;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
+    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        x = gen_xmlSchemaValPtr(n_x, 0);
+        y = gen_xmlSchemaValPtr(n_y, 1);
 
-        ret_val = xmlUCSIsLatinExtendedAdditional(code);
+        ret_val = xmlSchemaCompareValues(x, y);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_x, x, 0);
+        des_xmlSchemaValPtr(n_y, y, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedAdditional",
+            printf("Leak of %d blocks found in xmlSchemaCompareValues",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_x);
+            printf(" %d", n_y);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41711,32 +35206,53 @@ test_xmlUCSIsLatinExtendedAdditional(void) {
 
 
 static int
-test_xmlUCSIsLatinExtendedB(void) {
+test_xmlSchemaCompareValuesWhtsp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr x; /* a first value */
+    int n_x;
+    xmlSchemaWhitespaceValueType xws; /* the whitespace value of x */
+    int n_xws;
+    xmlSchemaValPtr y; /* a second value */
+    int n_y;
+    xmlSchemaWhitespaceValueType yws; /* the whitespace value of y */
+    int n_yws;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
+    for (n_xws = 0;n_xws < gen_nb_xmlSchemaWhitespaceValueType;n_xws++) {
+    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
+    for (n_yws = 0;n_yws < gen_nb_xmlSchemaWhitespaceValueType;n_yws++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        x = gen_xmlSchemaValPtr(n_x, 0);
+        xws = gen_xmlSchemaWhitespaceValueType(n_xws, 1);
+        y = gen_xmlSchemaValPtr(n_y, 2);
+        yws = gen_xmlSchemaWhitespaceValueType(n_yws, 3);
 
-        ret_val = xmlUCSIsLatinExtendedB(code);
+        ret_val = xmlSchemaCompareValuesWhtsp(x, xws, y, yws);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_x, x, 0);
+        des_xmlSchemaWhitespaceValueType(n_xws, xws, 1);
+        des_xmlSchemaValPtr(n_y, y, 2);
+        des_xmlSchemaWhitespaceValueType(n_yws, yws, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedB",
+            printf("Leak of %d blocks found in xmlSchemaCompareValuesWhtsp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_x);
+            printf(" %d", n_xws);
+            printf(" %d", n_y);
+            printf(" %d", n_yws);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -41745,63 +35261,39 @@ test_xmlUCSIsLatinExtendedB(void) {
 
 
 static int
-test_xmlUCSIsLetterlikeSymbols(void) {
+test_xmlSchemaCopyValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsLetterlikeSymbols(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLetterlikeSymbols",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsLimbu(void) {
+test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr ret_val;
+    xmlSchemaTypePtr type; /* the built-in simple type. */
+    int n_type;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
 
-        ret_val = xmlUCSIsLimbu(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaGetBuiltInListSimpleTypeItemType(type);
+        desret_xmlSchemaTypePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLimbu",
+            printf("Leak of %d blocks found in xmlSchemaGetBuiltInListSimpleTypeItemType",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
             printf("\n");
         }
     }
@@ -41813,31 +35305,22 @@ test_xmlUCSIsLimbu(void) {
 
 
 static int
-test_xmlUCSIsLinearBIdeograms(void) {
+test_xmlSchemaGetBuiltInType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+#if defined(LIBXML_SCHEMAS_ENABLED)
+    xmlSchemaTypePtr ret_val;
+    xmlSchemaValType type; /* the type of the built in type */
+    int n_type;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+    for (n_type = 0;n_type < gen_nb_xmlSchemaValType;n_type++) {
+        type = gen_xmlSchemaValType(n_type, 0);
 
-        ret_val = xmlUCSIsLinearBIdeograms(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaGetBuiltInType(type);
+        desret_xmlSchemaTypePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValType(n_type, type, 0);
         xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLinearBIdeograms",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
     }
     function_tests++;
 #endif
@@ -41847,32 +35330,39 @@ test_xmlUCSIsLinearBIdeograms(void) {
 
 
 static int
-test_xmlUCSIsLinearBSyllabary(void) {
+test_xmlSchemaGetCanonValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
+    const xmlChar ** retValue; /* the returned value */
+    int n_retValue;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
+    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        val = gen_xmlSchemaValPtr(n_val, 0);
+        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
 
-        ret_val = xmlUCSIsLinearBSyllabary(code);
+        ret_val = xmlSchemaGetCanonValue(val, retValue);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_val, val, 0);
+        des_const_xmlChar_ptr_ptr(n_retValue, retValue, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLinearBSyllabary",
+            printf("Leak of %d blocks found in xmlSchemaGetCanonValue",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_val);
+            printf(" %d", n_retValue);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41881,32 +35371,46 @@ test_xmlUCSIsLinearBSyllabary(void) {
 
 
 static int
-test_xmlUCSIsLowSurrogates(void) {
+test_xmlSchemaGetCanonValueWhtsp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
+    const xmlChar ** retValue; /* the returned value */
+    int n_retValue;
+    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
+    int n_ws;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
+    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
+    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        val = gen_xmlSchemaValPtr(n_val, 0);
+        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
+        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 2);
 
-        ret_val = xmlUCSIsLowSurrogates(code);
+        ret_val = xmlSchemaGetCanonValueWhtsp(val, retValue, ws);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_val, val, 0);
+        des_const_xmlChar_ptr_ptr(n_retValue, retValue, 1);
+        des_xmlSchemaWhitespaceValueType(n_ws, ws, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsLowSurrogates",
+            printf("Leak of %d blocks found in xmlSchemaGetCanonValueWhtsp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_val);
+            printf(" %d", n_retValue);
+            printf(" %d", n_ws);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -41915,29 +35419,29 @@ test_xmlUCSIsLowSurrogates(void) {
 
 
 static int
-test_xmlUCSIsMalayalam(void) {
+test_xmlSchemaGetFacetValueAsULong(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    unsigned long ret_val;
+    xmlSchemaFacetPtr facet; /* an schemas type facet */
+    int n_facet;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
 
-        ret_val = xmlUCSIsMalayalam(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaGetFacetValueAsULong(facet);
+        desret_unsigned_long(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMalayalam",
+            printf("Leak of %d blocks found in xmlSchemaGetFacetValueAsULong",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_facet);
             printf("\n");
         }
     }
@@ -41949,32 +35453,39 @@ test_xmlUCSIsMalayalam(void) {
 
 
 static int
-test_xmlUCSIsMathematicalAlphanumericSymbols(void) {
+test_xmlSchemaGetPredefinedType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr ret_val;
+    const xmlChar * name; /* the type name */
+    int n_name;
+    const xmlChar * ns; /* the URI of the namespace usually "http://www.w3.org/2001/XMLSchema" */
+    int n_ns;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
+    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        name = gen_const_xmlChar_ptr(n_name, 0);
+        ns = gen_const_xmlChar_ptr(n_ns, 1);
 
-        ret_val = xmlUCSIsMathematicalAlphanumericSymbols(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaGetPredefinedType(name, ns);
+        desret_xmlSchemaTypePtr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_name, name, 0);
+        des_const_xmlChar_ptr(n_ns, ns, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMathematicalAlphanumericSymbols",
+            printf("Leak of %d blocks found in xmlSchemaGetPredefinedType",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_name);
+            printf(" %d", n_ns);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -41983,29 +35494,29 @@ test_xmlUCSIsMathematicalAlphanumericSymbols(void) {
 
 
 static int
-test_xmlUCSIsMathematicalOperators(void) {
+test_xmlSchemaGetValType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValType ret_val;
+    xmlSchemaValPtr val; /* a schemas value */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        val = gen_xmlSchemaValPtr(n_val, 0);
 
-        ret_val = xmlUCSIsMathematicalOperators(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaGetValType(val);
+        desret_xmlSchemaValType(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_val, val, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMathematicalOperators",
+            printf("Leak of %d blocks found in xmlSchemaGetValType",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
@@ -42017,32 +35528,17 @@ test_xmlUCSIsMathematicalOperators(void) {
 
 
 static int
-test_xmlUCSIsMiscellaneousMathematicalSymbolsA(void) {
+test_xmlSchemaInitTypes(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
 
-        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
+        ret_val = xmlSchemaInitTypes();
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
         xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsA",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
     function_tests++;
 #endif
 
@@ -42051,32 +35547,39 @@ test_xmlUCSIsMiscellaneousMathematicalSymbolsA(void) {
 
 
 static int
-test_xmlUCSIsMiscellaneousMathematicalSymbolsB(void) {
+test_xmlSchemaIsBuiltInTypeFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr type; /* the built-in type */
+    int n_type;
+    int facetType; /* the facet type */
+    int n_facetType;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
+    for (n_facetType = 0;n_facetType < gen_nb_int;n_facetType++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
+        facetType = gen_int(n_facetType, 1);
 
-        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
+        ret_val = xmlSchemaIsBuiltInTypeFacet(type, facetType);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
+        des_int(n_facetType, facetType, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsB",
+            printf("Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
+            printf(" %d", n_facetType);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -42085,168 +35588,100 @@ test_xmlUCSIsMiscellaneousMathematicalSymbolsB(void) {
 
 
 static int
-test_xmlUCSIsMiscellaneousSymbols(void) {
+test_xmlSchemaNewFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsMiscellaneousSymbols(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbols",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsMiscellaneousSymbolsandArrows(void) {
+test_xmlSchemaNewNOTATIONValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsMiscellaneousSymbolsandArrows(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbolsandArrows",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsMiscellaneousTechnical(void) {
+test_xmlSchemaNewQNameValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsMiscellaneousTechnical(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousTechnical",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsMongolian(void) {
+test_xmlSchemaNewStringValue(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsMongolian(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMongolian",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#define gen_nb_xmlSchemaValPtr_ptr 1
+#define gen_xmlSchemaValPtr_ptr(no, nr) NULL
+#define des_xmlSchemaValPtr_ptr(no, val, nr)
+#endif
+
 
 static int
-test_xmlUCSIsMusicalSymbols(void) {
+test_xmlSchemaValPredefTypeNode(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr type; /* the predefined type */
+    int n_type;
+    const xmlChar * value; /* the value to check */
+    int n_value;
+    xmlSchemaValPtr * val; /* the return computed value */
+    int n_val;
+    xmlNodePtr node; /* the node containing the value */
+    int n_node;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
+    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
+        node = gen_xmlNodePtr(n_node, 3);
 
-        ret_val = xmlUCSIsMusicalSymbols(code);
+        ret_val = xmlSchemaValPredefTypeNode(type, value, val, node);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_xmlSchemaValPtr_ptr(n_val, val, 2);
+        des_xmlNodePtr(n_node, node, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMusicalSymbols",
+            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNode",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
+            printf(" %d", n_node);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42255,32 +35690,53 @@ test_xmlUCSIsMusicalSymbols(void) {
 
 
 static int
-test_xmlUCSIsMyanmar(void) {
+test_xmlSchemaValPredefTypeNodeNoNorm(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr type; /* the predefined type */
+    int n_type;
+    const xmlChar * value; /* the value to check */
+    int n_value;
+    xmlSchemaValPtr * val; /* the return computed value */
+    int n_val;
+    xmlNodePtr node; /* the node containing the value */
+    int n_node;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
+    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
+        node = gen_xmlNodePtr(n_node, 3);
 
-        ret_val = xmlUCSIsMyanmar(code);
+        ret_val = xmlSchemaValPredefTypeNodeNoNorm(type, value, val, node);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_xmlSchemaValPtr_ptr(n_val, val, 2);
+        des_xmlNodePtr(n_node, node, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsMyanmar",
+            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
+            printf(" %d", n_node);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42289,32 +35745,53 @@ test_xmlUCSIsMyanmar(void) {
 
 
 static int
-test_xmlUCSIsNumberForms(void) {
+test_xmlSchemaValidateFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr base; /* the base type */
+    int n_base;
+    xmlSchemaFacetPtr facet; /* the facet to check */
+    int n_facet;
+    const xmlChar * value; /* the lexical repr of the value to validate */
+    int n_value;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_base = 0;n_base < gen_nb_xmlSchemaTypePtr;n_base++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        base = gen_xmlSchemaTypePtr(n_base, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
+        value = gen_const_xmlChar_ptr(n_value, 2);
+        val = gen_xmlSchemaValPtr(n_val, 3);
 
-        ret_val = xmlUCSIsNumberForms(code);
+        ret_val = xmlSchemaValidateFacet(base, facet, value, val);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_base, base, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 1);
+        des_const_xmlChar_ptr(n_value, value, 2);
+        des_xmlSchemaValPtr(n_val, val, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsNumberForms",
+            printf("Leak of %d blocks found in xmlSchemaValidateFacet",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_base);
+            printf(" %d", n_facet);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42323,32 +35800,67 @@ test_xmlUCSIsNumberForms(void) {
 
 
 static int
-test_xmlUCSIsOgham(void) {
+test_xmlSchemaValidateFacetWhtsp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaFacetPtr facet; /* the facet to check */
+    int n_facet;
+    xmlSchemaWhitespaceValueType fws; /* the whitespace type of the facet's value */
+    int n_fws;
+    xmlSchemaValType valType; /* the built-in type of the value */
+    int n_valType;
+    const xmlChar * value; /* the lexical (or normalized for pattern) repr of the value to validate */
+    int n_value;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
+    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
+    int n_ws;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_fws = 0;n_fws < gen_nb_xmlSchemaWhitespaceValueType;n_fws++) {
+    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
+    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
+        fws = gen_xmlSchemaWhitespaceValueType(n_fws, 1);
+        valType = gen_xmlSchemaValType(n_valType, 2);
+        value = gen_const_xmlChar_ptr(n_value, 3);
+        val = gen_xmlSchemaValPtr(n_val, 4);
+        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
 
-        ret_val = xmlUCSIsOgham(code);
+        ret_val = xmlSchemaValidateFacetWhtsp(facet, fws, valType, value, val, ws);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 0);
+        des_xmlSchemaWhitespaceValueType(n_fws, fws, 1);
+        des_xmlSchemaValType(n_valType, valType, 2);
+        des_const_xmlChar_ptr(n_value, value, 3);
+        des_xmlSchemaValPtr(n_val, val, 4);
+        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsOgham",
+            printf("Leak of %d blocks found in xmlSchemaValidateFacetWhtsp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_facet);
+            printf(" %d", n_fws);
+            printf(" %d", n_valType);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
+            printf(" %d", n_ws);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42357,32 +35869,60 @@ test_xmlUCSIsOgham(void) {
 
 
 static int
-test_xmlUCSIsOldItalic(void) {
+test_xmlSchemaValidateLengthFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr type; /* the built-in type */
+    int n_type;
+    xmlSchemaFacetPtr facet; /* the facet to check */
+    int n_facet;
+    const xmlChar * value; /* the lexical repr. of the value to be validated */
+    int n_value;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
+    unsigned long * length; /* the actual length of the value */
+    int n_length;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
+    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
+        value = gen_const_xmlChar_ptr(n_value, 2);
+        val = gen_xmlSchemaValPtr(n_val, 3);
+        length = gen_unsigned_long_ptr(n_length, 4);
 
-        ret_val = xmlUCSIsOldItalic(code);
+        ret_val = xmlSchemaValidateLengthFacet(type, facet, value, val, length);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 1);
+        des_const_xmlChar_ptr(n_value, value, 2);
+        des_xmlSchemaValPtr(n_val, val, 3);
+        des_unsigned_long_ptr(n_length, length, 4);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsOldItalic",
+            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacet",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
+            printf(" %d", n_facet);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
+            printf(" %d", n_length);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42391,32 +35931,67 @@ test_xmlUCSIsOldItalic(void) {
 
 
 static int
-test_xmlUCSIsOpticalCharacterRecognition(void) {
+test_xmlSchemaValidateLengthFacetWhtsp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaFacetPtr facet; /* the facet to check */
+    int n_facet;
+    xmlSchemaValType valType; /* the built-in type */
+    int n_valType;
+    const xmlChar * value; /* the lexical repr. of the value to be validated */
+    int n_value;
+    xmlSchemaValPtr val; /* the precomputed value */
+    int n_val;
+    unsigned long * length; /* the actual length of the value */
+    int n_length;
+    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
+    int n_ws;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
+    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
+    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
+        valType = gen_xmlSchemaValType(n_valType, 1);
+        value = gen_const_xmlChar_ptr(n_value, 2);
+        val = gen_xmlSchemaValPtr(n_val, 3);
+        length = gen_unsigned_long_ptr(n_length, 4);
+        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
 
-        ret_val = xmlUCSIsOpticalCharacterRecognition(code);
+        ret_val = xmlSchemaValidateLengthFacetWhtsp(facet, valType, value, val, length, ws);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 0);
+        des_xmlSchemaValType(n_valType, valType, 1);
+        des_const_xmlChar_ptr(n_value, value, 2);
+        des_xmlSchemaValPtr(n_val, val, 3);
+        des_unsigned_long_ptr(n_length, length, 4);
+        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsOpticalCharacterRecognition",
+            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacetWhtsp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_facet);
+            printf(" %d", n_valType);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
+            printf(" %d", n_length);
+            printf(" %d", n_ws);
             printf("\n");
         }
     }
+    }
+    }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42425,32 +36000,53 @@ test_xmlUCSIsOpticalCharacterRecognition(void) {
 
 
 static int
-test_xmlUCSIsOriya(void) {
+test_xmlSchemaValidateListSimpleTypeFacet(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaFacetPtr facet; /* the facet to check */
+    int n_facet;
+    const xmlChar * value; /* the lexical repr of the value to validate */
+    int n_value;
+    unsigned long actualLen; /* the number of list items */
+    int n_actualLen;
+    unsigned long * expectedLen; /* the resulting expected number of list items */
+    int n_expectedLen;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_actualLen = 0;n_actualLen < gen_nb_unsigned_long;n_actualLen++) {
+    for (n_expectedLen = 0;n_expectedLen < gen_nb_unsigned_long_ptr;n_expectedLen++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        actualLen = gen_unsigned_long(n_actualLen, 2);
+        expectedLen = gen_unsigned_long_ptr(n_expectedLen, 3);
 
-        ret_val = xmlUCSIsOriya(code);
+        ret_val = xmlSchemaValidateListSimpleTypeFacet(facet, value, actualLen, expectedLen);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaFacetPtr(n_facet, facet, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_unsigned_long(n_actualLen, actualLen, 2);
+        des_unsigned_long_ptr(n_expectedLen, expectedLen, 3);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsOriya",
+            printf("Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_facet);
+            printf(" %d", n_value);
+            printf(" %d", n_actualLen);
+            printf(" %d", n_expectedLen);
             printf("\n");
         }
     }
+    }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42459,32 +36055,46 @@ test_xmlUCSIsOriya(void) {
 
 
 static int
-test_xmlUCSIsOsmanya(void) {
+test_xmlSchemaValidatePredefinedType(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaTypePtr type; /* the predefined type */
+    int n_type;
+    const xmlChar * value; /* the value to check */
+    int n_value;
+    xmlSchemaValPtr * val; /* the return computed value */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        type = gen_xmlSchemaTypePtr(n_type, 0);
+        value = gen_const_xmlChar_ptr(n_value, 1);
+        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
 
-        ret_val = xmlUCSIsOsmanya(code);
+        ret_val = xmlSchemaValidatePredefinedType(type, value, val);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaTypePtr(n_type, type, 0);
+        des_const_xmlChar_ptr(n_value, value, 1);
+        des_xmlSchemaValPtr_ptr(n_val, val, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsOsmanya",
+            printf("Leak of %d blocks found in xmlSchemaValidatePredefinedType",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_type);
+            printf(" %d", n_value);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
 #endif
 
@@ -42493,32 +36103,39 @@ test_xmlUCSIsOsmanya(void) {
 
 
 static int
-test_xmlUCSIsPhoneticExtensions(void) {
+test_xmlSchemaValueAppend(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr prev; /* the value */
+    int n_prev;
+    xmlSchemaValPtr cur; /* the value to be appended */
+    int n_cur;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_prev = 0;n_prev < gen_nb_xmlSchemaValPtr;n_prev++) {
+    for (n_cur = 0;n_cur < gen_nb_xmlSchemaValPtr;n_cur++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        prev = gen_xmlSchemaValPtr(n_prev, 0);
+        cur = gen_xmlSchemaValPtr(n_cur, 1);
 
-        ret_val = xmlUCSIsPhoneticExtensions(code);
+        ret_val = xmlSchemaValueAppend(prev, cur);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_prev, prev, 0);
+        des_xmlSchemaValPtr(n_cur, cur, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsPhoneticExtensions",
+            printf("Leak of %d blocks found in xmlSchemaValueAppend",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_prev);
+            printf(" %d", n_cur);
             printf("\n");
         }
     }
+    }
     function_tests++;
 #endif
 
@@ -42527,29 +36144,29 @@ test_xmlUCSIsPhoneticExtensions(void) {
 
 
 static int
-test_xmlUCSIsPrivateUse(void) {
+test_xmlSchemaValueGetAsBoolean(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlSchemaValPtr val; /* the value */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        val = gen_xmlSchemaValPtr(n_val, 0);
 
-        ret_val = xmlUCSIsPrivateUse(code);
+        ret_val = xmlSchemaValueGetAsBoolean(val);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_val, val, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsPrivateUse",
+            printf("Leak of %d blocks found in xmlSchemaValueGetAsBoolean",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
@@ -42561,29 +36178,29 @@ test_xmlUCSIsPrivateUse(void) {
 
 
 static int
-test_xmlUCSIsPrivateUseArea(void) {
+test_xmlSchemaValueGetAsString(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    xmlSchemaValPtr val; /* the value */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        val = gen_xmlSchemaValPtr(n_val, 0);
 
-        ret_val = xmlUCSIsPrivateUseArea(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaValueGetAsString(val);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_xmlSchemaValPtr(n_val, val, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsPrivateUseArea",
+            printf("Leak of %d blocks found in xmlSchemaValueGetAsString",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
@@ -42595,63 +36212,39 @@ test_xmlUCSIsPrivateUseArea(void) {
 
 
 static int
-test_xmlUCSIsRunic(void) {
+test_xmlSchemaValueGetNext(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsRunic(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsRunic",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsShavian(void) {
+test_xmlSchemaWhiteSpaceReplace(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
+#if defined(LIBXML_SCHEMAS_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * value; /* a value */
+    int n_value;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        value = gen_const_xmlChar_ptr(n_value, 0);
 
-        ret_val = xmlUCSIsShavian(code);
-        desret_int(ret_val);
+        ret_val = xmlSchemaWhiteSpaceReplace(value);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_value, value, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsShavian",
+            printf("Leak of %d blocks found in xmlSchemaWhiteSpaceReplace",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_value);
             printf("\n");
         }
     }
@@ -42661,1132 +36254,1151 @@ test_xmlUCSIsShavian(void) {
     return(test_ret);
 }
 
+static int
+test_xmlschemastypes(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing xmlschemastypes : 26 of 34 functions ...\n");
+    test_ret += test_xmlSchemaCheckFacet();
+    test_ret += test_xmlSchemaCleanupTypes();
+    test_ret += test_xmlSchemaCollapseString();
+    test_ret += test_xmlSchemaCompareValues();
+    test_ret += test_xmlSchemaCompareValuesWhtsp();
+    test_ret += test_xmlSchemaCopyValue();
+    test_ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
+    test_ret += test_xmlSchemaGetBuiltInType();
+    test_ret += test_xmlSchemaGetCanonValue();
+    test_ret += test_xmlSchemaGetCanonValueWhtsp();
+    test_ret += test_xmlSchemaGetFacetValueAsULong();
+    test_ret += test_xmlSchemaGetPredefinedType();
+    test_ret += test_xmlSchemaGetValType();
+    test_ret += test_xmlSchemaInitTypes();
+    test_ret += test_xmlSchemaIsBuiltInTypeFacet();
+    test_ret += test_xmlSchemaNewFacet();
+    test_ret += test_xmlSchemaNewNOTATIONValue();
+    test_ret += test_xmlSchemaNewQNameValue();
+    test_ret += test_xmlSchemaNewStringValue();
+    test_ret += test_xmlSchemaValPredefTypeNode();
+    test_ret += test_xmlSchemaValPredefTypeNodeNoNorm();
+    test_ret += test_xmlSchemaValidateFacet();
+    test_ret += test_xmlSchemaValidateFacetWhtsp();
+    test_ret += test_xmlSchemaValidateLengthFacet();
+    test_ret += test_xmlSchemaValidateLengthFacetWhtsp();
+    test_ret += test_xmlSchemaValidateListSimpleTypeFacet();
+    test_ret += test_xmlSchemaValidatePredefinedType();
+    test_ret += test_xmlSchemaValueAppend();
+    test_ret += test_xmlSchemaValueGetAsBoolean();
+    test_ret += test_xmlSchemaValueGetAsString();
+    test_ret += test_xmlSchemaValueGetNext();
+    test_ret += test_xmlSchemaWhiteSpaceReplace();
+
+    if (test_ret != 0)
+	printf("Module xmlschemastypes: %d errors\n", test_ret);
+    return(test_ret);
+}
 
 static int
-test_xmlUCSIsSinhala(void) {
+test_xmlCharStrdup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const char * cur; /* the input char * */
+    int n_cur;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        cur = gen_const_char_ptr(n_cur, 0);
 
-        ret_val = xmlUCSIsSinhala(code);
-        desret_int(ret_val);
+        ret_val = xmlCharStrdup(cur);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_char_ptr(n_cur, cur, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSinhala",
+            printf("Leak of %d blocks found in xmlCharStrdup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_cur);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSmallFormVariants(void) {
+test_xmlCharStrndup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const char * cur; /* the input char * */
+    int n_cur;
+    int len; /* the len of @cur */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        cur = gen_const_char_ptr(n_cur, 0);
+        len = gen_int(n_len, 1);
+        if ((cur != NULL) &&
+            (len > xmlStrlen(BAD_CAST cur)))
+            len = 0;
 
-        ret_val = xmlUCSIsSmallFormVariants(code);
-        desret_int(ret_val);
+        ret_val = xmlCharStrndup(cur, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_char_ptr(n_cur, cur, 0);
+        des_int(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSmallFormVariants",
+            printf("Leak of %d blocks found in xmlCharStrndup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_cur);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSpacingModifierLetters(void) {
+test_xmlCheckUTF8(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const unsigned char * utf; /* Pointer to putative UTF-8 encoded string. */
+    int n_utf;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_unsigned_char_ptr(n_utf, 0);
 
-        ret_val = xmlUCSIsSpacingModifierLetters(code);
+        ret_val = xmlCheckUTF8(utf);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_unsigned_char_ptr(n_utf, utf, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSpacingModifierLetters",
+            printf("Leak of %d blocks found in xmlCheckUTF8",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSpecials(void) {
+test_xmlGetUTF8Char(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const unsigned char * utf; /* a sequence of UTF-8 encoded bytes */
+    int n_utf;
+    int * len; /* a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence. */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
+    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_unsigned_char_ptr(n_utf, 0);
+        len = gen_int_ptr(n_len, 1);
 
-        ret_val = xmlUCSIsSpecials(code);
+        ret_val = xmlGetUTF8Char(utf, len);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_unsigned_char_ptr(n_utf, utf, 0);
+        des_int_ptr(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSpecials",
+            printf("Leak of %d blocks found in xmlGetUTF8Char",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSuperscriptsandSubscripts(void) {
+test_xmlStrEqual(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str1; /* the first xmlChar * */
+    int n_str1;
+    const xmlChar * str2; /* the second xmlChar * */
+    int n_str2;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
 
-        ret_val = xmlUCSIsSuperscriptsandSubscripts(code);
+        ret_val = xmlStrEqual(str1, str2);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSuperscriptsandSubscripts",
+            printf("Leak of %d blocks found in xmlStrEqual",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSupplementalArrowsA(void) {
+test_xmlStrPrintf(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsSupplementalArrowsA(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsA",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSupplementalArrowsB(void) {
+test_xmlStrQEqual(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * pref; /* the prefix of the QName */
+    int n_pref;
+    const xmlChar * name; /* the localname of the QName */
+    int n_name;
+    const xmlChar * str; /* the second xmlChar * */
+    int n_str;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
+    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        pref = gen_const_xmlChar_ptr(n_pref, 0);
+        name = gen_const_xmlChar_ptr(n_name, 1);
+        str = gen_const_xmlChar_ptr(n_str, 2);
 
-        ret_val = xmlUCSIsSupplementalArrowsB(code);
+        ret_val = xmlStrQEqual(pref, name, str);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_pref, pref, 0);
+        des_const_xmlChar_ptr(n_name, name, 1);
+        des_const_xmlChar_ptr(n_str, str, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsB",
+            printf("Leak of %d blocks found in xmlStrQEqual",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_pref);
+            printf(" %d", n_name);
+            printf(" %d", n_str);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSupplementalMathematicalOperators(void) {
+test_xmlStrVPrintf(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
-    int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
-
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
-        mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
-
-        ret_val = xmlUCSIsSupplementalMathematicalOperators(code);
-        desret_int(ret_val);
-        call_tests++;
-        des_int(n_code, code, 0);
-        xmlResetLastError();
-        if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSupplementalMathematicalOperators",
-	           xmlMemBlocks() - mem_base);
-	    test_ret++;
-            printf(" %d", n_code);
-            printf("\n");
-        }
-    }
-    function_tests++;
-#endif
 
+    /* missing type support */
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSupplementaryPrivateUseAreaA(void) {
+test_xmlStrcasecmp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str1; /* the first xmlChar * */
+    int n_str1;
+    const xmlChar * str2; /* the second xmlChar * */
+    int n_str2;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
 
-        ret_val = xmlUCSIsSupplementaryPrivateUseAreaA(code);
+        ret_val = xmlStrcasecmp(str1, str2);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaA",
+            printf("Leak of %d blocks found in xmlStrcasecmp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSupplementaryPrivateUseAreaB(void) {
+test_xmlStrcasestr(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    const xmlChar * str; /* the xmlChar * array (haystack) */
+    int n_str;
+    const xmlChar * val; /* the xmlChar to search (needle) */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
+    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str = gen_const_xmlChar_ptr(n_str, 0);
+        val = gen_const_xmlChar_ptr(n_val, 1);
 
-        ret_val = xmlUCSIsSupplementaryPrivateUseAreaB(code);
-        desret_int(ret_val);
+        ret_val = xmlStrcasestr(str, val);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str, str, 0);
+        des_const_xmlChar_ptr(n_val, val, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaB",
+            printf("Leak of %d blocks found in xmlStrcasestr",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsSyriac(void) {
+test_xmlStrchr(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    const xmlChar * str; /* the xmlChar * array */
+    int n_str;
+    xmlChar val; /* the xmlChar to search */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
+    for (n_val = 0;n_val < gen_nb_xmlChar;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str = gen_const_xmlChar_ptr(n_str, 0);
+        val = gen_xmlChar(n_val, 1);
 
-        ret_val = xmlUCSIsSyriac(code);
-        desret_int(ret_val);
+        ret_val = xmlStrchr(str, val);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str, str, 0);
+        des_xmlChar(n_val, val, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsSyriac",
+            printf("Leak of %d blocks found in xmlStrchr",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTagalog(void) {
+test_xmlStrcmp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str1; /* the first xmlChar * */
+    int n_str1;
+    const xmlChar * str2; /* the second xmlChar * */
+    int n_str2;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
 
-        ret_val = xmlUCSIsTagalog(code);
+        ret_val = xmlStrcmp(str1, str2);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTagalog",
+            printf("Leak of %d blocks found in xmlStrcmp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTagbanwa(void) {
+test_xmlStrdup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * cur; /* the input xmlChar * */
+    int n_cur;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        cur = gen_const_xmlChar_ptr(n_cur, 0);
 
-        ret_val = xmlUCSIsTagbanwa(code);
-        desret_int(ret_val);
+        ret_val = xmlStrdup(cur);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_cur, cur, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTagbanwa",
+            printf("Leak of %d blocks found in xmlStrdup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_cur);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTags(void) {
+test_xmlStrlen(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str; /* the xmlChar * array */
+    int n_str;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str = gen_const_xmlChar_ptr(n_str, 0);
 
-        ret_val = xmlUCSIsTags(code);
+        ret_val = xmlStrlen(str);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str, str, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTags",
+            printf("Leak of %d blocks found in xmlStrlen",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTaiLe(void) {
+test_xmlStrncasecmp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str1; /* the first xmlChar * */
+    int n_str1;
+    const xmlChar * str2; /* the second xmlChar * */
+    int n_str2;
+    int len; /* the max comparison length */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
+        len = gen_int(n_len, 2);
+        if ((str2 != NULL) &&
+            (len > xmlStrlen(BAD_CAST str2)))
+            len = 0;
 
-        ret_val = xmlUCSIsTaiLe(code);
+        ret_val = xmlStrncasecmp(str1, str2, len);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTaiLe",
+            printf("Leak of %d blocks found in xmlStrncasecmp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTaiXuanJingSymbols(void) {
+test_xmlStrncatNew(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * str1; /* first xmlChar string */
+    int n_str1;
+    const xmlChar * str2; /* second xmlChar string */
+    int n_str2;
+    int len; /* the len of @str2 or < 0 */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
+        len = gen_int(n_len, 2);
+        if ((str2 != NULL) &&
+            (len > xmlStrlen(BAD_CAST str2)))
+            len = 0;
 
-        ret_val = xmlUCSIsTaiXuanJingSymbols(code);
-        desret_int(ret_val);
+        ret_val = xmlStrncatNew(str1, str2, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTaiXuanJingSymbols",
+            printf("Leak of %d blocks found in xmlStrncatNew",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTamil(void) {
+test_xmlStrncmp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * str1; /* the first xmlChar * */
+    int n_str1;
+    const xmlChar * str2; /* the second xmlChar * */
+    int n_str2;
+    int len; /* the max comparison length */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
+    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str1 = gen_const_xmlChar_ptr(n_str1, 0);
+        str2 = gen_const_xmlChar_ptr(n_str2, 1);
+        len = gen_int(n_len, 2);
+        if ((str2 != NULL) &&
+            (len > xmlStrlen(BAD_CAST str2)))
+            len = 0;
 
-        ret_val = xmlUCSIsTamil(code);
+        ret_val = xmlStrncmp(str1, str2, len);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str1, str1, 0);
+        des_const_xmlChar_ptr(n_str2, str2, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTamil",
+            printf("Leak of %d blocks found in xmlStrncmp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str1);
+            printf(" %d", n_str2);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTelugu(void) {
+test_xmlStrndup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * cur; /* the input xmlChar * */
+    int n_cur;
+    int len; /* the len of @cur */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        cur = gen_const_xmlChar_ptr(n_cur, 0);
+        len = gen_int(n_len, 1);
+        if ((cur != NULL) &&
+            (len > xmlStrlen(BAD_CAST cur)))
+            len = 0;
 
-        ret_val = xmlUCSIsTelugu(code);
-        desret_int(ret_val);
+        ret_val = xmlStrndup(cur, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_cur, cur, 0);
+        des_int(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTelugu",
+            printf("Leak of %d blocks found in xmlStrndup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_cur);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsThaana(void) {
+test_xmlStrstr(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    const xmlChar * str; /* the xmlChar * array (haystack) */
+    int n_str;
+    const xmlChar * val; /* the xmlChar to search (needle) */
+    int n_val;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
+    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str = gen_const_xmlChar_ptr(n_str, 0);
+        val = gen_const_xmlChar_ptr(n_val, 1);
 
-        ret_val = xmlUCSIsThaana(code);
-        desret_int(ret_val);
+        ret_val = xmlStrstr(str, val);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str, str, 0);
+        des_const_xmlChar_ptr(n_val, val, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsThaana",
+            printf("Leak of %d blocks found in xmlStrstr",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str);
+            printf(" %d", n_val);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsThai(void) {
+test_xmlStrsub(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * str; /* the xmlChar * array (haystack) */
+    int n_str;
+    int start; /* the index of the first char (zero based) */
+    int n_start;
+    int len; /* the length of the substring */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
+    for (n_start = 0;n_start < gen_nb_int;n_start++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        str = gen_const_xmlChar_ptr(n_str, 0);
+        start = gen_int(n_start, 1);
+        len = gen_int(n_len, 2);
+        if ((str != NULL) &&
+            (start > xmlStrlen(BAD_CAST str)))
+            start = 0;
+        if ((str != NULL) &&
+            (len > xmlStrlen(BAD_CAST str)))
+            len = 0;
 
-        ret_val = xmlUCSIsThai(code);
-        desret_int(ret_val);
+        ret_val = xmlStrsub(str, start, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_str, str, 0);
+        des_int(n_start, start, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsThai",
+            printf("Leak of %d blocks found in xmlStrsub",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_str);
+            printf(" %d", n_start);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsTibetan(void) {
+test_xmlUTF8Charcmp(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * utf1; /* pointer to first UTF8 char */
+    int n_utf1;
+    const xmlChar * utf2; /* pointer to second UTF8 char */
+    int n_utf2;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
+    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
+        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);
 
-        ret_val = xmlUCSIsTibetan(code);
+        ret_val = xmlUTF8Charcmp(utf1, utf2);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf1, utf1, 0);
+        des_const_xmlChar_ptr(n_utf2, utf2, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsTibetan",
+            printf("Leak of %d blocks found in xmlUTF8Charcmp",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf1);
+            printf(" %d", n_utf2);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsUgaritic(void) {
+test_xmlUTF8Size(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * utf; /* pointer to the UTF8 character */
+    int n_utf;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
 
-        ret_val = xmlUCSIsUgaritic(code);
+        ret_val = xmlUTF8Size(utf);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsUgaritic",
+            printf("Leak of %d blocks found in xmlUTF8Size",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsUnifiedCanadianAboriginalSyllabics(void) {
+test_xmlUTF8Strlen(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
+    int n_utf;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
 
-        ret_val = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
+        ret_val = xmlUTF8Strlen(utf);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsUnifiedCanadianAboriginalSyllabics",
+            printf("Leak of %d blocks found in xmlUTF8Strlen",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
             printf("\n");
         }
     }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsVariationSelectors(void) {
+test_xmlUTF8Strloc(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * utf; /* the input UTF8 * */
+    int n_utf;
+    const xmlChar * utfchar; /* the UTF8 character to be found */
+    int n_utfchar;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
+    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
+        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);
 
-        ret_val = xmlUCSIsVariationSelectors(code);
+        ret_val = xmlUTF8Strloc(utf, utfchar);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
+        des_const_xmlChar_ptr(n_utfchar, utfchar, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsVariationSelectors",
+            printf("Leak of %d blocks found in xmlUTF8Strloc",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_utfchar);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsVariationSelectorsSupplement(void) {
+test_xmlUTF8Strndup(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * utf; /* the input UTF8 * */
+    int n_utf;
+    int len; /* the len of @utf (in chars) */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
+        len = gen_int(n_len, 1);
+        if ((utf != NULL) &&
+            (len > xmlStrlen(BAD_CAST utf)))
+            len = 0;
 
-        ret_val = xmlUCSIsVariationSelectorsSupplement(code);
-        desret_int(ret_val);
+        ret_val = xmlUTF8Strndup(utf, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
+        des_int(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsVariationSelectorsSupplement",
+            printf("Leak of %d blocks found in xmlUTF8Strndup",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsYiRadicals(void) {
+test_xmlUTF8Strpos(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * ret_val;
+    const xmlChar * utf; /* the input UTF8 * */
+    int n_utf;
+    int pos; /* the position of the desired UTF8 char (in chars) */
+    int n_pos;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
+    for (n_pos = 0;n_pos < gen_nb_int;n_pos++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
+        pos = gen_int(n_pos, 1);
 
-        ret_val = xmlUCSIsYiRadicals(code);
-        desret_int(ret_val);
+        ret_val = xmlUTF8Strpos(utf, pos);
+        desret_const_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
+        des_int(n_pos, pos, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsYiRadicals",
+            printf("Leak of %d blocks found in xmlUTF8Strpos",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_pos);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsYiSyllables(void) {
+test_xmlUTF8Strsize(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
     int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
+    int n_utf;
+    int len; /* the number of characters in the array */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
+        len = gen_int(n_len, 1);
+        if ((utf != NULL) &&
+            (len > xmlStrlen(BAD_CAST utf)))
+            len = 0;
 
-        ret_val = xmlUCSIsYiSyllables(code);
+        ret_val = xmlUTF8Strsize(utf, len);
         desret_int(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
+        des_int(n_len, len, 1);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsYiSyllables",
+            printf("Leak of %d blocks found in xmlUTF8Strsize",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 
 static int
-test_xmlUCSIsYijingHexagramSymbols(void) {
+test_xmlUTF8Strsub(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_UNICODE_ENABLED)
     int mem_base;
-    int ret_val;
-    int code; /* UCS code point */
-    int n_code;
+    xmlChar * ret_val;
+    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
+    int n_utf;
+    int start; /* relative pos of first char */
+    int n_start;
+    int len; /* total number to copy */
+    int n_len;
 
-    for (n_code = 0;n_code < gen_nb_int;n_code++) {
+    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
+    for (n_start = 0;n_start < gen_nb_int;n_start++) {
+    for (n_len = 0;n_len < gen_nb_int;n_len++) {
         mem_base = xmlMemBlocks();
-        code = gen_int(n_code, 0);
+        utf = gen_const_xmlChar_ptr(n_utf, 0);
+        start = gen_int(n_start, 1);
+        len = gen_int(n_len, 2);
+        if ((utf != NULL) &&
+            (start > xmlStrlen(BAD_CAST utf)))
+            start = 0;
+        if ((utf != NULL) &&
+            (len > xmlStrlen(BAD_CAST utf)))
+            len = 0;
 
-        ret_val = xmlUCSIsYijingHexagramSymbols(code);
-        desret_int(ret_val);
+        ret_val = xmlUTF8Strsub(utf, start, len);
+        desret_xmlChar_ptr(ret_val);
         call_tests++;
-        des_int(n_code, code, 0);
+        des_const_xmlChar_ptr(n_utf, utf, 0);
+        des_int(n_start, start, 1);
+        des_int(n_len, len, 2);
         xmlResetLastError();
         if (mem_base != xmlMemBlocks()) {
-            printf("Leak of %d blocks found in xmlUCSIsYijingHexagramSymbols",
+            printf("Leak of %d blocks found in xmlUTF8Strsub",
 	           xmlMemBlocks() - mem_base);
 	    test_ret++;
-            printf(" %d", n_code);
+            printf(" %d", n_utf);
+            printf(" %d", n_start);
+            printf(" %d", n_len);
             printf("\n");
         }
     }
+    }
+    }
     function_tests++;
-#endif
 
     return(test_ret);
 }
 
 static int
-test_xmlunicode(void) {
-    int test_ret = 0;
-
-    if (quiet == 0) printf("Testing xmlunicode : 166 of 166 functions ...\n");
-    test_ret += test_xmlUCSIsAegeanNumbers();
-    test_ret += test_xmlUCSIsAlphabeticPresentationForms();
-    test_ret += test_xmlUCSIsArabic();
-    test_ret += test_xmlUCSIsArabicPresentationFormsA();
-    test_ret += test_xmlUCSIsArabicPresentationFormsB();
-    test_ret += test_xmlUCSIsArmenian();
-    test_ret += test_xmlUCSIsArrows();
-    test_ret += test_xmlUCSIsBasicLatin();
-    test_ret += test_xmlUCSIsBengali();
-    test_ret += test_xmlUCSIsBlock();
-    test_ret += test_xmlUCSIsBlockElements();
-    test_ret += test_xmlUCSIsBopomofo();
-    test_ret += test_xmlUCSIsBopomofoExtended();
-    test_ret += test_xmlUCSIsBoxDrawing();
-    test_ret += test_xmlUCSIsBraillePatterns();
-    test_ret += test_xmlUCSIsBuhid();
-    test_ret += test_xmlUCSIsByzantineMusicalSymbols();
-    test_ret += test_xmlUCSIsCJKCompatibility();
-    test_ret += test_xmlUCSIsCJKCompatibilityForms();
-    test_ret += test_xmlUCSIsCJKCompatibilityIdeographs();
-    test_ret += test_xmlUCSIsCJKCompatibilityIdeographsSupplement();
-    test_ret += test_xmlUCSIsCJKRadicalsSupplement();
-    test_ret += test_xmlUCSIsCJKSymbolsandPunctuation();
-    test_ret += test_xmlUCSIsCJKUnifiedIdeographs();
-    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionA();
-    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionB();
-    test_ret += test_xmlUCSIsCat();
-    test_ret += test_xmlUCSIsCatC();
-    test_ret += test_xmlUCSIsCatCc();
-    test_ret += test_xmlUCSIsCatCf();
-    test_ret += test_xmlUCSIsCatCo();
-    test_ret += test_xmlUCSIsCatCs();
-    test_ret += test_xmlUCSIsCatL();
-    test_ret += test_xmlUCSIsCatLl();
-    test_ret += test_xmlUCSIsCatLm();
-    test_ret += test_xmlUCSIsCatLo();
-    test_ret += test_xmlUCSIsCatLt();
-    test_ret += test_xmlUCSIsCatLu();
-    test_ret += test_xmlUCSIsCatM();
-    test_ret += test_xmlUCSIsCatMc();
-    test_ret += test_xmlUCSIsCatMe();
-    test_ret += test_xmlUCSIsCatMn();
-    test_ret += test_xmlUCSIsCatN();
-    test_ret += test_xmlUCSIsCatNd();
-    test_ret += test_xmlUCSIsCatNl();
-    test_ret += test_xmlUCSIsCatNo();
-    test_ret += test_xmlUCSIsCatP();
-    test_ret += test_xmlUCSIsCatPc();
-    test_ret += test_xmlUCSIsCatPd();
-    test_ret += test_xmlUCSIsCatPe();
-    test_ret += test_xmlUCSIsCatPf();
-    test_ret += test_xmlUCSIsCatPi();
-    test_ret += test_xmlUCSIsCatPo();
-    test_ret += test_xmlUCSIsCatPs();
-    test_ret += test_xmlUCSIsCatS();
-    test_ret += test_xmlUCSIsCatSc();
-    test_ret += test_xmlUCSIsCatSk();
-    test_ret += test_xmlUCSIsCatSm();
-    test_ret += test_xmlUCSIsCatSo();
-    test_ret += test_xmlUCSIsCatZ();
-    test_ret += test_xmlUCSIsCatZl();
-    test_ret += test_xmlUCSIsCatZp();
-    test_ret += test_xmlUCSIsCatZs();
-    test_ret += test_xmlUCSIsCherokee();
-    test_ret += test_xmlUCSIsCombiningDiacriticalMarks();
-    test_ret += test_xmlUCSIsCombiningDiacriticalMarksforSymbols();
-    test_ret += test_xmlUCSIsCombiningHalfMarks();
-    test_ret += test_xmlUCSIsCombiningMarksforSymbols();
-    test_ret += test_xmlUCSIsControlPictures();
-    test_ret += test_xmlUCSIsCurrencySymbols();
-    test_ret += test_xmlUCSIsCypriotSyllabary();
-    test_ret += test_xmlUCSIsCyrillic();
-    test_ret += test_xmlUCSIsCyrillicSupplement();
-    test_ret += test_xmlUCSIsDeseret();
-    test_ret += test_xmlUCSIsDevanagari();
-    test_ret += test_xmlUCSIsDingbats();
-    test_ret += test_xmlUCSIsEnclosedAlphanumerics();
-    test_ret += test_xmlUCSIsEnclosedCJKLettersandMonths();
-    test_ret += test_xmlUCSIsEthiopic();
-    test_ret += test_xmlUCSIsGeneralPunctuation();
-    test_ret += test_xmlUCSIsGeometricShapes();
-    test_ret += test_xmlUCSIsGeorgian();
-    test_ret += test_xmlUCSIsGothic();
-    test_ret += test_xmlUCSIsGreek();
-    test_ret += test_xmlUCSIsGreekExtended();
-    test_ret += test_xmlUCSIsGreekandCoptic();
-    test_ret += test_xmlUCSIsGujarati();
-    test_ret += test_xmlUCSIsGurmukhi();
-    test_ret += test_xmlUCSIsHalfwidthandFullwidthForms();
-    test_ret += test_xmlUCSIsHangulCompatibilityJamo();
-    test_ret += test_xmlUCSIsHangulJamo();
-    test_ret += test_xmlUCSIsHangulSyllables();
-    test_ret += test_xmlUCSIsHanunoo();
-    test_ret += test_xmlUCSIsHebrew();
-    test_ret += test_xmlUCSIsHighPrivateUseSurrogates();
-    test_ret += test_xmlUCSIsHighSurrogates();
-    test_ret += test_xmlUCSIsHiragana();
-    test_ret += test_xmlUCSIsIPAExtensions();
-    test_ret += test_xmlUCSIsIdeographicDescriptionCharacters();
-    test_ret += test_xmlUCSIsKanbun();
-    test_ret += test_xmlUCSIsKangxiRadicals();
-    test_ret += test_xmlUCSIsKannada();
-    test_ret += test_xmlUCSIsKatakana();
-    test_ret += test_xmlUCSIsKatakanaPhoneticExtensions();
-    test_ret += test_xmlUCSIsKhmer();
-    test_ret += test_xmlUCSIsKhmerSymbols();
-    test_ret += test_xmlUCSIsLao();
-    test_ret += test_xmlUCSIsLatin1Supplement();
-    test_ret += test_xmlUCSIsLatinExtendedA();
-    test_ret += test_xmlUCSIsLatinExtendedAdditional();
-    test_ret += test_xmlUCSIsLatinExtendedB();
-    test_ret += test_xmlUCSIsLetterlikeSymbols();
-    test_ret += test_xmlUCSIsLimbu();
-    test_ret += test_xmlUCSIsLinearBIdeograms();
-    test_ret += test_xmlUCSIsLinearBSyllabary();
-    test_ret += test_xmlUCSIsLowSurrogates();
-    test_ret += test_xmlUCSIsMalayalam();
-    test_ret += test_xmlUCSIsMathematicalAlphanumericSymbols();
-    test_ret += test_xmlUCSIsMathematicalOperators();
-    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsA();
-    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsB();
-    test_ret += test_xmlUCSIsMiscellaneousSymbols();
-    test_ret += test_xmlUCSIsMiscellaneousSymbolsandArrows();
-    test_ret += test_xmlUCSIsMiscellaneousTechnical();
-    test_ret += test_xmlUCSIsMongolian();
-    test_ret += test_xmlUCSIsMusicalSymbols();
-    test_ret += test_xmlUCSIsMyanmar();
-    test_ret += test_xmlUCSIsNumberForms();
-    test_ret += test_xmlUCSIsOgham();
-    test_ret += test_xmlUCSIsOldItalic();
-    test_ret += test_xmlUCSIsOpticalCharacterRecognition();
-    test_ret += test_xmlUCSIsOriya();
-    test_ret += test_xmlUCSIsOsmanya();
-    test_ret += test_xmlUCSIsPhoneticExtensions();
-    test_ret += test_xmlUCSIsPrivateUse();
-    test_ret += test_xmlUCSIsPrivateUseArea();
-    test_ret += test_xmlUCSIsRunic();
-    test_ret += test_xmlUCSIsShavian();
-    test_ret += test_xmlUCSIsSinhala();
-    test_ret += test_xmlUCSIsSmallFormVariants();
-    test_ret += test_xmlUCSIsSpacingModifierLetters();
-    test_ret += test_xmlUCSIsSpecials();
-    test_ret += test_xmlUCSIsSuperscriptsandSubscripts();
-    test_ret += test_xmlUCSIsSupplementalArrowsA();
-    test_ret += test_xmlUCSIsSupplementalArrowsB();
-    test_ret += test_xmlUCSIsSupplementalMathematicalOperators();
-    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaA();
-    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaB();
-    test_ret += test_xmlUCSIsSyriac();
-    test_ret += test_xmlUCSIsTagalog();
-    test_ret += test_xmlUCSIsTagbanwa();
-    test_ret += test_xmlUCSIsTags();
-    test_ret += test_xmlUCSIsTaiLe();
-    test_ret += test_xmlUCSIsTaiXuanJingSymbols();
-    test_ret += test_xmlUCSIsTamil();
-    test_ret += test_xmlUCSIsTelugu();
-    test_ret += test_xmlUCSIsThaana();
-    test_ret += test_xmlUCSIsThai();
-    test_ret += test_xmlUCSIsTibetan();
-    test_ret += test_xmlUCSIsUgaritic();
-    test_ret += test_xmlUCSIsUnifiedCanadianAboriginalSyllabics();
-    test_ret += test_xmlUCSIsVariationSelectors();
-    test_ret += test_xmlUCSIsVariationSelectorsSupplement();
-    test_ret += test_xmlUCSIsYiRadicals();
-    test_ret += test_xmlUCSIsYiSyllables();
-    test_ret += test_xmlUCSIsYijingHexagramSymbols();
+test_xmlstring(void) {
+    int test_ret = 0;
+
+    if (quiet == 0) printf("Testing xmlstring : 26 of 30 functions ...\n");
+    test_ret += test_xmlCharStrdup();
+    test_ret += test_xmlCharStrndup();
+    test_ret += test_xmlCheckUTF8();
+    test_ret += test_xmlGetUTF8Char();
+    test_ret += test_xmlStrEqual();
+    test_ret += test_xmlStrPrintf();
+    test_ret += test_xmlStrQEqual();
+    test_ret += test_xmlStrVPrintf();
+    test_ret += test_xmlStrcasecmp();
+    test_ret += test_xmlStrcasestr();
+    test_ret += test_xmlStrchr();
+    test_ret += test_xmlStrcmp();
+    test_ret += test_xmlStrdup();
+    test_ret += test_xmlStrlen();
+    test_ret += test_xmlStrncasecmp();
+    test_ret += test_xmlStrncatNew();
+    test_ret += test_xmlStrncmp();
+    test_ret += test_xmlStrndup();
+    test_ret += test_xmlStrstr();
+    test_ret += test_xmlStrsub();
+    test_ret += test_xmlUTF8Charcmp();
+    test_ret += test_xmlUTF8Size();
+    test_ret += test_xmlUTF8Strlen();
+    test_ret += test_xmlUTF8Strloc();
+    test_ret += test_xmlUTF8Strndup();
+    test_ret += test_xmlUTF8Strpos();
+    test_ret += test_xmlUTF8Strsize();
+    test_ret += test_xmlUTF8Strsub();
 
     if (test_ret != 0)
-	printf("Module xmlunicode: %d errors\n", test_ret);
+	printf("Module xmlstring: %d errors\n", test_ret);
     return(test_ret);
 }
 
@@ -47445,7 +41057,7 @@ static int
 test_xmlXPathInit(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#if defined(LIBXML_XPATH_ENABLED)
     int mem_base;
 
         mem_base = xmlMemBlocks();
@@ -47470,7 +41082,7 @@ static int
 test_xmlXPathIsInf(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#if defined(LIBXML_XPATH_ENABLED)
     int mem_base;
     int ret_val;
     double val; /* a double value */
@@ -47504,7 +41116,7 @@ static int
 test_xmlXPathIsNaN(void) {
     int test_ret = 0;
 
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#if defined(LIBXML_XPATH_ENABLED)
     int mem_base;
     int ret_val;
     double val; /* a double value */
@@ -52169,7 +45781,6 @@ test_module(const char *module) {
     if (!strcmp(module, "xmlschemas")) return(test_xmlschemas());
     if (!strcmp(module, "xmlschemastypes")) return(test_xmlschemastypes());
     if (!strcmp(module, "xmlstring")) return(test_xmlstring());
-    if (!strcmp(module, "xmlunicode")) return(test_xmlunicode());
     if (!strcmp(module, "xmlwriter")) return(test_xmlwriter());
     if (!strcmp(module, "xpath")) return(test_xpath());
     if (!strcmp(module, "xpathInternals")) return(test_xpathInternals());
diff --git a/testchar.c b/testchar.c
index 98f85f60..15d163ba 100644
--- a/testchar.c
+++ b/testchar.c
@@ -751,21 +751,20 @@ error:
 static char *
 convert(xmlCharEncodingHandlerPtr handler, const char *utf8, int size,
         int *outSize) {
+    xmlBufferPtr in, out;
     char *ret;
-    int inlen;
-    int res;
-
-    inlen = size;
-    *outSize = size * 2;
-    ret = xmlMalloc(*outSize);
-    if (ret == NULL)
-        return(NULL);
-    res = handler->output(BAD_CAST ret, outSize, BAD_CAST utf8, &inlen);
-    if ((res < 0) || (inlen != size)) {
-        xmlFree(ret);
-        return(NULL);
-    }
 
+    in = xmlBufferCreate();
+    xmlBufferAdd(in, BAD_CAST utf8, size);
+    out = xmlBufferCreate();
+    xmlCharEncOutFunc(handler, out, in);
+
+    if (outSize)
+        *outSize = out->use;
+    ret = (char *) xmlBufferDetach(out);
+
+    xmlBufferFree(out);
+    xmlBufferFree(in);
     return(ret);
 }
 
@@ -880,8 +879,110 @@ error:
 
 #endif
 
-int main(void) {
+static void
+bufDump(const char *prefix, const xmlChar *content, int len) {
+    int i;
+
+    fprintf(stderr, "%s", prefix);
+    for (i = 0; i < len; i++) {
+        fprintf(stderr, " %02X", content[i]);
+    }
+    fprintf(stderr, "\n");
+}
+
+static int
+bufCompare(xmlBufferPtr got, const xmlChar *expectContent, int expectLen) {
+    const xmlChar *gotContent = xmlBufferContent(got);
+    int gotLen = xmlBufferLength(got);
+
+    if ((gotLen == expectLen) &&
+        (memcmp(gotContent, expectContent, gotLen) == 0))
+        return(0);
+
+    bufDump("got:     ", gotContent, gotLen);
+    bufDump("expected:", expectContent, expectLen);
+
+    return(-1);
+}
+
+static int
+testEncHandler(xmlCharEncodingHandlerPtr handler, const xmlChar *dec,
+                int decSize, const xmlChar *enc, int encSize) {
+    xmlBufferPtr encBuf = xmlBufferCreate();
+    xmlBufferPtr decBuf = xmlBufferCreate();
+    int ret = 0;
 
+    xmlBufferAdd(encBuf, enc, encSize);
+    xmlCharEncInFunc(handler, decBuf, encBuf);
+    if (bufCompare(decBuf, dec, decSize) != 0) {
+        fprintf(stderr, "Decoding %s failed\n", handler->name);
+        ret = -1;
+    }
+
+#ifdef LIBXML_OUTPUT_ENABLED
+    xmlBufferEmpty(decBuf);
+    xmlBufferAdd(decBuf, dec, decSize);
+    xmlCharEncOutFunc(handler, encBuf, decBuf);
+    if (bufCompare(encBuf, enc, encSize) != 0) {
+        fprintf(stderr, "Encoding %s failed\n", handler->name);
+        ret = -1;
+    }
+#endif
+
+    xmlBufferFree(decBuf);
+    xmlBufferFree(encBuf);
+    return(ret);
+}
+
+static int
+testUTF16(void) {
+    static const xmlChar utf8[] =
+        "\x01"
+        "\x7F"
+        "\xC2\x80"
+        "\xDF\xBF"
+        "\xE0\xA0\x80"
+        "\xEF\xBF\xBF"
+        "\xF0\x90\x80\x80"
+        "\xF4\x8F\xBF\xBF";
+    static const xmlChar utf16LE[] =
+        "\x01\x00"
+        "\x7F\x00"
+        "\x80\x00"
+        "\xFF\x07"
+        "\x00\x08"
+        "\xFF\xFF"
+        "\x00\xD8\x00\xDC"
+        "\xFF\xDB\xFF\xDF";
+    static const xmlChar utf16BE[] =
+        "\x00\x01"
+        "\x00\x7F"
+        "\x00\x80"
+        "\x07\xFF"
+        "\x08\x00"
+        "\xFF\xFF"
+        "\xD8\x00\xDC\x00"
+        "\xDB\xFF\xDF\xFF";
+
+    xmlCharEncodingHandlerPtr handler16LE, handler16BE;
+    int ret = 0;
+
+    handler16LE = xmlFindCharEncodingHandler("UTF-16LE");
+    handler16BE = xmlFindCharEncodingHandler("UTF-16BE");
+
+    if (testEncHandler(handler16LE,
+                       utf8, sizeof(utf8) - 1,
+                       utf16LE, sizeof(utf16LE) - 1) != 0)
+        ret = -1;
+    if (testEncHandler(handler16BE,
+                       utf8, sizeof(utf8) - 1,
+                       utf16BE, sizeof(utf16BE) - 1) != 0)
+        ret = -1;
+
+    return(ret);
+}
+
+int main(void) {
     int ret = 0;
 
     /*
@@ -907,6 +1008,7 @@ int main(void) {
     ret += testUserEncodingPush();
     ret += testUTF8Chunks();
 #endif
+    ret += testUTF16();
 
     /*
      * Cleanup function for the XML library.
diff --git a/testlimits.c b/testlimits.c
index b61c42cf..1fc1aaf9 100644
--- a/testlimits.c
+++ b/testlimits.c
@@ -10,6 +10,7 @@
  * daniel@veillard.com
  */
 
+#include "libxml.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -461,7 +462,6 @@ internalSubsetCallback(void *ctx ATTRIBUTE_UNUSED,
                        const xmlChar * SystemID ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -477,7 +477,6 @@ externalSubsetCallback(void *ctx ATTRIBUTE_UNUSED,
                        const xmlChar * SystemID ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -558,7 +557,6 @@ entityDeclCallback(void *ctx ATTRIBUTE_UNUSED,
                    xmlChar * content ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -578,7 +576,6 @@ attributeDeclCallback(void *ctx ATTRIBUTE_UNUSED,
                       xmlEnumerationPtr tree ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -597,7 +594,6 @@ elementDeclCallback(void *ctx ATTRIBUTE_UNUSED,
                     xmlElementContentPtr content ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -616,7 +612,6 @@ notationDeclCallback(void *ctx ATTRIBUTE_UNUSED,
                      const xmlChar * systemId ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -637,7 +632,6 @@ unparsedEntityDeclCallback(void *ctx ATTRIBUTE_UNUSED,
                            const xmlChar * notationName ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -653,7 +647,6 @@ setDocumentLocatorCallback(void *ctx ATTRIBUTE_UNUSED,
                            xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -666,7 +659,6 @@ static void
 startDocumentCallback(void *ctx ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -679,7 +671,6 @@ static void
 endDocumentCallback(void *ctx ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 #if 0
@@ -730,7 +721,6 @@ charactersCallback(void *ctx ATTRIBUTE_UNUSED,
                    int len ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -745,7 +735,6 @@ referenceCallback(void *ctx ATTRIBUTE_UNUSED,
                   const xmlChar * name ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -764,7 +753,6 @@ ignorableWhitespaceCallback(void *ctx ATTRIBUTE_UNUSED,
                             int len ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -782,7 +770,6 @@ processingInstructionCallback(void *ctx ATTRIBUTE_UNUSED,
                               const xmlChar * data ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -799,7 +786,6 @@ cdataBlockCallback(void *ctx ATTRIBUTE_UNUSED,
                    int len ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -814,7 +800,6 @@ commentCallback(void *ctx ATTRIBUTE_UNUSED,
                 const xmlChar * value ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -831,7 +816,6 @@ warningCallback(void *ctx ATTRIBUTE_UNUSED,
                 const char *msg ATTRIBUTE_UNUSED, ...)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -848,7 +832,6 @@ errorCallback(void *ctx ATTRIBUTE_UNUSED, const char *msg ATTRIBUTE_UNUSED,
               ...)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -864,7 +847,6 @@ static void
 fatalErrorCallback(void *ctx ATTRIBUTE_UNUSED,
                    const char *msg ATTRIBUTE_UNUSED, ...)
 {
-    return;
 }
 
 
@@ -891,7 +873,6 @@ startElementNsCallback(void *ctx ATTRIBUTE_UNUSED,
                        const xmlChar ** attributes ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 /**
@@ -908,7 +889,6 @@ endElementNsCallback(void *ctx ATTRIBUTE_UNUSED,
                      const xmlChar * URI ATTRIBUTE_UNUSED)
 {
     callbacks++;
-    return;
 }
 
 static xmlSAXHandler callbackSAX2HandlerStruct = {
diff --git a/testparser.c b/testparser.c
index d19e9ea5..11008dbb 100644
--- a/testparser.c
+++ b/testparser.c
@@ -4,13 +4,34 @@
  * See Copyright for the status of this software.
  */
 
+#define XML_DEPRECATED
+
+#include "libxml.h"
 #include <libxml/parser.h>
+#include <libxml/parserInternals.h>
+#include <libxml/uri.h>
 #include <libxml/xmlreader.h>
+#include <libxml/xmlsave.h>
 #include <libxml/xmlwriter.h>
 #include <libxml/HTMLparser.h>
 
 #include <string.h>
 
+static int
+testNewDocNode(void) {
+    xmlNodePtr node;
+    int err = 0;
+
+    node = xmlNewDocNode(NULL, NULL, BAD_CAST "c", BAD_CAST "");
+    if (node->children != NULL) {
+        fprintf(stderr, "empty node has children\n");
+        err = 1;
+    }
+    xmlFreeNode(node);
+
+    return err;
+}
+
 static int
 testStandaloneWithEncoding(void) {
     xmlDocPtr doc;
@@ -48,7 +69,8 @@ testUnsupportedEncoding(void) {
     xmlFreeDoc(doc);
 
     error = xmlGetLastError();
-    if (error->code != XML_ERR_UNSUPPORTED_ENCODING ||
+    if (error == NULL ||
+        error->code != XML_ERR_UNSUPPORTED_ENCODING ||
         error->level != XML_ERR_WARNING ||
         strcmp(error->message, "Unsupported encoding: #unsupported\n") != 0)
     {
@@ -78,6 +100,112 @@ testNodeGetContent(void) {
     return err;
 }
 
+static int
+testCFileIO(void) {
+    xmlDocPtr doc;
+    int err = 0;
+
+    /* Deprecated FILE-based API */
+    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen, xmlFileRead,
+                              xmlFileClose);
+    doc = xmlReadFile("test/ent1", NULL, 0);
+
+    if (doc == NULL) {
+        err = 1;
+    } else {
+        xmlNodePtr root = xmlDocGetRootElement(doc);
+
+        if (root == NULL || !xmlStrEqual(root->name, BAD_CAST "EXAMPLE"))
+            err = 1;
+    }
+
+    xmlFreeDoc(doc);
+    xmlPopInputCallbacks();
+
+    if (err)
+        fprintf(stderr, "xmlReadFile failed with FILE input callbacks\n");
+
+    return err;
+}
+
+#ifdef LIBXML_OUTPUT_ENABLED
+static xmlChar *
+dumpNodeList(xmlNodePtr list) {
+    xmlBufferPtr buffer;
+    xmlSaveCtxtPtr save;
+    xmlNodePtr cur;
+    xmlChar *ret;
+
+    buffer = xmlBufferCreate();
+    save = xmlSaveToBuffer(buffer, "UTF-8", 0);
+    for (cur = list; cur != NULL; cur = cur->next)
+        xmlSaveTree(save, cur);
+    xmlSaveClose(save);
+
+    ret = xmlBufferDetach(buffer);
+    xmlBufferFree(buffer);
+    return ret;
+}
+
+static int
+testCtxtParseContent(void) {
+    xmlParserCtxtPtr ctxt;
+    xmlParserInputPtr input;
+    xmlDocPtr doc;
+    xmlNodePtr node, list;
+    const char *content;
+    xmlChar *output;
+    int i, j;
+    int err = 0;
+
+    static const char *const tests[] = {
+        "<!-- c -->\xF0\x9F\x98\x84<a/><b/>end",
+        "text<a:foo><b:foo/></a:foo>text<!-- c -->"
+    };
+
+    doc = xmlReadDoc(BAD_CAST "<doc xmlns:a='a'><elem xmlns:b='b'/></doc>",
+                     NULL, NULL, 0);
+    node = doc->children->children;
+
+    ctxt = xmlNewParserCtxt();
+
+    for (i = 0; (size_t) i < sizeof(tests) / sizeof(tests[0]); i++) {
+        content = tests[i];
+
+        for (j = 0; j < 2; j++) {
+            if (j == 0) {
+                input = xmlNewInputFromString(NULL, content,
+                                              XML_INPUT_BUF_STATIC);
+                list = xmlCtxtParseContent(ctxt, input, node, 0);
+            } else {
+                xmlParseInNodeContext(node, content, strlen(content), 0,
+                                      &list);
+            }
+
+            output = dumpNodeList(list);
+
+            if ((j == 0 && ctxt->nsWellFormed == 0) ||
+                strcmp((char *) output, content) != 0) {
+                fprintf(stderr, "%s failed test %d, got:\n%s\n",
+                        j == 0 ?
+                            "xmlCtxtParseContent" :
+                            "xmlParseInNodeContext",
+                        i, output);
+                err = 1;
+            }
+
+            xmlFree(output);
+            xmlFreeNodeList(list);
+        }
+    }
+
+    xmlFreeParserCtxt(ctxt);
+    xmlFreeDoc(doc);
+
+    return err;
+}
+#endif /* LIBXML_OUTPUT_ENABLED */
+
 #ifdef LIBXML_SAX1_ENABLED
 static int
 testBalancedChunk(void) {
@@ -163,9 +291,34 @@ testHugeEncodedChunk(void) {
 
     return err;
 }
+#endif
 
 #ifdef LIBXML_HTML_ENABLED
 static int
+testHtmlIds(void) {
+    const char *htmlContent =
+        "<html><body><div id='myId'>Hello, World!</div></body></html>";
+    htmlDocPtr doc;
+    xmlAttrPtr node;
+
+    doc = htmlReadDoc(BAD_CAST htmlContent, NULL, NULL, 0);
+    if (doc == NULL) {
+        fprintf(stderr, "could not parse HTML content\n");
+        return 1;
+    }
+
+    node = xmlGetID(doc, BAD_CAST "myId");
+    if (node == NULL) {
+        fprintf(stderr, "xmlGetID doesn't work on HTML\n");
+        return 1;
+    }
+
+    xmlFreeDoc(doc);
+    return 0;
+}
+
+#ifdef LIBXML_PUSH_ENABLED
+static int
 testHtmlPushWithEncoding(void) {
     htmlParserCtxtPtr ctxt;
     htmlDocPtr doc;
@@ -386,20 +539,241 @@ testWriterClose(void){
 }
 #endif
 
+typedef struct {
+    const char *uri;
+    const char *base;
+    const char *result;
+} xmlRelativeUriTest;
+
+static int
+testBuildRelativeUri(void) {
+    xmlChar *res;
+    int err = 0;
+    int i;
+
+    static const xmlRelativeUriTest tests[] = {
+        {
+            "/a/b1/c1",
+            "/a/b2/c2",
+            "../b1/c1"
+        }, {
+            "a/b1/c1",
+            "a/b2/c2",
+            "../b1/c1"
+        }, {
+            "a/././b1/x/y/../z/../.././c1",
+            "./a/./b2/././b2",
+            "../b1/c1"
+        }, {
+            "file:///a/b1/c1",
+            "/a/b2/c2",
+            NULL
+        }, {
+            "/a/b1/c1",
+            "file:///a/b2/c2",
+            NULL
+        }, {
+            "a/b1/c1",
+            "/a/b2/c2",
+            NULL
+        }, {
+            "/a/b1/c1",
+            "a/b2/c2",
+            NULL
+        }, {
+            "http://example.org/a/b1/c1",
+            "http://example.org/a/b2/c2",
+            "../b1/c1"
+        }, {
+            "http://example.org/a/b1/c1",
+            "https://example.org/a/b2/c2",
+            NULL
+        }, {
+            "http://example.org/a/b1/c1",
+            "http://localhost/a/b2/c2",
+            NULL
+        }, {
+            "with space/x x/y y",
+            "with space/b2/c2",
+            "../x%20x/y%20y"
+        }, {
+            "with space/x x/y y",
+            "/b2/c2",
+            "with%20space/x%20x/y%20y"
+        }
+#if defined(_WIN32) || defined(__CYGWIN__)
+        , {
+            "\\a\\b1\\c1",
+            "\\a\\b2\\c2",
+            "../b1/c1"
+        }, {
+            "\\a\\b1\\c1",
+            "/a/b2/c2",
+            "../b1/c1"
+        }, {
+            "a\\b1\\c1",
+            "a/b2/c2",
+            "../b1/c1"
+        }, {
+            "file://server/a/b1/c1",
+            "\\\\?\\UNC\\server\\a\\b2\\c2",
+            "../b1/c1"
+        }, {
+            "file://server/a/b1/c1",
+            "\\\\server\\a\\b2\\c2",
+            "../b1/c1"
+        }, {
+            "file:///x:/a/b1/c1",
+            "x:\\a\\b2\\c2",
+            "../b1/c1"
+        }, {
+            "file:///x:/a/b1/c1",
+            "\\\\?\\x:\\a\\b2\\c2",
+            "../b1/c1"
+        }, {
+            "file:///x:/a/b1/c1",
+            "file:///y:/a/b2/c2",
+            NULL
+        }, {
+            "x:/a/b1/c1",
+            "y:/a/b2/c2",
+            "file:///x:/a/b1/c1"
+        }, {
+            "/a/b1/c1",
+            "y:/a/b2/c2",
+            NULL
+        }, {
+            "\\\\server\\a\\b1\\c1",
+            "a/b2/c2",
+            "file://server/a/b1/c1"
+        }
+#endif
+    };
+
+    for (i = 0; (size_t) i < sizeof(tests) / sizeof(tests[0]); i++) {
+        const xmlRelativeUriTest *test = tests + i;
+        const char *expect;
+
+        res = xmlBuildRelativeURI(BAD_CAST test->uri, BAD_CAST test->base);
+        expect = test->result ? test->result : test->uri;
+        if (!xmlStrEqual(res, BAD_CAST expect)) {
+            fprintf(stderr, "xmlBuildRelativeURI failed uri=%s base=%s "
+                    "result=%s expected=%s\n", test->uri, test->base,
+                    res, expect);
+            err = 1;
+        }
+        xmlFree(res);
+    }
+
+    return err;
+}
+
+static int charEncConvImplError;
+
+static int
+rot13Convert(unsigned char *out, int *outlen,
+             const unsigned char *in, int *inlen, void *vctxt) {
+    int *ctxt = vctxt;
+    int inSize = *inlen;
+    int outSize = *outlen;
+    int rot, i;
+
+    rot = *ctxt;
+
+    for (i = 0; i < inSize && i < outSize; i++) {
+        int c = in[i];
+
+        if (c >= 'A' && c <= 'Z')
+            c = 'A' + (c - 'A' + rot) % 26;
+        else if (c >= 'a' && c <= 'z')
+            c = 'a' + (c - 'a' + rot) % 26;
+
+        out[i] = c;
+    }
+
+    *inlen = i;
+    *outlen = i;
+
+    return XML_ENC_ERR_SUCCESS;
+}
+
+static void
+rot13ConvCtxtDtor(void *vctxt) {
+    xmlFree(vctxt);
+}
+
+static int
+rot13ConvImpl(void *vctxt ATTRIBUTE_UNUSED, const char *name,
+              xmlCharEncConverter *conv) {
+    int *inputCtxt;
+
+    if (strcmp(name, "rot13") != 0) {
+        fprintf(stderr, "rot13ConvImpl received wrong name\n");
+        charEncConvImplError = 1;
+
+        return XML_ERR_UNSUPPORTED_ENCODING;
+    }
+
+    conv->input = rot13Convert;
+    conv->output = rot13Convert;
+    conv->ctxtDtor = rot13ConvCtxtDtor;
+    
+    inputCtxt = xmlMalloc(sizeof(*inputCtxt));
+    *inputCtxt = 13;
+    conv->inputCtxt = inputCtxt;
+
+    return XML_ERR_OK;
+}
+
+static int
+testCharEncConvImpl(void) {
+    xmlParserCtxtPtr ctxt;
+    xmlDocPtr doc;
+    xmlNodePtr root;
+    int err = 0;
+
+    ctxt = xmlNewParserCtxt();
+    xmlCtxtSetCharEncConvImpl(ctxt, rot13ConvImpl, NULL);
+    charEncConvImplError = 0;
+    doc = xmlCtxtReadDoc(ctxt, BAD_CAST "<?kzy irefvba='1.0'?><qbp/>", NULL,
+                         "rot13", 0);
+    if (charEncConvImplError)
+        err = 1;
+    xmlFreeParserCtxt(ctxt);
+
+    root = xmlDocGetRootElement(doc);
+    if (root == NULL || strcmp((char *) root->name, "doc") != 0) {
+        fprintf(stderr, "testCharEncConvImpl failed\n");
+        err = 1;
+    }
+
+    xmlFreeDoc(doc);
+
+    return err;
+}
+
 int
 main(void) {
     int err = 0;
 
+    err |= testNewDocNode();
     err |= testStandaloneWithEncoding();
     err |= testUnsupportedEncoding();
     err |= testNodeGetContent();
+    err |= testCFileIO();
+#ifdef LIBXML_OUTPUT_ENABLED
+    err |= testCtxtParseContent();
+#endif
 #ifdef LIBXML_SAX1_ENABLED
     err |= testBalancedChunk();
 #endif
 #ifdef LIBXML_PUSH_ENABLED
     err |= testHugePush();
     err |= testHugeEncodedChunk();
+#endif
 #ifdef LIBXML_HTML_ENABLED
+    err |= testHtmlIds();
+#ifdef LIBXML_PUSH_ENABLED
     err |= testHtmlPushWithEncoding();
 #endif
 #endif
@@ -413,6 +787,8 @@ main(void) {
 #ifdef LIBXML_WRITER_ENABLED
     err |= testWriterClose();
 #endif
+    err |= testBuildRelativeUri();
+    err |= testCharEncConvImpl();
 
     return err;
 }
diff --git a/testrecurse.c b/testrecurse.c
index 5aa2449d..478cb974 100644
--- a/testrecurse.c
+++ b/testrecurse.c
@@ -12,7 +12,7 @@
 
 #define XML_DEPRECATED_MEMBER
 
-#include "config.h"
+#include "libxml.h"
 #include <stdio.h>
 
 #include <stdlib.h>
@@ -145,9 +145,35 @@ static void globfree(glob_t *pglob) {
     }
 }
 
-#else
+#elif HAVE_DECL_GLOB
+
 #include <glob.h>
-#endif
+
+#else /* _WIN32, HAVE_DECL_GLOB */
+
+#define GLOB_DOOFFS 0
+
+typedef struct {
+      size_t gl_pathc;    /* Count of paths matched so far  */
+      char **gl_pathv;    /* List of matched pathnames.  */
+      size_t gl_offs;     /* Slots to reserve in 'gl_pathv'.  */
+} glob_t;
+
+static int
+glob(const char *pattern ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED,
+     int errfunc(const char *epath, int eerrno) ATTRIBUTE_UNUSED,
+     glob_t *pglob) {
+    pglob->gl_pathc = 0;
+    pglob->gl_pathv = NULL;
+
+    return(0);
+}
+
+static void
+globfree(glob_t *pglob ATTRIBUTE_UNUSED) {
+}
+
+#endif /* _WIN32, HAVE_DECL_GLOB */
 
 /************************************************************************
  *									*
diff --git a/threads.c b/threads.c
index 36347c2f..4a087562 100644
--- a/threads.c
+++ b/threads.c
@@ -11,6 +11,7 @@
 #include "libxml.h"
 
 #include <string.h>
+#include <stdarg.h>
 #include <stdlib.h>
 
 #include <libxml/threads.h>
@@ -27,97 +28,23 @@
 #include <note.h>
 #endif
 
+#include "private/cata.h"
 #include "private/dict.h"
 #include "private/enc.h"
+#include "private/error.h"
 #include "private/globals.h"
 #include "private/io.h"
 #include "private/memory.h"
 #include "private/threads.h"
 #include "private/xpath.h"
 
-#if defined(HAVE_POSIX_THREADS) && \
-    defined(__GLIBC__) && \
-    __GLIBC__ * 100 + __GLIBC_MINOR__ >= 234
-
-/*
- * The modern way available since glibc 2.32.
- *
- * The check above is for glibc 2.34 which merged the pthread symbols into
- * libc. Since we still allow linking without pthread symbols (see below),
- * this only works if pthread symbols are guaranteed to be available.
- */
-
-#include <sys/single_threaded.h>
-
-#define XML_IS_THREADED() (!__libc_single_threaded)
-#define XML_IS_NEVER_THREADED() 0
-
-#elif defined(HAVE_POSIX_THREADS) && \
-      defined(__GLIBC__) && \
-      defined(__GNUC__)
-
-/*
- * The traditional way to check for single-threaded applications with
- * glibc was to check whether the separate libpthread library is
- * linked in. This works by not linking libxml2 with libpthread (see
- * BASE_THREAD_LIBS in configure.ac and Makefile.am) and declaring
- * pthread functions as weak symbols.
- *
- * In glibc 2.34, the pthread symbols were moved from libpthread to libc,
- * so this doesn't work anymore.
- *
- * At some point, this legacy code and the BASE_THREAD_LIBS hack in
- * configure.ac can probably be removed.
- */
-
-#pragma weak pthread_mutex_init
-#pragma weak pthread_mutex_destroy
-#pragma weak pthread_mutex_lock
-#pragma weak pthread_mutex_unlock
-#pragma weak pthread_cond_init
-#pragma weak pthread_cond_destroy
-#pragma weak pthread_cond_wait
-#pragma weak pthread_equal
-#pragma weak pthread_self
-#pragma weak pthread_cond_signal
-
-#define XML_PTHREAD_WEAK
-#define XML_IS_THREADED() libxml_is_threaded
-#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
-
-static int libxml_is_threaded = -1;
-
-#else /* other POSIX platforms */
-
-#define XML_IS_THREADED() 1
-#define XML_IS_NEVER_THREADED() 0
-
-#endif
-
 /*
  * TODO: this module still uses malloc/free and not xmlMalloc/xmlFree
  *       to avoid some craziness since xmlMalloc/xmlFree may actually
  *       be hosted on allocated blocks needing them for the allocation ...
  */
 
-/*
- * xmlRMutex are reentrant mutual exception locks
- */
-struct _xmlRMutex {
-#ifdef HAVE_POSIX_THREADS
-    pthread_mutex_t lock;
-    unsigned int held;
-    unsigned int waiters;
-    pthread_t tid;
-    pthread_cond_t cv;
-#elif defined HAVE_WIN32_THREADS
-    CRITICAL_SECTION cs;
-#else
-    int empty;
-#endif
-};
-
-static xmlRMutexPtr xmlLibraryLock = NULL;
+static xmlRMutex xmlLibraryLock;
 
 /**
  * xmlInitMutex:
@@ -129,8 +56,7 @@ void
 xmlInitMutex(xmlMutexPtr mutex)
 {
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_NEVER_THREADED() == 0)
-        pthread_mutex_init(&mutex->lock, NULL);
+    pthread_mutex_init(&mutex->lock, NULL);
 #elif defined HAVE_WIN32_THREADS
     InitializeCriticalSection(&mutex->cs);
 #else
@@ -151,7 +77,8 @@ xmlNewMutex(void)
 {
     xmlMutexPtr tok;
 
-    if ((tok = malloc(sizeof(xmlMutex))) == NULL)
+    tok = malloc(sizeof(xmlMutex));
+    if (tok == NULL)
         return (NULL);
     xmlInitMutex(tok);
     return (tok);
@@ -167,8 +94,7 @@ void
 xmlCleanupMutex(xmlMutexPtr mutex)
 {
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_NEVER_THREADED() == 0)
-        pthread_mutex_destroy(&mutex->lock);
+    pthread_mutex_destroy(&mutex->lock);
 #elif defined HAVE_WIN32_THREADS
     DeleteCriticalSection(&mutex->cs);
 #else
@@ -208,8 +134,7 @@ xmlMutexLock(xmlMutexPtr tok)
      * This assumes that __libc_single_threaded won't change while the
      * lock is held.
      */
-    if (XML_IS_THREADED() != 0)
-        pthread_mutex_lock(&tok->lock);
+    pthread_mutex_lock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     EnterCriticalSection(&tok->cs);
 #endif
@@ -228,13 +153,26 @@ xmlMutexUnlock(xmlMutexPtr tok)
     if (tok == NULL)
         return;
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_THREADED() != 0)
-        pthread_mutex_unlock(&tok->lock);
+    pthread_mutex_unlock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     LeaveCriticalSection(&tok->cs);
 #endif
 }
 
+void
+xmlInitRMutex(xmlRMutexPtr tok) {
+    (void) tok;
+
+#ifdef HAVE_POSIX_THREADS
+    pthread_mutex_init(&tok->lock, NULL);
+    tok->held = 0;
+    tok->waiters = 0;
+    pthread_cond_init(&tok->cv, NULL);
+#elif defined HAVE_WIN32_THREADS
+    InitializeCriticalSection(&tok->cs);
+#endif
+}
+
 /**
  * xmlNewRMutex:
  *
@@ -250,19 +188,23 @@ xmlNewRMutex(void)
 {
     xmlRMutexPtr tok;
 
-    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
+    tok = malloc(sizeof(xmlRMutex));
+    if (tok == NULL)
         return (NULL);
+    xmlInitRMutex(tok);
+    return (tok);
+}
+
+void
+xmlCleanupRMutex(xmlRMutexPtr tok) {
+    (void) tok;
+
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_NEVER_THREADED() == 0) {
-        pthread_mutex_init(&tok->lock, NULL);
-        tok->held = 0;
-        tok->waiters = 0;
-        pthread_cond_init(&tok->cv, NULL);
-    }
+    pthread_mutex_destroy(&tok->lock);
+    pthread_cond_destroy(&tok->cv);
 #elif defined HAVE_WIN32_THREADS
-    InitializeCriticalSection(&tok->cs);
+    DeleteCriticalSection(&tok->cs);
 #endif
-    return (tok);
 }
 
 /**
@@ -273,18 +215,11 @@ xmlNewRMutex(void)
  * reentrant mutex.
  */
 void
-xmlFreeRMutex(xmlRMutexPtr tok ATTRIBUTE_UNUSED)
+xmlFreeRMutex(xmlRMutexPtr tok)
 {
     if (tok == NULL)
         return;
-#ifdef HAVE_POSIX_THREADS
-    if (XML_IS_NEVER_THREADED() == 0) {
-        pthread_mutex_destroy(&tok->lock);
-        pthread_cond_destroy(&tok->cv);
-    }
-#elif defined HAVE_WIN32_THREADS
-    DeleteCriticalSection(&tok->cs);
-#endif
+    xmlCleanupRMutex(tok);
     free(tok);
 }
 
@@ -300,9 +235,6 @@ xmlRMutexLock(xmlRMutexPtr tok)
     if (tok == NULL)
         return;
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_THREADED() == 0)
-        return;
-
     pthread_mutex_lock(&tok->lock);
     if (tok->held) {
         if (pthread_equal(tok->tid, pthread_self())) {
@@ -336,9 +268,6 @@ xmlRMutexUnlock(xmlRMutexPtr tok ATTRIBUTE_UNUSED)
     if (tok == NULL)
         return;
 #ifdef HAVE_POSIX_THREADS
-    if (XML_IS_THREADED() == 0)
-        return;
-
     pthread_mutex_lock(&tok->lock);
     tok->held--;
     if (tok->held == 0) {
@@ -376,8 +305,6 @@ xmlGetThreadId(void)
     pthread_t id;
     int ret;
 
-    if (XML_IS_THREADED() == 0)
-        return (0);
     id = pthread_self();
     /* horrible but preserves compat, see warning above */
     memcpy(&ret, &id, sizeof(ret));
@@ -398,7 +325,7 @@ xmlGetThreadId(void)
 void
 xmlLockLibrary(void)
 {
-    xmlRMutexLock(xmlLibraryLock);
+    xmlRMutexLock(&xmlLibraryLock);
 }
 
 /**
@@ -410,7 +337,7 @@ xmlLockLibrary(void)
 void
 xmlUnlockLibrary(void)
 {
-    xmlRMutexUnlock(xmlLibraryLock);
+    xmlRMutexUnlock(&xmlLibraryLock);
 }
 
 /**
@@ -437,6 +364,16 @@ xmlCleanupThreads(void)
 {
 }
 
+static void
+xmlInitThreadsInternal(void) {
+    xmlInitRMutex(&xmlLibraryLock);
+}
+
+static void
+xmlCleanupThreadsInternal(void) {
+    xmlCleanupRMutex(&xmlLibraryLock);
+}
+
 /************************************************************************
  *									*
  *			Library wide initialization			*
@@ -444,218 +381,142 @@ xmlCleanupThreads(void)
  ************************************************************************/
 
 static int xmlParserInitialized = 0;
-static int xmlParserInnerInitialized = 0;
-
 
 #ifdef HAVE_POSIX_THREADS
-static pthread_mutex_t global_init_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_once_t onceControl = PTHREAD_ONCE_INIT;
 #elif defined HAVE_WIN32_THREADS
-static volatile LPCRITICAL_SECTION global_init_lock = NULL;
+static INIT_ONCE onceControl = INIT_ONCE_STATIC_INIT;
+#else
+static int onceControl = 0;
 #endif
 
-/**
- * xmlGlobalInitMutexLock
- *
- * Makes sure that the global initialization mutex is initialized and
- * locks it.
- */
 static void
-xmlGlobalInitMutexLock(void) {
-#ifdef HAVE_POSIX_THREADS
-
-#ifdef XML_PTHREAD_WEAK
+xmlInitParserInternal(void) {
     /*
-     * This is somewhat unreliable since libpthread could be loaded
-     * later with dlopen() and threads could be created. But it's
-     * long-standing behavior and hard to work around.
+     * Note that the initialization code must not make memory allocations.
      */
-    if (libxml_is_threaded == -1)
-        libxml_is_threaded =
-            (pthread_mutex_init != NULL) &&
-            (pthread_mutex_destroy != NULL) &&
-            (pthread_mutex_lock != NULL) &&
-            (pthread_mutex_unlock != NULL) &&
-            (pthread_cond_init != NULL) &&
-            (pthread_cond_destroy != NULL) &&
-            (pthread_cond_wait != NULL) &&
-            /*
-             * pthread_equal can be inline, resuting in -Waddress warnings.
-             * Let's assume it's available if all the other functions are.
-             */
-            /* (pthread_equal != NULL) && */
-            (pthread_self != NULL) &&
-            (pthread_cond_signal != NULL);
+    xmlInitRandom(); /* Required by xmlInitGlobalsInternal */
+    xmlInitMemoryInternal();
+    xmlInitThreadsInternal();
+    xmlInitGlobalsInternal();
+    xmlInitDictInternal();
+    xmlInitEncodingInternal();
+#if defined(LIBXML_XPATH_ENABLED)
+    xmlInitXPathInternal();
 #endif
-
-    /* The mutex is statically initialized, so we just lock it. */
-    if (XML_IS_THREADED() != 0)
-        pthread_mutex_lock(&global_init_lock);
-
-#elif defined HAVE_WIN32_THREADS
-
-    LPCRITICAL_SECTION cs;
-
-    /* Create a new critical section */
-    if (global_init_lock == NULL) {
-        cs = malloc(sizeof(CRITICAL_SECTION));
-        if (cs == NULL) {
-            fprintf(stderr, "libxml2: xmlInitParser: out of memory\n");
-            abort();
-        }
-        InitializeCriticalSection(cs);
-
-        /* Swap it into the global_init_lock */
-#ifdef InterlockedCompareExchangePointer
-        InterlockedCompareExchangePointer((void **) &global_init_lock,
-                                          cs, NULL);
-#else /* Use older void* version */
-        InterlockedCompareExchange((void **) &global_init_lock,
-                                   (void *) cs, NULL);
-#endif /* InterlockedCompareExchangePointer */
-
-        /* If another thread successfully recorded its critical
-         * section in the global_init_lock then discard the one
-         * allocated by this thread. */
-        if (global_init_lock != cs) {
-            DeleteCriticalSection(cs);
-            free(cs);
-        }
-    }
-
-    /* Lock the chosen critical section */
-    EnterCriticalSection(global_init_lock);
-
+    xmlInitIOCallbacks();
+#ifdef LIBXML_CATALOG_ENABLED
+    xmlInitCatalogInternal();
 #endif
-}
 
-static void
-xmlGlobalInitMutexUnlock(void) {
-#ifdef HAVE_POSIX_THREADS
-    if (XML_IS_THREADED() != 0)
-        pthread_mutex_unlock(&global_init_lock);
-#elif defined HAVE_WIN32_THREADS
-    if (global_init_lock != NULL)
-	LeaveCriticalSection(global_init_lock);
-#endif
+    xmlParserInitialized = 1;
 }
 
-/**
- * xmlGlobalInitMutexDestroy
- *
- * Makes sure that the global initialization mutex is destroyed before
- * application termination.
- */
-static void
-xmlGlobalInitMutexDestroy(void) {
-#ifdef HAVE_POSIX_THREADS
-#elif defined HAVE_WIN32_THREADS
-    if (global_init_lock != NULL) {
-        DeleteCriticalSection(global_init_lock);
-        free(global_init_lock);
-        global_init_lock = NULL;
-    }
-#endif
+#if defined(HAVE_WIN32_THREADS)
+static BOOL WINAPI
+xmlInitParserWinWrapper(INIT_ONCE *initOnce ATTRIBUTE_UNUSED,
+                        void *parameter ATTRIBUTE_UNUSED,
+                        void **context ATTRIBUTE_UNUSED) {
+    xmlInitParserInternal();
+    return(TRUE);
 }
+#endif
 
 /**
  * xmlInitParser:
  *
  * Initialization function for the XML parser.
  *
- * Call once from the main thread before using the library in
- * multithreaded programs.
+ * For older versions, it's recommended to call this function once
+ * from the main thread before using the library in multithreaded
+ * programs.
+ *
+ * Since 2.14.0, there's no distinction between threads. It should
+ * be unnecessary to call this function.
  */
 void
 xmlInitParser(void) {
-    /*
-     * Note that the initialization code must not make memory allocations.
-     */
-    if (xmlParserInitialized != 0)
-        return;
-
-    xmlGlobalInitMutexLock();
-
-    if (xmlParserInnerInitialized == 0) {
-#if defined(_WIN32) && \
-    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
-    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
-        if (xmlFree == free)
-            atexit(xmlCleanupParser);
-#endif
-
-        xmlInitRandom(); /* Required by xmlInitGlobalsInternal */
-        xmlInitMemoryInternal();
-        xmlInitGlobalsInternal();
-        xmlInitDictInternal();
-        xmlInitEncodingInternal();
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
-        xmlInitXPathInternal();
-#endif
-        xmlInitIOCallbacks();
-
-        xmlParserInnerInitialized = 1;
+#ifdef HAVE_POSIX_THREADS
+    pthread_once(&onceControl, xmlInitParserInternal);
+#elif defined(HAVE_WIN32_THREADS)
+    InitOnceExecuteOnce(&onceControl, xmlInitParserWinWrapper, NULL, NULL);
+#else
+    if (onceControl == 0) {
+        xmlInitParserInternal();
+        onceControl = 1;
     }
-
-    xmlGlobalInitMutexUnlock();
-
-    xmlParserInitialized = 1;
+#endif
 }
 
 /**
  * xmlCleanupParser:
  *
- * This function name is somewhat misleading. It does not clean up
- * parser state, it cleans up memory allocated by the library itself.
- * It is a cleanup function for the XML library. It tries to reclaim all
- * related global memory allocated for the library processing.
- * It doesn't deallocate any document related memory. One should
- * call xmlCleanupParser() only when the process has finished using
- * the library and all XML/HTML documents built with it.
- * See also xmlInitParser() which has the opposite function of preparing
- * the library for operations.
+ * This function is named somewhat misleadingly. It does not clean up
+ * parser state but global memory allocated by the library itself.
  *
- * WARNING: if your application is multithreaded or has plugin support
- *          calling this may crash the application if another thread or
- *          a plugin is still using libxml2. It's sometimes very hard to
- *          guess if libxml2 is in use in the application, some libraries
- *          or plugins may use it without notice. In case of doubt abstain
- *          from calling this function or do it just before calling exit()
- *          to avoid leak reports from valgrind !
+ * Since 2.9.11, cleanup is performed automatically if a shared or
+ * dynamic libxml2 library is unloaded. This function should only
+ * be used to avoid false positives from memory leak checkers in
+ * static builds.
+ *
+ * WARNING: xmlCleanupParser assumes that all other threads that called
+ * libxml2 functions have terminated. No library calls must be made
+ * after calling this function. In general, THIS FUNCTION SHOULD ONLY
+ * BE CALLED RIGHT BEFORE THE WHOLE PROCESS EXITS.
  */
 void
 xmlCleanupParser(void) {
+    /*
+     * Unfortunately, some users call this function to fix memory
+     * leaks on unload with versions before 2.9.11. This can result
+     * in the library being reinitialized, so this use case must
+     * be supported.
+     */
     if (!xmlParserInitialized)
         return;
 
-    /* These functions can call xmlFree. */
-
     xmlCleanupCharEncodingHandlers();
 #ifdef LIBXML_CATALOG_ENABLED
     xmlCatalogCleanup();
+    xmlCleanupCatalogInternal();
 #endif
 #ifdef LIBXML_SCHEMAS_ENABLED
     xmlSchemaCleanupTypes();
     xmlRelaxNGCleanupTypes();
 #endif
 
-    /* These functions should never call xmlFree. */
-
     xmlCleanupDictInternal();
     xmlCleanupRandom();
     xmlCleanupGlobalsInternal();
+    xmlCleanupThreadsInternal();
+
     /*
-     * Must come last. On Windows, xmlCleanupGlobalsInternal can call
-     * xmlFree which uses xmlMemMutex in debug mode.
+     * Must come after all cleanup functions that call xmlFree which
+     * uses xmlMemMutex in debug mode.
      */
     xmlCleanupMemoryInternal();
 
-    xmlGlobalInitMutexDestroy();
-
     xmlParserInitialized = 0;
-    xmlParserInnerInitialized = 0;
+
+    /*
+     * This is a bit sketchy but should make reinitialization work.
+     */
+#ifdef HAVE_POSIX_THREADS
+    {
+        pthread_once_t tmp = PTHREAD_ONCE_INIT;
+        memcpy(&onceControl, &tmp, sizeof(tmp));
+    }
+#elif defined(HAVE_WIN32_THREADS)
+    {
+        INIT_ONCE tmp = INIT_ONCE_STATIC_INIT;
+        memcpy(&onceControl, &tmp, sizeof(tmp));
+    }
+#else
+    onceControl = 0;
+#endif
 }
 
-#if defined(HAVE_ATTRIBUTE_DESTRUCTOR) && \
+#if defined(HAVE_FUNC_ATTRIBUTE_DESTRUCTOR) && \
     !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
     !defined(LIBXML_STATIC) && \
     !defined(_WIN32)
@@ -670,4 +531,3 @@ xmlDestructor(void) {
         xmlCleanupParser();
 }
 #endif
-
diff --git a/genChRanges.py b/tools/genChRanges.py
similarity index 100%
rename from genChRanges.py
rename to tools/genChRanges.py
diff --git a/tools/genEscape.py b/tools/genEscape.py
new file mode 100755
index 00000000..67742cbd
--- /dev/null
+++ b/tools/genEscape.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+
+entities = [
+    [ '',   '&#xFFFD;' ],
+    [ '\t', '&#9;' ],
+    [ '\n', '&#10;' ],
+    [ '\r', '&#13;' ],
+    [ '"',  '&quot;' ],
+    [ '&',  '&amp;' ],
+    [ '<',  '&lt;' ],
+    [ '>',  '&gt;' ],
+]
+
+### xmlEscapeContent
+
+offset = [ None ] * 128
+pos = 0
+r = ''
+
+for rec in entities:
+    char, repl = rec
+
+    if char:
+        offset[ord(char)] = pos
+
+    if pos % 12 == 0: r += '\n    '
+    else: r += ' '
+    r += '%3d,' % len(repl)
+    pos += 1
+
+    for c in repl:
+        if pos % 12 == 0: r += '\n    '
+        else: r += ' '
+        r += "'%s'," % c
+        pos += 1
+
+print('static const char xmlEscapeContent[] = {%s\n};\n' % r)
+
+### xmlEscapeTab
+
+escape = '\r&<>'
+r = ''
+
+for i in range(0x80):
+
+    if chr(i) in escape:
+        v = offset[i]
+    elif i != 9 and i != 10 and i < 20:
+        v = 0
+    else:
+        v = -1
+
+    if i % 16 == 0: r += '\n    '
+    else: r += ' '
+    r += '%2d,' % v
+
+print('static const char xmlEscapeTab[128] = {%s\n};\n' % r)
+
+### xmlEscapeTabAttr
+
+escape = '\t\n\r"&<>'
+r = ''
+
+for i in range(0x80):
+
+    if chr(i) in escape:
+        v = offset[i]
+    elif i != 9 and i != 10 and i < 20:
+        v = 0
+    else:
+        v = -1
+
+    if i % 16 == 0: r += '\n    '
+    else: r += ' '
+    r += '%2d,' % v
+
+print('static const char xmlEscapeTabAttr[128] = {%s\n};\n' % r)
+
diff --git a/genUnicode.py b/tools/genUnicode.py
similarity index 100%
rename from genUnicode.py
rename to tools/genUnicode.py
diff --git a/gentest.py b/tools/gentest.py
similarity index 98%
rename from gentest.py
rename to tools/gentest.py
index 482d6830..fcdf2062 100755
--- a/gentest.py
+++ b/tools/gentest.py
@@ -20,7 +20,7 @@ else:
 # Modules we want to skip in API test
 #
 skipped_modules = [ "SAX", "xlink", "threads", "globals",
-  "xmlmemory", "xmlversion", "xmlexports", "nanoftp",
+  "xmlmemory", "xmlversion", "xmlexports", "xmlunicode", "nanoftp",
 ]
 
 #
@@ -79,15 +79,6 @@ function_defines = {
     "xmlAttrSerializeTxtContent": "LIBXML_OUTPUT_ENABLED",
     "xmlSAXParseFile": "LIBXML_SAX1_ENABLED",
     "xmlSAXParseEntity": "LIBXML_SAX1_ENABLED",
-    "xmlNewTextChild": "LIBXML_TREE_ENABLED",
-    "xmlNewDocRawNode": "LIBXML_TREE_ENABLED",
-    "xmlNewProp": "LIBXML_TREE_ENABLED",
-    "xmlReconciliateNs": "LIBXML_TREE_ENABLED",
-    "xmlValidateNCName": "LIBXML_TREE_ENABLED",
-    "xmlValidateNMToken": "LIBXML_TREE_ENABLED",
-    "xmlValidateName": "LIBXML_TREE_ENABLED",
-    "xmlNewChild": "LIBXML_TREE_ENABLED",
-    "xmlValidateQName": "LIBXML_TREE_ENABLED",
     "xmlSprintfElementContent": "LIBXML_OUTPUT_ENABLED",
     "xmlValidGetPotentialChildren" : "LIBXML_VALID_ENABLED",
     "xmlValidGetValidElements" : "LIBXML_VALID_ENABLED",
@@ -155,6 +146,8 @@ skipped_functions = [
 # Legacy
 "xmlCleanupPredefinedEntities", "xmlInitializePredefinedEntities",
 "xmlSetFeature", "xmlGetFeature", "xmlGetFeaturesList",
+# Shouldn't free result
+"xmlCtxtGetDict",
 ]
 
 #
diff --git a/tree.c b/tree.c
index 75f7569a..1b79b992 100644
--- a/tree.c
+++ b/tree.c
@@ -47,7 +47,12 @@
 #include "private/error.h"
 #include "private/tree.h"
 
-int __xmlRegisterCallbacks = 0;
+/*
+ * Internal variable indicating whether a callback has been registered
+ * for node creation/destruction. This avoids looking up thread-local
+ * data if no callback was ever registered.
+ */
+int xmlRegisterCallbacks = 0;
 
 /************************************************************************
  *									*
@@ -99,7 +104,6 @@ static int xmlCompressMode = 0;
  ************************************************************************/
 #include <libxml/hash.h>
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlGetEntityFromDtd:
  * @dtd:  A pointer to the DTD to search
@@ -142,7 +146,6 @@ xmlGetParameterEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {
     }
     return(NULL);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /************************************************************************
  *									*
@@ -183,7 +186,7 @@ xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
     lenp = strlen((char *) prefix);
 
     if ((memory == NULL) || (len < lenn + lenp + 2)) {
-	ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	ret = xmlMalloc(lenn + lenp + 2);
 	if (ret == NULL)
 	    return(NULL);
     } else {
@@ -418,7 +421,6 @@ try_complex:
     return(0);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlValidateQName:
  * @value: the value to check
@@ -657,7 +659,6 @@ try_complex:
 	return(1);
     return(0);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /************************************************************************
  *									*
@@ -665,41 +666,6 @@ try_complex:
  *									*
  ************************************************************************/
 
-/**
- * xmlSetBufferAllocationScheme:
- * @scheme:  allocation method to use
- *
- * Set the buffer allocation method.  Types are
- * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
- * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,
- *                             improves performance
- */
-void
-xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme) {
-    if ((scheme == XML_BUFFER_ALLOC_EXACT) ||
-        (scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
-        (scheme == XML_BUFFER_ALLOC_HYBRID))
-	xmlBufferAllocScheme = scheme;
-}
-
-/**
- * xmlGetBufferAllocationScheme:
- *
- * Types are
- * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
- * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,
- *                             improves performance
- * XML_BUFFER_ALLOC_HYBRID - use exact sizes on small strings to keep memory usage tight
- *                            in normal usage, and doubleit on large strings to avoid
- *                            pathological performance.
- *
- * Returns the current allocation scheme
- */
-xmlBufferAllocationScheme
-xmlGetBufferAllocationScheme(void) {
-    return(xmlBufferAllocScheme);
-}
-
 /**
  * xmlNewNs:
  * @node:  the element carrying the namespace (optional)
@@ -882,7 +848,7 @@ xmlNewDtd(xmlDocPtr doc, const xmlChar *name,
 	doc->extSubset = cur;
     cur->doc = doc;
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 
@@ -1005,7 +971,7 @@ xmlCreateIntSubset(xmlDocPtr doc, const xmlChar *name,
 	}
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 
@@ -1041,7 +1007,7 @@ xmlFreeDtd(xmlDtdPtr cur) {
     }
     if (cur->doc != NULL) dict = cur->doc->dict;
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
 
     if (cur->children != NULL) {
@@ -1122,7 +1088,7 @@ xmlNewDoc(const xmlChar *version) {
      */
     cur->charset = XML_CHAR_ENCODING_UTF8;
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 }
@@ -1144,7 +1110,7 @@ xmlFreeDoc(xmlDocPtr cur) {
 
     dict = cur->dict;
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
 
     /*
@@ -1213,15 +1179,14 @@ xmlNodeParseContentInternal(const xmlDoc *doc, xmlNodePtr parent,
     else
         remaining = len;
 
-    if (value == NULL)
+    if ((value == NULL) || (value[0] == 0))
         goto done;
 
     cur = value;
 
-    buf = xmlBufCreateSize(64);
+    buf = xmlBufCreate(50);
     if (buf == NULL)
         return(-1);
-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 
     q = cur;
     while ((remaining > 0) && (*cur != 0)) {
@@ -1479,8 +1444,8 @@ xmlNodeParseContent(xmlNodePtr node, const xmlChar *content, int len) {
  *
  * See xmlStringGetNodeList.
  *
- * Returns a pointer to the first child or NULL if a memory
- * allocation failed.
+ * Returns a pointer to the first child or NULL if the value if empty
+ * or a memory allocation failed.
  */
 xmlNodePtr
 xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len) {
@@ -1506,8 +1471,8 @@ xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len) {
  * undeclared entities will be ignored silently with unspecified
  * results.
  *
- * Returns a pointer to the first child or NULL if a memory
- * allocation failed.
+ * Returns a pointer to the first child or NULL if the value if empty
+ * or a memory allocation failed.
  */
 xmlNodePtr
 xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {
@@ -1542,7 +1507,7 @@ xmlNodeListGetStringInternal(xmlDocPtr doc, const xmlNode *node, int escMode) {
         return(xmlStrdup(node->content));
     }
 
-    buf = xmlBufCreateSize(64);
+    buf = xmlBufCreate(50);
     if (buf == NULL)
         return(NULL);
 
@@ -1556,11 +1521,11 @@ xmlNodeListGetStringInternal(xmlDocPtr doc, const xmlNode *node, int escMode) {
                     xmlChar *encoded;
 
                     if (escMode == 1)
-                        encoded = xmlEncodeEntitiesReentrant(doc,
-                                                             node->content);
+                        encoded = xmlEncodeEntitiesInternal(doc, node->content,
+                                                            0);
                     else if (escMode == 2)
-                        encoded = xmlEncodeAttributeEntities(doc,
-                                                             node->content);
+                        encoded = xmlEncodeEntitiesInternal(doc, node->content,
+                                                            XML_ESCAPE_ATTR);
                     else
                         encoded = xmlEncodeSpecialChars(doc, node->content);
                     if (encoded == NULL)
@@ -1594,11 +1559,11 @@ error:
 /**
  * xmlNodeListGetString:
  * @doc:  a document (optional)
- * @list:  a node list of attribute children (optional)
+ * @list:  a node list of attribute children
  * @inLine:  whether entity references are substituted
  *
  * Serializes attribute children (text and entity reference nodes)
- * into a string. An empty list produces an empty string.
+ * into a string.
  *
  * If @inLine is true, entity references will be substituted.
  * Otherwise, entity references will be kept and special characters
@@ -1612,11 +1577,14 @@ xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
 {
     int escMode;
 
+    /* backward compatibility */
+    if (list == NULL)
+        return(NULL);
+
     if (inLine) {
         escMode = 0;
     } else {
-        if ((list != NULL) &&
-            (list->parent != NULL) &&
+        if ((list->parent != NULL) &&
             (list->parent->type == XML_ATTRIBUTE_NODE))
             escMode = 2;
         else
@@ -1626,15 +1594,14 @@ xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
     return(xmlNodeListGetStringInternal(doc, list, escMode));
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNodeListGetRawString:
  * @doc:  a document (optional)
- * @list:  a node list of attribute children (optional)
+ * @list:  a node list of attribute children
  * @inLine:  whether entity references are substituted
  *
  * Serializes attribute children (text and entity reference nodes)
- * into a string. An empty list produces an empty string.
+ * into a string.
  *
  * If @inLine is true, entity references will be substituted.
  * Otherwise, entity references will be kept and special characters
@@ -1646,9 +1613,13 @@ xmlChar *
 xmlNodeListGetRawString(const xmlDoc *doc, const xmlNode *list, int inLine)
 {
     int escMode = inLine ? 0 : 3;
+
+    /* backward compatibility */
+    if (list == NULL)
+        return(NULL);
+
     return(xmlNodeListGetStringInternal((xmlDocPtr) doc, list, escMode));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 static xmlAttrPtr
 xmlNewPropInternal(xmlNodePtr node, xmlNsPtr ns,
@@ -1739,7 +1710,7 @@ xmlNewPropInternal(xmlNodePtr node, xmlNsPtr ns,
         }
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
         xmlRegisterNodeDefaultValue((xmlNodePtr) cur);
     return (cur);
 
@@ -1748,8 +1719,6 @@ error:
     return(NULL);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlNewProp:
  * @node:  the parent node (optional)
@@ -1776,7 +1745,6 @@ xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {
 
 	return xmlNewPropInternal(node, NULL, name, value, 0);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNewNsProp:
@@ -1877,7 +1845,7 @@ xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {
             goto error;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 
@@ -1916,7 +1884,7 @@ xmlFreeProp(xmlAttrPtr cur) {
 
     if (cur->doc != NULL) dict = cur->doc->dict;
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
 
     /* Check for ID removal -> leading to invalid references ! */
@@ -2012,7 +1980,7 @@ xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
             goto error;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
     return(cur);
 
@@ -2099,7 +2067,7 @@ xmlNewElem(xmlDocPtr doc, xmlNsPtr ns, const xmlChar *name,
         }
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
 
     return(cur);
@@ -2198,7 +2166,6 @@ xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
     return(cur);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNewDocRawNode:
  * @doc:  the target document
@@ -2262,11 +2229,10 @@ xmlNewDocFragment(xmlDocPtr doc) {
 
     cur->doc = doc;
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNewText:
@@ -2299,7 +2265,7 @@ xmlNewText(const xmlChar *content) {
             goto error;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 
@@ -2308,7 +2274,6 @@ error:
     return(NULL);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNewTextChild:
  * @parent:  the parent node
@@ -2370,7 +2335,6 @@ xmlNewTextChild(xmlNodePtr parent, xmlNsPtr ns,
 
     return(cur);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNewEntityRef:
@@ -2402,7 +2366,7 @@ xmlNewEntityRef(xmlDocPtr doc, xmlChar *name) {
     cur->doc = doc;
     cur->name = name;
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
 
     return(cur);
@@ -2503,7 +2467,7 @@ xmlNewReference(const xmlDoc *doc, const xmlChar *name) {
 	cur->last = (xmlNodePtr) ent;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 
@@ -2563,7 +2527,7 @@ xmlNewTextLen(const xmlChar *content, int len) {
         }
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 }
@@ -2619,7 +2583,7 @@ xmlNewComment(const xmlChar *content) {
             goto error;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 
@@ -2661,7 +2625,7 @@ xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {
         }
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue(cur);
     return(cur);
 }
@@ -2920,7 +2884,6 @@ xmlSetListDoc(xmlNodePtr list, xmlDocPtr doc) {
     return(ret);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlNewChild:
  * @parent:  the parent node
@@ -2984,7 +2947,6 @@ xmlNewChild(xmlNodePtr parent, xmlNsPtr ns,
 
     return(cur);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 static void
 xmlTextSetContent(xmlNodePtr text, xmlChar *content) {
@@ -3177,8 +3139,6 @@ xmlAddNextSibling(xmlNodePtr prev, xmlNodePtr cur) {
     return(xmlInsertNode(prev->doc, cur, prev->parent, prev, prev->next, 0));
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
 /**
  * xmlAddPrevSibling:
  * @next:  the target node
@@ -3209,7 +3169,6 @@ xmlAddPrevSibling(xmlNodePtr next, xmlNodePtr cur) {
 
     return(xmlInsertNode(next->doc, cur, next->parent, next->prev, next, 0));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlAddSibling:
@@ -3428,7 +3387,6 @@ xmlGetLastChild(const xmlNode *parent) {
     return(parent->last);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /*
  * 5 interfaces from DOM ElementTraversal
  */
@@ -3613,8 +3571,6 @@ xmlNextElementSibling(xmlNodePtr node) {
     return(NULL);
 }
 
-#endif /* LIBXML_TREE_ENABLED */
-
 /**
  * xmlFreeNodeList:
  * @cur:  the first node in the list
@@ -3657,7 +3613,7 @@ xmlFreeNodeList(xmlNodePtr cur) {
             cur->prev = NULL;
             cur->next = NULL;
         } else {
-	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+	    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 		xmlDeregisterNodeDefaultValue(cur);
 
 	    if (((cur->type == XML_ELEMENT_NODE) ||
@@ -3731,17 +3687,16 @@ xmlFreeNode(xmlNodePtr cur) {
 	xmlFreeProp((xmlAttrPtr) cur);
 	return;
     }
+    if (cur->type == XML_ENTITY_DECL) {
+        xmlFreeEntity((xmlEntityPtr) cur);
+        return;
+    }
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue(cur);
 
     if (cur->doc != NULL) dict = cur->doc->dict;
 
-    if (cur->type == XML_ENTITY_DECL) {
-        xmlEntityPtr ent = (xmlEntityPtr) cur;
-	DICT_FREE(ent->SystemID);
-	DICT_FREE(ent->ExternalID);
-    }
     if ((cur->children != NULL) &&
 	(cur->type != XML_ENTITY_REF_NODE))
 	xmlFreeNodeList(cur->children);
@@ -3840,7 +3795,6 @@ xmlUnlinkNode(xmlNodePtr cur) {
     xmlUnlinkNodeInternal(cur);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 /**
  * xmlReplaceNode:
  * @old:  the old node
@@ -3902,7 +3856,6 @@ xmlReplaceNode(xmlNodePtr old, xmlNodePtr cur) {
     old->parent = NULL;
     return(old);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /************************************************************************
  *									*
@@ -4060,7 +4013,6 @@ xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {
      */
     if ((target != NULL) && (cur != NULL) &&
 	(target->doc != NULL) && (cur->doc != NULL) &&
-	(cur->doc->ids != NULL) &&
         (cur->parent != NULL) &&
         (cur->children != NULL)) {
         int res = xmlIsID(cur->doc, cur->parent, cur);
@@ -4196,9 +4148,7 @@ xmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,
 
         case XML_DOCUMENT_NODE:
         case XML_HTML_DOCUMENT_NODE:
-#ifdef LIBXML_TREE_ENABLED
 	    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));
-#endif /* LIBXML_TREE_ENABLED */
         default:
             return(NULL);
     }
@@ -4349,7 +4299,7 @@ xmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,
     }
 
 out:
-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
 	xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
     return(ret);
 
@@ -4380,7 +4330,6 @@ xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {
     while (node != NULL) {
         xmlNodePtr next = node->next;
 
-#ifdef LIBXML_TREE_ENABLED
 	if (node->type == XML_DTD_NODE ) {
 	    if (doc == NULL) {
 		node = next;
@@ -4418,7 +4367,6 @@ xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {
                 q->prev = NULL;
 	    }
 	} else
-#endif /* LIBXML_TREE_ENABLED */
 	    q = xmlStaticCopyNode(node, doc, parent, 1);
 	if (q == NULL) goto error;
 	if (ret == NULL) {
@@ -4518,7 +4466,6 @@ xmlNodePtr xmlCopyNodeList(xmlNodePtr node) {
     return(ret);
 }
 
-#if defined(LIBXML_TREE_ENABLED)
 /**
  * xmlCopyDtd:
  * @dtd:  the DTD
@@ -4624,9 +4571,7 @@ error:
     xmlFreeDtd(ret);
     return(NULL);
 }
-#endif
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlCopyDoc:
  * @doc:  the document
@@ -4668,7 +4613,6 @@ xmlCopyDoc(xmlDocPtr doc, int recursive) {
 
     ret->last = NULL;
     ret->children = NULL;
-#ifdef LIBXML_TREE_ENABLED
     if (doc->intSubset != NULL) {
         ret->intSubset = xmlCopyDtd(doc->intSubset);
 	if (ret->intSubset == NULL)
@@ -4676,7 +4620,6 @@ xmlCopyDoc(xmlDocPtr doc, int recursive) {
         /* Can't fail on DTD */
 	xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);
     }
-#endif
     if (doc->oldNs != NULL) {
         ret->oldNs = xmlCopyNamespaceList(doc->oldNs);
         if (ret->oldNs == NULL)
@@ -4703,7 +4646,6 @@ error:
     xmlFreeDoc(ret);
     return(NULL);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /************************************************************************
  *									*
@@ -4777,7 +4719,6 @@ xmlGetLineNo(const xmlNode *node)
     return(xmlGetLineNoInternal(node, 0));
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
 /**
  * xmlGetNodePath:
  * @node: a node
@@ -4803,10 +4744,10 @@ xmlGetNodePath(const xmlNode *node)
         return (NULL);
 
     buf_len = 500;
-    buffer = (xmlChar *) xmlMallocAtomic(buf_len);
+    buffer = xmlMalloc(buf_len);
     if (buffer == NULL)
         return (NULL);
-    buf = (xmlChar *) xmlMallocAtomic(buf_len);
+    buf = xmlMalloc(buf_len);
     if (buf == NULL) {
         xmlFree(buffer);
         return (NULL);
@@ -5019,7 +4960,6 @@ xmlGetNodePath(const xmlNode *node)
     xmlFree(buf);
     return (buffer);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlDocGetRootElement:
@@ -5044,7 +4984,6 @@ xmlDocGetRootElement(const xmlDoc *doc) {
     return(ret);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 /**
  * xmlDocSetRootElement:
  * @doc:  the document
@@ -5090,9 +5029,7 @@ xmlDocSetRootElement(xmlDocPtr doc, xmlNodePtr root) {
     }
     return(old);
 }
-#endif
 
-#if defined(LIBXML_TREE_ENABLED)
 /**
  * xmlNodeSetLang:
  * @cur:  the node being changed
@@ -5122,7 +5059,6 @@ xmlNodeSetLang(xmlNodePtr cur, const xmlChar *lang) {
 
     return(0);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNodeGetLang:
@@ -5157,7 +5093,6 @@ xmlNodeGetLang(const xmlNode *cur) {
 }
 
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNodeSetSpacePreserve:
  * @cur:  the node being changed
@@ -5194,7 +5129,6 @@ xmlNodeSetSpacePreserve(xmlNodePtr cur, int val) {
 
     return(0);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNodeGetSpacePreserve:
@@ -5237,7 +5171,6 @@ xmlNodeGetSpacePreserve(const xmlNode *cur) {
     return(-1);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNodeSetName:
  * @cur:  the node being changed
@@ -5283,9 +5216,7 @@ xmlNodeSetName(xmlNodePtr cur, const xmlChar *name) {
         ((dict == NULL) || (!xmlDictOwns(dict, oldName))))
         xmlFree((xmlChar *) oldName);
 }
-#endif
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
 /**
  * xmlNodeSetBase:
  * @cur:  the node being changed
@@ -5340,7 +5271,6 @@ xmlNodeSetBase(xmlNodePtr cur, const xmlChar* uri) {
 
     return(0);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNodeGetBaseSafe:
@@ -5498,13 +5428,13 @@ int
 xmlNodeBufGetContent(xmlBufferPtr buffer, const xmlNode *cur)
 {
     xmlBufPtr buf;
-    int ret;
+    int ret1, ret2;
 
     if ((cur == NULL) || (buffer == NULL)) return(-1);
     buf = xmlBufFromBuffer(buffer);
-    ret = xmlBufGetNodeContent(buf, cur);
-    buffer = xmlBufBackToBuffer(buf);
-    if ((ret < 0) || (buffer == NULL))
+    ret1 = xmlBufGetNodeContent(buf, cur);
+    ret2 = xmlBufBackToBuffer(buf, buffer);
+    if ((ret1 < 0) || (ret2 < 0))
         return(-1);
     return(0);
 }
@@ -5686,10 +5616,9 @@ xmlNodeGetContent(const xmlNode *cur)
             return(NULL);
     }
 
-    buf = xmlBufCreateSize(64);
+    buf = xmlBufCreate(50);
     if (buf == NULL)
         return (NULL);
-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
     xmlBufGetNodeContent(buf, cur);
     ret = xmlBufDetach(buf);
     xmlBufFree(buf);
@@ -5764,7 +5693,6 @@ xmlNodeSetContent(xmlNodePtr cur, const xmlChar *content) {
     return(xmlNodeSetContentInternal(cur, content, -1));
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlNodeSetContentLen:
  * @cur:  the node being modified
@@ -5779,7 +5707,6 @@ int
 xmlNodeSetContentLen(xmlNodePtr cur, const xmlChar *content, int len) {
     return(xmlNodeSetContentInternal(cur, content, len));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 /**
  * xmlNodeAddContentLen:
@@ -5873,7 +5800,6 @@ xmlTextMerge(xmlNodePtr first, xmlNodePtr second) {
     return(first);
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlGetNsListSafe:
  * @doc:  the document
@@ -5963,7 +5889,6 @@ xmlGetNsList(const xmlDoc *doc, const xmlNode *node)
     xmlGetNsListSafe(doc, node, &ret);
     return(ret);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 static xmlNsPtr
 xmlNewXmlNs(void) {
@@ -6343,8 +6268,6 @@ xmlNewReconciledNs(xmlNodePtr tree, xmlNsPtr ns) {
     return(def);
 }
 
-#ifdef LIBXML_TREE_ENABLED
-
 typedef struct {
     xmlNsPtr oldNs;
     xmlNsPtr newNs;
@@ -6503,7 +6426,6 @@ xmlReconciliateNs(xmlDocPtr doc, xmlNodePtr tree) {
 	xmlFree(cache);
     return(ret);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 static xmlAttrPtr
 xmlGetPropNodeInternal(const xmlNode *node, const xmlChar *name,
@@ -6545,7 +6467,6 @@ xmlGetPropNodeInternal(const xmlNode *node, const xmlChar *name,
 	}
     }
 
-#ifdef LIBXML_TREE_ENABLED
     if (! useDTD)
 	return(NULL);
     /*
@@ -6632,7 +6553,7 @@ xmlGetPropNodeInternal(const xmlNode *node, const xmlChar *name,
 	if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
 	    return((xmlAttrPtr) attrDecl);
     }
-#endif /* LIBXML_TREE_ENABLED */
+
     return(NULL);
 }
 
@@ -6845,7 +6766,6 @@ xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
     return(xmlGetPropNodeValueInternal(prop));
 }
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 /**
  * xmlUnsetProp:
  * @node:  the node
@@ -6888,9 +6808,7 @@ xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name) {
     xmlFreeProp(prop);
     return(0);
 }
-#endif
 
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
 /**
  * xmlSetProp:
  * @node:  the node
@@ -7004,8 +6922,6 @@ xmlSetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name,
     return(xmlNewPropInternal(node, ns, name, value, 0));
 }
 
-#endif /* LIBXML_TREE_ENABLED */
-
 /**
  * xmlNodeIsText:
  * @node:  the node
@@ -7075,650 +6991,6 @@ xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len) {
     return(xmlTextAddContent(node, content, len));
 }
 
-/************************************************************************
- *									*
- *			Output : to a FILE or in memory			*
- *									*
- ************************************************************************/
-
-/**
- * xmlBufferCreate:
- *
- * routine to create an XML buffer.
- * returns the new structure.
- */
-xmlBufferPtr
-xmlBufferCreate(void) {
-    xmlBufferPtr ret;
-
-    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));
-    if (ret == NULL)
-        return(NULL);
-    ret->use = 0;
-    ret->size = xmlDefaultBufferSize;
-    ret->alloc = xmlBufferAllocScheme;
-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
-    if (ret->content == NULL) {
-	xmlFree(ret);
-        return(NULL);
-    }
-    ret->content[0] = 0;
-    ret->contentIO = NULL;
-    return(ret);
-}
-
-/**
- * xmlBufferCreateSize:
- * @size: initial size of buffer
- *
- * routine to create an XML buffer.
- * returns the new structure.
- */
-xmlBufferPtr
-xmlBufferCreateSize(size_t size) {
-    xmlBufferPtr ret;
-
-    if (size >= UINT_MAX)
-        return(NULL);
-    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));
-    if (ret == NULL)
-        return(NULL);
-    ret->use = 0;
-    ret->alloc = xmlBufferAllocScheme;
-    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
-    if (ret->size){
-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
-        if (ret->content == NULL) {
-            xmlFree(ret);
-            return(NULL);
-        }
-        ret->content[0] = 0;
-    } else
-	ret->content = NULL;
-    ret->contentIO = NULL;
-    return(ret);
-}
-
-/**
- * xmlBufferDetach:
- * @buf:  the buffer
- *
- * Remove the string contained in a buffer and gie it back to the
- * caller. The buffer is reset to an empty content.
- * This doesn't work with immutable buffers as they can't be reset.
- *
- * Returns the previous string contained by the buffer.
- */
-xmlChar *
-xmlBufferDetach(xmlBufferPtr buf) {
-    xmlChar *ret;
-
-    if (buf == NULL)
-        return(NULL);
-
-    ret = buf->content;
-    buf->content = NULL;
-    buf->size = 0;
-    buf->use = 0;
-
-    return ret;
-}
-
-
-/**
- * xmlBufferCreateStatic:
- * @mem: the memory area
- * @size:  the size in byte
- *
- * Returns an XML buffer initialized with bytes.
- */
-xmlBufferPtr
-xmlBufferCreateStatic(void *mem, size_t size) {
-    xmlBufferPtr buf = xmlBufferCreateSize(size);
-
-    xmlBufferAdd(buf, mem, size);
-    return(buf);
-}
-
-/**
- * xmlBufferSetAllocationScheme:
- * @buf:  the buffer to tune
- * @scheme:  allocation scheme to use
- *
- * Sets the allocation scheme for this buffer
- */
-void
-xmlBufferSetAllocationScheme(xmlBufferPtr buf,
-                             xmlBufferAllocationScheme scheme) {
-    if (buf == NULL) {
-        return;
-    }
-    if (buf->alloc == XML_BUFFER_ALLOC_IO) return;
-    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
-        (scheme == XML_BUFFER_ALLOC_EXACT) ||
-        (scheme == XML_BUFFER_ALLOC_HYBRID))
-	buf->alloc = scheme;
-}
-
-/**
- * xmlBufferFree:
- * @buf:  the buffer to free
- *
- * Frees an XML buffer. It frees both the content and the structure which
- * encapsulate it.
- */
-void
-xmlBufferFree(xmlBufferPtr buf) {
-    if (buf == NULL) {
-	return;
-    }
-
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
-        (buf->contentIO != NULL)) {
-        xmlFree(buf->contentIO);
-    } else if (buf->content != NULL) {
-        xmlFree(buf->content);
-    }
-    xmlFree(buf);
-}
-
-/**
- * xmlBufferEmpty:
- * @buf:  the buffer
- *
- * empty a buffer.
- */
-void
-xmlBufferEmpty(xmlBufferPtr buf) {
-    if (buf == NULL) return;
-    if (buf->content == NULL) return;
-    buf->use = 0;
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        size_t start_buf = buf->content - buf->contentIO;
-
-	buf->size += start_buf;
-        buf->content = buf->contentIO;
-        buf->content[0] = 0;
-    } else {
-        buf->content[0] = 0;
-    }
-}
-
-/**
- * xmlBufferShrink:
- * @buf:  the buffer to dump
- * @len:  the number of xmlChar to remove
- *
- * Remove the beginning of an XML buffer.
- *
- * Returns the number of #xmlChar removed, or -1 in case of failure.
- */
-int
-xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {
-    if (buf == NULL) return(-1);
-    if (len == 0) return(0);
-    if (len > buf->use) return(-1);
-
-    buf->use -= len;
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-	/*
-	 * we just move the content pointer, but also make sure
-	 * the perceived buffer size has shrunk accordingly
-	 */
-        buf->content += len;
-	buf->size -= len;
-
-        /*
-	 * sometimes though it maybe be better to really shrink
-	 * on IO buffers
-	 */
-	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-	    size_t start_buf = buf->content - buf->contentIO;
-	    if (start_buf >= buf->size) {
-		memmove(buf->contentIO, &buf->content[0], buf->use);
-		buf->content = buf->contentIO;
-		buf->content[buf->use] = 0;
-		buf->size += start_buf;
-	    }
-	}
-    } else {
-	memmove(buf->content, &buf->content[len], buf->use);
-	buf->content[buf->use] = 0;
-    }
-    return(len);
-}
-
-/**
- * xmlBufferGrow:
- * @buf:  the buffer
- * @len:  the minimum free size to allocate
- *
- * Grow the available space of an XML buffer.
- *
- * Returns the new available space or -1 in case of error
- */
-int
-xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {
-    unsigned int size;
-    xmlChar *newbuf;
-
-    if (buf == NULL) return(-1);
-
-    if (len < buf->size - buf->use)
-        return(0);
-    if (len >= UINT_MAX - buf->use)
-        return(-1);
-
-    if (buf->size > (size_t) len) {
-        size = buf->size > UINT_MAX / 2 ? UINT_MAX : buf->size * 2;
-    } else {
-        size = buf->use + len;
-        size = size > UINT_MAX - 100 ? UINT_MAX : size + 100;
-    }
-
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        size_t start_buf = buf->content - buf->contentIO;
-
-	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
-	if (newbuf == NULL)
-	    return(-1);
-	buf->contentIO = newbuf;
-	buf->content = newbuf + start_buf;
-    } else {
-	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
-	if (newbuf == NULL)
-	    return(-1);
-	buf->content = newbuf;
-    }
-    buf->size = size;
-    return(buf->size - buf->use - 1);
-}
-
-/**
- * xmlBufferDump:
- * @file:  the file output
- * @buf:  the buffer to dump
- *
- * Dumps an XML buffer to  a FILE *.
- * Returns the number of #xmlChar written
- */
-int
-xmlBufferDump(FILE *file, xmlBufferPtr buf) {
-    size_t ret;
-
-    if (buf == NULL) {
-	return(0);
-    }
-    if (buf->content == NULL) {
-	return(0);
-    }
-    if (file == NULL)
-	file = stdout;
-    ret = fwrite(buf->content, 1, buf->use, file);
-    return(ret > INT_MAX ? INT_MAX : ret);
-}
-
-/**
- * xmlBufferContent:
- * @buf:  the buffer
- *
- * Function to extract the content of a buffer
- *
- * Returns the internal content
- */
-
-const xmlChar *
-xmlBufferContent(const xmlBuffer *buf)
-{
-    if(!buf)
-        return NULL;
-
-    return buf->content;
-}
-
-/**
- * xmlBufferLength:
- * @buf:  the buffer
- *
- * Function to get the length of a buffer
- *
- * Returns the length of data in the internal content
- */
-
-int
-xmlBufferLength(const xmlBuffer *buf)
-{
-    if(!buf)
-        return 0;
-
-    return buf->use;
-}
-
-/**
- * xmlBufferResize:
- * @buf:  the buffer to resize
- * @size:  the desired size
- *
- * Resize a buffer to accommodate minimum size of @size.
- *
- * Returns  0 in case of problems, 1 otherwise
- */
-int
-xmlBufferResize(xmlBufferPtr buf, unsigned int size)
-{
-    unsigned int newSize;
-    xmlChar* rebuf = NULL;
-    size_t start_buf;
-
-    if (buf == NULL)
-        return(0);
-
-    /* Don't resize if we don't have to */
-    if (size < buf->size)
-        return 1;
-
-    if (size > UINT_MAX - 10)
-        return 0;
-
-    /* figure out new size */
-    switch (buf->alloc){
-	case XML_BUFFER_ALLOC_IO:
-	case XML_BUFFER_ALLOC_DOUBLEIT:
-	    /*take care of empty case*/
-            if (buf->size == 0)
-                newSize = size + 10;
-            else
-                newSize = buf->size;
-	    while (size > newSize) {
-	        if (newSize > UINT_MAX / 2)
-	            return 0;
-	        newSize *= 2;
-	    }
-	    break;
-	case XML_BUFFER_ALLOC_EXACT:
-	    newSize = size + 10;
-	    break;
-        case XML_BUFFER_ALLOC_HYBRID:
-            if (buf->use < BASE_BUFFER_SIZE)
-                newSize = size;
-            else {
-                newSize = buf->size;
-                while (size > newSize) {
-                    if (newSize > UINT_MAX / 2)
-                        return 0;
-                    newSize *= 2;
-                }
-            }
-            break;
-
-	default:
-	    newSize = size + 10;
-	    break;
-    }
-
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        start_buf = buf->content - buf->contentIO;
-
-        if (start_buf > newSize) {
-	    /* move data back to start */
-	    memmove(buf->contentIO, buf->content, buf->use);
-	    buf->content = buf->contentIO;
-	    buf->content[buf->use] = 0;
-	    buf->size += start_buf;
-	} else {
-	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
-	    if (rebuf == NULL)
-		return 0;
-	    buf->contentIO = rebuf;
-	    buf->content = rebuf + start_buf;
-	}
-    } else {
-	if (buf->content == NULL) {
-	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
-	    buf->use = 0;
-	    rebuf[buf->use] = 0;
-	} else if (buf->size - buf->use < 100) {
-	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
-        } else {
-	    /*
-	     * if we are reallocating a buffer far from being full, it's
-	     * better to make a new allocation and copy only the used range
-	     * and free the old one.
-	     */
-	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
-	    if (rebuf != NULL) {
-		memcpy(rebuf, buf->content, buf->use);
-		xmlFree(buf->content);
-		rebuf[buf->use] = 0;
-	    }
-	}
-	if (rebuf == NULL)
-	    return 0;
-	buf->content = rebuf;
-    }
-    buf->size = newSize;
-
-    return 1;
-}
-
-/**
- * xmlBufferAdd:
- * @buf:  the buffer to dump
- * @str:  the #xmlChar string
- * @len:  the number of #xmlChar to add
- *
- * Add a string range to an XML buffer. if len == -1, the length of
- * str is recomputed.
- *
- * Returns 0 successful, a positive error code number otherwise
- *         and -1 in case of internal or API error.
- */
-int
-xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {
-    unsigned int needSize;
-
-    if ((str == NULL) || (buf == NULL)) {
-	return -1;
-    }
-    if (len < -1) {
-	return -1;
-    }
-    if (len == 0) return 0;
-
-    if (len < 0)
-        len = xmlStrlen(str);
-
-    if (len < 0) return -1;
-    if (len == 0) return 0;
-
-    /* Note that both buf->size and buf->use can be zero here. */
-    if ((unsigned) len >= buf->size - buf->use) {
-        if ((unsigned) len >= UINT_MAX - buf->use)
-            return XML_ERR_NO_MEMORY;
-        needSize = buf->use + len + 1;
-        if (!xmlBufferResize(buf, needSize))
-            return XML_ERR_NO_MEMORY;
-    }
-
-    memmove(&buf->content[buf->use], str, len);
-    buf->use += len;
-    buf->content[buf->use] = 0;
-    return 0;
-}
-
-/**
- * xmlBufferAddHead:
- * @buf:  the buffer
- * @str:  the #xmlChar string
- * @len:  the number of #xmlChar to add
- *
- * Add a string range to the beginning of an XML buffer.
- * if len == -1, the length of @str is recomputed.
- *
- * Returns 0 successful, a positive error code number otherwise
- *         and -1 in case of internal or API error.
- */
-int
-xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {
-    unsigned int needSize;
-
-    if (buf == NULL)
-        return(-1);
-    if (str == NULL) {
-	return -1;
-    }
-    if (len < -1) {
-	return -1;
-    }
-    if (len == 0) return 0;
-
-    if (len < 0)
-        len = xmlStrlen(str);
-
-    if (len <= 0) return -1;
-
-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
-        size_t start_buf = buf->content - buf->contentIO;
-
-	if (start_buf > (unsigned int) len) {
-	    /*
-	     * We can add it in the space previously shrunk
-	     */
-	    buf->content -= len;
-            memmove(&buf->content[0], str, len);
-	    buf->use += len;
-	    buf->size += len;
-            buf->content[buf->use] = 0;
-	    return(0);
-	}
-    }
-    /* Note that both buf->size and buf->use can be zero here. */
-    if ((unsigned) len >= buf->size - buf->use) {
-        if ((unsigned) len >= UINT_MAX - buf->use)
-            return(-1);
-        needSize = buf->use + len + 1;
-        if (!xmlBufferResize(buf, needSize))
-            return(-1);
-    }
-
-    memmove(&buf->content[len], &buf->content[0], buf->use);
-    memmove(&buf->content[0], str, len);
-    buf->use += len;
-    buf->content[buf->use] = 0;
-    return 0;
-}
-
-/**
- * xmlBufferCat:
- * @buf:  the buffer to add to
- * @str:  the #xmlChar string
- *
- * Append a zero terminated string to an XML buffer.
- *
- * Returns 0 successful, a positive error code number otherwise
- *         and -1 in case of internal or API error.
- */
-int
-xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {
-    if (buf == NULL)
-        return(-1);
-    if (str == NULL) return -1;
-    return xmlBufferAdd(buf, str, -1);
-}
-
-/**
- * xmlBufferCCat:
- * @buf:  the buffer to dump
- * @str:  the C char string
- *
- * Append a zero terminated C string to an XML buffer.
- *
- * Returns 0 successful, a positive error code number otherwise
- *         and -1 in case of internal or API error.
- */
-int
-xmlBufferCCat(xmlBufferPtr buf, const char *str) {
-    return xmlBufferCat(buf, (const xmlChar *) str);
-}
-
-/**
- * xmlBufferWriteCHAR:
- * @buf:  the XML buffer
- * @string:  the string to add
- *
- * routine which manages and grows an output buffer. This one adds
- * xmlChars at the end of the buffer.
- */
-void
-xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {
-    if (buf == NULL)
-        return;
-    xmlBufferCat(buf, string);
-}
-
-/**
- * xmlBufferWriteChar:
- * @buf:  the XML buffer output
- * @string:  the string to add
- *
- * routine which manage and grows an output buffer. This one add
- * C chars at the end of the array.
- */
-void
-xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {
-    if (buf == NULL)
-        return;
-    xmlBufferCCat(buf, string);
-}
-
-
-/**
- * xmlBufferWriteQuotedString:
- * @buf:  the XML buffer output
- * @string:  the string to add
- *
- * routine which manage and grows an output buffer. This one writes
- * a quoted or double quoted #xmlChar string, checking first if it holds
- * quote or double-quotes internally
- */
-void
-xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {
-    const xmlChar *cur, *base;
-    if (buf == NULL)
-        return;
-    if (xmlStrchr(string, '\"')) {
-        if (xmlStrchr(string, '\'')) {
-	    xmlBufferCCat(buf, "\"");
-            base = cur = string;
-            while(*cur != 0){
-                if(*cur == '"'){
-                    if (base != cur)
-                        xmlBufferAdd(buf, base, cur - base);
-                    xmlBufferAdd(buf, BAD_CAST "&quot;", 6);
-                    cur++;
-                    base = cur;
-                }
-                else {
-                    cur++;
-                }
-            }
-            if (base != cur)
-                xmlBufferAdd(buf, base, cur - base);
-	    xmlBufferCCat(buf, "\"");
-	}
-        else{
-	    xmlBufferCCat(buf, "\'");
-            xmlBufferCat(buf, string);
-	    xmlBufferCCat(buf, "\'");
-        }
-    } else {
-        xmlBufferCCat(buf, "\"");
-        xmlBufferCat(buf, string);
-        xmlBufferCCat(buf, "\"");
-    }
-}
-
-
 /**
  * xmlGetDocCompressMode:
  * @doc:  the document
@@ -9957,7 +9229,7 @@ xmlRegisterNodeDefault(xmlRegisterNodeFunc func)
 {
     xmlRegisterNodeFunc old = xmlRegisterNodeDefaultValue;
 
-    __xmlRegisterCallbacks = 1;
+    xmlRegisterCallbacks = 1;
     xmlRegisterNodeDefaultValue = func;
     return(old);
 }
@@ -9977,7 +9249,7 @@ xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)
 {
     xmlDeregisterNodeFunc old = xmlDeregisterNodeDefaultValue;
 
-    __xmlRegisterCallbacks = 1;
+    xmlRegisterCallbacks = 1;
     xmlDeregisterNodeDefaultValue = func;
     return(old);
 }
diff --git a/uri.c b/uri.c
index 370b449f..94c831fb 100644
--- a/uri.c
+++ b/uri.c
@@ -1132,7 +1132,7 @@ xmlSaveUri(xmlURIPtr uri) {
 
 
     max = 80;
-    ret = (xmlChar *) xmlMallocAtomic(max + 1);
+    ret = xmlMalloc(max + 1);
     if (ret == NULL)
 	return(NULL);
     len = 0;
@@ -1469,7 +1469,7 @@ xmlIsPathSeparator(int c, int isFile) {
     if (c == '/')
         return(1);
 
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__CYGWIN__)
     if (isFile && (c == '\\'))
         return(1);
 #endif
@@ -1511,7 +1511,7 @@ xmlNormalizePath(char *path, int isFile) {
          * Collapse multiple separators first.
          */
         while (xmlIsPathSeparator(*cur, isFile)) {
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__CYGWIN__)
             /* Allow two separators at start of path */
             if ((isFile) && (out == path + 1))
                 *out++ = '/';
@@ -1625,7 +1625,7 @@ xmlURIUnescapeString(const char *str, int len, char *target) {
     if (len < 0) return(NULL);
 
     if (target == NULL) {
-	ret = (char *) xmlMallocAtomic(len + 1);
+	ret = xmlMalloc(len + 1);
 	if (ret == NULL)
 	    return(NULL);
     } else
@@ -1687,7 +1687,7 @@ xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {
     len = xmlStrlen(str);
 
     len += 20;
-    ret = (xmlChar *) xmlMallocAtomic(len);
+    ret = xmlMalloc(len);
     if (ret == NULL)
 	return(NULL);
     in = (const xmlChar *) str;
@@ -1876,7 +1876,7 @@ xmlIsAbsolutePath(const xmlChar *path) {
     if (xmlIsPathSeparator(c, 1))
         return(1);
 
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__CYGWIN__)
     if ((((c >= 'A') && (c <= 'Z')) ||
          ((c >= 'a') && (c <= 'z'))) &&
         (path[1] == ':'))
@@ -2018,6 +2018,18 @@ xmlBuildURISafe(const xmlChar *URI, const xmlChar *base, xmlChar **valPtr) {
 
     if (valPtr == NULL)
         return(1);
+    *valPtr = NULL;
+
+    if (URI == NULL)
+        return(1);
+
+    if (base == NULL) {
+        val = xmlStrdup(URI);
+        if (val == NULL)
+            return(-1);
+        *valPtr = val;
+        return(0);
+    }
 
     /*
      * 1) The URI reference is parsed into the potential four components and
@@ -2027,9 +2039,7 @@ xmlBuildURISafe(const xmlChar *URI, const xmlChar *base, xmlChar **valPtr) {
      *    as a reference to "." rather than as a synonym for the current
      *    URI.  Should we do that here?
      */
-    if (URI == NULL)
-        ret = 1;
-    else if (URI[0] != 0)
+    if (URI[0] != 0)
         ret = xmlParseURISafe((const char *) URI, &ref);
     else
         ret = 0;
@@ -2260,7 +2270,7 @@ xmlBuildURISafe(const xmlChar *URI, const xmlChar *base, xmlChar **valPtr) {
 	len += strlen(ref->path);
     if (bas->path != NULL)
 	len += strlen(bas->path);
-    res->path = (char *) xmlMallocAtomic(len);
+    res->path = xmlMalloc(len);
     if (res->path == NULL)
 	goto done;
     res->path[0] = 0;
@@ -2355,6 +2365,129 @@ xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
     return(out);
 }
 
+static int
+xmlParseUriOrPath(const char *str, xmlURIPtr *out, int *drive) {
+    xmlURIPtr uri;
+    char *buf = NULL;
+    int ret;
+
+    *out = NULL;
+    *drive = 0;
+
+    uri = xmlCreateURI();
+    if (uri == NULL) {
+        ret = -1;
+	goto done;
+    }
+
+    if (xmlStrstr(BAD_CAST str, BAD_CAST "://") == NULL) {
+        const char *path;
+        size_t pathSize;
+        int prependSlash = 0;
+
+        buf = xmlMemStrdup(str);
+        if (buf == NULL) {
+            ret = -1;
+            goto done;
+        }
+        xmlNormalizePath(buf, /* isFile */ 1);
+
+        path = buf;
+
+        if (xmlIsAbsolutePath(BAD_CAST buf)) {
+#if defined(_WIN32) || defined(__CYGWIN__)
+            const char *server = NULL;
+            int isFileScheme = 0;
+#endif
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+            if (strncmp(buf, "//?/UNC/", 8) == 0) {
+                server = buf + 8;
+                isFileScheme = 1;
+            } else if (strncmp(buf, "//?/", 4) == 0) {
+                path = buf + 3;
+                isFileScheme = 1;
+            } else if (strncmp(buf, "//", 2) == 0) {
+                server = buf + 2;
+                isFileScheme = 1;
+            }
+
+            if (server != NULL) {
+                const char *end = strchr(server, '/');
+
+                if (end == NULL) {
+                    uri->server = xmlMemStrdup(server);
+                    path = "/";
+                } else {
+                    uri->server = (char *) xmlStrndup(BAD_CAST server,
+                                                      end - server);
+                    path = end;
+                }
+                if (uri->server == NULL) {
+                    ret = -1;
+                    goto done;
+                }
+            }
+
+            if ((((path[0] >= 'A') && (path[0] <= 'Z')) ||
+                 ((path[0] >= 'a') && (path[0] <= 'z'))) &&
+                (path[1] == ':')) {
+                prependSlash = 1;
+                isFileScheme = 1;
+            }
+
+            if (isFileScheme) {
+                uri->scheme = xmlMemStrdup("file");
+                if (uri->scheme == NULL) {
+                    ret = -1;
+                    goto done;
+                }
+
+                if (uri->server == NULL)
+                    uri->port = PORT_EMPTY_SERVER;
+            }
+#endif
+        }
+
+        pathSize = strlen(path);
+        uri->path = xmlMalloc(pathSize + prependSlash + 1);
+        if (uri->path == NULL) {
+            ret = -1;
+            goto done;
+        }
+        if (prependSlash) {
+            uri->path[0] = '/';
+            memcpy(uri->path + 1, path, pathSize + 1);
+        } else {
+            memcpy(uri->path, path, pathSize + 1);
+        }
+    } else {
+	ret = xmlParseURIReference(uri, str);
+	if (ret != 0)
+	    goto done;
+
+        xmlNormalizePath(uri->path, /* isFile */ 0);
+    }
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+    if ((uri->path[0] == '/') &&
+        (((uri->path[1] >= 'A') && (uri->path[1] <= 'Z')) ||
+         ((uri->path[1] >= 'a') && (uri->path[1] <= 'z'))) &&
+        (uri->path[2] == ':'))
+        *drive = uri->path[1];
+#endif
+
+    *out = uri;
+    uri = NULL;
+    ret = 0;
+
+done:
+    xmlFreeURI(uri);
+    xmlFree(buf);
+
+    return(ret);
+}
+
 /**
  * xmlBuildRelativeURISafe:
  * @URI:  the URI reference under consideration
@@ -2362,12 +2495,10 @@ xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
  * @valPtr:  pointer to result URI
  *
  * Expresses the URI of the reference in terms relative to the
- * base.  Some examples of this operation include:
+ * base. Some examples of this operation include:
+ *
  *     base = "http://site1.com/docs/book1.html"
  *        URI input                        URI returned
- *     docs/pic1.gif                    pic1.gif
- *     docs/img/pic1.gif                img/pic1.gif
- *     img/pic1.gif                     ../img/pic1.gif
  *     http://site1.com/docs/pic1.gif   pic1.gif
  *     http://site2.com/docs/pic1.gif   http://site2.com/docs/pic1.gif
  *
@@ -2378,13 +2509,6 @@ xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
  *     img/pic1.gif                     ../img/pic1.gif
  *     http://site1.com/docs/pic1.gif   http://site1.com/docs/pic1.gif
  *
- *
- * Note: if the URI reference is really weird or complicated, it may be
- *       worthwhile to first convert it into a "nice" one by calling
- *       xmlBuildURI (using 'base') before calling this routine,
- *       since this routine (for reasonable efficiency) assumes URI has
- *       already been through some validation.
- *
  * Available since 2.13.0.
  *
  * Returns 0 on success, -1 if a memory allocation failed or an error
@@ -2401,8 +2525,10 @@ xmlBuildRelativeURISafe(const xmlChar * URI, const xmlChar * base,
     int len;
     xmlURIPtr ref = NULL;
     xmlURIPtr bas = NULL;
-    xmlChar *bptr, *uptr, *vptr;
+    const xmlChar *bptr, *uptr, *rptr;
+    xmlChar *vptr;
     int remove_path = 0;
+    int refDrive, baseDrive;
 
     if (valPtr == NULL)
         return(1);
@@ -2410,65 +2536,39 @@ xmlBuildRelativeURISafe(const xmlChar * URI, const xmlChar * base,
     if ((URI == NULL) || (*URI == 0))
 	return(1);
 
-    /*
-     * First parse URI into a standard form
-     */
-    ref = xmlCreateURI ();
-    if (ref == NULL) {
-        ret = -1;
-	goto done;
-    }
-    /* If URI not already in "relative" form */
-    if (URI[0] != '.') {
-	ret = xmlParseURIReference (ref, (const char *) URI);
-	if (ret != 0)
-	    goto done;		/* Error in URI, return NULL */
-    } else {
-	ref->path = (char *)xmlStrdup(URI);
-        if (ref->path == NULL) {
-            ret = -1;
-            goto done;
-        }
-    }
-
-    /*
-     * Next parse base into the same standard form
-     */
-    if ((base == NULL) || (*base == 0)) {
-	val = xmlStrdup (URI);
+    ret = xmlParseUriOrPath((char *) URI, &ref, &refDrive);
+    if (ret < 0)
+        goto done;
+    if (ret != 0) {
+        /* Return URI if URI is invalid */
+        ret = 0;
+        val = xmlStrdup(URI);
         if (val == NULL)
             ret = -1;
-	goto done;
-    }
-    bas = xmlCreateURI ();
-    if (bas == NULL) {
-        ret = -1;
-	goto done;
+        goto done;
     }
-    if (base[0] != '.') {
-	ret = xmlParseURIReference (bas, (const char *) base);
-	if (ret != 0)
-	    goto done;		/* Error in base, return NULL */
-    } else {
-	bas->path = (char *)xmlStrdup(base);
-        if (bas->path == NULL) {
-            ret = -1;
-            goto done;
-        }
+
+    /* Return URI if base is empty */
+    if ((base == NULL) || (*base == 0))
+        goto done;
+
+    ret = xmlParseUriOrPath((char *) base, &bas, &baseDrive);
+    if (ret < 0)
+        goto done;
+    if (ret != 0) {
+        /* Return URI if base is invalid */
+        ret = 0;
+        goto done;
     }
 
     /*
      * If the scheme / server on the URI differs from the base,
      * just return the URI
      */
-    if ((ref->scheme != NULL) &&
-	((bas->scheme == NULL) ||
-	 (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
-	 (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||
-         (bas->port != ref->port))) {
-	val = xmlStrdup (URI);
-        if (val == NULL)
-            ret = -1;
+    if ((xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
+	(xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||
+        (bas->port != ref->port) ||
+        (baseDrive != refDrive)) {
 	goto done;
     }
     if (xmlStrEqual((xmlChar *)bas->path, (xmlChar *)ref->path)) {
@@ -2479,35 +2579,35 @@ xmlBuildRelativeURISafe(const xmlChar * URI, const xmlChar * base,
     }
     if (bas->path == NULL) {
 	val = xmlStrdup((xmlChar *)ref->path);
-        if (val == NULL)
+        if (val == NULL) {
             ret = -1;
-	goto done;
+            goto done;
+        }
+	goto escape;
     }
     if (ref->path == NULL) {
         ref->path = (char *) "/";
 	remove_path = 1;
     }
 
+    bptr = (xmlChar *) bas->path;
+    rptr = (xmlChar *) ref->path;
+
     /*
-     * At this point (at last!) we can compare the two paths
-     *
-     * First we take care of the special case where either of the
-     * two path components may be missing (bug 316224)
+     * Return URI if URI and base aren't both absolute or relative.
+     */
+    if ((bptr[0] == '/') != (rptr[0] == '/'))
+        goto done;
+
+    /*
+     * At this point we can compare the two paths
      */
-    bptr = (xmlChar *)bas->path;
     {
-        xmlChar *rptr = (xmlChar *) ref->path;
         int pos = 0;
 
         /*
          * Next we compare the two strings and find where they first differ
          */
-	if ((*rptr == '.') && (rptr[1] == '/'))
-            rptr += 2;
-	if ((*bptr == '.') && (bptr[1] == '/'))
-            bptr += 2;
-	else if ((*bptr == '/') && (*rptr != '/'))
-	    bptr++;
 	while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))
 	    pos++;
 
@@ -2595,9 +2695,10 @@ xmlBuildRelativeURISafe(const xmlChar * URI, const xmlChar * base,
 	vptr[len - 1] = 0;
     }
 
+escape:
     /* escape the freshly-built path */
     vptr = val;
-	/* exception characters from xmlSaveUri */
+    /* exception characters from xmlSaveUri */
     val = xmlURIEscapeStr(vptr, BAD_CAST "/;&=+$,");
     if (val == NULL)
         ret = -1;
@@ -2606,6 +2707,12 @@ xmlBuildRelativeURISafe(const xmlChar * URI, const xmlChar * base,
     xmlFree(vptr);
 
 done:
+    if ((ret == 0) && (val == NULL)) {
+        val = xmlSaveUri(ref);
+        if (val == NULL)
+            ret = -1;
+    }
+
     /*
      * Free the working variables
      */
diff --git a/valid.c b/valid.c
index 1b711e64..ac985d02 100644
--- a/valid.c
+++ b/valid.c
@@ -119,7 +119,7 @@ xmlErrValid(xmlValidCtxtPtr ctxt, xmlParserErrors error,
                   NULL, NULL, 0, msg, extra);
 }
 
-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#ifdef LIBXML_VALID_ENABLED
 /**
  * xmlErrValidNode:
  * @ctxt:  an XML validation parser context
@@ -140,9 +140,7 @@ xmlErrValidNode(xmlValidCtxtPtr ctxt,
     xmlDoErrValid(ctxt, node, error, XML_ERR_ERROR, str1, str2, str3, 0,
                   msg, str1, str2, str3);
 }
-#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
 
-#ifdef LIBXML_VALID_ENABLED
 /**
  * xmlErrValidNodeNr:
  * @ctxt:  an XML validation parser context
@@ -675,7 +673,8 @@ done:
 xmlValidCtxtPtr xmlNewValidCtxt(void) {
     xmlValidCtxtPtr ret;
 
-    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL)
+    ret = xmlMalloc(sizeof (xmlValidCtxt));
+    if (ret == NULL)
 	return (NULL);
 
     (void) memset(ret, 0, sizeof (xmlValidCtxt));
@@ -1353,7 +1352,6 @@ xmlFreeElementTable(xmlElementTablePtr table) {
     xmlHashFree(table, xmlFreeElementTableEntry);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlCopyElement:
  * @elem:  An element
@@ -1409,7 +1407,6 @@ xmlElementTablePtr
 xmlCopyElementTable(xmlElementTablePtr table) {
     return(xmlHashCopySafe(table, xmlCopyElement, xmlFreeElementTableEntry));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /**
@@ -1519,7 +1516,6 @@ xmlFreeEnumeration(xmlEnumerationPtr cur) {
     }
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlCopyEnumeration:
  * @cur:  the tree to copy.
@@ -1554,7 +1550,6 @@ xmlCopyEnumeration(xmlEnumerationPtr cur) {
 
     return(ret);
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_VALID_ENABLED
 /**
@@ -1892,7 +1887,6 @@ xmlFreeAttributeTable(xmlAttributeTablePtr table) {
     xmlHashFree(table, xmlFreeAttributeTableEntry);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlCopyAttribute:
  * @attr:  An attribute
@@ -1958,7 +1952,6 @@ xmlCopyAttributeTable(xmlAttributeTablePtr table) {
     return(xmlHashCopySafe(table, xmlCopyAttribute,
                            xmlFreeAttributeTableEntry));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /**
@@ -2150,7 +2143,6 @@ xmlFreeNotationTable(xmlNotationTablePtr table) {
     xmlHashFree(table, xmlFreeNotationTableEntry);
 }
 
-#ifdef LIBXML_TREE_ENABLED
 /**
  * xmlCopyNotation:
  * @nota:  A notation
@@ -2202,7 +2194,6 @@ xmlNotationTablePtr
 xmlCopyNotationTable(xmlNotationTablePtr table) {
     return(xmlHashCopySafe(table, xmlCopyNotation, xmlFreeNotationTableEntry));
 }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /**
@@ -2336,9 +2327,6 @@ xmlAddIDInternal(xmlAttrPtr attr, const xmlChar *value, xmlIDPtr *idPtr) {
     if (doc == NULL)
         return(0);
 
-    if (attr->id != NULL)
-        xmlRemoveID(doc, attr);
-
     /*
      * Create the ID table if needed.
      */
@@ -2349,14 +2337,8 @@ xmlAddIDInternal(xmlAttrPtr attr, const xmlChar *value, xmlIDPtr *idPtr) {
             return(-1);
     } else {
         id = xmlHashLookup(table, value);
-        if (id != NULL) {
-            if (id->attr != NULL) {
-                id->attr->id = NULL;
-                id->attr->atype = 0;
-            }
-            ret = 0;
-            goto done;
-        }
+        if (id != NULL)
+            return(0);
     }
 
     id = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
@@ -2374,6 +2356,9 @@ xmlAddIDInternal(xmlAttrPtr attr, const xmlChar *value, xmlIDPtr *idPtr) {
         return(-1);
     }
 
+    if (attr->id != NULL)
+        xmlRemoveID(doc, attr);
+
     if (xmlHashAddEntry(table, value, id) < 0) {
 	xmlFreeID(id);
 	return(-1);
@@ -2383,7 +2368,6 @@ xmlAddIDInternal(xmlAttrPtr attr, const xmlChar *value, xmlIDPtr *idPtr) {
     if (idPtr != NULL)
         *idPtr = id;
 
-done:
     id->attr = attr;
     id->lineno = xmlGetLineNo(attr->parent);
     attr->atype = XML_ATTRIBUTE_ID;
@@ -2762,10 +2746,12 @@ xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,
      * Return the ref
      */
 
-    if (NULL == (ref_list = xmlHashLookup(table, value))) {
+    ref_list = xmlHashLookup(table, value);
+    if (ref_list == NULL) {
         int res;
 
-        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare)))
+        ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare);
+        if (ref_list == NULL)
 	    goto failed;
         res = xmlHashAdd(table, value, ref_list);
         if (res <= 0) {
@@ -3157,7 +3143,7 @@ xmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {
     return(xmlHashLookup(table, name));
 }
 
-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#ifdef LIBXML_VALID_ENABLED
 /**
  * xmlValidateNotationUse:
  * @ctxt:  the validation context
@@ -3183,7 +3169,7 @@ xmlValidateNotationUse(xmlValidCtxtPtr ctxt, xmlDocPtr doc,
     if ((notaDecl == NULL) && (doc->extSubset != NULL))
 	notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);
 
-    if ((notaDecl == NULL) && (ctxt != NULL)) {
+    if (notaDecl == NULL) {
 	xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,
 	                "NOTATION %s is not declared\n",
 		        notationName, NULL, NULL);
@@ -3191,7 +3177,7 @@ xmlValidateNotationUse(xmlValidCtxtPtr ctxt, xmlDocPtr doc,
     }
     return(1);
 }
-#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
+#endif /* LIBXML_VALID_ENABLED */
 
 /**
  * xmlIsMixedElement:
@@ -4115,13 +4101,6 @@ xmlValidateElementDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,
 
     if (elem == NULL) return(1);
 
-#if 0
-#ifdef LIBXML_REGEXP_ENABLED
-    /* Build the regexp associated to the content model */
-    ret = xmlValidBuildContentModel(ctxt, elem);
-#endif
-#endif
-
     /* No Duplicate Types */
     if (elem->etype == XML_ELEMENT_TYPE_MIXED) {
 	xmlElementContentPtr cur, next;
@@ -4513,25 +4492,6 @@ xmlNodePtr elem, const xmlChar *prefix, xmlNsPtr ns, const xmlChar *value) {
 	}
     }
 
-    /*
-     * Casting ns to xmlAttrPtr is wrong. We'd need separate functions
-     * xmlAddID and xmlAddRef for namespace declarations, but it makes
-     * no practical sense to use ID types anyway.
-     */
-#if 0
-    /* Validity Constraint: ID uniqueness */
-    if (attrDecl->atype == XML_ATTRIBUTE_ID) {
-        if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
-	    ret = 0;
-    }
-
-    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||
-	(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {
-        if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)
-	    ret = 0;
-    }
-#endif
-
     /* Validity Constraint: Notation Attributes */
     if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {
         xmlEnumerationPtr tree = attrDecl->tree;
@@ -5589,7 +5549,7 @@ xmlValidatePushElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,
 
     if (ctxt == NULL)
         return(0);
-/* printf("PushElem %s\n", qname); */
+
     if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {
 	xmlValidStatePtr state = ctxt->vstate;
 	xmlElementPtr elemDecl;
@@ -5683,7 +5643,6 @@ int
 xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {
     int ret = 1;
 
-/* printf("CDATA %s %d\n", data, len); */
     if (ctxt == NULL)
         return(0);
     if (len <= 0)
@@ -5762,7 +5721,7 @@ xmlValidatePopElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc ATTRIBUTE_UNUSED,
 
     if (ctxt == NULL)
         return(0);
-/* printf("PopElem %s\n", qname); */
+
     if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {
 	xmlValidStatePtr state = ctxt->vstate;
 	xmlElementPtr elemDecl;
@@ -6231,7 +6190,10 @@ xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr root) {
         if (elem->type == XML_ELEMENT_NODE) {
             attr = elem->properties;
             while (attr != NULL) {
-                value = xmlNodeListGetString(doc, attr->children, 0);
+                if (attr->children == NULL)
+                    value = xmlStrdup(BAD_CAST "");
+                else
+                    value = xmlNodeListGetString(doc, attr->children, 0);
                 if (value == NULL) {
                     xmlVErrMemory(ctxt);
                     ret = 0;
@@ -6808,7 +6770,6 @@ xmlValidGetPotentialChildren(xmlElementContent *ctree,
  */
 static void xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,
                                 const char *msg ATTRIBUTE_UNUSED, ...) {
-    return;
 }
 
 /**
diff --git a/win32/Makefile.bcb b/win32/Makefile.bcb
index be615b70..b9c3233e 100644
--- a/win32/Makefile.bcb
+++ b/win32/Makefile.bcb
@@ -59,8 +59,6 @@ CFLAGS = $(CFLAGS) -tWR
 !endif
 !if "$(WITH_THREADS)" == "ctls"
 CFLAGS = $(CFLAGS) "-DXML_THREAD_LOCAL=__declspec(thread)"
-!else if "$(WITH_THREADS)" == "posix"
-CFLAGS = $(CFLAGS) -DHAVE_PTHREAD_H
 !endif
 
 # The linker and its options.
@@ -206,12 +204,6 @@ UTILS = $(BINDIR)\xmllint.exe\
 	$(BINDIR)\testapi.exe\
 	$(BINDIR)\testlimits.exe
 
-
-!if "$(WITH_THREADS)" != "no"
-UTILS = $(UTILS) $(BINDIR)\testThreads.exe
-!endif
-
-
 all : libxml libxmla utils
 
 libxml : $(BINDIR)\$(XML_SO) 
diff --git a/win32/Makefile.mingw b/win32/Makefile.mingw
index ea276455..1eb058b6 100644
--- a/win32/Makefile.mingw
+++ b/win32/Makefile.mingw
@@ -42,9 +42,6 @@ CFLAGS += -I$(XML_SRCDIR) -I$(XML_SRCDIR)/include -I$(INCPREFIX) $(INCLUDE)
 ifeq ($(WITH_THREADS),ctls)
 CFLAGS += "-DXML_THREAD_LOCAL=__declspec(thread)"
 endif
-ifeq ($(WITH_THREADS),posix)
-CFLAGS += -DHAVE_PTHREAD_H
-endif
 
 # The linker and its options.
 LD = gcc.exe
@@ -190,10 +187,6 @@ UTILS = $(BINDIR)/xmllint.exe\
 	$(BINDIR)/testapi.exe\
 	$(BINDIR)/testlimits.exe
 
-ifneq ($(WITH_THREADS),no)
-UTILS += $(BINDIR)/testThreads.exe
-endif
-
 all : dep libxml libxmla utils
 
 libxml : $(BINDIR)/$(XML_SO) 
diff --git a/win32/Makefile.msvc b/win32/Makefile.msvc
index 9340cd31..2b2e6ca8 100644
--- a/win32/Makefile.msvc
+++ b/win32/Makefile.msvc
@@ -44,8 +44,6 @@ CFLAGS = /nologo /D "_WINDOWS" /D "_MBCS" /D "NOLIBTOOL" /W3 /wd4244 /wd4267 $(C
 CFLAGS = $(CFLAGS) /I$(XML_SRCDIR) /I$(XML_SRCDIR)\include /I$(INCPREFIX)
 !if "$(WITH_THREADS)" == "ctls"
 CFLAGS = $(CFLAGS) /D "XML_THREAD_LOCAL=__declspec(thread)"
-!else if "$(WITH_THREADS)" == "posix"
-CFLAGS = $(CFLAGS) /D "HAVE_PTHREAD_H"
 !endif
 CFLAGS = $(CFLAGS) /D_CRT_SECURE_NO_DEPRECATE /D_CRT_NONSTDC_NO_DEPRECATE
 
@@ -81,6 +79,7 @@ LIBS = $(LIBS) pthreadVC.lib
 !if "$(WITH_MODULES)" == "1"
 LIBS = $(LIBS) kernel32.lib
 !endif
+LIBS = $(LIBS) Bcrypt.lib
 
 # The archiver and its options.
 AR = lib.exe
@@ -253,10 +252,6 @@ UTILS = $(BINDIR)\xmllint.exe\
 	$(BINDIR)\testlimits.exe\
 	$(BINDIR)\testrecurse.exe
 	
-!if "$(WITH_THREADS)" != "no"
-UTILS = $(UTILS) $(BINDIR)\testThreads.exe
-!endif
-
 !if "$(VCMANIFEST)" == "1"
 _VC_MANIFEST_EMBED_EXE= if exist $@.manifest mt.exe -nologo -manifest $@.manifest -outputresource:$@;1
 _VC_MANIFEST_EMBED_DLL= if exist $@.manifest mt.exe -nologo -manifest $@.manifest -outputresource:$@;2
diff --git a/win32/configure.js b/win32/configure.js
index 92f3fc7d..f2d26f77 100644
--- a/win32/configure.js
+++ b/win32/configure.js
@@ -605,7 +605,7 @@ if (f) {
 fso.CopyFile(makefile, new_makefile, true);
 WScript.Echo("Created Makefile.");
 // Create the config.h.
-var confighsrc = "..\\include\\win32config.h";
+var confighsrc = "win32config.h";
 var configh = "..\\config.h";
 var f = fso.FileExists(configh);
 if (f) {
diff --git a/include/win32config.h b/win32/win32config.h
similarity index 85%
rename from include/win32config.h
rename to win32/win32config.h
index a25e0385..edd87633 100644
--- a/include/win32config.h
+++ b/win32/win32config.h
@@ -1,10 +1,6 @@
 #ifndef __LIBXML_WIN32_CONFIG__
 #define __LIBXML_WIN32_CONFIG__
 
-#define HAVE_SYS_STAT_H
-#define HAVE_STAT
-#define HAVE_FCNTL_H
-
 #if defined(__MINGW32__) || (defined(_MSC_VER) && _MSC_VER >= 1600)
   #define HAVE_STDINT_H
 #endif
diff --git a/xinclude.c b/xinclude.c
index c177b939..d4a40712 100644
--- a/xinclude.c
+++ b/xinclude.c
@@ -174,10 +174,10 @@ xmlXIncludeErr(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node, int error,
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, ctxt, node,
-                          XML_FROM_XINCLUDE, error, XML_ERR_ERROR,
-                          NULL, 0, (const char *) extra, NULL, NULL, 0, 0,
-		          msg, (const char *) extra);
+    res = xmlRaiseError(schannel, channel, data, ctxt, node,
+                        XML_FROM_XINCLUDE, error, XML_ERR_ERROR,
+                        NULL, 0, (const char *) extra, NULL, NULL, 0, 0,
+                        msg, (const char *) extra);
     if (res < 0) {
         ctxt->errNo = XML_ERR_NO_MEMORY;
         ctxt->fatalErr = 1;
@@ -341,13 +341,20 @@ xmlXIncludeParseFile(xmlXIncludeCtxtPtr ctxt, const char *URL) {
 	xmlDictReference(pctxt->dict);
     }
 
-    xmlCtxtUseOptions(pctxt, ctxt->parseFlags);
+    /*
+     * We set DTDLOAD to make sure that ID attributes declared in
+     * external DTDs are detected.
+     */
+    xmlCtxtUseOptions(pctxt, ctxt->parseFlags | XML_PARSE_DTDLOAD);
 
     inputStream = xmlLoadResource(pctxt, URL, NULL, XML_RESOURCE_XINCLUDE);
     if (inputStream == NULL)
         goto error;
 
-    inputPush(pctxt, inputStream);
+    if (inputPush(pctxt, inputStream) < 0) {
+        xmlFreeInputStream(inputStream);
+        goto error;
+    }
 
     xmlParseDocument(pctxt);
 
@@ -414,6 +421,10 @@ xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {
             xmlXIncludeErrMemory(ctxt);
 	    goto error;
         }
+    } else if (xmlStrlen(href) > XML_MAX_URI_LENGTH) {
+        xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI, "URI too long\n",
+                       NULL);
+        goto error;
     }
 
     parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);
@@ -630,7 +641,14 @@ xmlXIncludeBaseFixup(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur, xmlNodePtr copy,
         xmlXIncludeErrMemory(ctxt);
 
     if ((base != NULL) && !xmlStrEqual(base, targetBase)) {
-        if (xmlBuildRelativeURISafe(base, targetBase, &relBase) < 0) {
+        if ((xmlStrlen(base) > XML_MAX_URI_LENGTH) ||
+            (xmlStrlen(targetBase) > XML_MAX_URI_LENGTH)) {
+            relBase = xmlStrdup(base);
+            if (relBase == NULL) {
+                xmlXIncludeErrMemory(ctxt);
+                goto done;
+            }
+        } else if (xmlBuildRelativeURISafe(base, targetBase, &relBase) < 0) {
             xmlXIncludeErrMemory(ctxt);
             goto done;
         }
@@ -1211,9 +1229,11 @@ loaded:
 #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
             ctxt->xpctxt->opLimit = 100000;
 #endif
+        } else {
+            ctxt->xpctxt->doc = doc;
         }
 	xptr = xmlXPtrEval(fragment, ctxt->xpctxt);
-	if (xptr == NULL) {
+	if (ctxt->xpctxt->lastError.code != XML_ERR_OK) {
             if (ctxt->xpctxt->lastError.code == XML_ERR_NO_MEMORY)
                 xmlXIncludeErrMemory(ctxt);
             else
@@ -1222,6 +1242,8 @@ loaded:
                                fragment);
             goto error;
 	}
+        if (xptr == NULL)
+            goto done;
 	switch (xptr->type) {
 	    case XPATH_UNDEFINED:
 	    case XPATH_BOOLEAN:
@@ -1293,6 +1315,7 @@ loaded:
     }
 #endif
 
+done:
     ret = 0;
 
 error:
@@ -1387,9 +1410,14 @@ xmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {
     inputStream = xmlLoadResource(pctxt, (const char*) url, NULL,
                                   XML_RESOURCE_XINCLUDE_TEXT);
     if (inputStream == NULL) {
+        /*
+         * ENOENT only produces a warning which isn't reflected in errNo.
+         */
         if (pctxt->errNo == XML_ERR_NO_MEMORY)
             xmlXIncludeErrMemory(ctxt);
-        else
+        else if ((pctxt->errNo != XML_ERR_OK) &&
+                 (pctxt->errNo != XML_IO_ENOENT) &&
+                 (pctxt->errNo != XML_IO_UNKNOWN))
             xmlXIncludeErr(ctxt, NULL, pctxt->errNo, "load error", NULL);
 	goto error;
     }
@@ -1422,7 +1450,7 @@ xmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {
     }
 
     content = xmlBufContent(buf->buffer);
-    len = xmlBufLength(buf->buffer);
+    len = xmlBufUse(buf->buffer);
     for (i = 0; i < len;) {
         int cur;
         int l;
@@ -1692,10 +1720,15 @@ xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {
 		nb_elem++;
 	    tmp = tmp->next;
 	}
-	if (nb_elem > 1) {
-	    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,
-		       "XInclude error: would result in multiple root nodes\n",
-			   NULL);
+        if (nb_elem != 1) {
+            if (nb_elem > 1)
+                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,
+                               "XInclude error: would result in multiple root "
+                               "nodes\n", NULL);
+            else
+                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,
+                               "XInclude error: would result in no root "
+                               "node\n", NULL);
             xmlFreeNodeList(list);
 	    return(-1);
 	}
@@ -1789,11 +1822,6 @@ xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
         (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS))) {
 	if (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS)) {
 	    if (ctxt->legacy == 0) {
-#if 0 /* wait for the XML Core Working Group to get something stable ! */
-		xmlXIncludeWarn(ctxt, node, XML_XINCLUDE_DEPRECATED_NS,
-	               "Deprecated XInclude namespace found, use %s",
-		                XINCLUDE_NS);
-#endif
 	        ctxt->legacy = 1;
 	    }
 	}
diff --git a/xml2-config.in b/xml2-config.in
index 1f82f80c..00977518 100644
--- a/xml2-config.in
+++ b/xml2-config.in
@@ -71,9 +71,9 @@ while test $# -gt 0; do
        	;;
 
     --libtool-libs)
-	if [ -r ${libdir}/@XML_LIBTOOLLIBS@ ]
+	if [ -r ${libdir}/libxml2.la ]
 	then
-	    echo ${libdir}/@XML_LIBTOOLLIBS@
+	    echo ${libdir}/libxml2.la
 	fi
         ;;
 
@@ -86,10 +86,10 @@ while test $# -gt 0; do
             shift
             libs="@XML_LIBS@ @XML_PRIVATE_LIBS_NO_SHARED@"
         else
-            libs="@XML_LIBS@ @XML_PRIVATE_LIBS@ @MODULE_PLATFORM_LIBS@ @LIBS@"
+            libs="@XML_LIBS@ @XML_PRIVATE_LIBS@ @LIBS@"
         fi
 
-        if [ "@XML_LIBDIR@" != "-L/usr/lib" -a "@XML_LIBDIR@" != "-L/usr/lib64" ]; then
+        if [ "@libdir@" != "/usr/lib" -a "@libdir@" != "/usr/lib64" ]; then
             libs="@XML_LIBDIR@ $libs"
         fi
         ;;
diff --git a/xmlIO.c b/xmlIO.c
index ac2cf0d2..7298cfca 100644
--- a/xmlIO.c
+++ b/xmlIO.c
@@ -13,15 +13,18 @@
 #include <stdlib.h>
 #include <errno.h>
 
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(_WIN32)
+  #define WIN32_LEAN_AND_MEAN
+  #include <windows.h>
+  #include <io.h>
+  #include <direct.h>
+#else
+  #include <unistd.h>
 #endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
+
 #ifdef LIBXML_ZLIB_ENABLED
 #include <zlib.h>
 #endif
@@ -29,13 +32,6 @@
 #include <lzma.h>
 #endif
 
-#if defined(_WIN32)
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <io.h>
-#include <direct.h>
-#endif
-
 #include <libxml/xmlIO.h>
 #include <libxml/xmlmemory.h>
 #include <libxml/uri.h>
@@ -48,9 +44,14 @@
 
 #include "private/buf.h"
 #include "private/enc.h"
+#include "private/entities.h"
 #include "private/error.h"
 #include "private/io.h"
 
+#ifndef SIZE_MAX
+  #define SIZE_MAX ((size_t) -1)
+#endif
+
 /* #define VERBOSE_FAILURE */
 
 #define MINLEN 4000
@@ -363,19 +364,16 @@ xmlNormalizeWindowsPath(const xmlChar *path)
 int
 xmlCheckFilename(const char *path)
 {
-#ifdef HAVE_STAT
 #if defined(_WIN32)
     struct _stat stat_buffer;
 #else
     struct stat stat_buffer;
 #endif
     int res;
-#endif
 
     if (path == NULL)
 	return(0);
 
-#ifdef HAVE_STAT
 #if defined(_WIN32)
     {
         wchar_t *wpath;
@@ -405,7 +403,6 @@ xmlCheckFilename(const char *path)
     if (S_ISDIR(stat_buffer.st_mode))
         return 2;
 #endif
-#endif /* HAVE_STAT */
 
     return 1;
 }
@@ -478,7 +475,7 @@ xmlFdOpen(const char *filename, int write, int *out) {
             flags = _O_WRONLY | _O_CREAT | _O_TRUNC;
         else
             flags = _O_RDONLY;
-	fd = _wopen(wpath, flags | _O_BINARY, 0777);
+	fd = _wopen(wpath, flags | _O_BINARY, 0666);
         xmlFree(wpath);
     }
 #else
@@ -486,7 +483,7 @@ xmlFdOpen(const char *filename, int write, int *out) {
         flags = O_WRONLY | O_CREAT | O_TRUNC;
     else
         flags = O_RDONLY;
-    fd = open(filename, flags, 0777);
+    fd = open(filename, flags, 0666);
 #endif /* WIN32 */
 
     if (fd < 0) {
@@ -714,7 +711,7 @@ xmlFileRead(void * context, char * buffer, int len) {
     if ((bytes < (size_t) len) && (ferror(file)))
         return(-xmlIOErr(errno));
 
-    return(len);
+    return(bytes);
 }
 
 #ifdef LIBXML_OUTPUT_ENABLED
@@ -1189,6 +1186,8 @@ xmlOutputDefaultOpen(xmlOutputBufferPtr buf, const char *filename,
  * xmlAllocParserInputBuffer:
  * @enc:  the charset encoding if known (deprecated)
  *
+ * DEPRECATED: Use xmlNewInputFrom*.
+ *
  * Create a buffered parser input for progressive parsing.
  *
  * The encoding argument is deprecated and should be set to
@@ -1206,12 +1205,11 @@ xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 	return(NULL);
     }
     memset(ret, 0, sizeof(xmlParserInputBuffer));
-    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
+    ret->buffer = xmlBufCreate(XML_IO_BUFFER_SIZE);
     if (ret->buffer == NULL) {
         xmlFree(ret);
 	return(NULL);
     }
-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
     if (enc != XML_CHAR_ENCODING_NONE) {
         if (xmlLookupCharEncodingHandler(enc, &ret->encoder) != 0) {
             /* We can't handle errors properly here. */
@@ -1220,7 +1218,7 @@ xmlAllocParserInputBuffer(xmlCharEncoding enc) {
         }
     }
     if (ret->encoder != NULL)
-        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
+        ret->raw = xmlBufCreate(XML_IO_BUFFER_SIZE);
     else
         ret->raw = NULL;
     ret->readcallback = NULL;
@@ -1239,6 +1237,8 @@ xmlAllocParserInputBuffer(xmlCharEncoding enc) {
  *
  * Create a buffered parser output
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new parser output or NULL
  */
 xmlOutputBufferPtr
@@ -1247,22 +1247,22 @@ xmlAllocOutputBuffer(xmlCharEncodingHandlerPtr encoder) {
 
     ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
     if (ret == NULL) {
+        xmlCharEncCloseFunc(encoder);
 	return(NULL);
     }
     memset(ret, 0, sizeof(xmlOutputBuffer));
-    ret->buffer = xmlBufCreate();
+    ret->buffer = xmlBufCreate(MINLEN);
     if (ret->buffer == NULL) {
+        xmlCharEncCloseFunc(encoder);
         xmlFree(ret);
 	return(NULL);
     }
-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_IO);
 
     ret->encoder = encoder;
     if (encoder != NULL) {
-        ret->conv = xmlBufCreateSize(4000);
+        ret->conv = xmlBufCreate(MINLEN);
 	if (ret->conv == NULL) {
-            xmlBufFree(ret->buffer);
-	    xmlFree(ret);
+            xmlOutputBufferClose(ret);
 	    return(NULL);
 	}
 
@@ -1279,59 +1279,6 @@ xmlAllocOutputBuffer(xmlCharEncodingHandlerPtr encoder) {
 
     return(ret);
 }
-
-/**
- * xmlAllocOutputBufferInternal:
- * @encoder:  the encoding converter or NULL
- *
- * Create a buffered parser output
- *
- * Returns the new parser output or NULL
- */
-xmlOutputBufferPtr
-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder) {
-    xmlOutputBufferPtr ret;
-
-    ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
-    if (ret == NULL) {
-	return(NULL);
-    }
-    memset(ret, 0, sizeof(xmlOutputBuffer));
-    ret->buffer = xmlBufCreate();
-    if (ret->buffer == NULL) {
-        xmlFree(ret);
-	return(NULL);
-    }
-
-
-    /*
-     * For conversion buffers we use the special IO handling
-     */
-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_IO);
-
-    ret->encoder = encoder;
-    if (encoder != NULL) {
-        ret->conv = xmlBufCreateSize(4000);
-	if (ret->conv == NULL) {
-            xmlBufFree(ret->buffer);
-	    xmlFree(ret);
-	    return(NULL);
-	}
-
-	/*
-	 * This call is designed to initiate the encoder state
-	 */
-        xmlCharEncOutput(ret, 1);
-    } else
-        ret->conv = NULL;
-    ret->writecallback = NULL;
-    ret->closecallback = NULL;
-    ret->context = NULL;
-    ret->written = 0;
-
-    return(ret);
-}
-
 #endif /* LIBXML_OUTPUT_ENABLED */
 
 /**
@@ -1434,6 +1381,8 @@ xmlParserInputBufferCreateUrl(const char *URI, xmlCharEncoding enc,
     int ret;
     int i;
 
+    xmlInitParser();
+
     *out = NULL;
     if (URI == NULL)
         return(XML_ERR_ARGUMENT);
@@ -1492,6 +1441,8 @@ __xmlParserInputBufferCreateFilename(const char *URI, xmlCharEncoding enc) {
  * @URI:  a C string containing the URI or filename
  * @enc:  the charset encoding if known
  *
+ * DEPRECATED: Use xmlNewInputFromUrl.
+ *
  * Create a buffered parser input for the progressive parsing of a file
  * Automatic support for ZLIB/Compress compressed document is provided
  * by default if found at compile-time.
@@ -1520,6 +1471,8 @@ __xmlOutputBufferCreateFilename(const char *URI,
     int i = 0;
     char *unescaped = NULL;
 
+    xmlInitParser();
+
     if (URI == NULL)
         return(NULL);
 
@@ -1530,11 +1483,12 @@ __xmlOutputBufferCreateFilename(const char *URI,
          */
         if (puri->scheme == NULL) {
             unescaped = xmlURIUnescapeString(URI, 0, NULL);
-             if (unescaped == NULL) {
-                 xmlFreeURI(puri);
-                 return(NULL);
-             }
-             URI = unescaped;
+            if (unescaped == NULL) {
+                xmlFreeURI(puri);
+                xmlCharEncCloseFunc(encoder);
+                return(NULL);
+            }
+            URI = unescaped;
         }
         xmlFreeURI(puri);
     }
@@ -1542,7 +1496,7 @@ __xmlOutputBufferCreateFilename(const char *URI,
     /*
      * Allocate the Output buffer front-end.
      */
-    ret = xmlAllocOutputBufferInternal(encoder);
+    ret = xmlAllocOutputBuffer(encoder);
     if (ret == NULL) {
         xmlFree(unescaped);
         return(NULL);
@@ -1594,6 +1548,8 @@ __xmlOutputBufferCreateFilename(const char *URI,
  * TODO: currently if compression is set, the library only support
  *       writing to a local file.
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new output or NULL
  */
 xmlOutputBufferPtr
@@ -1612,6 +1568,8 @@ xmlOutputBufferCreateFilename(const char *URI,
  * @file:  a FILE*
  * @enc:  the charset encoding if known (deprecated)
  *
+ * DEPRECATED: Don't use.
+ *
  * Create a buffered parser input for the progressive parsing of a FILE *
  * buffered C I/O
  *
@@ -1646,6 +1604,8 @@ xmlParserInputBufferCreateFile(FILE *file, xmlCharEncoding enc) {
  * Create a buffered output for the progressive saving to a FILE *
  * buffered C I/O
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new parser output or NULL
  */
 xmlOutputBufferPtr
@@ -1654,7 +1614,7 @@ xmlOutputBufferCreateFile(FILE *file, xmlCharEncodingHandlerPtr encoder) {
 
     if (file == NULL) return(NULL);
 
-    ret = xmlAllocOutputBufferInternal(encoder);
+    ret = xmlAllocOutputBuffer(encoder);
     if (ret != NULL) {
         ret->context = file;
 	ret->writecallback = xmlFileWrite;
@@ -1671,6 +1631,8 @@ xmlOutputBufferCreateFile(FILE *file, xmlCharEncodingHandlerPtr encoder) {
  *
  * Create a buffered output for the progressive saving to a xmlBuffer
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new parser output or NULL
  */
 xmlOutputBufferPtr
@@ -1726,6 +1688,8 @@ xmlOutputBufferGetSize(xmlOutputBufferPtr out) {
  * @fd:  a file descriptor number
  * @enc:  the charset encoding if known (deprecated)
  *
+ * DEPRECATED: Use xmlNewInputFromFd.
+ *
  * Create a buffered parser input for the progressive parsing for the input
  * from a file descriptor
  *
@@ -1751,7 +1715,6 @@ xmlParserInputBufferCreateFd(int fd, xmlCharEncoding enc) {
 }
 
 typedef struct {
-    char *mem;
     const char *cur;
     size_t size;
 } xmlMemIOCtxt;
@@ -1774,8 +1737,6 @@ static int
 xmlMemClose(void *vctxt) {
     xmlMemIOCtxt *ctxt = vctxt;
 
-    if (ctxt->mem != NULL)
-        xmlFree(ctxt->mem);
     xmlFree(ctxt);
     return(0);
 }
@@ -1795,42 +1756,46 @@ xmlParserInputBufferPtr
 xmlNewInputBufferMemory(const void *mem, size_t size, int flags,
                         xmlCharEncoding enc) {
     xmlParserInputBufferPtr ret;
-    xmlMemIOCtxt *ctxt;
-    char *copy = NULL;
 
-    if ((flags & XML_INPUT_BUF_STATIC) == 0) {
-        if (size + 1 == 0)
+    if ((flags & XML_INPUT_BUF_STATIC) &&
+        ((flags & XML_INPUT_BUF_ZERO_TERMINATED) == 0)) {
+        xmlMemIOCtxt *ctxt;
+
+        /*
+         * Static buffer without zero terminator.
+         * Stream memory to avoid a copy.
+         */
+        ret = xmlAllocParserInputBuffer(enc);
+        if (ret == NULL)
             return(NULL);
-        copy = xmlMalloc(size + 1);
-        if (copy == NULL)
+
+        ctxt = xmlMalloc(sizeof(*ctxt));
+        if (ctxt == NULL) {
+            xmlFreeParserInputBuffer(ret);
             return(NULL);
-        memcpy(copy, mem, size);
-        copy[size] = 0;
+        }
 
-        mem = copy;
-    }
+        ctxt->cur = mem;
+        ctxt->size = size;
 
-    ret = xmlAllocParserInputBuffer(enc);
-    if (ret == NULL) {
-        xmlFree(copy);
-        return(NULL);
-    }
+        ret->context = ctxt;
+        ret->readcallback = xmlMemRead;
+        ret->closecallback = xmlMemClose;
+    } else {
+        ret = xmlMalloc(sizeof(*ret));
+        if (ret == NULL)
+            return(NULL);
+        memset(ret, 0, sizeof(xmlParserInputBuffer));
+        ret->compressed = -1;
 
-    ctxt = xmlMalloc(sizeof(*ctxt));
-    if (ctxt == NULL) {
-        xmlFreeParserInputBuffer(ret);
-        xmlFree(copy);
-        return(NULL);
+        ret->buffer = xmlBufCreateMem((const xmlChar *) mem, size,
+                                      (flags & XML_INPUT_BUF_STATIC ? 1 : 0));
+        if (ret->buffer == NULL) {
+            xmlFree(ret);
+            return(NULL);
+        }
     }
 
-    ctxt->mem = copy;
-    ctxt->cur = mem;
-    ctxt->size = size;
-
-    ret->context = ctxt;
-    ret->readcallback = xmlMemRead;
-    ret->closecallback = xmlMemClose;
-
     return(ret);
 }
 
@@ -1840,6 +1805,8 @@ xmlNewInputBufferMemory(const void *mem, size_t size, int flags,
  * @size:  the length of the memory block
  * @enc:  the charset encoding if known (deprecated)
  *
+ * DEPRECATED: Use xmlNewInputFromMemory.
+ *
  * Create a parser input buffer for parsing from a memory area.
  *
  * This function makes a copy of the whole input buffer. If you are sure
@@ -1867,6 +1834,8 @@ xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
  * @size:  the length of the memory block
  * @enc:  the charset encoding if known
  *
+ * DEPRECATED: Use xmlNewInputFromMemory.
+ *
  * Create a parser input buffer for parsing from a memory area.
  *
  * This functions assumes that the contents of the input buffer remain
@@ -1888,65 +1857,34 @@ xmlParserInputBufferCreateStatic(const char *mem, int size,
     return(xmlNewInputBufferMemory(mem, size, XML_INPUT_BUF_STATIC, enc));
 }
 
-typedef struct {
-    const char *str;
-} xmlStringIOCtxt;
-
-static int
-xmlStringRead(void *vctxt, char *buf, int size) {
-    xmlStringIOCtxt *ctxt = vctxt;
-    const char *zero;
-    size_t len;
-
-    zero = memchr(ctxt->str, 0, size);
-    len = zero ? zero - ctxt->str : size;
-
-    memcpy(buf, ctxt->str, len);
-    ctxt->str += len;
-
-    return(len);
-}
-
-static int
-xmlStringClose(void *vctxt) {
-    xmlFree(vctxt);
-    return(0);
-}
-
 /**
  * xmlNewInputBufferString:
  * @str:  C string
  * @flags:  flags
  *
- * Create an input buffer for a null-teriminated C string.
+ * DEPRECATED: Use xmlNewInputFromString.
+ *
+ * Create an input buffer for a null-terminated C string.
  *
  * Returns the new input buffer or NULL.
  */
 xmlParserInputBufferPtr
 xmlNewInputBufferString(const char *str, int flags) {
     xmlParserInputBufferPtr ret;
-    xmlStringIOCtxt *ctxt;
 
-    if ((flags & XML_INPUT_BUF_STATIC) == 0)
-        return(xmlNewInputBufferMemory(str, strlen(str), flags,
-                                       XML_CHAR_ENCODING_NONE));
-
-    ret = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
+    ret = xmlMalloc(sizeof(*ret));
     if (ret == NULL)
-        return(NULL);
+	return(NULL);
+    memset(ret, 0, sizeof(xmlParserInputBuffer));
+    ret->compressed = -1;
 
-    ctxt = xmlMalloc(sizeof(*ctxt));
-    if (ctxt == NULL) {
-        xmlFreeParserInputBuffer(ret);
-        return(NULL);
+    ret->buffer = xmlBufCreateMem((const xmlChar *) str, strlen(str),
+                                  (flags & XML_INPUT_BUF_STATIC ? 1 : 0));
+    if (ret->buffer == NULL) {
+        xmlFree(ret);
+	return(NULL);
     }
 
-    ctxt->str = str;
-
-    ret->context = ctxt;
-    ret->readcallback = xmlStringRead;
-    ret->closecallback = xmlStringClose;
-
     return(ret);
 }
 
@@ -1959,6 +1897,8 @@ xmlNewInputBufferString(const char *str, int flags) {
  * Create a buffered output for the progressive saving
  * to a file descriptor
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new parser output or NULL
  */
 xmlOutputBufferPtr
@@ -1967,7 +1907,7 @@ xmlOutputBufferCreateFd(int fd, xmlCharEncodingHandlerPtr encoder) {
 
     if (fd < 0) return(NULL);
 
-    ret = xmlAllocOutputBufferInternal(encoder);
+    ret = xmlAllocOutputBuffer(encoder);
     if (ret != NULL) {
         ret->context = (void *) (ptrdiff_t) fd;
 	ret->writecallback = xmlFdWrite;
@@ -1985,6 +1925,8 @@ xmlOutputBufferCreateFd(int fd, xmlCharEncodingHandlerPtr encoder) {
  * @ioctx:  an I/O handler
  * @enc:  the charset encoding if known (deprecated)
  *
+ * DEPRECATED: Use xmlNewInputFromIO.
+ *
  * Create a buffered parser input for the progressive parsing for the input
  * from an I/O handler
  *
@@ -2022,6 +1964,8 @@ xmlParserInputBufferCreateIO(xmlInputReadCallback   ioread,
  * Create a buffered output for the progressive saving
  * to an I/O handler
  *
+ * Consumes @encoder even in error case.
+ *
  * Returns the new parser output or NULL
  */
 xmlOutputBufferPtr
@@ -2030,9 +1974,12 @@ xmlOutputBufferCreateIO(xmlOutputWriteCallback   iowrite,
 	 xmlCharEncodingHandlerPtr encoder) {
     xmlOutputBufferPtr ret;
 
-    if (iowrite == NULL) return(NULL);
+    if (iowrite == NULL) {
+        xmlCharEncCloseFunc(encoder);
+        return(NULL);
+    }
 
-    ret = xmlAllocOutputBufferInternal(encoder);
+    ret = xmlAllocOutputBuffer(encoder);
     if (ret != NULL) {
         ret->context = (void *) ioctx;
 	ret->writecallback = iowrite;
@@ -2096,6 +2043,8 @@ xmlOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)
  * @len:  the size in bytes of the array.
  * @buf:  an char array
  *
+ * DEPRECATED: Internal function, don't use.
+ *
  * Push the content of the arry in the input buffer
  * This routine handle the I18N transcoding to internal UTF-8
  * This is used when operating the parser in progressive (push) mode.
@@ -2106,7 +2055,7 @@ xmlOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)
 int
 xmlParserInputBufferPush(xmlParserInputBufferPtr in,
 	                 int len, const char *buf) {
-    int nbchars = 0;
+    size_t nbchars = 0;
     int ret;
 
     if (len < 0) return(0);
@@ -2116,7 +2065,7 @@ xmlParserInputBufferPush(xmlParserInputBufferPtr in,
 	 * Store the data in the incoming raw buffer
 	 */
         if (in->raw == NULL) {
-	    in->raw = xmlBufCreate();
+	    in->raw = xmlBufCreate(50);
             if (in->raw == NULL) {
                 in->error = XML_ERR_NO_MEMORY;
                 return(-1);
@@ -2131,9 +2080,11 @@ xmlParserInputBufferPush(xmlParserInputBufferPtr in,
 	/*
 	 * convert as much as possible to the parser reading buffer.
 	 */
-	nbchars = xmlCharEncInput(in);
-	if (nbchars < 0)
-	    return(-1);
+        nbchars = SIZE_MAX;
+	if (xmlCharEncInput(in, &nbchars) < 0)
+            return(-1);
+        if (nbchars > INT_MAX)
+            nbchars = INT_MAX;
     } else {
 	nbchars = len;
         ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);
@@ -2163,41 +2114,49 @@ endOfInput (void * context ATTRIBUTE_UNUSED,
  * @in:  a buffered parser input
  * @len:  indicative value of the amount of chars to read
  *
+ * DEPRECATED: Internal function, don't use.
+ *
  * Grow up the content of the input buffer, the old data are preserved
  * This routine handle the I18N transcoding to internal UTF-8
  * This routine is used when operating the parser in normal (pull) mode
  *
- * TODO: one should be able to remove one extra copy by copying directly
- *       onto in->buffer or in->raw
- *
  * Returns the number of chars read and stored in the buffer, or -1
  *         in case of error.
  */
 int
 xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
-    xmlBufPtr buf;
     int res = 0;
 
-    if ((in == NULL) || (in->error)) return(-1);
-    if ((len <= MINLEN) && (len != 4))
-        len = MINLEN;
+    if ((in == NULL) || (in->error))
+        return(-1);
 
-    if (in->encoder == NULL) {
-        if (in->readcallback == NULL)
-            return(0);
-        buf = in->buffer;
-    } else {
-        if (in->raw == NULL) {
-	    in->raw = xmlBufCreate();
-	}
-        buf = in->raw;
-    }
+    if (len < MINLEN)
+        len = MINLEN;
 
     /*
      * Call the read method for this I/O type.
      */
     if (in->readcallback != NULL) {
-        if (xmlBufGrow(buf, len + 1) < 0) {
+        xmlBufPtr buf;
+
+        if (in->encoder == NULL) {
+            buf = in->buffer;
+        } else {
+            /*
+             * Some users only set 'encoder' and expect us to create
+             * the raw buffer lazily.
+             */
+            if (in->raw == NULL) {
+                in->raw = xmlBufCreate(XML_IO_BUFFER_SIZE);
+                if (in->raw == NULL) {
+                    in->error = XML_ERR_NO_MEMORY;
+                    return(-1);
+                }
+            }
+            buf = in->raw;
+        }
+
+        if (xmlBufGrow(buf, len) < 0) {
             in->error = XML_ERR_NO_MEMORY;
             return(-1);
         }
@@ -2220,19 +2179,22 @@ xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
     }
 
     /*
-     * try to establish compressed status of input if not done already
+     * Handle encoding.
      */
-    if (in->compressed == -1) {
-#ifdef LIBXML_LZMA_ENABLED
-	if (in->readcallback == xmlXzfileRead)
-            in->compressed = __libxml2_xzcompressed(in->context);
-#endif
-    }
-
     if (in->encoder != NULL) {
-	res = xmlCharEncInput(in);
-	if (res < 0)
+        size_t sizeOut;
+
+        /*
+         * Don't convert whole buffer when reading from memory.
+         */
+        if (in->readcallback == NULL)
+            sizeOut = len;
+        else
+            sizeOut = SIZE_MAX;
+
+	if (xmlCharEncInput(in, &sizeOut) < 0)
 	    return(-1);
+        res = sizeOut;
     }
     return(res);
 }
@@ -2242,9 +2204,9 @@ xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
  * @in:  a buffered parser input
  * @len:  indicative value of the amount of chars to read
  *
- * Refresh the content of the input buffer, the old data are considered
- * consumed
- * This routine handle the I18N transcoding to internal UTF-8
+ * DEPRECATED: Internal function, don't use.
+ *
+ * Same as xmlParserInputBufferGrow.
  *
  * Returns the number of chars read and stored in the buffer, or -1
  *         in case of error.
@@ -2259,7 +2221,7 @@ xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {
  * xmlOutputBufferWrite:
  * @out:  a buffered parser output
  * @len:  the size in bytes of the array.
- * @buf:  an char array
+ * @data:  an char array
  *
  * Write the content of the array in the output I/O buffer
  * This routine handle the I18N transcoding from internal UTF-8
@@ -2270,20 +2232,28 @@ xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {
  *         in case of error.
  */
 int
-xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
-    int nbchars = 0; /* number of chars to output to I/O */
-    int ret;         /* return from function call */
-    int written = 0; /* number of char written to I/O so far */
-    int chunk;       /* number of byte current processed from buf */
+xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *data) {
+    size_t written = 0;
 
-    if ((out == NULL) || (out->error)) return(-1);
-    if (len < 0) return(0);
-    if (out->error) return(-1);
+    if ((out == NULL) || (out->error))
+        return(-1);
+    if (len < 0)
+        return(0);
+
+    while (len > 0) {
+        xmlBufPtr buf = NULL;
+        int chunk;
+        int ret;
 
-    do {
 	chunk = len;
-	if (chunk > 4 * MINLEN)
-	    chunk = 4 * MINLEN;
+	if (chunk > 256 * 1024)
+	    chunk = 256 * 1024;
+
+        ret = xmlBufAdd(out->buffer, (const xmlChar *) data, chunk);
+        if (ret != 0) {
+            out->error = XML_ERR_NO_MEMORY;
+            return(-1);
+        }
 
 	/*
 	 * first handle encoding stuff.
@@ -2293,137 +2263,71 @@ xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
 	     * Store the data in the incoming raw buffer
 	     */
 	    if (out->conv == NULL) {
-		out->conv = xmlBufCreate();
+		out->conv = xmlBufCreate(MINLEN);
                 if (out->conv == NULL) {
                     out->error = XML_ERR_NO_MEMORY;
                     return(-1);
                 }
 	    }
-	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
-	    if (ret != 0) {
-                out->error = XML_ERR_NO_MEMORY;
-	        return(-1);
-            }
-
-	    if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))
-		goto done;
 
 	    /*
 	     * convert as much as possible to the parser reading buffer.
 	     */
-	    ret = xmlCharEncOutput(out, 0);
-	    if (ret < 0)
-		return(-1);
+            if (xmlBufUse(out->buffer) < 256) {
+                ret = 0;
+            } else {
+                ret = xmlCharEncOutput(out, 0);
+                if (ret < 0)
+                    return(-1);
+            }
+
             if (out->writecallback)
-	        nbchars = xmlBufUse(out->conv);
+                buf = out->conv;
             else
-                nbchars = ret >= 0 ? ret : 0;
+                written += ret;
 	} else {
-	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
-	    if (ret != 0) {
-                out->error = XML_ERR_NO_MEMORY;
-	        return(-1);
-            }
             if (out->writecallback)
-	        nbchars = xmlBufUse(out->buffer);
+	        buf = out->buffer;
             else
-                nbchars = chunk;
+                written += chunk;
 	}
-	buf += chunk;
+	data += chunk;
 	len -= chunk;
 
-	if (out->writecallback) {
-            if ((nbchars < MINLEN) && (len <= 0))
-                goto done;
-
+	if ((buf != NULL) && (out->writecallback)) {
 	    /*
 	     * second write the stuff to the I/O channel
 	     */
-	    if (out->encoder != NULL) {
-		ret = out->writecallback(out->context,
-                           (const char *)xmlBufContent(out->conv), nbchars);
-		if (ret >= 0)
-		    xmlBufShrink(out->conv, ret);
-	    } else {
-		ret = out->writecallback(out->context,
-                           (const char *)xmlBufContent(out->buffer), nbchars);
-		if (ret >= 0)
-		    xmlBufShrink(out->buffer, ret);
-	    }
-	    if (ret < 0) {
-		out->error = (ret == -1) ? XML_IO_WRITE : -ret;
-		return(ret);
-	    }
-            if (out->written > INT_MAX - ret)
-                out->written = INT_MAX;
-            else
-                out->written += ret;
-	}
-	written += nbchars;
-    } while (len > 0);
+	    while (1) {
+                size_t nbchars = xmlBufUse(buf);
 
-done:
-    return(written);
-}
+                if (nbchars < MINLEN)
+                    break;
+                if (nbchars > 256 * 1024)
+                    nbchars = 256 * 1024;
 
-/**
- * xmlEscapeContent:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of unescaped UTF-8 bytes
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and escape them.
- * Returns 0 if success, or -1 otherwise
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
- */
-static int
-xmlEscapeContent(unsigned char* out, int *outlen,
-                 const xmlChar* in, int *inlen) {
-    unsigned char* outstart = out;
-    const unsigned char* base = in;
-    unsigned char* outend = out + *outlen;
-    const unsigned char* inend;
-
-    inend = in + (*inlen);
-
-    while ((in < inend) && (out < outend)) {
-	if (*in == '<') {
-	    if (outend - out < 4) break;
-	    *out++ = '&';
-	    *out++ = 'l';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*in == '>') {
-	    if (outend - out < 4) break;
-	    *out++ = '&';
-	    *out++ = 'g';
-	    *out++ = 't';
-	    *out++ = ';';
-	} else if (*in == '&') {
-	    if (outend - out < 5) break;
-	    *out++ = '&';
-	    *out++ = 'a';
-	    *out++ = 'm';
-	    *out++ = 'p';
-	    *out++ = ';';
-	} else if (*in == '\r') {
-	    if (outend - out < 5) break;
-	    *out++ = '&';
-	    *out++ = '#';
-	    *out++ = '1';
-	    *out++ = '3';
-	    *out++ = ';';
-	} else {
-	    *out++ = *in;
+		ret = out->writecallback(out->context,
+                           (const char *)xmlBufContent(buf), nbchars);
+                if (ret < 0) {
+                    out->error = (ret == -1) ? XML_IO_WRITE : -ret;
+                    return(-1);
+                }
+                if ((ret == 0) || ((size_t) ret > nbchars)) {
+                    out->error = XML_ERR_INTERNAL_ERROR;
+                    return(-1);
+                }
+
+		xmlBufShrink(buf, ret);
+	        written += ret;
+                if (out->written > INT_MAX - ret)
+                    out->written = INT_MAX;
+                else
+                    out->written += ret;
+            }
 	}
-	++in;
     }
-    *outlen = out - outstart;
-    *inlen = in - base;
-    return(0);
+
+    return(written <= INT_MAX ? written : INT_MAX);
 }
 
 /**
@@ -2444,130 +2348,61 @@ xmlEscapeContent(unsigned char* out, int *outlen,
 int
 xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str,
                            xmlCharEncodingOutputFunc escaping) {
-    int nbchars = 0; /* number of chars to output to I/O */
-    int ret;         /* return from function call */
-    int written = 0; /* number of char written to I/O so far */
-    int oldwritten=0;/* loop guard */
-    int chunk;       /* number of byte currently processed from str */
-    int len;         /* number of bytes in str */
-    int cons;        /* byte from str consumed */
-
-    if ((out == NULL) || (out->error) || (str == NULL) ||
-        (out->buffer == NULL))
+    int ret;
+    int written = 0;
+    size_t len;
+
+    if ((out == NULL) || (out->error) || (str == NULL))
         return(-1);
-    len = strlen((const char *)str);
-    if (len < 0) return(0);
-    if (out->error) return(-1);
-    if (escaping == NULL) escaping = xmlEscapeContent;
 
-    do {
-        oldwritten = written;
+    len = strlen((const char *) str);
+    if (len >= INT_MAX) {
+        out->error = XML_ERR_RESOURCE_LIMIT;
+        return(-1);
+    }
 
-        /*
-	 * how many bytes to consume and how many bytes to store.
-	 */
-	cons = len;
-	chunk = xmlBufAvail(out->buffer);
+    if (escaping == NULL) {
+        char *escaped = (char *) xmlEscapeText(str, XML_ESCAPE_ALLOW_INVALID);
 
-        /*
-	 * make sure we have enough room to save first, if this is
-	 * not the case force a flush, but make sure we stay in the loop
-	 */
-	if (chunk < 40) {
-	    if (xmlBufGrow(out->buffer, 100) < 0) {
-                out->error = XML_ERR_NO_MEMORY;
-	        return(-1);
-            }
-            oldwritten = -1;
-	    continue;
-	}
+        if (escaped == NULL) {
+            out->error = XML_ERR_NO_MEMORY;
+            return(-1);
+        }
 
-	/*
-	 * first handle encoding stuff.
-	 */
-	if (out->encoder != NULL) {
-	    /*
-	     * Store the data in the incoming raw buffer
-	     */
-	    if (out->conv == NULL) {
-		out->conv = xmlBufCreate();
-                if (out->conv == NULL) {
-                    out->error = XML_ERR_NO_MEMORY;
-                    return(-1);
-                }
-	    }
-	    ret = escaping(xmlBufEnd(out->buffer) ,
-	                   &chunk, str, &cons);
-            if (ret < 0) {
-                out->error = XML_ERR_NO_MEMORY;
-                return(-1);
-            }
-            xmlBufAddLen(out->buffer, chunk);
+        len = strlen(escaped);
+        if (len >= INT_MAX) {
+            out->error = XML_ERR_RESOURCE_LIMIT;
+            return(-1);
+        }
 
-	    if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))
-		goto done;
+        ret = xmlOutputBufferWrite(out, len, escaped);
 
-	    /*
-	     * convert as much as possible to the output buffer.
-	     */
-	    ret = xmlCharEncOutput(out, 0);
-	    if (ret < 0)
-		return(-1);
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->conv);
-            else
-                nbchars = ret >= 0 ? ret : 0;
-	} else {
-	    ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);
-            if (ret < 0) {
-                out->error = XML_ERR_NO_MEMORY;
-                return(-1);
-            }
-            xmlBufAddLen(out->buffer, chunk);
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->buffer);
-            else
-                nbchars = chunk;
-	}
-	str += cons;
-	len -= cons;
+        xmlFree(escaped);
+        return(ret);
+    }
 
-	if (out->writecallback) {
-            if ((nbchars < MINLEN) && (len <= 0))
-                goto done;
+    while (len > 0) {
+        xmlChar buf[1024];
+        int c_out;
+        int c_in;
 
-	    /*
-	     * second write the stuff to the I/O channel
-	     */
-	    if (out->encoder != NULL) {
-		ret = out->writecallback(out->context,
-                           (const char *)xmlBufContent(out->conv), nbchars);
-		if (ret >= 0)
-		    xmlBufShrink(out->conv, ret);
-	    } else {
-		ret = out->writecallback(out->context,
-                           (const char *)xmlBufContent(out->buffer), nbchars);
-		if (ret >= 0)
-		    xmlBufShrink(out->buffer, ret);
-	    }
-	    if (ret < 0) {
-		out->error = (ret == -1) ? XML_IO_WRITE : -ret;
-		return(-1);
-	    }
-            if (out->written > INT_MAX - ret)
-                out->written = INT_MAX;
-            else
-                out->written += ret;
-	} else if (xmlBufAvail(out->buffer) < MINLEN) {
-            if (xmlBufGrow(out->buffer, MINLEN) < 0) {
-                out->error = XML_ERR_NO_MEMORY;
-                return(-1);
-            }
-	}
-	written += nbchars;
-    } while ((len > 0) && (oldwritten != written));
+	c_out = 1024;
+	c_in = len;
+
+        ret = escaping(buf, &c_out, str, &c_in);
+        if (ret < 0) {
+            out->error = XML_ERR_NO_MEMORY;
+            return(-1);
+        }
+        str += c_in;
+        len -= c_in;
+
+        ret = xmlOutputBufferWrite(out, c_out, (char *) buf);
+        if (ret < 0)
+            return(ret);
+        written += ret;
+    }
 
-done:
     return(written);
 }
 
@@ -2739,10 +2574,7 @@ xmlParserGetDirectory(const char *filename) {
 	else *cur = 0;
 	ret = xmlMemStrdup(dir);
     } else {
-        if (getcwd(dir, 1024) != NULL) {
-	    dir[1023] = 0;
-	    ret = xmlMemStrdup(dir);
-	}
+        ret = xmlMemStrdup(".");
     }
     return(ret);
 #undef IS_XMLPGD_SEP
@@ -2818,6 +2650,8 @@ int
 xmlRegisterInputCallbacks(xmlInputMatchCallback matchFunc,
 	xmlInputOpenCallback openFunc, xmlInputReadCallback readFunc,
 	xmlInputCloseCallback closeFunc) {
+    xmlInitParser();
+
     if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
 	return(-1);
     }
@@ -2849,6 +2683,8 @@ xmlRegisterDefaultInputCallbacks(void) {
 int
 xmlPopInputCallbacks(void)
 {
+    xmlInitParser();
+
     if (xmlInputCallbackNr <= 0)
         return(-1);
 
@@ -2866,6 +2702,8 @@ xmlPopInputCallbacks(void)
 void
 xmlCleanupInputCallbacks(void)
 {
+    xmlInitParser();
+
     xmlInputCallbackNr = 0;
 }
 
@@ -2885,6 +2723,8 @@ int
 xmlRegisterOutputCallbacks(xmlOutputMatchCallback matchFunc,
 	xmlOutputOpenCallback openFunc, xmlOutputWriteCallback writeFunc,
 	xmlOutputCloseCallback closeFunc) {
+    xmlInitParser();
+
     if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
 	return(-1);
     }
@@ -2916,6 +2756,8 @@ xmlRegisterDefaultOutputCallbacks (void) {
 int
 xmlPopOutputCallbacks(void)
 {
+    xmlInitParser();
+
     if (xmlOutputCallbackNr <= 0)
         return(-1);
 
@@ -2933,6 +2775,8 @@ xmlPopOutputCallbacks(void)
 void
 xmlCleanupOutputCallbacks(void)
 {
+    xmlInitParser();
+
     xmlOutputCallbackNr = 0;
 }
 
diff --git a/xmlcatalog.c b/xmlcatalog.c
index 588802b4..a32f688e 100644
--- a/xmlcatalog.c
+++ b/xmlcatalog.c
@@ -13,6 +13,13 @@
 #include <stdarg.h>
 #include <stdlib.h>
 
+#ifdef _WIN32
+  #include <fcntl.h>
+  #include <io.h>
+#else
+  #include <unistd.h>
+#endif
+
 #ifdef HAVE_LIBREADLINE
 #include <readline/readline.h>
 #ifdef HAVE_LIBHISTORY
@@ -25,6 +32,10 @@
 #include <libxml/catalog.h>
 #include <libxml/parser.h>
 
+#ifndef STDIN_FILENO
+  #define STDIN_FILENO 0
+#endif
+
 #if defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
 static int shell = 0;
 static int sgml = 0;
@@ -58,35 +69,39 @@ static char *filename = NULL;
  */
 static char *
 xmlShellReadline(const char *prompt) {
+    char buf[501];
+    char *ret;
+    int len;
+
 #ifdef HAVE_LIBREADLINE
-    char *line_read;
+    if (isatty(STDIN_FILENO)) {
+        char *line_read;
 
-    /* Get a line from the user. */
-    line_read = readline (prompt);
+        /* Get a line from the user. */
+        line_read = readline (prompt);
 
-    /* If the line has any text in it, save it on the history. */
-    if (line_read && *line_read)
-	add_history (line_read);
+#ifdef HAVE_LIBHISTORY
+        /* If the line has any text in it, save it on the history. */
+        if (line_read && *line_read)
+           add_history (line_read);
+#endif
 
-    return (line_read);
-#else
-    char line_read[501];
-    char *ret;
-    int len;
+        return (line_read);
+    }
+#endif
 
     if (prompt != NULL)
-	fprintf(stdout, "%s", prompt);
+       fprintf(stdout, "%s", prompt);
     fflush(stdout);
-    if (!fgets(line_read, 500, stdin))
+    if (!fgets(buf, 500, stdin))
         return(NULL);
-    line_read[500] = 0;
-    len = strlen(line_read);
+    buf[500] = 0;
+    len = strlen(buf);
     ret = (char *) malloc(len + 1);
     if (ret != NULL) {
-	memcpy (ret, line_read, len + 1);
+       memcpy (ret, buf, len + 1);
     }
     return(ret);
-#endif
 }
 
 static void usershell(void) {
@@ -313,6 +328,11 @@ int main(int argc, char **argv) {
     int ret;
     int exit_value = 0;
 
+#ifdef _WIN32
+    _setmode(_fileno(stdin), _O_BINARY);
+    _setmode(_fileno(stdout), _O_BINARY);
+    _setmode(_fileno(stderr), _O_BINARY);
+#endif
 
     if (argc <= 1) {
 	usage(argv[0]);
@@ -401,6 +421,13 @@ int main(int argc, char **argv) {
 	    if ((ret < 0) && (create)) {
 		xmlCatalogAdd(BAD_CAST "catalog", BAD_CAST argv[i], NULL);
 	    }
+
+            /*
+             * Catalogs are loaded lazily. Make sure that dumping works
+             * by the issuing a dummy request that forces the catalog to
+             * be loaded.
+             */
+            xmlCatalogResolvePublic(BAD_CAST "");
 	}
 	break;
     }
@@ -475,7 +502,7 @@ int main(int argc, char **argv) {
 		    if (xmlCatalogIsEmpty(catal)) {
 			remove(argv[i + 1]);
 		    } else {
-			out = fopen(argv[i + 1], "w");
+			out = fopen(argv[i + 1], "wb");
 			if (out == NULL) {
 			    fprintf(stderr, "could not open %s for saving\n",
 				    argv[i + 1]);
@@ -490,7 +517,7 @@ int main(int argc, char **argv) {
 			if (xmlCatalogIsEmpty(super)) {
 			    remove(XML_SGML_DEFAULT_CATALOG);
 			} else {
-			    out = fopen(XML_SGML_DEFAULT_CATALOG, "w");
+			    out = fopen(XML_SGML_DEFAULT_CATALOG, "wb");
 			    if (out == NULL) {
 				fprintf(stderr,
 					"could not open %s for saving\n",
@@ -580,7 +607,7 @@ int main(int argc, char **argv) {
 	if (noout && filename && *filename) {
 	    FILE *out;
 
-	    out = fopen(filename, "w");
+	    out = fopen(filename, "wb");
 	    if (out == NULL) {
 		fprintf(stderr, "could not open %s for saving\n", filename);
 		exit_value = 2;
diff --git a/xmllint.c b/xmllint.c
index e603f209..006bb846 100644
--- a/xmllint.c
+++ b/xmllint.c
@@ -17,35 +17,23 @@
 #include <errno.h>
 #include <limits.h>
 
-#ifdef HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef HAVE_SYS_TIMEB_H
-#include <sys/timeb.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+  #include <io.h>
+  #include <sys/timeb.h>
+#else
+  #include <sys/time.h>
+  #include <unistd.h>
 #endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#elif defined (_WIN32)
-#include <io.h>
-#endif
-#ifdef HAVE_SYS_MMAN_H
-#include <sys/mman.h>
-/* seems needed for Solaris */
-#ifndef MAP_FAILED
-#define MAP_FAILED ((void *) -1)
-#endif
-#endif
-#ifdef HAVE_LIBREADLINE
-#include <readline/readline.h>
-#ifdef HAVE_LIBHISTORY
-#include <readline/history.h>
-#endif
+
+#if HAVE_DECL_MMAP
+  #include <sys/mman.h>
+  /* seems needed for Solaris */
+  #ifndef MAP_FAILED
+    #define MAP_FAILED ((void *) -1)
+  #endif
 #endif
 
 #include <libxml/xmlmemory.h>
@@ -81,6 +69,8 @@
 #include <libxml/xmlsave.h>
 #endif
 
+#include "private/shell.h"
+
 #ifdef XMLLINT_FUZZ
   #define ERR_STREAM stdout
 #else
@@ -110,15 +100,13 @@ typedef enum {
     XMLLINT_ERR_XPATH_EMPTY = 11    /* XPath result is empty */
 } xmllintReturnCode;
 
-#ifdef LIBXML_DEBUG_ENABLED
 static int shell = 0;
+#ifdef LIBXML_DEBUG_ENABLED
 static int debugent = 0;
 #endif
 static int debug = 0;
 static int maxmem = 0;
-#ifdef LIBXML_TREE_ENABLED
 static int copy = 0;
-#endif /* LIBXML_TREE_ENABLED */
 static int noout = 0;
 #ifdef LIBXML_OUTPUT_ENABLED
 static const char *output = NULL;
@@ -150,9 +138,9 @@ static int xmlout = 0;
 static int htmlout = 0;
 #ifdef LIBXML_PUSH_ENABLED
 static int push = 0;
-static int pushsize = 4096;
+static const int pushsize = 4096;
 #endif /* LIBXML_PUSH_ENABLED */
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
 static int memory = 0;
 #endif
 static int testIO = 0;
@@ -246,7 +234,7 @@ xmllintResourceLoader(void *ctxt ATTRIBUTE_UNUSED, const char *URL,
     if (defaultResourceLoader != NULL)
         code = defaultResourceLoader(NULL, URL, ID, type, flags, out);
     else
-        code = xmlInputCreateUrl(URL, flags, out);
+        code = xmlNewInputFromUrl(URL, flags, out);
     if (code != XML_IO_ENOENT) {
         if ((load_trace) && (code == XML_ERR_OK)) {
             fprintf(ERR_STREAM, "Loaded URL=\"%s\" ID=\"%s\"\n",
@@ -266,7 +254,7 @@ xmllintResourceLoader(void *ctxt ATTRIBUTE_UNUSED, const char *URL,
                 code = defaultResourceLoader(NULL, (const char *) newURL, ID,
                                              type, flags, out);
             else
-                code = xmlInputCreateUrl((const char *) newURL, flags, out);
+                code = xmlNewInputFromUrl((const char *) newURL, flags, out);
             if (code != XML_IO_ENOENT) {
                 if ((load_trace) && (code == XML_ERR_OK)) {
                     fprintf(ERR_STREAM, "Loaded URL=\"%s\" ID=\"%s\"\n",
@@ -349,33 +337,29 @@ myStrdupFunc(const char *str)
  *									*
  ************************************************************************/
 
-#ifndef HAVE_GETTIMEOFDAY
-#ifdef HAVE_SYS_TIMEB_H
-#ifdef HAVE_SYS_TIME_H
-#ifdef HAVE_FTIME
+typedef struct {
+   int sec;
+   int usec;
+} xmlTime;
 
-static int
-my_gettimeofday(struct timeval *tvp, void *tzp)
-{
-	struct timeb timebuffer;
+static xmlTime begin, end;
 
-	ftime(&timebuffer);
-	if (tvp) {
-		tvp->tv_sec = timebuffer.time;
-		tvp->tv_usec = timebuffer.millitm * 1000L;
-	}
-	return (0);
-}
-#define HAVE_GETTIMEOFDAY 1
-#define gettimeofday my_gettimeofday
+static void
+getTime(xmlTime *time) {
+#ifdef _WIN32
+    struct timeb timebuffer;
 
-#endif /* HAVE_FTIME */
-#endif /* HAVE_SYS_TIME_H */
-#endif /* HAVE_SYS_TIMEB_H */
-#endif /* !HAVE_GETTIMEOFDAY */
+    ftime(&timebuffer);
+    time->sec = timebuffer.time;
+    time->usec = timebuffer.millitm * 1000L;
+#else /* _WIN32 */
+    struct timeval tv;
 
-#if defined(HAVE_GETTIMEOFDAY)
-static struct timeval begin, end;
+    gettimeofday(&tv, NULL);
+    time->sec = tv.tv_sec;
+    time->usec = tv.tv_usec;
+#endif /* _WIN32 */
+}
 
 /*
  * startTimer: call where you want to start timing
@@ -383,7 +367,7 @@ static struct timeval begin, end;
 static void
 startTimer(void)
 {
-    gettimeofday(&begin, NULL);
+    getTime(&begin);
 }
 
 /*
@@ -397,10 +381,10 @@ endTimer(const char *fmt, ...)
     long msec;
     va_list ap;
 
-    gettimeofday(&end, NULL);
-    msec = end.tv_sec - begin.tv_sec;
+    getTime(&end);
+    msec = end.sec - begin.sec;
     msec *= 1000;
-    msec += (end.tv_usec - begin.tv_usec) / 1000;
+    msec += (end.usec - begin.usec) / 1000;
 
     va_start(ap, fmt);
     vfprintf(ERR_STREAM, fmt, ap);
@@ -408,37 +392,7 @@ endTimer(const char *fmt, ...)
 
     fprintf(ERR_STREAM, " took %ld ms\n", msec);
 }
-#else
-/*
- * No gettimeofday function, so we have to make do with calling clock.
- * This is obviously less accurate, but there's little we can do about
- * that.
- */
-#ifndef CLOCKS_PER_SEC
-#define CLOCKS_PER_SEC 100
-#endif
-
-static clock_t begin, end;
-static void
-startTimer(void)
-{
-    begin = clock();
-}
-static void LIBXML_ATTR_FORMAT(1,2)
-endTimer(const char *fmt, ...)
-{
-    long msec;
-    va_list ap;
-
-    end = clock();
-    msec = ((end - begin) * 1000) / CLOCKS_PER_SEC;
 
-    va_start(ap, fmt);
-    vfprintf(ERR_STREAM, fmt, ap);
-    va_end(ap);
-    fprintf(ERR_STREAM, " took %ld ms\n", msec);
-}
-#endif
 /************************************************************************
  *									*
  *			HTML output					*
@@ -483,16 +437,30 @@ xmlHTMLBufCat(void *data ATTRIBUTE_UNUSED, const char *fmt, ...) {
     }
 }
 
+/**
+ * xmlHTMLError:
+ * @ctx:  an XML parser context
+ * @msg:  the message to display/transmit
+ * @...:  extra parameters for the message display
+ *
+ * Display and format an error messages, gives file, line, position and
+ * extra parameters.
+ */
 static void
-xmlHTMLPrintError(void *ctx, const char *level, const char *msg, va_list ap) {
-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
+xmlHTMLError(void *vctxt, const xmlError *error)
+{
+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) vctxt;
     xmlParserInputPtr input;
+    xmlGenericErrorFunc oldError;
+    void *oldErrorCtxt;
 
     input = ctxt->input;
     if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) {
         input = ctxt->inputTab[ctxt->inputNr - 2];
     }
 
+    oldError = xmlGenericError;
+    oldErrorCtxt = xmlGenericErrorContext;
     xmlSetGenericErrorFunc(NULL, xmlHTMLBufCat);
 
     fprintf(ERR_STREAM, "<p>");
@@ -500,9 +468,12 @@ xmlHTMLPrintError(void *ctx, const char *level, const char *msg, va_list ap) {
     xmlParserPrintFileInfo(input);
     xmlHTMLEncodeSend();
 
-    fprintf(ERR_STREAM, "<b>%s</b>: ", level);
+    fprintf(ERR_STREAM, "<b>%s%s</b>: ",
+            (error->domain == XML_FROM_VALID) ||
+            (error->domain == XML_FROM_DTD) ? "validity " : "",
+            error->level == XML_ERR_WARNING ? "warning" : "error");
 
-    vsnprintf(buffer, sizeof(buffer), msg, ap);
+    snprintf(buffer, sizeof(buffer), "%s", error->message);
     xmlHTMLEncodeSend();
 
     fprintf(ERR_STREAM, "</p>\n");
@@ -516,138 +487,9 @@ xmlHTMLPrintError(void *ctx, const char *level, const char *msg, va_list ap) {
         fprintf(ERR_STREAM, "</pre>");
     }
 
-    xmlSetGenericErrorFunc(NULL, NULL);
-}
-
-/**
- * xmlHTMLError:
- * @ctx:  an XML parser context
- * @msg:  the message to display/transmit
- * @...:  extra parameters for the message display
- *
- * Display and format an error messages, gives file, line, position and
- * extra parameters.
- */
-static void LIBXML_ATTR_FORMAT(2,3)
-xmlHTMLError(void *ctx, const char *msg, ...)
-{
-    va_list args;
-
-    va_start(args, msg);
-    xmlHTMLPrintError(ctx, "error", msg, args);
-    va_end(args);
-}
-
-/**
- * xmlHTMLWarning:
- * @ctx:  an XML parser context
- * @msg:  the message to display/transmit
- * @...:  extra parameters for the message display
- *
- * Display and format a warning messages, gives file, line, position and
- * extra parameters.
- */
-static void LIBXML_ATTR_FORMAT(2,3)
-xmlHTMLWarning(void *ctx, const char *msg, ...)
-{
-    va_list args;
-
-    va_start(args, msg);
-    xmlHTMLPrintError(ctx, "warning", msg, args);
-    va_end(args);
-}
-
-/**
- * xmlHTMLValidityError:
- * @ctx:  an XML parser context
- * @msg:  the message to display/transmit
- * @...:  extra parameters for the message display
- *
- * Display and format an validity error messages, gives file,
- * line, position and extra parameters.
- */
-static void LIBXML_ATTR_FORMAT(2,3)
-xmlHTMLValidityError(void *ctx, const char *msg, ...)
-{
-    va_list args;
-
-    va_start(args, msg);
-    xmlHTMLPrintError(ctx, "validity error", msg, args);
-    va_end(args);
-
-    progresult = XMLLINT_ERR_VALID;
-}
-
-/**
- * xmlHTMLValidityWarning:
- * @ctx:  an XML parser context
- * @msg:  the message to display/transmit
- * @...:  extra parameters for the message display
- *
- * Display and format a validity warning messages, gives file, line,
- * position and extra parameters.
- */
-static void LIBXML_ATTR_FORMAT(2,3)
-xmlHTMLValidityWarning(void *ctx, const char *msg, ...)
-{
-    va_list args;
-
-    va_start(args, msg);
-    xmlHTMLPrintError(ctx, "validity warning", msg, args);
-    va_end(args);
+    xmlSetGenericErrorFunc(oldErrorCtxt, oldError);
 }
 
-/************************************************************************
- *									*
- *			Shell Interface					*
- *									*
- ************************************************************************/
-#ifdef LIBXML_DEBUG_ENABLED
-#ifdef LIBXML_XPATH_ENABLED
-/**
- * xmlShellReadline:
- * @prompt:  the prompt value
- *
- * Read a string
- *
- * Returns a pointer to it or NULL on EOF the caller is expected to
- *     free the returned string.
- */
-static char *
-xmlShellReadline(char *prompt) {
-#ifdef HAVE_LIBREADLINE
-    char *line_read;
-
-    /* Get a line from the user. */
-    line_read = readline (prompt);
-
-    /* If the line has any text in it, save it on the history. */
-    if (line_read && *line_read)
-	add_history (line_read);
-
-    return (line_read);
-#else
-    char line_read[501];
-    char *ret;
-    int len;
-
-    if (prompt != NULL)
-	fprintf(stdout, "%s", prompt);
-    fflush(stdout);
-    if (!fgets(line_read, 500, stdin))
-        return(NULL);
-    line_read[500] = 0;
-    len = strlen(line_read);
-    ret = (char *) malloc(len + 1);
-    if (ret != NULL) {
-	memcpy (ret, line_read, len + 1);
-    }
-    return(ret);
-#endif
-}
-#endif /* LIBXML_XPATH_ENABLED */
-#endif /* LIBXML_DEBUG_ENABLED */
-
 /************************************************************************
  *									*
  *			I/O Interfaces					*
@@ -1589,13 +1431,8 @@ static void processNode(xmlTextReaderPtr reader) {
 	    match = xmlPatternMatch(patternc, xmlTextReaderCurrentNode(reader));
 
 	    if (match) {
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
 		path = xmlGetNodePath(xmlTextReaderCurrentNode(reader));
 		printf("Node %s matches pattern %s\n", path, pattern);
-#else
-                printf("Node %s matches pattern %s\n",
-                       xmlTextReaderConstName(reader), pattern);
-#endif
 	    }
 	}
 	if (patstream != NULL) {
@@ -1610,12 +1447,10 @@ static void processNode(xmlTextReaderPtr reader) {
                     xmlFreeStreamCtxt(patstream);
 		    patstream = NULL;
 		} else if (ret != match) {
-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
 		    if (path == NULL) {
 		        path = xmlGetNodePath(
 		                       xmlTextReaderCurrentNode(reader));
 		    }
-#endif
 		    fprintf(ERR_STREAM,
 		            "xmlPatternMatch and xmlStreamPush disagree\n");
                     if (path != NULL)
@@ -1646,7 +1481,7 @@ static void processNode(xmlTextReaderPtr reader) {
 static void streamFile(const char *filename) {
     xmlTextReaderPtr reader;
     int ret;
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
     int fd = -1;
     struct stat info;
     const char *base = NULL;
@@ -1654,7 +1489,8 @@ static void streamFile(const char *filename) {
     if (memory) {
 	if (stat(filename, &info) < 0)
 	    return;
-	if ((fd = open(filename, O_RDONLY)) < 0)
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
 	    return;
 	base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;
 	if (base == (void *) MAP_FAILED) {
@@ -1794,7 +1630,7 @@ static void streamFile(const char *filename) {
 	patstream = NULL;
     }
 #endif
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
     if (memory) {
 	munmap((char *) base, info.st_size);
 	close(fd);
@@ -2004,7 +1840,6 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
     xmlParserCtxtPtr ctxt;
     xmlDocPtr doc = NULL;
 
-#ifdef LIBXML_TREE_ENABLED
     if ((generate) && (filename == NULL)) {
         xmlNodePtr n;
 
@@ -2029,7 +1864,6 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
 
         return(doc);
     }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_HTML_ENABLED
 #ifdef LIBXML_PUSH_ENABLED
@@ -2072,14 +1906,15 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
     }
 #endif /* LIBXML_PUSH_ENABLED */
 
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
     if ((html) && (memory)) {
 	int fd;
 	struct stat info;
 	const char *base;
 	if (stat(filename, &info) < 0)
 	    return(NULL);
-	if ((fd = open(filename, O_RDONLY)) < 0)
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
 	    return(NULL);
 	base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;
 	if (base == (void *) MAP_FAILED) {
@@ -2146,12 +1981,8 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
         if (maxAmpl > 0)
             xmlCtxtSetMaxAmplification(ctxt, maxAmpl);
 
-        if (htmlout) {
-            ctxt->sax->error = xmlHTMLError;
-            ctxt->sax->warning = xmlHTMLWarning;
-            ctxt->vctxt.error = xmlHTMLValidityError;
-            ctxt->vctxt.warning = xmlHTMLValidityWarning;
-        }
+        if (htmlout)
+            xmlCtxtSetErrorHandler(ctxt, xmlHTMLError, ctxt);
 
         while ((res = fread(chars, 1, pushsize, f)) > 0) {
             xmlParseChunk(ctxt, chars, res, 0);
@@ -2178,12 +2009,8 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
         if (maxAmpl > 0)
             xmlCtxtSetMaxAmplification(ctxt, maxAmpl);
 
-        if (htmlout) {
-            ctxt->sax->error = xmlHTMLError;
-            ctxt->sax->warning = xmlHTMLWarning;
-            ctxt->vctxt.error = xmlHTMLValidityError;
-            ctxt->vctxt.warning = xmlHTMLValidityWarning;
-        }
+        if (htmlout)
+            xmlCtxtSetErrorHandler(ctxt, xmlHTMLError, ctxt);
 
         if (testIO) {
             FILE *f;
@@ -2201,7 +2028,7 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
 
             doc = xmlCtxtReadIO(ctxt, myRead, myClose, f, filename, NULL,
                                 options);
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
         } else if (memory) {
             int fd;
             struct stat info;
@@ -2209,7 +2036,8 @@ parseFile(const char *filename, xmlParserCtxtPtr rectxt) {
 
             if (stat(filename, &info) < 0)
                 goto error;
-            if ((fd = open(filename, O_RDONLY)) < 0)
+            fd = open(filename, O_RDONLY);
+            if (fd < 0)
                 goto error;
             base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;
             if (base == (void *) MAP_FAILED) {
@@ -2299,19 +2127,18 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
     }
 #endif
 
-#ifdef LIBXML_DEBUG_ENABLED
-#ifdef LIBXML_XPATH_ENABLED
+#ifndef XMLLINT_FUZZ
     /*
      * shell interaction
      */
     if (shell) {
+#ifdef LIBXML_XPATH_ENABLED
         xmlXPathOrderDocElems(doc);
-        xmlShell(doc, filename, xmlShellReadline, stdout);
-    }
 #endif
+        xmllintShell(doc, filename, stdout);
+    }
 #endif
 
-#ifdef LIBXML_TREE_ENABLED
     /*
      * test intermediate copy if needed.
      */
@@ -2339,7 +2166,6 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
 	    endTimer("Freeing original");
 	}
     }
-#endif /* LIBXML_TREE_ENABLED */
 
 #ifdef LIBXML_VALID_ENABLED
     if ((insert)
@@ -2478,7 +2304,7 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
 		}
 	    } else
 #endif
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
 	    if (memory) {
 		xmlChar *result;
 		int len;
@@ -2506,7 +2332,7 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
 		}
 
 	    } else
-#endif /* HAVE_MMAP */
+#endif /* HAVE_DECL_MMAP */
 	    if (compress) {
 		xmlSaveFile(output ? output : "-", doc);
 	    } else {
@@ -2592,7 +2418,8 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
 	} else {
 	    xmlValidCtxtPtr cvp;
 
-	    if ((cvp = xmlNewValidCtxt()) == NULL) {
+	    cvp = xmlNewValidCtxt();
+	    if (cvp == NULL) {
 		fprintf(ERR_STREAM,
 			"Couldn't allocate validation context\n");
                 progresult = XMLLINT_ERR_MEM;
@@ -2623,7 +2450,8 @@ parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {
     } else if (postvalid) {
 	xmlValidCtxtPtr cvp;
 
-	if ((cvp = xmlNewValidCtxt()) == NULL) {
+	cvp = xmlNewValidCtxt();
+	if (cvp == NULL) {
 	    fprintf(ERR_STREAM,
 		    "Couldn't allocate validation context\n");
             progresult = XMLLINT_ERR_MEM;
@@ -2823,18 +2651,16 @@ static void usage(FILE *f, const char *name) {
     fprintf(f, "\tParse the XML files\n");
 #endif /* LIBXML_OUTPUT_ENABLED */
     fprintf(f, "\t--version : display the version of the XML library used\n");
+    fprintf(f, "\t--shell : run a navigating shell\n");
 #ifdef LIBXML_DEBUG_ENABLED
     fprintf(f, "\t--debug : dump a debug tree of the in-memory document\n");
-    fprintf(f, "\t--shell : run a navigating shell\n");
     fprintf(f, "\t--debugent : debug the entities defined in the document\n");
 #else
 #ifdef LIBXML_READER_ENABLED
     fprintf(f, "\t--debug : dump the nodes content when using --stream\n");
 #endif /* LIBXML_READER_ENABLED */
 #endif
-#ifdef LIBXML_TREE_ENABLED
     fprintf(f, "\t--copy : used to test the internal copy implementation\n");
-#endif /* LIBXML_TREE_ENABLED */
     fprintf(f, "\t--recover : output what was parsable on broken XML documents\n");
     fprintf(f, "\t--huge : remove any internal arbitrary parser limits\n");
     fprintf(f, "\t--noent : substitute entity references by their value\n");
@@ -2864,15 +2690,16 @@ static void usage(FILE *f, const char *name) {
 #endif
 #ifdef LIBXML_PUSH_ENABLED
     fprintf(f, "\t--push : use the push mode of the parser\n");
-    fprintf(f, "\t--pushsmall : use the push mode of the parser using tiny increments\n");
 #endif /* LIBXML_PUSH_ENABLED */
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
     fprintf(f, "\t--memory : parse from memory\n");
 #endif
     fprintf(f, "\t--maxmem nbbytes : limits memory allocation to nbbytes bytes\n");
     fprintf(f, "\t--nowarning : do not emit warnings from parser/validator\n");
     fprintf(f, "\t--noblanks : drop (ignorable?) blanks spaces\n");
     fprintf(f, "\t--nocdata : replace cdata section with text nodes\n");
+    fprintf(f, "\t--nodict : create document without dictionary\n");
+    fprintf(f, "\t--pedantic : enable additional warnings\n");
 #ifdef LIBXML_OUTPUT_ENABLED
     fprintf(f, "\t--output file or -o file: save to a given file\n");
     fprintf(f, "\t--format : reformat/reindent the output\n");
@@ -3025,9 +2852,7 @@ xmllintMain(int argc, const char **argv, xmlResourceLoader loader) {
 #endif
     debug = 0;
     maxmem = 0;
-#ifdef LIBXML_TREE_ENABLED
     copy = 0;
-#endif /* LIBXML_TREE_ENABLED */
     noout = 0;
 #ifdef LIBXML_OUTPUT_ENABLED
     format = 0;
@@ -3058,9 +2883,8 @@ xmllintMain(int argc, const char **argv, xmlResourceLoader loader) {
     htmlout = 0;
 #ifdef LIBXML_PUSH_ENABLED
     push = 0;
-    pushsize = 4096;
 #endif /* LIBXML_PUSH_ENABLED */
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
     memory = 0;
 #endif
     testIO = 0;
@@ -3093,6 +2917,12 @@ xmllintMain(int argc, const char **argv, xmlResourceLoader loader) {
     maxAmpl = 0;
 #endif /* XMLLINT_FUZZ */
 
+#ifdef _WIN32
+    _setmode(_fileno(stdin), _O_BINARY);
+    _setmode(_fileno(stdout), _O_BINARY);
+    _setmode(_fileno(stderr), _O_BINARY);
+#endif
+
     if (argc <= 1) {
 	usage(ERR_STREAM, argv[0]);
 	return(XMLLINT_ERR_UNCLASS);
@@ -3125,18 +2955,14 @@ xmllintMain(int argc, const char **argv, xmlResourceLoader loader) {
 	if ((!strcmp(argv[i], "-debug")) || (!strcmp(argv[i], "--debug")))
 	    debug++;
 	else
-#ifdef LIBXML_DEBUG_ENABLED
 	if ((!strcmp(argv[i], "-shell")) ||
 	         (!strcmp(argv[i], "--shell"))) {
 	    shell++;
             noout = 1;
         } else
-#endif
-#ifdef LIBXML_TREE_ENABLED
 	if ((!strcmp(argv[i], "-copy")) || (!strcmp(argv[i], "--copy")))
 	    copy++;
 	else
-#endif /* LIBXML_TREE_ENABLED */
 	if ((!strcmp(argv[i], "-recover")) ||
 	         (!strcmp(argv[i], "--recover"))) {
 	    options |= XML_PARSE_RECOVER;
@@ -3237,13 +3063,8 @@ xmllintMain(int argc, const char **argv, xmlResourceLoader loader) {
 	else if ((!strcmp(argv[i], "-push")) ||
 	         (!strcmp(argv[i], "--push")))
 	    push++;
-	else if ((!strcmp(argv[i], "-pushsmall")) ||
-	         (!strcmp(argv[i], "--pushsmall"))) {
-	    push++;
-            pushsize = 10;
-        }
 #endif /* LIBXML_PUSH_ENABLED */
-#ifdef HAVE_MMAP
+#if HAVE_DECL_MMAP
 	else if ((!strcmp(argv[i], "-memory")) ||
 	         (!strcmp(argv[i], "--memory")))
 	    memory++;
diff --git a/xmlmemory.c b/xmlmemory.c
index f0628e2a..4ac22cdc 100644
--- a/xmlmemory.c
+++ b/xmlmemory.c
@@ -17,6 +17,7 @@
 #include <libxml/parser.h>
 #include <libxml/threads.h>
 
+#include "private/error.h"
 #include "private/memory.h"
 #include "private/threads.h"
 
@@ -103,16 +104,12 @@ xmlMemMalloc(size_t size)
 
     xmlInitParser();
 
-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {
-        fprintf(stderr, "xmlMemMalloc: Unsigned overflow\n");
+    if (size > (MAX_SIZE_T - RESERVE_SIZE))
         return(NULL);
-    }
 
     p = (MEMHDR *) malloc(RESERVE_SIZE + size);
-    if (!p) {
-        fprintf(stderr, "xmlMemMalloc: Out of memory\n");
+    if (!p)
         return(NULL);
-    }
     p->mh_tag = MEMTAG;
     p->mh_size = size;
 
@@ -161,14 +158,12 @@ xmlMemRealloc(void *ptr, size_t size) {
 
     xmlInitParser();
 
-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {
-        fprintf(stderr, "xmlMemRealloc: Unsigned overflow\n");
+    if (size > (MAX_SIZE_T - RESERVE_SIZE))
         return(NULL);
-    }
 
     p = CLIENT_2_HDR(ptr);
     if (p->mh_tag != MEMTAG) {
-        fprintf(stderr, "xmlMemRealloc: Tag error\n");
+        xmlPrintErrorMessage("xmlMemRealloc: Tag error\n");
         return(NULL);
     }
     oldSize = p->mh_size;
@@ -177,7 +172,6 @@ xmlMemRealloc(void *ptr, size_t size) {
     tmp = (MEMHDR *) realloc(p, RESERVE_SIZE + size);
     if (!tmp) {
         p->mh_tag = MEMTAG;
-        fprintf(stderr, "xmlMemRealloc: Out of memory\n");
         return(NULL);
     }
     p = tmp;
@@ -207,13 +201,13 @@ xmlMemFree(void *ptr)
         return;
 
     if (ptr == (void *) -1) {
-        fprintf(stderr, "xmlMemFree: Pointer from freed area\n");
+        xmlPrintErrorMessage("xmlMemFree: Pointer from freed area\n");
         return;
     }
 
     p = CLIENT_2_HDR(ptr);
     if (p->mh_tag != MEMTAG) {
-        fprintf(stderr, "xmlMemFree: Tag error\n");
+        xmlPrintErrorMessage("xmlMemFree: Tag error\n");
         return;
     }
     p->mh_tag = ~MEMTAG;
@@ -225,8 +219,6 @@ xmlMemFree(void *ptr)
     xmlMutexUnlock(&xmlMemMutex);
 
     free(p);
-
-    return;
 }
 
 /**
@@ -262,16 +254,12 @@ xmlMemoryStrdup(const char *str) {
 
     xmlInitParser();
 
-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {
-        fprintf(stderr, "xmlMemoryStrdup: Unsigned overflow\n");
+    if (size > (MAX_SIZE_T - RESERVE_SIZE))
         return(NULL);
-    }
 
     p = (MEMHDR *) malloc(RESERVE_SIZE + size);
-    if (!p) {
-        fprintf(stderr, "xmlMemoryStrdup: Out of memory\n");
+    if (!p)
         return(NULL);
-    }
     p->mh_tag = MEMTAG;
     p->mh_size = size;
 
@@ -509,6 +497,8 @@ xmlMemGet(xmlFreeFunc *freeFunc, xmlMallocFunc *mallocFunc,
  * @reallocFunc: the realloc() function to use
  * @strdupFunc: the strdup() function to use
  *
+ * DEPRECATED: Use xmlMemSetup.
+ *
  * Override the default memory access functions with a new set
  * This has to be called before any other libxml routines !
  * The mallocAtomicFunc is specialized for atomic block
@@ -549,6 +539,8 @@ xmlGcMemSetup(xmlFreeFunc freeFunc, xmlMallocFunc mallocFunc,
  * @reallocFunc: place to save the realloc() function in use
  * @strdupFunc: place to save the strdup() function in use
  *
+ * DEPRECATED: xmlMemGet.
+ *
  * Provides the memory access functions set currently in use
  * The mallocAtomicFunc is specialized for atomic block
  * allocations (i.e. of areas  useful for garbage collected memory allocators
diff --git a/xmlmodule.c b/xmlmodule.c
index dd2fd7a5..3f105fd4 100644
--- a/xmlmodule.c
+++ b/xmlmodule.c
@@ -157,9 +157,7 @@ xmlModuleFree(xmlModulePtr module)
 }
 
 #if defined(HAVE_DLOPEN) && !defined(_WIN32)
-#ifdef HAVE_DLFCN_H
 #include <dlfcn.h>
-#endif
 
 #ifndef RTLD_GLOBAL            /* For Tru64 UNIX 4.0 */
 #define RTLD_GLOBAL 0
@@ -210,9 +208,7 @@ xmlModulePlatformSymbol(void *handle, const char *name, void **symbol)
 #else /* ! HAVE_DLOPEN */
 
 #ifdef HAVE_SHLLOAD             /* HAVE_SHLLOAD */
-#ifdef HAVE_DL_H
 #include <dl.h>
-#endif
 /*
  * xmlModulePlatformOpen:
  * returns a handle on success, and zero on error.
diff --git a/xmlreader.c b/xmlreader.c
index bc69a670..e074da6a 100644
--- a/xmlreader.c
+++ b/xmlreader.c
@@ -259,7 +259,7 @@ xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
         dict = NULL;
     if (cur == NULL) return;
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
 
     if (cur->children != NULL)
@@ -350,7 +350,7 @@ xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
 	/* unroll to speed up freeing the document */
 	if (cur->type != XML_DTD_NODE) {
 
-	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+	    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 		xmlDeregisterNodeDefaultValue(cur);
 
 	    if (((cur->type == XML_ELEMENT_NODE) ||
@@ -437,7 +437,7 @@ xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
 	cur->children = NULL;
     }
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue(cur);
 
     if (((cur->type == XML_ELEMENT_NODE) ||
@@ -490,7 +490,7 @@ xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {
 
     if (cur == NULL) return;
 
-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
 
     /*
@@ -836,15 +836,12 @@ xmlTextReaderPushData(xmlTextReaderPtr reader) {
      * Discard the consumed input when needed and possible
      */
     if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {
-        if (reader->input->readcallback != NULL) {
-	    if ((reader->cur >= 4096) &&
-		(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {
-		val = xmlBufShrink(inbuf, reader->cur);
-		if (val >= 0) {
-		    reader->cur -= val;
-		}
-	    }
-	}
+        if (reader->cur > 80 /* LINE_LEN */) {
+            val = xmlBufShrink(inbuf, reader->cur - 80);
+            if (val >= 0) {
+                reader->cur -= val;
+            }
+        }
     }
 
     /*
@@ -1754,7 +1751,10 @@ xmlTextReaderReadString(xmlTextReaderPtr reader)
     switch (node->type) {
         case XML_TEXT_NODE:
         case XML_CDATA_SECTION_NODE:
+            break;
         case XML_ELEMENT_NODE:
+            if (xmlTextReaderDoExpand(reader) == -1)
+                return(NULL);
             break;
         case XML_ATTRIBUTE_NODE:
             /* TODO */
@@ -1763,12 +1763,11 @@ xmlTextReaderReadString(xmlTextReaderPtr reader)
             break;
     }
 
-    buf = xmlBufCreateSize(30);
+    buf = xmlBufCreate(50);
     if (buf == NULL) {
         xmlTextReaderErrMemory(reader);
         return(NULL);
     }
-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 
     cur = node;
     while (cur != NULL) {
@@ -1809,66 +1808,6 @@ done:
     return(ret);
 }
 
-#if 0
-/**
- * xmlTextReaderReadBase64:
- * @reader:  the xmlTextReaderPtr used
- * @array:  a byte array to store the content.
- * @offset:  the zero-based index into array where the method should
- *           begin to write.
- * @len:  the number of bytes to write.
- *
- * Reads and decodes the Base64 encoded contents of an element and
- * stores the result in a byte buffer.
- *
- * Returns the number of bytes written to array, or zero if the current
- *         instance is not positioned on an element or -1 in case of error.
- */
-int
-xmlTextReaderReadBase64(xmlTextReaderPtr reader,
-                        unsigned char *array ATTRIBUTE_UNUSED,
-	                int offset ATTRIBUTE_UNUSED,
-			int len ATTRIBUTE_UNUSED) {
-    if ((reader == NULL) || (reader->ctxt == NULL))
-	return(-1);
-    if (reader->ctxt->wellFormed != 1)
-	return(-1);
-
-    if ((reader->node == NULL) || (reader->node->type == XML_ELEMENT_NODE))
-	return(0);
-    return(0);
-}
-
-/**
- * xmlTextReaderReadBinHex:
- * @reader:  the xmlTextReaderPtr used
- * @array:  a byte array to store the content.
- * @offset:  the zero-based index into array where the method should
- *           begin to write.
- * @len:  the number of bytes to write.
- *
- * Reads and decodes the BinHex encoded contents of an element and
- * stores the result in a byte buffer.
- *
- * Returns the number of bytes written to array, or zero if the current
- *         instance is not positioned on an element or -1 in case of error.
- */
-int
-xmlTextReaderReadBinHex(xmlTextReaderPtr reader,
-                        unsigned char *array ATTRIBUTE_UNUSED,
-	                int offset ATTRIBUTE_UNUSED,
-			int len ATTRIBUTE_UNUSED) {
-    if ((reader == NULL) || (reader->ctxt == NULL))
-	return(-1);
-    if (reader->ctxt->wellFormed != 1)
-	return(-1);
-
-    if ((reader->node == NULL) || (reader->node->type == XML_ELEMENT_NODE))
-	return(0);
-    return(0);
-}
-#endif
-
 /************************************************************************
  *									*
  *			Operating on a preparsed tree			*
@@ -2072,14 +2011,11 @@ xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
     ret->entMax = 0;
     ret->entNr = 0;
     ret->input = input;
-    ret->buffer = xmlBufCreateSize(100);
+    ret->buffer = xmlBufCreate(50);
     if (ret->buffer == NULL) {
         xmlFree(ret);
 	return(NULL);
     }
-    /* no operation on a reader should require a huge buffer */
-    xmlBufSetAllocationScheme(ret->buffer,
-			      XML_BUFFER_ALLOC_DOUBLEIT);
     ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
     if (ret->sax == NULL) {
 	xmlBufFree(ret->buffer);
@@ -2343,6 +2279,8 @@ xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, int no) {
     }
     /* TODO walk the DTD if present */
 
+    if (cur->children == NULL)
+        return(NULL);
     ret = xmlNodeListGetString(reader->node->doc, cur->children, 1);
     if (ret == NULL)
         xmlTextReaderErrMemory(reader);
@@ -3588,6 +3526,8 @@ xmlTextReaderValue(xmlTextReaderPtr reader) {
             xmlDocPtr doc = NULL;
             xmlChar *ret;
 
+            if (attr->children == NULL)
+                return(NULL);
 	    if (attr->parent != NULL)
                 doc = attr->parent->doc;
 	    ret = xmlNodeListGetString(doc, attr->children, 1);
@@ -3640,11 +3580,9 @@ xmlTextReaderConstValue(xmlTextReaderPtr reader) {
 		return(attr->children->content);
 	    else {
 		if (reader->buffer == NULL) {
-		    reader->buffer = xmlBufCreateSize(100);
+		    reader->buffer = xmlBufCreate(50);
                     if (reader->buffer == NULL)
                         return (NULL);
-		    xmlBufSetAllocationScheme(reader->buffer,
-		                              XML_BUFFER_ALLOC_DOUBLEIT);
                 } else
                     xmlBufEmpty(reader->buffer);
 	        xmlBufGetNodeContent(reader->buffer, node);
@@ -3653,9 +3591,7 @@ xmlTextReaderConstValue(xmlTextReaderPtr reader) {
                     xmlTextReaderErrMemory(reader);
 		    /* error on the buffer best to reallocate */
 		    xmlBufFree(reader->buffer);
-		    reader->buffer = xmlBufCreateSize(100);
-		    xmlBufSetAllocationScheme(reader->buffer,
-		                              XML_BUFFER_ALLOC_DOUBLEIT);
+		    reader->buffer = xmlBufCreate(50);
 		}
 		return(ret);
 	    }
@@ -4905,13 +4841,10 @@ xmlTextReaderSetup(xmlTextReaderPtr reader,
 	reader->allocs |= XML_TEXTREADER_INPUT;
     }
     if (reader->buffer == NULL)
-        reader->buffer = xmlBufCreateSize(100);
+        reader->buffer = xmlBufCreate(50);
     if (reader->buffer == NULL) {
         return (-1);
     }
-    /* no operation on a reader should require a huge buffer */
-    xmlBufSetAllocationScheme(reader->buffer,
-			      XML_BUFFER_ALLOC_DOUBLEIT);
     if (reader->sax == NULL)
 	reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
     if (reader->sax == NULL) {
@@ -4985,7 +4918,10 @@ xmlTextReaderSetup(xmlTextReaderPtr reader,
 	    inputStream->buf = buf;
             xmlBufResetInput(buf->buffer, inputStream);
 
-	    inputPush(reader->ctxt, inputStream);
+            if (inputPush(reader->ctxt, inputStream) < 0) {
+                xmlFreeInputStream(inputStream);
+                return(-1);
+            }
 	    reader->cur = 0;
 	}
     }
@@ -5092,6 +5028,10 @@ xmlTextReaderGetLastError(xmlTextReaderPtr reader)
  * xmlTextReaderByteConsumed:
  * @reader: an XML reader
  *
+ * DEPRECATED: The returned value is mostly random and useless.
+ * It reflects the parser reading ahead and is in no way related to
+ * the current node.
+ *
  * This function provides the current index of the parser used
  * by the reader, relative to the start of the current entity.
  * This function actually just wraps a call to xmlBytesConsumed()
@@ -5103,9 +5043,14 @@ xmlTextReaderGetLastError(xmlTextReaderPtr reader)
  */
 long
 xmlTextReaderByteConsumed(xmlTextReaderPtr reader) {
+    xmlParserInputPtr in;
+
     if ((reader == NULL) || (reader->ctxt == NULL))
         return(-1);
-    return(xmlByteConsumed(reader->ctxt));
+    in = reader->ctxt->input;
+    if (in == NULL)
+        return(-1);
+    return(in->consumed + (in->cur - in->base));
 }
 
 
@@ -5532,213 +5477,4 @@ xmlReaderNewIO(xmlTextReaderPtr reader, xmlInputReadCallback ioread,
     return (xmlTextReaderSetup(reader, input, URL, encoding, options));
 }
 
-/************************************************************************
- *									*
- *			Utilities					*
- *									*
- ************************************************************************/
-#ifdef NOT_USED_YET
-
-/**
- * xmlBase64Decode:
- * @in:  the input buffer
- * @inlen:  the size of the input (in), the size read from it (out)
- * @to:  the output buffer
- * @tolen:  the size of the output (in), the size written to (out)
- *
- * Base64 decoder, reads from @in and save in @to
- * TODO: tell jody when this is actually exported
- *
- * Returns 0 if all the input was consumer, 1 if the Base64 end was reached,
- *         2 if there wasn't enough space on the output or -1 in case of error.
- */
-static int
-xmlBase64Decode(const unsigned char *in, unsigned long *inlen,
-                unsigned char *to, unsigned long *tolen)
-{
-    unsigned long incur;        /* current index in in[] */
-
-    unsigned long inblk;        /* last block index in in[] */
-
-    unsigned long outcur;       /* current index in out[] */
-
-    unsigned long inmax;        /* size of in[] */
-
-    unsigned long outmax;       /* size of out[] */
-
-    unsigned char cur;          /* the current value read from in[] */
-
-    unsigned char intmp[4], outtmp[4];  /* temporary buffers for the convert */
-
-    int nbintmp;                /* number of byte in intmp[] */
-
-    int is_ignore;              /* cur should be ignored */
-
-    int is_end = 0;             /* the end of the base64 was found */
-
-    int retval = 1;
-
-    int i;
-
-    if ((in == NULL) || (inlen == NULL) || (to == NULL) || (tolen == NULL))
-        return (-1);
-
-    incur = 0;
-    inblk = 0;
-    outcur = 0;
-    inmax = *inlen;
-    outmax = *tolen;
-    nbintmp = 0;
-
-    while (1) {
-        if (incur >= inmax)
-            break;
-        cur = in[incur++];
-        is_ignore = 0;
-        if ((cur >= 'A') && (cur <= 'Z'))
-            cur = cur - 'A';
-        else if ((cur >= 'a') && (cur <= 'z'))
-            cur = cur - 'a' + 26;
-        else if ((cur >= '0') && (cur <= '9'))
-            cur = cur - '0' + 52;
-        else if (cur == '+')
-            cur = 62;
-        else if (cur == '/')
-            cur = 63;
-        else if (cur == '.')
-            cur = 0;
-        else if (cur == '=')    /*no op , end of the base64 stream */
-            is_end = 1;
-        else {
-            is_ignore = 1;
-            if (nbintmp == 0)
-                inblk = incur;
-        }
-
-        if (!is_ignore) {
-            int nbouttmp = 3;
-
-            int is_break = 0;
-
-            if (is_end) {
-                if (nbintmp == 0)
-                    break;
-                if ((nbintmp == 1) || (nbintmp == 2))
-                    nbouttmp = 1;
-                else
-                    nbouttmp = 2;
-                nbintmp = 3;
-                is_break = 1;
-            }
-            intmp[nbintmp++] = cur;
-            /*
-             * if intmp is full, push the 4byte sequence as a 3 byte
-             * sequence out
-             */
-            if (nbintmp == 4) {
-                nbintmp = 0;
-                outtmp[0] = (intmp[0] << 2) | ((intmp[1] & 0x30) >> 4);
-                outtmp[1] =
-                    ((intmp[1] & 0x0F) << 4) | ((intmp[2] & 0x3C) >> 2);
-                outtmp[2] = ((intmp[2] & 0x03) << 6) | (intmp[3] & 0x3F);
-                if (outcur + 3 >= outmax) {
-                    retval = 2;
-                    break;
-                }
-
-                for (i = 0; i < nbouttmp; i++)
-                    to[outcur++] = outtmp[i];
-                inblk = incur;
-            }
-
-            if (is_break) {
-                retval = 0;
-                break;
-            }
-        }
-    }
-
-    *tolen = outcur;
-    *inlen = inblk;
-    return (retval);
-}
-
-/*
- * Test routine for the xmlBase64Decode function
- */
-#if 0
-int
-main(int argc, char **argv)
-{
-    char *input = "  VW4 gcGV0        \n      aXQgdGVzdCAuCg== ";
-
-    char output[100];
-
-    char output2[100];
-
-    char output3[100];
-
-    unsigned long inlen = strlen(input);
-
-    unsigned long outlen = 100;
-
-    int ret;
-
-    unsigned long cons, tmp, tmp2, prod;
-
-    /*
-     * Direct
-     */
-    ret = xmlBase64Decode(input, &inlen, output, &outlen);
-
-    output[outlen] = 0;
-    printf("ret: %d, inlen: %ld , outlen: %ld, output: '%s'\n", ret, inlen,
-           outlen, output)indent: Standard input:179: Error:Unmatched #endif
-;
-
-    /*
-     * output chunking
-     */
-    cons = 0;
-    prod = 0;
-    while (cons < inlen) {
-        tmp = 5;
-        tmp2 = inlen - cons;
-
-        printf("%ld %ld\n", cons, prod);
-        ret = xmlBase64Decode(&input[cons], &tmp2, &output2[prod], &tmp);
-        cons += tmp2;
-        prod += tmp;
-        printf("%ld %ld\n", cons, prod);
-    }
-    output2[outlen] = 0;
-    printf("ret: %d, cons: %ld , prod: %ld, output: '%s'\n", ret, cons,
-           prod, output2);
-
-    /*
-     * input chunking
-     */
-    cons = 0;
-    prod = 0;
-    while (cons < inlen) {
-        tmp = 100 - prod;
-        tmp2 = inlen - cons;
-        if (tmp2 > 5)
-            tmp2 = 5;
-
-        printf("%ld %ld\n", cons, prod);
-        ret = xmlBase64Decode(&input[cons], &tmp2, &output3[prod], &tmp);
-        cons += tmp2;
-        prod += tmp;
-        printf("%ld %ld\n", cons, prod);
-    }
-    output3[outlen] = 0;
-    printf("ret: %d, cons: %ld , prod: %ld, output: '%s'\n", ret, cons,
-           prod, output3);
-    return (0);
-
-}
-#endif
-#endif /* NOT_USED_YET */
-
 #endif /* LIBXML_READER_ENABLED */
diff --git a/xmlregexp.c b/xmlregexp.c
index 31e3d1a6..fda8713d 100644
--- a/xmlregexp.c
+++ b/xmlregexp.c
@@ -385,10 +385,10 @@ xmlRegexpErrCompile(xmlRegParserCtxtPtr ctxt, const char *extra)
 	ctxt->error = XML_REGEXP_COMPILE_ERROR;
     }
 
-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,
-                          XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL,
-                          NULL, 0, extra, regexp, NULL, idx, 0,
-                          "failed to compile: %s\n", extra);
+    res = xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,
+                        XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL,
+                        NULL, 0, extra, regexp, NULL, idx, 0,
+                        "failed to compile: %s\n", extra);
     if (res < 0)
         xmlRegexpErrMemory(ctxt);
 }
@@ -611,10 +611,6 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 			goto not_determ;
 		    }
 		} else {
-#if 0
-		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
-			   i, j, trans->atom->no, trans->to, atomno, targetno);
-#endif
 		    transitions[stateno * (nbatoms + 1) + atomno + 1] =
 			targetno + 1; /* to avoid 0 */
 		    if (transdata != NULL)
@@ -2964,7 +2960,6 @@ xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {
 	    return(accept);
 	}
         case XML_REGEXP_STRING:
-	    printf("TODO: XML_REGEXP_STRING\n");
 	    return(-1);
         case XML_REGEXP_ANYCHAR:
         case XML_REGEXP_ANYSPACE:
@@ -3098,7 +3093,6 @@ xmlFARegExecRollBack(xmlRegExecCtxtPtr exec) {
     exec->transno = exec->rollbacks[exec->nbRollbacks].nextbranch;
     if (exec->comp->nbCounters > 0) {
 	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {
-	    fprintf(stderr, "exec save: allocation failed");
 	    exec->status = XML_REGEXP_INTERNAL_ERROR;
 	    return;
 	}
@@ -3200,7 +3194,6 @@ xmlFARegExec(xmlRegexpPtr comp, const xmlChar *content) {
 		if ((ret) && (counter->min != counter->max))
 		    deter = 0;
 	    } else if (atom == NULL) {
-		fprintf(stderr, "epsilon transition left at runtime\n");
 		exec->status = XML_REGEXP_INTERNAL_ERROR;
 		break;
 	    } else if (exec->inputString[exec->index] != 0) {
@@ -3810,7 +3803,6 @@ xmlRegExecPushStringInternal(xmlRegExecCtxtPtr exec, const xmlChar *value,
 		counter = &exec->comp->counters[trans->count];
 		ret = ((count >= counter->min) && (count <= counter->max));
 	    } else if (atom == NULL) {
-		fprintf(stderr, "epsilon transition left at runtime\n");
 		exec->status = XML_REGEXP_INTERNAL_ERROR;
 		break;
 	    } else if (value != NULL) {
@@ -3980,7 +3972,6 @@ rollback:
 	continue;
 progress:
         progress = 1;
-	continue;
     }
     if (exec->status == XML_REGEXP_OK) {
         return(exec->state->type == XML_REGEXP_FINAL_STATE);
@@ -4038,7 +4029,7 @@ xmlRegExecPushString2(xmlRegExecCtxtPtr exec, const xmlChar *value,
     lenp = strlen((char *) value);
 
     if (150 < lenn + lenp + 2) {
-	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	str = xmlMalloc(lenn + lenp + 2);
 	if (str == NULL) {
 	    exec->status = XML_REGEXP_OUT_OF_MEMORY;
 	    return(-1);
@@ -4275,150 +4266,6 @@ xmlRegExecErrInfo(xmlRegExecCtxtPtr exec, const xmlChar **string,
     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));
 }
 
-#if 0
-static int
-xmlRegExecPushChar(xmlRegExecCtxtPtr exec, int UCS) {
-    xmlRegTransPtr trans;
-    xmlRegAtomPtr atom;
-    int ret;
-    int codepoint, len;
-
-    if (exec == NULL)
-	return(-1);
-    if (exec->status != XML_REGEXP_OK)
-	return(exec->status);
-
-    while ((exec->status == XML_REGEXP_OK) &&
-	   ((exec->inputString[exec->index] != 0) ||
-	    (exec->state->type != XML_REGEXP_FINAL_STATE))) {
-
-	/*
-	 * End of input on non-terminal state, rollback, however we may
-	 * still have epsilon like transition for counted transitions
-	 * on counters, in that case don't break too early.
-	 */
-	if ((exec->inputString[exec->index] == 0) && (exec->counts == NULL))
-	    goto rollback;
-
-	exec->transcount = 0;
-	for (;exec->transno < exec->state->nbTrans;exec->transno++) {
-	    trans = &exec->state->trans[exec->transno];
-	    if (trans->to < 0)
-		continue;
-	    atom = trans->atom;
-	    ret = 0;
-	    if (trans->count >= 0) {
-		int count;
-		xmlRegCounterPtr counter;
-
-		/*
-		 * A counted transition.
-		 */
-
-		count = exec->counts[trans->count];
-		counter = &exec->comp->counters[trans->count];
-		ret = ((count >= counter->min) && (count <= counter->max));
-	    } else if (atom == NULL) {
-		fprintf(stderr, "epsilon transition left at runtime\n");
-		exec->status = XML_REGEXP_INTERNAL_ERROR;
-		break;
-	    } else if (exec->inputString[exec->index] != 0) {
-                codepoint = CUR_SCHAR(&(exec->inputString[exec->index]), len);
-		ret = xmlRegCheckCharacter(atom, codepoint);
-		if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {
-		    xmlRegStatePtr to = exec->comp->states[trans->to];
-
-		    /*
-		     * this is a multiple input sequence
-		     */
-		    if (exec->state->nbTrans > exec->transno + 1) {
-			xmlFARegExecSave(exec);
-		    }
-		    exec->transcount = 1;
-		    do {
-			/*
-			 * Try to progress as much as possible on the input
-			 */
-			if (exec->transcount == atom->max) {
-			    break;
-			}
-			exec->index += len;
-			/*
-			 * End of input: stop here
-			 */
-			if (exec->inputString[exec->index] == 0) {
-			    exec->index -= len;
-			    break;
-			}
-			if (exec->transcount >= atom->min) {
-			    int transno = exec->transno;
-			    xmlRegStatePtr state = exec->state;
-
-			    /*
-			     * The transition is acceptable save it
-			     */
-			    exec->transno = -1; /* trick */
-			    exec->state = to;
-			    xmlFARegExecSave(exec);
-			    exec->transno = transno;
-			    exec->state = state;
-			}
-			codepoint = CUR_SCHAR(&(exec->inputString[exec->index]),
-				              len);
-			ret = xmlRegCheckCharacter(atom, codepoint);
-			exec->transcount++;
-		    } while (ret == 1);
-		    if (exec->transcount < atom->min)
-			ret = 0;
-
-		    /*
-		     * If the last check failed but one transition was found
-		     * possible, rollback
-		     */
-		    if (ret < 0)
-			ret = 0;
-		    if (ret == 0) {
-			goto rollback;
-		    }
-		}
-	    }
-	    if (ret == 1) {
-		if (exec->state->nbTrans > exec->transno + 1) {
-		    xmlFARegExecSave(exec);
-		}
-		/*
-		 * restart count for expressions like this ((abc){2})*
-		 */
-		if (trans->count >= 0) {
-		    exec->counts[trans->count] = 0;
-		}
-		if (trans->counter >= 0) {
-		    exec->counts[trans->counter]++;
-		}
-		exec->state = exec->comp->states[trans->to];
-		exec->transno = 0;
-		if (trans->atom != NULL) {
-		    exec->index += len;
-		}
-		goto progress;
-	    } else if (ret < 0) {
-		exec->status = XML_REGEXP_INTERNAL_ERROR;
-		break;
-	    }
-	}
-	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {
-rollback:
-	    /*
-	     * Failed to find a way out
-	     */
-	    exec->determinist = 0;
-	    xmlFARegExecRollBack(exec);
-	}
-progress:
-	continue;
-    }
-}
-#endif
 /************************************************************************
  *									*
  *	Parser for the Schemas Datatype Regular Expressions		*
@@ -4995,7 +4842,6 @@ xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {
         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);
     }
-    return;
 }
 
 /**
@@ -5550,7 +5396,6 @@ xmlRegFreeRegexp(xmlRegexpPtr regexp) {
     xmlFree(regexp);
 }
 
-#ifdef LIBXML_AUTOMATA_ENABLED
 /************************************************************************
  *									*
  *			The Automata interface				*
@@ -5724,7 +5569,7 @@ xmlAutomataNewTransition2(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	lenn = strlen((char *) token2);
 	lenp = strlen((char *) token);
 
-	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	str = xmlMalloc(lenn + lenp + 2);
 	if (str == NULL) {
 	    xmlRegFreeAtom(atom);
 	    return(NULL);
@@ -5786,7 +5631,7 @@ xmlAutomataNewNegTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	lenn = strlen((char *) token2);
 	lenp = strlen((char *) token);
 
-	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	str = xmlMalloc(lenn + lenp + 2);
 	if (str == NULL) {
 	    xmlRegFreeAtom(atom);
 	    return(NULL);
@@ -5858,7 +5703,7 @@ xmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	lenn = strlen((char *) token2);
 	lenp = strlen((char *) token);
 
-	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	str = xmlMalloc(lenn + lenp + 2);
 	if (str == NULL)
 	    goto error;
 	memcpy(&str[0], token, lenp);
@@ -6031,7 +5876,7 @@ xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	lenn = strlen((char *) token2);
 	lenp = strlen((char *) token);
 
-	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
+	str = xmlMalloc(lenn + lenp + 2);
 	if (str == NULL)
 	    goto error;
 	memcpy(&str[0], token, lenp);
@@ -6315,14 +6160,121 @@ xmlAutomataIsDeterminist(xmlAutomataPtr am) {
     ret = xmlFAComputesDeterminism(am);
     return(ret);
 }
-#endif /* LIBXML_AUTOMATA_ENABLED */
 
 #ifdef LIBXML_EXPR_ENABLED
+/** DOC_DISABLE */
 /************************************************************************
  *									*
  *		Formal Expression handling code				*
  *									*
  ************************************************************************/
+
+/*
+ * Formal regular expression handling
+ * Its goal is to do some formal work on content models
+ */
+
+/* expressions are used within a context */
+typedef struct _xmlExpCtxt xmlExpCtxt;
+typedef xmlExpCtxt *xmlExpCtxtPtr;
+
+XMLPUBFUN void
+			xmlExpFreeCtxt	(xmlExpCtxtPtr ctxt);
+XMLPUBFUN xmlExpCtxtPtr
+			xmlExpNewCtxt	(int maxNodes,
+					 xmlDictPtr dict);
+
+XMLPUBFUN int
+			xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);
+XMLPUBFUN int
+			xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);
+
+/* Expressions are trees but the tree is opaque */
+typedef struct _xmlExpNode xmlExpNode;
+typedef xmlExpNode *xmlExpNodePtr;
+
+typedef enum {
+    XML_EXP_EMPTY = 0,
+    XML_EXP_FORBID = 1,
+    XML_EXP_ATOM = 2,
+    XML_EXP_SEQ = 3,
+    XML_EXP_OR = 4,
+    XML_EXP_COUNT = 5
+} xmlExpNodeType;
+
+/*
+ * 2 core expressions shared by all for the empty language set
+ * and for the set with just the empty token
+ */
+XMLPUBVAR xmlExpNodePtr forbiddenExp;
+XMLPUBVAR xmlExpNodePtr emptyExp;
+
+/*
+ * Expressions are reference counted internally
+ */
+XMLPUBFUN void
+			xmlExpFree	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr);
+XMLPUBFUN void
+			xmlExpRef	(xmlExpNodePtr expr);
+
+/*
+ * constructors can be either manual or from a string
+ */
+XMLPUBFUN xmlExpNodePtr
+			xmlExpParse	(xmlExpCtxtPtr ctxt,
+					 const char *expr);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpNewAtom	(xmlExpCtxtPtr ctxt,
+					 const xmlChar *name,
+					 int len);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpNewOr	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr left,
+					 xmlExpNodePtr right);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpNewSeq	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr left,
+					 xmlExpNodePtr right);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpNewRange	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr subset,
+					 int min,
+					 int max);
+/*
+ * The really interesting APIs
+ */
+XMLPUBFUN int
+			xmlExpIsNillable(xmlExpNodePtr expr);
+XMLPUBFUN int
+			xmlExpMaxToken	(xmlExpNodePtr expr);
+XMLPUBFUN int
+			xmlExpGetLanguage(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar**langList,
+					 int len);
+XMLPUBFUN int
+			xmlExpGetStart	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar**tokList,
+					 int len);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpStringDerive(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar *str,
+					 int len);
+XMLPUBFUN xmlExpNodePtr
+			xmlExpExpDerive	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 xmlExpNodePtr sub);
+XMLPUBFUN int
+			xmlExpSubsume	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 xmlExpNodePtr sub);
+XMLPUBFUN void
+			xmlExpDump	(xmlBufferPtr buf,
+					 xmlExpNodePtr expr);
+
 /************************************************************************
  *									*
  *		Expression handling context				*
@@ -7195,10 +7147,6 @@ xmlExpCheckCard(xmlExpNodePtr exp, xmlExpNodePtr sub) {
     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {
         ret = 0;
     }
-#if 0
-    if ((IS_NILLABLE(sub)) && (!IS_NILLABLE(exp)))
-        ret = 0;
-#endif
     return(ret);
 }
 
@@ -7738,7 +7686,6 @@ xmlExpParseOr(xmlExpCtxtPtr ctxt) {
 	ret = xmlExpParseExpr(ctxt);
 	SKIP_BLANKS
 	if (*ctxt->cur != ')') {
-	    fprintf(stderr, "unbalanced '(' : %s\n", base);
 	    xmlExpFree(ctxt, ret);
 	    return(NULL);
 	}
@@ -7946,7 +7893,7 @@ xmlExpDumpInt(xmlBufferPtr buf, xmlExpNodePtr expr, int glob) {
 	    break;
 	}
 	default:
-	    fprintf(stderr, "Error in tree\n");
+            break;
     }
     if (glob)
         xmlBufferWriteChar(buf, ")");
@@ -8010,6 +7957,7 @@ xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt) {
     return(ctxt->nb_cons);
 }
 
+/** DOC_ENABLE */
 #endif /* LIBXML_EXPR_ENABLED */
 
 #endif /* LIBXML_REGEXP_ENABLED */
diff --git a/xmlsave.c b/xmlsave.c
index ba001559..d0492ee4 100644
--- a/xmlsave.c
+++ b/xmlsave.c
@@ -23,6 +23,7 @@
 
 #include "private/buf.h"
 #include "private/enc.h"
+#include "private/entities.h"
 #include "private/error.h"
 #include "private/io.h"
 #include "private/save.h"
@@ -46,7 +47,6 @@ struct _xmlSaveCtxt {
     int indent_nr;
     int indent_size;
     xmlCharEncodingOutputFunc escape;	/* used for element content */
-    xmlCharEncodingOutputFunc escapeAttr;/* used for attribute content */
 };
 
 /************************************************************************
@@ -95,27 +95,17 @@ xmlSaveErr(xmlOutputBufferPtr out, int code, xmlNodePtr node,
     if (out != NULL)
         out->error = code;
 
-    switch(code) {
-        case XML_SAVE_NOT_UTF8:
-	    msg = "string is not in UTF-8\n";
-	    break;
-	case XML_SAVE_CHAR_INVALID:
-	    msg = "invalid character value\n";
-	    break;
-	case XML_SAVE_UNKNOWN_ENCODING:
-	    msg = "unknown encoding %s\n";
-	    break;
-	case XML_SAVE_NO_DOCTYPE:
-	    msg = "document has no DOCTYPE\n";
-	    break;
-	default:
-	    msg = "unexpected error number\n";
+    if (code == XML_ERR_UNSUPPORTED_ENCODING) {
+        msg = "Unsupported encoding: %s";
+    } else {
+        msg = xmlErrString(code);
+        extra = NULL;
     }
 
-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, node,
-                          XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,
-                          extra, NULL, NULL, 0, 0,
-                          msg, extra);
+    res = xmlRaiseError(NULL, NULL, NULL, NULL, node,
+                        XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,
+                        extra, NULL, NULL, 0, 0,
+                        msg, extra);
     if (res < 0)
         xmlSaveErrMemory(out);
 }
@@ -125,145 +115,108 @@ xmlSaveErr(xmlOutputBufferPtr out, int code, xmlNodePtr node,
  *			Special escaping routines			*
  *									*
  ************************************************************************/
-static unsigned char *
-xmlSerializeHexCharRef(unsigned char *out, int val) {
-    unsigned char *ptr;
-
-    *out++ = '&';
-    *out++ = '#';
-    *out++ = 'x';
-    if (val < 0x10) ptr = out;
-    else if (val < 0x100) ptr = out + 1;
-    else if (val < 0x1000) ptr = out + 2;
-    else if (val < 0x10000) ptr = out + 3;
-    else if (val < 0x100000) ptr = out + 4;
-    else ptr = out + 5;
-    out = ptr + 1;
-    while (val > 0) {
-	switch (val & 0xF) {
-	    case 0: *ptr-- = '0'; break;
-	    case 1: *ptr-- = '1'; break;
-	    case 2: *ptr-- = '2'; break;
-	    case 3: *ptr-- = '3'; break;
-	    case 4: *ptr-- = '4'; break;
-	    case 5: *ptr-- = '5'; break;
-	    case 6: *ptr-- = '6'; break;
-	    case 7: *ptr-- = '7'; break;
-	    case 8: *ptr-- = '8'; break;
-	    case 9: *ptr-- = '9'; break;
-	    case 0xA: *ptr-- = 'A'; break;
-	    case 0xB: *ptr-- = 'B'; break;
-	    case 0xC: *ptr-- = 'C'; break;
-	    case 0xD: *ptr-- = 'D'; break;
-	    case 0xE: *ptr-- = 'E'; break;
-	    case 0xF: *ptr-- = 'F'; break;
-	    default: *ptr-- = '0'; break;
-	}
-	val >>= 4;
-    }
-    *out++ = ';';
-    *out = 0;
-    return(out);
-}
 
-/**
- * xmlEscapeEntities:
- * @out:  a pointer to an array of bytes to store the result
- * @outlen:  the length of @out
- * @in:  a pointer to an array of unescaped UTF-8 bytes
- * @inlen:  the length of @in
- *
- * Take a block of UTF-8 chars in and escape them. Used when there is no
- * encoding specified.
- *
- * Returns 0 if success, or -1 otherwise
- * The value of @inlen after return is the number of octets consumed
- *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+/*
+ * Tables generated with tools/genEscape.py
  */
-static int
-xmlEscapeEntities(unsigned char* out, int *outlen,
-                 const xmlChar* in, int *inlen) {
-    unsigned char* outstart = out;
-    const unsigned char* base = in;
-    unsigned char* outend = out + *outlen;
-    const unsigned char* inend;
-    int val;
-
-    inend = in + (*inlen);
-
-    while ((in < inend) && (out < outend)) {
-	if (*in == '<') {
-	    if (outend - out < 4) break;
-	    *out++ = '&';
-	    *out++ = 'l';
-	    *out++ = 't';
-	    *out++ = ';';
-	    in++;
-	    continue;
-	} else if (*in == '>') {
-	    if (outend - out < 4) break;
-	    *out++ = '&';
-	    *out++ = 'g';
-	    *out++ = 't';
-	    *out++ = ';';
-	    in++;
-	    continue;
-	} else if (*in == '&') {
-	    if (outend - out < 5) break;
-	    *out++ = '&';
-	    *out++ = 'a';
-	    *out++ = 'm';
-	    *out++ = 'p';
-	    *out++ = ';';
-	    in++;
-	    continue;
-	} else if (*in == 0xD) {
-	    if (outend - out < 5) break;
-	    *out++ = '&';
-	    *out++ = '#';
-	    *out++ = 'x';
-	    *out++ = 'D';
-	    *out++ = ';';
-	    in++;
-	} else if (((*in >= 0x20) && (*in < 0x80)) ||
-	           (*in == 0xA) || (*in == 0x9)) {
-	    /*
-	     * default case, just copy !
-	     */
-	    *out++ = *in++;
-	    continue;
-	} else if (*in < 0x80) {
-            /* invalid control char */
-	    if (outend - out < 8) break;
-	    out = xmlSerializeHexCharRef(out, 0xFFFD);
-	    in++;
-	} else {
-            int len;
-
-	    if (outend - out < 11) break;
-
-            len = inend - in;
-            val = xmlGetUTF8Char(in, &len);
 
+static const char xmlEscapeContent[] = {
+      8, '&', '#', 'x', 'F', 'F', 'F', 'D', ';',   4, '&', '#',
+    '9', ';',   5, '&', '#', '1', '0', ';',   5, '&', '#', '1',
+    '3', ';',   6, '&', 'q', 'u', 'o', 't', ';',   5, '&', 'a',
+    'm', 'p', ';',   4, '&', 'l', 't', ';',   4, '&', 'g', 't',
+    ';',
+};
+
+static const signed char xmlEscapeTab[128] = {
+     0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1,  0,  0, 20,  0,  0,
+     0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, 44, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static const signed char xmlEscapeTabAttr[128] = {
+     0,  0,  0,  0,  0,  0,  0,  0,  0,  9, 14,  0,  0, 20,  0,  0,
+     0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, 26, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, 44, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static void
+xmlSerializeText(xmlOutputBufferPtr buf, const xmlChar *string,
+                 unsigned flags) {
+    const char *cur;
+    const signed char *tab;
+
+    if (string == NULL)
+        return;
+
+    if (flags & XML_ESCAPE_ATTR)
+        tab = xmlEscapeTabAttr;
+    else
+        tab = xmlEscapeTab;
+
+    cur = (const char *) string;
+
+    while (*cur != 0) {
+        const char *base;
+        int c;
+        int offset;
+
+        base = cur;
+        offset = -1;
+
+        while (1) {
+            c = (unsigned char) *cur;
+
+            if (c < 0x80) {
+                offset = tab[c];
+                if (offset >= 0)
+                    break;
+            } else if (flags & XML_ESCAPE_NON_ASCII) {
+                break;
+            }
+
+            cur += 1;
+        }
+
+        if (cur > base)
+            xmlOutputBufferWrite(buf, cur - base, base);
+
+        if (offset >= 0) {
+            if (c == 0)
+                break;
+
+            xmlOutputBufferWrite(buf, xmlEscapeContent[offset],
+                                 &xmlEscapeContent[offset+1]);
+            cur += 1;
+        } else {
+            char tempBuf[12];
+            int tempSize;
+            int val = 0, len = 4;
+
+            val = xmlGetUTF8Char((const xmlChar *) cur, &len);
             if (val < 0) {
                 val = 0xFFFD;
-                in++;
+                cur += 1;
             } else {
                 if (!IS_CHAR(val))
                     val = 0xFFFD;
-                in += len;
+                cur += len;
             }
 
-	    /*
-	     * We could do multiple things here. Just save as a char ref
-	     */
-	    out = xmlSerializeHexCharRef(out, val);
-	}
+            tempSize = xmlSerializeHexCharRef(tempBuf, val);
+            xmlOutputBufferWrite(buf, tempSize, tempBuf);
+        }
     }
-    *outlen = out - outstart;
-    *inlen = in - base;
-    return(0);
 }
 
 /************************************************************************
@@ -271,6 +224,38 @@ xmlEscapeEntities(unsigned char* out, int *outlen,
  *			Allocation and deallocation			*
  *									*
  ************************************************************************/
+
+/**
+ * xmlSaveSetIndentString:
+ * @ctxt:  save context
+ * @indent:  indent string
+ *
+ * Sets the indent string.
+ *
+ * Available since 2.14.0.
+ *
+ * Returns 0 on success, -1 if the string is NULL, empty or too long.
+ */
+int
+xmlSaveSetIndentString(xmlSaveCtxtPtr ctxt, const char *indent) {
+    size_t len;
+    int i;
+
+    if ((ctxt == NULL) || (indent == NULL))
+        return(-1);
+
+    len = strlen(indent);
+    if ((len <= 0) || (len > MAX_INDENT))
+        return(-1);
+
+    ctxt->indent_size = len;
+    ctxt->indent_nr = MAX_INDENT / ctxt->indent_size;
+    for (i = 0; i < ctxt->indent_nr; i++)
+        memcpy(&ctxt->indent[i * ctxt->indent_size], indent, len);
+
+    return(0);
+}
+
 /**
  * xmlSaveCtxtInit:
  * @ctxt: the saving context
@@ -278,29 +263,22 @@ xmlEscapeEntities(unsigned char* out, int *outlen,
  * Initialize a saving context
  */
 static void
-xmlSaveCtxtInit(xmlSaveCtxtPtr ctxt)
+xmlSaveCtxtInit(xmlSaveCtxtPtr ctxt, int options)
 {
-    int i;
-    int len;
-
     if (ctxt == NULL) return;
-    if ((ctxt->encoding == NULL) && (ctxt->escape == NULL))
-        ctxt->escape = xmlEscapeEntities;
-    len = xmlStrlen((xmlChar *)xmlTreeIndentString);
-    if ((xmlTreeIndentString == NULL) || (len == 0)) {
-        memset(&ctxt->indent[0], 0, MAX_INDENT + 1);
-    } else {
-	ctxt->indent_size = len;
-	ctxt->indent_nr = MAX_INDENT / ctxt->indent_size;
-	for (i = 0;i < ctxt->indent_nr;i++)
-	    memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,
-		   ctxt->indent_size);
-        ctxt->indent[ctxt->indent_nr * ctxt->indent_size] = 0;
-    }
 
-    if (xmlSaveNoEmptyTags) {
-	ctxt->options |= XML_SAVE_NO_EMPTY;
-    }
+    xmlSaveSetIndentString(ctxt, xmlTreeIndentString);
+
+    if (options & XML_SAVE_FORMAT)
+        ctxt->format = 1;
+    else if (options & XML_SAVE_WSNONSIG)
+        ctxt->format = 2;
+
+    if (((options & XML_SAVE_EMPTY) == 0) &&
+        (xmlSaveNoEmptyTags))
+	options |= XML_SAVE_NO_EMPTY;
+
+    ctxt->options = options;
 }
 
 /**
@@ -343,30 +321,15 @@ xmlNewSaveCtxt(const char *encoding, int options)
 
         res = xmlOpenCharEncodingHandler(encoding, /* output */ 1,
                                          &ret->handler);
-	if (ret->handler == NULL) {
+	if (res != XML_ERR_OK) {
 	    xmlSaveErr(NULL, res, NULL, encoding);
             xmlFreeSaveCtxt(ret);
 	    return(NULL);
 	}
         ret->encoding = xmlStrdup((const xmlChar *)encoding);
-	ret->escape = NULL;
-    }
-    xmlSaveCtxtInit(ret);
-
-    /*
-     * Use the options
-     */
-
-    /* Re-check this option as it may already have been set */
-    if ((ret->options & XML_SAVE_NO_EMPTY) && ! (options & XML_SAVE_NO_EMPTY)) {
-	options |= XML_SAVE_NO_EMPTY;
     }
 
-    ret->options = options;
-    if (options & XML_SAVE_FORMAT)
-        ret->format = 1;
-    else if (options & XML_SAVE_WSNONSIG)
-        ret->format = 2;
+    xmlSaveCtxtInit(ret, options);
 
     return(ret);
 }
@@ -376,25 +339,33 @@ xmlNewSaveCtxt(const char *encoding, int options)
  *		Dumping XML tree content to a simple buffer		*
  *									*
  ************************************************************************/
+
+static void
+xmlSaveWriteText(xmlSaveCtxt *ctxt, const xmlChar *text, unsigned flags) {
+    if (ctxt->encoding == NULL)
+        flags |= XML_ESCAPE_NON_ASCII;
+
+    xmlSerializeText(ctxt->buf, text, flags);
+}
+
 /**
- * xmlAttrSerializeContent:
- * @buf:  the XML buffer output
- * @doc:  the document
+ * xmlSaveWriteAttrContent:
+ * @ctxt:  save context
  * @attr:  the attribute pointer
  *
  * Serialize the attribute in the buffer
  */
 static void
-xmlAttrSerializeContent(xmlOutputBufferPtr buf, xmlAttrPtr attr)
+xmlSaveWriteAttrContent(xmlSaveCtxt *ctxt, xmlAttrPtr attr)
 {
     xmlNodePtr children;
+    xmlOutputBufferPtr buf = ctxt->buf;
 
     children = attr->children;
     while (children != NULL) {
         switch (children->type) {
             case XML_TEXT_NODE:
-	        xmlBufAttrSerializeTxtContent(buf, attr->doc,
-		                              children->content);
+	        xmlSaveWriteText(ctxt, children->content, XML_ESCAPE_ATTR);
 		break;
             case XML_ENTITY_REF_NODE:
                 xmlOutputBufferWrite(buf, 1, "&");
@@ -801,11 +772,11 @@ static int xmlSaveSwitchEncoding(xmlSaveCtxtPtr ctxt, const char *encoding) {
         int res;
 
 	res = xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
-        if (handler == NULL) {
+        if (res != XML_ERR_OK) {
             xmlSaveErr(buf, res, NULL, encoding);
             return(-1);
         }
-	buf->conv = xmlBufCreate();
+	buf->conv = xmlBufCreate(4000 /* MINLEN */);
 	if (buf->conv == NULL) {
 	    xmlCharEncCloseFunc(handler);
             xmlSaveErrMemory(buf);
@@ -837,6 +808,22 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur);
 static void xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur);
 static int xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur);
 
+static void
+xmlSaveWriteIndent(xmlSaveCtxtPtr ctxt, int extra)
+{
+    int level;
+
+    if ((ctxt->options & XML_SAVE_NO_INDENT) ||
+        (((ctxt->options & XML_SAVE_INDENT) == 0) &&
+         (xmlIndentTreeOutput == 0)))
+        return;
+
+    level = ctxt->level + extra;
+    if (level > ctxt->indent_nr)
+        level = ctxt->indent_nr;
+    xmlOutputBufferWrite(ctxt->buf, ctxt->indent_size * level, ctxt->indent);
+}
+
 /**
  * xmlOutputBufferWriteWSNonSig:
  * @ctxt:  The save context
@@ -870,9 +857,14 @@ xmlOutputBufferWriteWSNonSig(xmlSaveCtxtPtr ctxt, int extra)
  * If @ctxt is supplied, @buf should be its buffer.
  */
 static void
-xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNsPtr cur,
-                xmlSaveCtxtPtr ctxt) {
+xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur, xmlSaveCtxtPtr ctxt) {
+    unsigned escapeFlags = XML_ESCAPE_ATTR;
+
     if ((cur == NULL) || (buf == NULL)) return;
+
+    if ((ctxt == NULL) || (ctxt->encoding == NULL))
+        escapeFlags |= XML_ESCAPE_NON_ASCII;
+
     if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {
 	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))
 	    return;
@@ -889,7 +881,7 @@ xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNsPtr cur,
 	} else
 	    xmlOutputBufferWrite(buf, 5, "xmlns");
         xmlOutputBufferWrite(buf, 2, "=\"");
-        xmlBufAttrSerializeTxtContent(buf, doc, cur->href);
+        xmlSerializeText(buf, cur->href, escapeFlags);
         xmlOutputBufferWrite(buf, 1, "\"");
     }
 }
@@ -903,9 +895,9 @@ xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNsPtr cur,
  * Should be called in the context of attribute dumps.
  */
 static void
-xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlDocPtr doc, xmlNsPtr cur) {
+xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {
     while (cur != NULL) {
-        xmlNsDumpOutput(ctxt->buf, doc, cur, ctxt);
+        xmlNsDumpOutput(ctxt->buf, cur, ctxt);
 	cur = cur->next;
     }
 }
@@ -921,7 +913,7 @@ xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlDocPtr doc, xmlNsPtr cur) {
 void
 xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur) {
     while (cur != NULL) {
-        xmlNsDumpOutput(buf, NULL, cur, NULL);
+        xmlNsDumpOutput(buf, cur, NULL);
 	cur = cur->next;
     }
 }
@@ -1016,7 +1008,7 @@ xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
     } else
 #endif
     {
-        xmlAttrSerializeContent(buf, cur);
+        xmlSaveWriteAttrContent(ctxt, cur);
     }
     xmlOutputBufferWrite(buf, 1, "\"");
 }
@@ -1030,7 +1022,6 @@ xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
  */
 static int
 htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
-    const xmlChar *oldenc = NULL;
     const xmlChar *oldctxtenc = ctxt->encoding;
     const xmlChar *encoding = ctxt->encoding;
     xmlOutputBufferPtr buf = ctxt->buf;
@@ -1040,14 +1031,8 @@ htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
     xmlInitParser();
 
     doc = cur->doc;
-    if (doc != NULL) {
-        oldenc = doc->encoding;
-	if (ctxt->encoding != NULL) {
-	    doc->encoding = BAD_CAST ctxt->encoding;
-	} else if (doc->encoding != NULL) {
-	    encoding = doc->encoding;
-	}
-    }
+    if ((encoding == NULL) && (doc != NULL))
+	encoding = doc->encoding;
 
     if ((encoding != NULL) && (doc != NULL))
 	htmlSetMetaEncoding(doc, (const xmlChar *) encoding);
@@ -1057,10 +1042,8 @@ htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 	encoding = BAD_CAST "HTML";
     if ((encoding != NULL) && (oldctxtenc == NULL) &&
 	(buf->encoder == NULL) && (buf->conv == NULL)) {
-	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {
-	    doc->encoding = oldenc;
+	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0)
 	    return(-1);
-	}
 	switched_encoding = 1;
     }
     if (ctxt->options & XML_SAVE_FORMAT)
@@ -1075,8 +1058,6 @@ htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
     if ((switched_encoding) && (oldctxtenc == NULL)) {
 	xmlSaveClearEncoding(ctxt);
     }
-    if (doc != NULL)
-	doc->encoding = oldenc;
     return(0);
 }
 #endif
@@ -1133,12 +1114,8 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
             break;
 
         case XML_ELEMENT_NODE:
-	    if ((cur != root) && (ctxt->format == 1) &&
-                (xmlIndentTreeOutput))
-		xmlOutputBufferWrite(buf, ctxt->indent_size *
-				     (ctxt->level > ctxt->indent_nr ?
-				      ctxt->indent_nr : ctxt->level),
-				     ctxt->indent);
+	    if ((cur != root) && (ctxt->format == 1))
+                xmlSaveWriteIndent(ctxt, 0);
 
             /*
              * Some users like lxml are known to pass nodes with a corrupted
@@ -1157,7 +1134,7 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
             }
             xmlOutputBufferWriteString(buf, (const char *)cur->name);
             if (cur->nsDef)
-                xmlNsListDumpOutputCtxt(ctxt, cur->doc, cur->nsDef);
+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
             for (attr = cur->properties; attr != NULL; attr = attr->next)
                 xmlAttrDumpOutput(ctxt, attr);
 
@@ -1210,7 +1187,15 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 	    if (cur->content == NULL)
                 break;
 	    if (cur->name != xmlStringTextNoenc) {
-                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
+                if (ctxt->escape)
+                    xmlOutputBufferWriteEscape(buf, cur->content,
+                                               ctxt->escape);
+#ifdef TEST_OUTPUT_BUFFER_WRITE_ESCAPE
+                else if (ctxt->encoding)
+                    xmlOutputBufferWriteEscape(buf, cur->content, NULL);
+#endif
+                else
+                    xmlSaveWriteText(ctxt, cur->content, /* flags */ 0);
 	    } else {
 		/*
 		 * Disable escaping, needed for XSLT
@@ -1220,11 +1205,8 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 	    break;
 
         case XML_PI_NODE:
-	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
-		xmlOutputBufferWrite(buf, ctxt->indent_size *
-				     (ctxt->level > ctxt->indent_nr ?
-				      ctxt->indent_nr : ctxt->level),
-				     ctxt->indent);
+	    if ((cur != root) && (ctxt->format == 1))
+                xmlSaveWriteIndent(ctxt, 0);
 
             if (cur->content != NULL) {
                 xmlOutputBufferWrite(buf, 2, "<?");
@@ -1248,11 +1230,8 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
             break;
 
         case XML_COMMENT_NODE:
-	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
-		xmlOutputBufferWrite(buf, ctxt->indent_size *
-				     (ctxt->level > ctxt->indent_nr ?
-				      ctxt->indent_nr : ctxt->level),
-				     ctxt->indent);
+	    if ((cur != root) && (ctxt->format == 1))
+                xmlSaveWriteIndent(ctxt, 0);
 
             if (cur->content != NULL) {
                 xmlOutputBufferWrite(buf, 4, "<!--");
@@ -1297,7 +1276,7 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
             break;
 
         case XML_NAMESPACE_DECL:
-            xmlNsDumpOutput(buf, NULL, (xmlNsPtr) cur, ctxt);
+            xmlNsDumpOutput(buf, (xmlNsPtr) cur, ctxt);
             break;
 
         default:
@@ -1322,11 +1301,8 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 
             if (cur->type == XML_ELEMENT_NODE) {
                 if (ctxt->level > 0) ctxt->level--;
-                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
-                    xmlOutputBufferWrite(buf, ctxt->indent_size *
-                                         (ctxt->level > ctxt->indent_nr ?
-                                          ctxt->indent_nr : ctxt->level),
-                                         ctxt->indent);
+                if (ctxt->format == 1)
+                    xmlSaveWriteIndent(ctxt, 0);
 
                 xmlOutputBufferWrite(buf, 2, "</");
                 if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
@@ -1361,11 +1337,8 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
     xmlDtdPtr dtd;
     int is_xhtml = 0;
 #endif
-    const xmlChar *oldenc = cur->encoding;
     const xmlChar *oldctxtenc = ctxt->encoding;
     const xmlChar *encoding = ctxt->encoding;
-    xmlCharEncodingOutputFunc oldescape = ctxt->escape;
-    xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;
     xmlOutputBufferPtr buf = ctxt->buf;
     xmlCharEncoding enc;
     int switched_encoding = 0;
@@ -1376,11 +1349,8 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
         (cur->type != XML_DOCUMENT_NODE))
 	 return(-1);
 
-    if (ctxt->encoding != NULL) {
-        cur->encoding = BAD_CAST ctxt->encoding;
-    } else if (cur->encoding != NULL) {
+    if (ctxt->encoding == NULL)
 	encoding = cur->encoding;
-    }
 
     if (((cur->type == XML_HTML_DOCUMENT_NODE) &&
          ((ctxt->options & XML_SAVE_AS_XML) == 0) &&
@@ -1396,7 +1366,6 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
 	if ((encoding != NULL) && (oldctxtenc == NULL) &&
 	    (buf->encoder == NULL) && (buf->conv == NULL)) {
 	    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {
-		cur->encoding = oldenc;
 		return(-1);
 	    }
 	}
@@ -1406,8 +1375,6 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
 	else
 	    htmlDocContentDumpFormatOutput(buf, cur,
 	                                   (const char *)encoding, 0);
-	if (ctxt->encoding != NULL)
-	    cur->encoding = oldenc;
 	return(0);
 #else
         return(-1);
@@ -1427,16 +1394,10 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
 		 * document since we output the XMLDecl the conversion
 		 * must be done to not generate not well formed documents.
 		 */
-		if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {
-		    cur->encoding = oldenc;
+		if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0)
 		    return(-1);
-		}
 		switched_encoding = 1;
 	    }
-	    if (ctxt->escape == xmlEscapeEntities)
-		ctxt->escape = NULL;
-	    if (ctxt->escapeAttr == xmlEscapeEntities)
-		ctxt->escapeAttr = NULL;
 	}
 
 
@@ -1499,10 +1460,7 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
      */
     if ((switched_encoding) && (oldctxtenc == NULL)) {
 	xmlSaveClearEncoding(ctxt);
-	ctxt->escape = oldescape;
-	ctxt->escapeAttr = oldescapeAttr;
     }
-    cur->encoding = oldenc;
     return(0);
 }
 
@@ -1629,7 +1587,7 @@ xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
 	     (xmlStrEqual(parent->name, BAD_CAST "frame")) ||
 	     (xmlStrEqual(parent->name, BAD_CAST "iframe")))) {
 	    xmlOutputBufferWrite(buf, 5, " id=\"");
-	    xmlAttrSerializeContent(buf, name);
+            xmlSaveWriteAttrContent(ctxt, name);
 	    xmlOutputBufferWrite(buf, 1, "\"");
 	}
     }
@@ -1638,12 +1596,12 @@ xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
      */
     if ((lang != NULL) && (xml_lang == NULL)) {
 	xmlOutputBufferWrite(buf, 11, " xml:lang=\"");
-	xmlAttrSerializeContent(buf, lang);
+        xmlSaveWriteAttrContent(ctxt, lang);
 	xmlOutputBufferWrite(buf, 1, "\"");
     } else
     if ((xml_lang != NULL) && (lang == NULL)) {
 	xmlOutputBufferWrite(buf, 7, " lang=\"");
-	xmlAttrSerializeContent(buf, xml_lang);
+        xmlSaveWriteAttrContent(ctxt, xml_lang);
 	xmlOutputBufferWrite(buf, 1, "\"");
     }
 }
@@ -1681,7 +1639,7 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 	    break;
 
         case XML_NAMESPACE_DECL:
-	    xmlNsDumpOutput(buf, NULL, (xmlNsPtr) cur, ctxt);
+	    xmlNsDumpOutput(buf, (xmlNsPtr) cur, ctxt);
 	    break;
 
         case XML_DTD_NODE:
@@ -1712,11 +1670,8 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
         case XML_ELEMENT_NODE:
             addmeta = 0;
 
-	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
-		xmlOutputBufferWrite(buf, ctxt->indent_size *
-				     (ctxt->level > ctxt->indent_nr ?
-				      ctxt->indent_nr : ctxt->level),
-				     ctxt->indent);
+	    if ((cur != root) && (ctxt->format == 1))
+                xmlSaveWriteIndent(ctxt, 0);
 
             /*
              * Some users like lxml are known to pass nodes with a corrupted
@@ -1736,7 +1691,7 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 
             xmlOutputBufferWriteString(buf, (const char *)cur->name);
             if (cur->nsDef)
-                xmlNsListDumpOutputCtxt(ctxt, cur->doc, cur->nsDef);
+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
             if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
                 (cur->ns == NULL) && (cur->nsDef == NULL))) {
                 /*
@@ -1786,11 +1741,7 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
                         xmlOutputBufferWrite(buf, 1, ">");
                         if (ctxt->format == 1) {
                             xmlOutputBufferWrite(buf, 1, "\n");
-                            if (xmlIndentTreeOutput)
-                                xmlOutputBufferWrite(buf, ctxt->indent_size *
-                                    (ctxt->level + 1 > ctxt->indent_nr ?
-                                    ctxt->indent_nr : ctxt->level + 1),
-                                    ctxt->indent);
+                            xmlSaveWriteIndent(ctxt, 1);
                         }
                         xmlOutputBufferWriteString(buf,
                                 "<meta http-equiv=\"Content-Type\" "
@@ -1824,11 +1775,7 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
                 if (addmeta == 1) {
                     if (ctxt->format == 1) {
                         xmlOutputBufferWrite(buf, 1, "\n");
-                        if (xmlIndentTreeOutput)
-                            xmlOutputBufferWrite(buf, ctxt->indent_size *
-                                (ctxt->level + 1 > ctxt->indent_nr ?
-                                ctxt->indent_nr : ctxt->level + 1),
-                                ctxt->indent);
+                        xmlSaveWriteIndent(ctxt, 1);
                     }
                     xmlOutputBufferWriteString(buf,
                             "<meta http-equiv=\"Content-Type\" "
@@ -1869,7 +1816,11 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
                 break;
 	    if ((cur->name == xmlStringText) ||
 		(cur->name != xmlStringTextNoenc)) {
-                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
+                if (ctxt->escape)
+                    xmlOutputBufferWriteEscape(buf, cur->content,
+                                               ctxt->escape);
+                else
+                    xmlSaveWriteText(ctxt, cur->content, /* flags */ 0);
 	    } else {
 		/*
 		 * Disable escaping, needed for XSLT
@@ -1958,11 +1909,8 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 
             if (cur->type == XML_ELEMENT_NODE) {
                 if (ctxt->level > 0) ctxt->level--;
-                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
-                    xmlOutputBufferWrite(buf, ctxt->indent_size *
-                                         (ctxt->level > ctxt->indent_nr ?
-                                          ctxt->indent_nr : ctxt->level),
-                                         ctxt->indent);
+                if (ctxt->format == 1)
+                    xmlSaveWriteIndent(ctxt, 0);
 
                 xmlOutputBufferWrite(buf, 2, "</");
                 if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
@@ -2012,7 +1960,6 @@ xmlSaveToFd(int fd, const char *encoding, int options)
     if (ret == NULL) return(NULL);
     ret->buf = xmlOutputBufferCreateFd(fd, ret->handler);
     if (ret->buf == NULL) {
-        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -2042,7 +1989,6 @@ xmlSaveToFilename(const char *filename, const char *encoding, int options)
     ret->buf = xmlOutputBufferCreateFilename(filename, ret->handler,
                                              compression);
     if (ret->buf == NULL) {
-        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -2070,7 +2016,6 @@ xmlSaveToBuffer(xmlBufferPtr buffer, const char *encoding, int options)
     if (ret == NULL) return(NULL);
     ret->buf = xmlOutputBufferCreateBuffer(buffer, ret->handler);
     if (ret->buf == NULL) {
-        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -2101,7 +2046,6 @@ xmlSaveToIO(xmlOutputWriteCallback iowrite,
     if (ret == NULL) return(NULL);
     ret->buf = xmlOutputBufferCreateIO(iowrite, ioclose, ioctx, ret->handler);
     if (ret->buf == NULL) {
-        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -2264,6 +2208,8 @@ xmlSaveFinish(xmlSaveCtxtPtr ctxt)
  * @ctxt:  a document saving context
  * @escape:  the escaping function
  *
+ * DEPRECATED: Don't use.
+ *
  * Set a custom escaping function to be used for text in element content
  *
  * Returns 0 if successful or -1 in case of error.
@@ -2281,15 +2227,17 @@ xmlSaveSetEscape(xmlSaveCtxtPtr ctxt, xmlCharEncodingOutputFunc escape)
  * @ctxt:  a document saving context
  * @escape:  the escaping function
  *
- * Set a custom escaping function to be used for text in attribute content
+ * DEPRECATED: Don't use.
+ *
+ * Has no effect.
  *
  * Returns 0 if successful or -1 in case of error.
  */
 int
-xmlSaveSetAttrEscape(xmlSaveCtxtPtr ctxt, xmlCharEncodingOutputFunc escape)
+xmlSaveSetAttrEscape(xmlSaveCtxtPtr ctxt,
+                     xmlCharEncodingOutputFunc escape ATTRIBUTE_UNUSED)
 {
     if (ctxt == NULL) return(-1);
-    ctxt->escapeAttr = escape;
     return(0);
 }
 
@@ -2311,88 +2259,11 @@ void
 xmlBufAttrSerializeTxtContent(xmlOutputBufferPtr buf, xmlDocPtr doc,
                               const xmlChar *string)
 {
-    const xmlChar *base, *cur;
+    int flags = XML_ESCAPE_ATTR;
 
-    if (string == NULL)
-        return;
-    base = cur = string;
-    while (*cur != 0) {
-        if (*cur == '\n') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 5, "&#10;");
-            cur++;
-            base = cur;
-        } else if (*cur == '\r') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 5, "&#13;");
-            cur++;
-            base = cur;
-        } else if (*cur == '\t') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 4, "&#9;");
-            cur++;
-            base = cur;
-        } else if (*cur == '"') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 6, "&quot;");
-            cur++;
-            base = cur;
-        } else if (*cur == '<') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 4, "&lt;");
-            cur++;
-            base = cur;
-        } else if (*cur == '>') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 4, "&gt;");
-            cur++;
-            base = cur;
-        } else if (*cur == '&') {
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-            xmlOutputBufferWrite(buf, 5, "&amp;");
-            cur++;
-            base = cur;
-        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
-	           ((doc == NULL) || (doc->encoding == NULL))) {
-            /*
-             * We assume we have UTF-8 content.
-             */
-            unsigned char tmp[12];
-            int val = 0, l = 4;
-
-            if (base != cur)
-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);
-
-            val = xmlGetUTF8Char(cur, &l);
-            if (val < 0) {
-                val = 0xFFFD;
-                cur++;
-            } else {
-                if (!IS_CHAR(val))
-                    val = 0xFFFD;
-                cur += l;
-            }
-
-            /*
-             * We could do multiple things here. Just save
-             * as a char ref
-             */
-	    xmlSerializeHexCharRef(tmp, val);
-            xmlOutputBufferWriteString(buf, (const char *) tmp);
-            base = cur;
-        } else {
-            cur++;
-        }
-    }
-    if (base != cur)
-        xmlOutputBufferWrite(buf, cur - base, (const char *) base);
+    if ((doc == NULL) || (doc->encoding == NULL))
+        flags |= XML_ESCAPE_NON_ASCII;
+    xmlSerializeText(buf, string, flags);
 }
 
 /**
@@ -2442,7 +2313,8 @@ xmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
             int format)
 {
     xmlBufPtr buffer;
-    size_t ret;
+    size_t ret1;
+    int ret2;
 
     if ((buf == NULL) || (cur == NULL))
         return(-1);
@@ -2453,11 +2325,11 @@ xmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
     buffer = xmlBufFromBuffer(buf);
     if (buffer == NULL)
         return(-1);
-    ret = xmlBufNodeDump(buffer, doc, cur, level, format);
-    xmlBufBackToBuffer(buffer);
-    if (ret > INT_MAX)
+    ret1 = xmlBufNodeDump(buffer, doc, cur, level, format);
+    ret2 = xmlBufBackToBuffer(buffer, buf);
+    if ((ret1 == (size_t) -1) || (ret2 < 0))
         return(-1);
-    return(ret);
+    return(ret1 > INT_MAX ? INT_MAX : ret1);
 }
 
 /**
@@ -2483,7 +2355,6 @@ xmlBufNodeDump(xmlBufPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
     size_t use;
     size_t ret;
     xmlOutputBufferPtr outbuf;
-    int oldalloc;
 
     xmlInitParser();
 
@@ -2507,10 +2378,7 @@ xmlBufNodeDump(xmlBufPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
     outbuf->written = 0;
 
     use = xmlBufUse(buf);
-    oldalloc = xmlBufGetAllocationScheme(buf);
-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
     xmlNodeDumpOutput(outbuf, doc, cur, level, format, NULL);
-    xmlBufSetAllocationScheme(buf, oldalloc);
     if (outbuf->error)
         ret = (size_t) -1;
     else
@@ -2574,6 +2442,7 @@ xmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur,
                   int level, int format, const char *encoding)
 {
     xmlSaveCtxt ctxt;
+    int options;
 #ifdef LIBXML_HTML_ENABLED
     xmlDtdPtr dtd;
     int is_xhtml = 0;
@@ -2596,10 +2465,12 @@ xmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur,
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = buf;
     ctxt.level = level;
-    ctxt.format = format ? 1 : 0;
     ctxt.encoding = (const xmlChar *) encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    options = XML_SAVE_AS_XML;
+    if (format)
+        options |= XML_SAVE_FORMAT;
+    xmlSaveCtxtInit(&ctxt, options);
 
 #ifdef LIBXML_HTML_ENABLED
     dtd = xmlGetIntSubset(doc);
@@ -2636,6 +2507,7 @@ xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc, xmlChar **doc_txt_ptr,
 		int * doc_txt_len, const char * txt_encoding,
 		int format) {
     xmlSaveCtxt ctxt;
+    int options;
     int                         dummy = 0;
     xmlOutputBufferPtr          out_buff = NULL;
     xmlCharEncodingHandlerPtr   conv_hdlr = NULL;
@@ -2669,25 +2541,28 @@ xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc, xmlChar **doc_txt_ptr,
 
 	res = xmlOpenCharEncodingHandler(txt_encoding, /* output */ 1,
                                          &conv_hdlr);
-	if (conv_hdlr == NULL) {
+	if (res != XML_ERR_OK) {
             xmlSaveErr(NULL, res, NULL, txt_encoding);
 	    return;
 	}
     }
 
-    if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {
+    out_buff = xmlAllocOutputBuffer(conv_hdlr);
+    if (out_buff == NULL ) {
         xmlSaveErrMemory(NULL);
-        xmlCharEncCloseFunc(conv_hdlr);
         return;
     }
 
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = out_buff;
     ctxt.level = 0;
-    ctxt.format = format ? 1 : 0;
     ctxt.encoding = (const xmlChar *) txt_encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    options = XML_SAVE_AS_XML;
+    if (format)
+        options |= XML_SAVE_FORMAT;
+    xmlSaveCtxtInit(&ctxt, options);
+
     xmlDocContentDumpOutput(&ctxt, out_doc);
     xmlOutputBufferFlush(out_buff);
 
@@ -2776,6 +2651,7 @@ xmlDocFormatDump(FILE *f, xmlDocPtr cur, int format) {
     const char * encoding;
     xmlCharEncodingHandlerPtr handler = NULL;
     int ret;
+    int options;
 
     if (cur == NULL) {
 	return(-1);
@@ -2783,10 +2659,11 @@ xmlDocFormatDump(FILE *f, xmlDocPtr cur, int format) {
     encoding = (const char *) cur->encoding;
 
     if (encoding != NULL) {
-	xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
-	if (handler == NULL) {
+        int res;
+
+	res = xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
+	if (res != XML_ERR_OK) {
 	    xmlFree((char *) cur->encoding);
-	    cur->encoding = NULL;
 	    encoding = NULL;
 	}
     }
@@ -2795,10 +2672,13 @@ xmlDocFormatDump(FILE *f, xmlDocPtr cur, int format) {
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = buf;
     ctxt.level = 0;
-    ctxt.format = format ? 1 : 0;
     ctxt.encoding = (const xmlChar *) encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    options = XML_SAVE_AS_XML;
+    if (format)
+        options |= XML_SAVE_FORMAT;
+    xmlSaveCtxtInit(&ctxt, options);
+
     xmlDocContentDumpOutput(&ctxt, cur);
 
     ret = xmlOutputBufferClose(buf);
@@ -2844,10 +2724,10 @@ xmlSaveFileTo(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding) {
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = buf;
     ctxt.level = 0;
-    ctxt.format = 0;
     ctxt.encoding = (const xmlChar *) encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    xmlSaveCtxtInit(&ctxt, XML_SAVE_AS_XML);
+
     xmlDocContentDumpOutput(&ctxt, cur);
     ret = xmlOutputBufferClose(buf);
     return(ret);
@@ -2872,6 +2752,7 @@ xmlSaveFormatFileTo(xmlOutputBufferPtr buf, xmlDocPtr cur,
 {
     xmlSaveCtxt ctxt;
     int ret;
+    int options;
 
     if (buf == NULL) return(-1);
     if ((cur == NULL) ||
@@ -2883,10 +2764,13 @@ xmlSaveFormatFileTo(xmlOutputBufferPtr buf, xmlDocPtr cur,
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = buf;
     ctxt.level = 0;
-    ctxt.format = format ? 1 : 0;
     ctxt.encoding = (const xmlChar *) encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    options = XML_SAVE_AS_XML;
+    if (format)
+        options |= XML_SAVE_FORMAT;
+    xmlSaveCtxtInit(&ctxt, options);
+
     xmlDocContentDumpOutput(&ctxt, cur);
     ret = xmlOutputBufferClose(buf);
     return (ret);
@@ -2912,6 +2796,7 @@ xmlSaveFormatFileEnc( const char * filename, xmlDocPtr cur,
     xmlOutputBufferPtr buf;
     xmlCharEncodingHandlerPtr handler = NULL;
     int ret;
+    int options;
 
     if (cur == NULL)
 	return(-1);
@@ -2920,8 +2805,10 @@ xmlSaveFormatFileEnc( const char * filename, xmlDocPtr cur,
 	encoding = (const char *) cur->encoding;
 
     if (encoding != NULL) {
-        xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
-        if (handler == NULL)
+        int res;
+
+        res = xmlOpenCharEncodingHandler(encoding, /* output */ 1, &handler);
+        if (res != XML_ERR_OK)
             return(-1);
     }
 
@@ -2936,10 +2823,12 @@ xmlSaveFormatFileEnc( const char * filename, xmlDocPtr cur,
     memset(&ctxt, 0, sizeof(ctxt));
     ctxt.buf = buf;
     ctxt.level = 0;
-    ctxt.format = format ? 1 : 0;
     ctxt.encoding = (const xmlChar *) encoding;
-    xmlSaveCtxtInit(&ctxt);
-    ctxt.options |= XML_SAVE_AS_XML;
+
+    options = XML_SAVE_AS_XML;
+    if (format)
+        options |= XML_SAVE_FORMAT;
+    xmlSaveCtxtInit(&ctxt, options);
 
     xmlDocContentDumpOutput(&ctxt, cur);
 
diff --git a/xmlschemas.c b/xmlschemas.c
index cae55fac..f5958327 100644
--- a/xmlschemas.c
+++ b/xmlschemas.c
@@ -27292,7 +27292,7 @@ xmlSchemaSAXHandleStartElementNs(void *ctx,
 	    * we are forced to work around it.
 	    */
 	    valueLen = attributes[j+4] - attributes[j+3];
-	    value = xmlMallocAtomic(valueLen + 1);
+	    value = xmlMalloc(valueLen + 1);
 	    if (value == NULL) {
 		xmlSchemaVErrMemory(vctxt);
 		goto internal_error;
@@ -27343,7 +27343,6 @@ exit:
 internal_error:
     vctxt->err = -1;
     xmlStopParser(vctxt->parserCtxt);
-    return;
 }
 
 static void
@@ -27387,7 +27386,6 @@ exit:
 internal_error:
     vctxt->err = -1;
     xmlStopParser(vctxt->parserCtxt);
-    return;
 }
 
 /************************************************************************
@@ -28808,7 +28806,11 @@ xmlSchemaValidateStream(xmlSchemaValidCtxtPtr ctxt,
         ret = -1;
 	goto done;
     }
-    inputPush(pctxt, inputStream);
+    if (inputPush(pctxt, inputStream) < 0) {
+        xmlFreeInputStream(inputStream);
+        ret = -1;
+        goto done;
+    }
 
     ctxt->enc = enc;
 
diff --git a/xmlschemastypes.c b/xmlschemastypes.c
index 5c6db292..1d91aaf2 100644
--- a/xmlschemastypes.c
+++ b/xmlschemastypes.c
@@ -36,10 +36,8 @@
 
 #include "private/error.h"
 
-#ifndef LIBXML_XPATH_ENABLED
-extern double xmlXPathNAN;
-extern double xmlXPathPINF;
-extern double xmlXPathNINF;
+#ifndef isnan
+  #define isnan(x) (!((x) == (x)))
 #endif
 
 #define XML_SCHEMAS_NAMESPACE_NAME \
@@ -124,6 +122,11 @@ struct _xmlSchemaVal {
 };
 
 static int xmlSchemaTypesInitialized = 0;
+
+static double xmlSchemaNAN = 0.0;
+static double xmlSchemaPINF = 0.0;
+static double xmlSchemaNINF = 0.0;
+
 static xmlHashTablePtr xmlSchemaTypesBank = NULL;
 
 /*
@@ -521,6 +524,19 @@ xmlSchemaInitTypes(void)
 {
     if (xmlSchemaTypesInitialized != 0)
         return (0);
+
+#if defined(NAN) && defined(INFINITY)
+    xmlSchemaNAN = NAN;
+    xmlSchemaPINF = INFINITY;
+    xmlSchemaNINF = -INFINITY;
+#else
+    /* MSVC doesn't allow division by zero in constant expressions. */
+    double zero = 0.0;
+    xmlSchemaNAN = 0.0 / zero;
+    xmlSchemaPINF = 1.0 / zero;
+    xmlSchemaNINF = -xmlSchemaPINF;
+#endif
+
     xmlSchemaTypesBank = xmlHashCreate(40);
     if (xmlSchemaTypesBank == NULL) {
 	xmlSchemaTypeErrMemory();
@@ -2709,7 +2725,7 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                         if (type == xmlSchemaTypeFloatDef) {
                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
                             if (v != NULL) {
-                                v->value.f = (float) xmlXPathNAN;
+                                v->value.f = (float) xmlSchemaNAN;
                             } else {
                                 xmlSchemaFreeValue(v);
                                 goto error;
@@ -2717,7 +2733,7 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                         } else {
                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
                             if (v != NULL) {
-                                v->value.d = xmlXPathNAN;
+                                v->value.d = xmlSchemaNAN;
                             } else {
                                 xmlSchemaFreeValue(v);
                                 goto error;
@@ -2740,9 +2756,9 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
                             if (v != NULL) {
                                 if (neg)
-                                    v->value.f = (float) xmlXPathNINF;
+                                    v->value.f = (float) xmlSchemaNINF;
                                 else
-                                    v->value.f = (float) xmlXPathPINF;
+                                    v->value.f = (float) xmlSchemaPINF;
                             } else {
                                 xmlSchemaFreeValue(v);
                                 goto error;
@@ -2751,9 +2767,9 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
                             if (v != NULL) {
                                 if (neg)
-                                    v->value.d = xmlXPathNINF;
+                                    v->value.d = xmlSchemaNINF;
                                 else
-                                    v->value.d = xmlXPathPINF;
+                                    v->value.d = xmlSchemaPINF;
                             } else {
                                 xmlSchemaFreeValue(v);
                                 goto error;
@@ -3180,8 +3196,13 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                 if ((node == NULL) || (node->doc == NULL))
                     ret = 3;
                 if (ret == 0) {
-                    ret = xmlValidateNotationUse(NULL, node->doc, value);
-                    if (ret == 1)
+                    xmlNotationPtr nota;
+
+                    nota = xmlGetDtdNotationDesc(node->doc->intSubset, value);
+                    if ((nota == NULL) && (node->doc->extSubset != NULL))
+                        nota = xmlGetDtdNotationDesc(node->doc->extSubset,
+                                                     value);
+                    if (nota != NULL)
                         ret = 0;
                     else
                         ret = 1;
@@ -3405,7 +3426,7 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                     if (v == NULL)
                         goto error;
                     base =
-                        (xmlChar *) xmlMallocAtomic(i + pad + 1);
+                        xmlMalloc(i + pad + 1);
                     if (base == NULL) {
 		        xmlSchemaTypeErrMemory();
                         xmlFree(v);
@@ -4818,27 +4839,13 @@ xmlSchemaCompareFloats(xmlSchemaValPtr x, xmlSchemaValPtr y) {
     /*
      * Check for special cases.
      */
-    if (xmlXPathIsNaN(d1)) {
-	if (xmlXPathIsNaN(d2))
+    if (isnan(d1)) {
+	if (isnan(d2))
 	    return(0);
 	return(1);
     }
-    if (xmlXPathIsNaN(d2))
+    if (isnan(d2))
 	return(-1);
-    if (d1 == xmlXPathPINF) {
-	if (d2 == xmlXPathPINF)
-	    return(0);
-        return(1);
-    }
-    if (d2 == xmlXPathPINF)
-        return(-1);
-    if (d1 == xmlXPathNINF) {
-	if (d2 == xmlXPathNINF)
-	    return(0);
-        return(-1);
-    }
-    if (d2 == xmlXPathNINF)
-        return(1);
 
     /*
      * basic tests, the last one we should have equality, but
@@ -5777,86 +5784,6 @@ xmlSchemaValidateFacetWhtsp(xmlSchemaFacetPtr facet,
 	 value, val, ws));
 }
 
-#if 0
-#ifndef DBL_DIG
-#define DBL_DIG 16
-#endif
-#ifndef DBL_EPSILON
-#define DBL_EPSILON 1E-9
-#endif
-
-#define INTEGER_DIGITS DBL_DIG
-#define FRACTION_DIGITS (DBL_DIG + 1)
-#define EXPONENT_DIGITS (3 + 2)
-
-/**
- * xmlXPathFormatNumber:
- * @number:     number to format
- * @buffer:     output buffer
- * @buffersize: size of output buffer
- *
- * Convert the number into a string representation.
- */
-static void
-xmlSchemaFormatFloat(double number, char buffer[], int buffersize)
-{
-    switch (xmlXPathIsInf(number)) {
-    case 1:
-	if (buffersize > (int)sizeof("INF"))
-	    snprintf(buffer, buffersize, "INF");
-	break;
-    case -1:
-	if (buffersize > (int)sizeof("-INF"))
-	    snprintf(buffer, buffersize, "-INF");
-	break;
-    default:
-	if (xmlXPathIsNaN(number)) {
-	    if (buffersize > (int)sizeof("NaN"))
-		snprintf(buffer, buffersize, "NaN");
-	} else if (number == 0) {
-	    snprintf(buffer, buffersize, "0.0E0");
-	} else {
-	    /* 3 is sign, decimal point, and terminating zero */
-	    char work[DBL_DIG + EXPONENT_DIGITS + 3];
-	    int integer_place, fraction_place;
-	    char *ptr;
-	    char *after_fraction;
-	    double absolute_value;
-	    int size;
-
-	    absolute_value = fabs(number);
-
-	    /*
-	     * Result is in work, and after_fraction points
-	     * just past the fractional part.
-	     * Use scientific notation
-	    */
-	    integer_place = DBL_DIG + EXPONENT_DIGITS + 1;
-	    fraction_place = DBL_DIG - 1;
-	    snprintf(work, sizeof(work),"%*.*e",
-		integer_place, fraction_place, number);
-	    after_fraction = strchr(work + DBL_DIG, 'e');
-	    /* Remove fractional trailing zeroes */
-	    ptr = after_fraction;
-	    while (*(--ptr) == '0')
-		;
-	    if (*ptr != '.')
-	        ptr++;
-	    while ((*ptr++ = *after_fraction++) != 0);
-
-	    /* Finally copy result back to caller */
-	    size = strlen(work) + 1;
-	    if (size > buffersize) {
-		work[buffersize - 1] = 0;
-		size = buffersize;
-	    }
-	    memmove(buffer, work, size);
-	}
-	break;
-    }
-}
-#endif
-
 /**
  * xmlSchemaGetCanonValue:
  * @val: the precomputed value
diff --git a/xmlstring.c b/xmlstring.c
index 258ecc92..b5000e4f 100644
--- a/xmlstring.c
+++ b/xmlstring.c
@@ -54,7 +54,7 @@ xmlStrndup(const xmlChar *cur, int len) {
     xmlChar *ret;
 
     if ((cur == NULL) || (len < 0)) return(NULL);
-    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
+    ret = xmlMalloc((size_t) len + 1);
     if (ret == NULL) {
         return(NULL);
     }
@@ -98,7 +98,7 @@ xmlCharStrndup(const char *cur, int len) {
     xmlChar *ret;
 
     if ((cur == NULL) || (len < 0)) return(NULL);
-    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
+    ret = xmlMalloc((size_t) len + 1);
     if (ret == NULL) {
         return(NULL);
     }
@@ -994,7 +994,8 @@ xmlUTF8Strsize(const xmlChar *utf, int len) {
     while ( len-- > 0) {
         if ( !*ptr )
             break;
-        if ( (ch = *ptr++) & 0x80)
+        ch = *ptr++;
+        if ((ch & 0x80))
             while ((ch<<=1) & 0x80 ) {
 		if (*ptr == 0) break;
                 ptr++;
@@ -1021,7 +1022,7 @@ xmlUTF8Strndup(const xmlChar *utf, int len) {
 
     if ((utf == NULL) || (len < 0)) return(NULL);
     i = xmlUTF8Strsize(utf, len);
-    ret = (xmlChar *) xmlMallocAtomic((size_t) i + 1);
+    ret = xmlMalloc((size_t) i + 1);
     if (ret == NULL) {
         return(NULL);
     }
@@ -1048,7 +1049,9 @@ xmlUTF8Strpos(const xmlChar *utf, int pos) {
     if (pos < 0)
         return(NULL);
     while (pos--) {
-        if ((ch=*utf++) == 0) return(NULL);
+        ch = *utf++;
+        if (ch == 0)
+            return(NULL);
         if ( ch & 0x80 ) {
             /* if not simple ascii, verify proper format */
             if ( (ch & 0xc0) != 0xc0 )
@@ -1175,7 +1178,7 @@ xmlEscapeFormatString(xmlChar **msg)
     if ((count > INT_MAX) || (msgLen > INT_MAX - count))
         return(NULL);
     resultLen = msgLen + count + 1;
-    result = (xmlChar *) xmlMallocAtomic(resultLen);
+    result = xmlMalloc(resultLen);
     if (result == NULL) {
         /* Clear *msg to prevent format string vulnerabilities in
            out-of-memory situations. */
diff --git a/xmlunicode.c b/xmlunicode.c
index 677f25e8..a385bcbd 100644
--- a/xmlunicode.c
+++ b/xmlunicode.c
@@ -954,7 +954,8 @@ static xmlIntFunc
     sptr = tptr->table;
     while (low <= high) {
 	mid = (low + high) / 2;
-	if ((cmp=strcmp(tname, sptr[mid].rangename)) == 0)
+	cmp = strcmp(tname, sptr[mid].rangename);
+	if (cmp == 0)
 	    return (sptr[mid].func);
 	if (cmp < 0)
 	    high = mid - 1;
diff --git a/xmlwriter.c b/xmlwriter.c
index f648dc05..b706889a 100644
--- a/xmlwriter.c
+++ b/xmlwriter.c
@@ -123,14 +123,14 @@ static void
 xmlWriterErrMsg(xmlTextWriterPtr ctxt, xmlParserErrors error,
                const char *msg)
 {
-    if (ctxt != NULL) {
-	__xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,
-	            NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,
-		    NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
-    } else {
-	__xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,
-                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
-    }
+    xmlParserCtxtPtr pctxt = NULL;
+
+    if (ctxt != NULL)
+        pctxt = ctxt->ctxt;
+
+    xmlRaiseError(NULL, NULL, NULL, pctxt,
+                  NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,
+                  NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
 }
 
 /**
@@ -146,14 +146,14 @@ static void LIBXML_ATTR_FORMAT(3,0)
 xmlWriterErrMsgInt(xmlTextWriterPtr ctxt, xmlParserErrors error,
                const char *msg, int val)
 {
-    if (ctxt != NULL) {
-	__xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,
-	            NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,
-		    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
-    } else {
-	__xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,
-                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
-    }
+    xmlParserCtxtPtr pctxt = NULL;
+
+    if (ctxt != NULL)
+        pctxt = ctxt->ctxt;
+
+    xmlRaiseError(NULL, NULL, NULL, pctxt,
+	          NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,
+		  NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
 }
 
 /**
@@ -355,8 +355,6 @@ xmlNewTextWriterDoc(xmlDocPtr * doc, int compression)
     memset(&saxHandler, '\0', sizeof(saxHandler));
     xmlSAX2InitDefaultSAXHandler(&saxHandler, 1);
     saxHandler.startDocument = xmlTextWriterStartDocumentCallback;
-    saxHandler.startElement = xmlSAX2StartElement;
-    saxHandler.endElement = xmlSAX2EndElement;
 
     ctxt = xmlCreatePushParserCtxt(&saxHandler, NULL, NULL, 0, NULL);
     if (ctxt == NULL) {
@@ -424,8 +422,6 @@ xmlNewTextWriterTree(xmlDocPtr doc, xmlNodePtr node, int compression)
     memset(&saxHandler, '\0', sizeof(saxHandler));
     xmlSAX2InitDefaultSAXHandler(&saxHandler, 1);
     saxHandler.startDocument = xmlTextWriterStartDocumentCallback;
-    saxHandler.startElement = xmlSAX2StartElement;
-    saxHandler.endElement = xmlSAX2EndElement;
 
     ctxt = xmlCreatePushParserCtxt(&saxHandler, NULL, NULL, 0, NULL);
     if (ctxt == NULL) {
@@ -539,7 +535,7 @@ xmlTextWriterStartDocument(xmlTextWriterPtr writer, const char *version,
     writer->out->encoder = encoder;
     if (encoder != NULL) {
 	if (writer->out->conv == NULL) {
-	    writer->out->conv = xmlBufCreateSize(4000);
+	    writer->out->conv = xmlBufCreate(4000);
 	}
         xmlCharEncOutput(writer->out, 1);
         if ((writer->doc != NULL) && (writer->doc->encoding == NULL))
@@ -1488,10 +1484,9 @@ xmlTextWriterWriteString(xmlTextWriterPtr writer, const xmlChar * content)
             switch (p->state) {
                 case XML_TEXTWRITER_NAME:
                 case XML_TEXTWRITER_TEXT:
-#if 0
-                    buf = NULL;
-		    xmlOutputBufferWriteEscape(writer->out, content, NULL);
-#endif
+                    /*
+                     * TODO: Use xmlSerializeText
+                     */
                     buf = xmlEncodeSpecialChars(NULL, content);
                     break;
                 case XML_TEXTWRITER_ATTRIBUTE:
@@ -4443,7 +4438,8 @@ xmlTextWriterWriteDocCallback(void *context, const char *str, int len)
     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) context;
     int rc;
 
-    if ((rc = xmlParseChunk(ctxt, str, len, 0)) != 0) {
+    rc = xmlParseChunk(ctxt, str, len, 0);
+    if (rc != 0) {
         xmlWriterErrMsgInt(NULL, XML_ERR_INTERNAL_ERROR,
                         "xmlTextWriterWriteDocCallback : XML error %d !\n",
                         rc);
@@ -4467,7 +4463,8 @@ xmlTextWriterCloseDocCallback(void *context)
     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) context;
     int rc;
 
-    if ((rc = xmlParseChunk(ctxt, NULL, 0, 1)) != 0) {
+    rc = xmlParseChunk(ctxt, NULL, 0, 1);
+    if (rc != 0) {
         xmlWriterErrMsgInt(NULL, XML_ERR_INTERNAL_ERROR,
                         "xmlTextWriterCloseDocCallback : XML error %d !\n",
                         rc);
diff --git a/xpath.c b/xpath.c
index e9fddc90..e6aa90b5 100644
--- a/xpath.c
+++ b/xpath.c
@@ -131,7 +131,7 @@
  * any use of the macros IS_ASCII_CHARACTER and IS_ASCII_DIGIT)
  */
 
-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#if defined(LIBXML_XPATH_ENABLED)
 
 /************************************************************************
  *									*
@@ -212,10 +212,6 @@ xmlXPathIsInf(double val) {
 #endif
 }
 
-#endif /* SCHEMAS or XPATH */
-
-#ifdef LIBXML_XPATH_ENABLED
-
 /*
  * TODO: when compatibility allows remove all "fake node libxslt" strings
  *       the test should just be name[0] = ' '
@@ -230,13 +226,6 @@ static const xmlNs xmlXPathXMLNamespaceStruct = {
     NULL
 };
 static const xmlNs *const xmlXPathXMLNamespace = &xmlXPathXMLNamespaceStruct;
-#ifndef LIBXML_THREAD_ENABLED
-/*
- * Optimizer is disabled only when threaded apps are detected while
- * the library ain't compiled for thread safety.
- */
-static int xmlXPathDisableOptimizer = 0;
-#endif
 
 static void
 xmlXPathNodeSetClear(xmlNodeSetPtr set, int hasNsNodes);
@@ -707,12 +696,12 @@ xmlXPathErr(xmlXPathParserContextPtr ctxt, int code)
         data = xmlGenericErrorContext;
     }
 
-    res = __xmlRaiseError(schannel, channel, data, NULL, node, XML_FROM_XPATH,
-                          code + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
-                          XML_ERR_ERROR, NULL, 0,
-                          (const char *) ctxt->base, NULL, NULL,
-                          ctxt->cur - ctxt->base, 0,
-                          "%s", xmlXPathErrorMessages[code]);
+    res = xmlRaiseError(schannel, channel, data, NULL, node, XML_FROM_XPATH,
+                        code + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
+                        XML_ERR_ERROR, NULL, 0,
+                        (const char *) ctxt->base, NULL, NULL,
+                        ctxt->cur - ctxt->base, 0,
+                        "%s", xmlXPathErrorMessages[code]);
     if (res < 0)
         xmlXPathPErrMemory(ctxt);
 }
@@ -1019,32 +1008,6 @@ xmlXPathCompExprAdd(xmlXPathParserContextPtr ctxt, int ch1, int ch2,
     return(comp->nbStep++);
 }
 
-/**
- * xmlXPathCompSwap:
- * @comp:  the compiled expression
- * @op: operation index
- *
- * Swaps 2 operations in the compiled expression
- */
-static void
-xmlXPathCompSwap(xmlXPathStepOpPtr op) {
-    int tmp;
-
-#ifndef LIBXML_THREAD_ENABLED
-    /*
-     * Since this manipulates possibly shared variables, this is
-     * disabled if one detects that the library is used in a multithreaded
-     * application
-     */
-    if (xmlXPathDisableOptimizer)
-	return;
-#endif
-
-    tmp = op->ch1;
-    op->ch1 = op->ch2;
-    op->ch2 = tmp;
-}
-
 #define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)	\
     xmlXPathCompExprAdd(ctxt, (op1), (op2),			\
 	                (op), (val), (val2), (val3), (val4), (val5))
@@ -2134,11 +2097,6 @@ xmlXPathPopNodeSet (xmlXPathParserContextPtr ctxt) {
     }
     obj = valuePop(ctxt);
     ret = obj->nodesetval;
-#if 0
-    /* to fix memory leak of not clearing obj->user */
-    if (obj->boolval && obj->user != NULL)
-        xmlFreeNodeList((xmlNodePtr) obj->user);
-#endif
     obj->nodesetval = NULL;
     xmlXPathReleaseObject(ctxt->context, obj);
     return(ret);
@@ -2202,9 +2160,9 @@ xmlXPathPopExternal (xmlXPathParserContextPtr ctxt) {
 #define CUR_PTR ctxt->cur
 #define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
 
-#define COPY_BUF(l,b,i,v)                                              \
-    if (l == 1) b[i++] = v;                                            \
-    else i += xmlCopyChar(l,&b[i],v)
+#define COPY_BUF(b, i, v)						\
+    if (v < 0x80) b[i++] = v;						\
+    else i += xmlCopyCharMultiByte(&b[i],v)
 
 #define NEXTL(l)  ctxt->cur += l
 
@@ -4390,38 +4348,6 @@ xmlXPathObjectCopy(xmlXPathObjectPtr val) {
             }
 	    break;
 	case XPATH_XSLT_TREE:
-#if 0
-/*
-  Removed 11 July 2004 - the current handling of xslt tmpRVT nodes means that
-  this previous handling is no longer correct, and can cause some serious
-  problems (ref. bug 145547)
-*/
-	    if ((val->nodesetval != NULL) &&
-		(val->nodesetval->nodeTab != NULL)) {
-		xmlNodePtr cur, tmp;
-		xmlDocPtr top;
-
-		ret->boolval = 1;
-		top =  xmlNewDoc(NULL);
-		top->name = (char *)
-		    xmlStrdup(val->nodesetval->nodeTab[0]->name);
-		ret->user = top;
-		if (top != NULL) {
-		    top->doc = top;
-		    cur = val->nodesetval->nodeTab[0]->children;
-		    while (cur != NULL) {
-			tmp = xmlDocCopyNode(cur, top, 1);
-			xmlAddChild((xmlNodePtr) top, tmp);
-			cur = cur->next;
-		    }
-		}
-
-		ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);
-	    } else
-		ret->nodesetval = xmlXPathNodeSetCreate(NULL);
-	    /* Deallocate the copied tree value */
-	    break;
-#endif
 	case XPATH_NODESET:
 	    ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);
             if (ret->nodesetval == NULL) {
@@ -4556,7 +4482,6 @@ free_obj:
 	    xmlXPathFreeNodeSet(obj->nodesetval);
 	xmlFree(obj);
     }
-    return;
 }
 
 
@@ -6559,78 +6484,6 @@ xmlXPathNextChildElement(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
     return(NULL);
 }
 
-#if 0
-/**
- * xmlXPathNextDescendantOrSelfElemParent:
- * @ctxt:  the XPath Parser context
- * @cur:  the current node in the traversal
- *
- * Traversal function for the "descendant-or-self" axis.
- * Additionally it returns only nodes which can be parents of
- * element nodes.
- *
- *
- * Returns the next element following that axis
- */
-static xmlNodePtr
-xmlXPathNextDescendantOrSelfElemParent(xmlNodePtr cur,
-				       xmlNodePtr contextNode)
-{
-    if (cur == NULL) {
-	if (contextNode == NULL)
-	    return(NULL);
-	switch (contextNode->type) {
-	    case XML_ELEMENT_NODE:
-	    case XML_XINCLUDE_START:
-	    case XML_DOCUMENT_FRAG_NODE:
-	    case XML_DOCUMENT_NODE:
-	    case XML_HTML_DOCUMENT_NODE:
-		return(contextNode);
-	    default:
-		return(NULL);
-	}
-	return(NULL);
-    } else {
-	xmlNodePtr start = cur;
-
-	while (cur != NULL) {
-	    switch (cur->type) {
-		case XML_ELEMENT_NODE:
-		/* TODO: OK to have XInclude here? */
-		case XML_XINCLUDE_START:
-		case XML_DOCUMENT_FRAG_NODE:
-		    if (cur != start)
-			return(cur);
-		    if (cur->children != NULL) {
-			cur = cur->children;
-			continue;
-		    }
-		    break;
-		/* Not sure if we need those here. */
-		case XML_DOCUMENT_NODE:
-		case XML_HTML_DOCUMENT_NODE:
-		    if (cur != start)
-			return(cur);
-		    return(xmlDocGetRootElement((xmlDocPtr) cur));
-		default:
-		    break;
-	    }
-
-next_sibling:
-	    if ((cur == NULL) || (cur == contextNode))
-		return(NULL);
-	    if (cur->next != NULL) {
-		cur = cur->next;
-	    } else {
-		cur = cur->parent;
-		goto next_sibling;
-	    }
-	}
-    }
-    return(NULL);
-}
-#endif
-
 /**
  * xmlXPathNextDescendant:
  * @ctxt:  the XPath Parser context
@@ -7463,7 +7316,6 @@ xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {
         xmlXPathPErrMemory(ctxt);
     xmlFree(tokens);
     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, ret));
-    return;
 }
 
 /**
@@ -8184,7 +8036,7 @@ xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs) {
         }
     }
 
-    target = xmlBufCreateSize(64);
+    target = xmlBufCreate(50);
     if (target == NULL) {
         xmlXPathPErrMemory(ctxt);
         goto error;
@@ -8778,7 +8630,7 @@ xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {
 	    (c == '_') || ((qualified) && (c == ':')) ||
 	    (IS_COMBINING(c)) ||
 	    (IS_EXTENDER(c)))) {
-	COPY_BUF(l,buf,len,c);
+	COPY_BUF(buf,len,c);
 	NEXTL(l);
 	c = CUR_CHAR(l);
 	if (len >= XML_MAX_NAMELEN) {
@@ -8792,7 +8644,7 @@ xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {
             if (len > XML_MAX_NAME_LENGTH) {
                 XP_ERRORNULL(XPATH_EXPR_ERROR);
             }
-	    buffer = (xmlChar *) xmlMallocAtomic(max);
+	    buffer = xmlMalloc(max);
 	    if (buffer == NULL) {
                 xmlXPathPErrMemory(ctxt);
                 return(NULL);
@@ -8818,7 +8670,7 @@ xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {
 		    }
                     buffer = tmp;
 		}
-		COPY_BUF(l,buffer,len,c);
+		COPY_BUF(buffer,len,c);
 		NEXTL(l);
 		c = CUR_CHAR(l);
 	    }
@@ -9951,16 +9803,7 @@ xmlXPathCompNodeTest(xmlXPathParserContextPtr ctxt, xmlXPathTestVal *test,
 	 * only at evaluation time. The compilation is done
 	 * outside of any context.
 	 */
-#if 0
-	*prefix = xmlXPathNsLookup(ctxt->context, name);
-	if (name != NULL)
-	    xmlFree(name);
-	if (*prefix == NULL) {
-	    XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
-	}
-#else
 	*prefix = name;
-#endif
 
 	if (CUR == '*') {
 	    /*
@@ -11178,9 +11021,6 @@ xmlXPathCompOpEvalFirst(xmlXPathParserContextPtr ctxt,
             }
             valuePush(ctxt, arg1);
 	    xmlXPathReleaseObject(ctxt->context, arg2);
-            /* optimizer */
-	    if (total > cur)
-		xmlXPathCompSwap(op);
             total += cur;
             break;
         case XPATH_OP_ROOT:
@@ -11320,9 +11160,6 @@ xmlXPathCompOpEvalLast(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op,
             }
             valuePush(ctxt, arg1);
 	    xmlXPathReleaseObject(ctxt->context, arg2);
-            /* optimizer */
-	    if (total > cur)
-		xmlXPathCompSwap(op);
             total += cur;
             break;
         case XPATH_OP_ROOT:
@@ -11975,9 +11812,6 @@ xmlXPathRunStreamEval(xmlXPathParserContextPtr pctxt, xmlPatternPtr comp,
     from_root = xmlPatternFromRoot(comp);
     if (from_root < 0)
         return(-1);
-#if 0
-    printf("stream eval: depth %d from root %d\n", max_depth, from_root);
-#endif
 
     if (! toBool) {
 	if (resultSeq == NULL)
@@ -12608,9 +12442,6 @@ xmlXPathCompiledEvalInternal(xmlXPathCompExprPtr comp,
 {
     xmlXPathParserContextPtr pctxt;
     xmlXPathObjectPtr resObj = NULL;
-#ifndef LIBXML_THREAD_ENABLED
-    static int reentance = 0;
-#endif
     int res;
 
     if (comp == NULL)
@@ -12619,12 +12450,6 @@ xmlXPathCompiledEvalInternal(xmlXPathCompExprPtr comp,
 
     xmlResetError(&ctxt->lastError);
 
-#ifndef LIBXML_THREAD_ENABLED
-    reentance++;
-    if (reentance > 1)
-	xmlXPathDisableOptimizer = 1;
-#endif
-
     pctxt = xmlXPathCompParserContext(comp, ctxt);
     if (pctxt == NULL)
         return(-1);
@@ -12644,9 +12469,6 @@ xmlXPathCompiledEvalInternal(xmlXPathCompExprPtr comp,
 
     pctxt->comp = NULL;
     xmlXPathFreeParserContext(pctxt);
-#ifndef LIBXML_THREAD_ENABLED
-    reentance--;
-#endif
 
     return(res);
 }
@@ -12911,7 +12733,7 @@ xmlXPathEscapeUriFunction(xmlXPathParserContextPtr ctxt, int nargs) {
     CAST_TO_STRING;
     str = valuePop(ctxt);
 
-    target = xmlBufCreateSize(64);
+    target = xmlBufCreate(50);
 
     escape[0] = '%';
     escape[3] = 0;
diff --git a/xpointer.c b/xpointer.c
index e643ab6b..6c995b77 100644
--- a/xpointer.c
+++ b/xpointer.c
@@ -99,11 +99,11 @@ xmlXPtrErr(xmlXPathParserContextPtr ctxt, int code,
         node = ctxt->context->debugNode;
     }
 
-    res = __xmlRaiseError(serror, NULL, data, NULL, node,
-                          XML_FROM_XPOINTER, code, XML_ERR_ERROR, NULL, 0,
-                          (const char *) extra, (const char *) ctxt->base,
-                          NULL, ctxt->cur - ctxt->base, 0,
-                          msg, extra);
+    res = xmlRaiseError(serror, NULL, data, NULL, node,
+                        XML_FROM_XPOINTER, code, XML_ERR_ERROR, NULL, 0,
+                        (const char *) extra, (const char *) ctxt->base,
+                        NULL, ctxt->cur - ctxt->base, 0,
+                        msg, extra);
     if (res < 0)
         xmlXPathPErrMemory(ctxt);
 }
@@ -267,7 +267,7 @@ xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 
     len = xmlStrlen(ctxt->cur);
     len++;
-    buffer = (xmlChar *) xmlMallocAtomic(len);
+    buffer = xmlMalloc(len);
     if (buffer == NULL) {
         xmlXPathPErrMemory(ctxt);
         xmlFree(name);
diff --git a/xzlib.c b/xzlib.c
index 3d607ad5..f3b05393 100644
--- a/xzlib.c
+++ b/xzlib.c
@@ -14,17 +14,15 @@
 #include <stdlib.h>
 #include <errno.h>
 
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+  #include <io.h>
+#else
+  #include <unistd.h>
 #endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#elif defined (_WIN32)
-#include <io.h>
-#endif
+
 #ifdef LIBXML_ZLIB_ENABLED
 #include <zlib.h>
 #endif
@@ -101,8 +99,8 @@ xz_error(xz_statep state, int err, const char *msg)
     }
 
     /* construct error message with path */
-    if ((state->msg =
-         xmlMalloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {
+    state->msg = xmlMalloc(strlen(state->path) + strlen(msg) + 3);
+    if (state->msg == NULL) {
         state->err = LZMA_MEM_ERROR;
         state->msg = (char *) "out of memory";
         return;
@@ -110,7 +108,6 @@ xz_error(xz_statep state, int err, const char *msg)
     strcpy(state->msg, state->path);
     strcat(state->msg, ": ");
     strcat(state->msg, msg);
-    return;
 }
 
 static void
```

