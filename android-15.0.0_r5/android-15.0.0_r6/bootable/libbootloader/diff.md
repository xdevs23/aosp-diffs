```diff
diff --git a/gbl/BUILD b/gbl/BUILD
index 96485a3..341da2e 100644
--- a/gbl/BUILD
+++ b/gbl/BUILD
@@ -20,13 +20,16 @@ readme_test(
     # Note: can't read files in subpackages, not sure how to add a dependency on all,
     # globbed, subpackages and all the rust_lib targets they contain.
     deps = [
-        "@gbl//efi:main",
+        "@gbl//efi:app",
+        "@gbl//efi:libgbl_efi",
         "@gbl//libavb:sysdeps",
         "@gbl//libboot",
         "@gbl//libbootconfig",
         "@gbl//libbootimg",
         "@gbl//libc",
         "@gbl//libefi",
+        "@gbl//libefi_types",
+        "@gbl//liberror",
         "@gbl//libfastboot",
         "@gbl//libfdt",
         "@gbl//libgbl",
diff --git a/gbl/OWNERS b/gbl/OWNERS
index af218ad..f0899b9 100644
--- a/gbl/OWNERS
+++ b/gbl/OWNERS
@@ -1,3 +1,4 @@
+dimorinny@google.com
 dovs@google.com
 dpursell@google.com
 rammuthiah@google.com
diff --git a/gbl/README.md b/gbl/README.md
index d0b33c4..c20f0bf 100644
--- a/gbl/README.md
+++ b/gbl/README.md
@@ -4,11 +4,24 @@ This directory hosts the Generic Bootloader Library project. A Bazel
 workspace is setup for building the library as well as an EFI executable that
 can be loaded directly from the firmware.
 
-## Build
+## Get source tree and build
+
+To succesfully get and build the tree your machine must have the following dependencies installed:
+
+```
+# repo to work with android repositories (https://source.android.com/docs/setup/reference/repo)
+# bazel-bootstrap to build (https://bazel.build/)
+sudo apt install repo bazel-bootstrap
+```
 
 The GBL project are intended to be built from the
 [Android UEFI Manifest](https://android.googlesource.com/kernel/manifest/+/refs/heads/uefi-gbl-mainline/default.xml)
-checkout.
+checkout:
+
+```
+repo init -u https://android.googlesource.com/kernel/manifest -b uefi-gbl-mainline
+repo sync -j16
+```
 
 To build the EFI application:
 
@@ -33,10 +46,10 @@ If you have a main AOSP checkout and is setup to run
 run the EFI image directly with:
 
 ```
-launch_cvd --android_efi_loader=<path to the EFI image> ...
+cvd start --android_efi_loader=<path to the EFI image> ...
 ```
 
-The above uses the same setting as a normal `launch_cvd` run, except that
+The above uses the same setting as a normal `cvd start` run, except that
 insted of booting Android directly, the emulator first hands off to the EFI
 application, which will take over booting android.
 
diff --git a/gbl/android_external_rust_crates/BUILD b/gbl/android_external_rust_crates/BUILD
deleted file mode 100644
index 12e8070..0000000
--- a/gbl/android_external_rust_crates/BUILD
+++ /dev/null
@@ -1,17 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(
-    default_visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.bitflags.bazel b/gbl/android_external_rust_crates/BUILD.bitflags.bazel
deleted file mode 100644
index f82b0df..0000000
--- a/gbl/android_external_rust_crates/BUILD.bitflags.bazel
+++ /dev/null
@@ -1,22 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "bitflags",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.byteorder.bazel b/gbl/android_external_rust_crates/BUILD.byteorder.bazel
deleted file mode 100644
index 216486d..0000000
--- a/gbl/android_external_rust_crates/BUILD.byteorder.bazel
+++ /dev/null
@@ -1,22 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "byteorder",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.cfg-if.bazel b/gbl/android_external_rust_crates/BUILD.cfg-if.bazel
deleted file mode 100644
index b199aa2..0000000
--- a/gbl/android_external_rust_crates/BUILD.cfg-if.bazel
+++ /dev/null
@@ -1,22 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "cfg-if",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.crc32fast.bazel b/gbl/android_external_rust_crates/BUILD.crc32fast.bazel
deleted file mode 100644
index fd586e8..0000000
--- a/gbl/android_external_rust_crates/BUILD.crc32fast.bazel
+++ /dev/null
@@ -1,23 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "crc32fast",
-    srcs = glob(["**/*.rs"]),
-    edition = "2015",
-    visibility = ["//visibility:public"],
-    deps = ["@cfg-if"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.hex.bazel b/gbl/android_external_rust_crates/BUILD.hex.bazel
deleted file mode 100644
index ea92815..0000000
--- a/gbl/android_external_rust_crates/BUILD.hex.bazel
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "hex",
-    srcs = glob(["**/*.rs"]),
-    crate_features = [
-        "alloc",
-        "default",
-        "std",
-    ],
-    edition = "2021",
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.proc-macro2.bazel b/gbl/android_external_rust_crates/BUILD.proc-macro2.bazel
deleted file mode 100644
index 7fa1e9a..0000000
--- a/gbl/android_external_rust_crates/BUILD.proc-macro2.bazel
+++ /dev/null
@@ -1,42 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//cargo:defs.bzl", "cargo_build_script")
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-CRATE_FEATURES = [
-    "default",
-    "proc-macro",
-]
-
-rust_library(
-    name = "proc-macro2",
-    srcs = glob(["**/*.rs"]),
-    crate_features = CRATE_FEATURES,
-    edition = "2021",
-    visibility = ["//visibility:public"],
-    deps = [
-        ":proc-macro2_build_script",
-        "@unicode-ident",
-    ],
-)
-
-cargo_build_script(
-    name = "proc-macro2_build_script",
-    srcs = glob(["**/*.rs"]),
-    crate_features = CRATE_FEATURES,
-    crate_root = "build.rs",
-    edition = "2021",
-    visibility = ["//visibility:private"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.quote.bazel b/gbl/android_external_rust_crates/BUILD.quote.bazel
deleted file mode 100644
index 868510f..0000000
--- a/gbl/android_external_rust_crates/BUILD.quote.bazel
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "quote",
-    srcs = glob(["**/*.rs"]),
-    crate_features = [
-        "default",
-        "proc-macro",
-    ],
-    edition = "2021",
-    visibility = ["//visibility:public"],
-    deps = ["@proc-macro2"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.unicode-ident.bazel b/gbl/android_external_rust_crates/BUILD.unicode-ident.bazel
deleted file mode 100644
index f6bd546..0000000
--- a/gbl/android_external_rust_crates/BUILD.unicode-ident.bazel
+++ /dev/null
@@ -1,22 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "unicode-ident",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    visibility = ["//visibility:public"],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.zerocopy-derive.bazel b/gbl/android_external_rust_crates/BUILD.zerocopy-derive.bazel
deleted file mode 100644
index 23b5324..0000000
--- a/gbl/android_external_rust_crates/BUILD.zerocopy-derive.bazel
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_proc_macro")
-
-rust_proc_macro(
-    name = "zerocopy-derive",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    visibility = ["//visibility:public"],
-    deps = [
-        "@proc-macro2",
-        "@quote",
-        "@syn",
-    ],
-)
diff --git a/gbl/android_external_rust_crates/BUILD.zerocopy.bazel b/gbl/android_external_rust_crates/BUILD.zerocopy.bazel
deleted file mode 100644
index bed2a8d..0000000
--- a/gbl/android_external_rust_crates/BUILD.zerocopy.bazel
+++ /dev/null
@@ -1,24 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-rust_library(
-    name = "zerocopy",
-    srcs = glob(["**/*.rs"]),
-    edition = "2021",
-    proc_macro_deps = ["@zerocopy-derive"],
-    visibility = ["//visibility:public"],
-    deps = ["@byteorder"],
-)
diff --git a/gbl/bazel.MODULE.bazel b/gbl/bazel.MODULE.bazel
index 44a39d7..4231fd0 100644
--- a/gbl/bazel.MODULE.bazel
+++ b/gbl/bazel.MODULE.bazel
@@ -14,28 +14,17 @@
 
 """Custom MODULE.bazel definition for GBL.
 
-Ideally, MODULE.bazel from Kleaf should be used instead because Kleaf is the
-root module. However, rules_rust_tinyjson and other crates needs to be resolved
-properly so it can be vendored.
-
-Do not fork this file for other projects!
+This is a stripped down version of Kleaf's MODULE.bazel because this repository does not build
+kernel.
 """
 
-# TODO(b/328465178): Use MODULE.bazel from Kleaf instead.
-
 module(
     name = "uefi-gbl",
     version = "0.0.0",
 )
 
-kernel_toolchain_ext = use_extension("//build/kernel/kleaf:kernel_toolchain_ext.bzl", "kernel_toolchain_ext")
-use_repo(kernel_toolchain_ext, "kernel_toolchain_info")
-use_repo(kernel_toolchain_ext, "kleaf_clang_toolchain")
-use_repo(kernel_toolchain_ext, "kleaf_host_tools")
-
 register_toolchains(
-    "@kleaf_clang_toolchain//:all",
-    "//build/kernel:hermetic_tools_toolchain",
+    "//prebuilts/build-tools:py_toolchain_musl",
     "//prebuilts/build-tools:py_toolchain",
 )
 
@@ -48,12 +37,20 @@ bazel_dep(
 bazel_dep(
     name = "rules_cc",
 )
+bazel_dep(
+    name = "rules_pkg",
+)
 
 local_path_override(
     module_name = "apple_support",
     path = "external/bazelbuild-apple_support",
 )
 
+local_path_override(
+    module_name = "bazel_features",
+    path = "external/bazel-contrib-bazel_features",
+)
+
 local_path_override(
     module_name = "bazel_skylib",
     path = "external/bazel-skylib",
@@ -79,6 +76,11 @@ local_path_override(
     path = "external/bazelbuild-rules_license",
 )
 
+local_path_override(
+    module_name = "rules_pkg",
+    path = "external/bazelbuild-rules_pkg",
+)
+
 local_path_override(
     module_name = "rules_python",
     path = "external/bazelbuild-rules_python",
diff --git a/gbl/build.config.constants b/gbl/build.config.constants
deleted file mode 100644
index 0a9f1f5..0000000
--- a/gbl/build.config.constants
+++ /dev/null
@@ -1,2 +0,0 @@
-BRANCH=u-boot-mainline
-CLANG_VERSION=r510928
diff --git a/gbl/docs/EFI_ANDROID_BOOT_PROTOCOL.md b/gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md
similarity index 70%
rename from gbl/docs/EFI_ANDROID_BOOT_PROTOCOL.md
rename to gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md
index acdf90e..dfa2efa 100644
--- a/gbl/docs/EFI_ANDROID_BOOT_PROTOCOL.md
+++ b/gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md
@@ -1,9 +1,7 @@
-# EFI Android Boot Protocol
+# GBL EFI Fastboot USB Protocol
 
-This document describes the Android Boot protocol. The protocol defines
-interfaces that can be used by EFI applications to implement an Android
-bootloader in compliance with the Android Verified Boot(AVB) requirement and
-tooling interfaces such as the Fastboot over USB protocol.
+This document describes the GBL Fastboot USB protocol. The protocol defines
+interfaces that can be used by EFI applications to implement Fastboot over USB.
 
 |||
 | ----------- | ----------- |
@@ -11,7 +9,7 @@ tooling interfaces such as the Fastboot over USB protocol.
 | **Created** | 2024-3-21 |
 
 
-## EFI_ANDROID_BOOT_PROTOCOL
+## GBL_EFI_FASTBOOT_USB_PROTOCOL
 
 ### Summary
 
@@ -25,7 +23,7 @@ starting/stopping a Fastboot USB interface and sending/receiving USB packets.
 
 ```c
 // {6281a893-ac23-4ca7-b281-340ef8168955}
-#define EFI_ANDROID_BOOT_PROTOCOL_GUID               \
+#define GBL_EFI_FASTBOOT_USB_PROTOCOL_GUID           \
   {                                                  \
     0x6281a893, 0xac23, 0x4ca7, {                    \
       0xb2, 0x81, 0x34, 0x0e, 0xf8, 0x16, 0x89, 0x55 \
@@ -36,51 +34,51 @@ starting/stopping a Fastboot USB interface and sending/receiving USB packets.
 ### Revision Number
 
 ```c
-#define EFI_ANDROID_BOOT_PROTOCOL_REVISION 0x00000000
+#define GBL_EFI_FASTBOOT_USB_PROTOCOL_REVISION 0x00000000
 ```
 
 ### Protocol Interface Structure
 
 ```c
-typedef struct _EFI_ANDROID_BOOT_PROTOCOL {
-  UINT64                                          Revision;
-  EFI_ANDROID_BOOT_FASTBOOT_USB_INTERFACE_START   FastbootUsbInterfaceStart;
-  EFI_ANDROID_BOOT_FASTBOOT_USB_INTERFACE_STOP    FastbootUsbInterfaceStop;
-  EFI_ANDROID_BOOT_FASTBOOT_USB_RECEIVE           FastbootUsbReceive;
-  EFI_ANDROID_BOOT_FASTBOOT_USB_SEND              FastbootUsbSend;
-  EFI_EVENT                                       WaitForSendCompletion;
-} EFI_ANDROID_BOOT_PROTOCOL;
+typedef struct _GBL_EFI_FASTBOOT_USB_PROTOCOL {
+  UINT64                                              Revision;
+  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_START   FastbootUsbInterfaceStart;
+  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_STOP    FastbootUsbInterfaceStop;
+  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_RECEIVE           FastbootUsbReceive;
+  GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_SEND              FastbootUsbSend;
+  EFI_EVENT                                           WaitForSendCompletion;
+} GBL_EFI_FASTBOOT_USB_PROTOCOL;
 ```
 
 ### Parameters
 
 **Revision**  
-The revision to which the EFI_ANDROID_BOOT_PROTOCOL adheres. All future revisions must be
-backwards compatible. If a future version is not backwards compatible, a
-different GUID must be used.
+The revision to which the GBL_EFI_FASTBOOT_USB_PROTOCOL adheres. All future
+revisions must be backwards compatible. If a future version is not backwards
+compatible, a different GUID must be used.
 
 **FastbootUsbInterfaceStart**  
 Starts a USB interface for Fastboot traffic. See
-[`EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbInterfaceStart()`](#efi_android_boot_protocolfastbootusbinterfacestart).
+[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStart()`](#gbl_efi_fastboot_usb_protocolfastbootusbinterfacestart).
 
 **FastbootUsbInterfaceStop**  
 Stops the USB interface started by `FastbootUsbInterfaceStart()`. See
-[`EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbInterfaceStop()`](#efi_android_boot_protocolfastbootusbinterfacestop).
+[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStop()`](#gbl_efi_fastboot_usb_protocolfastbootusbinterfacestop).
 
 **FastbootUsbReceive**  
 Polls and receives the next USB packet if available. See
-[`EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbReceive()`](#efi_android_boot_protocolfastbootusbreceive).
+[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()`](#gbl_efi_fastboot_usb_protocolfastbootusbreceive).
 
 **FastbootUsbSend**  
 Sends a USB packet. See
-[`EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbSend()`](#efi_android_boot_protocolfastbootusbsend).
+[`GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()`](#gbl_efi_fastboot_usb_protocolfastbootusbsend).
 
 **WaitForSendCompletion**  
 Event used with `EFI_BOOT_SERVICES.WaitForEvent()` to wait for the previous
 packet sent by `FastbootUsbSend()` to complete.
 
 
-## EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbInterfaceStart()
+## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStart()
 
 ### Summary
 
@@ -91,16 +89,17 @@ Starts a USB interface for Fastboot.
 ```c
 typedef
 EFI_STATUS
-(EFIAPI * EFI_ANDROID_BOOT_FASTBOOT_USB_INTERFACE_START)(
-  IN EFI_ANDROID_BOOT_PROTOCOL  *This,
-  OUT UINTN                     *MaxPacketSize,
+(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_START)(
+  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
+  OUT UINTN                         *MaxPacketSize,
   );
 ```
 
 ### Parameters
 
 *This*  
-A pointer to the [`EFI_ANDROID_BOOT_PROTOCOL`](#efi_android_boot_protocol) instance.
+A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
+instance.
 
 *MaxPacketSize*  
 On exit, set to the maximum packet size in bytes allowed by the USB interface.
@@ -146,7 +145,7 @@ this protocol and Android Fastboot tool may support this usecase.
 | EFI_UNSUPPORTED | USB is not supported by the platform |
 | EFI_DEVICE_ERROR | The physical device reported an error. |
 
-## EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbInterfaceStop()
+## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbInterfaceStop()
 
 ### Summary
 
@@ -157,15 +156,15 @@ Stops the USB interface started by `FastbootUsbInterfaceStart()`.
 ```c
 typedef
 EFI_STATUS
-(EFIAPI * EFI_ANDROID_BOOT_FASTBOOT_USB_INTERFACE_STOP)(
-  IN EFI_ANDROID_BOOT_PROTOCOL  *This
+(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_INTERFACE_STOP)(
+  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This
   );
 ```
 
 ### Parameters
 
 *This*  
-A pointer to the [`EFI_ANDROID_BOOT_PROTOCOL`](#efi_android_boot_protocol)
+A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
 instance.
 
 ### Description
@@ -184,7 +183,7 @@ device from the host.
 | EFI_NOT_STARTED | The USB interface is not started.|
 | EFI_DEVICE_ERROR | The physical device reported an error.|
 
-## EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbReceive()
+## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()
 
 ### Summary
 
@@ -196,17 +195,17 @@ Receives a USB packet from the interface started by
 ```c
 typedef
 EFI_STATUS
-(EFIAPI * EFI_ANDROID_BOOT_FASTBOOT_USB_RECEIVE)(
-  IN EFI_ANDROID_BOOT_PROTOCOL  *This,
-  IN OUT UINTN                  *BufferSize,
-  OUT VOID                      *Buffer,
+(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_RECEIVE)(
+  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
+  IN OUT UINTN                      *BufferSize,
+  OUT VOID                          *Buffer,
   );
 ```
 
 ### Parameters
 
 *This*  
-A pointer to the [`EFI_ANDROID_BOOT_PROTOCOL`](#efi_android_boot_protocol)
+A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
 instance.
 
 *BufferSize*  
@@ -232,7 +231,7 @@ packet from the Fastboot USB interface into the provided buffer.
 | EFI_BUFFER_TOO_SMALL | Buffer is too small for the next packet. `BufferSize` should be updated to the required size in this case. |
 | EFI_DEVICE_ERROR | The physical device reported an error.|
 
-## EFI_ANDROID_BOOT_PROTOCOL.FastbootUsbSend()
+## GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()
 
 ### Summary
 
@@ -244,17 +243,17 @@ Sends a USB packet from the USB interface started by
 ```c
 typedef
 EFI_STATUS
-(EFIAPI * EFI_ANDROID_BOOT_FASTBOOT_USB_SEND)(
-  IN EFI_ANDROID_BOOT_PROTOCOL  *This,
-  IN OUT UINTN                  *BufferSize,
-  IN CONST VOID                 *Buffer,
+(EFIAPI * GBL_EFI_FASTBOOT_USB_FASTBOOT_USB_SEND)(
+  IN GBL_EFI_FASTBOOT_USB_PROTOCOL  *This,
+  IN OUT UINTN                      *BufferSize,
+  IN CONST VOID                     *Buffer,
   );
 ```
 
 ### Parameters
 
 *This*  
-A pointer to the [`EFI_ANDROID_BOOT_PROTOCOL`](#efi_android_boot_protocol)
+A pointer to the [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](#gbl_efi_fastboot_usb_protocol)
 instance.
 
 *BufferSize*  
diff --git a/gbl/docs/efi_protocols.md b/gbl/docs/efi_protocols.md
index 32d09f3..e73b648 100644
--- a/gbl/docs/efi_protocols.md
+++ b/gbl/docs/efi_protocols.md
@@ -1,65 +1,193 @@
-The EFI application of GBL requires certain EFI protocols in order to boot,
-and can require other protocols for certain targets or to enable optional features.
+# GBL UEFI Protocols
 
-### Required Protocols
+This document lists every UEFI protocol that GBL may potentially use, and
+describes the use case with any requirements.
 
-#### BlockIoProtocol
+## Upstream Protocols
 
-The BlockIo protocol is required for loading system images from disk.
-If a target supports Fastboot mode, it is also used for writing images to disk.
+These protocols are taken from an external source, typically the UEFI spec.
 
-#### SimpleTextOutputProtocol
+### BlockIoProtocol
 
-The SimpleTextOutput protocol is used for logging
-and the text-based interface of Fastboot.
-On systems where there is no output functionality,
-this can be implemented as a series of no-op functions.
+* [`EFI_BLOCK_IO_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#efi-block-io-protocol)
+* required
 
-### Conditionally Required Protocols
+Used to read the GPT, load images from disk, and write data back to disk in
+e.g. in fastboot.
 
-#### RiscvBootProtocol
+This is required even if the Block I/O 2 Protocol is provided, as some use cases
+might want to use this simpler API.
 
-Determines the boot hart ID which is then passed to the kernel.
-Only required for RISC-V targets.
+### BlockIo2Protocol
 
-### Optional Protocols
+* [`EFI_BLOCK_IO2_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/13_Protocols_Media_Access.html#block-i-o-2-protocol)
+* optional: enables performance optimizations
 
-#### AndroidBootProtocol
+If provided, GBL may use this protocol instead of the Block I/O Protocol as a
+performance optimization; for example during fastboot flashing it may flash to
+disk while concurrently receiving the next image over USB.
 
-This is a custom protocol intended to provide
-specific functionality needed to boot Android.
-A full description is available [here](./EFI_ANDROID_BOOT_PROTOCOL.md).
+### DevicePathProtocol
 
-#### DevicePathProtocol
+* [`EFI_DEVICE_PATH_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html#efi-device-path-protocol)
+* optional: enables logging the image path on GBL start
 
-The DevicePath protocol is a variable length binary structure
-made of variable length Device Path nodes.
-A handle representing a hardware resource is mapped
-to the protocol and provides specific data about that resource.
+Used for logging the GBL image path to the console on load. This can be useful
+as a "Hello world" proof-of-concept that GBL is running and can interact with
+the UEFI protocols.
 
-If all three of DevicePath protocol, DevicePathToText protocol,
-and LoadedImage protocol are present, the GBL image path is logged
-to the console on load.
+This logging requires all three of:
+* Device Path Protocol
+* Device Path to Text Protocol
+* Loaded Image Protocol
 
-This is a useful proof of concept for development to demonstrate
-that GBL is running and can interact with the UEFI environment.
+### DevicePathToTextProtocol
 
-#### DevicePathToTextProtocol
+* [`EFI_DEVICE_PATH_TO_TEXT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html#device-path-to-text-protocol)
+* optional: enables logging the image path on GBL start
 
-The DevicePathToText protocol converts device paths and nodes to text.
+Used for logging the GBL image path to the console on load. This can be useful
+as a "Hello world" proof-of-concept that GBL is running and can interact with
+the UEFI protocols.
 
-#### LoadedImageProtocol
+This logging requires all three of:
+* Device Path Protocol
+* Device Path to Text Protocol
+* Loaded Image Protocol
 
-The LoadedImage protocol can be used on the handle of an image to provide
-information about the image, including its device handle and device path.
+### LoadedImageProtocol
 
-#### SimpleNetworkProtocol
+* [`EFI_LOADED_IMAGE_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/09_Protocols_EFI_Loaded_Image.html#efi-loaded-image-protocol)
+* optional: enables logging the image path on GBL start
 
-If present, the SimpleNetwork protocol is used to provide Fastboot over TCP.
-No other EFI protocols are required: GBL wraps SimpleNetwork to provide TCP.
+Used for logging the GBL image path to the console on load. This can be useful
+as a "Hello world" proof-of-concept that GBL is running and can interact with
+the UEFI protocols.
 
-Note: for security reasons, Fastboot over TCP is only available in dev builds.
+This logging requires all three of:
+* Device Path Protocol
+* Device Path to Text Protocol
+* Loaded Image Protocol
 
-#### SimpleTextInputProtocol
+### Memory Allocation Services
 
-TODO: remove this protocol
+* [Memory allocation services](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-allocation-services)
+* all required
+
+Used by libavb for image verification.
+
+Dynamic memory allocation can be minimized, but not completely eliminated, by
+providing preallocated image buffers via the GBL Image Loading Protocol.
+
+### RiscvBootProtocol
+
+* [`RISCV_EFI_BOOT_PROTOCOL`](https://github.com/riscv-non-isa/riscv-uefi/blob/main/boot_protocol.adoc)
+* required for RISC-V targets
+
+Used to query the boot hart ID which is required to pass to the kernel.
+
+### SimpleNetworkProtocol
+
+* [`EFI_SIMPLE_NETWORK_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/24_Network_Protocols_SNP_PXE_BIS.html#simple-network-protocol)
+* optional: enables fastboot over TCP
+
+Used to provide fastboot over TCP. This can be enabled by itself, or in
+addition to fastboot over USB.
+
+Currently if this protocol is available GBL will always start fastboot over TCP,
+but in the future this functionality will be restricted to dev builds only.
+Production devices should not expose fastboot over TCP.
+
+GBL only uses the Simple Network Protocol, and will not use higher-level
+protocols such as the TCP4/6 Protocols even if they are available.
+
+### SimpleTextInputProtocol
+
+* [`EFI_SIMPLE_TEXT_INPUT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/12_Protocols_Console_Support.html#simple-text-input-protocol)
+* optional: enables the 'f' key to enter fastboot
+
+This is currently used to look for the 'f' key on the serial line during boot,
+which will trigger GBL to enter fastboot mode. If not provided, GBL will skip
+this check.
+
+We plan to remove this and instead use a more general protocol to allow devices
+to specify their own custom fastboot triggers.
+
+### SimpleTextOutputProtocol
+
+* [`EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/12_Protocols_Console_Support.html#simple-text-output-protocol)
+* required, but can be no-op
+
+Used for logging and debugging. Implementations must provide this protocol, but
+the functions may be no-ops.
+
+## GBL Custom Protocols
+
+These protocols are defined by GBL to provide specific functionality that is
+not available elsewhere.
+
+None of these custom protocols are required, with the intention that dev boards
+that support a typical set of UEFI protocols should be able to use GBL without
+any firmware modifications and still get some basic booting functionality.
+
+However, without these protocols GBL will be missing key features such as
+USB fastboot and verified boot, so production targets and more full-featured dev
+boards will need to implement them.
+
+### GblFastbootProtocol
+
+* [`GBL_EFI_FASTBOOT_PROTOCOL`](./gbl_efi_fastboot_protocol.md)
+* optional: enables custom fastboot functionality.
+
+Used to provide an interface for
+* Custom variables
+* OEM commands
+* Device lock/unlock controls
+* Lock-contingent partition permission information
+* User data erasure
+
+### GblFastbootUsbProtocol
+
+* [`GBL_EFI_FASTBOOT_USB_PROTOCOL`](./GBL_EFI_FASTBOOT_USB_PROTOCOL.md)
+* optional: enables fastboot over USB
+
+Used to provide fastboot over USB. This can be enabled by itself, or in
+addition to fastboot over TCP.
+
+### GblOsConfigurationProtocol
+
+* [`GBL_EFI_OS_CONFIGURATION_PROTOCOL`](./gbl_os_configuration_protocol.md)
+* optional: enables runtime fixups of OS data
+
+Used for runtime fixups of data provided to the OS such as command line and
+device tree. If not provided, the data in the OS images loaded from disk will
+be used without modification.
+
+### GblSlotProtocol
+
+* TODO(b/359946695): link documentation
+* optional: enables A/B slotted booting
+
+Used to read and write A/B slot metadata. If not provided, GBL will
+load from either the `_a` slot or a slotless boot partition.
+
+All components that interact with A/B slot metadata must use the same format.
+Typically these components are:
+
+1. The UEFI firmware selecting which GBL slot to load
+2. GBL selecting which OS slot to load
+3. The OS update engine updating the metadata when a new version is downloaded
+
+This protocol allows the device to implement its own A/B metadata format while
+still allowing GBL to implement the boot flow logic.
+
+### GblImageLoadingProtocol
+
+* TODO(b/359946775): link documentation
+* optional: enables loading images to predefined memory locations
+
+Used to provide buffers to load the images for verification and boot process.
+
+In addition this protocol provides a list of additional custom partitions to be
+verified before booting, for boards that want to verify data in addition to the
+standard boot partitions.
diff --git a/gbl/docs/gbl_efi_ab_slot_protocol.md b/gbl/docs/gbl_efi_ab_slot_protocol.md
new file mode 100644
index 0000000..36cfdc6
--- /dev/null
+++ b/gbl/docs/gbl_efi_ab_slot_protocol.md
@@ -0,0 +1,717 @@
+# GBL EFI AB Slot Protocol
+
+This document describes the GBL AB Slot protocol.
+The protocol defines interfaces that can be used by EFI applications
+to query and manipulate boot slots.
+
+| **Status**  | Work in progress |
+|:------------|-----------------:|
+| **Created** |        2024-9-17 |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL`
+
+### Summary
+
+This protocol provides interfaces for platform specific boot slot operations,
+such as determining the number of slots and the current target slot,
+changing the current target boot slot, marking boot attempts, and more.
+
+### Boot Slot Coherency Warning
+
+**Warning:** a boot slot may contain multiple artifacts, e.g. firmware images,
+kernel images, RAM disks, partitions, and so forth. It is **NOT** guaranteed
+that arbitrary artifacts from different slots interoperate correctly.
+For example, the bootloader in slot A may pass command line arguments that are
+invalid for the kernel in slot B. The **ONLY** safe way to boot a slot
+different from the active boot slot is to
+
+1. Change the slot by calling
+[`SetActiveSlot()`](#gbl_efi_ab_slot_protocolsetactiveslot).
+2. Reboot the device.
+   1. Optionally enter fastboot mode.
+3. Continue the boot process.
+
+It is the EFI application's responsibility to track whether `SetActiveSlot()`
+has been called and whether the current target slot and the active slot differ.
+
+### GUID
+
+```c
+// {9a7a7db4-614b-4a08-3df9-006f49b0d80c}
+#define GBL_EFI_AB_SLOT_PROTOCOL_GUID                \
+  {                                                  \
+    0x9a7a7db4, 0x614b, 0x4a08, {                    \
+      0x3d, 0xf9, 0x00, 0x6f, 0x49, 0xb0, 0xd8, 0x0c \
+    }                                                \
+  }
+```
+
+### Protocol Version
+```c
+#define GBL_EFI_AB_SLOT_PROTOCOL_VERSION 0x00010000
+```
+
+### Protocol Interface Structure
+
+```c
+typedef struct GBL_EFI_AB_SLOT_PROTOCOL {
+  // Currently must contain 0x00010000
+  UINT32                              Version;
+  GBL_EFI_AB_SLOT_LOAD_BOOT_DATA      LoadBootData;
+  GBL_EFI_AB_SLOT_GET_SLOT_INFO       GetSlotInfo;
+  GBL_EFI_AB_SLOT_GET_CURRENT_SLOT    GetCurrentSlot;
+  GBL_EFI_AB_SLOT_SET_ACTIVE_SLOT     SetActiveSlot;
+  GBL_EFI_AB_SLOT_SET_SLOT_UNBOOTABLE SetSlotUnbootable;
+  GBL_EFI_AB_SLOT_MARK_BOOT_ATTEMPT   MarkBootAttempt;
+  GBL_EFI_AB_SLOT_REINITIALIZE        Reinitialize;
+  GBL_EFI_AB_SLOT_GET_BOOT_REASON     GetBootReason;
+  GBL_EFI_AB_SLOT_SET_BOOT_REASON     SetBootReason;
+  GBL_EFI_AB_SLOT_FLUSH               Flush;
+} GBL_EFI_AB_SLOT_PROTOCOL;
+```
+
+### Parameters
+
+**Version**
+
+The revision to which the `GBL_EFI_AB_SLOT_PROTOCOL` adheres.
+All future version must be backwards compatible.
+If a future version is not backwards compatible, a different GUID must be used.
+
+**LoadBootData**
+
+Loads slot metadata from persistent storage. Other slot operations may call
+this method internally.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.LoadBootData()`](#gbl_efi_ab_slot_protocolloadbootdata).
+
+**GetSlotInfo**
+
+Returns information about a slot by index.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.GetSlotInfo()`](#gbl_efi_ab_slot_protocolgetslotinfo).
+
+**GetCurrentSlot**
+
+Returns information about the current slot.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot).
+
+**SetActiveSlot**
+
+Marks the specified slot as the active boot target.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()`](#gbl_efi_ab_slot_protocolsetactiveslot).
+
+**SetSlotUnbootable**
+
+Marks the specified slot as unbootable.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.SetSlotUnbootable()`](#gbl_efi_ab_slot_protocolsetslotunbootable).
+
+**MarkBootAttempt**
+
+Marks the boot attempt and modifies tries remaining for the active slot.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.MarkBootAttempt()`](#gbl_efi_ab_slot_protocolmarkbootattempt).
+
+**Reinitialize**
+
+Resets slot metadata to a default, initial state.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.Reinitialize()`](#gbl_efi_ab_slot_protocolreinitialize).
+
+**GetBootReason**
+
+Gets the boot reason.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.GetBootReason()`](#gbl_efi_ab_slot_protocolgetbootreason).
+
+**SetBootReason**
+
+Sets the boot reason.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.SetBootReason()`](#gbl_efi_ab_slot_protocolsetbootreason).
+
+**Flush**
+
+Synchronizes slot metadata with persistent storage. May re-establish data
+structure invariants, e.g. recalculate checksums.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.Flush()`](#gbl_efi_ab_slot_protocolflush).
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.LoadBootData()`
+
+### Summary
+
+Loads metadata about system boot slots.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_LOAD_BOOT_DATA)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL*     This,
+    OUT GBL_EFI_SLOT_METADATA_BLOCK* Metadata,
+);
+```
+
+### Related Definitions
+
+```c
+typedef enum _GBL_EFI_SLOT_MERGE_STATUS {
+  GBL_EFI_SLOT_MERGE_STATUS_NONE = 0,
+  GBL_EFI_SLOT_MERGE_STATUS_UNKNOWN,
+  GBL_EFI_SLOT_MERGE_STATUS_SNAPSHOTTED,
+  GBL_EFI_SLOT_MERGE_STATUS_MERGING,
+  GBL_EFI_SLOT_MERGE_STATUS_CANCELLED,
+} GBL_EFI_SLOT_MERGE_STATUS;
+
+typedef struct _GBL_EFI_SLOT_METADATA_BLOCK {
+  // Value of 1 if persistent metadata tracks slot unbootable reasons.
+  UINT8 UnbootableMetadata;
+  UINT8 MaxRetries;
+  UINT8 SlotCount;
+  // See the definition of GBL_EFI_SLOT_MERGE_STATUS.
+  UINT8  MergeStatus;
+} GBL_EFI_SLOT_METADATA_BLOCK;
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Metadata*
+
+On return contains device-specific immutable information about the AB slot
+implementation. See [`Related Definitions`](#related-definitions) for the layout
+of the metadata structure and its fields.
+
+### Description
+
+In addition to information about individual slots, EFI applications need
+overarching metadata about AB boot slot implementations.
+In particular, implementations might not store persistent metadata detailing why
+specific slots are not bootable (i.e. unbootable metadata). Developers may want
+to know whether a device supports unbootable metadata to ease in debugging.
+
+Certain operations may be prohibited due to the device's A/B merge status.
+For more information about the *MergeStatus* field and Android Virtual A/B, see
+the documentation
+[here](https://source.android.com/docs/core/ota/virtual_ab/implement).
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                     |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | Slot metadata was successfully read from persistent storage.                                                  |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Metadata* is `NULL` or improperly aligned.                                                  |
+| `EFI_DEVICE_ERROR`      | There was an error while performing the read operation.                                                       |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.GetSlotInfo()`
+
+### Summary
+
+Queries info about a boot slot by index.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_GET_SLOT_INFO)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    IN UINT8                     Idx,
+    OUT GBL_EFI_SLOT_INFO*       Info,
+)
+```
+
+### Related Definitions
+
+```c
+typedef enum _GBL_EFI_SLOT_UNBOOTABLE_REASON {
+  UNKNOWN_REASON = 0,
+  NO_MORE_TRIES,
+  SYSTEM_UPDATE,
+  USER_REQUESTED,
+  VERIFICATION_FAILURE,
+} GBL_EFI_SLOT_UNBOOTABLE_REASON;
+
+typedef struct _GBL_EFI_SLOT_INFO {
+    // One UTF-8 encoded single character
+    UINT32 Suffix;
+    // Any value other than those explicitly enumerated in
+    // GBL_EFI_SLOT_UNBOOTABLE_REASON
+    // will be interpreted as UNKNOWN_REASON.
+    UINT32 UnbootableReason;
+    UINT8  Priority;
+    UINT8  Tries;
+    // Value of 1 if slot has successfully booted
+    UINT8  Successful;
+} GBL_EFI_SLOT_INFO;
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Idx*
+
+The index of the slot to query.
+
+*Info*
+
+On exit contains the metadata for the specified slot.
+See [Related Definitions](#related-definitions-1)
+for the layout and fields of the metadata structure.
+
+### Description
+
+Developers and EFI applications may wish to query metadata of arbitrary boot
+slots as part of debugging or logging.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                     |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned, or the value of *Idx* invalid.                       |
+| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()`
+
+### Summary
+
+Returns the slot information of the current slot.
+
+### Definitions
+
+The *current target* slot is defined as the highest priority bootable slot with
+ties broken by inverse lexicographical ordering of slot suffixes. E.g. if slot A
+and slot B are both bootable and have priority 15, slot A is the current slot.
+The *active* slot is the slot that owns the running bootloader firmware.
+Depending on whether `SetActiveSlot()` has been called, the current and active
+slots may be the same or they may differ. See the
+[Boot Slot Coherency Warning](#boot-slot-coherency-warning) for details.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_GET_CURRENT_SLOT)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    OUT GBL_EFI_SLOT_INFO*       Info,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Info*
+
+On exit contains the metadata for the current slot.
+See the definition for [`GBL_EFI_SLOT_INFO`](#related-definitions-1)
+for the structure definition.
+
+### Description
+
+This is identical to knowing the index of the current slot and calling
+`GetSlotInfo()` with that index.
+
+**Note:** the current slot is returned by value and not by index.
+This simplifies interactions for the caller, who is usually more interested in
+the suffix and associated metadata for a slot than its index.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                     |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned.                                                      |
+| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()`
+
+### Summary
+
+Sets the active slot by index, reinitializes its tries remaining and priority,
+and clears any unbootable reasons.
+Sets the priority for all other slots to be lower than the new active slot's.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_SET_ACTIVE_SLOT)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    IN UINT8                     Idx,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Idx*
+
+The index of the new active slot.
+
+### Description
+
+Explicitly sets the target boot slot to the one defined by `Idx`.
+This clears any unbootable reason metadata the slot may have, resets its tries
+remaining to a device specific default, resets its priority to a device specific
+default, sets the priority of all other slots to be lower than that of the
+target, and clears the slot's *Successful* flag.
+All these changes **MUST** be visible in subsequent calls to `GetSlotInfo()`.
+Depending on device policy, e.g. lock state, changing the target boot slot
+explicitly may be prohibited.
+
+**Warning:** See the description for
+[`GetCurrentSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot) for the
+distinction between the *current target* boot slot and the *active* boot slot,
+and see the [Boot Slot Coherency Warning](#boot-slot-coherency-warning) for
+details about safely changing the *current target* slot.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                     |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned, or the value of *Idx* was invalid.                   |
+| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
+| `EFI_ACCESS_DENIED`     | Device policy prohibited the boot slot target change.                                                         |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.SetSlotUnbootable()`
+
+### Summary
+
+Marks a slot as unbootable for the provided reason.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_SET_SLOT_UNBOOTABLE)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    IN UINT8                     Idx,
+    IN UINT32                    UnbootableReason,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Idx*
+
+The index of the slot to mark unbootable.
+
+*UnbootableReason*
+
+The reason the slot is being marked unable to be booted.
+See the definition for [`GBL_EFI_SLOT_UNBOOTABLE_REASON`](#related-definitions-1)
+for valid values of *UnbootableReason*.
+
+**Note:** Unbootable reason codes are a best-effort debug and RMA helper.
+The device's persistent metadata structures may not track unbootable reasons,
+and other software that interacts with boot slots may not set unbootable reason
+codes accurately.
+
+### Description
+
+Marks a slot as not a valid boot target.
+The slot's *Priority*, *TriesRemaining*, and *Successful* fields are all set to
+`0`.
+Subsequent calls to `GetSlotInfo()` **MUST** reflect these changes to slot info.
+If the slot was the current slot, the current boot target will have changed.
+This change **MUST** be reflected in subsequent calls to `GetCurrentSlot()`.
+
+If the protocol driver supports tracking slot unbootable reasons, then
+subsequent calls to `GetSlotInfo()` **MUST** have the same *UnbootableReason* in
+the info structure.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                             |
+|:------------------------|:----------------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                                      |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned, the value of *Idx* is invalid, or the value of *UnbootableReason* is invalid. |
+| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                          |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions.         |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.MarkBootAttempt()`
+
+### Summary
+
+Marks a boot attempt on the current slot.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_MARK_BOOT_ATTEMPT)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+);
+```
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+### Description
+
+Updates internal metadata for the current boot target slot.
+If the current slot has registered a successful boot, its tries remaining field
+is left unchanged.
+If there are no slots with non-zero *Successful* or *Tries* fields, the call to
+`MarkBootAttempt()` **MUST** return `EFI_ACCESS_DENIED`. The bootloader then
+must decide on the next action to take.
+
+Subsequent calls to `GetSlotInfo()` and `GetCurrentSlot()` **MUST** reflect
+the decremented tries.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                     |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                              |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                                                                       |
+| `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
+| `EFI_ACCESS_DENIED`     | The current slot has no more tries remaining.                                                                 |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.Reinitialize()`
+
+### Summary
+
+Reinitializes all boot slot metadata to a known initial state.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_REINITIALIZE)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+### Description
+
+In particular, all slots should have the following fields cleared and set to
+device-specific defaults:
+* *Priority*
+* *Tries*
+
+and have the following fields set to `0`:
+* *UnbootableReason*
+* *Successful*
+
+This may change the current target boot slot.
+See the [Boot Slot Coherency Warning](#boot-slot-coherency-warning) for details.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                              |
+|:------------------------|:-------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                       |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                |
+| `EFI_ACCESS_DENIED`     | Device policy prohibited resetting boot slot metadata. |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.GetBootReason()`
+
+### Summary
+
+Gets the current boot reason and subreason.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_GET_BOOT_REASON)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    OUT UINT32*                  Reason,
+    IN OUT UINTN*                SubreasonLength;
+    OUT UINT8*                   Subreason;
+);
+```
+
+### Related Definitions
+
+```c
+typedef enum _GBL_EFI_AB_SLOT_BOOT_REASON {
+    EMPTY = 0,
+    UNKNOWN = 1,
+    WATCHDOG = 14,
+    KERNEL_PANIC = 15,
+    RECOVERY = 3,
+    BOOTLOADER = 55,
+    COLD = 56,
+    HARD = 57,
+    WARM = 58,
+    SHUTDOWN = 59,
+    REBOOT = 18,
+} GBL_EFI_AB_SLOT_BOOT_REASON;
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Reason*
+
+On exit, the boot reason code. See [Related Definitions](#related-definitions-2)
+for the list of valid codes.
+
+*SubreasonLength*
+
+On entry, the length of *Subreason* in bytes.
+On exit, the length of the UTF-8 encoded string pointed to by *Subreason*,
+ignoring any Null-terminator.
+
+*Subreason*
+
+On exit, the boot subreason as a UTF-8 encoded, Null-terminated string.
+
+### Description
+
+The boot reason is an Android mechanism for communicating between the running
+system and the bootloader. For example, if the boot reason is 'recovery', the
+bootloader should load the recovery RAM disk and command line. This information
+is stored in a device specific location and format.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                                                                   |
+|:------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                            |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Reason*, *SubreasonLength*, or *Subreason* is `NULL` or improperly aligned.                                                                 |
+| `EFI_BUFFER_TOO_SMALL`  | *Subreason* is too small to store the serialized subreason string. The value of *SubreasonLength* is modified to contain the minimum necessary buffer size. |
+| `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions.                                               |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.SetBootReason()`
+
+### Summary
+
+Sets the current boot reason.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_SET_BOOT_REASON)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    IN UINT32                    Reason,
+    IN UINTN                     SubreasonLength,
+    IN UINT8                     Subreason,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*Reason*
+
+The desired boot reason to set. See [here](#related-definitions-2) for the list
+of valid boot reasons.
+
+*SubreasonLength*
+
+The length of the *Subreason* string.
+
+*Subreason*
+
+The desired boot subreason as a UTF-8 encoded, Null-terminated string.
+
+### Description
+
+Sets the Android boot reason and subreason.
+This is usually used by the bootloader to clear the boot reason.
+See [`GetBootReason()`](#gbl_efi_ab_slot_protocolgetbootreason) for more
+information about boot reasons.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                               |
+|:------------------------|:----------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                        |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Reason*, or *Subreason* is `NULL` or improperly aligned.                |
+| `EFI_INVALID_PARAMETER` | *Reason* is not a valid reason code or *Subreason* is not a valid UTF-8 encoded string. |
+| `EFI_UNSUPPORTED`       | The platform does not support setting the boot reason.                                  |
+| `EFI_BAD_BUFFER_SIZE`   | *Subreason* is too large  to be written to persistent storage.                          |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.Flush()`
+
+### Summary
+
+Writes any slot metadata modifications to persistent storage.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_FLUSH)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+### Description
+
+Protocol driver implementations may store modifications to boot slot metadata in
+memory before committing changes to storage in a single write operation.
+Protocol consumers need a mechanism to instruct the driver that they are
+finished operating on boot slots and that changes should be committed.
+The implementation should conduct any necessary ancillary tasks, e.g.
+recalculating checksums, before writing to storage.
+This is an optimization for performance and flash lifetime; implementations are
+free to write all modifications to storage as they occur and to define `Flash()`
+as a no-op.
+
+### Status Codes Returned
+
+| Return Code        | Semantics                                                 |
+|:-------------------|:----------------------------------------------------------|
+| `EFI_SUCCESS`      | The call completed successfully.                          |
+| `EFI_DEVICE_ERROR` | The device reported a write error during synchronization. |
diff --git a/gbl/docs/gbl_efi_fastboot_protocol.md b/gbl/docs/gbl_efi_fastboot_protocol.md
new file mode 100644
index 0000000..3d21040
--- /dev/null
+++ b/gbl/docs/gbl_efi_fastboot_protocol.md
@@ -0,0 +1,753 @@
+# GBL EFI Fastboot Protocol
+
+This document describes the GBL Fastboot protocol. The protocol defines
+interfaces that can be used by EFI applications to query and modify vendor-specific
+information on a device that may be desired in the context of a fastboot environment.
+
+|             |                    |
+|:------------|-------------------:|
+| **Status**  | *Work in progress* |
+| **Created** |          2024-9-11 |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL`
+
+### Summary
+
+This protocol provides interfaces for platform-specific operations during Fastboot.
+This can include support for vendor defined variables or variables whose query
+requires cooperation with vendor firmware, OEM commands,
+
+### GUID
+```c
+// {c67e48a0-5eb8-4127-be89-df2ed93d8a9a}
+#define GBL_EFI_FASTBOOT_PROTOCOL_GUID               \
+  {                                                  \
+    0xc67e48a0, 0x5eb8, 0x4127, {                    \
+      0xbe, 0x89, 0xdf, 0x2e, 0xd9, 0x3d, 0x8a, 0x9a \
+    }                                                \
+  }
+```
+
+### Revision Number
+
+```c
+#define GBL_EFI_FASTBOOT_PROTOCOL_REVISION 0x00000000
+```
+
+### Protocol Interface Structure
+
+```c
+#define GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8 32
+
+typedef struct _GBL_EFI_FASTBOOT_PROTOCOL {
+  UINT32                                        Revision
+  CHAR8                                         SerialNumber[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
+  GBL_EFI_FASTBOOT_GET_VAR                      GetVar;
+  GBL_EFI_FASTBOOT_START_VAR_ITERATOR           StartVarIterator;
+  GBL_EFI_FASTBOOT_GET_NEXT_VAR_ARGS            GetNextVarArgs;
+  GBL_EFI_FASTBOOT_RUN_OEM_FUNCTION             RunOemFunction;
+  GBL_EFI_FASTBOOT_GET_POLICY                   GetPolicy;
+  GBL_EFI_FASTBOOT_SET_LOCK                     SetLock;
+  GBL_EFI_FASTBOOT_CLEAR_LOCK                   ClearLock;
+  GBL_EFI_FASTBOOT_GET_PARTITION_PERMISSIONS    GetPartitionPermissions;
+  GBL_EFI_FASTBOOT_WIPE_USER_DATA               WipeUserData;
+} GBL_EFI_FASTBOOT_PROTOCOL;
+```
+
+### Parameters
+
+**Revision**
+
+The revision to which the `GBL_EFI_FASTBOOT_PROTOCOL` adheres.
+All future revisions must be backwards compatible.
+If a future version is not backwards compatible, a different GUID must be used.
+
+**SerialNumber**
+
+The device serial number expressed as a Null-terminated UTF-8 encoded string.
+If the device serial number is 32 bytes long, the Null terminator must be excluded.
+If the device serial number is longer than 32 bytes, it must be truncated.
+
+**GetVar**
+
+Gets the value for the given fastboot variable.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`](#gbl_efi_fastboot_protocolgetvar).
+
+**StartVarIterator**
+
+Creates an iterator at the beginning of all valid fastboot variables
+tracked by the protocol driver.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`](#gbl_efi_fastboot_protocolstartvariterator).
+
+**GetNextVarArgs**
+
+Gets the next variable and sub-arguments in the iterator.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs).
+
+**RunOemFunction**
+
+Runs an OEM-defined command on the device.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.RunOemFunction()`](#gbl_efi_fastboot_protocolrunoemfunction).
+
+**GetPolicy**
+
+Querys device policy including device lock state, whether the device firmware
+supports a 'critical' lock, and whether the device is capable of booting from
+an image loaded directly into RAM.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.GetPolicy()`](#gbl_efi_fastboot_protocolgetpolicy).
+
+**SetLock**
+
+Enables device locks according to the provided ORed lock definitions.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.SetLock()`](#gbl_efi_fastboot_protocolsetlock).
+
+**ClearLock**
+
+Removes devices locks according to the provided ORed lock definitions.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.ClearLock()`](#gbl_efi_fastboot_protocolclearlock).
+
+**GetPartitionPermissions**
+
+Queries permissions information about the provided partition.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.GetPartitionPermissions()`](#gbl_efi_fastboot_protocolgetpartitionpermissions).
+
+**WipeUserData**
+
+Erases all partitions containing user data.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.WipeUserData()`](#gbl_efi_fastboot_protocolwipeuserdata).
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`
+
+### Summary
+
+Gets the value for a fastboot variable.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_GET_VAR)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL*         This,
+    IN GBL_EFI_FASTBOOT_ARG*              Args,
+    IN UINTN                              NumArgs,
+    OUT CHAR8*                            Buf,
+    IN OUT UINTN*                         BufSize,
+    OPTIONAL IN GBL_EFI_FASTBOOT_TOKEN    Hint,
+);
+```
+
+### Related Definitions
+
+```c
+typedef struct _GBL_EFI_FASTBOOT_ARG {
+    // Pointer to a Null-terminated, UTF-8 encoded string.
+    const CHAR8* StrUtf8;
+    // Length of StrUtf8 excluding the Null terminator.
+    UINTN        Length;
+} GBL_EFI_FASTBOOT_ARG;
+
+typedef VOID* GBL_EFI_FASTBOOT_TOKEN;
+```
+
+### String Encoding
+
+All strings provided to protocol methods, returned from protocol methods,
+or defined as protocol fields are UTF-8 encoded and Null terminated.
+
+Additionally, with the exception of `GBL_EFI_FASTBOOT_PROTOCOL.SerialNumber`,
+all strings are either passed as pointer/length paired parameters or
+are described by a `GBL_EFI_FASTBOOT_ARG`, which has pointer and length fields.
+No length ever includes any Null-terminator characters.
+
+The protocol requires both explicit length and Null-termination because GBL is
+written in Rust. The Rust primitive `str` type is defined as a pointer and
+length and is **NOT** Null-terminated.
+Requiring protocol strings to provide an explicit length facilitates Rust
+wrapping returned strings more easily.
+
+Additionally, in-out length fields allow protocol methods to return
+`EFI_BUFFER_TOO_SMALL` and provide the required buffer size to the caller
+if necessary.
+
+Null-terminators are required when passing strings to protocol methods because
+Null-terminated strings are the standard in C, and protocol implementations
+written in C must be supported.
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*Args*
+
+A pointer to an array of string fragments that describe a fastboot variable.
+The caller splits an input string delimited with `:` to generate the fragments
+and replaces the `:` characters with `\0`.
+
+*NumArgs*
+
+The number of elements in the *Args* array.
+
+*Buf*
+
+A pointer to the data buffer to store the value of the variable as a UTF-8
+encoded string.
+
+*BufSize*
+
+On entry, the size in bytes of *Buf*.
+On exit, the size in bytes of the UTF-8 encoded string describing the value,
+excluding any Null-terminator.
+
+*Hint*
+
+If not `NULL` provides the driver with a user-opaque hint
+in order to optimize variable lookup.
+The only way to provide a valid hint is to use the tokens generated by
+[`GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`](#gbl_efi_fastboot_protocolstartvariterator) and
+[`GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs).
+
+### Description
+
+`GetVar()` queries internal data structures and devices
+to determine the value of the given variable.
+Variables may have zero or more subfields with arbitrarily many variants per subfield.
+These subfields are parsed by the caller and passed to `GetVar()`
+as an array of UTF-8 encoded string slices.
+The string slices are defined by a pointer and length structure,
+and each string slice is also guaranteed to have a Null terminator.
+See [Related Definitions](#related-definitions-1) for the definition of `GBL_EFI_FASTBOOT_ARG`.
+
+The *Hint* parameter is an optional token generated
+as part of iterating over the fastboot variables.
+The method implementation can use a non-`NULL` *Hint*
+to bypass a more expensive variable lookup.
+
+An example client interaction:
+```bash
+# A variable with no subfields
+$ fastboot getvar max-download-size
+OKAY0x20000000
+
+# A variable with two subfields
+$ fastboot getvar block-device:0:total-blocks
+OKAY0x800000000000
+```
+
+If *Hint* is `NULL`, invalid, or wrong, the lookup should proceed
+as if the hint was not provided at all.
+
+**Note:** even if the *Hint* parameter is *valid*,
+i.e. it correctly points to a fastboot variable entry,
+it may disagree with the variable description in *Args*.
+The method implementation should check that the variable entry
+described by *Hint* matches with *Args*.
+If there is a discrepancy, *Args* should provide the authoritative lookup parameters
+and *Hint* should be ignored.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                                                                                |
+|:------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The variable was found and its value successfully serialized.                                                                                                            |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *Buf*, or *BufSize* is `NULL` or improperly aligned.                                                                                              |
+| `EFI_NOT_FOUND`         | The first element of *Args* does not contain a known variable.                                                                                                           |
+| `EFI_UNSUPPORTED`       | The contents of *Args* do not contain a known variable with valid aruments. Any of the subarguments may be unknown, or too many or too few subarguments may be provided. |
+| `EFI_BUFFER_TOO_SMALL`  | *Buf* is too small to store the serialized variable string. The value of *BufSize* is modified to contain the minimum necessary buffer size.                             |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`
+
+### Summary
+
+Creates an iterator at the beginning of the fastboot variables.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_START_VAR_ITERATOR)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL*  This,
+    OUT GBL_EFI_FASTBOOT_TOKEN*    Token,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*Token*
+
+On exit contains a caller-opaque token describing an iterator
+at the beginning of the fastboot variables defined by the driver.
+
+### Description
+`StartVarIterator()` is used in conjunction with
+[`GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs) and
+[`GetVar()`](#gbl_efi_fastboot_protocolgetvar) to
+iterate over all variants of all driver defined fastboot variables and retrieve their values.
+This faculty is used when a client requests the special `all` variable as in the following example.
+The value of *Token* returned by `StartVarIterator()` **MUST** be a valid value for *Hint*
+when passed to `GetVar()` along with the *Args* array returned by the first call to
+`GetNextVarArgs()`.
+
+Example client running `getvar all`:
+```bash
+$ fastboot getvar all
+(bootloader) max-download-size: 0x20000000
+(bootloader) version-bootloader: 1.0
+(bootloader) max-fetch-size: 0xffffffffffffffff
+(bootloader) partition-size:vbmeta:0: 0x8000000
+(bootloader) partition-type:vbmeta:0: raw
+(bootloader) partition-size:misc:0: 0x100000
+(bootloader) partition-type:misc:0: raw
+...
+```
+
+**Note:** `StartVarIterator()` **SHOULD** be idempotent,
+i.e. the same token should be returned each time.
+This makes comparing iterator values more stable,
+which is helpful for detecting and exiting loops due to bugs.
+
+**Note:** between the first call to `StartVarIterator()` and the final call to `GetNextVarArgs()`,
+the iterator **MUST** remain valid.
+The GBL is expected to invoke the following protocol methods during variable iteration;
+these methods **MUST NOT** invalidate the iterator.
+
+* `GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`
+* `GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`
+* `GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()`
+* `GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()`
+* `EFI_SIMPLE_NETWORK_PROTOCOL.Receive()`
+* `EFI_SIMPLE_NETWORK_PROTOCOL.Transmit()`
+* `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.OutputString()`
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                          |
+|:------------------------|:-----------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The value of *Token* has been updated to reference the starting iterator position. |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Token* is `NULL` or improperly aligned.                          |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`
+
+### Summary
+
+Gets the fastboot variable arguments at the current iterator position and advances the iterator.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_GET_NEXT_VAR_ARGS)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL*     This,
+    OUT GBL_EFI_FASTBOOT_ARG*         Args,
+    IN OUT UINTN*                     NumArgs,
+    IN OUT GBL_EFI_FASTBOOT_TOKEN*    Token,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*Args*
+
+A pointer to an uninitialized, caller-owned array of `GBL_EFI_FASTBOOT_ARG`.
+On return defines the fastboot variable and subvariable variant
+at the position indicated by the input value of *Token*.
+
+*NumArgs*
+
+On entry contains the maximum length of *Args*.
+On exit contains the length of *Args* in elements defining the current variable.
+
+*Token*
+
+On entry contains the current iterator position.
+On exit contains the next iterator position.
+
+### Description
+
+`GetNextVarArgs()` is used in conjunction with `GetVar()` and `StartVarIterator()`
+to iterate over all fastboot variables and corresponding values provided by the protocol driver.
+This functionality is used when handling the special `all` fastboot variable.
+
+The position of the iterator is tracked by *Token*.
+All values of *Token* are opaque handles used by the protocol driver.
+Users **MUST NOT** assume that they are pointers, indices, references,
+or have any user-accessible semantics of any kind.
+
+When the iterator has reached the final fastboot variable entry,
+the *next* call to `GetNextVarArgs()` **MUST** do **ALL** of the following:
+
+* Return `EFI_SUCCESS`
+* Set *NumArgs* to `0`
+* Leave the value of *Token* unchanged
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                                                        |
+|:------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                 |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *NumArgs*, or *Token* is `NULL` or improperly aligned.                                                                    |
+| `EFI_INVALID_PARAMETER` | The input value of *Token* is nonsensical.                                                                                                       |
+| `EFI_BUFFER_TOO_SMALL`  | The entry value of *NumArgs* is too small to store the variable arguments. Its value is updated to contain the minimum necessary size of *Args*. |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.RunOemFunction()`
+
+### Summary
+
+Runs a vendor defined function that requires firmware support.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_RUN_OEM_FUNCTION)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+    IN CHAR8*                     Command,
+    IN UINTN                      CommandLen,
+    OUT CHAR8*                    Buf,
+    IN OUT UINTN*                 BufSize,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*Command*
+
+The command to run as a Null-terminated UTF-8 encoded string.
+
+*CommandLen*
+
+The length of the command in bytes, excluding any Null-terminator.
+
+*Buf*
+
+A pointer to the data buffer to store any output the command generates
+as a UTF-8 encoded, Null-terminated string.
+On success, this output will be sent to the connected client as an INFO message.
+On failure, this output will be sent to the connected client as a FAIL message.
+
+**Note:** GBL is the only expected caller for any method of
+`GBL_EFI_FASTBOOT_PROTOCOL`, including `RunOemFunction()`.
+For a non-zero `BufSize`, GBL and all other callers are required to set the
+first byte of `Buf` to `0`. GBL and all other callers are responsible for
+parsing `Buf` until the first Null-terminator or for `Buf + BufSize` bytes,
+whichever occurs first.
+
+*BufSize*
+
+On entry, the size in bytes of `Buf`.
+On exit, the size in bytes of the UTF-8 encoded string describing the value,
+excluding any Null-terminator.
+
+### Description
+
+`RunOemFunction()` runs a vendor defined Oem function.
+These functions can take arbitrary arguments or subcommands;
+the caller does no parsing or verification.
+All parsing and verification is the responsibility of the method implementation.
+Oem functions can display power or battery information, print or iterate over UEFI variables,
+or conduct arbitrary other operations.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                                                                                                                                                       |
+|:------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                                                |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Command*, *CommandLen*, *Buf*, or *BufSize* is `NULL` or improperly aligned.                                                                                    |
+| `EFI_BUFFER_TOO_SMALL`  | The provided buffer is too small to store the serialized representation of the command output. The value of `BufSize` is modified to contain the minimum necessary buffer size. |
+| `EFI_UNSUPPORTED`       | The command is not supported or is nonsensical.                                                                                                                                 |
+| `EFI_ACCESS_DENIED`     | The operation is not permitted in the current lock state.                                                                                                                       |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.GetPolicy()`
+
+### Summary
+
+Gets the device policy pertaining to locking and booting directly from RAM.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_GET_POLICY)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+    OUT GBL_EFI_FASTBOOT_POLICY*  Policy,
+);
+```
+
+### Related Definitions
+
+```c
+typedef struct _GBL_EFI_FASTBOOT_POLICY {
+  // Indicates whether device can be unlocked.
+  BOOL CanUnlock;
+  // Device firmware supports 'critical' partition locking.
+  BOOL HasCriticalLock;
+  // Indicates whether device allows booting
+  // from images loaded directly from RAM.
+  BOOL CanRamBoot;
+} GBL_EFI_FASTBOOT_POLICY;
+
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*Policy*
+
+On exit contains the device policy.
+See [Related Definitions](#related-definitions-2) for the definition of `GBL_EFI_FASTBOOT_POLICY`.
+
+### Description
+
+Depending on various factors including whether the device
+is a development target or end-user device,
+certain operations may be prohibited.
+In particular, loading an image directly into RAM and then booting it
+is generally not permitted on anything except development hardware.
+Developer workflows and CI/CD infrastructure need to be able to query
+whether a device is able to be unlocked and whether RAM booting is permitted.
+
+See [`SetLock()`](#gbl_efi_fastboot_protocolsetlock) and [`ClearLock()`](#gbl_efi_fastboot_protocolclearlock)
+for methods that modify the device lock state. Querying lock state is handled by Android Verified Boot.
+
+### Status Codes
+
+| Return Code             | Semantics                                                  |
+|:------------------------|:-----------------------------------------------------------|
+| `EFI_SUCCESS`           | The device policy was successfuly retrieved.               |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Policy* is `NULL` or improperly aligned. |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.SetLock()`
+
+### Summary
+
+Sets device partition locks.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_SET_LOCK)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+    IN UINT64                     LockState,
+);
+```
+
+### Related Definitions
+
+```c
+typedef enum _GBL_EFI_FASTBOOT_LOCK_FLAGS {
+  // All device partitions are locked.
+  GBL_EFI_FASTBOOT_GBL_EFI_LOCKED = 0x1 << 0,
+  // All 'critical' device partitions are locked.
+  // The 'critical' lock is optional,
+  // and which partitions are locked by the critical lock
+  // is a vendor implementation detail.
+  GBL_EFI_FASTBOOT_GBL_EFI_CRITICAL_LOCKED = 0x1 << 1,
+} GBL_EFI_FASTBOOT_LOCK_FLAGS;
+
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*LockState*
+
+The ORed value of all device partition locks to enable.
+When locked, partitions generally cannot be read, written, or erased via fastboot.
+See [Related Definitions](#related-definitions-3) for valid lock flags.
+
+### Description
+
+Device lock state determines what operations can be performed on device partitions.
+`SetLock()` enables the locks defined in *LockState*, some of which may already be set.
+No locks are cleared by any call to `SetLock()`.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                          |
+|:------------------------|:---------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                   |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.            |
+| `EFI_INVALID_PARAMETER` | The lock flags in *LockState* are invalid.         |
+| `EFI_ACCESS_DENIED`     | Device policy prohibited the change in lock state. |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.ClearLock()`
+
+### Summary
+
+Clears device partition locks.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_CLEAR_LOCK)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+    IN UINT64                     LockState,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*LockState*
+
+The ORed value of all device partition locks to disable.
+See the [Related Definitions](#related-definitions-3) for `SetLock()` for valid lock flags.
+
+### Description
+
+Device lock state determines what operations can be performed on device partitions.
+`ClearLock()` disables the locks defined in *LockState*, some of which may already be cleared.
+
+### Status Codes Returned
+
+| Return Code             | Semantics                                          |
+|:------------------------|:---------------------------------------------------|
+| `EFI_SUCCESS`           | The call completed successfully.                   |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.            |
+| `EFI_INVALID_PARAMETER` | The lock flags in *LockState* are invalid.         |
+| `EFI_ACCESS_DENIED`     | Device policy prohibited the change in lock state. |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.GetPartitionPermissions()`
+
+### Summary
+
+Gets access permission information about the given partition.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_GET_PARTITION_PERMISSIONS)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+    IN CHAR8*                     PartName,
+    IN UINTN                      PartNameLen,
+    OUT UINT64                    Permissions,
+);
+```
+
+### Related Definitions
+
+```c
+typedef enum _GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS {
+  // Firmware can read the given partition and send its data to fastboot client.
+  GBL_EFI_FASTBOOT_PARTITION_READ = 0x1 << 0,
+  // Firmware can overwrite the given partition.
+  GBL_EFI_FASTBOOT_PARTITION_WRITE = 0x1 << 1,
+  // Firmware can erase the given partition.
+  GBL_EFI_FASTBOOT_PARTITION_ERASE = 0x1 << 2,
+} GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS;
+
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+*PartName*
+
+The name of the partition to query as a UTF-8 encoded, Null-terminated string.
+
+*PartNameLen*
+
+The length of *PartName* in bytes, excluding any Null-terminator.
+
+*Permissions*
+
+On exit contains the ORed flags detailing the current fastboot permissions for
+the given partition.
+See [Related Definitions](#related-definitions-4) for flag value semantics.
+
+### Description
+
+Depending on device lock state, Android Verified Boot policy, and other factors,
+various partitions may have restricted permissions within a fastboot environment.
+`GetPartitionPermissions()` retrieves the current permissions
+for the requested partition.
+
+By default, unless overridden by device policy, no operations are permitted on
+any partition when the device is locked, and all operations are permitted
+on all partitions when the device is unlocked.
+
+### Status Codes
+
+| Return Code             | Semantics                                                                          |
+|:------------------------|:-----------------------------------------------------------------------------------|
+| `EFI_SUCCESS`           | The partition permision information was successfully queried.                      |
+| `EFI_INVALID_PARAMETER` | One of *This*, *PartName*, or *Permissions* is `NULL` or improperly aligned.       |
+| `EFI_NOT_FOUND`         | There is no partition named *PartName*.                                            |
+| `EFI_UNSUPPORTED`       | The device does not have a partition permission policy different from the default. |
+
+## `GBL_EFI_FASTBOOT_PROTOCOL.WipeUserData()`
+
+### Summary
+
+Erases all partitions containing user data.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_FASTBOOT_WIPE_USER_DATA)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL* This,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+
+### Description
+
+Device user data is often stored on a dedicated partition
+apart from kernel images or other system data.
+This helps protect user data during system upgrades.
+`WipeUserData()` erases all user data partitions.
+This can be used to restore a device to its factory settings,
+as part of a refurbishment process, or for testing purposes.
+
+### Status Codes
+
+| Return Code             | Semantics                                                 |
+|:------------------------|:----------------------------------------------------------|
+| `EFI_SUCCESS`           | User data was successfully wiped.                         |
+| `EFI_INVALID_PARAMETER` | *This* is `NULL` or improperly aligned.                   |
+| `EFI_ACCESS_DENIED`     | The operation is not permitted in the current lock state. |
+| `EFI_DEVICE_ERROR`      | There was a block device or storage error.                |
+
diff --git a/gbl/docs/gbl_fastboot.md b/gbl/docs/gbl_fastboot.md
index f2dd277..4407248 100644
--- a/gbl/docs/gbl_fastboot.md
+++ b/gbl/docs/gbl_fastboot.md
@@ -7,53 +7,117 @@ This document describes Fastboot in the [GBL UEFI bootloader](../efi/BUILD).
 The GBL UEFI bootloader supports both Fastboot over TCP and USB. To enable
 Fastboot over TCP, the UEFI loader needs to implement the
 `EFI_SIMPLE_NETWORK_PROTOCOL` protocol. To enable Fastboot over USB, the
-[EFI_ANDROID_BOOT_PROTOCOL](./EFI_ANDROID_BOOT_PROTOCOL.md) protocol is needed.
-GBL automatically establishes the corresponding transport channel if the needed
-protocol is available.
+[GBL_EFI_FASTBOOT_USB_PROTOCOL](./GBL_EFI_FASTBOOT_USB_PROTOCOL.md) protocol is
+needed. GBL automatically establishes the corresponding transport channel if
+the needed protocol is available.
 
-## Definition of Partition
+## The Partition Argument
 
-Certain fastboot commands such as `fastboot flash`, `fastboot fetch` and
-`fastboot getvar partition-size` require to specify a partition. GBL Fastboot
-assumes that the platform may have multiple storage devices that may or may not
-use GPT partitions. Therefore, in the context of GBL Fastboot, the notion
-"partition" is defined to represent both GPT partitions or raw storage of any
-sub window and on any storage device. Specifically, the following semantics are
-introduced for specifying a partition:
+Fastboot commands such as `fastboot flash`, `fastboot fetch` and
+`fastboot getvar partition-size` operate on partitions and requires a partition
+name argument. See this [doc](./partitions.md) for how GBL defines and handles
+partitions on storage devices. GBL fastboot additionaly supports accessing
+sub ranges of partitions and disambiguating betweeen same name partitions on
+multiple storage devices (i.e. in the presence of external or removable boot
+storage). The following summarizes the supported semantics for partition
+name argument in fastboot.
 
-* GPT partitions
+* Partition
   ```sh
-  <part>[:<block_id>]
-  <part>:[<block_id>][:<offset>]
-  <part>:[<block_id>]:[<offset>][:<size>]
+  <part>[:<storage_id>]
+  <part>:[<storage_id>][:<offset>]
+  <part>:[<storage_id>]:[<offset>][:<size>]
   ```
-  This specifies range `[offset, offset+size)` in GPT partition `part` on the
-  block device with ID `block id`. `block_id`, `offset` and `size` must be a
-  64bit integer hex string. If `block id` is not given, GBL will check and only
-  accept it if the GPT partition is unique among all devices. `offset` defaults
-  to 0 if not given. `size` defaults to the rest of the GPT partition after
-  `offset` if not given. The list of GPT partitions, block devices and IDs are
-  listed by `fastboot getvar all`
+
+  This specifies range `[offset, offset+size)` in partition `part` on the
+  storage device with ID `storage_id`. `storage_id` is a hex string and
+  represents a unique integer ID assigned to each storage device detected
+  by GBL. The integer ID is for disambiguation purpose in case multiple storage
+  devices have same name partitions.  If `storage_id` is not given, GBL will
+  check if a default storage ID is set via
+  `fastboot oem gbl-set-default-block <storage_id>` and use the default ID if
+  set. If the default ID is not set, GBL will check that `part` can match to a
+  unique parition. Otherwise, it will be rejected. The default ID can be unset
+  via `fastboot oem gbl-unset-default-block`. `offset` and `size` must be a
+  64bit integer hex string. `offset` defaults to 0 if not given. `size`
+  defaults to the rest of the partition after `offset` if not given.
 
   Examples:
-  * `fastboot flash boot_a` -- Checks that `boot_a` is a unique GPT partition
-  among all storage devices and flashes in the entire range of the partition.
+  * `fastboot flash boot_a` -- If a default storage ID is set via
+    `fastboot oem gbl-set-default-block <default ID>`, flashes in the entire
+    range of partition `boot_a` on storage device `<default ID>`. If not,
+    checks that `boot_a` can match to a unique partition among all storage
+    devices and flashes to it.
   * `fastboot flash boot_a:0x0` or `boot_a:0` -- Flashes in the entire range of
-  GPT partition "boot_a" on block device 0.
-  * `fastboot flash boot_a:0:200` -- Flashes only in range `[512, end)` of GPT
-  partition "boot_a" on block device 0.
+    partition "boot_a" on storage device 0.
+  * `fastboot flash boot_a:0:200` -- Flashes only in range `[512, end)` of
+    partition "boot_a" on storage device 0.
   * `fastboot flash boot_a:0:200:200` -- Flashes only in range `[512, 1024)` of
-  GPT partition "boot_a" on block device 0.
-  * `fastboot flash boot_a:::` -- Same as `"boot_a"`.
+    partition "boot_a" on storage device 0.
+  * `fastboot flash boot_a:::` -- Same as `"fastboot flash boot_a"`.
+  * `fastboot flash boot_a::200:200` -- Same as `"fastboot flash boot_a:::"`,
+    except that it only flashes in range `[512, 1024)`
 
-* Raw storage
+* Raw storage devices by ID
   ```
-  :<block_id>
-  :<block_id>[:<offset>]
-  :<block_id>:[<offset>][:<size>]
+  :[<storage_id>]
+  :[<storage_id>][:<offset>]
+  :[<storage_id>][:<offset>][:<size>]
   ```
-  This is similar to the case of GPT partitions except that `part` is an empty
-  string and `block_id` is mandatory. It specifies range `[offset, offset+size)`
-  of the raw data on the block device with ID `block_id`. `offset` defaults to
-  0 if not given. `size` defaults to the rest of the storage after `offset` if
-  not given.
+
+  This is similar to the case of partition except that `part` is an empty
+  string. It specifies range`[offset, offset+size)` of the raw data on the
+  storage device with ID `storage_id`.  If `storage_id` is not given, GBL will
+  check if a default storage ID is set via
+  `fastboot oem gbl-set-default-block <storage_id>` and use the default ID if
+  set. Otherwise it is rejected. `offset` defaults to 0 if not given. `size`
+  defaults to the rest of the block after `offset` if not given. This semantic
+  applies to all storage devcies that can detected by GBL, whether or not it is
+  a raw storage partition or GPT device.
+
+  Examples:
+  * `fastboot flash :` -- If a default storage ID is set via
+    `fastboot oem gbl-set-default-block <default ID>`, flashes in the entire
+    range of storage device `<default ID>`.
+  * `fastboot flash :0x0` or `:0` -- Flashes in the entire range of storage
+    device 0.
+  * `fastboot flash :0:200` -- Flashes only in range `[512, end)` of storage
+    device 0.
+  * `fastboot flash :0:200:200` -- Flashes only in range `[512, 1024)` of
+    storage device 0.
+  * `fastboot flash :::` -- Same as `"fastboot flash :"`.
+  * `fastboot flash ::200:200` -- Same as `"fastboot flash :::"`, except that
+    it only flashes in range `[512, 1024)`
+
+## Non-blocking `fastboot flash`.
+
+If the UEFI firmware supports `EFI_BLOCK_IO2_PROTOCOL` for the storage devices,
+GBL Fastboot provides an option to make `fastboot flash` non-blocking.
+Specifically, after the image is downloaded, GBL Fastboot will launch a
+separate task in the background for writing the image to the device, while
+itself will continue to listen for the next Fastboot command from the host,
+including a new `fastboot flash` command. This provides some paralellism
+between downloading and flashing when the host is flashing multiple images.
+Example:
+
+```
+fastboot oem gbl-enable-async-block-io
+fastboot flash boot_a <image>
+fastboot flash boot_b <image>
+fastboot flash vendor_boot_a <image>
+...
+fastboot oem gbl-sync-blocks
+fastboot oem gbl-disable-async-block-io
+```
+
+If a storage device is busy processing a previous flash when a new image is
+downloaded and ready to be flashed, it will be blocked until the previous flash
+is completed. Different storage devices are independent to each other.
+
+Because IO is now non-blocking, the return status of a `fastboot flash` does
+not necessarily represents the status of the IO. If a storage device encounters
+errors while processing a non-blocking IO, all subsequent flash requests will
+be rejected and the host should reboot the device.
+`fastboot oem gbl-sync-blocks` can be used to wait until all currently pending
+flash are completed. The command returns error if any previous or current flash
+encounters errors.
diff --git a/gbl/docs/gbl_os_configuration_protocol.md b/gbl/docs/gbl_os_configuration_protocol.md
new file mode 100644
index 0000000..d0593aa
--- /dev/null
+++ b/gbl/docs/gbl_os_configuration_protocol.md
@@ -0,0 +1,181 @@
+# GBL OS Configuration EFI Protocol
+
+This document defines an EFI protocol for GBL which allows the device to
+apply runtime fixups to data passed into the OS.
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL
+
+### Summary
+
+This protocol provides a mechanism for the EFI firmware to modify OS
+configuration data:
+
+* kernel commandline
+* bootconfig
+* devicetree
+
+GBL will load and verify the base data from disk, and then call these protocol
+functions to give the firmware a chance to adjust the data as needed for the
+particular device.
+
+If no runtime modifications are necessary, this protocol may be left
+unimplemented.
+
+### GUID
+
+```c
+// {dda0d135-aa5b-42ff-85ac-e3ad6efb4619}
+#define GBL_EFI_OS_CONFIGURATION_PROTOCOL_GUID       \
+  {                                                  \
+    0xdda0d135, 0xaa5b, 0x42ff, {                    \
+      0x85, 0xac, 0xe3, 0xad, 0x6e, 0xfb, 0x46, 0x19 \
+    }                                                \
+  }
+```
+
+### Revision Number
+
+Note: revision 0 means the protocol is not yet stable and may change in
+backwards-incompatible ways.
+
+```c
+#define GBL_EFI_OS_CONFIGURATION_PROTOCOL_REVISION 0x00000000
+```
+
+### Protocol Interface Structure
+
+```c
+typedef struct GBL_EFI_OS_CONFIGURATION_PROTOCOL {
+  UINT64                              Revision;
+  GBL_FIXUP_ASCII_DATA                FixupKernelCommandline;
+  GBL_FIXUP_ASCII_DATA                FixupBootconfig;
+  GBL_FIXUP_DEVICETREE                FixupDevicetree;
+  GBL_FIXUP_ZBI                       FixupZbi;
+} GBL_EFI_OS_CONFIGURATION_PROTOCOL;
+```
+
+### Parameters
+
+#### Revision
+The revision to which the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` adheres. All
+future revisions must be backwards compatible. If a future version is not
+backwards compatible, a different GUID must be used.
+
+#### FixupKernelCommandline
+Applies kernel commandline fixups. See
+[`FixupKernelCommandline()`](#FixupKernelCommandline).
+
+#### FixupBootconfig
+Applies bootconfig fixups. See [`FixupBootconfig()`](#FixupBootconfig).
+
+#### FixupDevicetree
+Applies devicetree fixups. See [`FixupDevicetree()`](#FixupDevicetree).
+
+#### FixupZbi
+Applies ZBI fixups (Fuchsia kernels only). See [`FixupZbi()`](#FixupZbi).
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupKernelCommandline() {#FixupKernelCommandline}
+
+### Summary
+
+Applies runtime fixups to the kernel command line.
+
+### Prototype
+
+```c
+typedef EFI_STATUS (EFIAPI *GBL_FIXUP_ASCII_DATA)(
+  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL     *This,
+  IN OUT CHAR8                             *Data,
+  IN OUT UINTN                             *BufferSize
+);
+```
+
+### Parameters
+
+#### This
+A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
+
+#### Data
+A pointer to the ASCII nul-terminated data.
+
+The protocol can modify this data directly, with the following restrictions:
+* on return, the data must be valid ASCII encoding with nul termination
+* the data and termination byte must never exceed the provided `BufferSize`
+* no libavb arguments may be added, deleted, or modified (see Security below)
+
+Ownership of this data is loaned only for the duration of the function call, and
+must not be retained by the protocol after returning.
+
+#### BufferSize
+On function call, this contains the size of the command line buffer, which may
+be larger than the current command line contents. The implementation is free to
+grow the command line contents up to this size, including the termination byte.
+
+If the buffer is not large enough to fit the fixups, the function should update
+`BufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`; GBL will
+then allocate a larger buffer and re-call this function with the original
+un-modified command line.
+
+`BufferSize` does not need to be updated on success, GBL will determine the
+command line data size via the nul terminator.
+
+### Description
+
+GBL will call this function after loading and verifying the base kernel command
+line, to give the device an opportunity to supply any runtime fixups.
+
+Since the devicetree selection affects the base kernel command line, GBL will
+call `FixupDevicetree` first before calling `FixupKernelCommandline`.
+
+#### Security
+
+To ensure the integrity of verified boot data, this protocol will not be
+allowed to add, delete, or modify any command line parameters provided by
+[libavb](https://source.android.com/docs/security/features/verifiedboot/avb).
+If any of these parameters are modified, GBL will treat this as a failed boot
+attempt:
+* `androidboot.veritymode*`
+* `androidboot.vbmeta*`
+* `dm`
+* `root`
+
+Additionally, all data used to apply fixups to the command line must be trusted.
+In particular, if the protocol loads any data from non-secure storage, it should
+verify that data before use.
+
+### Status Codes Returned
+
+|||
+| ----------- | ----------- |
+| `EFI_SUCCESS` | Command line fixup completed. |
+| `EFI_INVALID_PARAMETER` | A parameter is invalid. |
+| `EFI_BUFFER_TOO_SMALL` | The buffer is too small; `BufferSize` has been updated with the required size. |
+| `EFI_DEVICE_ERROR` | Internal error while updating the command line. |
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootconfig() {#FixupBootconfig}
+
+### Summary
+
+GBL will call this function after loading and verifying the base bootconfig, to
+give the device an opportunity to supply any runtime modifications.
+
+### Description
+
+[Bootconfig](https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig)
+is very similar to the kernel command line, but the format is slightly
+different, and the contents are intended for user space consumption rather than
+kernel.
+
+This implementation only needs to update the bootconfig parameters, GBL will automatically update
+the bootconfig trailer metadata afterwards.
+
+This function's API, usage, and security guidelines are exactly identical to
+[`FixupKernelCommandline`](#FixupKernelCommandline); see those docs for details.
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupDevicetree() {#FixupDevicetree}
+
+TODO(b/353272981)
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupZbi() {#FixupZbi}
+
+TODO(b/353272981)
diff --git a/gbl/docs/partitions.md b/gbl/docs/partitions.md
new file mode 100644
index 0000000..cc3e174
--- /dev/null
+++ b/gbl/docs/partitions.md
@@ -0,0 +1,51 @@
+# Partitions in GBL
+
+This document describes how GBL defines and handles partitions on mass storage
+devices.
+
+## Definition of Partition
+
+In GBL, all EFI devices that implement either the `EFI_BLOCK_IO_PROTOCOL` or
+`EFI_BLOCK_IO2_PROTOCOL` protocols are considered storage devices that may
+contain necessary data for GBL to access. For each of this device, GBL supports
+two schemes of partition:
+
+1. Entire raw storage as a partition.
+
+   This scheme treats the entire storage device as a single partition. For
+   storage devices intended to be used according to this scheme, the device
+   need to provide an instance of device path that ends with the GBL
+   "Vendor-Defined Media Device Path" defined as follows.
+
+   | Mnemonic | Bytes Offset | Bytes Length | Description |
+   | ----------- | ----------- | ----------- | ----------- |
+   | Type | 0 | 1 | Type 4-Media Device Path. |
+   | Sub-Type | 1 | 1 | Sub-Type 3 - Vendor. |
+   | Length | 2 | 2 | Length of this structure in bytes. Length is 92 bytes. |
+   | Vendor GUID | 4 | 16 | The `GBL_VENDOR_MEDIA_DEVICE_PATH_GUID` GUID defined below. |
+   | Vendor Defined Data | 20 | 72 | Null-terminated ASCII partition name. |
+
+   ```c
+   // {a09773e3-0xf027-0x4f33-adb3-bd8dcf4b3854}
+   #define GBL_VENDOR_MEDIA_DEVICE_PATH_GUID           \
+     {                                                  \
+       0xa09773e3, 0xf027, 0x4f33, {                    \
+         0xad, 0xb3, 0xbd, 0x8d, 0xcf, 0x4b, 0x38, 0x54 \
+       }                                                \
+     }
+   ```
+
+   The partition will be identified using the null-terminated ASCII name from
+   the device path in the context of booting and fastboot.
+
+
+2. UEFI GUID Partition Table (GPT)
+
+   For all other storage devices that doesn't have an instance of GBL
+   vendor-defined media device path, GBL considers them to be using the GPT
+   partition scheme defined in the UEFI spec. Each partition will be identified
+   using its corresponding GPT partition name in the context of booting and
+   fastboot.
+
+Because partitions are identified by their names in fastboot. They cannot
+contain character `":"`.
diff --git a/gbl/efi/BUILD b/gbl/efi/BUILD
index db28634..51d7dba 100644
--- a/gbl/efi/BUILD
+++ b/gbl/efi/BUILD
@@ -13,82 +13,133 @@
 # limitations under the License.
 
 load("@gbl//toolchain:gbl_toolchain.bzl", "build_with_platform")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@gbl_llvm_prebuilts//:info.bzl", "gbl_llvm_tool_path")
-load("@rules_rust//rust:defs.bzl", "rust_binary")
+load("@rules_rust//rust:defs.bzl", "rust_binary", "rust_library", "rust_test")
 
 package(
     default_visibility = ["//visibility:public"],
 )
 
-rust_binary(
-    name = "main",
-    srcs = [
-        "src/android_boot.rs",
-        "src/avb.rs",
-        "src/error.rs",
-        "src/fastboot.rs",
-        "src/fuchsia_boot.rs",
-        "src/main.rs",
-        "src/net.rs",
-        "src/riscv64.rs",
-        "src/utils.rs",
-    ],
-    linker_script = select({
-        "@gbl//toolchain:gbl_rust_elf_riscv64": "@gbl//efi/arch/riscv64:riscv64_efi.lds",
-        "//conditions:default": None,
-    }),
-    rustc_flags = [
-        "-C",
-        "panic=abort",
-    ],
+rust_library(
+    name = "libgbl_efi",
+    srcs = glob(["src/**/*.rs"]),
+    crate_name = "gbl_efi",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         "@avb",
         "@avb//:avb_crypto_ops_sha_impl_staticlib",
+        "@gbl//libasync",
+        "@gbl//libasync:cyclic_executor",
         "@gbl//libavb:sysdeps",
         "@gbl//libboot",
         "@gbl//libbootconfig",
         "@gbl//libbootimg",
+        "@gbl//libdttable",
         "@gbl//libefi",
+        "@gbl//libefi_types",
+        "@gbl//liberror",
         "@gbl//libfastboot",
         "@gbl//libfdt",
         "@gbl//libgbl",
         "@gbl//libmisc",
+        "@gbl//libsafemath",
         "@gbl//libstorage",
         "@gbl//third_party/libzbi",
         "@smoltcp",
+        "@spin",
         "@uuid",
         "@zerocopy",
-    ] + select({
-        "@gbl//toolchain:gbl_rust_elf_riscv64": ["@gbl//efi/arch/riscv64:efi_arch_deps_riscv64"],
-        "@gbl//toolchain:gbl_rust_uefi_x86_64": ["@gbl//efi/arch/x86_64:efi_arch_deps_x86_64"],
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["@gbl//efi/arch/x86:efi_arch_deps_x86"],
-        "//conditions:default": [],
-    }),
+    ] + select(
+        {
+            "@gbl//toolchain:gbl_rust_uefi_aarch64": [
+                "@gbl//efi/arch/aarch64",
+            ],
+            "//conditions:default": [],
+        },
+    ),
+)
+
+rust_test(
+    name = "test",
+    crate = ":libgbl_efi",
+    # TODO(b/355436086): mock out the rest of the libefi APIs and
+    # remove dead-code; for now it would require a lot of invasive
+    # code changes to selectively disable things on tests so this
+    # is worth it to keep things more readable.
+    rustc_flags = ANDROID_RUST_LINTS + [
+        "-A",
+        "dead-code",
+    ],
+    deps = [
+        "@gbl//libefi:mocks",
+        "@mockall",
+    ],
+)
+
+# The UEFI application target.
+#
+# Almost all logic should be in the libgbl_efi target; this contains only the
+# things that would prevent unittesting such as global allocation hooks or
+# target-specific compiler dependencies.
+rust_binary(
+    name = "app",
+    srcs = glob(["app/**/*.rs"]),
+    linker_script = select(
+        {
+            "@gbl//toolchain:gbl_rust_elf_riscv64": "@gbl//efi/arch/riscv64:riscv64_efi.lds",
+            "//conditions:default": None,
+        },
+    ),
+    rustc_flags = ANDROID_RUST_LINTS + [
+        "-C",
+        "panic=abort",
+    ],
+    deps = [
+        ":libgbl_efi",
+        "@gbl//libefi",
+        "@gbl//libefi_types",
+    ] + select(
+        {
+            "@gbl//toolchain:gbl_rust_elf_riscv64": [
+                "@gbl//efi/arch/riscv64:efi_arch_deps_riscv64",
+            ],
+            "//conditions:default": [],
+        },
+    ),
 )
 
 genrule(
     name = "gbl_efi",
-    srcs = [":main"],
+    srcs = [":app"],
     outs = ["gbl.efi"],
-    cmd = select({
-        # For RISCV target, existing toolchain can only generate ELF format image.
-        # The current solution is to manually add a PE/COFF header at image
-        # start and use objcopy to remove the ELF header to make it a PE/COFF image.
-        # Also use `elf_static_relocation_checker` to check that our relocation library
-        # can handle all the generated relocation types. The following expands to two commands:
-        #
-        # 1. `llvm-objcopy <elf image> -O binary <efi image>`
-        # 2. `elf_static_relocation_checker <elf image> <efi image>`
-        "@gbl//toolchain:gbl_rust_elf_riscv64": """
-            {} -O binary $(location @gbl//efi:main) $(OUTS) && \\
+    cmd = select(
+        {
+            # For RISCV target, existing toolchain can only generate ELF format image.
+            # The current solution is to manually add a PE/COFF header at image
+            # start and use objcopy to remove the ELF header to make it a PE/COFF image.
+            # Also use `elf_static_relocation_checker` to check that our relocation library
+            # can handle all the generated relocation types. The following expands to two commands:
+            #
+            # 1. `llvm-objcopy <elf image> -O binary <efi image>`
+            # 2. `elf_static_relocation_checker <elf image> <efi image>`
+            "@gbl//toolchain:gbl_rust_elf_riscv64": """
+            {} -O binary $(location @gbl//efi:app) $(OUTS) && \\
             $(location @gbl//libelf:elf_static_relocation_checker) $(SRCS) $(OUTS)
-        """.format(gbl_llvm_tool_path("llvm-objcopy")),
-        "//conditions:default": "cp $(SRCS) $(OUTS)",
-    }),
-    tools = select({
-        "@gbl//toolchain:gbl_rust_elf_riscv64": ["@gbl//libelf:elf_static_relocation_checker"],
-        "//conditions:default": [],
-    }),
+        """.format(
+                gbl_llvm_tool_path("llvm-objcopy"),
+            ),
+            "//conditions:default": "cp $(SRCS) $(OUTS)",
+        },
+    ),
+    tools = select(
+        {
+            "@gbl//toolchain:gbl_rust_elf_riscv64": [
+                "@gbl//libelf:elf_static_relocation_checker",
+            ],
+            "//conditions:default": [],
+        },
+    ),
 )
 
 build_with_platform(
diff --git a/gbl/efi/app/main.rs b/gbl/efi/app/main.rs
new file mode 100644
index 0000000..00ee301
--- /dev/null
+++ b/gbl/efi/app/main.rs
@@ -0,0 +1,53 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! The GBL UEFI application.
+//!
+//! This just contains the minimal entry point and global hook declarations
+//! needed for a full application build; all the logic should go in the
+//! `gbl_efi` library instead.
+
+#![no_std]
+#![no_main]
+
+#[cfg(target_arch = "riscv64")]
+mod riscv64;
+
+use core::{ffi::c_void, panic::PanicInfo};
+use efi::{initialize, panic, EfiAllocator};
+use efi_types::EfiSystemTable;
+use gbl_efi::app_main;
+
+#[panic_handler]
+fn handle_panic(p_info: &PanicInfo) -> ! {
+    panic(p_info)
+}
+
+#[no_mangle]
+#[global_allocator]
+static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::Uninitialized;
+
+/// EFI application entry point. Does not return.
+///
+/// # Safety
+/// `image_handle` and `systab_ptr` must be valid objects that adhere to the UEFI specification.
+#[no_mangle]
+pub unsafe extern "C" fn efi_main(image_handle: *mut c_void, systab_ptr: *mut EfiSystemTable) {
+    // SAFETY:
+    // * caller provides valid `image_handle` and `systab_ptr` objects
+    // * we only call `initialize()` once
+    let entry = unsafe { initialize(image_handle, systab_ptr) }.unwrap();
+    app_main(entry).unwrap();
+    loop {}
+}
diff --git a/gbl/efi/src/riscv64.rs b/gbl/efi/app/riscv64.rs
similarity index 100%
rename from gbl/efi/src/riscv64.rs
rename to gbl/efi/app/riscv64.rs
diff --git a/gbl/efi/arch/x86_64/BUILD b/gbl/efi/arch/aarch64/BUILD
similarity index 51%
rename from gbl/efi/arch/x86_64/BUILD
rename to gbl/efi/arch/aarch64/BUILD
index 5dda42e..ee78561 100644
--- a/gbl/efi/arch/x86_64/BUILD
+++ b/gbl/efi/arch/aarch64/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,19 +12,31 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
     default_visibility = ["//visibility:public"],
 )
 
-cc_library(
-    name = "lib_efi_arch_deps_x86_64",
-    srcs = ["deps.S"],
-    visibility = ["//visibility:public"],
+rust_library(
+    name = "aarch64",
+    srcs = glob(["src/**/*.rs"]),
+    crate_name = "gbl_efi_aarch64",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//liberror",
+        "@gbl//libgbl",
+        "@lz4_flex",
+        "@zune_inflate",
+    ],
 )
 
-link_static_cc_library(
-    name = "efi_arch_deps_x86_64",
-    cc_library = ":lib_efi_arch_deps_x86_64",
+rust_test(
+    name = "test",
+    crate = ":aarch64",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libefi:mocks",
+    ],
 )
diff --git a/gbl/efi/arch/aarch64/src/lib.rs b/gbl/efi/arch/aarch64/src/lib.rs
new file mode 100644
index 0000000..51d7059
--- /dev/null
+++ b/gbl/efi/arch/aarch64/src/lib.rs
@@ -0,0 +1,114 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! ARM-specific library for GBL EFI application.
+#![cfg_attr(not(test), no_std)]
+
+// Decompression is done on the heap
+extern crate alloc;
+
+use liberror::{Error, Result};
+use libgbl::{gbl_print, gbl_println, GblOps};
+use lz4_flex::decompress_into;
+use zune_inflate::DeflateDecoder;
+
+/// Decompresses the given kernel if necessary
+///
+/// The possibly-compressed kernel starts in `buffer`. If it's compressed, it will be decompressed
+/// using heap memory and then copied back into the end of `buffer`.
+///
+/// # Returns
+/// The offset of the decompressed kernel in `buffer`. If the kernel was not compressed. this
+/// function is a no-op and will return `kernel_start` unchanged.
+pub fn decompress_kernel<'a>(
+    ops: &mut impl GblOps<'a>,
+    buffer: &mut [u8],
+    kernel_start: usize,
+) -> Result<usize> {
+    if buffer[kernel_start..kernel_start + 2] == [0x1f, 0x8b] {
+        gbl_println!(ops, "kernel is gzip compressed");
+        let mut decoder = DeflateDecoder::new(&buffer[kernel_start..]);
+        let decompressed_data = match decoder.decode_gzip() {
+            Ok(decompressed_data) => decompressed_data,
+            _ => {
+                return Err(Error::InvalidInput.into());
+            }
+        };
+        gbl_println!(ops, "kernel decompressed size {}", decompressed_data.len());
+        let kernel_start = buffer.len() - decompressed_data.len();
+        // Move decompressed data to slice.
+        buffer[kernel_start..].clone_from_slice(&decompressed_data);
+        Ok(kernel_start)
+    } else if buffer[kernel_start..kernel_start + 4] == [0x02, 0x21, 0x4c, 0x18] {
+        gbl_println!(ops, "kernel is lz4 compressed");
+        let kernel_tail_buffer = &buffer[kernel_start..];
+        let mut contents = &kernel_tail_buffer[4..];
+        let mut decompressed_kernel = alloc::vec::Vec::new();
+        loop {
+            if contents.len() < 4 {
+                if contents.len() != 0 {
+                    gbl_println!(ops, "Error: some leftover data in the content");
+                }
+                break;
+            }
+            let block_size: usize =
+                u32::from_le_bytes(contents[0..4].try_into().unwrap()).try_into().unwrap();
+            let block;
+            (block, contents) = contents.split_at(block_size + 4);
+            let block = &block[4..];
+            // extend decompressed kernel buffer by 8MB
+            let decompressed_kernel_len = decompressed_kernel.len();
+            decompressed_kernel.resize(decompressed_kernel_len + 8 * 1024 * 1024, 0);
+            // decompress the block
+            let decompressed_data_size =
+                decompress_into(&block, &mut decompressed_kernel[decompressed_kernel_len..])
+                    .unwrap();
+            // reduce the size of decompressed kernel buffer
+            decompressed_kernel.resize(decompressed_kernel_len + decompressed_data_size, 0);
+        }
+        gbl_println!(ops, "kernel decompressed size {}", decompressed_kernel.len());
+        let kernel_start = buffer.len() - decompressed_kernel.len();
+        // Move decompressed data to slice
+        buffer[kernel_start..].clone_from_slice(&decompressed_kernel);
+        Ok(kernel_start)
+    } else {
+        Ok(kernel_start)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use efi_mocks::MockEfi;
+
+    #[test]
+    fn ops_write_trait() {
+        let mut mock_efi = MockEfi::new();
+        let installed = mock_efi.install();
+
+        let original_data = "Test TTTTTTTTT 123";
+        let compressed_data = [
+            0x02, 0x21, 0x4c, 0x18, 0x0f, 0x00, 0x00, 0x00, 0x63, 0x54, 0x65, 0x73, 0x74, 0x20,
+            0x54, 0x01, 0x00, 0x50, 0x54, 0x20, 0x31, 0x32, 0x33,
+        ];
+
+        let buffer = vec![0u8; 8 * 1024];
+        // Copy compressed data somewhere in buffer.
+        buffer[buffer.len() - compressed_data.len()..].clone_from_slice(compressed_data);
+
+        let offset =
+            decompress_kernel(installed.entry(), buffer, buffer.len() - compressed_data.len());
+        assert_eq!(buffer[offset..], original_data);
+    }
+}
diff --git a/gbl/efi/arch/riscv64/deps.cpp b/gbl/efi/arch/riscv64/deps.cpp
index 3ce5be4..23b3317 100644
--- a/gbl/efi/arch/riscv64/deps.cpp
+++ b/gbl/efi/arch/riscv64/deps.cpp
@@ -14,62 +14,12 @@
  * limitations under the License.
  */
 
-#include <stddef.h>
 #include <stdint.h>
 
 #include "elf/relocation.h"
 
-// Following are naive implementations of functions in <string.h> that are not
-// provided by the toolchain for RISC-V targets. They are simply for getting
-// compilation passed and not necessarily optimzied.
 extern "C" {
 
-int memcmp(const void* s1, const void* s2, size_t count) {
-  const uint8_t* left = static_cast<const uint8_t*>(s1);
-  const uint8_t* right = static_cast<const uint8_t*>(s2);
-  for (size_t i = 0; i < count; i++) {
-    if (left[i] == right[i]) {
-      continue;
-    }
-    return left[i] < right[i] ? -1 : 1;
-  }
-  return 0;
-}
-
-void* memmove(void* dest, void const* src, size_t count) {
-  uint8_t* _dest = static_cast<uint8_t*>(dest);
-  const uint8_t* _src = static_cast<const uint8_t*>(src);
-  if (dest < src) {
-    for (size_t i = 0; i < count; i++) {
-      _dest[i] = _src[i];
-    }
-  } else {
-    for (size_t i = count; i > 0; i--) {
-      _dest[i - 1] = _src[i - 1];
-    }
-  }
-  return dest;
-}
-
-size_t strlen(const char* str) {
-  size_t i = 0;
-  for (; str[i] != 0; i++) {
-  }
-  return i;
-}
-
-void* memset(void* ptr, int value, size_t num) {
-  uint8_t* start = static_cast<uint8_t*>(ptr);
-  for (size_t i = 0; i < num; i++) {
-    start[i] = value;
-  }
-  return ptr;
-}
-
-void* memcpy(void* dest, const void* src, size_t num) {
-  return memmove(dest, src, num);
-}
-
 void ApplyRelocationHangIfFail(uintptr_t program_base, uintptr_t dynamic_section) {
   if (!ApplyRelocation(program_base, dynamic_section)) {
     while (true) {
diff --git a/gbl/efi/arch/riscv64/riscv64_efi_header.S b/gbl/efi/arch/riscv64/riscv64_efi_header.S
index a1fc5d4..bdb7880 100644
--- a/gbl/efi/arch/riscv64/riscv64_efi_header.S
+++ b/gbl/efi/arch/riscv64/riscv64_efi_header.S
@@ -179,13 +179,13 @@ _start:
   // Behave like a function call.
   addi sp, sp, -8*3
   sd ra, 0(sp)
-  sd t0, 8(sp)
-  sd t1, 16(sp)
+  sd s0, 8(sp)
+  sd s1, 16(sp)
 
   // Save the EFI image handle from a0
-  mv t0, a0
+  mv s0, a0
   // Save the EFI system table from a1
-  mv t1, a1
+  mv s1, a1
 
   // Get the program load address (same as dos_header), and .dynamic section address.
   lla a0, dos_header
@@ -194,13 +194,13 @@ _start:
   call ApplyRelocationHangIfFail
 
   // Now call efi_main.
-  mv a0, t0
-  mv a1, t1
+  mv a0, s0
+  mv a1, s1
   call efi_main
 
   // Prepare to return.
   ld ra, 0(sp)
-  ld t0, 8(sp)
-  ld t1, 16(sp)
+  ld s0, 8(sp)
+  ld s1, 16(sp)
   add sp, sp, 8*3
   ret
diff --git a/gbl/efi/src/android_boot.rs b/gbl/efi/src/android_boot.rs
index 5576a34..c8f023f 100644
--- a/gbl/efi/src/android_boot.rs
+++ b/gbl/efi/src/android_boot.rs
@@ -12,48 +12,67 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use core::ffi::CStr;
-use core::fmt::Write;
-use core::str::from_utf8;
-
-use bootconfig::{BootConfigBuilder, BootConfigError};
+use crate::{
+    avb::GblEfiAvbOps,
+    efi_blocks::find_block_devices,
+    ops::Ops,
+    utils::{aligned_subslice, cstr_bytes_to_str},
+};
+use avb::{slot_verify, HashtreeErrorMode, Ops as _, SlotVerifyFlags};
+use bootconfig::BootConfigBuilder;
 use bootimg::{BootImage, VendorImageHeader};
-use efi::{efi_print, efi_println, exit_boot_services, EfiEntry};
+use core::cmp::max;
+use core::{ffi::CStr, fmt::Write, str::from_utf8};
+use efi::{exit_boot_services, EfiEntry};
 use fdt::Fdt;
-use gbl_storage::AsMultiBlockDevices;
+use liberror::Error;
+use libgbl::{gbl_print, gbl_println, GblOps, IntegrationError, Result};
 use misc::{AndroidBootMode, BootloaderMessage};
+use safemath::SafeNum;
+use zerocopy::{AsBytes, ByteSlice};
 
-use crate::error::{EfiAppError, GblEfiError, Result};
-use crate::utils::{
-    aligned_subslice, cstr_bytes_to_str, find_gpt_devices, get_efi_fdt, usize_add, usize_roundup,
-    EfiMultiBlockDevices,
-};
-
-use crate::avb::GblEfiAvbOps;
-use avb::{slot_verify, HashtreeErrorMode, Ops, SlotVerifyFlags};
+#[cfg(target_arch = "aarch64")]
+use gbl_efi_aarch64::decompress_kernel;
 
 // Linux kernel requires 2MB alignment.
 const KERNEL_ALIGNMENT: usize = 2 * 1024 * 1024;
 // libfdt requires FDT buffer to be 8-byte aligned.
 const FDT_ALIGNMENT: usize = 8;
 
-/// A helper macro for creating a null-terminated string literal as CStr.
-macro_rules! cstr_literal {
-    ( $( $x:expr ),* $(,)?) => {
-       CStr::from_bytes_until_nul(core::concat!($($x),*, "\0").as_bytes()).unwrap()
-    };
-}
-
 /// Helper function for performing libavb verification.
-fn avb_verify_slot<'a, 'b, 'c>(
-    gpt_dev: &'b mut EfiMultiBlockDevices,
-    kernel: &'b [u8],
-    vendor_boot: &'b [u8],
-    init_boot: &'b [u8],
-    bootconfig_builder: &'b mut BootConfigBuilder<'c>,
+///
+/// Currently this requires the caller to preload all relevant images from disk; in its final
+/// state `ops` will provide the necessary callbacks for where the images should go in RAM and
+/// which ones are preloaded.
+///
+/// # Arguments
+/// * `ops`: [GblOps] providing device-specific backend.
+/// * `kernel`: buffer containing the `boot` image loaded from disk.
+/// * `vendor_boot`: buffer containing the `vendor_boot` image loaded from disk.
+/// * `init_boot`: buffer containing the `init_boot` image loaded from disk.
+/// * `dtbo`: buffer containing the `dtbo` image loaded from disk, if it exists.
+/// * `bootconfig_builder`: object to write the bootconfig data into.
+///
+/// # Returns
+/// `()` on success, error if the images fail to verify or we fail to update the bootconfig.
+fn avb_verify_slot<'a>(
+    ops: &mut impl GblOps<'a>,
+    kernel: &[u8],
+    vendor_boot: &[u8],
+    init_boot: &[u8],
+    dtbo: Option<&[u8]>,
+    bootconfig_builder: &mut BootConfigBuilder,
 ) -> Result<()> {
-    let preloaded = [("boot", kernel), ("vendor_boot", vendor_boot), ("init_boot", init_boot)];
-    let mut avb_ops = GblEfiAvbOps::new(gpt_dev, Some(&preloaded));
+    let mut partitions = vec![c"boot", c"vendor_boot", c"init_boot"];
+    let mut preloaded =
+        vec![("boot", kernel), ("vendor_boot", vendor_boot), ("init_boot", init_boot)];
+
+    if let Some(dtbo) = dtbo {
+        partitions.push(c"dtbo");
+        preloaded.push(("dtbo", dtbo));
+    }
+
+    let mut avb_ops = GblEfiAvbOps::new(ops, Some(&preloaded));
     let avb_state = match avb_ops.read_is_device_unlocked()? {
         true => "orange",
         _ => "green",
@@ -61,25 +80,101 @@ fn avb_verify_slot<'a, 'b, 'c>(
 
     let res = slot_verify(
         &mut avb_ops,
-        &[cstr_literal!("boot"), cstr_literal!("vendor_boot"), cstr_literal!("init_boot")],
-        Some(cstr_literal!("_a")),
+        &partitions,
+        Some(c"_a"),
         SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
         // For demo, we use the same setting as Cuttlefish u-boot.
         HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
     )
-    .map_err(|e| Into::<GblEfiError>::into(e.without_verify_data()))?;
+    .map_err(|e| IntegrationError::from(e.without_verify_data()))?;
 
     // Append avb generated bootconfig.
     for cmdline_arg in res.cmdline().to_str().unwrap().split(' ') {
-        write!(bootconfig_builder, "{}\n", cmdline_arg).map_err(|_| EfiAppError::BufferTooSmall)?;
+        write!(bootconfig_builder, "{}\n", cmdline_arg).or(Err(Error::BufferTooSmall(None)))?;
     }
 
     // Append "androidboot.verifiedbootstate="
     write!(bootconfig_builder, "androidboot.verifiedbootstate={}\n", avb_state)
-        .map_err(|_| EfiAppError::BufferTooSmall)?;
+        .or(Err(Error::BufferTooSmall(None)))?;
     Ok(())
 }
 
+/// Helper function to parse common fields from boot image headers.
+///
+/// # Returns
+///
+/// Returns a tuple of 6 slices corresponding to:
+/// (kernel_size, cmdline, page_size, ramdisk_size, second_size, dtb_size)
+fn boot_header_elements<B: ByteSlice + PartialEq>(
+    hdr: &BootImage<B>,
+) -> Result<(usize, &[u8], usize, usize, usize, usize)> {
+    const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
+    Ok(match hdr {
+        BootImage::V2(ref hdr) => {
+            let kernel_size = hdr._base._base.kernel_size as usize;
+            let page_size = hdr._base._base.page_size as usize;
+            let ramdisk_size = hdr._base._base.ramdisk_size as usize;
+            let second_size = hdr._base._base.second_size as usize;
+            let dtb_size = hdr.dtb_size as usize;
+            (
+                kernel_size,
+                &hdr._base._base.cmdline[..],
+                page_size,
+                ramdisk_size,
+                second_size,
+                dtb_size,
+            )
+        }
+        BootImage::V3(ref hdr) => {
+            (hdr.kernel_size as usize, &hdr.cmdline[..], PAGE_SIZE, hdr.ramdisk_size as usize, 0, 0)
+        }
+        BootImage::V4(ref hdr) => (
+            hdr._base.kernel_size as usize,
+            &hdr._base.cmdline[..],
+            PAGE_SIZE,
+            hdr._base.ramdisk_size as usize,
+            0,
+            0,
+        ),
+        _ => {
+            return Err(Error::UnsupportedVersion.into());
+        }
+    })
+}
+
+/// Helper function to parse common fields from vendor image headers.
+///
+/// # Returns
+///
+/// Returns a tuple of 5 slices corresponding to:
+/// (vendor_ramdisk_size, hdr_size, cmdline, page_size, dtb_size)
+fn vendor_header_elements<B: ByteSlice + PartialEq>(
+    hdr: &VendorImageHeader<B>,
+) -> Result<(usize, usize, &[u8], usize, usize)> {
+    Ok(match hdr {
+        VendorImageHeader::V3(ref hdr) => (
+            hdr.vendor_ramdisk_size as usize,
+            SafeNum::from(hdr.bytes().len())
+                .round_up(hdr.page_size)
+                .try_into()
+                .map_err(Error::from)?,
+            &hdr.cmdline.as_bytes(),
+            hdr.page_size as usize,
+            hdr.dtb_size as usize,
+        ),
+        VendorImageHeader::V4(ref hdr) => (
+            hdr._base.vendor_ramdisk_size as usize,
+            SafeNum::from(hdr.bytes().len())
+                .round_up(hdr._base.page_size)
+                .try_into()
+                .map_err(Error::from)?,
+            &hdr._base.cmdline.as_bytes(),
+            hdr._base.page_size as usize,
+            hdr._base.dtb_size as usize,
+        ),
+    })
+}
+
 /// Loads Android images from disk and fixes up bootconfig, commandline, and FDT.
 ///
 /// A number of simplifications are made:
@@ -89,73 +184,76 @@ fn avb_verify_slot<'a, 'b, 'c>(
 ///   * Only support V3/V4 image and Android 13+ (generic ramdisk from the "init_boot" partition)
 ///   * Only support booting recovery from boot image
 ///
-/// # Returns
+/// # Arguments
+/// * `ops`: the [GblOps] object providing platform-specific backends.
+/// * `load`: the combined buffer to load all images into.
 ///
+/// # Returns
 /// Returns a tuple of 4 slices corresponding to:
 ///   (ramdisk load buffer, FDT load buffer, kernel load buffer, unused buffer).
-pub fn load_android_simple<'a>(
-    efi_entry: &EfiEntry,
+pub fn load_android_simple<'a, 'b>(
+    ops: &mut impl GblOps<'b>,
     load: &'a mut [u8],
 ) -> Result<(&'a mut [u8], &'a mut [u8], &'a mut [u8], &'a mut [u8])> {
-    let mut gpt_devices = find_gpt_devices(efi_entry)?;
-
     const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
 
     let (bcb_buffer, load) = load.split_at_mut(BootloaderMessage::SIZE_BYTES);
-    gpt_devices.read_gpt_partition("misc", 0, bcb_buffer)?;
+    ops.read_from_partition_sync("misc", 0, bcb_buffer)?;
     let bcb = BootloaderMessage::from_bytes_ref(bcb_buffer)?;
     let boot_mode = bcb.boot_mode()?;
-    efi_println!(efi_entry, "boot mode from BCB: {}", boot_mode);
+    gbl_println!(ops, "boot mode from BCB: {}", boot_mode);
 
     // Parse boot header.
     let (boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
-    gpt_devices.read_gpt_partition("boot_a", 0, boot_header_buffer)?;
-    let boot_header = BootImage::parse(boot_header_buffer)?;
-    let (kernel_size, cmdline, kernel_hdr_size) = match boot_header {
-        BootImage::V3(ref hdr) => (hdr.kernel_size as usize, &hdr.cmdline[..], PAGE_SIZE),
-        BootImage::V4(ref hdr) => {
-            (hdr._base.kernel_size as usize, &hdr._base.cmdline[..], PAGE_SIZE)
-        }
-        _ => {
-            efi_println!(efi_entry, "V0/V1/V2 images are not supported");
-            return Err(GblEfiError::EfiAppError(EfiAppError::Unsupported));
-        }
-    };
-    efi_println!(efi_entry, "boot image size: {}", kernel_size);
-    efi_println!(efi_entry, "boot image cmdline: \"{}\"", from_utf8(cmdline).unwrap());
+    ops.read_from_partition_sync("boot_a", 0, boot_header_buffer)?;
+    let boot_header = BootImage::parse(boot_header_buffer).map_err(Error::from)?;
+    let (kernel_size, cmdline, kernel_hdr_size, boot_ramdisk_size, boot_second_size, boot_dtb_size) =
+        boot_header_elements(&boot_header)?;
+    gbl_println!(ops, "boot image size: {}", kernel_size);
+    gbl_println!(ops, "boot image cmdline: \"{}\"", from_utf8(cmdline).unwrap());
+    gbl_println!(ops, "boot ramdisk size: {}", boot_ramdisk_size);
+    gbl_println!(ops, "boot dtb size: {}", boot_dtb_size);
 
     // Parse vendor boot header.
     let (vendor_boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
-    gpt_devices.read_gpt_partition("vendor_boot_a", 0, vendor_boot_header_buffer)?;
-    let vendor_boot_header = VendorImageHeader::parse(vendor_boot_header_buffer)?;
-    let (vendor_ramdisk_size, vendor_hdr_size, vendor_cmdline) = match vendor_boot_header {
-        VendorImageHeader::V3(ref hdr) => (
-            hdr.vendor_ramdisk_size as usize,
-            usize_roundup(hdr.bytes().len(), hdr.page_size)?,
-            &hdr.cmdline[..],
-        ),
-        VendorImageHeader::V4(ref hdr) => (
-            hdr._base.vendor_ramdisk_size as usize,
-            usize_roundup(hdr.bytes().len(), hdr._base.page_size)?,
-            &hdr._base.cmdline[..],
-        ),
+    ops.read_from_partition_sync("vendor_boot_a", 0, vendor_boot_header_buffer)?;
+    let vendor_boot_header =
+        VendorImageHeader::parse(vendor_boot_header_buffer).map_err(Error::from)?;
+    let (vendor_ramdisk_size, vendor_hdr_size, vendor_cmdline, vendor_page_size, vendor_dtb_size) =
+        vendor_header_elements(&vendor_boot_header)?;
+    gbl_println!(ops, "vendor ramdisk size: {}", vendor_ramdisk_size);
+    gbl_println!(ops, "vendor cmdline: \"{}\"", from_utf8(vendor_cmdline).unwrap());
+    gbl_println!(ops, "vendor dtb size: {}", vendor_dtb_size);
+
+    let (dtbo_buffer, load) = match ops.partition_size("dtbo_a") {
+        Ok(Some(sz)) => {
+            let (dtbo_buffer, load) =
+                aligned_subslice(load, FDT_ALIGNMENT)?.split_at_mut(sz.try_into().unwrap());
+            ops.read_from_partition_sync("dtbo_a", 0, dtbo_buffer)?;
+            (Some(dtbo_buffer), load)
+        }
+        _ => (None, load),
     };
-    efi_println!(efi_entry, "vendor ramdisk size: {}", vendor_ramdisk_size);
-    efi_println!(efi_entry, "vendor cmdline: \"{}\"", from_utf8(vendor_cmdline).unwrap());
 
     // Parse init_boot header
     let init_boot_header_buffer = &mut load[..PAGE_SIZE];
-    gpt_devices.read_gpt_partition("init_boot_a", 0, init_boot_header_buffer)?;
-    let init_boot_header = BootImage::parse(init_boot_header_buffer)?;
-    let (generic_ramdisk_size, init_boot_hdr_size) = match init_boot_header {
-        BootImage::V3(ref hdr) => (hdr.ramdisk_size as usize, PAGE_SIZE),
-        BootImage::V4(ref hdr) => (hdr._base.ramdisk_size as usize, PAGE_SIZE),
-        _ => {
-            efi_println!(efi_entry, "V0/V1/V2 images are not supported");
-            return Err(GblEfiError::EfiAppError(EfiAppError::Unsupported));
+    let (generic_ramdisk_size, init_boot_hdr_size) = match ops.partition_size("init_boot_a") {
+        Ok(Some(_sz)) => {
+            ops.read_from_partition_sync("init_boot_a", 0, init_boot_header_buffer)?;
+            let init_boot_header =
+                BootImage::parse(init_boot_header_buffer).map_err(Error::from)?;
+            match init_boot_header {
+                BootImage::V3(ref hdr) => (hdr.ramdisk_size as usize, PAGE_SIZE),
+                BootImage::V4(ref hdr) => (hdr._base.ramdisk_size as usize, PAGE_SIZE),
+                _ => {
+                    gbl_println!(ops, "V0/V1/V2 images are not supported");
+                    return Err(Error::UnsupportedVersion.into());
+                }
+            }
         }
+        _ => (0, 0),
     };
-    efi_println!(efi_entry, "init_boot image size: {}", generic_ramdisk_size);
+    gbl_println!(ops, "init_boot image size: {}", generic_ramdisk_size);
 
     // Load and prepare various images.
     let images_buffer = aligned_subslice(load, KERNEL_ALIGNMENT)?;
@@ -166,49 +264,71 @@ pub fn load_android_simple<'a>(
     // memory overlapping with ramdisk. We place kernel after ramdisk. We first load it to the tail
     // of the buffer and move it forward as much as possible after ramdisk and fdt are loaded,
     // fixed-up and finalized.
-    let kernel_load_offset = {
-        let off = load.len().checked_sub(kernel_size).ok_or_else(|| EfiAppError::BufferTooSmall)?;
-        off.checked_sub(load[off..].as_ptr() as usize % KERNEL_ALIGNMENT)
-            .ok_or_else(|| EfiAppError::BufferTooSmall)?
+    let boot_img_load_offset: usize = {
+        let off = SafeNum::from(load.len()) - kernel_size - boot_ramdisk_size;
+        let off_idx: usize = off.try_into().map_err(Error::from)?;
+        let aligned_off = off - (&load[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
+        aligned_off.try_into().map_err(Error::from)?
     };
-    let (load, kernel_tail_buffer) = load.split_at_mut(kernel_load_offset);
-    gpt_devices.read_gpt_partition(
+    let (load, boot_img_buffer) = load.split_at_mut(boot_img_load_offset);
+    ops.read_from_partition_sync(
         "boot_a",
         kernel_hdr_size.try_into().unwrap(),
-        &mut kernel_tail_buffer[..kernel_size],
+        &mut boot_img_buffer[..kernel_size + boot_ramdisk_size],
     )?;
 
     // Load vendor ramdisk
-    let mut ramdisk_load_curr = 0;
-    gpt_devices.read_gpt_partition(
+    let mut ramdisk_load_curr = SafeNum::ZERO;
+    ops.read_from_partition_sync(
         "vendor_boot_a",
-        vendor_hdr_size.try_into().unwrap(),
-        &mut load[ramdisk_load_curr..][..vendor_ramdisk_size],
+        u64::try_from(vendor_hdr_size).map_err(Error::from)?,
+        &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..vendor_ramdisk_size],
     )?;
-    ramdisk_load_curr = usize_add(ramdisk_load_curr, vendor_ramdisk_size)?;
+    ramdisk_load_curr += vendor_ramdisk_size;
 
     // Load generic ramdisk
-    gpt_devices.read_gpt_partition(
-        "init_boot_a",
-        init_boot_hdr_size.try_into().unwrap(),
-        &mut load[ramdisk_load_curr..][..generic_ramdisk_size],
-    )?;
-    ramdisk_load_curr = usize_add(ramdisk_load_curr, generic_ramdisk_size)?;
+    if generic_ramdisk_size > 0 {
+        ops.read_from_partition_sync(
+            "init_boot_a",
+            init_boot_hdr_size.try_into().unwrap(),
+            &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..generic_ramdisk_size],
+        )?;
+        ramdisk_load_curr += generic_ramdisk_size;
+    }
+
+    // Load ramdisk from boot image
+    if boot_ramdisk_size > 0 {
+        load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..boot_ramdisk_size]
+            .copy_from_slice(&boot_img_buffer[kernel_size..][..boot_ramdisk_size]);
+        ramdisk_load_curr += boot_ramdisk_size;
+    }
 
     // Prepare partition data for avb verification
     let (vendor_boot_load_buffer, remains) = load.split_at_mut(vendor_ramdisk_size);
     let (init_boot_load_buffer, remains) = remains.split_at_mut(generic_ramdisk_size);
+    let (_boot_ramdisk_load_buffer, remains) = remains.split_at_mut(boot_ramdisk_size);
     // Prepare a BootConfigBuilder to add avb generated bootconfig.
     let mut bootconfig_builder = BootConfigBuilder::new(remains)?;
     // Perform avb verification.
     avb_verify_slot(
-        &mut gpt_devices,
-        kernel_tail_buffer,
+        ops,
+        boot_img_buffer,
         vendor_boot_load_buffer,
         init_boot_load_buffer,
+        dtbo_buffer.as_deref(),
         &mut bootconfig_builder,
     )?;
 
+    // Move kernel to end of the boot image buffer
+    let (_boot_img_buffer, kernel_tail_buffer) = {
+        let off = SafeNum::from(boot_img_buffer.len()) - kernel_size;
+        let off_idx: usize = off.try_into().map_err(Error::from)?;
+        let aligned_off = off - (&boot_img_buffer[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
+        let aligned_off_idx = aligned_off.try_into().map_err(Error::from)?;
+        boot_img_buffer.copy_within(0..kernel_size, aligned_off_idx);
+        boot_img_buffer.split_at_mut(aligned_off_idx)
+    };
+
     // Add slot index
     bootconfig_builder.add("androidboot.slot_suffix=_a\n")?;
 
@@ -224,75 +344,111 @@ pub fn load_android_simple<'a>(
 
     // V4 image has vendor bootconfig.
     if let VendorImageHeader::V4(ref hdr) = vendor_boot_header {
-        let mut bootconfig_offset: usize = vendor_hdr_size;
+        let mut bootconfig_offset = SafeNum::from(vendor_hdr_size);
         for image_size in
             [hdr._base.vendor_ramdisk_size, hdr._base.dtb_size, hdr.vendor_ramdisk_table_size]
         {
-            bootconfig_offset =
-                usize_add(bootconfig_offset, usize_roundup(image_size, hdr._base.page_size)?)?;
+            bootconfig_offset += SafeNum::from(image_size).round_up(hdr._base.page_size);
         }
         bootconfig_builder.add_with(|out| {
-            gpt_devices
-                .read_gpt_partition(
-                    "vendor_boot_a",
-                    bootconfig_offset.try_into().unwrap(),
-                    &mut out[..hdr.bootconfig_size as usize],
-                )
-                .map_err(|_| BootConfigError::GenericReaderError(-1))?;
+            ops.read_from_partition_sync(
+                "vendor_boot_a",
+                bootconfig_offset.try_into()?,
+                &mut out[..hdr.bootconfig_size as usize],
+            )?;
             Ok(hdr.bootconfig_size as usize)
         })?;
     }
     // Check if there is a device specific bootconfig partition.
-    match gpt_devices.find_partition("bootconfig").and_then(|v| v.size()) {
-        Ok(sz) => {
+    match ops.partition_size("bootconfig") {
+        Ok(Some(sz)) => {
             bootconfig_builder.add_with(|out| {
                 // For proof-of-concept only, we just load as much as possible and figure out the
                 // actual bootconfig string length after. This however, can introduce large amount
                 // of unnecessary disk access. In real implementation, we might want to either read
                 // page by page or find way to know the actual length first.
                 let max_size = core::cmp::min(sz.try_into().unwrap(), out.len());
-                gpt_devices
-                    .read_gpt_partition("bootconfig", 0, &mut out[..max_size])
-                    .map_err(|_| BootConfigError::GenericReaderError(-1))?;
+                ops.read_from_partition_sync("bootconfig", 0, &mut out[..max_size])?;
                 // Compute the actual config string size. The config is a null-terminated string.
                 Ok(CStr::from_bytes_until_nul(&out[..])
-                    .map_err(|_| BootConfigError::GenericReaderError(-1))?
+                    .or(Err(Error::InvalidInput))?
                     .to_bytes()
                     .len())
             })?;
         }
         _ => {}
     }
-    efi_println!(efi_entry, "final bootconfig: \"{}\"", bootconfig_builder);
-    ramdisk_load_curr = usize_add(ramdisk_load_curr, bootconfig_builder.config_bytes().len())?;
+    gbl_println!(ops, "final bootconfig: \"{}\"", bootconfig_builder);
+
+    ramdisk_load_curr += bootconfig_builder.config_bytes().len();
+
+    // On ARM, we may need to decompress the kernel and re-split the buffer to the new kernel size.
+    #[cfg(target_arch = "aarch64")]
+    let (load, kernel_size, kernel_tail_buffer) = {
+        let kernel_size = kernel_tail_buffer.len();
+        let compressed_kernel_offset = images_buffer.len() - kernel_size;
+        let decompressed_kernel_offset =
+            decompress_kernel(ops, images_buffer, compressed_kernel_offset)?;
+        let (load, kernel_tail_buffer) = images_buffer.split_at_mut(decompressed_kernel_offset);
+        (load, kernel_tail_buffer.len(), kernel_tail_buffer)
+    };
 
     // Prepare FDT.
 
     // For cuttlefish, FDT comes from EFI vendor configuration table installed by u-boot. In real
     // product, it may come from vendor boot image.
-    let (_, fdt_bytes) = get_efi_fdt(&efi_entry).ok_or_else(|| EfiAppError::NoFdt)?;
+    let mut fdt_bytes_buffer = vec![0u8; max(vendor_dtb_size, boot_dtb_size)];
+    let fdt_bytes_buffer = &mut fdt_bytes_buffer[..];
+    let fdt_bytes = match ops.get_custom_device_tree() {
+        Some(fdt_bytes) => fdt_bytes,
+        None if vendor_dtb_size > 0 => {
+            let vendor_dtb_offset: usize = (SafeNum::from(vendor_hdr_size)
+                + SafeNum::from(vendor_ramdisk_size))
+            .round_up(vendor_page_size)
+            .try_into()
+            .map_err(Error::from)?;
+            gbl_println!(
+                ops,
+                "Loading vendor_boot dtb size {} at {}",
+                vendor_dtb_size,
+                vendor_dtb_offset
+            );
+            let fdt_bytes = &mut fdt_bytes_buffer[..vendor_dtb_size.try_into().unwrap()];
+            ops.read_from_partition_sync(
+                "vendor_boot_a",
+                vendor_dtb_offset.try_into().unwrap(),
+                fdt_bytes,
+            )?;
+            fdt_bytes
+        }
+        None if boot_dtb_size > 0 => {
+            let mut boot_dtb_offset = SafeNum::from(kernel_hdr_size);
+            for image_size in [kernel_size, boot_ramdisk_size, boot_second_size] {
+                boot_dtb_offset += SafeNum::from(image_size).round_up(kernel_hdr_size);
+            }
+            let fdt_bytes = &mut fdt_bytes_buffer[..boot_dtb_size.try_into().unwrap()];
+            ops.read_from_partition_sync("boot_a", boot_dtb_offset.try_into().unwrap(), fdt_bytes)?;
+            fdt_bytes
+        }
+        None => &mut [],
+    };
     let fdt_origin = Fdt::new(fdt_bytes)?;
 
     // Use the remaining load buffer for updating FDT.
-    let (ramdisk_load_buffer, load) = load.split_at_mut(ramdisk_load_curr);
+    let (ramdisk_load_buffer, load) =
+        load.split_at_mut(ramdisk_load_curr.try_into().map_err(Error::from)?);
     let load = aligned_subslice(load, FDT_ALIGNMENT)?;
     let mut fdt = Fdt::new_from_init(&mut load[..], fdt_bytes)?;
 
     // Add ramdisk range to FDT
-    let ramdisk_addr: u64 = (ramdisk_load_buffer.as_ptr() as usize).try_into().unwrap();
-    let ramdisk_end: u64 = ramdisk_addr + u64::try_from(ramdisk_load_buffer.len()).unwrap();
-    fdt.set_property(
-        "chosen",
-        CStr::from_bytes_with_nul(b"linux,initrd-start\0").unwrap(),
-        &ramdisk_addr.to_be_bytes(),
-    )?;
-    fdt.set_property(
-        "chosen",
-        CStr::from_bytes_with_nul(b"linux,initrd-end\0").unwrap(),
-        &ramdisk_end.to_be_bytes(),
-    )?;
-    efi_println!(&efi_entry, "linux,initrd-start: {:#x}", ramdisk_addr);
-    efi_println!(&efi_entry, "linux,initrd-end: {:#x}", ramdisk_end);
+    let ramdisk_addr: u64 =
+        (ramdisk_load_buffer.as_ptr() as usize).try_into().map_err(Error::from)?;
+    let ramdisk_end: u64 =
+        ramdisk_addr + u64::try_from(ramdisk_load_buffer.len()).map_err(Error::from)?;
+    fdt.set_property("chosen", c"linux,initrd-start", &ramdisk_addr.to_be_bytes())?;
+    fdt.set_property("chosen", c"linux,initrd-end", &ramdisk_end.to_be_bytes())?;
+    gbl_println!(ops, "linux,initrd-start: {:#x}", ramdisk_addr);
+    gbl_println!(ops, "linux,initrd-end: {:#x}", ramdisk_end);
 
     // Concatenate kernel commandline and add it to FDT.
     let bootargs_prop = CStr::from_bytes_with_nul(b"bootargs\0").unwrap();
@@ -312,7 +468,7 @@ pub fn load_android_simple<'a>(
         cmdline_payload[cmdline_payload_off..][..ele.len()].clone_from_slice(ele.as_bytes());
         cmdline_payload_off += ele.len();
     }
-    efi_println!(&efi_entry, "final cmdline: \"{}\"", from_utf8(cmdline_payload).unwrap());
+    gbl_println!(ops, "final cmdline: \"{}\"", from_utf8(cmdline_payload).unwrap());
 
     // Finalize FDT to actual used size.
     fdt.shrink_to_fit()?;
@@ -350,25 +506,30 @@ pub fn load_android_simple<'a>(
 // flow in libgbl, which will eventually replace this demo. The demo is currently used as an
 // end-to-end test for libraries developed so far.
 pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
-    efi_println!(entry, "Try booting as Android");
+    let mut blks = find_block_devices(&entry)?;
+    let partitions = &blks.as_gbl_parts()?;
+    let mut ops = Ops { efi_entry: &entry, partitions };
+
+    gbl_println!(ops, "Try booting as Android");
 
     // Allocate buffer for load.
     let mut load_buffer = vec![0u8; 128 * 1024 * 1024]; // 128MB
 
-    let (ramdisk, fdt, kernel, remains) = load_android_simple(&entry, &mut load_buffer[..])?;
+    let (ramdisk, fdt, kernel, remains) = load_android_simple(&mut ops, &mut load_buffer[..])?;
 
-    efi_println!(&entry, "");
-    efi_println!(
-        &entry,
+    gbl_println!(ops, "");
+    gbl_println!(
+        ops,
         "Booting kernel @ {:#x}, ramdisk @ {:#x}, fdt @ {:#x}",
         kernel.as_ptr() as usize,
         ramdisk.as_ptr() as usize,
         fdt.as_ptr() as usize
     );
-    efi_println!(&entry, "");
+    gbl_println!(ops, "");
 
     #[cfg(target_arch = "aarch64")]
     {
+        drop(blks); // Drop `blks` to release the borrow on `entry`.
         let _ = exit_boot_services(entry, remains)?;
         // SAFETY: We currently targets at Cuttlefish emulator where images are provided valid.
         unsafe { boot::aarch64::jump_linux_el2_or_lower(kernel, ramdisk, fdt) };
@@ -377,6 +538,7 @@ pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
     #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
     {
         let fdt = fdt::Fdt::new(&fdt[..])?;
+        drop(blks); // Drop `blks` to release the borrow on `entry`.
         let efi_mmap = exit_boot_services(entry, remains)?;
         // SAFETY: We currently target at Cuttlefish emulator where images are provided valid.
         unsafe {
@@ -391,7 +553,7 @@ pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
                 |e820_entries| {
                     // Convert EFI memory type to e820 memory type.
                     if efi_mmap.len() > e820_entries.len() {
-                        return Err(boot::BootError::E820MemoryMapCallbackError(-1));
+                        return Err(Error::MemoryMapCallbackError(-1));
                     }
                     for (idx, mem) in efi_mmap.into_iter().enumerate() {
                         e820_entries[idx] = boot::x86::e820entry {
@@ -415,7 +577,8 @@ pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
             .boot_services()
             .find_first_and_open::<efi::protocol::riscv::RiscvBootProtocol>()?
             .get_boot_hartid()?;
-        efi_println!(entry, "riscv boot_hart_id: {}", boot_hart_id);
+        gbl_println!(ops, "riscv boot_hart_id: {}", boot_hart_id);
+        drop(blks); // Drop `blks` to release the borrow on `entry`.
         let _ = exit_boot_services(entry, remains)?;
         // SAFETY: We currently target at Cuttlefish emulator where images are provided valid.
         unsafe { boot::riscv64::jump_linux(kernel, boot_hart_id, fdt) };
diff --git a/gbl/efi/src/avb.rs b/gbl/efi/src/avb.rs
index 5a80000..365e4c6 100644
--- a/gbl/efi/src/avb.rs
+++ b/gbl/efi/src/avb.rs
@@ -16,25 +16,34 @@
 // is mainly for use by the boot demo. Eventually, these backends will be implemented from the
 // `GblOps` interface in libgbl, where EFI services will be one level lower as its backend instead.
 
-use crate::utils::EfiMultiBlockDevices;
-use avb::{IoError, IoResult, Ops, PublicKeyForPartitionInfo};
+use avb::{IoError, IoResult, Ops as AvbOps, PublicKeyForPartitionInfo};
 use core::ffi::CStr;
-use gbl_storage::AsMultiBlockDevices;
+use libgbl::GblOps;
 use uuid::Uuid;
 
 extern crate avb_sysdeps;
 
-pub struct GblEfiAvbOps<'a, 'b> {
-    gpt_dev: &'b mut EfiMultiBlockDevices<'a>,
-    preloaded_partitions: Option<&'b [(&'b str, &'b [u8])]>,
+/// [AvbOps] implementation for [GblOps].
+// TODO(b/363074091): this code is now platform-independent; move it into libgbl.
+pub struct GblEfiAvbOps<'a, G> {
+    gbl_ops: &'a mut G,
+    preloaded_partitions: Option<&'a [(&'a str, &'a [u8])]>,
 }
 
-impl<'a, 'b> GblEfiAvbOps<'a, 'b> {
+/// # Lifetimes
+/// * `'a`: borrowed data minimum lifetime
+/// * `'b`: [GblOps] partition lifetime
+impl<'a, 'b, G: GblOps<'b>> GblEfiAvbOps<'a, G> {
     pub fn new(
-        gpt_dev: &'b mut EfiMultiBlockDevices<'a>,
-        preloaded_partitions: Option<&'b [(&'b str, &'b [u8])]>,
+        gbl_ops: &'a mut G,
+        preloaded_partitions: Option<&'a [(&'a str, &'a [u8])]>,
     ) -> Self {
-        Self { gpt_dev, preloaded_partitions }
+        Self { gbl_ops, preloaded_partitions }
+    }
+
+    /// Returns the size of a partition.
+    fn partition_size(&mut self, partition: &str) -> IoResult<u64> {
+        self.gbl_ops.partition_size(partition).or(Err(IoError::Io))?.ok_or(IoError::NoSuchPartition)
     }
 }
 
@@ -43,7 +52,7 @@ fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
     Ok(s.to_str().map_err(|_| err)?)
 }
 
-impl<'b> Ops<'b> for GblEfiAvbOps<'_, 'b> {
+impl<'a, 'b, G: GblOps<'b>> AvbOps<'a> for GblEfiAvbOps<'a, G> {
     fn read_from_partition(
         &mut self,
         partition: &CStr,
@@ -51,24 +60,19 @@ impl<'b> Ops<'b> for GblEfiAvbOps<'_, 'b> {
         buffer: &mut [u8],
     ) -> IoResult<usize> {
         let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-        let partition_size: u64 = self
-            .gpt_dev
-            .find_partition(part_str)
-            .and_then(|v| v.size())
-            .map_err(|_| IoError::NoSuchPartition)?
-            .try_into()
-            .map_err(|_| IoError::Oom)?;
+        let partition_size: u64 =
+            self.partition_size(part_str)?.try_into().map_err(|_| IoError::Oom)?;
         let read_off: u64 = match offset < 0 {
             true => {
                 partition_size.checked_sub(offset.abs() as u64).ok_or(IoError::InvalidValueSize)?
             }
             _ => offset.try_into().map_err(|_| IoError::InvalidValueSize)?,
         };
-        self.gpt_dev.read_gpt_partition(part_str, read_off, buffer).map_err(|_| IoError::Io)?;
+        self.gbl_ops.read_from_partition_sync(part_str, read_off, buffer).or(Err(IoError::Io))?;
         Ok(buffer.len())
     }
 
-    fn get_preloaded_partition(&mut self, partition: &CStr) -> IoResult<&'b [u8]> {
+    fn get_preloaded_partition(&mut self, partition: &CStr) -> IoResult<&'a [u8]> {
         let part_str = cstr_to_str(partition, IoError::NotImplemented)?;
         Ok(self
             .preloaded_partitions
@@ -109,9 +113,9 @@ impl<'b> Ops<'b> for GblEfiAvbOps<'_, 'b> {
     }
 
     fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> IoResult<Uuid> {
-        let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-        let ptn = self.gpt_dev.find_partition(part_str).map_err(|_| IoError::NoSuchPartition)?;
-        Ok(Uuid::from_bytes(ptn.gpt_entry().guid))
+        // The ops is only used to check that a partition exists. GUID is not used.
+        self.partition_size(cstr_to_str(partition, IoError::NoSuchPartition)?)?;
+        Ok(Uuid::nil())
     }
 
     fn get_size_of_partition(&mut self, partition: &CStr) -> IoResult<u64> {
@@ -119,13 +123,7 @@ impl<'b> Ops<'b> for GblEfiAvbOps<'_, 'b> {
             Ok(img) => Ok(img.len().try_into().unwrap()),
             _ => {
                 let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-                Ok(self
-                    .gpt_dev
-                    .find_partition(part_str)
-                    .and_then(|v| v.size())
-                    .map_err(|_| IoError::NoSuchPartition)?
-                    .try_into()
-                    .map_err(|_| IoError::NoSuchPartition)?)
+                self.partition_size(part_str)
             }
         }
     }
diff --git a/gbl/efi/src/efi_blocks.rs b/gbl/efi/src/efi_blocks.rs
new file mode 100644
index 0000000..31c99a8
--- /dev/null
+++ b/gbl/efi/src/efi_blocks.rs
@@ -0,0 +1,172 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use alloc::vec::Vec;
+use core::{cmp::max, fmt::Write};
+use efi::{
+    efi_print, efi_println,
+    protocol::{block_io::BlockIoProtocol, block_io2::BlockIo2Protocol, Protocol},
+    EfiEntry,
+};
+use efi_types::EfiBlockIoMedia;
+use gbl_async::block_on;
+use gbl_storage::{AsyncBlockDevice, BlockInfo, BlockIoAsync, GptCache};
+use liberror::Error;
+use libgbl::partition::{check_part_unique, Partition, PartitionBlockDevice};
+use safemath::SafeNum;
+
+/// `EfiBlockDeviceIo` wraps a EFI `BlockIoProtocol` or `BlockIo2Protocol` and implements the
+/// `BlockIoAsync` interface.
+pub enum EfiBlockDeviceIo<'a> {
+    Sync(Protocol<'a, BlockIoProtocol>),
+    Async(Protocol<'a, BlockIo2Protocol>),
+}
+
+impl<'a> EfiBlockDeviceIo<'a> {
+    fn media(&self) -> EfiBlockIoMedia {
+        match self {
+            EfiBlockDeviceIo::Sync(v) => v.media(),
+            EfiBlockDeviceIo::Async(v) => v.media(),
+        }
+        .unwrap()
+    }
+
+    fn info(&mut self) -> BlockInfo {
+        let media = self.media();
+        BlockInfo {
+            block_size: media.block_size as u64,
+            num_blocks: (media.last_block + 1) as u64,
+            alignment: max(1, media.io_align as u64),
+        }
+    }
+}
+
+impl BlockIoAsync for EfiBlockDeviceIo<'_> {
+    fn info(&mut self) -> BlockInfo {
+        (*self).info()
+    }
+
+    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), Error> {
+        match self {
+            EfiBlockDeviceIo::Sync(v) => v.read_blocks(blk_offset, out),
+            EfiBlockDeviceIo::Async(v) => v.read_blocks_ex(blk_offset, out).await,
+        }
+        .or(Err(Error::BlockIoError))
+    }
+
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
+        match self {
+            EfiBlockDeviceIo::Sync(v) => v.write_blocks(blk_offset, data),
+            EfiBlockDeviceIo::Async(v) => v.write_blocks_ex(blk_offset, data).await,
+        }
+        .or(Err(Error::BlockIoError))
+    }
+}
+
+const MAX_GPT_ENTRIES: u64 = 128;
+
+/// `PartitionInfoBuffer` manages the buffer for raw partition name or GPT partition table.
+enum PartitionInfoBuffer {
+    Gpt(Vec<u8>),
+    // TODO(b/357688291): Add raw partition entry once supported.
+}
+
+/// `EfiBlockDevice` manages EFI block IO, scratch and partition table buffers.
+pub struct EfiBlockDevice<'a> {
+    io: EfiBlockDeviceIo<'a>,
+    scratch: Vec<u8>,
+    partition: PartitionInfoBuffer,
+}
+
+impl<'a> EfiBlockDevice<'a> {
+    /// Creates a new instance as GPT partition device.
+    ///
+    /// The API allocates scratch and GPT buffer from heap.
+    pub fn new_gpt(mut io: EfiBlockDeviceIo<'a>) -> Result<Self, Error> {
+        let scratch_size =
+            SafeNum::from(AsyncBlockDevice::<EfiBlockDeviceIo>::required_scratch_size(&mut io)?);
+        let mut gpt_buf = vec![0u8; GptCache::required_buffer_size(MAX_GPT_ENTRIES)?];
+        // Initializes GPT buffer.
+        let _ = GptCache::from_uninit(MAX_GPT_ENTRIES, &mut gpt_buf)?;
+        Ok(Self {
+            io,
+            scratch: vec![0u8; scratch_size.try_into()?],
+            partition: PartitionInfoBuffer::Gpt(gpt_buf),
+        })
+    }
+
+    /// Creates an instance of GBL partition block device.
+    pub fn as_gbl_part(
+        &mut self,
+    ) -> Result<PartitionBlockDevice<&mut EfiBlockDeviceIo<'a>>, Error> {
+        let blk = AsyncBlockDevice::new(&mut self.io, &mut self.scratch)?;
+        Ok(match &mut self.partition {
+            PartitionInfoBuffer::Gpt(buf) => {
+                PartitionBlockDevice::new_gpt(blk, GptCache::from_existing(buf).unwrap())
+            }
+        })
+    }
+}
+
+/// `EfiMultiBlockDevices` wraps a vector of `EfiBlockDevice`.
+pub struct EfiMultiBlockDevices<'a>(pub Vec<EfiBlockDevice<'a>>);
+
+impl<'a> EfiMultiBlockDevices<'a> {
+    /// Creates a vector of `PartitionBlockDevice`
+    pub fn as_gbl_parts(
+        &mut self,
+    ) -> Result<Vec<PartitionBlockDevice<&mut EfiBlockDeviceIo<'a>>>, Error> {
+        let mut res = vec![];
+        for ele in &mut self.0 {
+            res.push(ele.as_gbl_part()?)
+        }
+        Ok(res)
+    }
+
+    /// Finds a partition.
+    // TODO(b/357688291): Remove once we switch to GblOps for finding partitions.
+    pub fn find_partition(&mut self, part: &str) -> Result<Partition, Error> {
+        Ok(check_part_unique(&self.as_gbl_parts()?, part)?.1)
+    }
+}
+
+/// Finds and returns all EFI devices supporting either EFI_BLOCK_IO or EFI_BLOCK_IO2 protocol.
+pub fn find_block_devices(efi_entry: &EfiEntry) -> Result<EfiMultiBlockDevices, Error> {
+    let bs = efi_entry.system_table().boot_services();
+    let block_dev_handles = bs.locate_handle_buffer_by_protocol::<BlockIoProtocol>()?;
+    let mut block_devices = Vec::<EfiBlockDevice>::new();
+    for (idx, handle) in block_dev_handles.handles().iter().enumerate() {
+        // Prioritizes `BlockIo2Protocol`.
+        let blk_io = match bs.open_protocol::<BlockIo2Protocol>(*handle) {
+            Ok(v) => EfiBlockDeviceIo::Async(v),
+            _ => EfiBlockDeviceIo::Sync(bs.open_protocol::<BlockIoProtocol>(*handle)?),
+        };
+        if blk_io.media().logical_partition {
+            continue;
+        }
+        // TODO(b/357688291): Support raw partition based on device path info.
+        let mut blk = EfiBlockDevice::new_gpt(blk_io)?;
+        match block_on(blk.as_gbl_part()?.sync_gpt()) {
+            Ok(true) => {
+                efi_println!(efi_entry, "Block #{}: GPT detected", idx);
+            }
+            Err(e) => {
+                efi_println!(efi_entry, "Block #{}: Failed to find GPT. {:?}", idx, e);
+            }
+            _ => {}
+        };
+        block_devices.push(blk);
+    }
+    Ok(EfiMultiBlockDevices(block_devices))
+}
diff --git a/gbl/efi/src/error.rs b/gbl/efi/src/error.rs
index 0d56949..38abde5 100644
--- a/gbl/efi/src/error.rs
+++ b/gbl/efi/src/error.rs
@@ -12,56 +12,25 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use avb::{IoError, SlotVerifyError};
-use boot::BootError;
-use bootconfig::BootConfigError;
-use bootimg::ImageError;
-use efi::EfiError;
-use fastboot::TransportError;
-use fdt::FdtError;
-use gbl_storage::StorageError;
-use libgbl::composite_enum;
-use misc::BcbError;
+use liberror::Error;
 use smoltcp::socket::tcp::{ListenError, RecvError, SendError};
-use zbi::ZbiError;
 
-/// Error types for EFI application.
-#[derive(Debug)]
-pub enum EfiAppError {
-    ArithmeticOverflow,
-    BufferAlignment,
-    BufferTooSmall,
-    InvalidInput,
-    InvalidString,
-    NoFdt,
-    NotFound,
-    NoZbiImage,
-    PeerClosed,
-    Timeout,
-    Unsupported,
+pub fn recv_to_unified(err: RecvError) -> Error {
+    match err {
+        RecvError::InvalidState => Error::InvalidState,
+        RecvError::Finished => Error::Finished,
+    }
 }
 
-composite_enum! {
-    /// A top level error type that consolidates errors from different libraries.
-    #[derive(Debug)]
-    pub enum GblEfiError {
-        AvbIoError(IoError),
-        BcbError(BcbError),
-        BootConfigError(BootConfigError),
-        BootError(BootError),
-        EfiAppError(EfiAppError),
-        EfiError(EfiError),
-        FdtError(FdtError),
-        ImageError(ImageError),
-        ListenError(ListenError),
-        RecvError(RecvError),
-        SendError(SendError),
-        SlotVerifyError(SlotVerifyError<'static>),
-        StorageError(StorageError),
-        TransportError(TransportError),
-        ZbiError(ZbiError),
+pub fn send_to_unified(err: SendError) -> Error {
+    match err {
+        SendError::InvalidState => Error::InvalidState,
     }
 }
 
-/// Top level error type.
-pub type Result<T> = core::result::Result<T, GblEfiError>;
+pub fn listen_to_unified(err: ListenError) -> Error {
+    match err {
+        ListenError::InvalidState => Error::InvalidState,
+        ListenError::Unaddressable => Error::Unaddressable,
+    }
+}
diff --git a/gbl/efi/src/fastboot.rs b/gbl/efi/src/fastboot.rs
index 0040e4b..9a268c6 100644
--- a/gbl/efi/src/fastboot.rs
+++ b/gbl/efi/src/fastboot.rs
@@ -17,24 +17,36 @@
 // `android_boot:android_boot_demo()` and `fuchsia_boot:fuchsia_boot_demo()` for
 // supported/unsupported features at the moment.
 
-use crate::error::{EfiAppError, GblEfiError, Result as GblResult};
-use crate::net::{with_efi_network, EfiTcpSocket};
-use crate::utils::{find_gpt_devices, loop_with_timeout};
-use core::{fmt::Write, result::Result};
+use crate::{
+    efi_blocks::find_block_devices,
+    net::{with_efi_network, EfiTcpSocket},
+    ops::Ops,
+};
+use alloc::vec::Vec;
+use core::{cmp::min, fmt::Write, future::Future, mem::take};
 use efi::{
-    defs::{EFI_STATUS_NOT_READY, EFI_STATUS_NOT_STARTED},
     efi_print, efi_println,
-    protocol::{android_boot::AndroidBootProtocol, Protocol},
+    protocol::{gbl_efi_fastboot_usb::GblFastbootUsbProtocol, Protocol},
     EfiEntry,
 };
-use fastboot::{Fastboot, TcpStream, Transport, TransportError};
-use libgbl::fastboot::GblFastboot;
+use fastboot::{
+    process_next_command, run_tcp_session, CommandResult, FastbootImplementation, TcpStream,
+    Transport,
+};
+use gbl_async::{yield_now, YieldCounter};
+use gbl_cyclic_executor::CyclicExecutor;
+use liberror::{Error, Result};
+use libgbl::{
+    fastboot::{GblFastboot, TasksExecutor},
+    GblOps,
+};
+use spin::{Mutex, MutexGuard};
 
 const DEFAULT_TIMEOUT_MS: u64 = 5_000;
 const FASTBOOT_TCP_PORT: u16 = 5554;
 
 struct EfiFastbootTcpTransport<'a, 'b, 'c> {
-    last_err: GblResult<()>,
+    last_err: Result<()>,
     socket: &'c mut EfiTcpSocket<'a, 'b>,
 }
 
@@ -46,172 +58,258 @@ impl<'a, 'b, 'c> EfiFastbootTcpTransport<'a, 'b, 'c> {
 
 impl TcpStream for EfiFastbootTcpTransport<'_, '_, '_> {
     /// Reads to `out` for exactly `out.len()` number bytes from the TCP connection.
-    fn read_exact(&mut self, out: &mut [u8]) -> Result<(), TransportError> {
-        self.last_err = self.socket.receive_exact(out, DEFAULT_TIMEOUT_MS);
-        self.last_err.as_ref().map_err(|_| TransportError::Others("TCP read error"))?;
+    async fn read_exact(&mut self, out: &mut [u8]) -> Result<()> {
+        self.last_err = self.socket.receive_exact(out, DEFAULT_TIMEOUT_MS).await;
+        self.last_err.as_ref().or(Err(Error::Other(Some("Tcp read error"))))?;
         Ok(())
     }
 
     /// Sends exactly `data.len()` number bytes from `data` to the TCP connection.
-    fn write_exact(&mut self, data: &[u8]) -> Result<(), TransportError> {
-        self.last_err = self.socket.send_exact(data, DEFAULT_TIMEOUT_MS);
-        self.last_err.as_ref().map_err(|_| TransportError::Others("TCP write error"))?;
+    async fn write_exact(&mut self, data: &[u8]) -> Result<()> {
+        self.last_err = self.socket.send_exact(data, DEFAULT_TIMEOUT_MS).await;
+        self.last_err.as_ref().or(Err(Error::Other(Some("Tcp write error"))))?;
         Ok(())
     }
 }
 
 /// `UsbTransport` implements the `fastboot::Transport` trait using USB interfaces from
-/// EFI_ANDROID_BOOT_PROTOCOL.
-pub struct UsbTransport<'a, 'b> {
-    last_err: GblResult<()>,
+/// GBL_EFI_FASTBOOT_USB_PROTOCOL.
+pub struct UsbTransport<'a> {
+    last_err: Result<()>,
     max_packet_size: usize,
-    protocol: &'b Protocol<'a, AndroidBootProtocol>,
+    protocol: Protocol<'a, GblFastbootUsbProtocol>,
+    io_yield_counter: YieldCounter,
+    // Buffer for prefetching an incoming packet in `wait_for_packet()`.
+    // Alternatively we can also consider adding an EFI event for packet arrive. But UEFI firmware
+    // may be more complicated.
+    prefetched: (Vec<u8>, usize),
 }
 
-impl<'a, 'b> UsbTransport<'a, 'b> {
-    fn new(max_packet_size: usize, protocol: &'b Protocol<'a, AndroidBootProtocol>) -> Self {
-        Self { last_err: Ok(()), max_packet_size: max_packet_size, protocol: protocol }
-    }
-
-    /// Waits for the previous send to complete up to `DEFAULT_TIMEOUT_MS` timeout.
-    fn wait_for_send(&self) -> GblResult<()> {
-        loop_with_timeout(self.protocol.efi_entry(), DEFAULT_TIMEOUT_MS, || {
-            match (|| -> GblResult<bool> {
-                Ok(self
-                    .protocol
-                    .efi_entry()
-                    .system_table()
-                    .boot_services()
-                    .check_event(&self.protocol.wait_for_send_completion()?)?)
-            })() {
-                Ok(true) => Ok(Ok(())),
-                Ok(false) => Err(false),
-                Err(e) => Ok(Err(e)),
+impl<'a> UsbTransport<'a> {
+    fn new(max_packet_size: usize, protocol: Protocol<'a, GblFastbootUsbProtocol>) -> Self {
+        Self {
+            last_err: Ok(()),
+            max_packet_size,
+            protocol,
+            io_yield_counter: YieldCounter::new(u64::MAX),
+            prefetched: (vec![0u8; max_packet_size], 0),
+        }
+    }
+
+    /// Sets the maximum number of bytes to read or write before a force await.
+    pub fn set_io_yield_threshold(&mut self, threshold: u64) {
+        self.io_yield_counter = YieldCounter::new(threshold)
+    }
+
+    /// Reads the next packet from the EFI USB protocol into the given buffer.
+    async fn receive_next_from_efi(&mut self, out: &mut [u8]) -> Result<usize> {
+        match self.protocol.receive_packet(out).await {
+            Ok(sz) => {
+                // Forces a yield to the executor if the data received/sent reaches a certain
+                // threshold. This is to prevent the async code from holding up the CPU for too long
+                // in case IO speed is high and the executor uses cooperative scheduling.
+                self.io_yield_counter.increment(sz.try_into().unwrap()).await;
+                return Ok(sz);
+            }
+            Err(e) => {
+                self.last_err = Err(e.into());
+                return Err(Error::Other(Some("USB receive error")));
+            }
+        }
+    }
+
+    /// Waits until a packet is cached into an internal buffer.
+    async fn cache_next_packet(&mut self) -> Result<()> {
+        match &mut self.prefetched {
+            (pkt, len) if *len == 0 => {
+                let mut packet = take(pkt);
+                let len = self.receive_next_from_efi(&mut packet[..]).await?;
+                self.prefetched = (packet, len);
             }
-        })?
-        .ok_or(EfiAppError::Timeout)??;
+            _ => {}
+        }
         Ok(())
     }
 }
 
-impl Transport for UsbTransport<'_, '_> {
-    fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, TransportError> {
-        let mut out_size = 0;
-        self.last_err = Ok(());
-        match self.protocol.fastboot_usb_receive(out, &mut out_size) {
-            Ok(()) => Ok(out_size),
-            Err(e) if e.is_efi_err(EFI_STATUS_NOT_READY) => Ok(0),
-            Err(e) => {
-                self.last_err = Err(e.into());
-                Err(TransportError::Others("USB receive error"))
+impl Transport for UsbTransport<'_> {
+    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
+        match &mut self.prefetched {
+            (pkt, len) if *len > 0 => {
+                let out = out.get_mut(..*len).ok_or(Error::BufferTooSmall(Some(*len)))?;
+                let src = pkt.get(..*len).ok_or(Error::Other(Some("Invalid USB read size")))?;
+                out.clone_from_slice(src);
+                return Ok(take(len));
             }
+            _ => self.receive_next_from_efi(out).await,
         }
     }
 
-    fn send_packet(&mut self, packet: &[u8]) -> Result<(), TransportError> {
-        let mut sent = 0;
-        self.last_err = (|| -> GblResult<()> {
-            while sent < packet.len() {
-                let to_send = core::cmp::min(packet.len() - sent, self.max_packet_size);
-                let mut out_size = 0;
-                self.protocol.fastboot_usb_send(&packet[sent..][..to_send], &mut out_size)?;
-                self.wait_for_send()?;
-                sent += to_send;
+    async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
+        self.last_err = async {
+            let mut curr = &packet[..];
+            while !curr.is_empty() {
+                let to_send = min(curr.len(), self.max_packet_size);
+                self.protocol.send_packet(&curr[..to_send], DEFAULT_TIMEOUT_MS).await?;
+                // Forces a yield to the executor if the data received/sent reaches a certain
+                // threshold. This is to prevent the async code from holding up the CPU for too long
+                // in case IO speed is high and the executor uses cooperative scheduling.
+                self.io_yield_counter.increment(to_send.try_into().unwrap()).await;
+                curr = &curr[to_send..];
             }
             Ok(())
-        })();
-        Ok(*self.last_err.as_ref().map_err(|_| TransportError::Others("USB send error"))?)
+        }
+        .await;
+        Ok(*self.last_err.as_ref().map_err(|_| Error::Other(Some("USB send error")))?)
     }
 }
 
-/// Loops and polls both USB and TCP transport. Runs Fastboot if any is available.
-fn fastboot_loop(
+/// Initializes the Fastboot USB interface and returns a `UsbTransport`.
+fn init_usb(efi_entry: &EfiEntry) -> Result<UsbTransport> {
+    let protocol =
+        efi_entry.system_table().boot_services().find_first_and_open::<GblFastbootUsbProtocol>()?;
+    match protocol.fastboot_usb_interface_stop() {
+        Err(e) if e != Error::NotStarted => Err(e),
+        _ => Ok(UsbTransport::new(protocol.fastboot_usb_interface_start()?, protocol)),
+    }
+}
+
+/// `EfiFbTaskExecutor` implements the `TasksExecutor` trait used by GBL fastboot for scheduling
+/// disk IO tasks.
+#[derive(Default)]
+struct EfiFbTaskExecutor<'a>(Mutex<CyclicExecutor<'a>>);
+
+impl<'a> TasksExecutor<'a> for EfiFbTaskExecutor<'a> {
+    fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()> {
+        Ok(self.0.lock().spawn_task(task))
+    }
+}
+
+/// Waits until a shared resource protected by a mutex is acquired successfully.
+async fn lock<T>(resource: &Mutex<T>) -> MutexGuard<T> {
+    loop {
+        // Yield first so that repetitive calls guarantees at least one yield.
+        yield_now().await;
+        match resource.try_lock() {
+            Some(v) => return v,
+            _ => {}
+        }
+    }
+}
+
+/// Task routine for Fastboot over USB.
+async fn fastboot_usb(
     efi_entry: &EfiEntry,
-    gbl_fb: &mut GblFastboot,
-    fastboot: &mut Fastboot,
-    mut socket: Option<&mut EfiTcpSocket>,
-    mut usb: Option<&mut UsbTransport>,
-) -> GblResult<()> {
-    if socket.is_none() && usb.is_none() {
-        return Err(EfiAppError::Unsupported.into());
-    }
-
-    efi_println!(efi_entry, "Fastboot USB: {}", usb.as_ref().map_or("No", |_| "Yes"));
-    if let Some(socket) = socket.as_ref() {
-        efi_println!(efi_entry, "Fastboot TCP: Yes");
-        efi_println!(efi_entry, "Device IP addresses:");
-        socket.interface().ip_addrs().iter().for_each(|v| {
-            efi_println!(efi_entry, "\t{}", v.address());
-        });
-    } else {
-        efi_println!(efi_entry, "Fastboot TCP: No");
+    gbl_fb: &Mutex<&mut impl FastbootImplementation>,
+    usb: &mut UsbTransport<'_>,
+) {
+    usb.set_io_yield_threshold(1024 * 1024); // 1MB
+    loop {
+        match usb.cache_next_packet().await {
+            Err(_) => efi_println!(efi_entry, "Fastboot USB error: {:?}", usb.last_err),
+            _ => match process_next_command(usb, *lock(gbl_fb).await).await {
+                Err(_) => efi_println!(efi_entry, "Fastboot USB error: {:?}", usb.last_err),
+                _ => {}
+            },
+        }
     }
+}
 
+/// Task routine for Fastboot over TCP.
+async fn fastboot_tcp(
+    efi_entry: &EfiEntry,
+    gbl_fb: &Mutex<&mut impl FastbootImplementation>,
+    socket: &mut EfiTcpSocket<'_, '_>,
+) {
+    socket.set_io_yield_threshold(1024 * 1024); // 1MB
     let mut listen_start_timestamp = EfiTcpSocket::timestamp(0);
     loop {
-        // Checks and processes commands over USB.
-        if let Some(usb) = usb.as_mut() {
-            if fastboot.process_next_command(*usb, gbl_fb).is_err() {
-                efi_println!(efi_entry, "Fastboot USB error: {:?}", usb.last_err);
+        // Acquires the lock before proceeding to handle network. This reduces interference to the
+        // Fastboot USB task which maybe in the middle of a download. `lock()` internally yields
+        // control to the executor and check later if the mutex can't be acquired.
+        let mut gbl_fb = lock(gbl_fb).await;
+        socket.poll();
+        let mut reset_socket = false;
+        if socket.check_active() {
+            let remote = socket.get_socket().remote_endpoint().unwrap();
+            efi_println!(efi_entry, "TCP connection from {}", remote);
+            let mut transport = EfiFastbootTcpTransport::new(socket);
+            let _ = run_tcp_session(&mut transport, *gbl_fb).await;
+            match transport.last_err {
+                Ok(()) | Err(Error::Disconnected) => {}
+                Err(e) => efi_println!(efi_entry, "Fastboot TCP error {:?}", e),
             }
+            reset_socket = true;
         }
-
-        // Checks and processes commands over TCP.
-        if let Some(socket) = socket.as_mut() {
-            socket.poll();
-            let mut reset_socket = false;
-            if socket.check_active() {
-                let remote = socket.get_socket().remote_endpoint().unwrap();
-                efi_println!(efi_entry, "TCP connection from {}", remote);
-                let mut transport = EfiFastbootTcpTransport::new(socket);
-                let _ = fastboot.run_tcp_session(&mut transport, gbl_fb);
-                match transport.last_err {
-                    Ok(()) | Err(GblEfiError::EfiAppError(EfiAppError::PeerClosed)) => {}
-                    Err(e) => {
-                        efi_println!(efi_entry, "Fastboot TCP error {:?}", e);
-                    }
-                }
-                reset_socket = true;
-            } else if EfiTcpSocket::timestamp(listen_start_timestamp) > DEFAULT_TIMEOUT_MS {
-                // Reset once in a while in case a remote client disconnects in the middle of
-                // TCP handshake and leaves the socket in a half open state.
-                reset_socket = true;
-            }
-
-            if reset_socket {
-                listen_start_timestamp = EfiTcpSocket::timestamp(0);
-                if let Err(e) = socket.listen(FASTBOOT_TCP_PORT) {
-                    efi_println!(efi_entry, "TCP listen error: {:?}", e);
-                }
+        // Reset once in a while in case a remote client disconnects in the middle of
+        // TCP handshake and leaves the socket in a half open state.
+        if reset_socket || EfiTcpSocket::timestamp(listen_start_timestamp) > DEFAULT_TIMEOUT_MS {
+            listen_start_timestamp = EfiTcpSocket::timestamp(0);
+            if let Err(e) = socket.listen(FASTBOOT_TCP_PORT) {
+                efi_println!(efi_entry, "TCP listen error: {:?}", e);
             }
         }
+        // Necessary because our executor uses cooperative scheduling.
+        yield_now().await;
     }
 }
 
-/// Initializes the Fastboot USB interface and returns a `UsbTransport`.
-fn init_usb<'a, 'b>(
-    android_boot_protocol: &Option<&'b Protocol<'a, AndroidBootProtocol>>,
-) -> GblResult<UsbTransport<'a, 'b>> {
-    let protocol = android_boot_protocol.ok_or(EfiAppError::Unsupported)?;
-    match protocol.fastboot_usb_interface_stop() {
-        Err(e) if !e.is_efi_err(EFI_STATUS_NOT_STARTED) => return Err(e.into()),
+/// Spawns and runs Fastboot tasks.
+fn run_fastboot<'a>(
+    efi_entry: &EfiEntry,
+    gbl_fb: &mut GblFastboot<'_, 'a, EfiFbTaskExecutor<'a>, impl GblOps<'a>>,
+    socket: Option<&mut EfiTcpSocket>,
+    usb: Option<&mut UsbTransport>,
+) -> Result<()> {
+    assert!(socket.is_some() || usb.is_some());
+    let blk_io_executor = gbl_fb.blk_io_executor();
+    let gbl_fb = gbl_fb.into();
+    let mut task_executor: CyclicExecutor = Default::default();
+    // Fastboot over USB task.
+    match usb {
+        Some(v) => {
+            efi_println!(efi_entry, "Started Fastboot over USB.");
+            task_executor.spawn_task(fastboot_usb(efi_entry, &gbl_fb, v));
+        }
         _ => {}
-    };
-    Ok(UsbTransport::new(protocol.fastboot_usb_interface_start()?, protocol))
+    }
+    // Fastboot over TCP task.
+    match socket {
+        Some(v) => {
+            efi_println!(efi_entry, "Started Fastboot over TCP");
+            efi_println!(efi_entry, "IP address:");
+            v.interface().ip_addrs().iter().for_each(|v| {
+                efi_println!(efi_entry, "\t{}", v.address());
+            });
+            task_executor.spawn_task(fastboot_tcp(efi_entry, &gbl_fb, v));
+        }
+        _ => {}
+    }
+    // Task for scheduling disk IO tasks spawned by Fastboot.
+    task_executor.spawn_task(async {
+        loop {
+            blk_io_executor.0.lock().poll();
+            yield_now().await;
+        }
+    });
+    // Run all tasks.
+    task_executor.run();
+    Ok(())
 }
 
 /// Runs Fastboot.
-pub fn run_fastboot(
-    efi_entry: &EfiEntry,
-    android_boot_protocol: Option<&Protocol<'_, AndroidBootProtocol>>,
-) -> GblResult<()> {
-    let mut gpt_devices = find_gpt_devices(efi_entry)?;
-    let mut gbl_fb = GblFastboot::new(&mut gpt_devices);
+pub fn fastboot(efi_entry: &EfiEntry) -> Result<()> {
     // TODO(b/328786603): Figure out where to get download buffer size.
-    let mut download_buffer = vec![0u8; 512 * 1024 * 1024];
-    let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+    let mut download_buffers = vec![vec![0u8; 512 * 1024 * 1024]; 2];
+    let download_buffers =
+        download_buffers.iter_mut().map(|v| v.as_mut_slice().into()).collect::<Vec<_>>();
+    let mut blks = find_block_devices(efi_entry)?;
+    let partitions = &blks.as_gbl_parts()?;
+    let mut gbl_ops = Ops { efi_entry: &efi_entry, partitions };
+    let blk_io_executor: EfiFbTaskExecutor = Default::default();
+    let gbl_fb = &mut GblFastboot::new(&blk_io_executor, &mut gbl_ops, &download_buffers);
 
-    let mut usb = match init_usb(&android_boot_protocol) {
+    let mut usb = match init_usb(efi_entry) {
         Ok(v) => Some(v),
         Err(e) => {
             efi_println!(efi_entry, "Failed to start Fastboot over USB. {:?}.", e);
@@ -219,12 +317,12 @@ pub fn run_fastboot(
         }
     };
 
-    match with_efi_network(efi_entry, |socket| -> GblResult<()> {
-        fastboot_loop(efi_entry, &mut gbl_fb, &mut fastboot, Some(socket), usb.as_mut())
+    match with_efi_network(efi_entry, |socket| {
+        run_fastboot(efi_entry, gbl_fb, Some(socket), usb.as_mut())
     }) {
         Err(e) => {
             efi_println!(efi_entry, "Failed to start EFI network. {:?}.", e);
-            fastboot_loop(efi_entry, &mut gbl_fb, &mut fastboot, None, usb.as_mut())
+            run_fastboot(efi_entry, gbl_fb, None, usb.as_mut())
         }
         v => v?,
     }
diff --git a/gbl/efi/src/fuchsia_boot.rs b/gbl/efi/src/fuchsia_boot.rs
index 79d91c0..0e07123 100644
--- a/gbl/efi/src/fuchsia_boot.rs
+++ b/gbl/efi/src/fuchsia_boot.rs
@@ -12,143 +12,18 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::error::{EfiAppError, Result};
-use crate::utils::{aligned_subslice, find_gpt_devices, get_efi_fdt, to_usize, usize_add};
+use crate::{efi_blocks::find_block_devices, ops::Ops};
 use core::fmt::Write;
-use core::mem::size_of;
 use efi::{efi_print, efi_println, EfiEntry};
-use fdt::Fdt;
-use gbl_storage::AsMultiBlockDevices;
-use zbi::{ZbiContainer, ZbiFlags, ZbiHeader, ZbiType, ZBI_ALIGNMENT_USIZE};
-use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
-
-/// A ZBI kernel is a ZBi container where the first ZBI item is a kernel type item.
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, FromBytes, AsBytes, FromZeroes)]
-struct ZbiKernelHeader {
-    container_header: ZbiHeader,
-    zbi_item_header: ZbiHeader,
-    pub entry: u64,
-    pub reserve_memory_size: u64,
-}
-
-// Kernel load address alignment. Value taken from
-// https://fuchsia.googlesource.com/fuchsia/+/4f204d8a0243e84a86af4c527a8edcc1ace1615f/zircon/kernel/target/arm64/boot-shim/BUILD.gn#38
-const ZIRCON_KERNEL_ALIGN: usize = 64 * 1024;
-
-/// Relocates a ZBI kernel to a different buffer and returns the kernel entry offset.
-pub fn relocate_kernel(kernel: &[u8], dest: &mut [u8]) -> Result<usize> {
-    if (dest.as_ptr() as usize % ZIRCON_KERNEL_ALIGN) != 0 {
-        return Err(EfiAppError::BufferAlignment.into());
-    }
-
-    let container = ZbiContainer::parse(&kernel[..])?;
-    container.is_bootable()?;
-    let kernel_header = Ref::<_, ZbiKernelHeader>::new_from_prefix(kernel)
-        .ok_or_else(|| EfiAppError::InvalidInput)?
-        .0
-        .into_ref();
-    let kernel_size = usize_add(2 * size_of::<ZbiHeader>(), kernel_header.zbi_item_header.length)?;
-    if dest.len() < usize_add(kernel_size, kernel_header.reserve_memory_size)? {
-        return Err(EfiAppError::BufferTooSmall.into());
-    }
-
-    dest[..kernel_size].clone_from_slice(&kernel[..kernel_size]);
-    // Updates destination ZBI container/item header.
-    let dest_kernel_header =
-        Ref::<_, ZbiKernelHeader>::new_from_prefix(&mut dest[..]).unwrap().0.into_mut();
-    dest_kernel_header.container_header.length = (kernel_size - size_of::<ZbiHeader>())
-        .try_into()
-        .map_err(|_| EfiAppError::ArithmeticOverflow)?;
-    Ok(to_usize(dest_kernel_header.entry)?)
-}
-
-/// A helper for getting the total size of a ZBI container, including payload and header.
-fn zbi_container_size(zbi: &[u8]) -> Result<usize> {
-    let payload_length = ZbiContainer::parse(&zbi[..])?.get_payload_length_usize();
-    Ok(usize_add(payload_length, size_of::<ZbiHeader>())?)
-}
-
-/// A helper for getting the trailing unused portion of a ZBI container buffer.
-///
-/// Returns a tuple of used subslice and unused subslice
-fn zbi_get_unused_buffer(zbi: &mut [u8]) -> Result<(&mut [u8], &mut [u8])> {
-    let container_size = zbi_container_size(zbi)?;
-    Ok(zbi.split_at_mut(container_size))
-}
-
-/// Relocate a ZBI kernel to the trailing unused buffer.
-///
-/// Returns the original kernel subslice, relocated kernel subslice, and kernel entry offset.
-fn relocate_to_tail(kernel: &mut [u8]) -> Result<(&mut [u8], &mut [u8], usize)> {
-    let (original, relocated) = zbi_get_unused_buffer(kernel)?;
-    let relocated = aligned_subslice(relocated, ZIRCON_KERNEL_ALIGN)?;
-    let entry = relocate_kernel(original, relocated)?;
-    Ok((original, relocated, entry))
-}
-
-/// Load a ZBI kernel from the disk.
-///
-/// Returns the subslice the kernel is loaded to.
-fn load_fuchsia_simple<'a>(efi_entry: &EfiEntry, load: &'a mut [u8]) -> Result<&'a mut [u8]> {
-    let load = aligned_subslice(load, ZBI_ALIGNMENT_USIZE)?;
-
-    let mut gpt_devices = find_gpt_devices(&efi_entry)?;
-
-    // Gets FDT from EFI configuration table.
-    let (_, fdt_bytes) = get_efi_fdt(&efi_entry).ok_or_else(|| EfiAppError::NoFdt).unwrap();
-    let fdt = Fdt::new(fdt_bytes)?;
-
-    // Checks if UEFI loader passes any custom ZBI blob.
-    let (custom_zbi, load) = match fdt
-        .get_property("zircon", core::ffi::CStr::from_bytes_with_nul(b"zbi-blob\0").unwrap())
-    {
-        Ok(blob) => {
-            // Make to copy to make sure container is in an aligned buffer
-            load[..blob.len()].clone_from_slice(blob);
-            let (custom_zbi_buffer, remains) = zbi_get_unused_buffer(load)?;
-            (Some(ZbiContainer::parse(custom_zbi_buffer).unwrap()), remains)
-        }
-        _ => (None, load),
-    };
-    let load = aligned_subslice(load, ZIRCON_KERNEL_ALIGN)?;
-
-    // Reads ZBI header to compute image length.
-    gpt_devices.read_gpt_partition("zircon_a", 0, &mut load[..size_of::<ZbiHeader>()]).unwrap();
-    let image_length = Ref::<_, ZbiHeader>::new_from_prefix(&mut load[..])
-        .ok_or_else(|| EfiAppError::NoZbiImage)?
-        .0
-        .into_ref()
-        .length;
-
-    // Reads the entire image.
-    gpt_devices
-        .read_gpt_partition(
-            "zircon_a",
-            0,
-            &mut load[..usize_add(size_of::<ZbiHeader>(), image_length)?],
-        )
-        .unwrap();
-
-    let mut zbi = ZbiContainer::parse(&mut load[..])?;
-    // Appends current slot zbi item. The demo always boots from A slot.
-    zbi.create_entry_with_payload(
-        ZbiType::CmdLine,
-        0,
-        ZbiFlags::default(),
-        b"zvb.current_slot=_a",
-    )?;
-    // Appends device custom ZBI blob.
-    if let Some(val) = custom_zbi {
-        zbi.extend(&val)?;
-    }
-
-    Ok(load)
-}
+use liberror::Error;
+use libgbl::{
+    fuchsia_boot::{zircon_load_verify_abr, zircon_part_name},
+    Result,
+};
 
 /// Check if the disk GPT layout is a Fuchsia device layout.
 pub fn is_fuchsia_gpt(efi_entry: &EfiEntry) -> Result<()> {
-    let mut gpt_devices = find_gpt_devices(&efi_entry)?;
+    let mut gpt_devices = find_block_devices(&efi_entry)?;
     let partitions: [&[&str]; 8] = [
         &["zircon_a"],
         &["zircon_b"],
@@ -156,42 +31,32 @@ pub fn is_fuchsia_gpt(efi_entry: &EfiEntry) -> Result<()> {
         &["vbmeta_a"],
         &["vbmeta_b"],
         &["vbmeta_r"],
-        &["misc", "durable_boot"],
         &["fvm"],
+        &["misc", "durable_boot"],
     ];
-    for partition in partitions {
-        if !partition.iter().any(|v| gpt_devices.find_partition(*v).is_ok()) {
-            return Err(EfiAppError::NotFound.into());
-        }
+    if !partitions
+        .iter()
+        .all(|&partition| partition.iter().any(|v| gpt_devices.find_partition(*v).is_ok()))
+    {
+        return Err(Error::NotFound.into());
     }
+
     Ok(())
 }
 
-// The following implements a demo for booting Fuchsia ZBI kernel from disk. It currently targets
-// at the Vim3 development board
-// (https://fuchsia.dev/fuchsia-src/development/hardware/khadas-vim3?hl=en).
-//
-// To run the demo:
-//   1. Complete all steps in the link above to setup Vim3 as a Fuchsia device.
-//   2. Reboot the device into fastboot mode.
-//   3. Run "fastboot stage <path to the EFI binary> && fastboot oem run-staged-efi"
-//
-// The demo has a number of simplifications:
-//
-//   * No A/B/R slot switching is performed. It always boot from zircon_a slot.
-//   * No AVB is performed.
-//
-// The missing pieces above are currently under development as part of the full end-to-end boot
-// flow in libgbl, which will eventually replace this demo. The demo is currently used as an
-// end-to-end test for libraries developed so far.
+/// Loads, verifies and boots Fuchsia according to A/B/R.
 pub fn fuchsia_boot_demo(efi_entry: EfiEntry) -> Result<()> {
     efi_println!(efi_entry, "Try booting as Fuchsia/Zircon");
 
-    // Allocate buffer for load.
+    // Allocates buffer for load.
     let mut load_buffer = vec![0u8; 128 * 1024 * 1024]; // 128MB
-    let zbi_kernel = load_fuchsia_simple(&efi_entry, &mut load_buffer[..])?;
-    #[allow(unused_variables)]
-    let (original, relocated, kernel_entry) = relocate_to_tail(&mut zbi_kernel[..])?;
+    let (_zbi_items, _kernel, slot) = {
+        let mut blks = find_block_devices(&efi_entry)?;
+        let partitions = &blks.as_gbl_parts()?;
+        let mut ops = Ops { efi_entry: &efi_entry, partitions };
+        zircon_load_verify_abr(&mut ops, &mut load_buffer)?
+    };
+    efi_println!(efi_entry, "Booting from slot: {}", zircon_part_name(Some(slot)));
 
     #[cfg(target_arch = "aarch64")]
     {
@@ -199,15 +64,24 @@ pub fn fuchsia_boot_demo(efi_entry: EfiEntry) -> Result<()> {
         // The map is not used for now. We currently rely on UEFI firmware to pass memory map via
         // an raw zbi blob in device tree. Long term we want to support adding from EFI memory maps
         // if none is provided.
-        let (_, remains) = zbi_get_unused_buffer(relocated)?;
+        let item_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size();
+        let (_, remains) = _zbi_items.split_at_mut(item_size);
         let _ = efi::exit_boot_services(efi_entry, remains).unwrap();
-        // SAFETY: For demo, we assume images are provided valid.
-        unsafe { boot::aarch64::jump_zircon_el2_or_lower(relocated, kernel_entry, original) };
+        // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
+        // assume the caller has addressed all safety and security concerns.
+        unsafe { boot::aarch64::jump_zircon_el2_or_lower(_kernel, _zbi_items) };
     }
 
     #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
     {
-        unimplemented!();
+        let items_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size();
+        let (_, remains) = _zbi_items.split_at_mut(items_size);
+        // `exit_boot_service` returnes EFI memory map that is used to derive and append MEM_CONFIG
+        // items.
+        let _ = efi::exit_boot_services(efi_entry, remains).unwrap();
+        // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
+        // assume the caller has addressed all safety and security concerns.
+        unsafe { boot::x86::zbi_boot(_kernel, _zbi_items) };
     }
 
     #[cfg(target_arch = "riscv64")]
diff --git a/gbl/efi/src/lib.rs b/gbl/efi/src/lib.rs
new file mode 100644
index 0000000..9ee0155
--- /dev/null
+++ b/gbl/efi/src/lib.rs
@@ -0,0 +1,111 @@
+// Copyright 2023, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This EFI application implements a demo for booting Android/Fuchsia from disk. See
+//! bootable/libbootloader/gbl/README.md for how to run the demo. See comments of
+//! `android_boot:android_boot_demo()` and `fuchsia_boot:fuchsia_boot_demo()` for
+//! supported/unsupported features at the moment.
+
+#![cfg_attr(not(test), no_std)]
+
+// For the `vec!` macro
+#[macro_use]
+extern crate alloc;
+
+mod efi_blocks;
+mod error;
+mod ops;
+#[macro_use]
+mod utils;
+
+// Currently un-testable modules.
+//
+// The libefi API surface is large and complex; rather than trying to mock it all out at once, we
+// will selectively enable modules for test as they become mockable.
+#[cfg(not(test))]
+mod android_boot;
+#[cfg(not(test))]
+mod avb;
+#[cfg(not(test))]
+mod fastboot;
+#[cfg(not(test))]
+mod fuchsia_boot;
+#[cfg(not(test))]
+mod net;
+
+// In tests, map the `efi_mocks` module as `efi`. This allows other modules to `use crate::efi`
+// and automatically pick up the correct one.
+#[cfg(not(test))]
+pub(crate) use efi;
+#[cfg(test)]
+pub(crate) use efi_mocks as efi;
+
+#[cfg(not(test))]
+use {
+    core::fmt::Write,
+    efi::{efi_print, efi_println, EfiEntry},
+    libgbl::{GblOps, Result},
+    utils::loaded_image_path,
+};
+
+#[cfg(not(test))]
+enum TargetOs {
+    Android,
+    Fuchsia,
+}
+
+#[cfg(not(test))]
+fn get_target_os(entry: &EfiEntry) -> TargetOs {
+    let mut buf = [0u8; 1];
+    if fuchsia_boot::is_fuchsia_gpt(&entry).is_ok()
+        || entry
+            .system_table()
+            .runtime_services()
+            .get_variable(&efi::GBL_EFI_VENDOR_GUID, efi::GBL_EFI_OS_BOOT_TARGET_VARNAME, &mut buf)
+            .is_ok()
+    {
+        TargetOs::Fuchsia
+    } else {
+        TargetOs::Android
+    }
+}
+
+/// GBL EFI application logic entry point.
+#[cfg(not(test))]
+pub fn app_main(entry: EfiEntry) -> Result<()> {
+    let mut ops = ops::Ops { efi_entry: &entry, partitions: &[] };
+
+    efi_println!(entry, "****Rust EFI Application****");
+    if let Ok(v) = loaded_image_path(&entry) {
+        efi_println!(entry, "Image path: {}", v);
+    }
+
+    match ops.should_stop_in_fastboot() {
+        Ok(true) => {
+            fastboot::fastboot(&entry)?;
+        }
+        Ok(false) => {}
+        Err(e) => {
+            efi_println!(entry, "Warning: error while checking fastboot trigger ({:?})", e);
+            efi_println!(entry, "Ignoring error and continuing with normal boot");
+        }
+    }
+
+    match get_target_os(&entry) {
+        TargetOs::Fuchsia => fuchsia_boot::fuchsia_boot_demo(entry)?,
+        TargetOs::Android => android_boot::android_boot_demo(entry)?,
+    }
+
+    Ok(())
+}
diff --git a/gbl/efi/src/main.rs b/gbl/efi/src/main.rs
deleted file mode 100644
index e06a9b6..0000000
--- a/gbl/efi/src/main.rs
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// This EFI application implements a demo for booting Android/Fuchsia from disk. See
-// bootable/libbootloader/gbl/README.md for how to run the demo. See comments of
-// `android_boot:android_boot_demo()` and `fuchsia_boot:fuchsia_boot_demo()` for
-// supported/unsupported features at the moment.
-
-#![no_std]
-#![no_main]
-
-// For the `vec!` macro
-#[macro_use]
-extern crate alloc;
-use core::fmt::Write;
-
-use efi::defs::EfiSystemTable;
-use efi::protocol::android_boot::AndroidBootProtocol;
-use efi::{efi_print, efi_println, initialize};
-
-#[macro_use]
-mod utils;
-use error::Result;
-use utils::{loaded_image_path, wait_key_stroke};
-
-#[cfg(target_arch = "riscv64")]
-mod riscv64;
-
-mod android_boot;
-mod avb;
-mod error;
-mod fastboot;
-mod fuchsia_boot;
-mod net;
-
-fn main(image_handle: *mut core::ffi::c_void, systab_ptr: *mut EfiSystemTable) -> Result<()> {
-    // SAFETY: Called only once here upon EFI app entry.
-    let entry = unsafe { initialize(image_handle, systab_ptr)? };
-
-    efi_println!(entry, "****Rust EFI Application****");
-    if let Ok(v) = loaded_image_path(&entry) {
-        efi_println!(entry, "Image path: {}", v);
-    }
-
-    efi_println!(entry, "Press 'f' to enter fastboot.");
-    match wait_key_stroke(&entry, 'f', 2000) {
-        Ok(true) => {
-            efi_println!(entry, "'f' pressed.");
-            let android_boot_protocol = entry
-                .system_table()
-                .boot_services()
-                .find_first_and_open::<AndroidBootProtocol>()
-                .ok();
-            fastboot::run_fastboot(&entry, android_boot_protocol.as_ref())?;
-        }
-        _ => {}
-    }
-
-    // For simplicity, we pick bootflow based on GPT layout.
-    if fuchsia_boot::is_fuchsia_gpt(&entry).is_ok() {
-        fuchsia_boot::fuchsia_boot_demo(entry)?;
-    } else {
-        android_boot::android_boot_demo(entry)?;
-    }
-
-    Ok(())
-}
-
-#[no_mangle]
-pub extern "C" fn efi_main(image_handle: *mut core::ffi::c_void, systab_ptr: *mut EfiSystemTable) {
-    main(image_handle, systab_ptr).unwrap();
-    loop {}
-}
diff --git a/gbl/efi/src/net.rs b/gbl/efi/src/net.rs
index b426882..d6f32e4 100644
--- a/gbl/efi/src/net.rs
+++ b/gbl/efi/src/net.rs
@@ -12,24 +12,22 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::{
-    error::{EfiAppError, Result},
-    utils::{get_device_path, loop_with_timeout, ms_to_100ns},
-};
+use crate::error::{listen_to_unified, recv_to_unified, send_to_unified};
+use crate::utils::{get_device_path, loop_with_timeout};
 use alloc::{boxed::Box, vec::Vec};
 use core::{
     fmt::Write,
     sync::atomic::{AtomicU64, Ordering},
 };
 use efi::{
-    defs::{
-        EfiEvent, EfiMacAddress, EFI_STATUS_ALREADY_STARTED, EFI_STATUS_NOT_STARTED,
-        EFI_TIMER_DELAY_TIMER_PERIODIC,
-    },
     efi_print, efi_println,
     protocol::{simple_network::SimpleNetworkProtocol, Protocol},
+    utils::{ms_to_100ns, Timeout},
     DeviceHandle, EfiEntry, EventNotify, EventType, Tpl,
 };
+use efi_types::{EfiEvent, EfiMacAddress, EFI_TIMER_DELAY_TIMER_PERIODIC};
+use gbl_async::{yield_now, YieldCounter};
+use liberror::{Error, Result};
 use smoltcp::{
     iface::{Config, Interface, SocketSet},
     phy,
@@ -46,22 +44,20 @@ const ETHERNET_FRAME_SIZE: usize = 1536;
 // Update period in milliseconds for `NETWORK_TIMESTAMP`.
 const NETWORK_TIMESTAMP_UPDATE_PERIOD: u64 = 50;
 // Size of the socket tx/rx application data buffer.
-const SOCKET_TX_RX_BUFFER: usize = 64 * 1024;
+const SOCKET_TX_RX_BUFFER: usize = 256 * 1024;
 
 /// Performs a shutdown and restart of the simple network protocol.
 fn reset_simple_network<'a>(snp: &Protocol<'a, SimpleNetworkProtocol>) -> Result<()> {
     match snp.shutdown() {
-        Err(e) if !e.is_efi_err(EFI_STATUS_NOT_STARTED) => return Err(e.into()),
+        Err(e) if e != Error::NotStarted => return Err(e),
         _ => {}
     };
 
     match snp.start() {
-        Err(e) if !e.is_efi_err(EFI_STATUS_ALREADY_STARTED) => {
-            return Err(e.into());
-        }
+        Err(e) if e != Error::AlreadyStarted => return Err(e),
         _ => {}
     };
-    snp.initialize(0, 0).unwrap();
+    snp.initialize(0, 0)?;
     Ok(snp.reset(true)?)
 }
 
@@ -98,7 +94,7 @@ impl<'a> EfiNetworkDevice<'a> {
 impl Drop for EfiNetworkDevice<'_> {
     fn drop(&mut self) {
         if let Err(e) = self.protocol.shutdown() {
-            if !e.is_efi_err(EFI_STATUS_NOT_STARTED) {
+            if e != Error::NotStarted {
                 // If shutdown fails, the protocol might still be operating on transmit buffers,
                 // which can cause undefined behavior. Thus we need to panic.
                 panic!("Failed to shutdown EFI network. {:?}", e);
@@ -287,7 +283,7 @@ fn find_net_device(efi_entry: &EfiEntry) -> Result<DeviceHandle> {
         // Finds the minimum path lexicographically.
         .min_by(|lhs, rhs| Ord::cmp(lhs.1.text().unwrap(), rhs.1.text().unwrap()))
         .map(|(h, _)| h)
-        .ok_or(EfiAppError::NotFound.into())
+        .ok_or(Error::NotFound.into())
 }
 
 /// Derives a link local ethernet mac address and IPv6 address from `EfiMacAddress`.
@@ -317,13 +313,14 @@ pub struct EfiTcpSocket<'a, 'b> {
     interface: &'b mut Interface,
     sockets: &'b mut SocketSet<'b>,
     efi_entry: &'a EfiEntry,
+    io_yield_counter: YieldCounter,
 }
 
 impl<'a, 'b> EfiTcpSocket<'a, 'b> {
     /// Resets the socket and starts listening for new TCP connection.
     pub fn listen(&mut self, port: u16) -> Result<()> {
         self.get_socket().abort();
-        self.get_socket().listen(port)?;
+        self.get_socket().listen(port).map_err(listen_to_unified)?;
         Ok(())
     }
 
@@ -350,53 +347,78 @@ impl<'a, 'b> EfiTcpSocket<'a, 'b> {
         return !self.get_socket().is_open() || self.get_socket().state() == tcp::State::CloseWait;
     }
 
+    /// Sets the maximum number of bytes to read or write before a force await.
+    pub fn set_io_yield_threshold(&mut self, threshold: u64) {
+        self.io_yield_counter = YieldCounter::new(threshold)
+    }
+
     /// Receives exactly `out.len()` number of bytes to `out`.
-    pub fn receive_exact(&mut self, out: &mut [u8], timeout: u64) -> Result<()> {
-        let mut recv_size = 0;
-        loop_with_timeout(self.efi_entry, timeout, || -> core::result::Result<Result<()>, bool> {
+    pub async fn receive_exact(&mut self, out: &mut [u8], timeout: u64) -> Result<()> {
+        let timer = Timeout::new(self.efi_entry, timeout)?;
+        let mut curr = &mut out[..];
+        while !curr.is_empty() {
             self.poll();
+            let mut has_progress = false;
+
             if self.is_closed() {
-                return Ok(Err(EfiAppError::PeerClosed.into()));
+                return Err(Error::Disconnected);
+            } else if timer.check()? {
+                return Err(Error::Timeout);
             } else if self.get_socket().can_recv() {
-                let this_recv = match self.get_socket().recv_slice(&mut out[recv_size..]) {
-                    Err(e) => return Ok(Err(e.into())),
-                    Ok(v) => v,
-                };
-                recv_size += this_recv;
-                if recv_size == out.len() {
-                    return Ok(Ok(()));
-                }
+                let recv_size = self.get_socket().recv_slice(curr).map_err(recv_to_unified)?;
+                curr = curr.get_mut(recv_size..).ok_or(Error::BadIndex(recv_size))?;
+                has_progress = recv_size > 0;
+                // Forces a yield to the executor if the data received/sent reaches a certain
+                // threshold. This is to prevent the async code from holding up the CPU for too long
+                // in case IO speed is high and the executor uses cooperative scheduling.
+                self.io_yield_counter.increment(recv_size.try_into().unwrap()).await;
+            }
 
-                return Err(this_recv > 0);
+            match has_progress {
+                true => timer.reset(timeout)?,
+                _ => yield_now().await,
             }
-            Err(false)
-        })?
-        .ok_or(EfiAppError::Timeout)?
+        }
+        Ok(())
     }
 
     /// Sends exactly `data.len()` number of bytes from `data`.
-    pub fn send_exact(&mut self, data: &[u8], timeout: u64) -> Result<()> {
-        let mut sent_size = 0;
-        let mut last_send_queue = 0usize;
-        loop_with_timeout(self.efi_entry, timeout, || -> core::result::Result<Result<()>, bool> {
+    pub async fn send_exact(&mut self, data: &[u8], timeout: u64) -> Result<()> {
+        let timer = Timeout::new(self.efi_entry, timeout)?;
+        let mut curr = &data[..];
+        let mut last_send_queue = self.get_socket().send_queue();
+        loop {
             self.poll();
-            if sent_size == data.len() && self.get_socket().send_queue() == 0 {
-                return Ok(Ok(()));
+            if curr.is_empty() && self.get_socket().send_queue() == 0 {
+                return Ok(());
             } else if self.is_closed() {
-                return Ok(Err(EfiAppError::PeerClosed.into()));
+                return Err(Error::Disconnected.into());
+            } else if timer.check()? {
+                return Err(Error::Timeout.into());
+            }
+
+            let mut has_progress = false;
+            // Checks if any data in the queue is sent.
+            if self.get_socket().send_queue() != last_send_queue {
+                last_send_queue = self.get_socket().send_queue();
+                has_progress = true;
             }
-            // As long as some data is sent, reset the timeout.
-            let reset = self.get_socket().send_queue() != last_send_queue;
-            if self.get_socket().can_send() && sent_size < data.len() {
-                sent_size += match self.get_socket().send_slice(&data[sent_size..]) {
-                    Err(e) => return Ok(Err(e.into())),
-                    Ok(v) => v,
-                };
+            // Checks if there are more data to be queued.
+            if self.get_socket().can_send() && !curr.is_empty() {
+                let sent = self.get_socket().send_slice(curr).map_err(send_to_unified)?;
+                curr = curr.get(sent..).ok_or(Error::BadIndex(sent))?;
+                // Forces a yield to the executor if the data received/sent reaches a certain
+                // threshold. This is to prevent the async code from holding up the CPU for too long
+                // in case IO speed is high and the executor uses cooperative scheduling.
+                self.io_yield_counter.increment(sent.try_into().unwrap()).await;
+                has_progress |= sent > 0;
+            }
+
+            match has_progress {
+                true => timer.reset(timeout)?,
+                _ => yield_now().await,
             }
-            last_send_queue = self.get_socket().send_queue();
-            Err(reset)
-        })?
-        .ok_or(EfiAppError::Timeout)?
+        }
     }
 
     /// Gets the smoltcp `Interface` for this socket.
@@ -429,7 +451,9 @@ where
         NETWORK_TIMESTAMP.fetch_add(NETWORK_TIMESTAMP_UPDATE_PERIOD, Ordering::Relaxed);
     };
     let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
-    let timer = bs.create_event(EventType::TimerNotifySignal, Some(&mut notify))?;
+    // SAFETY: the notification callback never allocates, deallocates, or panics.
+    let timer =
+        unsafe { bs.create_event_with_notification(EventType::TimerNotifySignal, &mut notify) }?;
     bs.set_timer(
         &timer,
         EFI_TIMER_DELAY_TIMER_PERIODIC,
@@ -441,6 +465,16 @@ where
     let snp = bs.open_protocol::<SimpleNetworkProtocol>(snp_dev)?;
     reset_simple_network(&snp)?;
 
+    // The TCP stack requires ICMP6 solicitation for discovery. Enable promiscuous mode so that all
+    // uni/multicast packets can be captured.
+    match snp.set_promiscuous_mode() {
+        Err(e) => efi_println!(
+            efi_entry,
+            "Warning: Failed to set promiscuous mode {e:?}. Device may be undiscoverable",
+        ),
+        _ => {}
+    }
+
     // Gets our MAC address and IPv6 address.
     // We can also consider getting this from vendor configuration.
     let (ll_mac, ll_ip6_addr) = ll_mac_ip6_addr_from_efi_mac(snp.mode()?.current_address);
@@ -466,6 +500,7 @@ where
         interface: &mut interface,
         sockets: &mut sockets,
         efi_entry: efi_entry,
+        io_yield_counter: YieldCounter::new(u64::MAX),
     };
 
     Ok(f(&mut socket))
diff --git a/gbl/efi/src/ops.rs b/gbl/efi/src/ops.rs
new file mode 100644
index 0000000..1cc2b80
--- /dev/null
+++ b/gbl/efi/src/ops.rs
@@ -0,0 +1,299 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implements [Gbl::Ops] for the EFI environment.
+
+use crate::{
+    efi,
+    efi_blocks::EfiBlockDeviceIo,
+    utils::{get_efi_fdt, wait_key_stroke},
+};
+use alloc::alloc::{alloc, handle_alloc_error, Layout};
+use core::{ffi::CStr, fmt::Write, mem::MaybeUninit, num::NonZeroUsize, slice::from_raw_parts_mut};
+use efi::{
+    efi_print, efi_println, protocol::gbl_efi_image_loading::GblImageLoadingProtocol, EfiEntry,
+};
+use efi_types::{GblEfiImageInfo, PARTITION_NAME_LEN_U16};
+use fdt::Fdt;
+use liberror::Error;
+use libgbl::{
+    ops::{AvbIoError, AvbIoResult, CertPermanentAttributes, ImageBuffer, SHA256_DIGEST_SIZE},
+    partition::PartitionBlockDevice,
+    slots::{BootToken, Cursor},
+    BootImages, GblOps, Result as GblResult,
+};
+use safemath::SafeNum;
+use zbi::ZbiContainer;
+use zerocopy::AsBytes;
+
+pub struct Ops<'a, 'b> {
+    pub efi_entry: &'a EfiEntry,
+    pub partitions: &'b [PartitionBlockDevice<'b, &'b mut EfiBlockDeviceIo<'a>>],
+}
+
+impl<'a> Ops<'a, '_> {
+    /// Gets the property of an FDT node from EFI FDT.
+    ///
+    /// Returns `None` if fail to get the node
+    fn get_efi_fdt_prop(&self, path: &str, prop: &CStr) -> Option<&'a [u8]> {
+        let (_, fdt_bytes) = get_efi_fdt(&self.efi_entry)?;
+        let fdt = Fdt::new(fdt_bytes).ok()?;
+        fdt.get_property(path, prop).ok()
+    }
+
+    /// Get buffer for partition loading and verification.
+    /// Uses GBL EFI ImageLoading protocol.
+    ///
+    /// # Arguments
+    /// * `image_name` - image name to differentiate the buffer properties. Processing is limited
+    /// to first [PARTITION_NAME_LEN_U16] symbols, and the remaining will be ignored.
+    /// * `size` - requested buffer size
+    ///
+    /// # Return
+    /// * Ok(ImageBuffer) - Return buffer for partition loading and verification.
+    /// * Err(_) - on error
+    fn get_buffer_image_loading(
+        &mut self,
+        image_name: &str,
+        size: NonZeroUsize,
+    ) -> GblResult<ImageBuffer<'static>> {
+        let mut image_type = [0u16; PARTITION_NAME_LEN_U16];
+        image_type.iter_mut().zip(image_name.encode_utf16()).for_each(|(dst, src)| {
+            *dst = src;
+        });
+        let image_info = GblEfiImageInfo { ImageType: image_type, SizeBytes: size.get() };
+        let efi_image_buffer = self
+            .efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblImageLoadingProtocol>()?
+            .get_buffer(&image_info)?;
+
+        // EfiImageBuffer -> ImageBuffer
+        // Make sure not to drop efi_image_buffer since we transferred ownership to ImageBuffer
+        let buffer = efi_image_buffer.take();
+        Ok(ImageBuffer::new(buffer))
+    }
+
+    /// Get buffer for partition loading and verification.
+    /// Uses provided allocator.
+    ///
+    /// # Arguments
+    /// * `efi_entry` - EFI entry
+    /// * `image_name` - image name to differentiate the buffer properties
+    /// * `size` - requested buffer size
+    ///
+    /// # Return
+    /// * Ok(ImageBuffer) - Return buffer for partition loading and verification.
+    /// * Err(_) - on error
+    // SAFETY:
+    // Allocated buffer is leaked intentionally. ImageBuffer is assumed to reference static memory.
+    // ImageBuffer is not expected to be released, and is allocated to hold data necessary for next
+    // boot stage (kernel boot). All allocated buffers are expected to be used by kernel.
+    fn allocate_image_buffer(
+        image_name: &str,
+        size: NonZeroUsize,
+    ) -> liberror::Result<ImageBuffer<'static>> {
+        const KERNEL_ALIGNMENT: usize = 2 * 1024 * 1024;
+        const FDT_ALIGNMENT: usize = 8;
+        const BOOTCMD_SIZE: usize = 16 * 1024;
+        let size = match image_name {
+            "boot" => size.get(),
+            "ramdisk" => (SafeNum::from(size.get()) + BOOTCMD_SIZE).try_into()?,
+            _ => size.get(),
+        };
+        // Check for `from_raw_parts_mut()` safety requirements.
+        assert!(size < isize::MAX.try_into().unwrap());
+        let align = match image_name {
+            "boot" => KERNEL_ALIGNMENT,
+            "fdt" => FDT_ALIGNMENT,
+            _ => 1,
+        };
+
+        if size == 0 {
+            return Err(Error::Other(Some("allocate_image_buffer() expects non zero size")));
+        }
+
+        let layout = Layout::from_size_align(size, align).or(Err(Error::InvalidAlignment))?;
+        // SAFETY:
+        // `layout.size()` is checked to be not zero.
+        let ptr = unsafe { alloc(layout) } as *mut MaybeUninit<u8>;
+        if ptr.is_null() {
+            handle_alloc_error(layout);
+        }
+
+        // SAFETY:
+        // `ptr` is checked to be not Null.
+        // `ptr` is a valid pointer to start of a single memory region of `size`-bytes because it
+        // was just returned by alloc. Buffer alignment requirement for u8 is 1-byte which is
+        // always the case.
+        // `alloc()` makes sure there is no other allocation of the same memory region until
+        // current one is released.
+        // `size` is a valid size of the memory region since `alloc()` succeeded.
+        //
+        // Total size of buffer is not greater than `isize::MAX` since it is checked at the
+        // beginning of the function.
+        //
+        // `ptr + size` doesn't wrap since it is returned from alloc and it didn't fail.
+        let buf = unsafe { from_raw_parts_mut(ptr, size) };
+
+        Ok(ImageBuffer::new(buf))
+    }
+}
+
+impl Write for Ops<'_, '_> {
+    fn write_str(&mut self, s: &str) -> core::fmt::Result {
+        efi_print!(self.efi_entry, "{}", s);
+        Ok(())
+    }
+}
+
+impl<'a, 'b> GblOps<'b> for Ops<'a, 'b>
+where
+    Self: 'b,
+{
+    type PartitionBlockIo = &'b mut EfiBlockDeviceIo<'a>;
+
+    fn console_out(&mut self) -> Option<&mut dyn Write> {
+        Some(self)
+    }
+
+    /// UEFI console uses \r\n newline.
+    fn console_newline(&self) -> &'static str {
+        "\r\n"
+    }
+
+    fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
+        // TODO(b/349829690): also query GblSlotProtocol.get_boot_reason() for board-specific
+        // fastboot triggers.
+        efi_println!(self.efi_entry, "Press Backspace to enter fastboot");
+        let found = wait_key_stroke(
+            self.efi_entry,
+            |key| key.unicode_char == 0x08 || (key.unicode_char == 0x0 && key.scan_code == 0x08),
+            2000,
+        );
+        if matches!(found, Ok(true)) {
+            efi_println!(self.efi_entry, "Backspace pressed, entering fastboot");
+        }
+        // TODO(b/358377120): pass the UEFI error when liberror::Error support lands.
+        found.or(Err(Error::Other(Some("wait for key stroke error"))))
+    }
+
+    fn preboot(&mut self, _: BootImages) -> Result<(), Error> {
+        unimplemented!();
+    }
+
+    fn partitions(&self) -> Result<&'b [PartitionBlockDevice<'b, Self::PartitionBlockIo>], Error> {
+        Ok(self.partitions)
+    }
+
+    fn zircon_add_device_zbi_items(
+        &mut self,
+        container: &mut ZbiContainer<&mut [u8]>,
+    ) -> Result<(), Error> {
+        // TODO(b/353272981): Switch to use OS configuration protocol once it is implemented on
+        // existing platforms such as VIM3.
+        Ok(match self.get_efi_fdt_prop("zircon", c"zbi-blob") {
+            Some(blob) => container.extend_unaligned(blob).map_err(|_| "Failed to append ZBI")?,
+            _ => efi_println!(self.efi_entry, "No device ZBI items.\r\n"),
+        })
+    }
+
+    fn do_fastboot<B: gbl_storage::AsBlockDevice>(&self, _: &mut Cursor<B>) -> GblResult<()> {
+        unimplemented!();
+    }
+
+    fn load_slot_interface<'c, B: gbl_storage::AsBlockDevice>(
+        &'c mut self,
+        _: &'c mut B,
+        _: BootToken,
+    ) -> GblResult<Cursor<'c, B>> {
+        unimplemented!();
+    }
+
+    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
+        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
+        Ok(true)
+    }
+
+    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
+        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
+        Ok(0)
+    }
+
+    fn avb_write_rollback_index(
+        &mut self,
+        _rollback_index_location: usize,
+        _index: u64,
+    ) -> AvbIoResult<()> {
+        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
+        Ok(())
+    }
+
+    fn avb_cert_read_permanent_attributes(
+        &mut self,
+        attributes: &mut CertPermanentAttributes,
+    ) -> AvbIoResult<()> {
+        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
+        let perm_attr = self
+            .get_efi_fdt_prop("gbl", c"avb-cert-permanent-attributes")
+            .ok_or(AvbIoError::NotImplemented)?;
+        attributes.as_bytes_mut().clone_from_slice(perm_attr);
+        Ok(())
+    }
+
+    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
+        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
+        let hash = self
+            .get_efi_fdt_prop("gbl", c"avb-cert-permanent-attributes-hash")
+            .ok_or(AvbIoError::NotImplemented)?;
+        Ok(hash.try_into().map_err(|_| AvbIoError::Io)?)
+    }
+
+    fn get_image_buffer<'c>(
+        &mut self,
+        image_name: &str,
+        size: NonZeroUsize,
+    ) -> GblResult<ImageBuffer<'c>> {
+        self.get_buffer_image_loading(image_name, size)
+            .or(Self::allocate_image_buffer(image_name, size)
+                .map_err(|e| libgbl::IntegrationError::UnificationError(e)))
+    }
+
+    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
+        // On Cuttlefish, the device tree comes from the UEFI config tables.
+        // TODO(b/353272981): once we've settled on the device tree UEFI protocol, use that
+        // instead to provide a Cuttlefish-specific backend.
+        Some(get_efi_fdt(&self.efi_entry)?.1)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use efi_mocks::MockEfi;
+    use mockall::predicate::eq;
+
+    #[test]
+    fn ops_write_trait() {
+        let mut mock_efi = MockEfi::new();
+
+        mock_efi.con_out.expect_write_str().with(eq("foo bar")).return_const(Ok(()));
+        let installed = mock_efi.install();
+
+        let mut ops = Ops { efi_entry: installed.entry(), partitions: &[] };
+
+        assert!(write!(&mut ops, "{} {}", "foo", "bar").is_ok());
+    }
+}
diff --git a/gbl/efi/src/utils.rs b/gbl/efi/src/utils.rs
index f3652a0..8f0f594 100644
--- a/gbl/efi/src/utils.rs
+++ b/gbl/efi/src/utils.rs
@@ -12,139 +12,34 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use alloc::vec::Vec;
+use crate::efi;
 use core::ffi::CStr;
-
-use crate::error::{EfiAppError, Result};
 use efi::{
-    defs::{EfiGuid, EFI_TIMER_DELAY_TIMER_RELATIVE},
     protocol::{
-        block_io::BlockIoProtocol,
         device_path::{DevicePathProtocol, DevicePathText, DevicePathToTextProtocol},
         loaded_image::LoadedImageProtocol,
         simple_text_input::SimpleTextInputProtocol,
-        Protocol,
     },
-    DeviceHandle, EfiEntry, EventType,
+    utils::Timeout,
+    DeviceHandle, EfiEntry,
 };
+use efi_types::{EfiGuid, EfiInputKey};
 use fdt::FdtHeader;
-use gbl_storage::{
-    required_scratch_size, AsBlockDevice, AsMultiBlockDevices, BlockInfo, BlockIo, BlockIoError,
-};
+use liberror::Error;
+use libgbl::Result;
+use safemath::SafeNum;
 
 pub const EFI_DTB_TABLE_GUID: EfiGuid =
     EfiGuid::new(0xb1b621d5, 0xf19c, 0x41a5, [0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0]);
 
-/// Checks and converts an integer into usize
-pub fn to_usize<T: TryInto<usize>>(val: T) -> Result<usize> {
-    Ok(val.try_into().map_err(|_| EfiAppError::ArithmeticOverflow)?)
-}
-
-/// Rounds up a usize convertible number.
-pub fn usize_roundup<L: TryInto<usize>, R: TryInto<usize>>(lhs: L, rhs: R) -> Result<usize> {
-    // (lhs + rhs - 1) / rhs * rhs
-    let lhs = to_usize(lhs)?;
-    let rhs = to_usize(rhs)?;
-    let compute = || lhs.checked_add(rhs.checked_sub(1)?)?.checked_div(rhs)?.checked_mul(rhs);
-    Ok(compute().ok_or_else(|| EfiAppError::ArithmeticOverflow)?)
-}
-
-/// Adds two usize convertible numbers and checks overflow.
-pub fn usize_add<L: TryInto<usize>, R: TryInto<usize>>(lhs: L, rhs: R) -> Result<usize> {
-    Ok(to_usize(lhs)?.checked_add(to_usize(rhs)?).ok_or_else(|| EfiAppError::ArithmeticOverflow)?)
-}
-
 /// Gets a subslice of the given slice with aligned address according to `alignment`
-pub fn aligned_subslice(bytes: &mut [u8], alignment: usize) -> Result<&mut [u8]> {
+pub fn aligned_subslice(
+    bytes: &mut [u8],
+    alignment: usize,
+) -> core::result::Result<&mut [u8], Error> {
     let addr = bytes.as_ptr() as usize;
-    Ok(&mut bytes[usize_roundup(addr, alignment)? - addr..])
-}
-
-// Implement a block device on top of BlockIoProtocol
-pub struct EfiBlockIo<'a>(pub Protocol<'a, BlockIoProtocol>);
-
-impl BlockIo for EfiBlockIo<'_> {
-    fn info(&mut self) -> BlockInfo {
-        BlockInfo {
-            block_size: self.0.media().unwrap().block_size as u64,
-            num_blocks: (self.0.media().unwrap().last_block + 1) as u64,
-            alignment: core::cmp::max(1, self.0.media().unwrap().io_align as u64),
-        }
-    }
-
-    fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        self.0
-            .read_blocks(blk_offset, out)
-            .map_err(|_| BlockIoError::Others(Some("EFI BLOCK_IO protocol read error")))
-    }
-
-    fn write_blocks(
-        &mut self,
-        blk_offset: u64,
-        data: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        self.0
-            .write_blocks(blk_offset, data)
-            .map_err(|_| BlockIoError::Others(Some("EFI BLOCK_IO protocol write error")))
-    }
-}
-
-/// `EfiGptDevice` wraps a `EfiBlockIo` and implements `AsBlockDevice` interface.
-pub struct EfiGptDevice<'a> {
-    io: EfiBlockIo<'a>,
-    scratch: Vec<u8>,
-}
-
-const MAX_GPT_ENTRIES: u64 = 128;
-
-impl<'a> EfiGptDevice<'a> {
-    /// Initialize from a `BlockIoProtocol` EFI protocol
-    pub fn new(protocol: Protocol<'a, BlockIoProtocol>) -> Result<Self> {
-        let mut io = EfiBlockIo(protocol);
-        let scratch = vec![0u8; required_scratch_size(&mut io, MAX_GPT_ENTRIES)?];
-        Ok(Self { io, scratch })
-    }
-}
-
-impl AsBlockDevice for EfiGptDevice<'_> {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
-        f(&mut self.io, &mut self.scratch[..], MAX_GPT_ENTRIES)
-    }
-}
-
-pub struct EfiMultiBlockDevices<'a>(pub alloc::vec::Vec<EfiGptDevice<'a>>);
-
-impl AsMultiBlockDevices for EfiMultiBlockDevices<'_> {
-    fn for_each(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64),
-    ) -> core::result::Result<(), Option<&'static str>> {
-        for (idx, ele) in self.0.iter_mut().enumerate() {
-            f(ele, u64::try_from(idx).unwrap());
-        }
-        Ok(())
-    }
-}
-
-/// Finds and returns all block devices that have a valid GPT.
-pub fn find_gpt_devices(efi_entry: &EfiEntry) -> Result<EfiMultiBlockDevices> {
-    let bs = efi_entry.system_table().boot_services();
-    let block_dev_handles = bs.locate_handle_buffer_by_protocol::<BlockIoProtocol>()?;
-    let mut gpt_devices = Vec::<EfiGptDevice>::new();
-    for handle in block_dev_handles.handles() {
-        let mut gpt_dev = EfiGptDevice::new(bs.open_protocol::<BlockIoProtocol>(*handle)?)?;
-        match gpt_dev.sync_gpt() {
-            Ok(_) => {
-                gpt_devices.push(gpt_dev);
-            }
-            _ => {}
-        };
-    }
-    Ok(EfiMultiBlockDevices(gpt_devices))
+    let aligned_start = SafeNum::from(addr).round_up(alignment) - addr;
+    Ok(&mut bytes[aligned_start.try_into()?..])
 }
 
 /// Helper function to get the `DevicePathText` from a `DeviceHandle`.
@@ -186,36 +81,28 @@ pub fn get_efi_fdt<'a>(entry: &'a EfiEntry) -> Option<(&FdtHeader, &[u8])> {
 #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
 pub fn efi_to_e820_mem_type(efi_mem_type: u32) -> u32 {
     match efi_mem_type {
-        efi::defs::EFI_MEMORY_TYPE_LOADER_CODE
-        | efi::defs::EFI_MEMORY_TYPE_LOADER_DATA
-        | efi::defs::EFI_MEMORY_TYPE_BOOT_SERVICES_CODE
-        | efi::defs::EFI_MEMORY_TYPE_BOOT_SERVICES_DATA
-        | efi::defs::EFI_MEMORY_TYPE_CONVENTIONAL_MEMORY => boot::x86::E820_ADDRESS_TYPE_RAM,
-        efi::defs::EFI_MEMORY_TYPE_RUNTIME_SERVICES_CODE
-        | efi::defs::EFI_MEMORY_TYPE_RUNTIME_SERVICES_DATA
-        | efi::defs::EFI_MEMORY_TYPE_MEMORY_MAPPED_IO
-        | efi::defs::EFI_MEMORY_TYPE_MEMORY_MAPPED_IOPORT_SPACE
-        | efi::defs::EFI_MEMORY_TYPE_PAL_CODE
-        | efi::defs::EFI_MEMORY_TYPE_RESERVED_MEMORY_TYPE => boot::x86::E820_ADDRESS_TYPE_RESERVED,
-        efi::defs::EFI_MEMORY_TYPE_UNUSABLE_MEMORY => boot::x86::E820_ADDRESS_TYPE_UNUSABLE,
-        efi::defs::EFI_MEMORY_TYPE_ACPIRECLAIM_MEMORY => boot::x86::E820_ADDRESS_TYPE_ACPI,
-        efi::defs::EFI_MEMORY_TYPE_ACPIMEMORY_NVS => boot::x86::E820_ADDRESS_TYPE_NVS,
-        efi::defs::EFI_MEMORY_TYPE_PERSISTENT_MEMORY => boot::x86::E820_ADDRESS_TYPE_PMEM,
+        efi_types::EFI_MEMORY_TYPE_LOADER_CODE
+        | efi_types::EFI_MEMORY_TYPE_LOADER_DATA
+        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_CODE
+        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_DATA
+        | efi_types::EFI_MEMORY_TYPE_CONVENTIONAL_MEMORY => boot::x86::E820_ADDRESS_TYPE_RAM,
+        efi_types::EFI_MEMORY_TYPE_RUNTIME_SERVICES_CODE
+        | efi_types::EFI_MEMORY_TYPE_RUNTIME_SERVICES_DATA
+        | efi_types::EFI_MEMORY_TYPE_MEMORY_MAPPED_IO
+        | efi_types::EFI_MEMORY_TYPE_MEMORY_MAPPED_IOPORT_SPACE
+        | efi_types::EFI_MEMORY_TYPE_PAL_CODE
+        | efi_types::EFI_MEMORY_TYPE_RESERVED_MEMORY_TYPE => boot::x86::E820_ADDRESS_TYPE_RESERVED,
+        efi_types::EFI_MEMORY_TYPE_UNUSABLE_MEMORY => boot::x86::E820_ADDRESS_TYPE_UNUSABLE,
+        efi_types::EFI_MEMORY_TYPE_ACPIRECLAIM_MEMORY => boot::x86::E820_ADDRESS_TYPE_ACPI,
+        efi_types::EFI_MEMORY_TYPE_ACPIMEMORY_NVS => boot::x86::E820_ADDRESS_TYPE_NVS,
+        efi_types::EFI_MEMORY_TYPE_PERSISTENT_MEMORY => boot::x86::E820_ADDRESS_TYPE_PMEM,
         v => panic!("Unmapped EFI memory type {v}"),
     }
 }
 
 /// A helper to convert a bytes slice containing a null-terminated string to `str`
-pub fn cstr_bytes_to_str(data: &[u8]) -> Result<&str> {
-    Ok(CStr::from_bytes_until_nul(data)
-        .map_err(|_| EfiAppError::InvalidString)?
-        .to_str()
-        .map_err(|_| EfiAppError::InvalidString)?)
-}
-
-/// Converts 1 ms to number of 100 nano seconds
-pub fn ms_to_100ns(ms: u64) -> Result<u64> {
-    Ok(ms.checked_mul(1000 * 10).ok_or(EfiAppError::ArithmeticOverflow)?)
+pub fn cstr_bytes_to_str(data: &[u8]) -> core::result::Result<&str, Error> {
+    Ok(CStr::from_bytes_until_nul(data)?.to_str()?)
 }
 
 /// Repetitively runs a closure until it signals completion or timeout.
@@ -228,17 +115,11 @@ pub fn loop_with_timeout<F, R>(efi_entry: &EfiEntry, timeout_ms: u64, mut f: F)
 where
     F: FnMut() -> core::result::Result<R, bool>,
 {
-    let bs = efi_entry.system_table().boot_services();
-    let timer = bs.create_event(EventType::Timer, None)?;
-    bs.set_timer(&timer, EFI_TIMER_DELAY_TIMER_RELATIVE, ms_to_100ns(timeout_ms)?)?;
-    while !bs.check_event(&timer)? {
+    let timeout = Timeout::new(efi_entry, timeout_ms)?;
+    while !timeout.check()? {
         match f() {
-            Ok(v) => {
-                return Ok(Some(v));
-            }
-            Err(true) => {
-                bs.set_timer(&timer, EFI_TIMER_DELAY_TIMER_RELATIVE, ms_to_100ns(timeout_ms)?)?;
-            }
+            Ok(v) => return Ok(Some(v)),
+            Err(true) => timeout.reset(timeout_ms)?,
             _ => {}
         }
     }
@@ -248,19 +129,20 @@ where
 /// Waits for a key stroke value from simple text input.
 ///
 /// Returns `Ok(true)` if the expected key stroke is read, `Ok(false)` if timeout, `Err` otherwise.
-pub fn wait_key_stroke(efi_entry: &EfiEntry, expected: char, timeout_ms: u64) -> Result<bool> {
+pub fn wait_key_stroke(
+    efi_entry: &EfiEntry,
+    pred: impl Fn(EfiInputKey) -> bool,
+    timeout_ms: u64,
+) -> Result<bool> {
     let input = efi_entry
         .system_table()
         .boot_services()
         .find_first_and_open::<SimpleTextInputProtocol>()?;
     loop_with_timeout(efi_entry, timeout_ms, || -> core::result::Result<Result<bool>, bool> {
         match input.read_key_stroke() {
-            Ok(Some(key)) => match char::decode_utf16([key.unicode_char]).next().unwrap() {
-                Ok(ch) if ch == expected => Ok(Ok(true)),
-                _ => Err(false),
-            },
-            Ok(None) => Err(false),
+            Ok(Some(key)) if pred(key) => Ok(Ok(true)),
             Err(e) => Ok(Err(e.into())),
+            _ => Err(false),
         }
     })?
     .unwrap_or(Ok(false))
diff --git a/gbl/integration/aosp_u-boot-mainline/workspace.bzl b/gbl/integration/aosp_u-boot-mainline/workspace.bzl
index 5d5b653..251508e 100644
--- a/gbl/integration/aosp_u-boot-mainline/workspace.bzl
+++ b/gbl/integration/aosp_u-boot-mainline/workspace.bzl
@@ -19,19 +19,29 @@ u-boot-mainline branch.
 
 load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
 load("@gbl//toolchain:gbl_workspace_util.bzl", "android_rust_prebuilts", "gbl_llvm_prebuilts")
-load("@kernel_toolchain_info//:dict.bzl", "CLANG_VERSION")
 
-def rust_crate_build_file(name, crate_name = "", deps = [], features = [], rustc_flags = []):
+_CLANG_VERSION = "r530567"
+
+def rust_crate_build_file(
+        name,
+        rule = "rust_library",
+        crate_name = "",
+        deps = [],
+        proc_macro_deps = [],
+        features = [],
+        rustc_flags = []):
     """Generate BUILD file content for a rust crate
 
     This helper is suitable for crates that have straightforward build rules. Specifically, the
-    crate contains a single `rust_library` targets that includes all source files under the repo.
+    crate contains a single Rust target that includes all source files under the repo.
     There is not any need of preprocessing, patching or source generation.
 
     Args:
         name (String): name of the rust_library target.
+        rule (String): Bazel Rust rule to build, defaults to `rust_library`.
         crate_name (String): name of the rust_library crate, same as name by default.
         deps (List of strings): The `deps` field.
+        proc_macro_deps (List of strings): The `proc_macro_deps` field.
         features (List of strings): The `features` field.
         rustc_flags (List of strings): The `rustc_flags` field.
 
@@ -40,12 +50,13 @@ def rust_crate_build_file(name, crate_name = "", deps = [], features = [], rustc
     """
     crate_name = name if len(crate_name) == 0 else crate_name
     deps = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in deps]))
+    proc_macro_deps = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in proc_macro_deps]))
     features = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in features]))
     rustc_flags = "[{}]".format(",".join(["\"{}\"".format(ele) for ele in rustc_flags]))
     return """
-load("@rules_rust//rust:defs.bzl", "rust_library")
+load("@rules_rust//rust:defs.bzl", \"{rule}\")
 
-rust_library(
+{rule}(
     name = \"{}\",
     crate_name = \"{}\",
     srcs = glob(["**/*.rs"]),
@@ -54,8 +65,9 @@ rust_library(
     rustc_flags ={},
     visibility = ["//visibility:public"],
     deps = {},
+    proc_macro_deps = {}
 )
-""".format(name, crate_name, features, rustc_flags, deps)
+""".format(name, crate_name, features, rustc_flags, deps, proc_macro_deps, rule = rule)
 
 def define_gbl_workspace(name = None):
     """Set up worksapce dependencies for GBL
@@ -86,13 +98,13 @@ def define_gbl_workspace(name = None):
 
     native.new_local_repository(
         name = "llvm_linux_x86_64_prebuilts",
-        path = "prebuilts/clang/host/linux-x86/clang-{}".format(CLANG_VERSION),
+        path = "prebuilts/clang/host/linux-x86/clang-{}".format(_CLANG_VERSION),
         build_file_content = "",
     )
 
     native.new_local_repository(
         name = "linux_x86_64_sysroot",
-        path = "build/kernel/build-tools",
+        path = "prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.17-4.8",
         build_file_content = """exports_files(glob(["**/*"]))
 cc_library(
     name = "linux_x86_64_sysroot_include",
@@ -139,6 +151,18 @@ cc_library(
         build_file = "@gbl//libfdt:BUILD.libfdt_c.bazel",
     )
 
+    native.new_local_repository(
+        name = "libufdt_c",
+        path = "external/libufdt",
+        build_file = "@gbl//libfdt:BUILD.libufdt_c.bazel",
+    )
+
+    native.new_local_repository(
+        name = "libdttable_c",
+        path = "external/libufdt/utils/src",
+        build_file = "@gbl//libdttable:BUILD.libdttable_c.bazel",
+    )
+
     native.new_local_repository(
         name = "arm_trusted_firmware",
         path = "external/arm-trusted-firmware",
@@ -248,7 +272,120 @@ cc_library(
         build_file = "@gbl//smoltcp:BUILD.smoltcp.bazel",
     )
 
-    # Following are third party rust crates dependencies.
+    native.new_local_repository(
+        name = "arrayvec",
+        path = "external/rust/crates/arrayvec",
+        build_file_content = rust_crate_build_file(
+            "arrayvec",
+            rustc_flags = ["-A", "dead_code"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "downcast",
+        path = "external/rust/crates/downcast",
+        build_file_content = rust_crate_build_file(
+            "downcast",
+            features = ["default", "std"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "fragile",
+        path = "external/rust/crates/fragile",
+        build_file_content = rust_crate_build_file("fragile"),
+    )
+
+    native.new_local_repository(
+        name = "lazy_static",
+        path = "external/rust/crates/lazy_static",
+        build_file_content = rust_crate_build_file("lazy_static"),
+    )
+
+    native.new_local_repository(
+        name = "mockall",
+        path = "external/rust/crates/mockall",
+        build_file_content = rust_crate_build_file(
+            "mockall",
+            deps = [
+                "@cfg-if",
+                "@downcast",
+                "@fragile",
+                "@lazy_static",
+                "@predicates",
+                "@predicates_tree",
+            ],
+            proc_macro_deps = ["@mockall_derive"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "mockall_derive",
+        path = "external/rust/crates/mockall_derive",
+        build_file_content = rust_crate_build_file(
+            "mockall_derive",
+            rule = "rust_proc_macro",
+            deps = ["@cfg-if", "@proc-macro2", "@quote", "@syn"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "predicates",
+        path = "external/rust/crates/predicates",
+        build_file_content = rust_crate_build_file(
+            "predicates",
+            deps = ["@itertools", "@predicates_core", "@termcolor"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "predicates_core",
+        path = "external/rust/crates/predicates-core",
+        build_file_content = rust_crate_build_file("predicates_core"),
+    )
+
+    native.new_local_repository(
+        name = "predicates_tree",
+        path = "external/rust/crates/predicates-tree",
+        build_file_content = rust_crate_build_file(
+            "predicates_tree",
+            deps = ["@predicates_core", "@termtree"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "termcolor",
+        path = "external/rust/crates/termcolor",
+        build_file_content = rust_crate_build_file("termcolor"),
+    )
+
+    native.new_local_repository(
+        name = "termtree",
+        path = "external/rust/crates/termtree",
+        build_file_content = rust_crate_build_file("termtree"),
+    )
+
+    native.new_local_repository(
+        name = "zune_inflate",
+        path = "external/rust/crates/zune-inflate",
+        build_file_content = rust_crate_build_file(
+            "zune_inflate",
+            features = ["gzip"],
+        ),
+    )
+
+    native.new_local_repository(
+        name = "lz4_flex",
+        path = "external/rust/crates/lz4_flex",
+        build_file_content = rust_crate_build_file(
+            "lz4_flex",
+            features = ["safe-decode"],
+            rustc_flags = ["-A", "dead_code"],
+        ),
+    )
+
+    # Following are third party rust crates dependencies which already contain a
+    # BUILD file that we can use as-is without any modification.
 
     THIRD_PARTY_CRATES = [
         "bitflags",
diff --git a/gbl/libabr/BUILD b/gbl/libabr/BUILD
index aa1eef1..5f65a3d 100644
--- a/gbl/libabr/BUILD
+++ b/gbl/libabr/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_static_library", "rust_test")
 
 package(
@@ -23,11 +24,16 @@ rust_library(
     srcs = ["src/lib.rs"],
     crate_name = "abr",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//liberror",
+    ],
 )
 
 rust_test(
     name = "libabr_test",
     crate = ":libabr",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 rust_static_library(
@@ -39,12 +45,17 @@ rust_static_library(
     crate_name = "abr_c",
     crate_root = "src/c_staticlib.rs",
     edition = "2021",
-    deps = [":libabr"],
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        ":libabr",
+        "@gbl//liberror",
+    ],
 )
 
 rust_test(
     name = "libabr_c_test",
     crate = ":libabr_c",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 test_suite(
diff --git a/gbl/libabr/src/c_staticlib.rs b/gbl/libabr/src/c_staticlib.rs
index 0110580..0c9299c 100644
--- a/gbl/libabr/src/c_staticlib.rs
+++ b/gbl/libabr/src/c_staticlib.rs
@@ -19,12 +19,14 @@
 use abr::{
     get_and_clear_one_shot_flag, get_boot_slot, get_slot_info, get_slot_last_marked_active,
     mark_slot_active, mark_slot_successful, mark_slot_unbootable, set_one_shot_bootloader,
-    set_one_shot_recovery, AbrResult, Error, Ops, SlotIndex, SlotInfo as AbrSlotInfo, SlotState,
+    set_one_shot_recovery, AbrData, AbrSlotData, Ops, SlotIndex, SlotInfo as AbrSlotInfo,
+    SlotState, ABR_DATA_SIZE,
 };
 use core::{
     ffi::{c_char, c_uint, c_void},
     fmt::Write,
 };
+use liberror::{Error, Result};
 
 pub mod utils;
 
@@ -84,6 +86,10 @@ fn panic(panic: &core::panic::PanicInfo<'_>) -> ! {
 ///     void* context;
 ///     bool (*read_abr_metadata)(void* context, size_t size, uint8_t* buffer);
 ///     bool (*write_abr_metadata)(void* context, const uint8_t* buffer, size_t size);
+///     bool (*read_abr_metadata_custom)(void* context, AbrSlotData* a_slot_data,
+///                                      AbrSlotData* b_slot_data, uint8_t* one_shot_flags);
+///     bool (*write_abr_metadata_custom)(void* context, const AbrSlotData* a_slot_data,
+///                                       const AbrSlotData* b_slot_data, uint8_t one_shot_flags);
 /// } AbrOps;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
@@ -93,6 +99,22 @@ pub struct AbrOps {
         Option<unsafe extern "C" fn(context: *mut c_void, size: usize, buffer: *mut u8) -> bool>,
     pub write_abr_metadata:
         Option<unsafe extern "C" fn(context: *mut c_void, buffer: *const u8, size: usize) -> bool>,
+    pub read_abr_metadata_custom: Option<
+        unsafe extern "C" fn(
+            context: *mut c_void,
+            a_slot_data: *mut AbrSlotData,
+            b_slot_data: *mut AbrSlotData,
+            one_shot_flags: *mut u8,
+        ) -> bool,
+    >,
+    pub write_abr_metadata_custom: Option<
+        unsafe extern "C" fn(
+            context: *mut c_void,
+            a_slot_data: *const AbrSlotData,
+            b_slot_data: *const AbrSlotData,
+            one_shot_flags: u8,
+        ) -> bool,
+    >,
 }
 
 /// `AbrOpsSafe` wraps a reference to `AbrOps` and is created by an unsafe constructor that
@@ -108,7 +130,8 @@ impl<'a> AbrOpsSafe<'a> {
     /// # Safety
     ///
     /// * Caller must make sure that `ops.context` is either not used, or points to a valid and
-    ///   correct type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+    ///   correct type of value needed by `ops.read_abr_metadata`, `ops.write_abr_metadata`,
+    ///   `ops.read_abr_metadata_custom` and `ops.write_abr_metadata_custom`.
     unsafe fn new(ops: &'a AbrOps) -> Self {
         Self { ops, log: AbrPrintSysdeps {} }
     }
@@ -117,31 +140,80 @@ impl<'a> AbrOpsSafe<'a> {
 type AbrSlotIndex = c_uint;
 
 impl Ops for AbrOpsSafe<'_> {
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<(), Option<&'static str>> {
-        let read_abr_metadata =
-            self.ops.read_abr_metadata.ok_or(Some("Missing read_abr_metadata() method"))?;
-        // SAFETY:
-        // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused, or
-        //   a valid pointer to a correct type of object used by `self.ops.read_abr_metadata`.
-        // * `out` is a valid buffer
-        // * `out` is for reading data only and will not be retained by the function.
-        match unsafe { read_abr_metadata(self.ops.context, out.len(), out.as_mut_ptr() as _) } {
-            false => Err(Some("read_abr_metadata() failed")),
-            _ => Ok(()),
+    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
+        if let Some(f) = self.ops.read_abr_metadata.as_ref() {
+            // SAFETY:
+            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
+            //   or a valid pointer to a correct type of object used by
+            //   `self.ops.write_abr_metadata`.
+            // * `out` is a valid buffer
+            // * `out` is for reading data only and will not be retained by the function.
+            match unsafe { f(self.ops.context, out.len(), out.as_mut_ptr() as _) } {
+                false => Err(Error::Other(Some("read_abr_metadata() failed"))),
+                _ => Ok(()),
+            }
+        } else if let Some(f) = self.ops.read_abr_metadata_custom.as_ref() {
+            let mut data: AbrData = Default::default();
+            // SAFETY:
+            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
+            //   or a valid pointer to a correct type of object used by
+            //   `self.ops.read_abr_metadata_custom`.
+            // * Pointers to `slot_a`, `slot_b` and `one_shot_flags` are a valid memory locations.
+            // * `slot_a`, `slot_b` and `one_shot_flags` are for output and will not be retained by
+            //   the function.
+            match unsafe {
+                f(
+                    self.ops.context,
+                    &mut data.slot_data[SlotIndex::A as usize],
+                    &mut data.slot_data[SlotIndex::B as usize],
+                    &mut data.one_shot_flags,
+                )
+            } {
+                false => Err(Error::Other(Some("read_abr_metadata_custom() failed"))),
+                _ => Ok(out[..ABR_DATA_SIZE].clone_from_slice(&data.serialize())),
+            }
+        } else {
+            Err(Error::NotImplemented)
         }
     }
 
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<(), Option<&'static str>> {
-        let write_abr_metadata =
-            self.ops.write_abr_metadata.ok_or(Some("Missing write_abr_metadata() method"))?;
-        // SAFETY:
-        // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused, or
-        //   a valid pointer to a correct type of object used by `self.ops.write_abr_metadata`.
-        // * `data` is a valid buffer.
-        // * `data` is for input only and will not be retained by the function.
-        match unsafe { write_abr_metadata(self.ops.context, data.as_ptr() as _, data.len()) } {
-            false => Err(Some("write_abr_metadata() failed")),
-            _ => Ok(()),
+    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
+        if let Some(f) = self.ops.write_abr_metadata.as_ref() {
+            // SAFETY:
+            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
+            //   or a valid pointer to a correct type of object used by
+            //   `self.ops.write_abr_metadata`.
+            // * `data` is a valid buffer.
+            // * `data` is for input only and will not be retained by the function.
+            match unsafe { f(self.ops.context, data.as_ptr() as _, data.len()) } {
+                false => Err(Error::Other(Some("write_abr_metadata() failed"))),
+                _ => Ok(()),
+            }
+        } else if let Some(f) = self.ops.write_abr_metadata_custom.as_ref() {
+            let mut abr_data = [0u8; ABR_DATA_SIZE];
+            abr_data.clone_from_slice(
+                data.get(..ABR_DATA_SIZE).ok_or(Error::BufferTooSmall(Some(ABR_DATA_SIZE)))?,
+            );
+            let abr_data = AbrData::deserialize(&mut abr_data).unwrap();
+            // SAFETY:
+            // * By safety requirement of `AbrOpsSafe::new()`, `self.ops.context` is either unused,
+            //   or a valid pointer to a correct type of object used by
+            //   `self.ops.write_abr_metadata_custom`.
+            // * Pointers to `slot_a` and `slot_b` are a valid memory locations.
+            // * `slot_a` and `slot_b` are for input and will not be retained by the function.
+            match unsafe {
+                f(
+                    self.ops.context,
+                    &abr_data.slot_data[SlotIndex::A as usize],
+                    &abr_data.slot_data[SlotIndex::B as usize],
+                    abr_data.one_shot_flags,
+                )
+            } {
+                false => Err(Error::Other(Some("read_abr_metadata_custom() failed"))),
+                _ => Ok(()),
+            }
+        } else {
+            Err(Error::NotImplemented)
         }
     }
 
@@ -151,14 +223,14 @@ impl Ops for AbrOpsSafe<'_> {
 }
 
 /// A helper that extracts the return value and maps the result to an integer A/B/R result code.
-fn unpack_result<T: Into<O>, O>(res: AbrResult<T>, val: &mut O) -> c_uint {
+fn unpack_result<T: Into<O>, O>(res: Result<T>, val: &mut O) -> c_uint {
     match res {
         Err(e) => match e {
-            Error::BadMagic | Error::BadChecksum | Error::InvalidData => {
+            Error::BadMagic | Error::BadChecksum | Error::InvalidInput => {
                 ABR_RESULT_ERR_INVALID_DATA
             }
             Error::UnsupportedVersion => ABR_RESULT_ERR_UNSUPPORTED_VERSION,
-            Error::OpsError(_) => ABR_RESULT_ERR_IO,
+            _ => ABR_RESULT_ERR_IO,
         },
         Ok(v) => {
             *val = v.into();
@@ -172,8 +244,8 @@ fn unpack_result<T: Into<O>, O>(res: AbrResult<T>, val: &mut O) -> c_uint {
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 /// * Caller must make sure to pass either a NULL or valid pointer for `is_slot_marked_successful`.
 #[no_mangle]
 #[allow(non_snake_case)]
@@ -182,9 +254,14 @@ pub unsafe extern "C" fn AbrGetBootSlot(
     update_metadata: bool,
     is_slot_marked_successful: *mut bool,
 ) -> AbrSlotIndex {
-    let mut abr_ops = AbrOpsSafe::new(abr_ops.as_ref().unwrap());
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
     let (slot_index, successful) = get_boot_slot(&mut abr_ops, update_metadata);
-    match is_slot_marked_successful.as_mut() {
+    // SAFETY: function safety requires `out_slot` to be a valid pointer or `NULL`.
+    match unsafe { is_slot_marked_successful.as_mut() } {
         Some(v) => *v = successful,
         _ => {}
     };
@@ -215,8 +292,8 @@ pub extern "C" fn AbrGetSlotSuffix(slot_index: AbrSlotIndex) -> *const c_char {
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrMarkSlotActive(
@@ -227,10 +304,13 @@ pub unsafe extern "C" fn AbrMarkSlotActive(
         Ok(v) => v,
         Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
     };
-    unpack_result(
-        mark_slot_active(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), slot_index),
-        &mut (),
-    )
+
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
+    unpack_result(mark_slot_active(&mut abr_ops, slot_index), &mut ())
 }
 
 /// C interface wrapper of `abr::get_slot_last_marked_active()`
@@ -238,18 +318,22 @@ pub unsafe extern "C" fn AbrMarkSlotActive(
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops` and `out_slot`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrGetSlotLastMarkedActive(
     abr_ops: *const AbrOps,
     out_slot: *mut AbrSlotIndex,
 ) -> c_uint {
-    unpack_result(
-        get_slot_last_marked_active(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap())),
-        out_slot.as_mut().unwrap(),
-    )
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+    // SAFETY: function safety requires `out_slot` to be a valid pointer.
+    let out_slot = unsafe { out_slot.as_mut() }.unwrap();
+
+    unpack_result(get_slot_last_marked_active(&mut abr_ops), out_slot)
 }
 
 /// C interface wrapper of `abr::mark_slot_unbootable()`
@@ -257,8 +341,8 @@ pub unsafe extern "C" fn AbrGetSlotLastMarkedActive(
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrMarkSlotUnbootable(
@@ -269,10 +353,13 @@ pub unsafe extern "C" fn AbrMarkSlotUnbootable(
         Ok(v) => v,
         Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
     };
-    unpack_result(
-        mark_slot_unbootable(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), slot_index),
-        &mut (),
-    )
+
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
+    unpack_result(mark_slot_unbootable(&mut abr_ops, slot_index), &mut ())
 }
 
 /// C interface wrapper of `abr::mark_slot_successful()`
@@ -280,8 +367,8 @@ pub unsafe extern "C" fn AbrMarkSlotUnbootable(
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrMarkSlotSuccessful(
@@ -292,10 +379,13 @@ pub unsafe extern "C" fn AbrMarkSlotSuccessful(
         Ok(v) => v,
         Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
     };
-    unpack_result(
-        mark_slot_successful(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), slot_index),
-        &mut (),
-    )
+
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
+    unpack_result(mark_slot_successful(&mut abr_ops, slot_index), &mut ())
 }
 
 /// `SlotInfo` contains the current state of a A/B/R slot.
@@ -336,8 +426,8 @@ impl From<AbrSlotInfo> for SlotInfo {
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops` and 'info'.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrGetSlotInfo(
@@ -349,11 +439,15 @@ pub unsafe extern "C" fn AbrGetSlotInfo(
         Ok(v) => v,
         Err(_) => return ABR_RESULT_ERR_INVALID_DATA,
     };
-    unpack_result(
-        get_slot_info(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), slot_index)
-            .map(|v| SlotInfo::from(v)),
-        info.as_mut().unwrap(),
-    )
+
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+    // SAFETY: function safety requires `info` to be a valid pointer.
+    let info = unsafe { info.as_mut() }.unwrap();
+
+    unpack_result(get_slot_info(&mut abr_ops, slot_index).map(|v| SlotInfo::from(v)), info)
 }
 
 /// C interface wrapper of `abr::set_one_shot_recovery()`
@@ -361,15 +455,17 @@ pub unsafe extern "C" fn AbrGetSlotInfo(
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrSetOneShotRecovery(abr_ops: *const AbrOps, enable: bool) -> c_uint {
-    unpack_result(
-        set_one_shot_recovery(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), enable),
-        &mut (),
-    )
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
+    unpack_result(set_one_shot_recovery(&mut abr_ops, enable), &mut ())
 }
 
 /// C interface wrapper of `abr::set_one_shot_bootloader()`
@@ -377,15 +473,17 @@ pub unsafe extern "C" fn AbrSetOneShotRecovery(abr_ops: *const AbrOps, enable: b
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrSetOneShotBootloader(abr_ops: *const AbrOps, enable: bool) -> c_uint {
-    unpack_result(
-        set_one_shot_bootloader(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap()), enable),
-        &mut (),
-    )
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+
+    unpack_result(set_one_shot_bootloader(&mut abr_ops, enable), &mut ())
 }
 
 /// Gets and clears the one shot flag.
@@ -393,18 +491,22 @@ pub unsafe extern "C" fn AbrSetOneShotBootloader(abr_ops: *const AbrOps, enable:
 /// # Safety
 ///
 /// * Caller must make sure to pass a valid pointer for `abr_ops` and `flags`.
-/// * Caller must make sure that `ops.context` is either not used, or points to a valid and correct
-///   type of value needed by `ops.read_abr_metadata` and `ops.write_abr_metadata`.
+/// * Caller must make sure that `abr_ops.context` is either not used, or points to a valid and
+///   correct type of value needed by `abr_ops.read_abr_metadata` and `abr_ops.write_abr_metadata`.
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrGetAndClearOneShotFlags(
     abr_ops: *const AbrOps,
     flags: *mut c_uint,
 ) -> c_uint {
-    unpack_result(
-        get_and_clear_one_shot_flag(&mut AbrOpsSafe::new(abr_ops.as_ref().unwrap())),
-        flags.as_mut().unwrap(),
-    )
+    // SAFETY: function safety requires `abr_ops` to be a valid pointer.
+    let abr_ops = unsafe { abr_ops.as_ref() }.unwrap();
+    // SAFETY: function safety requires `abr_ops.context` to be valid for `AbrOpsSafe::new`.
+    let mut abr_ops = unsafe { AbrOpsSafe::new(abr_ops) };
+    // SAFETY: function safety requires `flags` to be a valid pointer.
+    let flags = unsafe { flags.as_mut() }.unwrap();
+
+    unpack_result(get_and_clear_one_shot_flag(&mut abr_ops), flags)
 }
 
 // Needed because of no-std environment in static lib build.
diff --git a/gbl/libabr/src/lib.rs b/gbl/libabr/src/lib.rs
index dd0075c..6da4b16 100644
--- a/gbl/libabr/src/lib.rs
+++ b/gbl/libabr/src/lib.rs
@@ -12,10 +12,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! Fuchsia A/B/R boot slot library.
+
 #![cfg_attr(not(test), no_std)]
 
 use core::{cmp::min, ffi::c_uint, fmt::Write, mem::size_of};
 
+use liberror::{Error, Result};
+
 const ABR_MAGIC: &[u8; 4] = b"\0AB0";
 const ABR_MAJOR_VERSION: u8 = 2;
 const ABR_MINOR_VERSION: u8 = 2;
@@ -29,38 +33,41 @@ pub const ONE_SHOT_RECOVERY: u8 = 1 << 0;
 pub const ONE_SHOT_BOOTLOADER: u8 = 1 << 1;
 
 const ABR_MAX_PRIORITY: u8 = 15;
-const ABR_MAX_TRIES_REMAINING: u8 = 7;
-
-/// Error type for this library.
-#[derive(Debug)]
-pub enum Error {
-    BadMagic,
-    UnsupportedVersion,
-    BadChecksum,
-    InvalidData,
-    OpsError(Option<&'static str>),
-}
-
-impl From<Option<&'static str>> for Error {
-    fn from(val: Option<&'static str>) -> Self {
-        Error::OpsError(val)
-    }
-}
+/// Maximum number of retries.
+pub const ABR_MAX_TRIES_REMAINING: u8 = 7;
 
 /// `Ops` provides the backend interfaces needed by A/B/R APIs.
 pub trait Ops {
     /// Reads exactly `out.len()` bytes into `out` from the persistent storage hosting the A/B/R
     /// metadata.
-    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<(), Option<&'static str>>;
+    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()>;
 
     /// Writes exactly `data.len()` bytes from `data` to the persistent storage hosting the A/B/R
     /// metadata.
-    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<(), Option<&'static str>>;
+    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()>;
 
     /// Returns an optional console writer for logging error messages.
     fn console(&mut self) -> Option<&mut dyn Write>;
 }
 
+impl Ops for [u8; ABR_DATA_SIZE] {
+    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
+        Ok(out
+            .clone_from_slice(self.get(..out.len()).ok_or(Error::BufferTooSmall(Some(out.len())))?))
+    }
+
+    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
+        Ok(self
+            .get_mut(..data.len())
+            .ok_or(Error::BufferTooSmall(Some(data.len())))?
+            .clone_from_slice(data))
+    }
+
+    fn console(&mut self) -> Option<&mut dyn Write> {
+        None
+    }
+}
+
 /// Helper macro for printing ABR log messages.
 macro_rules! avb_print {
     ( $abr_ops:expr, $( $x:expr ),* $(,)? ) => {
@@ -74,8 +81,12 @@ macro_rules! avb_print {
 /// `SlotIndex` represents the A/B/R slot index.
 #[derive(Copy, Clone, Eq, PartialEq, Debug)]
 pub enum SlotIndex {
+    /// A slot; normal boot.
     A,
+    /// B slot; normal boot.
     B,
+    /// R slot; recovery boot. Doesn't have any associated metadata (e.g. cannot be active, no
+    /// retries), but is unconditionally used as a fallback if both A and B are unbootable.
     R,
 }
 
@@ -105,39 +116,46 @@ impl From<SlotIndex> for c_uint {
 impl TryFrom<c_uint> for SlotIndex {
     type Error = Error;
 
-    fn try_from(val: c_uint) -> core::result::Result<SlotIndex, Self::Error> {
+    fn try_from(val: c_uint) -> Result<SlotIndex> {
         match val {
             v if v == (SlotIndex::A).into() => Ok(SlotIndex::A),
             v if v == (SlotIndex::B).into() => Ok(SlotIndex::B),
             v if v == (SlotIndex::R).into() => Ok(SlotIndex::R),
-            _ => Err(Error::InvalidData),
+            _ => Err(Error::InvalidInput),
         }
     }
 }
 
 /// `SlotInfo` represents the current state of a A/B/R slot.
 pub enum SlotState {
+    /// Slot has successfully booted.
     Successful,
-    Bootable(u8), // u8 = tries remaining
+    /// Slot can be attempted but is not known to be successful. Contained value is the number
+    /// of boot attempts remaining before being marked as `Unbootable`.
+    Bootable(u8),
+    /// Slot is unbootable.
     Unbootable,
 }
 
 /// `SlotInfo` contains the current state and active status of a A/B/R slot.
 pub struct SlotInfo {
+    /// The [SlotState] describing the bootability.
     pub state: SlotState,
+    /// Whether this is currently the active slot.
     pub is_active: bool,
 }
 
-/// Error type for this library.
-pub type AbrResult<T> = Result<T, Error>;
-
 /// `AbrSlotData` is the wire format metadata for A/B slot.
 #[repr(C, packed)]
-#[derive(Copy, Clone, Debug, Eq, PartialEq)]
+#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]
 pub struct AbrSlotData {
+    /// Slot priority. Unbootable slots should always have priority 0.
     pub priority: u8,
+    /// Boot attempts remaining.
     pub tries_remaining: u8,
+    /// Whether this slot is known successful.
     pub successful_boot: u8,
+    /// Reserved for future use; must be set to 0.
     pub reserved: u8,
 }
 
@@ -202,17 +220,26 @@ impl AbrSlotData {
 #[repr(C, packed)]
 #[derive(Copy, Clone, Debug, Eq, PartialEq)]
 pub struct AbrData {
+    /// Magic value; must be [ABR_MAGIC].
     pub magic: [u8; 4],
+    /// Metadata major version, incremented when changes may break backwards compatibility.
     pub version_major: u8,
+    /// Metadata minor version, incremented when changes do not break backwards compatibility.
     pub version_minor: u8,
+    /// Reserved for future use; must be 0.
     pub reserved: [u8; 2],
+    /// A/B slot data.
     pub slot_data: [AbrSlotData; 2],
+    /// One-shot to bootloader/recovery.
     pub one_shot_flags: u8,
+    /// Reserved for future use; must be 0.
     pub reserved2: [u8; 11],
+    /// CRC32 checksum of this struct.
     pub crc32: u32,
 }
 
-const ABR_DATA_SIZE: usize = size_of::<AbrData>();
+/// Size of `AbrData`
+pub const ABR_DATA_SIZE: usize = size_of::<AbrData>();
 
 impl AbrData {
     /// Returns the numeric index value for a `SlotIndex`. This is for indexing into
@@ -236,7 +263,7 @@ impl AbrData {
     }
 
     /// Reads, parses and checks metadata from persistent storage.
-    fn deserialize(abr_ops: &mut dyn Ops) -> AbrResult<Self> {
+    pub fn deserialize(abr_ops: &mut dyn Ops) -> Result<Self> {
         let mut bytes = [0u8; ABR_DATA_SIZE];
         abr_ops.read_abr_metadata(&mut bytes[..])?;
         // Usually, the parsing below should be done using the zerocopy crate. However, the Fuchsia
@@ -275,7 +302,7 @@ impl AbrData {
     }
 
     /// Updates CRC32 and writes metadata to persistent storage.
-    fn serialize(&mut self) -> [u8; ABR_DATA_SIZE] {
+    pub fn serialize(&mut self) -> [u8; ABR_DATA_SIZE] {
         let mut res = [0u8; ABR_DATA_SIZE];
         res[..4].clone_from_slice(&self.magic);
         res[4] = self.version_major;
@@ -368,14 +395,14 @@ impl Default for AbrData {
 /// with save_metadata_if_changed().
 ///
 /// On success returns Ok((abr_data, abr_data_orig)). On failure an Error is returned.
-fn load_metadata(abr_ops: &mut dyn Ops) -> AbrResult<(AbrData, AbrData)> {
+fn load_metadata(abr_ops: &mut dyn Ops) -> Result<(AbrData, AbrData)> {
     let mut abr_data_orig = AbrData::null();
     let mut abr_data = match AbrData::deserialize(abr_ops) {
         Ok(v) => {
             abr_data_orig = v;
             v
         }
-        Err(Error::OpsError(e)) => {
+        Err(Error::Other(e)) => {
             avb_print!(abr_ops, "read_abr_metadata error: {:?}\n", e);
             return Err(e.into());
         }
@@ -393,7 +420,7 @@ fn load_metadata(abr_ops: &mut dyn Ops) -> AbrResult<(AbrData, AbrData)> {
 }
 
 /// Serializes and saves metadata to persistent storage.
-fn save_metadata(abr_ops: &mut dyn Ops, abr_data: &mut AbrData) -> AbrResult<()> {
+fn save_metadata(abr_ops: &mut dyn Ops, abr_data: &mut AbrData) -> Result<()> {
     let mut bytes = abr_data.serialize();
     abr_ops.write_abr_metadata(&mut bytes)?;
     Ok(())
@@ -404,7 +431,7 @@ fn save_metadata_if_changed(
     abr_ops: &mut dyn Ops,
     abr_data: &mut AbrData,
     abr_data_orig: &AbrData,
-) -> AbrResult<()> {
+) -> Result<()> {
     match abr_data == abr_data_orig {
         true => Ok(()),
         _ => save_metadata(abr_ops, abr_data),
@@ -485,10 +512,10 @@ pub fn get_boot_slot(abr_ops: &mut dyn Ops, update_metadata: bool) -> (SlotIndex
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_active(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResult<()> {
+pub fn mark_slot_active(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
     if slot_index == SlotIndex::R {
         avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as active.\n");
-        return Err(Error::InvalidData);
+        return Err(Error::InvalidInput);
     }
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
     // Make requested slot top priority, unsuccessful, and with max tries.
@@ -508,7 +535,7 @@ pub fn mark_slot_active(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResu
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_slot_last_marked_active(abr_ops: &mut dyn Ops) -> AbrResult<SlotIndex> {
+pub fn get_slot_last_marked_active(abr_ops: &mut dyn Ops) -> Result<SlotIndex> {
     let (abr_data, _) = load_metadata(abr_ops)?;
     Ok(
         match abr_data.slot_data(SlotIndex::B).priority > abr_data.slot_data(SlotIndex::A).priority
@@ -523,10 +550,10 @@ pub fn get_slot_last_marked_active(abr_ops: &mut dyn Ops) -> AbrResult<SlotIndex
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_unbootable(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResult<()> {
+pub fn mark_slot_unbootable(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
     if slot_index == SlotIndex::R {
         avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as unbootable.\n");
-        return Err(Error::InvalidData);
+        return Err(Error::InvalidInput);
     }
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
     abr_data.slot_data_mut(slot_index).set_slot_unbootable();
@@ -537,16 +564,16 @@ pub fn mark_slot_unbootable(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Abr
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn mark_slot_successful(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResult<()> {
+pub fn mark_slot_successful(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<()> {
     if slot_index == SlotIndex::R {
         avb_print!(abr_ops, "Invalid argument: Cannot mark slot R as successful.\n");
-        return Err(Error::InvalidData);
+        return Err(Error::InvalidInput);
     }
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
 
     if !abr_data.slot_data(slot_index).is_slot_bootable() {
         avb_print!(abr_ops, "Invalid argument: Cannot mark unbootable slot as successful.\n");
-        return Err(Error::InvalidData);
+        return Err(Error::InvalidInput);
     }
 
     abr_data.slot_data_mut(slot_index).tries_remaining = 0;
@@ -571,7 +598,7 @@ pub fn mark_slot_successful(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Abr
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_slot_info(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResult<SlotInfo> {
+pub fn get_slot_info(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> Result<SlotInfo> {
     let (abr_data, _) = load_metadata(abr_ops)?;
     Ok(match slot_index {
         // Assume that R slot is always OK.
@@ -595,7 +622,7 @@ pub fn get_slot_info(abr_ops: &mut dyn Ops, slot_index: SlotIndex) -> AbrResult<
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn set_one_shot_recovery(abr_ops: &mut dyn Ops, enable: bool) -> AbrResult<()> {
+pub fn set_one_shot_recovery(abr_ops: &mut dyn Ops, enable: bool) -> Result<()> {
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
     abr_data.set_one_shot_recovery(enable);
     save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
@@ -605,7 +632,7 @@ pub fn set_one_shot_recovery(abr_ops: &mut dyn Ops, enable: bool) -> AbrResult<(
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn set_one_shot_bootloader(abr_ops: &mut dyn Ops, enable: bool) -> AbrResult<()> {
+pub fn set_one_shot_bootloader(abr_ops: &mut dyn Ops, enable: bool) -> Result<()> {
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
     abr_data.set_one_shot_bootloader(enable);
     save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)
@@ -615,7 +642,7 @@ pub fn set_one_shot_bootloader(abr_ops: &mut dyn Ops, enable: bool) -> AbrResult
 ///
 /// TODO(b/338243123): Detailed documentation is available in Fuchsia upstream header
 /// "src/firmware/lib/abr/include/lib/abr/abr.h", which will migrate to the GBL repo.
-pub fn get_and_clear_one_shot_flag(abr_ops: &mut dyn Ops) -> AbrResult<u8> {
+pub fn get_and_clear_one_shot_flag(abr_ops: &mut dyn Ops) -> Result<u8> {
     let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
     let res = abr_data.one_shot_flags;
     abr_data.one_shot_flags = 0;
diff --git a/gbl/libabr/src/utils.rs b/gbl/libabr/src/utils.rs
index 0c446d3..81dd36d 100644
--- a/gbl/libabr/src/utils.rs
+++ b/gbl/libabr/src/utils.rs
@@ -43,7 +43,8 @@ pub extern "C" fn AbrIsOneShotRecoveryBootSet(flags: u8) -> bool {
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrIsOneShotRecoveryBoot(abr_data: *const AbrData) -> bool {
-    AbrIsOneShotRecoveryBootSet(abr_data.as_ref().unwrap().one_shot_flags)
+    // SAFETY: function safety requires `abr_data` to be a valid pointer.
+    AbrIsOneShotRecoveryBootSet(unsafe { abr_data.as_ref() }.unwrap().one_shot_flags)
 }
 
 /// Checks if one-shot bootloader boot is set in the given one-shot flags
@@ -61,7 +62,8 @@ pub extern "C" fn AbrIsOneShotBootloaderBootSet(flags: u8) -> bool {
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrIsOneShotBootloaderBoot(abr_data: *const AbrData) -> bool {
-    AbrIsOneShotBootloaderBootSet(abr_data.as_ref().unwrap().one_shot_flags)
+    // SAFETY: function safety requires `abr_data` to be a valid pointer.
+    AbrIsOneShotBootloaderBootSet(unsafe { abr_data.as_ref() }.unwrap().one_shot_flags)
 }
 
 /// Sets the one-shot recovery flag in the given AbrData.
@@ -72,7 +74,8 @@ pub unsafe extern "C" fn AbrIsOneShotBootloaderBoot(abr_data: *const AbrData) ->
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrSetOneShotRecoveryBoot(abr_data: *mut AbrData, enable: bool) {
-    abr_data.as_mut().unwrap().set_one_shot_recovery(enable);
+    // SAFETY: function safety requires `abr_data` to be a valid pointer.
+    unsafe { abr_data.as_mut() }.unwrap().set_one_shot_recovery(enable);
 }
 
 /// Sets the one-shot bootloader flag in the given AbrData.
@@ -83,5 +86,6 @@ pub unsafe extern "C" fn AbrSetOneShotRecoveryBoot(abr_data: *mut AbrData, enabl
 #[no_mangle]
 #[allow(non_snake_case)]
 pub unsafe extern "C" fn AbrSetOneShotBootloaderBoot(abr_data: *mut AbrData, enable: bool) {
-    abr_data.as_mut().unwrap().set_one_shot_bootloader(enable);
+    // SAFETY: function safety requires `abr_data` to be a valid pointer.
+    unsafe { abr_data.as_mut() }.unwrap().set_one_shot_bootloader(enable);
 }
diff --git a/gbl/libasync/BUILD b/gbl/libasync/BUILD
new file mode 100644
index 0000000..49d114f
--- /dev/null
+++ b/gbl/libasync/BUILD
@@ -0,0 +1,50 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
+
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+rust_library(
+    name = "libasync",
+    srcs = ["src/lib.rs"],
+    crate_name = "gbl_async",
+    edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+)
+
+rust_test(
+    name = "libasync_test",
+    crate = ":libasync",
+    rustc_flags = ANDROID_RUST_LINTS,
+)
+
+rust_library(
+    name = "cyclic_executor",
+    srcs = ["src/cyclic_executor.rs"],
+    crate_name = "gbl_cyclic_executor",
+    crate_root = "src/cyclic_executor.rs",
+    edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [":libasync"],
+)
+
+rust_test(
+    name = "cyclic_executor_test",
+    crate = ":cyclic_executor",
+    rustc_flags = ANDROID_RUST_LINTS,
+)
diff --git a/gbl/libasync/src/cyclic_executor.rs b/gbl/libasync/src/cyclic_executor.rs
new file mode 100644
index 0000000..5365354
--- /dev/null
+++ b/gbl/libasync/src/cyclic_executor.rs
@@ -0,0 +1,117 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This library implements a simple executor using cyclic scheduling.
+
+#![cfg_attr(not(test), no_std)]
+
+extern crate alloc;
+use alloc::{boxed::Box, vec::Vec};
+use core::{future::Future, pin::Pin};
+use gbl_async::poll;
+
+/// `CyclicExecutor` is a simple single thread executor that simply cyclically polls all Futures.
+#[derive(Default)]
+pub struct CyclicExecutor<'a> {
+    tasks: Vec<Pin<Box<dyn Future<Output = ()> + 'a>>>,
+}
+
+impl<'a> CyclicExecutor<'a> {
+    /// Adds a new task.
+    pub fn spawn_task(&mut self, task: impl Future<Output = ()> + 'a) {
+        let mut task = Box::pin(task);
+        // Schedule the task once.
+        match poll(&mut task.as_mut()) {
+            Some(_) => {}
+            _ => self.tasks.push(task),
+        }
+    }
+
+    /// Polls all `Future`s once.
+    pub fn poll(&mut self) {
+        let mut idx = 0;
+        while let Some(task) = self.tasks.get_mut(idx) {
+            if poll(&mut task.as_mut()).is_some() {
+                let _ = self.tasks.swap_remove(idx);
+            } else {
+                idx += 1;
+            }
+        }
+    }
+
+    /// Runs all `Future`s until completion.
+    pub fn run(&mut self) {
+        while !self.tasks.is_empty() {
+            self.poll();
+        }
+    }
+
+    /// Returns the current number of tasks.
+    pub fn num_tasks(&self) -> usize {
+        self.tasks.len()
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use gbl_async::yield_now;
+    use std::sync::Mutex;
+
+    #[test]
+    fn test_spawn_and_poll_task() {
+        let val1 = Mutex::new(0);
+        let val2 = Mutex::new(1);
+
+        let mut executor: CyclicExecutor = Default::default();
+        // Spawns 2 tasks.
+        executor.spawn_task(async {
+            *val1.try_lock().unwrap() += 1;
+            yield_now().await;
+            *val1.try_lock().unwrap() += 1;
+            yield_now().await;
+            *val1.try_lock().unwrap() += 1;
+            yield_now().await;
+        });
+        executor.spawn_task(async {
+            *val2.try_lock().unwrap() += 1;
+            yield_now().await;
+            *val2.try_lock().unwrap() += 1;
+            yield_now().await;
+            *val2.try_lock().unwrap() += 1;
+            yield_now().await;
+        });
+
+        // Test that spawning a task schedules it immediately.
+        assert_eq!(*val1.try_lock().unwrap(), 1);
+        assert_eq!(*val2.try_lock().unwrap(), 2);
+
+        // Polls all Futures once.
+        executor.poll();
+        assert_eq!(*val1.try_lock().unwrap(), 2);
+        assert_eq!(*val2.try_lock().unwrap(), 3);
+
+        // Runs to completion.
+        executor.run();
+        assert_eq!(*val1.try_lock().unwrap(), 3);
+        assert_eq!(*val2.try_lock().unwrap(), 4);
+    }
+
+    #[test]
+    fn test_complete_on_spawn_not_added() {
+        let mut executor: CyclicExecutor = Default::default();
+        executor.spawn_task(async {});
+        assert_eq!(executor.num_tasks(), 0);
+    }
+}
diff --git a/gbl/libasync/src/lib.rs b/gbl/libasync/src/lib.rs
new file mode 100644
index 0000000..59493fe
--- /dev/null
+++ b/gbl/libasync/src/lib.rs
@@ -0,0 +1,245 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file provides async utility APIs used by GBL.
+//!
+//! They are mainly barebone APIs for busy waiting and polling Futures. There is no support for
+//! sleep/wake or threading.
+
+#![cfg_attr(not(test), no_std)]
+
+use core::{
+    future::Future,
+    pin::{pin, Pin},
+    ptr::null,
+    task::{Context, Poll, RawWaker, RawWakerVTable, Waker},
+};
+
+/// Clone method for `NOOP_VTABLE`.
+fn noop_clone(_: *const ()) -> RawWaker {
+    noop_raw_waker()
+}
+
+/// Noop method for `wake`, `wake_by_ref` and `drop` in `RawWakerVTable`.
+fn noop_wake_method(_: *const ()) {}
+
+/// A noop `RawWakerVTable`
+const NOOP_VTABLE: RawWakerVTable =
+    RawWakerVTable::new(noop_clone, noop_wake_method, noop_wake_method, noop_wake_method);
+
+/// Creates a noop instance that does nothing.
+fn noop_raw_waker() -> RawWaker {
+    RawWaker::new(null(), &NOOP_VTABLE)
+}
+
+/// Repetitively polls and blocks until a future completes.
+pub fn block_on<O>(fut: impl Future<Output = O>) -> O {
+    let mut fut = pin!(fut);
+    loop {
+        match poll(&mut fut) {
+            Some(res) => return res,
+            _ => {}
+        }
+    }
+}
+
+/// Polls a Future.
+///
+/// Returns Some(_) if ready, None otherwise.
+pub fn poll<F: Future<Output = O> + ?Sized, O>(fut: &mut Pin<&mut F>) -> Option<O> {
+    // SAFETY:
+    // * All methods for noop_raw_waker() are either noop or have no shared state. Thus they are
+    //   thread-safe.
+    let waker = unsafe { Waker::from_raw(noop_raw_waker()) };
+    let mut context = Context::from_waker(&waker);
+    match fut.as_mut().poll(&mut context) {
+        Poll::Pending => None,
+        Poll::Ready(res) => Some(res),
+    }
+}
+
+/// `Yield` implements a simple API for yielding control once to the executor.
+struct Yield(bool);
+
+impl Future for Yield {
+    type Output = ();
+
+    fn poll(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {
+        self.0 = !self.0;
+        match self.0 {
+            true => Poll::Pending,
+            _ => Poll::Ready(()),
+        }
+    }
+}
+
+/// Yield the execution once.
+pub async fn yield_now() {
+    Yield(false).await
+}
+
+/// `YieldCounter` maintains a counter and yield control to executor once it overflows a given
+/// threshold. When overflow occurs, the counter value is reset and the carry over is discarded.
+pub struct YieldCounter {
+    threshold: u64,
+    current: u64,
+}
+
+impl YieldCounter {
+    /// Creates an instance with a given threshold.
+    pub fn new(threshold: u64) -> Self {
+        Self { threshold, current: 0 }
+    }
+
+    /// Increments the current counter and yield execution if the value overflows the threshold.
+    pub async fn increment(&mut self, inc: u64) {
+        self.current = self.current.saturating_sub(inc);
+        if self.current == 0 {
+            self.current = self.threshold;
+            yield_now().await;
+        }
+    }
+}
+
+/// Repetitively polls two futures until both of them finish.
+pub async fn join<L, LO, R, RO>(fut_lhs: L, fut_rhs: R) -> (LO, RO)
+where
+    L: Future<Output = LO>,
+    R: Future<Output = RO>,
+{
+    let fut_lhs = &mut pin!(fut_lhs);
+    let fut_rhs = &mut pin!(fut_rhs);
+    let mut out_lhs = poll(fut_lhs);
+    let mut out_rhs = poll(fut_rhs);
+    while out_lhs.is_none() || out_rhs.is_none() {
+        yield_now().await;
+        if out_lhs.is_none() {
+            out_lhs = poll(fut_lhs);
+        }
+
+        if out_rhs.is_none() {
+            out_rhs = poll(fut_rhs);
+        }
+    }
+    (out_lhs.unwrap(), out_rhs.unwrap())
+}
+
+/// Waits until either of the given two futures completes.
+pub async fn select<L, LO, R, RO>(fut_lhs: L, fut_rhs: R) -> (Option<LO>, Option<RO>)
+where
+    L: Future<Output = LO>,
+    R: Future<Output = RO>,
+{
+    let fut_lhs = &mut pin!(fut_lhs);
+    let fut_rhs = &mut pin!(fut_rhs);
+    let mut out_lhs = poll(fut_lhs);
+    let mut out_rhs = poll(fut_rhs);
+    while out_lhs.is_none() && out_rhs.is_none() {
+        yield_now().await;
+        out_lhs = poll(fut_lhs);
+        out_rhs = poll(fut_rhs);
+    }
+    (out_lhs, out_rhs)
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::sync::Mutex;
+
+    #[test]
+    fn test() {
+        let mut counter = YieldCounter::new(1);
+        let mut fut = pin!(async move {
+            counter.increment(2).await;
+            counter.increment(2).await;
+        });
+
+        assert!(poll(&mut fut).is_none());
+        assert!(poll(&mut fut).is_none());
+        assert!(poll(&mut fut).is_some());
+    }
+
+    #[test]
+    fn test_join() {
+        let val1 = Mutex::new(0);
+        let val2 = Mutex::new(1);
+
+        let mut join_fut = pin!(join(
+            async {
+                *val1.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val1.try_lock().unwrap() += 1;
+                yield_now().await;
+            },
+            async {
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+            }
+        ));
+
+        assert!(poll(&mut join_fut).is_none());
+        assert_eq!(*val1.try_lock().unwrap(), 1);
+        assert_eq!(*val2.try_lock().unwrap(), 2);
+
+        assert!(poll(&mut join_fut).is_none());
+        assert_eq!(*val1.try_lock().unwrap(), 2);
+        assert_eq!(*val2.try_lock().unwrap(), 3);
+
+        assert!(poll(&mut join_fut).is_none());
+        assert_eq!(*val1.try_lock().unwrap(), 2);
+        assert_eq!(*val2.try_lock().unwrap(), 4);
+
+        assert!(poll(&mut join_fut).is_some());
+    }
+
+    #[test]
+    fn test_select() {
+        let val1 = Mutex::new(0);
+        let val2 = Mutex::new(1);
+
+        let mut select_fut = pin!(select(
+            async {
+                *val1.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val1.try_lock().unwrap() += 1;
+                yield_now().await;
+            },
+            async {
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+                *val2.try_lock().unwrap() += 1;
+                yield_now().await;
+            }
+        ));
+
+        assert!(poll(&mut select_fut).is_none());
+        assert_eq!(*val1.try_lock().unwrap(), 1);
+        assert_eq!(*val2.try_lock().unwrap(), 2);
+
+        assert!(poll(&mut select_fut).is_none());
+        assert_eq!(*val1.try_lock().unwrap(), 2);
+        assert_eq!(*val2.try_lock().unwrap(), 3);
+
+        let (lhs, rhs) = poll(&mut select_fut).unwrap();
+        assert!(lhs.is_some());
+        assert!(rhs.is_none());
+    }
+}
diff --git a/gbl/libavb/BUILD b/gbl/libavb/BUILD
index 2d05993..772e93f 100644
--- a/gbl/libavb/BUILD
+++ b/gbl/libavb/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library")
 
 package(
@@ -20,15 +21,14 @@ package(
 
 exports_files(glob(["**/*"]))
 
-cc_library(
-    name = "gbl_deps",
-    hdrs = ["deps/include/inttypes.h"],
-    includes = ["./deps/include"],
-)
-
 rust_library(
     name = "sysdeps",
     srcs = glob(["**/*.rs"]),
     crate_name = "avb_sysdeps",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@avb//:avb_bindgen",
+        "@gbl//libc",
+    ],
 )
diff --git a/gbl/libavb/BUILD.avb.bazel b/gbl/libavb/BUILD.avb.bazel
index c556611..701468c 100644
--- a/gbl/libavb/BUILD.avb.bazel
+++ b/gbl/libavb/BUILD.avb.bazel
@@ -64,7 +64,7 @@ cc_library(
         ".",
         "libavb/sha/",
     ],
-    deps = ["@gbl//libavb:gbl_deps"],
+    deps = ["@gbl//libc:headers"],
 )
 
 cc_library(
@@ -104,10 +104,12 @@ cc_library(
         "-g",
         "-DAVB_ENABLE_DEBUG",
         "-DAVB_COMPILATION",
+        # libavb uses more than 4K of stack space. This prevents the compiler from inserting
+        # _chkstk().
+        "-mstack-probe-size=8192",
     ],
     deps = [
         ":headers",
-        "@gbl//libavb:gbl_deps",
     ],
 )
 
@@ -125,7 +127,6 @@ cc_library(
     copts = ["-DAVB_COMPILATION"],
     deps = [
         ":headers",
-        "@gbl//libavb:gbl_deps",
     ],
 )
 
@@ -136,28 +137,24 @@ link_static_cc_library(
 
 rust_bindgen(
     name = "libavb_c_bindgen",
+    # Flags should match Soong definition in external/avb/rust/Android.bp.
     bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
         "--constified-enum-module=AvbDescriptorTag",
         "--bitfield-enum=Avb.*Flags",
         "--default-enum-style=rust",
         "--with-derive-default",
         "--with-derive-custom=Avb.*Descriptor=FromZeroes,FromBytes",
+        "--with-derive-custom=AvbCertPermanentAttributes=FromZeroes,FromBytes,AsBytes",
+        "--with-derive-custom=AvbCertCertificate.*=FromZeroes,FromBytes,AsBytes",
+        "--with-derive-custom=AvbCertUnlock.*=FromZeroes,FromBytes,AsBytes",
         "--allowlist-type=AvbDescriptorTag",
         "--allowlist-type=Avb.*Flags",
         "--allowlist-function=.*",
         "--allowlist-var=AVB.*",
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![allow(dead_code)]
-#![cfg_attr(not(test), no_std)]
-
-use zerocopy::{FromBytes, FromZeroes};
-""",
+        "--use-core",
+        "--raw-line=#![no_std]",
+        "--raw-line=use zerocopy::{AsBytes, FromBytes, FromZeroes};",
+        "--ctypes-prefix=core::ffi",
     ],
     cc_lib = "headers",
     # For x86_32, we need to explicitly specify 32bit architecture.
@@ -174,6 +171,10 @@ use zerocopy::{FromBytes, FromZeroes};
 rust_library(
     name = "avb_bindgen",
     srcs = [":libavb_c_bindgen"],
+    rustc_flags = [
+        "--allow=non_snake_case",
+        "--allow=non_camel_case_types",
+    ],
     deps = ["@zerocopy"],
 )
 
diff --git a/gbl/libavb/src/lib.rs b/gbl/libavb/src/lib.rs
index fc2d987..f617b5d 100644
--- a/gbl/libavb/src/lib.rs
+++ b/gbl/libavb/src/lib.rs
@@ -16,19 +16,13 @@
 //! Global allocator is required.
 
 #![cfg_attr(not(test), no_std)]
+// These are implementations of required C functions, see libavb sysdeps for docs.
+#![allow(missing_docs)]
 
-extern crate alloc;
-use alloc::alloc::{alloc, dealloc};
-use core::{
-    alloc::Layout,
-    cmp::{min, Ord},
-    ffi::CStr,
-    mem::size_of,
-    ptr::{null_mut, NonNull},
-};
+use core::ffi::{c_char, c_int, c_void};
+use libc::{gbl_free, gbl_malloc, memcmp, memcpy, memset, strcmp, strlen, strncmp};
 
-/// `avb_malloc_()` requires allocation to be word aligned.
-const AVB_MALLOC_ALIGNMENT: usize = 2;
+const AVB_MALLOC_ALIGNMENT: usize = avb_bindgen::AVB_ALIGNMENT_SIZE as usize;
 
 #[no_mangle]
 pub extern "C" fn avb_abort() -> ! {
@@ -36,49 +30,23 @@ pub extern "C" fn avb_abort() -> ! {
 }
 
 #[no_mangle]
-pub extern "C" fn avb_malloc_(size: usize) -> *mut core::ffi::c_void {
-    (|| {
-        // Allocate extra to store the size value.
-        let size = size_of::<usize>().checked_add(size)?;
-        // SAFETY:
-        // *  On success, `alloc` guarantees to allocate enough memory.
-        // * `size.to_le_bytes().as_ptr()` is guaranteed valid memory.
-        // * Alignment is 1 for bytes copy.
-        unsafe {
-            let ptr =
-                NonNull::new(alloc(Layout::from_size_align(size, AVB_MALLOC_ALIGNMENT).ok()?))?;
-            ptr.as_ptr().copy_from(size.to_le_bytes().as_ptr(), size_of::<usize>());
-            let ptr = ptr.as_ptr().add(size_of::<usize>());
-            Some(ptr)
-        }
-    })()
-    .unwrap_or(null_mut()) as _
+pub extern "C" fn avb_malloc_(size: usize) -> *mut c_void {
+    // SAFETY: libavb calls are compatible with libc counterparts, alignment the same as
+    // avb_free
+    unsafe { gbl_malloc(size, AVB_MALLOC_ALIGNMENT) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_free(ptr: *mut core::ffi::c_void) {
-    assert_ne!(ptr, null_mut());
-    let mut ptr = ptr as *mut u8;
-    let mut size_bytes = [0u8; size_of::<usize>()];
-    // SAFETY:
-    // * `ptr` is allocated by `avb_malloc_` and guarantees to have enough memory for a preceding
-    //   usize value and payload.
-    // * `size_bytes.as_mut_ptr()` is a valid memory location.
-    // * Alignment is 1 for bytes copy.
-    unsafe {
-        ptr = ptr.sub(size_of::<usize>());
-        ptr.copy_to(size_bytes.as_mut_ptr(), size_of::<usize>())
-    };
-    let size = usize::from_le_bytes(size_bytes);
-    // SAFETY: Call to global allocator.
-    unsafe { dealloc(ptr, Layout::from_size_align(size, AVB_MALLOC_ALIGNMENT).unwrap()) };
+pub extern "C" fn avb_free(ptr: *mut c_void) {
+    // SAFETY: libavb calls are compatible with libc counterparts, alignment the same as
+    // avb_malloc_
+    unsafe { gbl_free(ptr, AVB_MALLOC_ALIGNMENT) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_strlen(s: *const core::ffi::c_char) -> usize {
-    // SAFETY: libavb guarantees to pass valid NULL-terminated strings to this function. The
-    // returned reference is only used to compute string length.
-    unsafe { CStr::from_ptr(s as *const _) }.to_bytes().len()
+pub extern "C" fn avb_strlen(s: *const c_char) -> usize {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { strlen(s) }
 }
 
 #[no_mangle]
@@ -91,64 +59,31 @@ pub extern "C" fn avb_div_by_10(dividend: *mut u64) -> u32 {
 }
 
 #[no_mangle]
-pub extern "C" fn avb_memcpy(
-    dest: *mut core::ffi::c_void,
-    src: *const core::ffi::c_void,
-    n: usize,
-) -> *mut core::ffi::c_void {
-    // SAFETY: libavb guarantees to pass valid pointers.
-    unsafe { (src.cast::<u8>()).copy_to(dest as *mut _, n) };
-    dest
+pub extern "C" fn avb_memcpy(dest: *mut c_void, src: *const c_void, n: usize) -> *mut c_void {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { memcpy(dest, src, n) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_memcmp(
-    src1: *const core::ffi::c_void,
-    src2: *const core::ffi::c_void,
-    n: usize,
-) -> core::ffi::c_int {
-    // SAFETY: libavb guarantees to pass valid pointers. References are only used within function.
-    let (lhs, rhs) = unsafe {
-        (
-            core::slice::from_raw_parts(src1 as *const u8, n),
-            core::slice::from_raw_parts(src2 as *const u8, n),
-        )
-    };
-    Ord::cmp(lhs, rhs) as i32
+pub extern "C" fn avb_memcmp(src1: *const c_void, src2: *const c_void, n: usize) -> c_int {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { memcmp(src1, src2, n) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_strcmp(
-    s1: *const core::ffi::c_char,
-    s2: *const core::ffi::c_char,
-) -> core::ffi::c_int {
-    // SAFETY: libavb guarantees to pass valid NULL-terminated strings. References are only used
-    // within function.
-    let (lhs, rhs) = unsafe { (CStr::from_ptr(s1 as *const _), CStr::from_ptr(s2 as *const _)) };
-    Ord::cmp(lhs, rhs) as i32
+pub extern "C" fn avb_memset(dest: *mut c_void, c: c_int, n: usize) -> *mut c_void {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { memset(dest, c, n) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_strncmp(
-    s1: *const core::ffi::c_char,
-    s2: *const core::ffi::c_char,
-    n: usize,
-) -> core::ffi::c_int {
-    // SAFETY: libavb guarantees to pass valid NULL-terminated strings. References are only used
-    // within function.
-    let (lhs, rhs) = unsafe { (CStr::from_ptr(s1 as *const _), CStr::from_ptr(s2 as *const _)) };
-    let cmp_size = min(min(lhs.to_bytes().len(), rhs.to_bytes().len()), n);
-    Ord::cmp(&lhs.to_bytes()[..cmp_size], &rhs.to_bytes()[..cmp_size]) as i32
+pub extern "C" fn avb_strcmp(s1: *const c_char, s2: *const c_char) -> c_int {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { strcmp(s1, s2) }
 }
 
 #[no_mangle]
-pub extern "C" fn avb_memset(
-    dest: *mut core::ffi::c_void,
-    c: core::ffi::c_int,
-    n: usize,
-) -> *mut core::ffi::c_void {
-    // SAFETY: libavb guarantees to pass valid buffer. Reference is only used within function.
-    let arr = unsafe { core::slice::from_raw_parts_mut(dest as *mut u8, n) };
-    arr.fill(c as u8);
-    dest
+pub extern "C" fn avb_strncmp(s1: *const c_char, s2: *const c_char, n: usize) -> c_int {
+    // SAFETY: libavb calls are compatible with libc counterparts
+    unsafe { strncmp(s1, s2, n) }
 }
diff --git a/gbl/libboot/BUILD b/gbl/libboot/BUILD
index 7177576..3ddd30f 100644
--- a/gbl/libboot/BUILD
+++ b/gbl/libboot/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
 load("@rules_rust//rust:defs.bzl", "rust_library")
 
@@ -71,8 +72,12 @@ rust_library(
     srcs = glob(["**/*.rs"]),
     crate_name = "boot",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         ":x86_bootparam_defs",
+        "@gbl//liberror",
+        "@gbl//libsafemath",
+        "@gbl//third_party/libzbi",
         "@zerocopy",
     ] + select({
         "@gbl//toolchain:gbl_rust_uefi_aarch64": [
diff --git a/gbl/libboot/src/aarch64.rs b/gbl/libboot/src/aarch64.rs
index 3c4f52c..6655c91 100644
--- a/gbl/libboot/src/aarch64.rs
+++ b/gbl/libboot/src/aarch64.rs
@@ -17,7 +17,10 @@
 //!   https://www.kernel.org/doc/html/v5.11/arm64/booting.html
 
 use core::arch::asm;
+use zbi::ZbiContainer;
 
+/// ARM exception levels.
+#[allow(missing_docs)]
 #[derive(Debug, PartialEq)]
 pub enum ExceptionLevel {
     EL0,
@@ -77,14 +80,18 @@ unsafe fn jump_kernel(addr: usize, arg0: usize, arg1: usize, arg2: usize, arg3:
     // be trusted, including stack memory. Therefore all needed data including local variables must
     // be ensured to be loaded to registers first. `disable_cache_mmu_and_jump` only operates on
     // registers and does not access stack or any other memory.
-    asm!(
-        "b disable_cache_mmu_and_jump",
-        in("x0") arg0,
-        in("x1") arg1,
-        in("x2") arg2,
-        in("x3") arg3,
-        in("x4") addr,
-    );
+    //
+    // SAFETY: By safety requirement of this function, `addr` contains valid execution code.
+    unsafe {
+        asm!(
+            "b disable_cache_mmu_and_jump",
+            in("x0") arg0,
+            in("x1") arg1,
+            in("x2") arg2,
+            in("x3") arg3,
+            in("x4") addr,
+        )
+    };
     unreachable!();
 }
 
@@ -113,13 +120,14 @@ pub unsafe fn jump_linux_el2_or_lower(kernel: &[u8], ramdisk: &[u8], fdt: &[u8])
 ///
 /// # Safety
 ///
-/// Caller must ensure that `zbi_kernel` contains a valid zircon kernel ZBI item and `entry_off` is
-/// the correct kernel entry offset.
-pub unsafe fn jump_zircon_el2_or_lower(zbi_kernel: &[u8], entry_off: usize, zbi_item: &[u8]) -> ! {
+/// Caller must ensure that `zbi_kernel` contains a valid zircon kernel ZBI item.
+pub unsafe fn jump_zircon_el2_or_lower(kernel: &[u8], zbi_item: &[u8]) -> ! {
     assert_ne!(current_el(), ExceptionLevel::EL3);
-    flush_dcache_buffer(zbi_kernel);
+    let (entry, _) =
+        ZbiContainer::parse(zbi_item).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
+    flush_dcache_buffer(kernel);
     flush_dcache_buffer(zbi_item);
-    let addr = (zbi_kernel.as_ptr() as usize).checked_add(entry_off).unwrap();
+    let addr = (kernel.as_ptr() as usize).checked_add(usize::try_from(entry).unwrap()).unwrap();
     // SAFETY:
     // * `zbi_kernel` and `zbi_item` have been flushed.
     // * By requirement of this function, the computed `addr` is a valid kernel entry point.
diff --git a/gbl/libboot/src/lib.rs b/gbl/libboot/src/lib.rs
index bd878db..58ece34 100644
--- a/gbl/libboot/src/lib.rs
+++ b/gbl/libboot/src/lib.rs
@@ -12,20 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#![cfg_attr(not(test), no_std)]
-
-// Library error type.
-#[derive(Debug)]
-pub enum BootError {
-    IntegerOverflow,
-    InvalidInput,
-    InvalidZImage,
-    UnsupportedZImage,
-    E820MemoryMapCallbackError(i64),
-}
+//! Functionality to boot kernels on X86, ARM, and RISC-V boards.
 
-/// Library result type,
-pub type Result<T> = core::result::Result<T, BootError>;
+#![cfg_attr(not(test), no_std)]
 
 #[cfg(target_arch = "aarch64")]
 pub mod aarch64;
diff --git a/gbl/libboot/src/riscv64.rs b/gbl/libboot/src/riscv64.rs
index d954ef3..a68100b 100644
--- a/gbl/libboot/src/riscv64.rs
+++ b/gbl/libboot/src/riscv64.rs
@@ -12,6 +12,8 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! Boot logic for RISC-V.
+
 use core::arch::asm;
 
 /// Boots a Linux kernel with the given boot hart ID and FDT blob.
diff --git a/gbl/libboot/src/x86.rs b/gbl/libboot/src/x86.rs
index b079173..fcc3fab 100644
--- a/gbl/libboot/src/x86.rs
+++ b/gbl/libboot/src/x86.rs
@@ -44,10 +44,11 @@
 //! See https://www.kernel.org/doc/html/v5.11/x86/boot.html#the-linux-x86-boot-protocol for more
 //! detail.
 
-use crate::*;
-
 use core::arch::asm;
+use core::mem::size_of;
 use core::slice::from_raw_parts_mut;
+use liberror::{Error, Result};
+use zbi::ZbiContainer;
 
 pub use x86_bootparam_defs::{boot_params, e820entry, setup_header};
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
@@ -61,12 +62,17 @@ const LOAD_ADDR_HIGH: usize = 0x10_0000;
 // Flag value to use high address for protected mode kernel.
 const LOAD_FLAG_LOADED_HIGH: u8 = 0x1;
 
-/// Constant for E820 address range type.
+/// E820 RAM address range type.
 pub const E820_ADDRESS_TYPE_RAM: u32 = 1;
+/// E820 reserved address range type.
 pub const E820_ADDRESS_TYPE_RESERVED: u32 = 2;
+/// E820 ACPI address range type.
 pub const E820_ADDRESS_TYPE_ACPI: u32 = 3;
+/// E820 NVS address range type.
 pub const E820_ADDRESS_TYPE_NVS: u32 = 4;
+/// E820 unusable address range type.
 pub const E820_ADDRESS_TYPE_UNUSABLE: u32 = 5;
+/// E820 PMEM address range type.
 pub const E820_ADDRESS_TYPE_PMEM: u32 = 7;
 
 /// Wrapper for `struct boot_params {}` C structure
@@ -78,7 +84,7 @@ impl BootParams {
     /// Cast a bytes into a reference of BootParams header
     pub fn from_bytes_ref(buffer: &[u8]) -> Result<&BootParams> {
         Ok(Ref::<_, BootParams>::new_from_prefix(buffer)
-            .ok_or_else(|| BootError::InvalidInput)?
+            .ok_or(Error::BufferTooSmall(Some(size_of::<BootParams>())))?
             .0
             .into_ref())
     }
@@ -86,7 +92,7 @@ impl BootParams {
     /// Cast a bytes into a mutable reference of BootParams header.
     pub fn from_bytes_mut(buffer: &mut [u8]) -> Result<&mut BootParams> {
         Ok(Ref::<_, BootParams>::new_from_prefix(buffer)
-            .ok_or_else(|| BootError::InvalidInput)?
+            .ok_or(Error::BufferTooSmall(Some(size_of::<BootParams>())))?
             .0
             .into_mut())
     }
@@ -107,14 +113,14 @@ impl BootParams {
         if !(self.setup_header_ref().boot_flag == 0xAA55
             && self.setup_header_ref().header.to_le_bytes() == *b"HdrS")
         {
-            return Err(BootError::InvalidZImage);
+            return Err(Error::BadMagic);
         }
 
         // Check if it is bzimage and version is supported.
         if !(self.0.hdr.version >= 0x0206
             && ((self.setup_header_ref().loadflags & LOAD_FLAG_LOADED_HIGH) != 0))
         {
-            return Err(BootError::UnsupportedZImage);
+            return Err(Error::UnsupportedVersion);
         }
 
         Ok(())
@@ -155,7 +161,7 @@ impl BootParams {
 /// * `mmap_cb`: A caller provided callback for setting the e820 memory map. The callback takes in
 ///     a mutable reference of e820 map entries (&mut [e820entry]). On success, it should return
 ///     the number of used entries. On error, it can return a
-///     `BootError::E820MemoryMapCallbackError(<code>)` to propagate a custom error code.
+///     `Error::MemoryMapCallbackError(<code>)` to propagate a custom error code.
 ///
 /// * `low_mem_addr`: The lowest memory touched by the bootloader section. This is where boot param
 ///      starts.
@@ -205,9 +211,12 @@ where
             .clone_from_slice(&kernel[boot_sector_size..]);
     }
 
-    // Copy over boot params to boot sector to prepare for fix-up.
+    // Zeroizes the entire boot sector.
     boot_param_buffer.fill(0);
-    boot_param_buffer[..boot_sector_size].clone_from_slice(&kernel[..boot_sector_size]);
+    let bootparam_fixup = BootParams::from_bytes_mut(boot_param_buffer)?;
+    // Only copies over the header. Leaves the rest zeroes.
+    *bootparam_fixup.setup_header_mut() =
+        *BootParams::from_bytes_ref(&kernel[..])?.setup_header_ref();
 
     let bootparam_fixup = BootParams::from_bytes_mut(boot_param_buffer)?;
 
@@ -217,10 +226,8 @@ where
     bootparam_fixup.setup_header_mut().cmdline_size = cmdline.len().try_into().unwrap();
 
     // Sets ramdisk address.
-    bootparam_fixup.setup_header_mut().ramdisk_image =
-        (ramdisk.as_ptr() as usize).try_into().map_err(|_| BootError::IntegerOverflow)?;
-    bootparam_fixup.setup_header_mut().ramdisk_size =
-        ramdisk.len().try_into().map_err(|_| BootError::IntegerOverflow)?;
+    bootparam_fixup.setup_header_mut().ramdisk_image = (ramdisk.as_ptr() as usize).try_into()?;
+    bootparam_fixup.setup_header_mut().ramdisk_size = ramdisk.len().try_into()?;
 
     // Sets to loader type "special loader". (Anything other than 0, otherwise linux kernel ignores
     // ramdisk.)
@@ -261,3 +268,57 @@ where
 
     Ok(())
 }
+
+/// Jump to prepared ZBI Fuchsia entry
+///
+/// SAFETY:
+/// Caller must ensure `entry` is valid entry point for kernel.
+/// Caller must ensure `data` is valid ZBI data and is 4K aligned.
+pub unsafe fn zbi_boot_raw(entry: usize, data: &[u8]) -> ! {
+    // Clears stack pointers, interrupt and jumps to protected mode kernel.
+    // SAFETY: By safety requirement of this function, input contains a valid ZBI kernel.
+    #[cfg(target_arch = "x86_64")]
+    unsafe {
+        asm!(
+            "xor ebp, ebp",
+            "xor esp, esp",
+            "cld",
+            "cli",
+            "jmp {ep}",
+            ep = in(reg) entry,
+            in("rsi") data.as_ptr(),
+        );
+    }
+    // SAFETY: By safety requirement of this function, input contains a valid ZBI kernel.
+    #[cfg(target_arch = "x86")]
+    unsafe {
+        asm!(
+            "xor ebp, ebp",
+            "xor esp, esp",
+            "mov esi, eax",
+            "cld",
+            "cli",
+            "jmp {ep}",
+            ep = in(reg) entry,
+            in("eax") data.as_ptr(),
+        );
+    }
+
+    unreachable!();
+}
+
+/// Boot ZBI kernel from provided ZBI containers
+///
+/// SAFETY:
+/// Caller must ensure `kernel` is valid ZBI kernel and is 4K aligned.
+/// Caller must ensure `data` is valid ZBI data and is 4K aligned.
+pub unsafe fn zbi_boot(kernel: &[u8], data: &[u8]) -> ! {
+    let (entry, _) =
+        ZbiContainer::parse(kernel).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
+    let addr = (kernel.as_ptr() as usize).checked_add(usize::try_from(entry).unwrap()).unwrap();
+    // SAFETY:
+    // `addr` is calculated from kernel ZBI, which is valid according to safety requirements for
+    // `zbi_boot()` function.
+    // `data` is required to be valid ZBI data as per safety requirements for `zbi_boot()`
+    unsafe { zbi_boot_raw(addr, data) };
+}
diff --git a/gbl/libbootconfig/BUILD b/gbl/libbootconfig/BUILD
index 6a71fac..8ad14b8 100644
--- a/gbl/libbootconfig/BUILD
+++ b/gbl/libbootconfig/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
@@ -23,9 +24,14 @@ rust_library(
     srcs = ["src/lib.rs"],
     crate_name = "bootconfig",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//liberror",
+    ],
 )
 
 rust_test(
     name = "libbootconfig_test",
     crate = ":libbootconfig",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libbootconfig/src/lib.rs b/gbl/libbootconfig/src/lib.rs
index d0172e3..bf15912 100644
--- a/gbl/libbootconfig/src/lib.rs
+++ b/gbl/libbootconfig/src/lib.rs
@@ -18,17 +18,7 @@
 
 #![cfg_attr(not(test), no_std)]
 
-/// Library error type.
-#[derive(Debug)]
-pub enum BootConfigError {
-    ArithmeticOverflow,
-    BufferTooSmall,
-    InvalidConfigString,
-    GenericReaderError(i64),
-}
-
-/// The type of Result used in this library.
-pub type Result<T> = core::result::Result<T, BootConfigError>;
+use liberror::{Error, Result};
 
 /// A class for constructing bootconfig section.
 pub struct BootConfigBuilder<'a> {
@@ -49,7 +39,7 @@ impl<'a> BootConfigBuilder<'a> {
     /// Initialize with a given buffer.
     pub fn new(buffer: &'a mut [u8]) -> Result<Self> {
         if buffer.len() < BOOTCONFIG_TRAILER_SIZE {
-            return Err(BootConfigError::BufferTooSmall);
+            return Err(Error::BufferTooSmall(Some(BOOTCONFIG_TRAILER_SIZE)));
         }
         let mut ret = Self { current_size: 0, buffer: buffer };
         ret.update_trailer()?;
@@ -75,8 +65,8 @@ impl<'a> BootConfigBuilder<'a> {
     /// Append a new config via a reader callback.
     ///
     /// A `&mut [u8]` that covers the remaining space is passed to the callback for reading the
-    /// config bytes. It should return the total size read if operation is successful or a custom
-    /// error code via `BootConfigError::GenericReaderError(<code>)`. Attempting to return a size
+    /// config bytes. It should return the total size read if operation is successful or
+    /// `Error::BufferTooSmall(Some(<minimum_buffer_size>))`. Attempting to return a size
     /// greater than the input will cause it to panic. Empty read is allowed. It's up to the caller
     /// to make sure the read content will eventually form a valid boot config. The API is for
     /// situations where configs are read from sources such as disk and separate buffer allocation
@@ -96,7 +86,7 @@ impl<'a> BootConfigBuilder<'a> {
     /// Append a new config from string.
     pub fn add(&mut self, config: &str) -> Result<()> {
         if self.remaining_capacity() < config.len() {
-            return Err(BootConfigError::BufferTooSmall);
+            return Err(Error::BufferTooSmall(Some(config.len())));
         }
         self.add_with(|out| {
             out[..config.len()].clone_from_slice(config.as_bytes());
@@ -109,8 +99,7 @@ impl<'a> BootConfigBuilder<'a> {
     /// https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig#bootloader-changes
     fn update_trailer(&mut self) -> Result<()> {
         // Config size
-        let size: u32 =
-            self.current_size.try_into().map_err(|_| BootConfigError::ArithmeticOverflow)?;
+        let size: u32 = self.current_size.try_into().or(Err(Error::Other(None)))?;
         // Check sum.
         let checksum = self.checksum();
         let trailer = &mut self.buffer[self.current_size..];
@@ -144,7 +133,7 @@ impl core::fmt::Write for BootConfigBuilder<'_> {
     fn write_str(&mut self, s: &str) -> core::fmt::Result {
         self.add_with(|out| {
             out.get_mut(..s.len())
-                .ok_or(BootConfigError::BufferTooSmall)?
+                .ok_or(Error::BufferTooSmall(Some(s.len())))?
                 .clone_from_slice(s.as_bytes());
             Ok(s.len())
         })
@@ -270,6 +259,6 @@ androidboot.verifiedbootstate=orange
     fn test_add_with_error() {
         let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE + 1];
         let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        assert!(builder.add_with(|_| Err(BootConfigError::GenericReaderError(123))).is_err());
+        assert!(builder.add_with(|_| Err(Error::Other(None))).is_err());
     }
 }
diff --git a/gbl/libbootimg/BUILD b/gbl/libbootimg/BUILD
index 7299022..ef6dbe4 100644
--- a/gbl/libbootimg/BUILD
+++ b/gbl/libbootimg/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
@@ -55,7 +56,10 @@ rust_bindgen(
         "--with-derive-default",
         "--blocklist-type={}".format(BLOCKED_TYPES_RE),
         "--blocklist-item={}".format(BLOCKED_ITEMS_RE),
-        "--with-derive-custom-struct={}={}".format(CUSTOM_STRUCT_RE, CUSTOM_STRUCT_DERIVES),
+        "--with-derive-custom-struct={}={}".format(
+            CUSTOM_STRUCT_RE,
+            CUSTOM_STRUCT_DERIVES,
+        ),
         "--raw-line",
         """
 #![allow(non_camel_case_types)]
@@ -64,11 +68,13 @@ rust_bindgen(
 use zerocopy::{AsBytes, FromBytes, FromZeroes};""",
     ],
     cc_lib = ":bootimg_cc_header",
-    clang_flags = select({
-        # For x86_32, we need to explicitly specify 32bit architecture.
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
+    clang_flags = select(
+        {
+            # For x86_32, we need to explicitly specify 32bit architecture.
+            "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
+            "//conditions:default": ["-m64"],
+        },
+    ) + [
         "-x",
         "c++",
         "-nostdinc",
@@ -114,8 +120,10 @@ rust_library(
     ],
     crate_name = "bootimg",
     data = [":bootimg_sources_gen"],
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         ":bootimg_private",
+        "@gbl//liberror",
         "@zerocopy",
     ],
 )
@@ -123,4 +131,5 @@ rust_library(
 rust_test(
     name = "libbootimg_test",
     crate = ":libbootimg",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libbootimg/src/lib.rs b/gbl/libbootimg/src/lib.rs
index ff7a272..d2b0135 100644
--- a/gbl/libbootimg/src/lib.rs
+++ b/gbl/libbootimg/src/lib.rs
@@ -12,9 +12,25 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! GBL build wrapper for the Android boot image library:
+//! https://cs.android.com/android/platform/superproject/main/+/main:system/tools/mkbootimg/rust/.
+
 #![cfg_attr(not(test), no_std)]
 
 #[rustfmt::skip]
 mod bootimg;
 pub use bootimg::*;
 pub use bootimg_private as defs;
+
+use liberror::Error;
+
+impl From<ImageError> for Error {
+    fn from(err: ImageError) -> Error {
+        match err {
+            ImageError::BufferTooSmall => Error::BufferTooSmall(None),
+            ImageError::BadMagic => Error::BadMagic,
+            ImageError::UnexpectedVersion => Error::UnsupportedVersion,
+            _ => Error::Other(None),
+        }
+    }
+}
diff --git a/gbl/libc/BUILD b/gbl/libc/BUILD
index d2d7d23..fb92e50 100644
--- a/gbl/libc/BUILD
+++ b/gbl/libc/BUILD
@@ -12,7 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@rules_rust//rust:defs.bzl", "rust_library")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
     default_visibility = ["//visibility:public"],
@@ -20,15 +21,29 @@ package(
 
 rust_library(
     name = "libc",
-    srcs = glob(["**/*.rs"]),
+    srcs = glob(["src/*.rs"]),
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libsafemath",
+    ],
+)
+
+rust_test(
+    name = "libc_test",
+    crate = ":libc",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 cc_library(
     name = "headers",
     hdrs = [
+        "include/debug.h",
+        "include/inttypes.h",
+        "include/stdio.h",
         "include/stdlib.h",
         "include/string.h",
+        "include/sys/types.h",
     ],
     includes = ["include"],
 )
diff --git a/gbl/libavb/deps/include/inttypes.h b/gbl/libc/include/debug.h
similarity index 100%
rename from gbl/libavb/deps/include/inttypes.h
rename to gbl/libc/include/debug.h
diff --git a/gbl/efi/arch/x86/deps.S b/gbl/libc/include/inttypes.h
similarity index 60%
rename from gbl/efi/arch/x86/deps.S
rename to gbl/libc/include/inttypes.h
index 9107919..59c1bc3 100644
--- a/gbl/efi/arch/x86/deps.S
+++ b/gbl/libc/include/inttypes.h
@@ -12,20 +12,7 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
  */
 
-/*
- * LLVM mangles the "___chkstk()" and "__alloca()" function from rust
- * libcompiler_builtins with an additional underscore, making them "___chkstk"
- * and "___alloca and causing the linker to fail finding them. We workaround by
- * defining the magled symbols that simply jump to the correct target.
- */
-
-.global ___chkstk
-.global __alloca
-
-___chkstk:
-    jmp ____chkstk
-
-__alloca:
-    jmp ___alloca
+// Placeholder only.
diff --git a/gbl/libc/include/stdio.h b/gbl/libc/include/stdio.h
new file mode 100644
index 0000000..59c1bc3
--- /dev/null
+++ b/gbl/libc/include/stdio.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// Placeholder only.
diff --git a/gbl/libc/include/stdlib.h b/gbl/libc/include/stdlib.h
index f9e0726..ad5dad4 100644
--- a/gbl/libc/include/stdlib.h
+++ b/gbl/libc/include/stdlib.h
@@ -17,7 +17,13 @@
 #ifndef __STDLIB_H__
 #define __STDLIB_H__
 
+#include <string.h>
+
+void* malloc(size_t size);
+void free(void* ptr);
 int memcmp(const void* ptr1, const void* ptr2, size_t num);
+void* memset(void* destination, int c, size_t num);
+void* memcpy(void* destination, const void* source, size_t num);
 void* memmove(void* destination, const void* source, size_t num);
 
 #endif
diff --git a/gbl/libc/include/string.h b/gbl/libc/include/string.h
index bee1457..d73187e 100644
--- a/gbl/libc/include/string.h
+++ b/gbl/libc/include/string.h
@@ -19,9 +19,13 @@
 
 #include <stddef.h>
 
-size_t strlen(const char * str);
+size_t strlen(const char *str);
 void *memchr(const void *ptr, int ch, size_t count);
 char *strrchr(const char *str, int c);
+char *strchr(const char *str, int c);
 size_t strnlen(const char *s, size_t maxlen);
+int strcmp(const char *s1, const char *s2);
+int strncmp(const char *s1, const char *s2, size_t n);
+unsigned long int strtoul(const char *s, char **endptr, int base);
 
 #endif
diff --git a/gbl/libc/include/sys/types.h b/gbl/libc/include/sys/types.h
new file mode 100644
index 0000000..46fc049
--- /dev/null
+++ b/gbl/libc/include/sys/types.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// Placeholder only.
\ No newline at end of file
diff --git a/gbl/libc/src/lib.rs b/gbl/libc/src/lib.rs
index 90c4792..68301a4 100644
--- a/gbl/libc/src/lib.rs
+++ b/gbl/libc/src/lib.rs
@@ -1,4 +1,4 @@
-// Copyright 2023, The Android Open Source Project
+// Copyright 2023-2024, The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -15,24 +15,170 @@
 //! This library provides implementation for a few libc functions for building third party C
 //! libraries.
 
-#![no_std]
+#![cfg_attr(not(test), no_std)]
 
-use core::ptr::null_mut;
+extern crate alloc;
+
+use alloc::alloc::{alloc, dealloc};
+use core::{
+    alloc::Layout,
+    ffi::{c_char, c_int, c_ulong, c_void},
+    mem::size_of_val,
+    ptr::{null_mut, NonNull},
+};
+use safemath::SafeNum;
+
+pub use strcmp::{strcmp, strncmp};
+
+pub mod strchr;
+pub mod strcmp;
+pub mod strtoul;
+
+// Linking compiler built-in intrinsics to expose libc compatible implementations
+// https://cs.android.com/android/platform/superproject/main/+/2e15fc2eadcb7db07bf6656086c50153bbafe7b6:prebuilts/rust/linux-x86/1.78.0/lib/rustlib/src/rust/vendor/compiler_builtins/src/mem/mod.rs;l=22
+extern "C" {
+    /// int memcmp(const void *src1, const void *src2, size_t n)
+    pub fn memcmp(src1: *const c_void, src2: *const c_void, n: usize) -> c_int;
+    /// void *memset(void *dest, int c, size_t n)
+    pub fn memset(dest: *mut c_void, c: c_int, n: usize) -> *mut c_void;
+    /// void *memcpy(void *dest, const void *src, size_t n)
+    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: usize) -> *mut c_void;
+    /// size_t strlen(const char *s)
+    pub fn strlen(s: *const c_char) -> usize;
+}
+
+/// Extended version of void *malloc(size_t size) with ptr alignment configuration support.
+/// Libraries may have a different alignment requirements.
+///
+/// # Safety
+///
+/// * Returns a valid pointer to a memory block of `size` bytes, aligned to `alignment`, or null
+///   on failure.
+#[no_mangle]
+pub unsafe extern "C" fn gbl_malloc(request_size: usize, alignment: usize) -> *mut c_void {
+    (|| {
+        // Prefix data:
+        let mut size = 0usize;
+        let mut offset = 0usize;
+
+        // Determine prefix size necessary to store data required for [gbl_free]: size, offset
+        let prefix_size: usize = size_of_val(&size) + size_of_val(&offset);
+
+        // Determine padding necessary to guarantee alignment. Padding includes prefix data.
+        let pad: usize = (SafeNum::from(alignment) + prefix_size).try_into().ok()?;
+
+        // Actual size to allocate. It includes padding to guarantee alignment.
+        size = (SafeNum::from(request_size) + pad).try_into().ok()?;
+
+        // SAFETY:
+        // *  On success, `alloc` guarantees to allocate enough memory.
+        let ptr = unsafe {
+            // Due to manual aligning, there is no need for specific layout alignment.
+            NonNull::new(alloc(Layout::from_size_align(size, 1).ok()?))?.as_ptr()
+        };
+
+        // Calculate the aligned address to return the caller.
+        let ret_address = (SafeNum::from(ptr as usize) + prefix_size).round_up(alignment);
+
+        // Calculate the offsets from the allocation start.
+        let ret_offset = ret_address - (ptr as usize);
+        let align_offset: usize = (ret_offset - size_of_val(&size)).try_into().ok()?;
+        let size_offset: usize = (align_offset - size_of_val(&offset)).try_into().ok()?;
+        offset = usize::try_from(ret_offset).ok()?;
+
+        // SAFETY:
+        // 'ptr' is guarantied to be valid:
+        // - not NULL; Checked with `NonNull`
+        // - it points to single block of memory big enough to hold size+offset (allocated this
+        // way)
+        // - memory is 1-byte aligned for [u8] slice
+        // - ptr+offset is guarantied to point to the buffer of size 'size' as per allocation that
+        // takes into account padding and prefix.
+        unsafe {
+            // Write metadata and return the caller's pointer.
+            core::slice::from_raw_parts_mut(ptr.add(size_offset), size_of_val(&size))
+                .copy_from_slice(&size.to_ne_bytes());
+            core::slice::from_raw_parts_mut(ptr.add(align_offset), size_of_val(&offset))
+                .copy_from_slice(&offset.to_ne_bytes());
+
+            Some(ptr.add(offset))
+        }
+    })()
+    .unwrap_or(null_mut()) as _
+}
+
+/// Extended version of void free(void *ptr) with ptr alignment configuration support.
+///
+/// # Safety
+///
+/// * `ptr` must be allocated by `gbl_malloc` and guarantee enough memory for a preceding
+///   `usize` value and payload or null.
+/// * `gbl_free` must be called with the same `alignment` as the corresponding `gbl_malloc` call.
+#[no_mangle]
+pub unsafe extern "C" fn gbl_free(ptr: *mut c_void, alignment: usize) {
+    if ptr.is_null() {
+        // follow libc free behavior
+        return;
+    }
+    let mut ptr = ptr as *mut u8;
+
+    let mut offset = 0usize;
+    let mut size = 0usize;
+
+    // Calculate offsets for size of align data
+    let align_offset: usize = size_of_val(&size);
+    let size_offset: usize = align_offset + size_of_val(&size);
+
+    // Read size used in allocation from prefix data.
+    offset = usize::from_ne_bytes(
+        // SAFETY:
+        // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
+        // prefix data. Which consists of align and size values.
+        // * Alignment is 1 for &[u8]
+        unsafe { core::slice::from_raw_parts(ptr.sub(align_offset), size_of_val(&offset)) }
+            .try_into()
+            .unwrap(),
+    );
+
+    // Read offset for unaligned pointer from prefix data.
+    size = usize::from_ne_bytes(
+        // SAFETY:
+        // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
+        // prefix data. Which consists of align and size values.
+        // * Alignment is 1 for &[u8]
+        unsafe { core::slice::from_raw_parts(ptr.sub(size_offset), size_of_val(&size)) }
+            .try_into()
+            .unwrap(),
+    );
+
+    // SAFETY:
+    // * `ptr` is allocated by `gbl_malloc` and has enough padding before `ptr` to hold
+    // prefix data. ptr - offset must point to unaligned pointer to buffer, which was returned by
+    // `alloc`, and must be passed to `dealloc`
+    unsafe {
+        // Calculate unaligned pointer returned by [alloc], which must be used in [dealloc]
+        ptr = ptr.sub(offset);
+
+        // Call to global allocator.
+        dealloc(ptr, Layout::from_size_align(size, alignment).unwrap());
+    };
+}
 
 /// void *memchr(const void *ptr, int ch, size_t count);
+///
+/// # Safety
+///
+/// * `ptr` needs to be a buffer with at least `count` bytes.
+/// * Returns the pointer within `ptr` buffer, or null if not found.
 #[no_mangle]
-pub extern "C" fn memchr(
-    ptr: *const core::ffi::c_void,
-    ch: core::ffi::c_int,
-    count: core::ffi::c_ulong,
-) -> *mut core::ffi::c_void {
+pub unsafe extern "C" fn memchr(ptr: *const c_void, ch: c_int, count: c_ulong) -> *mut c_void {
     assert!(!ptr.is_null());
     let start = ptr as *const u8;
     let target = (ch & 0xff) as u8;
     for i in 0..count {
-        // SAFETY: Buffer is assumed valid and bounded by count.
+        // SAFETY: `ptr` buffer is assumed valid and bounded by count.
         let curr = unsafe { start.add(i.try_into().unwrap()) };
-        // SAFETY: Buffer is assumed valid and bounded by count.
+        // SAFETY: `ptr` buffer is assumed valid and bounded by count.
         if *unsafe { curr.as_ref().unwrap() } == target {
             return curr as *mut _;
         }
@@ -40,28 +186,15 @@ pub extern "C" fn memchr(
     null_mut()
 }
 
-/// char *strrchr(const char *str, int c);
-#[no_mangle]
-pub extern "C" fn strrchr(
-    ptr: *const core::ffi::c_char,
-    ch: core::ffi::c_int,
-) -> *mut core::ffi::c_char {
-    assert!(!ptr.is_null());
-    // SAFETY: Input is a valid null terminated string.
-    let bytes = unsafe { core::ffi::CStr::from_ptr(ptr).to_bytes_with_nul() };
-    let target = (ch & 0xff) as u8;
-    for c in bytes.iter().rev() {
-        if *c == target {
-            return c as *const _ as *mut _;
-        }
-    }
-    null_mut()
-}
-
 /// size_t strnlen(const char *s, size_t maxlen);
+///
+/// # Safety
+///
+/// * `s` must be a valid pointer to a null terminated C string.
 #[no_mangle]
-pub fn strnlen(s: *const core::ffi::c_char, maxlen: usize) -> usize {
-    match memchr(s as *const _, 0, maxlen.try_into().unwrap()) {
+pub unsafe extern "C" fn strnlen(s: *const c_char, maxlen: usize) -> usize {
+    // SAFETY: `s` is a valid pointer to a null terminated string.
+    match unsafe { memchr(s as *const _, 0, maxlen.try_into().unwrap()) } {
         p if p.is_null() => maxlen,
         p => (p as usize) - (s as usize),
     }
diff --git a/gbl/libc/src/strchr.rs b/gbl/libc/src/strchr.rs
new file mode 100644
index 0000000..857eab1
--- /dev/null
+++ b/gbl/libc/src/strchr.rs
@@ -0,0 +1,207 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This library provides implementation for strchr libc functions family.
+//! https://en.cppreference.com/w/c/string/byte/strchr
+
+use core::ffi::{c_char, c_int, CStr};
+use core::ptr::null_mut;
+
+/// char *strchr(const char *str, int c);
+///
+/// # Safety
+///
+/// * `str` must be a valid null-terminated C string.
+#[no_mangle]
+pub unsafe extern "C" fn strchr(ptr: *const c_char, ch: c_int) -> *mut c_char {
+    assert!(!ptr.is_null());
+    // SAFETY: `str` is a valid null terminated string.
+    let bytes = unsafe { CStr::from_ptr(ptr) }.to_bytes_with_nul();
+    let target = (ch & 0xff) as u8;
+    for c in bytes.iter() {
+        if *c == target {
+            return c as *const _ as *mut _;
+        }
+    }
+    null_mut()
+}
+
+/// char *strrchr(const char *str, int c);
+///
+/// # Safety
+///
+/// * `str` must be a valid null-terminated C string.
+#[no_mangle]
+pub unsafe extern "C" fn strrchr(ptr: *const c_char, ch: c_int) -> *mut c_char {
+    assert!(!ptr.is_null());
+    // SAFETY: `str` is a null terminated string.
+    let bytes = unsafe { CStr::from_ptr(ptr) }.to_bytes_with_nul();
+    let target = (ch & 0xff) as u8;
+    for c in bytes.iter().rev() {
+        if *c == target {
+            return c as *const _ as *mut _;
+        }
+    }
+    null_mut()
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::ffi::CString;
+
+    fn to_cstr(s: &str) -> CString {
+        CString::new(s).unwrap()
+    }
+
+    fn do_strchr(input: &str, c: char) -> Option<usize> {
+        let input_cstr = to_cstr(input);
+        // SAFETY: `input_cstr` is a null terminated string.
+        let result = unsafe { strchr(input_cstr.as_ptr(), c as c_int) };
+
+        if result.is_null() {
+            None
+        } else {
+            let start_ptr = input_cstr.as_ptr();
+            // SAFETY: `result` is a pointer within the string that `start_ptr` points to.
+            Some(unsafe { result.offset_from(start_ptr) as usize })
+        }
+    }
+
+    fn do_strrchr(input: &str, c: char) -> Option<usize> {
+        let input_cstr = to_cstr(input);
+        // SAFETY: `input_cstr` is a null terminated string.
+        let result = unsafe { strrchr(input_cstr.as_ptr(), c as c_int) };
+
+        if result.is_null() {
+            None
+        } else {
+            let start_ptr = input_cstr.as_ptr();
+            // SAFETY: `result` is a pointer within the string that `start_ptr` points to.
+            Some(unsafe { result.offset_from(start_ptr) as usize })
+        }
+    }
+
+    // strchr tests
+
+    #[test]
+    fn strchr_find_first_occurrence() {
+        let offset = do_strchr("hello", 'e');
+        assert_eq!(offset, Some(1));
+    }
+
+    #[test]
+    fn strchr_find_first_occurrence_special_character() {
+        let offset = do_strchr("he!lo", '!');
+        assert_eq!(offset, Some(2));
+    }
+
+    #[test]
+    fn strchr_character_not_present() {
+        let offset = do_strchr("hello", 'z');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strchr_find_first_occurrence_at_start() {
+        let offset = do_strchr("hello", 'h');
+        assert_eq!(offset, Some(0));
+    }
+
+    #[test]
+    fn strchr_find_first_occurrence_at_end() {
+        let offset = do_strchr("hello", 'o');
+        assert_eq!(offset, Some(4));
+    }
+
+    #[test]
+    fn strchr_empty_string() {
+        let offset = do_strchr("", 'a');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strchr_find_first_occurrence_multiple() {
+        let offset = do_strchr("hellohello", 'l');
+        assert_eq!(offset, Some(2));
+    }
+
+    #[test]
+    fn strchr_case_sensitivity() {
+        let offset = do_strchr("Hello", 'h');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strchr_find_null_character() {
+        let offset = do_strchr("Hello", '\0');
+        assert_eq!(offset, Some(5));
+    }
+
+    // strrchr tests
+
+    #[test]
+    fn strrchr_find_last_occurrence() {
+        let offset = do_strrchr("hello", 'l');
+        assert_eq!(offset, Some(3));
+    }
+
+    #[test]
+    fn strrchr_find_last_occurrence_special_character() {
+        let offset = do_strrchr("he!lo!lo", '!');
+        assert_eq!(offset, Some(5));
+    }
+
+    #[test]
+    fn strrchr_character_not_present() {
+        let offset = do_strrchr("hello", 'z');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strrchr_find_last_occurrence_at_start() {
+        let offset = do_strrchr("hello", 'h');
+        assert_eq!(offset, Some(0));
+    }
+
+    #[test]
+    fn strrchr_find_last_occurrence_at_end() {
+        let offset = do_strrchr("hello", 'o');
+        assert_eq!(offset, Some(4));
+    }
+
+    #[test]
+    fn strrchr_empty_string() {
+        let offset = do_strrchr("", 'a');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strrchr_find_last_occurrence_multiple() {
+        let offset = do_strrchr("hellohello", 'l');
+        assert_eq!(offset, Some(8));
+    }
+
+    #[test]
+    fn strrchr_case_sensitivity() {
+        let offset = do_strrchr("Hello", 'h');
+        assert_eq!(offset, None);
+    }
+
+    #[test]
+    fn strrchr_find_null_character() {
+        let offset = do_strchr("Hello", '\0');
+        assert_eq!(offset, Some(5));
+    }
+}
diff --git a/gbl/libc/src/strcmp.rs b/gbl/libc/src/strcmp.rs
new file mode 100644
index 0000000..987773c
--- /dev/null
+++ b/gbl/libc/src/strcmp.rs
@@ -0,0 +1,206 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This library provides implementation for strcmp libc functions family.
+//! https://en.cppreference.com/w/c/string/byte/strncmp
+
+use core::cmp::Ordering;
+use core::ffi::{c_char, c_int, CStr};
+
+/// int strcmp(const char *s1, const char *s2);
+///
+/// # Safety
+///
+/// * `s1` and `s2` must be valid pointers to null terminated C strings.
+#[no_mangle]
+pub unsafe extern "C" fn strcmp(s1: *const c_char, s2: *const c_char) -> c_int {
+    // SAFETY: `s1` and `s2` are valid null-terminated strings. References are only used
+    // within function.
+    let (lhs, rhs) = unsafe { (CStr::from_ptr(s1.cast()), CStr::from_ptr(s2.cast())) };
+    Ord::cmp(lhs, rhs) as _
+}
+
+/// int strncmp(const char *s1, const char *s2, size_t n);
+///
+/// # Safety
+///
+/// * `s1` and `s2` must be at least nth sized or null terminated arrays.
+#[no_mangle]
+pub unsafe extern "C" fn strncmp(s1: *const c_char, s2: *const c_char, n: usize) -> c_int {
+    for i in 0..n {
+        // SAFETY: `i` is always within the bounds of `s1` and `s2` because it is limited by `n`,
+        // and this statement is unreachable if a null character is already encountered in `s1`
+        // or `s2`.
+        let (l, r) = unsafe { (*s1.add(i), *s2.add(i)) };
+
+        let cmp = l.cmp(&r);
+        if cmp != Ordering::Equal || l == 0 {
+            return cmp as _;
+        }
+    }
+    Ordering::Equal as _
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::ffi::CString;
+
+    fn to_cstr(s: &str) -> CString {
+        CString::new(s).unwrap()
+    }
+
+    fn do_strcmp(left: &str, right: &str) -> c_int {
+        let left_cstr = to_cstr(left);
+        let right_cstr = to_cstr(right);
+        // SAFETY: `left_cstr` and `right_cstr` are null terminated strings.
+        unsafe { strcmp(left_cstr.as_ptr(), right_cstr.as_ptr()) }
+    }
+
+    fn do_strncmp(left: &str, right: &str, n: usize) -> c_int {
+        let left_cstr = to_cstr(left);
+        let right_cstr = to_cstr(right);
+        // SAFETY: `left_cstr` and `right_cstr` are null terminated strings.
+        unsafe { strncmp(left_cstr.as_ptr(), right_cstr.as_ptr(), n) }
+    }
+
+    fn do_strncmp_bytes(left: &[u8], right: &[u8], n: usize) -> c_int {
+        // SAFETY: `left` and `right` are not null.
+        unsafe { strncmp(left.as_ptr().cast(), right.as_ptr().cast(), n) }
+    }
+
+    // strcmp tests
+
+    #[test]
+    fn strcmp_same() {
+        assert_eq!(do_strcmp("first", "first"), 0);
+    }
+
+    #[test]
+    fn strcmp_same_special_characters() {
+        assert_eq!(do_strcmp("!@#", "!@#"), 0);
+    }
+
+    #[test]
+    fn strcmp_left_smaller() {
+        assert_eq!(do_strcmp("first", "second"), -1);
+    }
+
+    #[test]
+    fn strcmp_left_is_prefix_of_right() {
+        assert_eq!(do_strcmp("first", "firstly"), -1);
+    }
+
+    #[test]
+    fn strcmp_right_is_prefix_of_left() {
+        assert_eq!(do_strcmp("firstly", "first"), 1);
+    }
+
+    #[test]
+    fn strcmp_empty() {
+        assert_eq!(do_strcmp("", ""), 0);
+    }
+
+    #[test]
+    fn strcmp_empty_vs_non_empty() {
+        assert_eq!(do_strcmp("", "nonempty"), -1);
+    }
+
+    #[test]
+    fn strcmp_non_empty_vs_empty() {
+        assert_eq!(do_strcmp("nonempty", ""), 1);
+    }
+
+    #[test]
+    fn strcmp_case_sensitivity() {
+        assert_eq!(do_strcmp("First", "first"), -1);
+    }
+
+    // strncmp tests
+
+    #[test]
+    fn strncmp_same_exact_length() {
+        assert_eq!(do_strncmp("hello", "hello", 5), 0);
+    }
+
+    #[test]
+    fn strncmp_same_partial_length() {
+        assert_eq!(do_strncmp("hello", "hello", 3), 0);
+    }
+
+    #[test]
+    fn strncmp_same_overflow() {
+        assert_eq!(do_strncmp("hello", "hello", 100), 0);
+    }
+
+    #[test]
+    fn strncmp_same_special_characters() {
+        assert_eq!(do_strncmp("!@#", "!@#", 3), 0);
+    }
+
+    #[test]
+    fn strncmp_different_exact_length() {
+        assert_eq!(do_strncmp("hello", "world", 5), -1);
+    }
+
+    #[test]
+    fn strncmp_different_partial_length() {
+        assert_eq!(do_strncmp("hello", "world", 3), -1);
+    }
+
+    #[test]
+    fn strncmp_left_is_prefix_of_right() {
+        assert_eq!(do_strncmp("abc", "abcdef", 6), -1);
+    }
+
+    #[test]
+    fn strncmp_right_is_prefix_of_left() {
+        assert_eq!(do_strncmp("abcdef", "abc", 6), 1);
+    }
+
+    #[test]
+    fn strncmp_empty_strings() {
+        assert_eq!(do_strncmp("", "", 5), 0);
+    }
+
+    #[test]
+    fn strncmp_empty_vs_non_empty() {
+        assert_eq!(do_strncmp("", "hello", 5), -1);
+    }
+
+    #[test]
+    fn strncmp_non_empty_vs_empty() {
+        assert_eq!(do_strncmp("hello", "", 5), 1);
+    }
+
+    #[test]
+    fn strncmp_case_sensitivity() {
+        assert_eq!(do_strncmp("Hello", "hello", 5), -1);
+    }
+
+    #[test]
+    fn strncmp_bytes_array_same_exact_length() {
+        assert_eq!(do_strncmp_bytes(b"hello", b"hello", 5), 0);
+    }
+
+    #[test]
+    fn strncmp_bytes_array_right_terminated() {
+        assert_eq!(do_strncmp_bytes(b"hello", b"hel\0", 5), 1);
+    }
+
+    #[test]
+    fn strncmp_bytes_array_left_terminated() {
+        assert_eq!(do_strncmp_bytes(b"hel\0", b"hello", 5), -1);
+    }
+}
diff --git a/gbl/libc/src/strtoul.rs b/gbl/libc/src/strtoul.rs
new file mode 100644
index 0000000..091bf46
--- /dev/null
+++ b/gbl/libc/src/strtoul.rs
@@ -0,0 +1,349 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This library provides implementation for strtoul libc functions family.
+//! https://en.cppreference.com/w/cpp/string/byte/strtoul
+
+use core::ffi::{c_char, c_int, c_ulong, CStr};
+use safemath::SafeNum;
+
+/// unsigned long int strtoul(const char *s, char **endptr, int base);
+///
+/// # Safety
+///
+/// * `s` must be valid pointer to null terminated C string
+/// * `endptr` must be a valid pointer that is available for writing or null
+#[no_mangle]
+pub unsafe extern "C" fn strtoul(
+    s: *const c_char,
+    endptr: *mut *const c_char,
+    base: c_int,
+) -> c_ulong {
+    assert!(!s.is_null());
+    assert!(base == 0 || base == 8 || base == 10 || base == 16);
+
+    let mut pos = 0;
+    let mut base = base;
+    let mut negative = false;
+
+    // SAFETY: `s` is a valid null terminated string
+    let bytes = unsafe { CStr::from_ptr(s) }.to_bytes();
+
+    // Skip leading whitespace
+    while pos < bytes.len() && bytes[pos].is_ascii_whitespace() {
+        pos += 1;
+    }
+
+    // Handle sign
+    if pos < bytes.len() {
+        match bytes[pos] {
+            b'+' => pos += 1,
+            b'-' => {
+                pos += 1;
+                negative = true;
+            }
+            _ => {}
+        }
+    }
+
+    // Handle base prefixes
+    if (base == 16 || base == 0)
+        && pos < bytes.len() - 1
+        && bytes[pos] == b'0'
+        && (bytes[pos + 1] == b'x' || bytes[pos + 1] == b'X')
+    {
+        pos += 2;
+        base = 16;
+    }
+    if (base == 8 || base == 0) && pos < bytes.len() && bytes[pos] == b'0' {
+        pos += 1;
+        base = 8;
+    }
+    if base == 0 {
+        base = 10;
+    }
+
+    let mut result: SafeNum = 0.into();
+    while pos < bytes.len() {
+        let symbol = bytes[pos];
+        let value = match symbol {
+            b'0'..=b'7' if base == 8 => symbol - b'0',
+            b'0'..=b'9' if base == 10 || base == 16 => symbol - b'0',
+            b'a'..=b'f' if base == 16 => symbol - b'a' + 10,
+            b'A'..=b'F' if base == 16 => symbol - b'A' + 10,
+            _ => break,
+        };
+        result = result * base + value;
+        pos += 1;
+    }
+
+    if !endptr.is_null() {
+        // SAFETY: `endptr` is a non-null pointer which is available for writing, `s` is a valid
+        // non-null pointer, `pos` is guaranteed to be within `s` by `pos < bytes.len()` checks.
+        unsafe { *endptr = s.add(pos) };
+    }
+
+    match c_ulong::try_from(result) {
+        Ok(result) if negative => result.overflowing_neg().0,
+        Ok(result) => result,
+        _ => c_ulong::MAX,
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::ffi::CString;
+    use std::ptr::null_mut;
+
+    fn to_cstr(s: &str) -> CString {
+        CString::new(s).unwrap()
+    }
+
+    fn do_strtoul(input: &str, base: i32) -> (c_ulong, Option<usize>) {
+        let input_cstr = to_cstr(input);
+        let mut end_ptr: *const c_char = null_mut();
+        // SAFETY: `input_cstr` is a null terminated string, `end_ptr` is initialized null pointer
+        let result = unsafe { strtoul(input_cstr.as_ptr(), &mut end_ptr, base) };
+
+        let end_position = if end_ptr.is_null() {
+            None
+        } else {
+            let start_ptr = input_cstr.as_ptr();
+            // SAFETY: `end_ptr` is a pointer within the string that `start_ptr` points to
+            Some(unsafe { end_ptr.offset_from(start_ptr) } as usize)
+        };
+
+        (result, end_position)
+    }
+
+    fn do_strtoul_no_endptr(input: &str, base: i32) -> c_ulong {
+        let input_cstr = to_cstr(input);
+        // SAFETY: `input_cstr` is a null terminated string
+        unsafe { strtoul(input_cstr.as_ptr(), null_mut(), base) }
+    }
+
+    // strtoul tests
+
+    #[test]
+    fn strtoul_decimal() {
+        let (r, end) = do_strtoul("12345", 10);
+        assert_eq!(r, 12345);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_no_endptr() {
+        let r = do_strtoul_no_endptr("12345", 10);
+        assert_eq!(r, 12345);
+    }
+
+    #[test]
+    fn strtoul_zero() {
+        let (r, end) = do_strtoul("0", 10);
+        assert_eq!(r, 0);
+        assert_eq!(end, Some(1));
+    }
+
+    #[test]
+    fn strtoul_empty() {
+        let (r, end) = do_strtoul("", 10);
+        assert_eq!(r, 0);
+        // Empty input, end_ptr should point to the start
+        assert_eq!(end, Some(0));
+    }
+
+    #[test]
+    fn strtoul_empty_no_endptr() {
+        let r = do_strtoul_no_endptr("", 10);
+        assert_eq!(r, 0);
+    }
+
+    #[test]
+    fn strtoul_invalid_characters() {
+        let (r, end) = do_strtoul("123abc", 10);
+        assert_eq!(r, 123);
+        // Parsing stops at 'a', so end_ptr should point to index 3
+        assert_eq!(end, Some(3));
+    }
+
+    #[test]
+    fn strtoul_positive_sign() {
+        let (r, end) = do_strtoul("+456", 10);
+        assert_eq!(r, 456);
+        assert_eq!(end, Some(4));
+    }
+
+    #[test]
+    fn strtoul_negative_sign() {
+        let (r, end) = do_strtoul("-1000", 10);
+        assert_eq!(r, 18446744073709550616);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_negative_zero_sign() {
+        let (r, end) = do_strtoul("-0", 10);
+        assert_eq!(r, 0);
+        assert_eq!(end, Some(2));
+    }
+
+    #[test]
+    fn strtoul_prefix_spaces() {
+        let (r, end) = do_strtoul("   456", 10);
+        assert_eq!(r, 456);
+        assert_eq!(end, Some(6));
+    }
+
+    #[test]
+    fn strtoul_leading_zeroes() {
+        let (r, end) = do_strtoul("0000456", 10);
+        assert_eq!(r, 456);
+        assert_eq!(end, Some(7));
+    }
+
+    #[test]
+    fn strtoul_overflow() {
+        let (r, end) = do_strtoul("999999999999999999999999999999", 10);
+        assert_eq!(r, c_ulong::MAX);
+        // Whole input string got processed, so end_ptr should point to the end
+        assert_eq!(end, Some(30));
+    }
+
+    #[test]
+    fn strtoul_octal() {
+        let (r, end) = do_strtoul("12345", 8);
+        assert_eq!(r, 0o12345);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_octal_prefix() {
+        let (r, end) = do_strtoul("01234", 8);
+        assert_eq!(r, 0o1234);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_octal_invalid_characters() {
+        let (r, end) = do_strtoul("1289", 8);
+        assert_eq!(r, 0o12);
+        assert_eq!(end, Some(2));
+    }
+
+    #[test]
+    fn strtoul_octal_prefix_spaces() {
+        let (r, end) = do_strtoul("   0755", 8);
+        assert_eq!(r, 0o755);
+        assert_eq!(end, Some(7));
+    }
+
+    #[test]
+    fn strtoul_octal_leading_zeroes() {
+        let (r, end) = do_strtoul("0000456", 8);
+        assert_eq!(r, 0o456);
+        assert_eq!(end, Some(7));
+    }
+
+    #[test]
+    fn strtoul_octal_overflow() {
+        let (r, end) = do_strtoul("7777777777777777777777", 8);
+        assert_eq!(r, c_ulong::MAX);
+        assert_eq!(end, Some(22));
+    }
+
+    #[test]
+    fn strtoul_hex() {
+        let (r, end) = do_strtoul("12345", 16);
+        assert_eq!(r, 0x12345);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_hex_prefix() {
+        let (r, end) = do_strtoul("0x1234", 16);
+        assert_eq!(r, 0x1234);
+        assert_eq!(end, Some(6));
+    }
+
+    #[test]
+    fn strtoul_hex_invalid_characters() {
+        let (r, end) = do_strtoul("12g89", 16);
+        assert_eq!(r, 0x12);
+        assert_eq!(end, Some(2));
+    }
+
+    #[test]
+    fn strtoul_hex_prefix_spaces() {
+        let (r, end) = do_strtoul("   0x7F5", 16);
+        assert_eq!(r, 0x7F5);
+        assert_eq!(end, Some(8));
+    }
+
+    #[test]
+    fn strtoul_hex_leading_zeroes() {
+        let (r, end) = do_strtoul("0000456", 16);
+        assert_eq!(r, 0x456);
+        assert_eq!(end, Some(7));
+    }
+
+    #[test]
+    fn strtoul_hex_overflow() {
+        let (r, end) = do_strtoul("FFFFFFFFFFFFFFFFFFFF", 16);
+        assert_eq!(r, c_ulong::MAX);
+        assert_eq!(end, Some(20));
+    }
+
+    #[test]
+    fn strtoul_autodetect_decimal() {
+        let (r, end) = do_strtoul("12345", 0);
+        assert_eq!(r, 12345);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_autodetect_octal() {
+        let (r, end) = do_strtoul("01234", 0);
+        assert_eq!(r, 0o1234);
+        assert_eq!(end, Some(5));
+    }
+
+    #[test]
+    fn strtoul_autodetect_hex() {
+        let (r, end) = do_strtoul("0x1234", 0);
+        assert_eq!(r, 0x1234);
+        assert_eq!(end, Some(6));
+    }
+
+    #[test]
+    fn strtoul_autodetect_hex_invalid() {
+        let (r, end) = do_strtoul("0x12G34", 0);
+        assert_eq!(r, 0x12);
+        assert_eq!(end, Some(4));
+    }
+
+    #[test]
+    fn strtoul_autodetect_hex_leading_spaces() {
+        let (r, end) = do_strtoul("   0x7F5", 0);
+        assert_eq!(r, 0x7F5);
+        assert_eq!(end, Some(8));
+    }
+
+    #[test]
+    fn strtoul_autodetect_hex_overflow() {
+        let (r, end) = do_strtoul("0xFFFFFFFFFFFFFFFFFFFF", 0);
+        assert_eq!(r, c_ulong::MAX);
+        assert_eq!(end, Some(22));
+    }
+}
diff --git a/gbl/libdttable/BUILD b/gbl/libdttable/BUILD
new file mode 100644
index 0000000..625a675
--- /dev/null
+++ b/gbl/libdttable/BUILD
@@ -0,0 +1,90 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
+load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
+
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+link_static_cc_library(
+    name = "libdttable_c_static",
+    cc_library = "@libdttable_c",
+)
+
+rust_bindgen(
+    name = "libdttable_c_bindgen",
+    bindgen_flags = [
+        "--use-core",
+        "--with-derive-custom-struct=dt_table.*=AsBytes,FromBytes,FromZeroes,PartialEq",
+        "--allowlist-type",
+        "(dt_table.*)",
+        "--allowlist-var",
+        "(DT_TABLE.*)",
+        "--raw-line",
+        """
+# ![cfg_attr(not(test), no_std)]
+
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
+""",
+    ],
+    cc_lib = "@libdttable_c",
+    # For x86_32, we need to explicitly specify 32bit architecture.
+    clang_flags = select({
+        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
+        "//conditions:default": ["-m64"],
+    }) + [
+        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
+        "-nostdinc",
+    ],
+    header = "@libdttable_c//:dt_table.h",
+)
+
+rust_library(
+    name = "libdttable_bindgen",
+    srcs = [":libdttable_c_bindgen"],
+    deps = ["@zerocopy"],
+)
+
+rust_library(
+    name = "libdttable",
+    srcs = ["src/lib.rs"],
+    crate_name = "dttable",
+    edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        ":libdttable_bindgen",
+        ":libdttable_c_static",
+        "@gbl//liberror",
+        "@gbl//libsafemath",
+        "@zerocopy",
+    ],
+)
+
+rust_test(
+    name = "libdttable_test",
+    compile_data = [
+        "@gbl//libdttable/test:dttable.img",
+        "@gbl//libdttable/test:corrupted_dttable.img",
+    ],
+    crate = ":libdttable",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libfdt",
+    ],
+)
diff --git a/gbl/efi/arch/x86/BUILD b/gbl/libdttable/BUILD.libdttable_c.bazel
similarity index 57%
rename from gbl/efi/arch/x86/BUILD
rename to gbl/libdttable/BUILD.libdttable_c.bazel
index 0b69afc..f4d937f 100644
--- a/gbl/efi/arch/x86/BUILD
+++ b/gbl/libdttable/BUILD.libdttable_c.bazel
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,19 +12,22 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
-
 package(
     default_visibility = ["//visibility:public"],
 )
 
-cc_library(
-    name = "lib_efi_arch_deps_x86",
-    srcs = ["deps.S"],
-    visibility = ["//visibility:public"],
+# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
+# library and instead of only headers. Thus we generate a placeholder source file to meet the
+# requirement.
+genrule(
+    name = "bindgen_noop_cc",
+    outs = ["bindgen_noop_cc.cc"],
+    cmd = "touch $(OUTS)",
 )
 
-link_static_cc_library(
-    name = "efi_arch_deps_x86",
-    cc_library = ":lib_efi_arch_deps_x86",
+cc_library(
+    name = "libdttable_c",
+    srcs = [":bindgen_noop_cc"],
+    hdrs = ["dt_table.h"],
+    includes = ["."],
 )
diff --git a/gbl/libdttable/src/lib.rs b/gbl/libdttable/src/lib.rs
new file mode 100644
index 0000000..e5b9563
--- /dev/null
+++ b/gbl/libdttable/src/lib.rs
@@ -0,0 +1,180 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This library provides a wrapper APIs for libdttable_c
+//! https://source.android.com/docs/core/architecture/dto/partitions
+
+#![cfg_attr(not(test), no_std)]
+
+use core::mem::size_of;
+use libdttable_bindgen::{dt_table_entry, dt_table_header, DT_TABLE_MAGIC};
+use liberror::{Error, Result};
+use safemath::SafeNum;
+use zerocopy::{AsBytes, FromBytes, FromZeroes, LayoutVerified};
+
+/// Rust wrapper for the dt table header
+#[repr(transparent)]
+#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq)]
+struct DtTableHeader(dt_table_header);
+
+impl DtTableHeader {
+    /// Get magic handling the bytes order
+    fn magic(self) -> u32 {
+        u32::from_be(self.0.magic)
+    }
+
+    /// Get dt_entry_count handling the bytes order
+    fn dt_entry_count(self) -> u32 {
+        u32::from_be(self.0.dt_entry_count)
+    }
+
+    /// Get dt_entry_size handling the bytes order
+    fn dt_entry_size(self) -> u32 {
+        u32::from_be(self.0.dt_entry_size)
+    }
+
+    /// Get dt_entries_offset handling the bytes order
+    fn dt_entries_offset(self) -> u32 {
+        u32::from_be(self.0.dt_entries_offset)
+    }
+}
+
+/// Rust wrapper for the dt table entry
+#[repr(transparent)]
+#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq)]
+struct DtTableHeaderEntry(dt_table_entry);
+
+impl DtTableHeaderEntry {
+    /// Get id handling the bytes order
+    fn id(self) -> u32 {
+        u32::from_be(self.0.id)
+    }
+
+    /// Get rev handling the bytes order
+    fn rev(self) -> u32 {
+        u32::from_be(self.0.rev)
+    }
+
+    /// Get dt_size handling the bytes order
+    fn dt_size(self) -> u32 {
+        u32::from_be(self.0.dt_size)
+    }
+
+    /// Get dt_offset handling the bytes order
+    fn dt_offset(self) -> u32 {
+        u32::from_be(self.0.dt_offset)
+    }
+}
+
+/// Device tree blob obtained from multidt table image
+pub struct DtTableEntry<'a> {
+    /// id field from corresponding entry header
+    pub id: u32,
+    /// rev field from corresponding entry header
+    pub rev: u32,
+    /// dtb payload extracted from image
+    pub dtb: &'a [u8],
+}
+
+/// Represents entier multidt table image
+pub struct DtTableImage<'a> {
+    buffer: &'a [u8],
+    header: LayoutVerified<&'a [u8], DtTableHeader>,
+    entries: LayoutVerified<&'a [u8], [DtTableHeaderEntry]>,
+}
+
+impl<'a> DtTableImage<'a> {
+    /// Verify and parse passed buffer following multidt table structure
+    pub fn from_bytes(buffer: &'a [u8]) -> Result<DtTableImage<'a>> {
+        let (header_layout, _) = LayoutVerified::new_from_prefix(buffer)
+            .ok_or(Error::BufferTooSmall(Some(size_of::<DtTableHeader>())))?;
+
+        let header: &DtTableHeader = &header_layout;
+        if header.magic() != DT_TABLE_MAGIC {
+            return Err(Error::BadMagic);
+        }
+
+        let entries_offset: SafeNum = header.dt_entries_offset().into();
+        let entry_size: SafeNum = header.dt_entry_size().into();
+        let entries_count: SafeNum = header.dt_entry_count().into();
+
+        let entries_start = entries_offset.try_into()?;
+        let entries_end = (entries_offset + entry_size * entries_count).try_into()?;
+
+        let entries_buffer = buffer
+            .get(entries_start..entries_end)
+            .ok_or(Error::BufferTooSmall(Some(entries_end)))?;
+        let entries_layout =
+            LayoutVerified::new_slice(entries_buffer).ok_or(Error::InvalidInput)?;
+
+        Ok(DtTableImage { buffer: buffer, header: header_layout, entries: entries_layout })
+    }
+
+    /// Get amount of presented dt entries in the multidt table image
+    pub fn entries_count(&self) -> u32 {
+        self.header.dt_entry_count()
+    }
+
+    /// Get nth dtb buffer with multidt table structure metadata
+    pub fn nth_entry(&self, n: usize) -> Result<DtTableEntry<'a>> {
+        let entry = self.entries.get(n).ok_or(Error::BadIndex(n))?;
+
+        let dtb_offset: SafeNum = entry.dt_offset().into();
+        let dtb_size: SafeNum = entry.dt_size().into();
+
+        let dtb_start: usize = dtb_offset.try_into()?;
+        let dtb_end: usize = (dtb_offset + dtb_size).try_into()?;
+
+        let dtb_buffer =
+            self.buffer.get(dtb_start..dtb_end).ok_or(Error::BufferTooSmall(Some(dtb_end)))?;
+
+        Ok(DtTableEntry { id: entry.id(), rev: entry.rev(), dtb: dtb_buffer })
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use fdt::Fdt;
+
+    #[test]
+    fn test_dt_table_is_parsed() {
+        let dttable = include_bytes!("../test/dttable.img").to_vec();
+        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
+
+        assert_eq!(table.entries_count(), 2, "Test data dttable image must have 2 dtb entries");
+
+        let first_entry = table.nth_entry(0).unwrap();
+        let second_entry = table.nth_entry(1).unwrap();
+
+        assert_eq!(first_entry.id, 1, "First dttable entry id is incorrect");
+        assert_eq!(first_entry.rev, 0, "First dttable entry rev is incorrect");
+        assert_eq!(second_entry.id, 2, "Second dttable entry id is incorrect");
+        assert_eq!(second_entry.rev, 0, "Second dttable entry rev is incorrect");
+
+        // verify fdt headers are properly parsed
+        let _ = Fdt::new(first_entry.dtb).unwrap();
+        let _ = Fdt::new(second_entry.dtb).unwrap();
+    }
+
+    #[test]
+    fn test_failed_to_parse_corrupted_dt_table() {
+        let dttable = include_bytes!("../test/corrupted_dttable.img").to_vec();
+
+        assert!(
+            DtTableImage::from_bytes(&dttable[..]).is_err(),
+            "Must fail when trying to parse corrupted dt table image"
+        );
+    }
+}
diff --git a/gbl/libfdt/test/BUILD b/gbl/libdttable/test/BUILD
similarity index 91%
rename from gbl/libfdt/test/BUILD
rename to gbl/libdttable/test/BUILD
index 6325cad..8798319 100644
--- a/gbl/libfdt/test/BUILD
+++ b/gbl/libdttable/test/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
diff --git a/gbl/libdttable/test/a.dts b/gbl/libdttable/test/a.dts
new file mode 100644
index 0000000..f84523d
--- /dev/null
+++ b/gbl/libdttable/test/a.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dttable.sh after change in this file
+&deviceA {
+  value = <0x2>;
+  status = "okay";
+};
diff --git a/gbl/libdttable/test/b.dts b/gbl/libdttable/test/b.dts
new file mode 100644
index 0000000..ca47391
--- /dev/null
+++ b/gbl/libdttable/test/b.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dttable.sh after change in this file
+&deviceB {
+  value = <0x1>;
+  status = "okay";
+};
diff --git a/gbl/libdttable/test/corrupted_dttable.img b/gbl/libdttable/test/corrupted_dttable.img
new file mode 100644
index 0000000..18f4e2a
--- /dev/null
+++ b/gbl/libdttable/test/corrupted_dttable.img
@@ -0,0 +1 @@
+corrupted dttable
diff --git a/gbl/libdttable/test/dttable.img b/gbl/libdttable/test/dttable.img
new file mode 100644
index 0000000..bd0044b
Binary files /dev/null and b/gbl/libdttable/test/dttable.img differ
diff --git a/gbl/libdttable/test/gen_test_dttable.sh b/gbl/libdttable/test/gen_test_dttable.sh
new file mode 100755
index 0000000..04afca9
--- /dev/null
+++ b/gbl/libdttable/test/gen_test_dttable.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -e
+
+readonly SCRIPT_DIR=`cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd`
+readonly TMP_DIR=`mktemp -d`
+
+dtc -I dts -O dtb -o ${TMP_DIR}/a.dtb ${SCRIPT_DIR}/a.dts
+dtc -I dts -O dtb -o ${TMP_DIR}/b.dtb ${SCRIPT_DIR}/b.dts
+
+echo "corrupted dttable" > ${SCRIPT_DIR}/corrupted_dttable.img
+
+# mkdtboimg is built by cd aosp/system/libufdt/utils && mm
+mkdtboimg create ${SCRIPT_DIR}/dttable.img \
+        --id=0x2 --rev=0x0 ${TMP_DIR}/b.dtb \
+        --id=0x1 --rev=0x0 ${TMP_DIR}/a.dtb
diff --git a/gbl/libefi/BUILD b/gbl/libefi/BUILD
index 639b361..969947d 100644
--- a/gbl/libefi/BUILD
+++ b/gbl/libefi/BUILD
@@ -12,111 +12,57 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
-load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
     default_visibility = ["//visibility:public"],
 )
 
-# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
-# library and instead of only headers. Thus we generate a placeholder source file to meet the
-# requirement.
-genrule(
-    name = "bindgen_noop_cc",
-    outs = ["bindgen_noop_cc.cc"],
-    cmd = "touch $(OUTS)",
-)
-
-cc_library(
-    name = "efi_c_headers",
-    srcs = [":bindgen_noop_cc"],
-    hdrs = [
-        "defs/boot_service.h",
-        "defs/efi.h",
-        "defs/protocols/android_boot_protocol.h",
-        "defs/protocols/block_io_protocol.h",
-        "defs/protocols/device_path_protocol.h",
-        "defs/protocols/loaded_image_protocol.h",
-        "defs/protocols/riscv_efi_boot_protocol.h",
-        "defs/protocols/simple_network_protocol.h",
-        "defs/protocols/simple_text_input_protocol.h",
-        "defs/protocols/simple_text_output_protocol.h",
-        "defs/runtime_service.h",
-        "defs/system_table.h",
-        "defs/types.h",
+rust_library(
+    name = "libefi",
+    srcs = glob(["src/**/*.rs"]),
+    crate_name = "efi",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@arrayvec",
+        "@gbl//libasync",
+        "@gbl//libefi_types",
+        "@gbl//liberror",
+        "@gbl//libgbl",
+        "@gbl//libsafemath",
+        "@gbl//libstorage",
+        "@spin",
+        "@zerocopy",
     ],
-    includes = ["defs"],
 )
 
-# Side note: function pointers for UEFI interfaces need to specify the "efiapi" ABI. i.e.
-# "unsafe extern "efiapi" fn(...)". bindgen uses "extern "C"" by default. We are currently fine
-# because for x86_64/x86_32/aarch64, we use dedicated rust UEFI compiler which uses EFIAPI ABI by
-# default. For riscv64 which we use ELF compiler, the efiapi calling convention is the same as C
-# calling convention according to the UEFI spec at the time of writing. If we do eventually run
-# into problems, we need to use a newer version of bindgen 0.65.0 or above, which offers
-# "--override-abi" with "efiapi" option.
-rust_bindgen(
-    name = "efi_defs_bindgen",
-    bindgen_flags = [
-        "--ctypes-prefix",
-        "core::ffi",
-        "--use-core",
-        "--with-derive-partialeq",
-        "--with-derive-default",
-        "--with-derive-custom-struct=EfiMemoryDescriptor=AsBytes,FromBytes,FromZeroes",
-        "--allowlist-type",
-        "(Efi.*)",
-        "--raw-line",
-        """
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-use zerocopy::{AsBytes, FromBytes, FromZeroes};""",
-    ],
-    cc_lib = ":efi_c_headers",
-    # For x86_32, we need to explicitly specify 32bit architecture.
-    clang_flags = select({
-        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
-        "//conditions:default": ["-m64"],
-    }) + [
-        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
-        "-nostdinc",
+rust_test(
+    name = "libefi_test",
+    crate = ":libefi",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libavb:sysdeps",
+        "@gbl//libstorage:libstorage_testlib",
+        "@gbl//third_party/libzbi",
     ],
-    header = "defs/efi.h",
-)
-
-# Copy the generated source to "src/defs.rs" in the output assembly, so that libefi can include it
-# as a source.
-genrule(
-    name = "efi_defs_genrule",
-    srcs = [":efi_defs_bindgen"],
-    outs = ["src/defs.rs"],
-    cmd = "cat $(location :efi_defs_bindgen) > $@",
 )
 
 rust_library(
-    name = "libefi",
-    srcs = [
-        "src/allocation.rs",
-        "src/defs.rs",  # Generated by :efi_defs_genrule
-        "src/lib.rs",
-        "src/protocol.rs",
-        "src/protocol/android_boot.rs",
-        "src/protocol/block_io.rs",
-        "src/protocol/device_path.rs",
-        "src/protocol/loaded_image.rs",
-        "src/protocol/riscv.rs",
-        "src/protocol/simple_network.rs",
-        "src/protocol/simple_text_input.rs",
-        "src/protocol/simple_text_output.rs",
+    name = "mocks",
+    srcs = glob(["mocks/**/*.rs"]),
+    crate_name = "efi_mocks",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libefi",
+        "@gbl//libefi_types",
+        "@gbl//liberror",
+        "@mockall",
     ],
-    crate_name = "efi",
-    data = [":efi_defs_genrule"],
-    deps = ["@zerocopy"],
 )
 
 rust_test(
-    name = "libefi_test",
-    crate = ":libefi",
+    name = "mocks_test",
+    crate = ":mocks",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libefi/mocks/lib.rs b/gbl/libefi/mocks/lib.rs
new file mode 100644
index 0000000..8b21cba
--- /dev/null
+++ b/gbl/libefi/mocks/lib.rs
@@ -0,0 +1,312 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! UEFI object mocks to support unit tests.
+//!
+//! This module aliases mock objects to their standard names, so that code can just unconditionally
+//! use e.g. `EfiEntry` and in test code it will switch to `MockEfiEntry`.
+
+#![feature(negative_impls)]
+
+pub mod protocol;
+pub mod utils;
+
+use efi_types::{EfiConfigurationTable, EfiTimerDelay};
+use liberror::Result;
+use mockall::mock;
+use protocol::simple_text_output::{passthrough_con_out, MockSimpleTextOutputProtocol};
+use std::cell::RefCell;
+
+/// libefi types that can be used in tests as-is.
+pub use efi::{efi_print, efi_println, DeviceHandle, EventNotify, EventType};
+
+/// Holds state to set up a mock UEFI environment.
+///
+/// Parts of the libefi API surface doesn't translate super well to mocks, so this struct helps
+/// cover over some of the awkwardness. In particular, APIs that return "views" over what is
+/// really a singleton object are difficult to mock properly.
+///
+/// For example, the [efi::EfiEntry::system_table()] function returns a full [efi::SystemTable]
+/// object, not a reference. This means that our mocks have to do the same, and return a new
+/// [MockSystemTable] object - but this sort of defeats the purpose of mocks, which is to have
+/// a mock that you can set up expectations ahead of time.
+///
+/// You can get around this in a limited fashion if the code under test only needs to grab the
+/// system table once; in this case you can use the `return_once()` expectation to move the mock
+/// around. But this will cause a runtime error if the code under test tries to grab the system
+/// table more than once, since the mock will have been moved out already. And since grabbing the
+/// system table is very common, this really restricts what you can do in a test.
+///
+/// [MockEfi] works around this by stashing objects like this in `thread_local` state, and the
+/// mocks created at runtime just forward all their calls to this shared state. This allows
+/// expectations to be placed at the EFI system level, and ignore any intermediate "view" mocks
+/// that get created and destroyed over the course of the test.
+pub struct MockEfi {
+    /// The global [MockEfiEntry] to set expectations on.
+    pub entry: MockEfiEntry,
+    /// The global [MockSystemTable] to set expectations on.
+    pub system_table: MockSystemTable,
+    /// The global [MockSimpleTextOutputProtocol] to set expectations on.
+    pub con_out: MockSimpleTextOutputProtocol,
+}
+
+thread_local! {
+    pub(crate) static MOCK_EFI: RefCell<Option<MockEfi>> = RefCell::new(None);
+}
+
+impl MockEfi {
+    /// Creates a new [MockEfi].
+    ///
+    /// The following expectations will be set by this function, and should generally not be
+    /// adjusted by the caller:
+    /// * `entry.system_table()` will automatically forward to `system_table`
+    /// * `system_table.con_out()` will automatically forward to `con_out`
+    ///
+    /// Other than that, callers may set the other expectations as needed on these mocks.
+    ///
+    /// Once the mocks are ready, call [install] to install the thread-local state.
+    pub fn new() -> Self {
+        let mut entry = MockEfiEntry::default();
+        entry.expect_system_table().returning(|| passthrough_system_table());
+
+        let mut system_table = MockSystemTable::default();
+        system_table.expect_con_out().returning(|| Ok(passthrough_con_out()));
+
+        let con_out = MockSimpleTextOutputProtocol::default();
+
+        Self { entry, system_table, con_out }
+    }
+
+    /// Installs the [MockEfi] in thread-local state.
+    ///
+    /// Only one [MockEfi] can be installed at a time (per thread). Attempting to install a
+    /// second will panic.
+    ///
+    /// Returns an [InstalledMockEfi] which automatically unregisters the state on drop.
+    pub fn install(self) -> InstalledMockEfi {
+        MOCK_EFI.with_borrow_mut(|efi| {
+            // If this error message changes the unittest will need to change as well.
+            assert!(efi.is_none(), "Only one MockEfi can be installed at a time (per-thread)");
+            *efi = Some(self)
+        });
+        InstalledMockEfi { entry: passthrough_efi_entry() }
+    }
+}
+
+/// Scoped wrapper to automatically unregister the global [MockEfi] on drop.
+pub struct InstalledMockEfi {
+    entry: MockEfiEntry,
+}
+
+impl InstalledMockEfi {
+    /// The user-facing [MockEfiEntry] to use in the code under test.
+    ///
+    /// This is a const ref so you cannot place expectations here, all calls will be forwarded to
+    /// the installed [MockEfi] mocks.
+    pub fn entry(&self) -> &MockEfiEntry {
+        &self.entry
+    }
+}
+
+/// [InstalledMockEfi] uses thread-local state so cannot be sent to another thread.
+impl !Send for InstalledMockEfi {}
+
+impl Drop for InstalledMockEfi {
+    fn drop(&mut self) {
+        MOCK_EFI.with_borrow_mut(|efi| *efi = None);
+    }
+}
+
+mock! {
+    /// Mock [efi::EfiEntry].
+    pub EfiEntry {
+        /// Returns a [MockSystemTable].
+        pub fn system_table(&self) -> MockSystemTable;
+
+        /// Returns a real [efi::DeviceHandle], which is data-only so isn't mocked.
+        pub fn image_handle(&self) -> DeviceHandle;
+    }
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type EfiEntry = MockEfiEntry;
+
+/// While this mock itself isn't necessarily thread-local, passing through to the thread-local state
+/// is our primary use case, so we just disallow [Send] entirely.
+impl !Send for MockEfiEntry {}
+
+/// Returns a [MockEfiEntry] that forwards all calls to `MOCK_EFI`.
+fn passthrough_efi_entry() -> MockEfiEntry {
+    let mut entry = MockEfiEntry::default();
+    entry
+        .expect_system_table()
+        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().entry.system_table()));
+    entry
+        .expect_image_handle()
+        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().entry.image_handle()));
+    entry
+}
+
+mock! {
+    /// Mock [efi::SystemTable].
+    pub SystemTable {
+        /// Returns a [MockBootServices].
+        pub fn boot_services(&self) -> MockBootServices;
+
+        /// Returns a [MockSimpleTextOutputProtocol]. This is a singleton protocol which is
+        /// always-open, as opposed to most protocols which need to be opened explicitly.
+        pub fn con_out(&self) -> Result<MockSimpleTextOutputProtocol>;
+
+        /// Returns a real [efi::EfiConfigurationTable], which is data-only so isn't mocked.
+        pub fn configuration_table(&self) -> Option<&'static [EfiConfigurationTable]>;
+    }
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type SystemTable = MockSystemTable;
+
+/// While this mock itself isn't necessarily thread-local, passing through to the thread-local state
+/// is our primary use case, so we just disallow [Send] entirely.
+impl !Send for MockSystemTable {}
+
+/// Returns a [MockSystemTable] that forwards all calls to `MOCK_EFI`.
+fn passthrough_system_table() -> MockSystemTable {
+    let mut table = MockSystemTable::default();
+    table
+        .expect_con_out()
+        .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().system_table.con_out()));
+    table
+}
+
+mock! {
+    /// Mock [efi::BootServices].
+    pub BootServices {
+        /// Returns an instance of the requested type `T`.
+        ///
+        /// This is slightly different than the original API because it's difficult to mock an
+        /// [efi::Protocol] wrapping [efi::ProtocolInfo]. To simplify, we just return a mock
+        /// that looks like the protocol object.
+        pub fn open_protocol<T: 'static>(&self, handle: DeviceHandle) -> Result<T>;
+
+        /// Similar to [open_protocol], returns the type `T`.
+        pub fn find_first_and_open<T: 'static>(&self) -> Result<T>;
+
+        /// Returns a [MockEvent].
+        pub fn create_event(
+            &self,
+            event_type: EventType,
+            mut cb: Option<&'static mut EventNotify<'static>>,
+        ) -> Result<MockEvent>;
+
+        /// Sets a [MockEvent] timer.
+        pub fn set_timer(
+            &self,
+            event: &MockEvent,
+            delay_type: EfiTimerDelay,
+            trigger_time: u64,
+        ) -> Result<()>;
+    }
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type BootServices = MockBootServices;
+
+mock! {
+    /// Mock [efi::LocatedHandles].
+    pub LocatedHandles {}
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type LocatedHandles = MockLocatedHandles;
+
+mock! {
+    /// Mock [efi::Event].
+    pub Event {}
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type Event = MockEvent;
+
+#[cfg(test)]
+pub mod test {
+    use super::*;
+    use mockall::predicate::eq;
+    use std::fmt::Write;
+
+    #[test]
+    fn efi_state_install() {
+        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
+
+        // Global should still be `None` until we call `install()`.
+        let mock_efi = MockEfi::new();
+        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
+
+        let installed = mock_efi.install();
+        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_some()));
+
+        // Global goes back to `None` once the install goes out of scope.
+        drop(installed);
+        MOCK_EFI.with_borrow_mut(|efi| assert!(efi.is_none()));
+    }
+
+    #[test]
+    #[should_panic(expected = "Only one MockEfi can be installed at a time (per-thread)")]
+    fn efi_state_double_install_fails() {
+        let mock_efi = MockEfi::new();
+        let mock_efi_2 = MockEfi::new();
+
+        let installed = mock_efi.install();
+        mock_efi_2.install();
+
+        // Explicit drop to keep it in scope until here.
+        drop(installed);
+    }
+
+    #[test]
+    fn efi_state_con_out_write_once() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
+
+        let installed = mock_efi.install();
+        let efi_entry = installed.entry();
+
+        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "foo", 123).is_ok());
+    }
+
+    #[test]
+    fn efi_state_con_out_write_twice_same_mock() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
+        mock_efi.con_out.expect_write_str().once().with(eq("bar 456")).return_const(Ok(()));
+
+        let installed = mock_efi.install();
+        let efi_entry = installed.entry();
+
+        let mut con_out = efi_entry.system_table().con_out().unwrap();
+        assert!(write!(con_out, "{} {}", "foo", 123).is_ok());
+        assert!(write!(con_out, "{} {}", "bar", 456).is_ok());
+    }
+
+    #[test]
+    fn efi_state_con_out_write_twice_different_mock() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi.con_out.expect_write_str().once().with(eq("foo 123")).return_const(Ok(()));
+        mock_efi.con_out.expect_write_str().once().with(eq("bar 456")).return_const(Ok(()));
+
+        let installed = mock_efi.install();
+        let efi_entry = installed.entry();
+
+        // Call `write!` on two separate passthrough mocks, both should forward the calls to
+        // the "real" global mock.
+        //
+        // A common instance of this is `efi_print!` which fetches a new `con_out` on every call.
+        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "foo", 123).is_ok());
+        assert!(write!(efi_entry.system_table().con_out().unwrap(), "{} {}", "bar", 456).is_ok());
+    }
+}
diff --git a/gbl/libefi/mocks/protocol.rs b/gbl/libefi/mocks/protocol.rs
new file mode 100644
index 0000000..bd1d7dd
--- /dev/null
+++ b/gbl/libefi/mocks/protocol.rs
@@ -0,0 +1,150 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Mock protocols.
+//!
+//! The structure of these sub-modules must match the libefi structure so that the code can refer
+//! to either one using the same path.
+
+use crate::{DeviceHandle, MOCK_EFI};
+use core::fmt::Write;
+use efi::protocol::gbl_efi_image_loading::EfiImageBuffer;
+use efi_types::{EfiInputKey, GblEfiImageInfo, GblEfiPartitionName};
+use liberror::Result;
+use mockall::mock;
+
+/// Mock device_path module.
+pub mod device_path {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::DevicePathProtocol].
+        pub DevicePathProtocol {}
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type DevicePathProtocol = MockDevicePathProtocol;
+
+    mock! {
+        /// Mock [efi::DevicePathToTextProtocol].
+        pub DevicePathToTextProtocol {
+            /// Returns a [MockDevicePathText].
+            ///
+            /// Lifetimes are a little difficult to mock perfectly, so here we can only allow a
+            /// `'static` return value.
+            pub fn convert_device_path_to_text(
+                &self,
+                device_path: &MockDevicePathProtocol,
+                display_only: bool,
+                allow_shortcuts: bool,
+            ) -> Result<MockDevicePathText<'static>>;
+        }
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type DevicePathToTextProtocol = MockDevicePathToTextProtocol;
+
+    mock! {
+        /// Mock [efi::DevicePathText].
+        pub DevicePathText<'a> {
+            /// Returns the text, which is data-only so isn't mocked.
+            pub fn text(&self) -> Option<&'a [u16]>;
+        }
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type DevicePathText<'a> = MockDevicePathText<'a>;
+}
+
+/// Mock loaded_image protocol.
+pub mod loaded_image {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::LoadedImageProtocol].
+        pub LoadedImageProtocol {
+            /// Returns a real [efi::DeviceHandle], which is data-only so isn't mocked.
+            pub fn device_handle(&self) -> Result<DeviceHandle>;
+        }
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type LoadedImageProtocol = MockLoadedImageProtocol;
+}
+
+/// Mock simple_text_input module.
+pub mod simple_text_input {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::SimpleTextInputProtocol].
+        pub SimpleTextInputProtocol {
+            /// Returns an [EfiInputKey], which is data-only so isn't mocked.
+            pub fn read_key_stroke(&self) -> Result<Option<EfiInputKey>>;
+        }
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type SimpleTextInputProtocol = MockSimpleTextInputProtocol;
+}
+
+/// Mock simple_text_output module.
+pub mod simple_text_output {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::SimpleTextOutputProtocol].
+        pub SimpleTextOutputProtocol {}
+
+        impl Write for SimpleTextOutputProtocol {
+            fn write_str(&mut self, s: &str) -> core::fmt::Result;
+        }
+    }
+    /// Map to the libefi name so code under test can just use one name.
+    pub type SimpleTextOutputProtocol = MockSimpleTextOutputProtocol;
+
+    /// Returns a [MockSimpleTextOutputProtocol] that forwards all calls to `MOCK_EFI`.
+    pub fn passthrough_con_out() -> MockSimpleTextOutputProtocol {
+        let mut con_out = MockSimpleTextOutputProtocol::default();
+        con_out.expect_write_str().returning(|s| {
+            MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().con_out.write_str(s))
+        });
+        con_out
+    }
+
+    /// While this mock itself isn't necessarily thread-local, passing through to the thread-local
+    /// state is our primary use case, so we just disallow [Send] entirely.
+    impl !Send for MockSimpleTextOutputProtocol {}
+}
+
+/// Mock image_loading protocol.
+pub mod gbl_efi_image_loading {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::ImageLoadingProtocol].
+        pub GblImageLoadingProtocol {
+            /// Returns [EfiImageBuffer] matching `gbl_image_info`
+            pub fn get_buffer(&self, gbl_image_info: &GblEfiImageInfo) -> Result<EfiImageBuffer>;
+
+            /// Returns number of partitions to be provided via `get_verify_partitions()`, and thus
+            /// expected size of `partition_name` slice.
+            pub fn get_verify_partitions_count(&self) -> Result<usize>;
+
+            /// Returns number of partition names written to `partition_name` slice.
+            pub fn get_verify_partitions(
+                &self,
+                partition_names: &mut [GblEfiPartitionName]
+            ) -> Result<usize>;
+        }
+    }
+
+    /// Map to the libefi name so code under test can just use one name.
+    pub type GblImageLoadingProtocol = MockGblImageLoadingProtocol;
+}
diff --git a/gbl/libefi/mocks/utils.rs b/gbl/libefi/mocks/utils.rs
new file mode 100644
index 0000000..b3d9a75
--- /dev/null
+++ b/gbl/libefi/mocks/utils.rs
@@ -0,0 +1,33 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Mock utils.
+
+use crate::MockEfiEntry;
+use liberror::Result;
+use mockall::mock;
+
+mock! {
+    /// Mock [efi::utils::Timeout].
+    pub Timeout {
+        /// Creates a new [MockTimeout].
+        pub fn new(efi_entry: &MockEfiEntry, timeout_ms: u64) -> Result<Self>;
+        /// Checks the timeout.
+        pub fn check(&self) -> Result<bool>;
+        /// Resets the timeout.
+        pub fn reset(&self, timeout_ms: u64) -> Result<()>;
+    }
+}
+/// Map to the libefi name so code under test can just use one name.
+pub type Timeout = MockTimeout;
diff --git a/gbl/libefi/src/ab_slots.rs b/gbl/libefi/src/ab_slots.rs
new file mode 100644
index 0000000..c9c5242
--- /dev/null
+++ b/gbl/libefi/src/ab_slots.rs
@@ -0,0 +1,672 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+extern crate gbl_storage;
+extern crate libgbl as gbl;
+
+use core::convert::TryInto;
+use gbl::slots::{
+    BootTarget, BootToken, Manager, OneShot, RecoveryTarget, Slot, SlotIterator, Suffix, Tries,
+    UnbootableReason,
+};
+use liberror::{Error, Result};
+
+use efi_types::{
+    GBL_EFI_BOOT_REASON_GBL_EFI_BOOTLOADER as REASON_BOOTLOADER,
+    GBL_EFI_BOOT_REASON_GBL_EFI_EMPTY_BOOT_REASON as REASON_EMPTY,
+    GBL_EFI_BOOT_REASON_GBL_EFI_RECOVERY as REASON_RECOVERY,
+};
+
+use crate::protocol::{gbl_efi_ab_slot as ab_slot, Protocol};
+
+const SUBREASON_BUF_LEN: usize = 64;
+
+/// Implementation for A/B slot manager based on custom EFI protocol.
+pub struct ABManager<'a> {
+    protocol: Protocol<'a, ab_slot::GblSlotProtocol>,
+    boot_token: Option<BootToken>,
+    last_set_active_idx: Option<u8>,
+}
+
+impl<'a> ABManager<'a> {
+    #[cfg(test)]
+    fn new_without_token(protocol: Protocol<'a, ab_slot::GblSlotProtocol>) -> Self {
+        Self { protocol, boot_token: None, last_set_active_idx: None }
+    }
+}
+
+impl gbl::slots::private::SlotGet for ABManager<'_> {
+    fn get_slot_by_number(&self, number: usize) -> Result<Slot> {
+        let idx = u8::try_from(number).or(Err(Error::BadIndex(number)))?;
+        let info = self.protocol.get_slot_info(idx).or(Err(Error::BadIndex(number)))?;
+        info.try_into()
+    }
+}
+
+impl Manager for ABManager<'_> {
+    fn get_boot_target(&self) -> Result<BootTarget> {
+        let slot = self.get_slot_last_set_active()?;
+        let mut subreason = [0u8; SUBREASON_BUF_LEN];
+        let (reason, _) = self.protocol.get_boot_reason(subreason.as_mut_slice())?;
+        // Don't currently care about the subreason
+        // CStr::from_bytes_until_nul(&subreason[..strlen])?
+        let target = match reason {
+            REASON_RECOVERY => BootTarget::Recovery(RecoveryTarget::Slotted(slot)),
+            _ => BootTarget::NormalBoot(slot),
+        };
+        Ok(target)
+    }
+
+    fn slots_iter(&self) -> SlotIterator {
+        SlotIterator::new(self)
+    }
+
+    fn get_slot_last_set_active(&self) -> Result<Slot> {
+        use gbl::slots::private::SlotGet;
+
+        if let Some(idx) = self.last_set_active_idx {
+            self.get_slot_by_number(idx.into())
+        } else {
+            self.protocol.get_current_slot()?.try_into()
+        }
+    }
+
+    fn mark_boot_attempt(&mut self) -> Result<BootToken> {
+        self.protocol.mark_boot_attempt().or(Err(Error::OperationProhibited))?;
+        self.boot_token.take().ok_or(Error::OperationProhibited)
+    }
+
+    fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<()> {
+        let idx: u8 = self
+            .slots_iter()
+            .position(|s| s.suffix == slot_suffix)
+            .ok_or(Error::InvalidInput)?
+            .try_into()
+            // This 'or' is technically unreachable because the protocol
+            // can't give us an index larger than a u8.
+            .or(Err(Error::Other(None)))?;
+        self.protocol.set_active_slot(idx).or(Err(Error::Other(None))).and_then(|_| {
+            self.last_set_active_idx = Some(idx);
+            Ok(())
+        })
+    }
+
+    fn set_slot_unbootable(&mut self, slot_suffix: Suffix, reason: UnbootableReason) -> Result<()> {
+        let idx: u8 = self
+            .slots_iter()
+            .position(|s| s.suffix == slot_suffix)
+            .ok_or(Error::InvalidInput)?
+            .try_into()
+            // This 'or' is technically unreachable because the protocol
+            // can't give us an index larger than a u8.
+            .or(Err(Error::Other(None)))?;
+        self.protocol.set_slot_unbootable(idx, u8::from(reason).into())
+    }
+
+    fn get_max_retries(&self) -> Result<Tries> {
+        Ok(self.protocol.load_boot_data()?.max_retries.into())
+    }
+
+    fn get_oneshot_status(&self) -> Option<OneShot> {
+        let mut subreason = [0u8; SUBREASON_BUF_LEN];
+        let (reason, _) = self.protocol.get_boot_reason(subreason.as_mut_slice()).ok()?;
+        // Currently we only care if the primary boot reason is BOOTLOADER.
+        // CStr::from_bytes_until_nul(&subreason[..strlen]).ok()?
+        match reason {
+            REASON_BOOTLOADER => Some(OneShot::Bootloader),
+            _ => None,
+        }
+    }
+
+    fn set_oneshot_status(&mut self, os: OneShot) -> Result<()> {
+        // Android doesn't have a concept of OneShot to recovery,
+        // and the subreason shouldn't matter.
+        match os {
+            OneShot::Bootloader => {
+                self.protocol.set_boot_reason(REASON_BOOTLOADER, &[]).or(Err(Error::Other(None)))
+            }
+            _ => Err(Error::OperationProhibited),
+        }
+    }
+
+    fn clear_oneshot_status(&mut self) {
+        let mut subreason = [0u8; SUBREASON_BUF_LEN];
+        // Only clear if the boot reason is the one we care about.
+        // CStr::from_bytes_until_nul(&subreason[..strlen]).or(Err(Error::Other))?
+        if let Ok((REASON_BOOTLOADER, _)) = self.protocol.get_boot_reason(subreason.as_mut_slice())
+        {
+            let _ = self.protocol.set_boot_reason(REASON_EMPTY, &[]);
+        }
+    }
+
+    fn write_back(&mut self, _: &mut dyn gbl_storage::AsBlockDevice) {
+        // Note: `expect` instead of swallowing the error.
+        // It is important that changes are not silently dropped.
+        self.protocol.flush().expect("could not write back modifications to slot metadata");
+    }
+}
+
+#[cfg(test)]
+mod test {
+    extern crate avb_sysdeps;
+
+    use super::*;
+    use crate::protocol::Protocol;
+    use crate::test::*;
+    use crate::EfiEntry;
+    use efi_types::{
+        EfiStatus, GblEfiABSlotProtocol, GblEfiSlotInfo, GblEfiSlotMetadataBlock,
+        EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
+        GBL_EFI_BOOT_REASON_GBL_EFI_EMPTY_BOOT_REASON as REASON_EMPTY,
+        GBL_EFI_BOOT_REASON_GBL_EFI_RECOVERY as REASON_RECOVERY,
+        GBL_EFI_BOOT_REASON_GBL_EFI_WATCHDOG as REASON_WATCHDOG,
+    };
+    use gbl::{
+        ops::{AvbIoResult, CertPermanentAttributes, SHA256_DIGEST_SIZE},
+        partition::PartitionBlockDevice,
+        slots::{Bootability, Cursor, RecoveryTarget, UnbootableReason},
+        BootImages, Gbl, GblOps, Result as GblResult,
+    };
+    use gbl_storage_testlib::TestBlockDevice;
+    use libgbl::ops::ImageBuffer;
+    // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+    use std::{
+        fmt::Write,
+        mem::align_of,
+        num::NonZeroUsize,
+        sync::atomic::{AtomicBool, AtomicU32, Ordering},
+    };
+    use zbi::ZbiContainer;
+
+    // The thread-local atomics are an ugly, ugly hack to pass state between
+    // the protocol method functions and the rest of the test body.
+    // Because the variables are thread-local, it is safe to run tests concurrently
+    // so long as they establish correct initial values.
+    // Also, because no atomic is being read or written to by more than one thread,
+    // Ordering::Relaxed is perfectly fine.
+    thread_local! {
+        static ATOMIC: AtomicBool = AtomicBool::new(false);
+    }
+
+    thread_local! {
+        static BOOT_REASON: AtomicU32 = AtomicU32::new(REASON_EMPTY);
+    }
+
+    // This provides reasonable defaults for all tests that need to get slot info.
+    //
+    // SAFETY: checks that `info` is properly aligned and not null.
+    // Caller must make sure `info` points to a valid GblEfiSlotInfo struct.
+    unsafe extern "C" fn get_info(
+        _: *mut GblEfiABSlotProtocol,
+        idx: u8,
+        info: *mut GblEfiSlotInfo,
+    ) -> EfiStatus {
+        // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+        if !info.is_null() && (info as usize) % align_of::<GblEfiSlotInfo>() == 0 && idx < 3 {
+            let slot_info = GblEfiSlotInfo {
+                suffix: ('a' as u8 + idx).into(),
+                unbootable_reason: 0,
+                priority: idx + 1,
+                tries: idx,
+                successful: 2 & idx,
+            };
+            unsafe { *info = slot_info };
+            EFI_STATUS_SUCCESS
+        } else {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+    }
+
+    extern "C" fn flush(_: *mut GblEfiABSlotProtocol) -> EfiStatus {
+        ATOMIC.with(|a| a.store(true, Ordering::Relaxed));
+        EFI_STATUS_SUCCESS
+    }
+
+    struct TestGblOps<'a> {
+        manager: ABManager<'a>,
+    }
+
+    impl<'a> TestGblOps<'a> {
+        fn new(protocol: Protocol<'a, ab_slot::GblSlotProtocol>) -> Self {
+            Self { manager: ABManager::new_without_token(protocol) }
+        }
+    }
+
+    impl<'a> GblOps<'a> for TestGblOps<'_>
+    where
+        Self: 'a,
+    {
+        fn console_out(&mut self) -> Option<&mut dyn Write> {
+            unimplemented!();
+        }
+
+        fn should_stop_in_fastboot(&mut self) -> Result<bool> {
+            unimplemented!();
+        }
+
+        fn preboot(&mut self, _: BootImages) -> Result<()> {
+            unimplemented!();
+        }
+
+        fn partitions(&self) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>]> {
+            unimplemented!();
+        }
+
+        fn zircon_add_device_zbi_items(&mut self, _: &mut ZbiContainer<&mut [u8]>) -> Result<()> {
+            unimplemented!();
+        }
+
+        fn do_fastboot<B: gbl_storage::AsBlockDevice>(&self, _: &mut Cursor<B>) -> GblResult<()> {
+            unimplemented!();
+        }
+
+        fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+            &'b mut self,
+            block_dev: &'b mut B,
+            boot_token: BootToken,
+        ) -> GblResult<Cursor<'b, B>> {
+            self.manager.boot_token = Some(boot_token);
+            Ok(Cursor { ctx: &mut self.manager, block_dev })
+        }
+
+        fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
+            unimplemented!();
+        }
+
+        fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
+            unimplemented!();
+        }
+
+        fn avb_write_rollback_index(
+            &mut self,
+            _rollback_index_location: usize,
+            _index: u64,
+        ) -> AvbIoResult<()> {
+            unimplemented!();
+        }
+
+        fn avb_cert_read_permanent_attributes(
+            &mut self,
+            _attributes: &mut CertPermanentAttributes,
+        ) -> AvbIoResult<()> {
+            unimplemented!();
+        }
+
+        fn avb_cert_read_permanent_attributes_hash(
+            &mut self,
+        ) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
+            unimplemented!();
+        }
+
+        fn get_image_buffer<'c>(
+            &mut self,
+            _image_name: &str,
+            _size: NonZeroUsize,
+        ) -> GblResult<ImageBuffer<'c>> {
+            unimplemented!();
+        }
+
+        fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
+            unimplemented!();
+        }
+    }
+
+    #[test]
+    fn test_manager_flush_on_close() {
+        ATOMIC.with(|a| a.store(false, Ordering::Relaxed));
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol { flush: Some(flush), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+
+            {
+                let mut block_device: TestBlockDevice = Default::default();
+                let mut test_ops = TestGblOps::new(protocol);
+                let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+                let _ = gbl.load_slot_interface(&mut block_device).unwrap();
+            }
+        });
+        assert!(ATOMIC.with(|a| a.load(Ordering::Relaxed)));
+    }
+
+    #[test]
+    fn test_iterator() {
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                get_slot_info: Some(get_info),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+
+            let slots: Vec<Slot> = cursor.ctx.slots_iter().collect();
+            assert_eq!(
+                slots,
+                vec![
+                    Slot {
+                        suffix: 'a'.into(),
+                        priority: 1usize.into(),
+                        bootability: Bootability::Unbootable(UnbootableReason::Unknown),
+                    },
+                    Slot {
+                        suffix: 'b'.into(),
+                        priority: 2usize.into(),
+                        bootability: Bootability::Retriable(1usize.into()),
+                    },
+                    Slot {
+                        suffix: 'c'.into(),
+                        priority: 3usize.into(),
+                        bootability: Bootability::Successful,
+                    }
+                ]
+            )
+        });
+    }
+
+    #[test]
+    fn test_active_slot() {
+        // SAFETY: verfies that `info` properly aligned and not null.
+        // It is the callers responsibility to make sure
+        // that `info` points to a valid GblEfiSlotInfo.
+        unsafe extern "C" fn get_current_slot(
+            _: *mut GblEfiABSlotProtocol,
+            info: *mut GblEfiSlotInfo,
+        ) -> EfiStatus {
+            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+            if info.is_null() || (info as usize) % align_of::<GblEfiSlotInfo>() != 0 {
+                return EFI_STATUS_INVALID_PARAMETER;
+            }
+            let slot_info = GblEfiSlotInfo {
+                suffix: 'a' as u32,
+                unbootable_reason: 0,
+                priority: 7,
+                tries: 15,
+                successful: 1,
+            };
+
+            unsafe { *info = slot_info };
+            EFI_STATUS_SUCCESS
+        }
+
+        // SAFETY: verifies that `reason` and `subreason_size` are aligned and not null.
+        // It is the caller's responsibility to make sure that `reason`
+        // and `subreason_size` point to valid output parameters.
+        unsafe extern "C" fn get_boot_reason(
+            _: *mut GblEfiABSlotProtocol,
+            reason: *mut u32,
+            subreason_size: *mut usize,
+            _subreason: *mut u8,
+        ) -> EfiStatus {
+            if reason.is_null()
+                || subreason_size.is_null()
+            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+                || (reason as usize) % align_of::<u32>() != 0
+                || (subreason_size as usize) % align_of::<usize>() != 0
+            {
+                return EFI_STATUS_INVALID_PARAMETER;
+            }
+
+            unsafe {
+                *reason = BOOT_REASON.with(|r| r.load(Ordering::Relaxed));
+                *subreason_size = 0;
+            }
+            EFI_STATUS_SUCCESS
+        }
+
+        BOOT_REASON.with(|r| r.store(REASON_EMPTY, Ordering::Relaxed));
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                get_current_slot: Some(get_current_slot),
+                get_boot_reason: Some(get_boot_reason),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+
+            let slot = Slot {
+                suffix: 'a'.into(),
+                priority: 7usize.into(),
+                bootability: Bootability::Successful,
+            };
+            assert_eq!(cursor.ctx.get_boot_target().unwrap(), BootTarget::NormalBoot(slot));
+            assert_eq!(cursor.ctx.get_slot_last_set_active().unwrap(), slot);
+
+            BOOT_REASON.with(|r| r.store(REASON_RECOVERY, Ordering::Relaxed));
+
+            assert_eq!(
+                cursor.ctx.get_boot_target().unwrap(),
+                BootTarget::Recovery(RecoveryTarget::Slotted(slot))
+            );
+        });
+    }
+
+    #[test]
+    fn test_mark_boot_attempt() {
+        extern "C" fn mark_boot_attempt(_: *mut GblEfiABSlotProtocol) -> EfiStatus {
+            ATOMIC.with(|a| a.store(true, Ordering::Relaxed));
+            EFI_STATUS_SUCCESS
+        }
+
+        ATOMIC.with(|a| a.store(false, Ordering::Relaxed));
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                mark_boot_attempt: Some(mark_boot_attempt),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            assert!(cursor.ctx.mark_boot_attempt().is_ok());
+            assert!(ATOMIC.with(|a| a.load(Ordering::Relaxed)));
+
+            assert_eq!(cursor.ctx.mark_boot_attempt(), Err(Error::OperationProhibited));
+        });
+    }
+
+    #[test]
+    fn test_get_max_retries() {
+        // SAFETY: verifies that `meta` is properly aligned and not null.
+        // It is the caller's responsibility to make sure that `meta` points to
+        // a valid GblEfiSlotMetadataBlock.
+        unsafe extern "C" fn load_boot_data(
+            _: *mut GblEfiABSlotProtocol,
+            meta: *mut GblEfiSlotMetadataBlock,
+        ) -> EfiStatus {
+            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+            if meta.is_null() || (meta as usize) % align_of::<GblEfiSlotMetadataBlock>() != 0 {
+                return EFI_STATUS_INVALID_PARAMETER;
+            }
+
+            let meta_block = GblEfiSlotMetadataBlock {
+                unbootable_metadata: 1,
+                max_retries: 66,
+                slot_count: 32, // why not?
+                merge_status: 0,
+            };
+
+            unsafe { *meta = meta_block };
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                load_boot_data: Some(load_boot_data),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            assert_eq!(cursor.ctx.get_max_retries().unwrap(), 66usize.into());
+        });
+    }
+
+    #[test]
+    fn test_set_active_slot() {
+        extern "C" fn set_active_slot(_: *mut GblEfiABSlotProtocol, idx: u8) -> EfiStatus {
+            // This is deliberate: we want to make sure that other logic catches
+            // 'no such slot' first but we also want to verify that errors propagate.
+            if idx != 2 {
+                EFI_STATUS_SUCCESS
+            } else {
+                EFI_STATUS_INVALID_PARAMETER
+            }
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                get_slot_info: Some(get_info),
+                set_active_slot: Some(set_active_slot),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+
+            assert_eq!(cursor.ctx.set_active_slot('b'.into()), Ok(()));
+            assert_eq!(cursor.ctx.set_active_slot('c'.into()), Err(Error::Other(None)));
+
+            let bad_suffix = '$'.into();
+            assert_eq!(cursor.ctx.set_active_slot(bad_suffix), Err(Error::InvalidInput));
+        });
+    }
+
+    #[test]
+    fn test_set_slot_unbootable() {
+        extern "C" fn set_slot_unbootable(
+            _: *mut GblEfiABSlotProtocol,
+            idx: u8,
+            _: u32,
+        ) -> EfiStatus {
+            // Same thing here as with set_active_slot.
+            // We want to make sure that iteration over the slots
+            // catches invalid suffixes, but we also want to make sure
+            // that errors from the protocol percolate up.
+            if idx == 0 {
+                EFI_STATUS_SUCCESS
+            } else {
+                EFI_STATUS_INVALID_PARAMETER
+            }
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                get_slot_info: Some(get_info),
+                set_slot_unbootable: Some(set_slot_unbootable),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+
+            assert_eq!(
+                cursor.ctx.set_slot_unbootable('a'.into(), UnbootableReason::SystemUpdate),
+                Ok(())
+            );
+
+            assert_eq!(
+                cursor.ctx.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested),
+                Err(Error::InvalidInput)
+            );
+        });
+    }
+
+    #[test]
+    fn test_oneshot() {
+        // SAFETY: checks that `reason` is not null and is properly aligned.
+        // Caller must make sure reason points to a valid u32.
+        unsafe extern "C" fn get_boot_reason(
+            _: *mut GblEfiABSlotProtocol,
+            reason: *mut u32,
+            _: *mut usize,
+            _: *mut u8,
+        ) -> EfiStatus {
+            // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+            if reason.is_null() || (reason as usize) % align_of::<u32>() != 0 {
+                return EFI_STATUS_INVALID_PARAMETER;
+            }
+
+            unsafe { *reason = BOOT_REASON.with(|r| r.load(Ordering::Relaxed)) };
+
+            EFI_STATUS_SUCCESS
+        }
+
+        extern "C" fn set_boot_reason(
+            _: *mut GblEfiABSlotProtocol,
+            reason: u32,
+            _: usize,
+            _: *const u8,
+        ) -> EfiStatus {
+            BOOT_REASON.with(|r| r.store(reason, Ordering::Relaxed));
+            EFI_STATUS_SUCCESS
+        }
+
+        BOOT_REASON.with(|r| r.store(REASON_EMPTY, Ordering::Relaxed));
+        run_test(|image_handle, systab_ptr| {
+            let mut ab = GblEfiABSlotProtocol {
+                get_boot_reason: Some(get_boot_reason),
+                set_boot_reason: Some(set_boot_reason),
+                flush: Some(flush),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
+            let mut block_device: TestBlockDevice = Default::default();
+            let mut test_ops = TestGblOps::new(protocol);
+            let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
+            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+
+            assert_eq!(cursor.ctx.get_oneshot_status(), None);
+            assert_eq!(
+                cursor.ctx.set_oneshot_status(OneShot::Continue(RecoveryTarget::Dedicated)),
+                Err(Error::OperationProhibited)
+            );
+            assert_eq!(cursor.ctx.set_oneshot_status(OneShot::Bootloader), Ok(()));
+            assert_eq!(cursor.ctx.get_oneshot_status(), Some(OneShot::Bootloader));
+
+            cursor.ctx.clear_oneshot_status();
+            assert_eq!(cursor.ctx.get_oneshot_status(), None);
+
+            BOOT_REASON.with(|r| r.store(REASON_WATCHDOG, Ordering::Relaxed));
+            assert_eq!(cursor.ctx.get_oneshot_status(), None);
+            cursor.ctx.clear_oneshot_status();
+            assert_eq!(BOOT_REASON.with(|r| r.load(Ordering::Relaxed)), REASON_WATCHDOG);
+        });
+    }
+}
diff --git a/gbl/libefi/src/allocation.rs b/gbl/libefi/src/allocation.rs
index fb3aa15..a0be720 100644
--- a/gbl/libefi/src/allocation.rs
+++ b/gbl/libefi/src/allocation.rs
@@ -12,21 +12,42 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{EFI_MEMORY_TYPE_LOADER_DATA, EFI_STATUS_ALREADY_STARTED};
-use crate::{EfiEntry, EfiResult};
+use crate::EfiEntry;
+use efi_types::EFI_MEMORY_TYPE_LOADER_DATA;
 
 use core::alloc::{GlobalAlloc, Layout};
+use core::mem::size_of_val;
 use core::ptr::null_mut;
+use liberror::{Error, Result};
+use safemath::SafeNum;
 
-/// Implement a global allocator using `EFI_BOOT_SERVICES.AllocatePool()/FreePool()`
+/// Implements a global allocator using `EFI_BOOT_SERVICES.AllocatePool()/FreePool()`
+///
+/// To use, add this exact declaration to the application code:
+///
+/// ```
+/// #[no_mangle]
+/// #[global_allocator]
+/// static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::Uninitialized;
+/// ```
+///
+/// This is only useful for real UEFI applications; attempting to install the `EFI_GLOBAL_ALLOCATOR`
+/// for host-side unit tests will cause the test to panic immediately.
 pub enum EfiAllocator {
+    /// Initial state, no UEFI entry point has been set, global hooks will not work.
     Uninitialized,
+    /// [EfiEntry] is registered, global hooks are active.
     Initialized(EfiEntry),
+    /// ExitBootServices has been called, global hooks will not work.
     Exited,
 }
 
-#[global_allocator]
-static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::Uninitialized;
+// This is a bit ugly, but we only expect this library to be used by our EFI application so it
+// doesn't need to be super clean or scalable. The user has to declare the global variable
+// exactly as written in the [EfiAllocator] docs for this to link properly.
+extern "Rust" {
+    static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator;
+}
 
 /// An internal API to obtain library internal global EfiEntry.
 pub(crate) fn internal_efi_entry() -> Option<&'static EfiEntry> {
@@ -45,7 +66,7 @@ pub(crate) fn internal_efi_entry() -> Option<&'static EfiEntry> {
 /// This function modifies global variable `EFI_GLOBAL_ALLOCATOR`. It should only be called when
 /// there is no event/notification function that can be triggered or modify it. Otherwise there
 /// is a risk of race condition.
-pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> EfiResult<()> {
+pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> Result<()> {
     // SAFETY: See SAFETY of `internal_efi_entry()`
     unsafe {
         match EFI_GLOBAL_ALLOCATOR {
@@ -53,7 +74,7 @@ pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> EfiResult<()>
                 EFI_GLOBAL_ALLOCATOR = EfiAllocator::Initialized(efi_entry);
                 Ok(())
             }
-            _ => Err(EFI_STATUS_ALREADY_STARTED.into()),
+            _ => Err(Error::AlreadyStarted),
         }
     }
 }
@@ -109,20 +130,73 @@ impl EfiAllocator {
     }
 }
 
+// Alignment guaranteed by EFI AllocatePoll()
+const EFI_ALLOCATE_POOL_ALIGNMENT: usize = 8;
+
 unsafe impl GlobalAlloc for EfiAllocator {
     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
-        let size = layout.size();
-        let align = layout.align();
-        // TODO(300168989): `EFI_BOOT_SERVICES.AllocatePool()` is only 8-byte aligned. Add support
-        // for arbitrary alignment.
-        // `AllocatePool()` can be slow for allocating large buffers. In this case,
-        // `AllocatePages()` is recommended.
-        assert_eq!(8usize.checked_rem(align).unwrap(), 0);
-        self.allocate(size)
+        (|| -> Result<*mut u8> {
+            let align = layout.align();
+
+            // EFI AllocatePoll() must be at 8-bytes aligned so we can just use returned pointer.
+            if align <= EFI_ALLOCATE_POOL_ALIGNMENT {
+                let ptr = self.allocate(layout.size());
+                assert_eq!(ptr as usize % EFI_ALLOCATE_POOL_ALIGNMENT, 0);
+                return Ok(ptr);
+            }
+
+            // If requested alignment is > EFI_ALLOCATE_POOL_ALIGNMENT then make sure to allocate
+            // bigger buffer and adjust ptr to be aligned.
+            let mut offset: usize = 0usize;
+            let extra_size = SafeNum::from(align) + size_of_val(&offset);
+            let size = SafeNum::from(layout.size()) + extra_size;
+
+            // TODO(300168989):
+            // `AllocatePool()` can be slow for allocating large buffers. In this case,
+            // `AllocatePages()` is recommended.
+            let unaligned_ptr = self.allocate(size.try_into()?);
+            if unaligned_ptr.is_null() {
+                return Err(Error::Other(Some("Allocation failed")));
+            }
+            offset = align - (unaligned_ptr as usize % align);
+
+            // SAFETY:
+            // - `unaligned_ptr` is guaranteed to point to buffer big enough to contain offset+size
+            // bytes since this is the size passed to `allocate`
+            // - ptr+layout.size() is also pointing to valid buffer since actual allocate size takes
+            // into account additional suffix for usize variable
+            unsafe {
+                let ptr = unaligned_ptr.add(offset);
+                core::slice::from_raw_parts_mut(ptr.add(layout.size()), size_of_val(&offset))
+                    .copy_from_slice(&offset.to_ne_bytes());
+                Ok(ptr)
+            }
+        })()
+        .unwrap_or(null_mut()) as _
     }
 
-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
-        self.deallocate(ptr);
+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
+        // If alignment is EFI_ALLOCATE_POOL_ALIGNMENT or less, then we can just used ptr directly
+        if layout.align() <= EFI_ALLOCATE_POOL_ALIGNMENT {
+            self.deallocate(ptr);
+            return;
+        }
+
+        let mut offset: usize = 0usize;
+        offset = usize::from_ne_bytes(
+            // SAFETY:
+            // * `ptr` is allocated by `alloc` and has enough padding after `ptr`+size to hold
+            // suffix `offset: usize`.
+            // * Alignment of `ptr` is 1 for &[u8]
+            unsafe { core::slice::from_raw_parts(ptr.add(layout.size()), size_of_val(&offset)) }
+                .try_into()
+                .unwrap(),
+        );
+
+        // SAFETY:
+        // (`ptr` - `offset`) must be valid unaligned pointer to buffer allocated by `alloc`
+        let real_start_ptr = unsafe { ptr.sub(offset) };
+        self.deallocate(real_start_ptr);
     }
 }
 
diff --git a/gbl/libefi/src/lib.rs b/gbl/libefi/src/lib.rs
index 3ad68cb..e88e5dd 100644
--- a/gbl/libefi/src/lib.rs
+++ b/gbl/libefi/src/lib.rs
@@ -22,7 +22,7 @@
 //! and prints out the device path, block size and io alignment info for each of them.
 //!
 //! ```
-//! fn main(image: EfiHandle, systab_ptr: *mut EfiSystemTable) -> efi::EfiResult<()> {
+//! fn main(image: EfiHandle, systab_ptr: *mut EfiSystemTable) -> liberror::Result<()> {
 //!     let efi_entry = initialize(image, systab_ptr)?;
 //!     let mut con_out = efi_entry.system_table().con_out()?;
 //!     let boot_services = efi_entry.system_table().boot_services();
@@ -53,77 +53,34 @@
 extern crate alloc;
 use alloc::vec::Vec;
 
-use core::ptr::null_mut;
-use core::slice::from_raw_parts;
-#[cfg(not(test))]
-use core::{fmt::Write, panic::PanicInfo};
-
-use zerocopy::Ref;
-
-#[rustfmt::skip]
-pub mod defs;
-use defs::*;
-
 #[cfg(not(test))]
 mod allocation;
 
 #[cfg(not(test))]
-pub use allocation::{efi_free, efi_malloc};
+pub use allocation::{efi_free, efi_malloc, EfiAllocator};
 
+/// The Android EFI protocol implementation of an A/B slot manager.
+pub mod ab_slots;
 pub mod protocol;
-use protocol::simple_text_output::SimpleTextOutputProtocol;
-use protocol::{Protocol, ProtocolInfo};
-
-mod error {
-    use super::defs::EFI_STATUS_SUCCESS;
-    use super::EfiStatus;
-
-    #[derive(Debug, Copy, Clone, PartialEq)]
-    pub enum ErrorTypes {
-        Unknown,
-        EfiStatusError(EfiStatus),
-    }
-
-    #[derive(Debug, PartialEq)]
-    pub struct EfiError(ErrorTypes);
-
-    impl EfiError {
-        pub fn err(&self) -> ErrorTypes {
-            self.0
-        }
-
-        /// Checks if the error is a particular EFI error.
-        pub fn is_efi_err(&self, code: EfiStatus) -> bool {
-            *self == code.into()
-        }
-    }
+pub mod utils;
 
-    impl From<EfiStatus> for EfiError {
-        fn from(efi_status: EfiStatus) -> EfiError {
-            EfiError(match efi_status {
-                EFI_STATUS_SUCCESS => ErrorTypes::Unknown,
-                _ => ErrorTypes::EfiStatusError(
-                    // Remove the highest bit in the error code so that it's eaiser to interpret
-                    // when printing.
-                    efi_status & !(1 << (core::mem::size_of::<EfiStatus>() * 8 - 1)),
-                ),
-            })
-        }
-    }
-}
-
-pub use error::*;
-
-/// Result type for this library.
-pub type EfiResult<T> = core::result::Result<T, EfiError>;
+#[cfg(not(test))]
+use core::{fmt::Write, panic::PanicInfo};
 
-/// Helper method to convert an EFI status code to EfiResult.
-fn map_efi_err(code: EfiStatus) -> EfiResult<()> {
-    match code {
-        EFI_STATUS_SUCCESS => Ok(()),
-        _ => Err(code.into()),
-    }
-}
+use core::{marker::PhantomData, ptr::null_mut, slice::from_raw_parts};
+use efi_types::{
+    EfiBootService, EfiConfigurationTable, EfiEvent, EfiGuid, EfiHandle, EfiMemoryDescriptor,
+    EfiMemoryType, EfiRuntimeService, EfiSystemTable, EfiTimerDelay, EFI_EVENT_TYPE_NOTIFY_SIGNAL,
+    EFI_EVENT_TYPE_NOTIFY_WAIT, EFI_EVENT_TYPE_RUNTIME, EFI_EVENT_TYPE_SIGNAL_EXIT_BOOT_SERVICES,
+    EFI_EVENT_TYPE_SIGNAL_VIRTUAL_ADDRESS_CHANGE, EFI_EVENT_TYPE_TIMER,
+    EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL, EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL,
+};
+use liberror::{Error, Result};
+use protocol::{
+    simple_text_output::SimpleTextOutputProtocol,
+    {Protocol, ProtocolInfo},
+};
+use zerocopy::Ref;
 
 /// `EfiEntry` stores the EFI system table pointer and image handle passed from the entry point.
 /// It's the root data structure that derives all other wrapper APIs and structures.
@@ -145,6 +102,16 @@ impl EfiEntry {
     }
 }
 
+/// The vendor GUID for UEFI variables defined by GBL.
+pub const GBL_EFI_VENDOR_GUID: EfiGuid =
+    EfiGuid::new(0x5a6d92f3, 0xa2d0, 0x4083, [0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]);
+
+/// The name of the UEFI variable that GBL defines to determine whether to boot Fuchsia.
+/// The value of the variable is ignored: if the variable is present,
+/// it indicates that the bootloader should attempt to boot a Fuchsia target.
+/// This may include reinitializing GPT partitions and partition contents.
+pub const GBL_EFI_OS_BOOT_TARGET_VARNAME: &str = "gbl_os_boot_fuchsia";
+
 /// Creates an `EfiEntry` and initialize EFI global allocator.
 ///
 /// # Safety
@@ -156,7 +123,7 @@ impl EfiEntry {
 pub unsafe fn initialize(
     image_handle: EfiHandle,
     systab_ptr: *const EfiSystemTable,
-) -> EfiResult<EfiEntry> {
+) -> Result<EfiEntry> {
     let efi_entry = EfiEntry { image_handle, systab_ptr };
     // SAFETY: By safety requirement of this function, `initialize` is only called once upon
     // entering EFI application, where there should be no event notify function that can be
@@ -187,9 +154,9 @@ pub fn aligned_subslice(buffer: &mut [u8], alignment: usize) -> Option<&mut [u8]
 ///
 /// Existing heap allocated memories will maintain their states. All system memory including them
 /// will be under onwership of the subsequent OS or OS loader code.
-pub fn exit_boot_services(entry: EfiEntry, mmap_buffer: &mut [u8]) -> EfiResult<EfiMemoryMap> {
+pub fn exit_boot_services(entry: EfiEntry, mmap_buffer: &mut [u8]) -> Result<EfiMemoryMap> {
     let aligned = aligned_subslice(mmap_buffer, core::mem::align_of::<EfiMemoryDescriptor>())
-        .ok_or_else::<EfiError, _>(|| EFI_STATUS_BUFFER_TOO_SMALL.into())?;
+        .ok_or(Error::BufferTooSmall(None))?;
 
     let res = entry.system_table().boot_services().get_memory_map(aligned)?;
     entry.system_table().boot_services().exit_boot_services(&res)?;
@@ -229,7 +196,7 @@ impl<'a> SystemTable<'a> {
     }
 
     /// Gets the `EFI_SYSTEM_TABLE.ConOut` field.
-    pub fn con_out(&self) -> EfiResult<Protocol<'a, SimpleTextOutputProtocol>> {
+    pub fn con_out(&self) -> Result<Protocol<'a, SimpleTextOutputProtocol>> {
         // SAFETY: `EFI_SYSTEM_TABLE.ConOut` is a pointer to EfiSimpleTextOutputProtocol structure
         // by definition. It lives until ExitBootService and thus as long as `self.efi_entry` or,
         // 'a
@@ -272,7 +239,7 @@ impl<'a> BootServices<'a> {
         &self,
         pool_type: EfiMemoryType,
         size: usize,
-    ) -> EfiResult<*mut core::ffi::c_void> {
+    ) -> Result<*mut core::ffi::c_void> {
         let mut out: *mut core::ffi::c_void = null_mut();
         // SAFETY: `EFI_BOOT_SERVICES` method call.
         unsafe {
@@ -282,16 +249,13 @@ impl<'a> BootServices<'a> {
     }
 
     /// Wrapper of `EFI_BOOT_SERVICES.FreePool()`.
-    fn free_pool(&self, buf: *mut core::ffi::c_void) -> EfiResult<()> {
+    fn free_pool(&self, buf: *mut core::ffi::c_void) -> Result<()> {
         // SAFETY: `EFI_BOOT_SERVICES` method call.
         unsafe { efi_call!(self.boot_services.free_pool, buf) }
     }
 
     /// Wrapper of `EFI_BOOT_SERVICES.OpenProtocol()`.
-    pub fn open_protocol<T: ProtocolInfo>(
-        &self,
-        handle: DeviceHandle,
-    ) -> EfiResult<Protocol<'a, T>> {
+    pub fn open_protocol<T: ProtocolInfo>(&self, handle: DeviceHandle) -> Result<Protocol<'a, T>> {
         let mut out_handle: EfiHandle = null_mut();
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe {
@@ -312,7 +276,8 @@ impl<'a> BootServices<'a> {
     }
 
     /// Wrapper of `EFI_BOOT_SERVICES.CloseProtocol()`.
-    fn close_protocol<T: ProtocolInfo>(&self, handle: DeviceHandle) -> EfiResult<()> {
+    #[allow(dead_code)]
+    fn close_protocol<T: ProtocolInfo>(&self, handle: DeviceHandle) -> Result<()> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe {
             efi_call!(
@@ -327,9 +292,7 @@ impl<'a> BootServices<'a> {
 
     /// Call `EFI_BOOT_SERVICES.LocateHandleBuffer()` with fixed
     /// `EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL` and without search key.
-    pub fn locate_handle_buffer_by_protocol<T: ProtocolInfo>(
-        &self,
-    ) -> EfiResult<LocatedHandles<'a>> {
+    pub fn locate_handle_buffer_by_protocol<T: ProtocolInfo>(&self) -> Result<LocatedHandles<'a>> {
         let mut num_handles: usize = 0;
         let mut handles: *mut EfiHandle = null_mut();
         // SAFETY: EFI_BOOT_SERVICES method call.
@@ -350,19 +313,19 @@ impl<'a> BootServices<'a> {
     }
 
     /// Search and open the first found target EFI protocol.
-    pub fn find_first_and_open<T: ProtocolInfo>(&self) -> EfiResult<Protocol<'a, T>> {
+    pub fn find_first_and_open<T: ProtocolInfo>(&self) -> Result<Protocol<'a, T>> {
         // We don't use EFI_BOOT_SERVICES.LocateProtocol() because it doesn't give device handle
         // which is required to close the protocol.
         let handle = *self
             .locate_handle_buffer_by_protocol::<T>()?
             .handles()
             .first()
-            .ok_or::<EfiError>(EFI_STATUS_NOT_FOUND.into())?;
+            .ok_or(Error::NotFound)?;
         self.open_protocol::<T>(handle)
     }
 
     /// Wrapper of `EFI_BOOT_SERVICE.GetMemoryMap()`.
-    pub fn get_memory_map<'b>(&self, mmap_buffer: &'b mut [u8]) -> EfiResult<EfiMemoryMap<'b>> {
+    pub fn get_memory_map<'b>(&self, mmap_buffer: &'b mut [u8]) -> Result<EfiMemoryMap<'b>> {
         let mut mmap_size = mmap_buffer.len();
         let mut map_key: usize = 0;
         let mut descriptor_size: usize = 0;
@@ -387,7 +350,7 @@ impl<'a> BootServices<'a> {
     }
 
     /// Wrapper of `EFI_BOOT_SERVICE.ExitBootServices()`.
-    fn exit_boot_services<'b>(&self, mmap: &'b EfiMemoryMap<'b>) -> EfiResult<()> {
+    fn exit_boot_services<'b>(&self, mmap: &'b EfiMemoryMap<'b>) -> Result<()> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe {
             efi_call!(
@@ -399,30 +362,76 @@ impl<'a> BootServices<'a> {
     }
 
     /// Wrapper of `EFI_BOOT_SERVICE.Stall()`.
-    pub fn stall(&self, micro: usize) -> EfiResult<()> {
+    pub fn stall(&self, micro: usize) -> Result<()> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe { efi_call!(self.boot_services.stall, micro) }
     }
 
-    /// Wrapper of `EFI_BOOT_SERVICE.CreateEvent()`.
+    /// Wraps `EFI_BOOT_SERVICE.CreateEvent()`.
     ///
-    /// Args:
+    /// This function creates an event without a notification callback function; to create an event
+    /// with a notification, see [create_event_with_notification].
     ///
-    ///  * `event_type`: The EFI event type.
-    ///  * `cb`: An optional `&'e mut EventNotify`, which implements the event
-    ///          notification function and provides the task level priority setting.
-    pub fn create_event<'n, 'e: 'n>(
+    /// # Arguments
+    /// * `event_type`: The EFI event type.
+    pub fn create_event(&self, event_type: EventType) -> Result<Event<'a, 'static>> {
+        let mut efi_event: EfiEvent = null_mut();
+        // SAFETY:
+        // * all parameters obey the `CreateEvent()` spec
+        // * on success we take ownership of the provided `efi_event`
+        unsafe {
+            efi_call!(
+                self.boot_services.create_event,
+                event_type as u32,
+                0,
+                None,
+                null_mut(),
+                &mut efi_event
+            )?;
+        }
+        Ok(Event::new(self.efi_entry, efi_event, None))
+    }
+
+    /// Wraps `EFI_BOOT_SERVICE.CreateEvent()`.
+    ///
+    /// This function creates an event with a notification callback function.
+    ///
+    /// Unlike [create_event], this function is unsafe because the callback will be executed
+    /// concurrently with the main application code at a higher interrupt level, and there are
+    /// a few cases where this can lead to races.
+    ///
+    /// # Arguments
+    /// * `event_type`: The EFI event type.
+    /// * `cb`: An [EventNotify] which implements the event notification function and provides the
+    ///         task level priority setting.
+    ///
+    /// # Safety
+    /// Most of the safety conditions are enforced at compile-time by the [Sync] requirement on
+    /// [EventNotifyCallback] - this ensures that e.g. callers cannot capture their raw [EfiEntry]
+    /// in a callback, but will need to wrap it in a [Sync] type which will ensure safe sharing
+    /// between the main application and the callback.
+    ///
+    /// The exception is the global allocation and panic hooks, which use a separate global
+    /// [EfiEntry] that is not synchronized outside the main application. The caller must ensure
+    /// that the main application code is not using its [EfiEntry] while a notification callback
+    /// is trying to concurrently use the global [EfiEntry].
+    ///
+    /// The easiest way to accomplish this is to write notifications callbacks that:
+    /// * do not allocate or deallocate heap memory
+    /// * do not panic
+    /// Callbacks following these guidelines are safe as they do not use the global [EfiEntry].
+    ///
+    /// If that is not possible, then the caller must ensure that nothing else makes any calls into
+    /// UEFI while the returned [Event] is alive; the callback function must have exclusive access
+    /// to the UEFI APIs so it can use the globals without triggering UEFI reentry.
+    ///
+    /// In unittests there is no global [EfiEntry] so this is always safe.
+    pub unsafe fn create_event_with_notification<'e>(
         &self,
         event_type: EventType,
-        mut cb: Option<&'n mut EventNotify<'e>>,
-    ) -> EfiResult<Event<'a, 'n>> {
+        notify: &'e mut EventNotify,
+    ) -> Result<Event<'a, 'e>> {
         let mut efi_event: EfiEvent = null_mut();
-        let (tpl, c_callback, cookie): (EfiTpl, EfiEventNotify, *mut core::ffi::c_void) = match cb {
-            Some(ref mut event_notify) => {
-                (event_notify.tpl as _, Some(efi_event_cb), *event_notify as *mut _ as _)
-            }
-            None => (0, None, null_mut()),
-        };
         // SAFETY:
         // Pointers passed are output/callback context pointers which will not be retained by the
         // callback (`fn efi_event_cb()`).
@@ -433,21 +442,17 @@ impl<'a> BootServices<'a> {
             efi_call!(
                 self.boot_services.create_event,
                 event_type as u32,
-                tpl as usize,
-                c_callback,
-                cookie,
+                notify.tpl as usize,
+                Some(efi_event_cb),
+                notify as *mut _ as *mut _,
                 &mut efi_event
             )?;
         }
-        Ok(Event::new(
-            Some(self.efi_entry),
-            efi_event,
-            cb.map::<&'n mut dyn FnMut(EfiEvent), _>(|v| v.cb),
-        ))
+        Ok(Event::new(self.efi_entry, efi_event, Some(notify.cb)))
     }
 
     /// Wrapper of `EFI_BOOT_SERVICE.CloseEvent()`.
-    fn close_event(&self, event: &Event) -> EfiResult<()> {
+    fn close_event(&self, event: &Event) -> Result<()> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe { efi_call!(self.boot_services.close_event, event.efi_event) }
     }
@@ -455,10 +460,10 @@ impl<'a> BootServices<'a> {
     /// Wrapper of `EFI_BOOT_SERVICE.CheckEvent()`.
     ///
     /// On success, returns true if the event is signaled, false if not.
-    pub fn check_event(&self, event: &Event) -> EfiResult<bool> {
+    pub fn check_event(&self, event: &Event) -> Result<bool> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         match unsafe { efi_call!(self.boot_services.check_event, event.efi_event) } {
-            Err(e) if e != EFI_STATUS_NOT_READY.into() => Err(e),
+            Err(e) if e != Error::NotReady => Err(e),
             Ok(()) => Ok(true),
             _ => Ok(false),
         }
@@ -470,7 +475,7 @@ impl<'a> BootServices<'a> {
         event: &Event,
         delay_type: EfiTimerDelay,
         trigger_time: u64,
-    ) -> EfiResult<()> {
+    ) -> Result<()> {
         // SAFETY: EFI_BOOT_SERVICES method call.
         unsafe {
             efi_call!(self.boot_services.set_timer, event.efi_event, delay_type, trigger_time)
@@ -486,7 +491,7 @@ pub struct RuntimeServices<'a> {
 
 impl<'a> RuntimeServices<'a> {
     /// Wrapper of `EFI_RUNTIME_SERVICES.GetVariable()`.
-    pub fn get_variable(&self, guid: &EfiGuid, name: &str, out: &mut [u8]) -> EfiResult<usize> {
+    pub fn get_variable(&self, guid: &EfiGuid, name: &str, out: &mut [u8]) -> Result<usize> {
         let mut size = out.len();
 
         let mut name_utf16: Vec<u16> = name.encode_utf16().collect();
@@ -495,23 +500,44 @@ impl<'a> RuntimeServices<'a> {
         // SAFETY:
         // * `&mut size` and `&mut out` are input/output params only and will not be retained
         // * `&mut size` and `&mut out` are valid pointers and outlive the call
-        match unsafe {
+        unsafe {
             efi_call!(
+                @bufsize size,
                 self.runtime_services.get_variable,
                 name_utf16.as_ptr(),
                 guid,
                 null_mut(),
                 &mut size,
                 out.as_mut_ptr() as *mut core::ffi::c_void
+            )?;
+        }
+        Ok(size)
+    }
+
+    /// Wrapper of `EFI_RUNTIME_SERVICES.SetVariable()`.
+    pub fn set_variable(&self, guid: &EfiGuid, name: &str, data: &[u8]) -> Result<()> {
+        let mut name_utf16: Vec<u16> = name.encode_utf16().collect();
+        name_utf16.push(0); // null-terminator
+
+        // SAFETY:
+        // * `data.as_mut_ptr()` and `name_utf16.as_ptr()` are valid pointers,
+        // * outlive the call, and are not retained.
+        unsafe {
+            efi_call!(
+                self.runtime_services.set_variable,
+                name_utf16.as_ptr(),
+                guid,
+                0,
+                data.len(),
+                data.as_ptr() as *const core::ffi::c_void
             )
-        } {
-            Ok(()) => Ok(size),
-            Err(e) => Err(e),
         }
     }
 }
 
-/// EFI Event type to pass to BootServicess::create_event;
+/// EFI Event type to pass to BootServicess::create_event.
+/// See UEFI documentation for details.
+#[allow(missing_docs)]
 #[repr(u32)]
 pub enum EventType {
     Timer = EFI_EVENT_TYPE_TIMER,
@@ -526,6 +552,8 @@ pub enum EventType {
 }
 
 /// EFI task level priority setting for event notify function.
+/// See UEFI documentation for details.
+#[allow(missing_docs)]
 #[repr(usize)]
 #[derive(Copy, Clone)]
 pub enum Tpl {
@@ -535,42 +563,63 @@ pub enum Tpl {
     HighLevel = 31,
 }
 
+/// Event notification callback function.
+///
+/// The callback function itself takes the [EfiEvent] as an argument and has no return value.
+/// This type is a mutable borrow of a closure to ensure that it will outlive the [EfiEvent] and
+/// that the callback has exclusive access to it.
+///
+/// Additionally, the function must be [Sync] because it will be run concurrently to the main app
+/// code at a higher interrupt level. One consequence of this is that we cannot capture an
+/// [EfiEntry] or any related object in the closure, as they are not [Sync]. This is intentional;
+/// in general UEFI APIs are not reentrant except in very limited ways, and we could trigger
+/// undefined behavior if we try to call into UEFI while the main application code is also in the
+/// middle of a UEFI call. Instead, the notification should signal the main app code to make any
+/// necessary UEFI calls once it regains control.
+pub type EventNotifyCallback<'a> = &'a mut (dyn FnMut(EfiEvent) + Sync);
+
 /// `EventNotify` contains the task level priority setting and a mutable reference to a
 /// closure for the callback. It is passed as the context pointer to low level EFI event
 /// notification function entry (`unsafe extern "C" fn efi_event_cb(...)`).
 pub struct EventNotify<'e> {
     tpl: Tpl,
-    cb: &'e mut dyn FnMut(EfiEvent),
+    cb: EventNotifyCallback<'e>,
 }
 
 impl<'e> EventNotify<'e> {
-    pub fn new(tpl: Tpl, cb: &'e mut dyn FnMut(EfiEvent)) -> Self {
+    /// Creates a new [EventNotify].
+    pub fn new(tpl: Tpl, cb: EventNotifyCallback<'e>) -> Self {
         Self { tpl, cb }
     }
 }
 
 /// `Event` wraps the raw `EfiEvent` handle and internally enforces a borrow of the registered
-/// callback for the given life time `e. The event is automatically closed when going out of scope.
+/// callback for the given life time `'n`. The event is automatically closed when going out of
+/// scope.
 pub struct Event<'a, 'n> {
     // If `efi_entry` is None, it represents an unowned Event and won't get closed on drop.
     efi_entry: Option<&'a EfiEntry>,
     efi_event: EfiEvent,
-    _cb: Option<&'n mut dyn FnMut(EfiEvent)>,
+    // The actual callback has been passed into UEFI via raw pointer in [create_event], so we
+    // use [PhantomData] to ensure the callback will outlive the event.
+    cb: PhantomData<Option<EventNotifyCallback<'n>>>,
 }
 
 impl<'a, 'n> Event<'a, 'n> {
     /// Creates an instance of owned `Event`. The `Event` is closed when going out of scope.
     fn new(
-        efi_entry: Option<&'a EfiEntry>,
+        efi_entry: &'a EfiEntry,
         efi_event: EfiEvent,
-        _cb: Option<&'n mut dyn FnMut(EfiEvent)>,
+        _cb: Option<EventNotifyCallback<'n>>,
     ) -> Self {
-        Self { efi_entry, efi_event, _cb }
+        Self { efi_entry: Some(efi_entry), efi_event, cb: PhantomData }
     }
 
     /// Creates an  unowned `Event`. The `Event` is not closed when going out of scope.
+    // TODO allow unused?
+    #[allow(dead_code)]
     fn new_unowned(efi_event: EfiEvent) -> Self {
-        Self { efi_entry: None, efi_event: efi_event, _cb: None }
+        Self { efi_entry: None, efi_event: efi_event, cb: PhantomData }
     }
 }
 
@@ -668,6 +717,13 @@ impl<'a: 'b, 'b> IntoIterator for &'b EfiMemoryMap<'a> {
 #[derive(Debug, Copy, Clone, PartialEq)]
 pub struct DeviceHandle(EfiHandle);
 
+impl DeviceHandle {
+    /// Public constructor
+    pub fn new(handle: EfiHandle) -> Self {
+        Self(handle)
+    }
+}
+
 /// `LocatedHandles` holds the array of handles return by
 /// `BootServices::locate_handle_buffer_by_protocol()`.
 pub struct LocatedHandles<'a> {
@@ -711,20 +767,23 @@ macro_rules! efi_print {
     };
 }
 
+/// Similar to [efi_print!], but automatically adds the UEFI newline sequence (`\r\n`).
 #[macro_export]
 macro_rules! efi_println {
-    ( $efi_entry:expr, $( $x:expr ),* ) => {
-        efi_print!($efi_entry, $($x,)*);
-        efi_print!($efi_entry, "\r\n");
+    ( $efi_entry:expr, $( $x:expr ),* $(,)? ) => {
+        {
+            efi_print!($efi_entry, $($x,)*);
+            efi_print!($efi_entry, "\r\n");
+        }
     };
 }
 
 /// Provides a builtin panic handler.
 /// In the long term, to improve flexibility, consider allowing application to install a custom
 /// handler into `EfiEntry` to be called here.
+/// Don't set this as the panic handler so that other crates' tests can depend on libefi.
 #[cfg(not(test))]
-#[panic_handler]
-fn panic(panic: &PanicInfo) -> ! {
+pub fn panic(panic: &PanicInfo) -> ! {
     // If there is a valid internal `efi_entry` from global allocator, print the panic info.
     let entry = allocation::internal_efi_entry();
     if let Some(e) = entry {
@@ -742,13 +801,23 @@ fn panic(panic: &PanicInfo) -> ! {
 mod test {
     use super::*;
     use crate::protocol::block_io::BlockIoProtocol;
-    use std::cell::RefCell;
-    use std::collections::VecDeque;
-    use std::mem::size_of;
-    use std::slice::from_raw_parts_mut;
-
+    use efi_types::{
+        EfiBlockIoProtocol, EfiEventNotify, EfiLocateHandleSearchType, EfiStatus, EfiTpl,
+        EFI_MEMORY_TYPE_LOADER_CODE, EFI_MEMORY_TYPE_LOADER_DATA, EFI_STATUS_NOT_FOUND,
+        EFI_STATUS_NOT_READY, EFI_STATUS_SUCCESS, EFI_STATUS_UNSUPPORTED,
+    };
+    use std::{cell::RefCell, collections::VecDeque, mem::size_of, slice::from_raw_parts_mut};
     use zerocopy::AsBytes;
 
+    /// Helper function to generate a Protocol from an interface type.
+    pub fn generate_protocol<'a, P: ProtocolInfo>(
+        efi_entry: &'a EfiEntry,
+        proto: &'a mut P::InterfaceType,
+    ) -> Protocol<'a, P> {
+        // SAFETY: proto is a valid pointer and lasts at least as long as efi_entry.
+        unsafe { Protocol::<'a, P>::new(DeviceHandle::new(null_mut()), proto, efi_entry) }
+    }
+
     /// A structure to store the traces of arguments/outputs for EFI methods.
     #[derive(Default)]
     pub struct EfiCallTraces {
@@ -814,10 +883,16 @@ mod test {
         assert_eq!(attr, EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL);
         EFI_CALL_TRACES.with(|traces| {
             let trace = &mut traces.borrow_mut().open_protocol_trace;
-            trace.inputs.push_back((DeviceHandle(handle), *protocol_guid, agent_handle));
+            trace.inputs.push_back((
+                DeviceHandle(handle),
+                // SAFETY: function safety docs require valid `protocol_guid`.
+                unsafe { *protocol_guid },
+                agent_handle,
+            ));
 
             let (intf_handle, status) = trace.outputs.pop_front().unwrap();
-            *intf = intf_handle;
+            // SAFETY: function safety docs require valid `intf`.
+            unsafe { *intf = intf_handle };
 
             status
         })
@@ -844,7 +919,8 @@ mod test {
         EFI_CALL_TRACES.with(|traces| {
             traces.borrow_mut().close_protocol_trace.inputs.push_back((
                 DeviceHandle(handle),
-                *protocol_guid,
+                // SAFETY: function safety docs require valid `protocol_guid`.
+                unsafe { *protocol_guid },
                 agent_handle,
             ));
             EFI_STATUS_SUCCESS
@@ -863,8 +939,8 @@ mod test {
     /// Mock of the `EFI_BOOT_SERVICE.LocateHandleBuffer` C API in test environment.
     ///
     /// # Safety
-    ///
-    ///   Caller should guarantee that `num_handles` and `buf` point to valid memory locations.
+    /// Caller should guarantee that `protocol`, `num_handles`, and `buf` point to valid memory
+    /// locations.
     unsafe extern "C" fn locate_handle_buffer(
         search_type: EfiLocateHandleSearchType,
         protocol: *const EfiGuid,
@@ -876,11 +952,14 @@ mod test {
         assert_eq!(search_key, null_mut());
         EFI_CALL_TRACES.with(|traces| {
             let trace = &mut traces.borrow_mut().locate_handle_buffer_trace;
-            trace.inputs.push_back(*protocol);
+            // SAFETY: function safety docs require valid `protocol`.
+            unsafe { trace.inputs.push_back(*protocol) };
 
             let (num, handles) = trace.outputs.pop_front().unwrap();
-            *num_handles = num as usize;
-            *buf = handles as *mut EfiHandle;
+            // SAFETY: function safety docs require valid `num_handles`.
+            unsafe { *num_handles = num as usize };
+            // SAFETY: function safety docs require valid `buf`.
+            unsafe { *buf = handles as *mut EfiHandle };
 
             EFI_STATUS_SUCCESS
         })
@@ -911,8 +990,10 @@ mod test {
         EFI_CALL_TRACES.with(|traces| {
             let trace = &mut traces.borrow_mut().get_memory_map_trace;
             trace.inputs.push_back((unsafe { *memory_map_size }, memory_map));
-            (*map_key, *memory_map_size) = trace.outputs.pop_front().unwrap();
-            *desc_size = size_of::<EfiMemoryDescriptor>();
+            // SAFETY: function safety docs require valid `memory_map_size`and `map_key`.
+            unsafe { (*map_key, *memory_map_size) = trace.outputs.pop_front().unwrap() };
+            // SAFETY: function safety docs require valid `desc_size`.
+            unsafe { *desc_size = size_of::<EfiMemoryDescriptor>() };
             EFI_STATUS_SUCCESS
         })
     }
@@ -957,7 +1038,8 @@ mod test {
         EFI_CALL_TRACES.with(|traces| {
             let trace = &mut traces.borrow_mut().create_event_trace;
             trace.inputs.push_back((type_, notify_tpl, notify_fn, notify_ctx));
-            *event = trace.outputs.pop_front().unwrap();
+            // SAFETY: function safety docs require valid `event`.
+            unsafe { *event = trace.outputs.pop_front().unwrap() };
             EFI_STATUS_SUCCESS
         })
     }
@@ -996,7 +1078,7 @@ mod test {
     /// A test wrapper that sets up a system table, image handle and runs a test function like it
     /// is an EFI application.
     /// TODO(300168989): Investigate using procedural macro to generate test that auto calls this.
-    pub fn run_test(func: fn(EfiHandle, *mut EfiSystemTable) -> ()) {
+    pub fn run_test(func: impl FnOnce(EfiHandle, *mut EfiSystemTable) -> ()) {
         // Reset all traces
         EFI_CALL_TRACES.with(|trace| {
             *trace.borrow_mut() = Default::default();
@@ -1025,8 +1107,33 @@ mod test {
         });
     }
 
+    /// Constructs a mock protocol `P` and run the given callback on it.
+    ///
+    /// This is similar to `run_test()`, but also provides the construction of a single mock
+    /// protocol to reduce boilerplate for tests to check the interface between a C EFI protocol
+    /// struct and our Rust wrappers.
+    ///
+    /// # Arguments
+    /// * `c_interface`: the raw C struct interface implementing the desired protocol.
+    /// * `f`: the callback function to run, given the resulting protocol as an argument.
+    pub fn run_test_with_mock_protocol<P: ProtocolInfo>(
+        mut c_interface: P::InterfaceType,
+        f: impl FnOnce(&Protocol<P>),
+    ) {
+        run_test(|image_handle, systab_ptr| {
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            // SAFETY:
+            // * `c_interface` is a valid C interface for proto `P`
+            // * `c_interface` outlives the created `protocol`
+            let protocol = unsafe {
+                Protocol::new(DeviceHandle::new(null_mut()), &mut c_interface, &efi_entry)
+            };
+            f(&protocol);
+        });
+    }
+
     /// Get the pointer to an object as an EfiHandle type.
-    fn as_efi_handle<T>(val: &mut T) -> EfiHandle {
+    pub fn as_efi_handle<T>(val: &mut T) -> EfiHandle {
         val as *mut T as *mut _
     }
 
@@ -1073,16 +1180,8 @@ mod test {
             }
 
             // Close protocol is called as `protocol` goes out of scope.
-            EFI_CALL_TRACES.with(|trace| {
-                assert_eq!(
-                    trace.borrow_mut().close_protocol_trace.inputs,
-                    [(
-                        DeviceHandle(as_efi_handle(&mut device_handle)),
-                        BlockIoProtocol::GUID,
-                        image_handle
-                    ),]
-                )
-            });
+            EFI_CALL_TRACES
+                .with(|trace| assert_eq!(trace.borrow_mut().close_protocol_trace.inputs, []));
         })
     }
 
@@ -1331,11 +1430,14 @@ mod test {
                 traces.borrow_mut().create_event_trace.outputs.push_back(event);
             });
             {
-                let _ = efi_entry
-                    .system_table()
-                    .boot_services()
-                    .create_event(EventType::Timer, Some(&mut cb))
-                    .unwrap();
+                // SAFETY: event notifications are always safe in unittests.
+                let _ = unsafe {
+                    efi_entry
+                        .system_table()
+                        .boot_services()
+                        .create_event_with_notification(EventType::Timer, &mut cb)
+                }
+                .unwrap();
             }
             let efi_cb: EfiEventNotify = Some(efi_event_cb);
             EFI_CALL_TRACES.with(|traces| {
@@ -1367,7 +1469,7 @@ mod test {
                 let _ = efi_entry
                     .system_table()
                     .boot_services()
-                    .create_event(EventType::Timer, None)
+                    .create_event(EventType::Timer)
                     .unwrap();
             }
             EFI_CALL_TRACES.with(|traces| {
@@ -1390,20 +1492,11 @@ mod test {
                 traces.borrow_mut().check_event_trace.outputs.push_back(EFI_STATUS_NOT_READY);
                 traces.borrow_mut().check_event_trace.outputs.push_back(EFI_STATUS_UNSUPPORTED);
             });
-            let res = efi_entry
-                .system_table()
-                .boot_services()
-                .create_event(EventType::Timer, None)
-                .unwrap();
+            let res =
+                efi_entry.system_table().boot_services().create_event(EventType::Timer).unwrap();
             assert_eq!(efi_entry.system_table().boot_services().check_event(&res), Ok(true));
             assert_eq!(efi_entry.system_table().boot_services().check_event(&res), Ok(false));
             assert!(efi_entry.system_table().boot_services().check_event(&res).is_err());
         });
     }
-
-    #[test]
-    fn test_efi_error() {
-        let res: EfiResult<()> = Err(EFI_STATUS_NOT_FOUND.into());
-        assert_eq!(res.unwrap_err().err(), ErrorTypes::EfiStatusError(14));
-    }
 }
diff --git a/gbl/libefi/src/protocol.rs b/gbl/libefi/src/protocol.rs
index 309d4a7..0422846 100644
--- a/gbl/libefi/src/protocol.rs
+++ b/gbl/libefi/src/protocol.rs
@@ -12,20 +12,29 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! EFI protocol wrappers to provide Rust-safe APIs for usage.
+
 use core::ptr::null_mut;
 
-use crate::defs::*;
-use crate::{DeviceHandle, EfiEntry, EfiResult};
+use crate::{DeviceHandle, EfiEntry};
+use efi_types::*;
 
-pub mod android_boot;
 pub mod block_io;
+pub mod block_io2;
 pub mod device_path;
+pub mod gbl_efi_ab_slot;
+pub mod gbl_efi_fastboot;
+pub mod gbl_efi_fastboot_usb;
+pub mod gbl_efi_image_loading;
+pub mod gbl_efi_os_configuration;
 pub mod loaded_image;
 pub mod riscv;
 pub mod simple_network;
 pub mod simple_text_input;
 pub mod simple_text_output;
 
+use liberror::{Error, Result};
+
 /// ProtocolInfo provides GUID info and the EFI data structure type for a protocol.
 pub trait ProtocolInfo {
     /// Data structure type of the interface.
@@ -65,9 +74,9 @@ impl<'a, T: ProtocolInfo> Protocol<'a, T> {
     }
 
     /// Returns the EFI data structure for the protocol interface.
-    pub fn interface(&self) -> EfiResult<&T::InterfaceType> {
+    pub fn interface(&self) -> Result<&T::InterfaceType> {
         // SAFETY: EFI protocol interface data structure.
-        unsafe { self.interface.as_ref() }.ok_or_else(|| EFI_STATUS_INVALID_PARAMETER.into())
+        unsafe { self.interface.as_ref() }.ok_or(Error::InvalidInput)
     }
 
     /// Returns the reference to EFI entry.
@@ -88,24 +97,79 @@ impl<T: ProtocolInfo> Drop for Protocol<'_, T> {
         // handle as a static permanent reference and don't close it. An example is
         // `EFI_SYSTEM_TABLE.ConOut`.
         if self.device.0 != null_mut() {
-            self.efi_entry.system_table().boot_services().close_protocol::<T>(self.device).unwrap();
-        }
-    }
-}
+            // Currently we open all protocols using flags BY_HANDLE_PROTOCOL. The flag allows a
+            // protocol to be opened for multiple copies, which is needed if a UEFI protocol
+            // implementation also require access for other protocols. But if any one of them is
+            // closed, all other opened copies will be affected. Therefore for now we don't close
+            // the protocol on drop. In the future when we start using other flags such as
+            // EXCLUSIVE, we should perform protocol close based on the open flags.
 
-impl EfiGuid {
-    pub const fn new(data1: u32, data2: u16, data3: u16, data4: [u8; 8usize]) -> Self {
-        EfiGuid { data1, data2, data3, data4 }
+            // self.efi_entry.system_table().boot_services().close_protocol::<T>(self.device).unwrap();
+        }
     }
 }
 
+/// Macro to perform an EFI protocol function call.
+///
+/// In the first variant, the first argument is the function pointer,
+/// and the following arguments are passed through as protocol args.
+///
+/// With our [Protocol] struct, usage generally looks something like:
+///
+/// ```
+/// efi_call!(
+///   self.interface()?.protocol_function_name,
+///   self.interface,
+///   arg1,
+///   arg2,
+///   ...
+/// )
+/// ```
+/// Most efi_call! invocations should use the first variant.
+///
+/// With the second variant, the first argument is an expression that references
+/// a buffer in-out size parameter.
+/// This is part of a pattern used by some protocol methods
+/// that take an output buffer and an in-out buffer size:
+/// if the method returns EFI_STATUS_BUFFER_TOO_SMALL,
+/// the size is mutated to contain the minimum required buffer size.
+/// The caller can then allocate a larger buffer and reattempt the method call.
+///
+/// Usage generally looks something like:
+/// ```
+/// efi_call!(
+///   @bufsize arg2,
+///   self.interface()?.protocol_function_name,
+///   self.interface,
+///   arg1,
+///   &mut arg2,
+///   ...
+/// )
+/// ```
 #[macro_export]
 macro_rules! efi_call {
     ( $method:expr, $($x:expr),*$(,)? ) => {
         {
-            let res: EfiResult<()> = match $method {
-                None => Err(EFI_STATUS_NOT_FOUND.into()),
-                Some(f) => map_efi_err(f($($x,)*))
+            use liberror::{Error, Result, efi_status_to_result};
+            let res: Result<()> = match $method {
+                None => Err(Error::NotFound),
+                Some(f) => efi_status_to_result(f($($x,)*)),
+            };
+            res
+        }
+    };
+    ( @bufsize $size:expr, $method:expr, $($x:expr),*$(,)? ) => {
+        {
+            use liberror::{Error, Result, efi_status_to_result};
+            use efi_types::EFI_STATUS_BUFFER_TOO_SMALL;
+            let res: Result<()> = match $method {
+                None => Err(Error::NotFound),
+                Some(f) => {
+                    match f($($x,)*) {
+                        EFI_STATUS_BUFFER_TOO_SMALL => Err(Error::BufferTooSmall(Some($size))),
+                        r => efi_status_to_result(r),
+                    }
+                },
             };
             res
         }
diff --git a/gbl/libefi/src/protocol/block_io.rs b/gbl/libefi/src/protocol/block_io.rs
index e646c26..f1b8a4b 100644
--- a/gbl/libefi/src/protocol/block_io.rs
+++ b/gbl/libefi/src/protocol/block_io.rs
@@ -12,12 +12,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{
-    EfiBlockIoMedia, EfiBlockIoProtocol, EfiGuid, EFI_STATUS_INVALID_PARAMETER,
-    EFI_STATUS_NOT_FOUND,
-};
+//! Rust wrapper for `EFI_BLOCK_IO_PROTOCOL`.
+
+use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiResult};
+use efi_types::{EfiBlockIoMedia, EfiBlockIoProtocol, EfiGuid};
+use liberror::{Error, Result};
 
 /// EFI_BLOCK_IO_PROTOCOL
 pub struct BlockIoProtocol;
@@ -32,7 +32,7 @@ impl ProtocolInfo for BlockIoProtocol {
 // Protocol interface wrappers.
 impl Protocol<'_, BlockIoProtocol> {
     /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.read_blocks()`
-    pub fn read_blocks(&self, lba: u64, buffer: &mut [u8]) -> EfiResult<()> {
+    pub fn read_blocks(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -51,7 +51,7 @@ impl Protocol<'_, BlockIoProtocol> {
     }
 
     /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.write_blocks()`
-    pub fn write_blocks(&self, lba: u64, buffer: &mut [u8]) -> EfiResult<()> {
+    pub fn write_blocks(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -70,7 +70,7 @@ impl Protocol<'_, BlockIoProtocol> {
     }
 
     /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.flush_blocks()`
-    pub fn flush_blocks(&self) -> EfiResult<()> {
+    pub fn flush_blocks(&self) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -79,7 +79,7 @@ impl Protocol<'_, BlockIoProtocol> {
     }
 
     /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.reset()`
-    pub fn reset(&self, extended_verification: bool) -> EfiResult<()> {
+    pub fn reset(&self, extended_verification: bool) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -88,9 +88,9 @@ impl Protocol<'_, BlockIoProtocol> {
     }
 
     /// Get a copy to the EFI_BLOCK_IO_PROTOCOL.Media structure.
-    pub fn media(&self) -> EfiResult<EfiBlockIoMedia> {
+    pub fn media(&self) -> Result<EfiBlockIoMedia> {
         let ptr = self.interface()?.media;
         // SFETY: Pointers to EFI data structure.
-        Ok(*unsafe { ptr.as_ref() }.ok_or_else(|| EFI_STATUS_INVALID_PARAMETER)?)
+        Ok(*unsafe { ptr.as_ref() }.ok_or(Error::InvalidInput)?)
     }
 }
diff --git a/gbl/libefi/src/protocol/block_io2.rs b/gbl/libefi/src/protocol/block_io2.rs
new file mode 100644
index 0000000..8964c87
--- /dev/null
+++ b/gbl/libefi/src/protocol/block_io2.rs
@@ -0,0 +1,149 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `EFI_BLOCK_IO2_PROTOCOL`.
+
+use crate::{
+    efi_call,
+    protocol::{Protocol, ProtocolInfo},
+    Event, EventNotify, EventType, Tpl,
+};
+use efi_types::{
+    EfiBlockIo2Protocol, EfiBlockIo2Token, EfiBlockIoMedia, EfiGuid, EFI_STATUS_NOT_READY,
+};
+use gbl_async::yield_now;
+use liberror::{efi_status_to_result, Error, Result};
+
+/// EFI_BLOCK_IO2_PROTOCOL
+pub struct BlockIo2Protocol;
+
+impl ProtocolInfo for BlockIo2Protocol {
+    type InterfaceType = EfiBlockIo2Protocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0xa77b2472, 0xe282, 0x4e9f, [0xa2, 0x45, 0xc2, 0xc0, 0xe2, 0x7b, 0xbc, 0xc1]);
+}
+
+// Protocol interface wrappers.
+impl Protocol<'_, BlockIo2Protocol> {
+    /// Syncs a non-blocking operation by waiting for the corresponding EFI event to be signaled.
+    async fn wait_io_completion(&self, event: &Event<'_, '_>) -> Result<()> {
+        let bs = self.efi_entry().system_table().boot_services();
+        loop {
+            match bs.check_event(&event) {
+                Err(e) => {
+                    // If we fail to check event/status, force reset the device to release any
+                    // retained user buffer. The reset cannot fail.
+                    self.reset(true).unwrap();
+                    return Err(e);
+                }
+                Ok(true) => return Ok(()),
+                _ => yield_now().await,
+            }
+        }
+    }
+
+    /// Wraps `EfiBlockIo2Protocol.read_blocks_ex`.
+    pub async fn read_blocks_ex(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
+        let bs = self.efi_entry().system_table().boot_services();
+        // UEFI spec requires that NOTIFY_WAIT event be always created with a callback.
+        let mut notify_fn = &mut |_| ();
+        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
+        // SAFETY: the notification callback never allocates, deallocates, or panics.
+        let event =
+            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
+        let mut token =
+            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * `self.interface` is input parameter and will not be retained. It outlives the call.
+        // * `Self::wait_io_completion()` is called immediately after. It makes sure the IO is either
+        //   completed successfully or is reset if `check_event` fails. Thus it's guaranteed that
+        //   after `Self::wait_io_completion()` returns, `buffer` and `token` are not being retained
+        //   by the UEFI firmware anymore.
+        unsafe {
+            efi_call!(
+                self.interface()?.read_blocks_ex,
+                self.interface,
+                self.media()?.media_id,
+                lba,
+                &mut token,
+                buffer.len(),
+                buffer.as_mut_ptr() as _
+            )?;
+        }
+        self.wait_io_completion(&event).await?;
+        efi_status_to_result(token.transaction_status)
+    }
+
+    /// Wraps `EfiBlockIo2Protocol.write_blocks_ex`.
+    pub async fn write_blocks_ex(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
+        let bs = self.efi_entry().system_table().boot_services();
+        let mut notify_fn = &mut |_| ();
+        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
+        // SAFETY: the notification callback never allocates, deallocates, or panics.
+        let event =
+            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
+        let mut token =
+            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
+        // SAFETY: See safety comment for `Self::read_blocks_ex()`.
+        unsafe {
+            efi_call!(
+                self.interface()?.write_blocks_ex,
+                self.interface,
+                self.media()?.media_id,
+                lba,
+                &mut token,
+                buffer.len(),
+                buffer.as_mut_ptr() as _
+            )?;
+        }
+        self.wait_io_completion(&event).await?;
+        efi_status_to_result(token.transaction_status)
+    }
+
+    /// Wraps `EFI_BLOCK_IO2_PROTOCOL.flush_blocks_ex()`
+    pub async fn flush_blocks_ex(&self) -> Result<()> {
+        let bs = self.efi_entry().system_table().boot_services();
+        let mut notify_fn = &mut |_| ();
+        let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
+        // SAFETY: the notification callback never allocates, deallocates, or panics.
+        let event =
+            unsafe { bs.create_event_with_notification(EventType::NotifyWait, &mut notify) }?;
+        let mut token =
+            EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
+        // SAFETY: See safety comment for `Self::read_blocks_ex()`.
+        unsafe {
+            efi_call!(self.interface()?.flush_blocks_ex, self.interface, &mut token,)?;
+        }
+        self.wait_io_completion(&event).await?;
+        efi_status_to_result(token.transaction_status)
+    }
+
+    /// Wraps `EFI_BLOCK_IO2_PROTOCOL.reset()`
+    pub fn reset(&self, extended_verification: bool) -> Result<()> {
+        // SAFETY:
+        // * See safety comment for `Self::read_blocks_ex()`.
+        // * The operation is synchronous, no need to call wait_io_completion().
+        unsafe { efi_call!(self.interface()?.reset, self.interface, extended_verification) }
+    }
+
+    /// Gets a copy of the `EFI_BLOCK_IO2_PROTOCOL.Media` structure.
+    pub fn media(&self) -> Result<EfiBlockIoMedia> {
+        let ptr = self.interface()?.media;
+        // SAFETY: Pointers to EFI data structure.
+        Ok(*unsafe { ptr.as_ref() }.ok_or(Error::InvalidInput)?)
+    }
+}
diff --git a/gbl/libefi/src/protocol/device_path.rs b/gbl/libefi/src/protocol/device_path.rs
index 2e18247..6ca5560 100644
--- a/gbl/libefi/src/protocol/device_path.rs
+++ b/gbl/libefi/src/protocol/device_path.rs
@@ -12,12 +12,13 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{
-    EfiDevicePathProtocol, EfiDevicePathToTextProtocol, EfiGuid, EFI_STATUS_NOT_FOUND,
-};
+//! Rust wrapper for `EFI_DEVICE_PATH_PROTOCOL`.
+
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{EfiEntry, EfiError, EfiResult};
+use crate::EfiEntry;
 use core::fmt::Display;
+use efi_types::{EfiDevicePathProtocol, EfiDevicePathToTextProtocol, EfiGuid};
+use liberror::{Error, Result};
 
 /// `EFI_DEVICE_PATH_PROTOCOL`
 pub struct DevicePathProtocol;
@@ -46,12 +47,8 @@ impl<'a> Protocol<'a, DevicePathToTextProtocol> {
         device_path: &Protocol<DevicePathProtocol>,
         display_only: bool,
         allow_shortcuts: bool,
-    ) -> EfiResult<DevicePathText<'a>> {
-        let f = self
-            .interface()?
-            .convert_device_path_to_text
-            .as_ref()
-            .ok_or_else::<EfiError, _>(|| EFI_STATUS_NOT_FOUND.into())?;
+    ) -> Result<DevicePathText<'a>> {
+        let f = self.interface()?.convert_device_path_to_text.as_ref().ok_or(Error::NotFound)?;
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -61,8 +58,8 @@ impl<'a> Protocol<'a, DevicePathToTextProtocol> {
     }
 }
 
-// `DevicePathText` is a wrapper for the return type of
-// EFI_DEVICE_PATH_TO_TEXT_PROTOCOL.ConvertDevicePathToText().
+/// `DevicePathText` is a wrapper for the return type of
+/// EFI_DEVICE_PATH_TO_TEXT_PROTOCOL.ConvertDevicePathToText().
 pub struct DevicePathText<'a> {
     text: Option<&'a [u16]>,
     efi_entry: &'a EfiEntry,
diff --git a/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs b/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
new file mode 100644
index 0000000..299fcd0
--- /dev/null
+++ b/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
@@ -0,0 +1,207 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `GBL_EFI_SLOT_PROTOCOL`.
+extern crate libgbl;
+
+use crate::efi_call;
+use crate::protocol::{Protocol, ProtocolInfo};
+use efi_types::{
+    EfiGuid, GblEfiABSlotProtocol, GblEfiBootReason, GblEfiSlotInfo, GblEfiSlotMetadataBlock,
+    GblEfiUnbootableReason, GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_NO_MORE_TRIES as NO_MORE_TRIES,
+    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_SYSTEM_UPDATE as SYSTEM_UPDATE,
+    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_USER_REQUESTED as USER_REQUESTED,
+    GBL_EFI_UNBOOTABLE_REASON_GBL_EFI_VERIFICATION_FAILURE as VERIFICATION_FAILURE,
+};
+use liberror::{Error, Result};
+
+use libgbl::slots::{Bootability, Slot, UnbootableReason};
+
+/// Wraps `GBL_EFI_SLOT_PROTOCOL`.
+pub struct GblSlotProtocol;
+
+impl ProtocolInfo for GblSlotProtocol {
+    type InterfaceType = GblEfiABSlotProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0x9a7a7db4, 0x614b, 0x4a08, [0x3d, 0xf9, 0x00, 0x6f, 0x49, 0xb0, 0xd8, 0x0c]);
+}
+
+fn from_efi_unbootable_reason(reason: GblEfiUnbootableReason) -> UnbootableReason {
+    match reason {
+        NO_MORE_TRIES => UnbootableReason::NoMoreTries,
+        SYSTEM_UPDATE => UnbootableReason::SystemUpdate,
+        USER_REQUESTED => UnbootableReason::UserRequested,
+        VERIFICATION_FAILURE => UnbootableReason::VerificationFailure,
+        _ => UnbootableReason::Unknown,
+    }
+}
+
+/// Newtype around GblEfiSlotInfo to bypass orphan rule.
+pub struct GblSlot(pub(crate) GblEfiSlotInfo);
+
+impl From<GblEfiSlotInfo> for GblSlot {
+    fn from(slot: GblEfiSlotInfo) -> Self {
+        Self(slot)
+    }
+}
+
+impl TryFrom<GblSlot> for libgbl::slots::Slot {
+    type Error = liberror::Error;
+    fn try_from(info: GblSlot) -> Result<Self> {
+        let info = info.0;
+        Ok(Slot {
+            suffix: info.suffix.try_into()?,
+            priority: info.priority.into(),
+            bootability: match (info.successful, info.tries) {
+                (s, _) if s != 0 => Bootability::Successful,
+                (0, t) if t > 0 => Bootability::Retriable(info.tries.into()),
+                _ => Bootability::Unbootable(from_efi_unbootable_reason(info.unbootable_reason)),
+            },
+        })
+    }
+}
+
+impl<'a> Protocol<'a, GblSlotProtocol> {
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.load_boot_data()`
+    pub fn load_boot_data(&self) -> Result<GblEfiSlotMetadataBlock> {
+        let mut block: GblEfiSlotMetadataBlock = Default::default();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `block` is an output parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.load_boot_data, self.interface, &mut block)? }
+        Ok(block)
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_slot_info()`
+    pub fn get_slot_info(&self, idx: u8) -> Result<GblSlot> {
+        let mut info: GblEfiSlotInfo = Default::default();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `info` is an output parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.get_slot_info, self.interface, idx, &mut info,)? }
+        Ok(info.into())
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_current_slot()`
+    pub fn get_current_slot(&self) -> Result<GblSlot> {
+        let mut info: GblEfiSlotInfo = Default::default();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `info` is an output parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.get_current_slot, self.interface, &mut info)? }
+        Ok(info.into())
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_active_slot()`
+    pub fn set_active_slot(&self, idx: u8) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.set_active_slot, self.interface, idx) }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_slot_unbootable()`
+    pub fn set_slot_unbootable(&self, idx: u8, reason: GblEfiUnbootableReason) -> Result<()> {
+        let reason: u32 = reason.try_into().or(Err(Error::InvalidInput))?;
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.set_slot_unbootable, self.interface, idx, reason) }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.mark_boot_attempt()`
+    pub fn mark_boot_attempt(&self) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.mark_boot_attempt, self.interface) }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.reinitialize()`
+    pub fn reinitialize(&self) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.reinitialize, self.interface) }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.get_boot_reason()`
+    pub fn get_boot_reason(&self, subreason: &mut [u8]) -> Result<(GblEfiBootReason, usize)> {
+        let mut reason: u32 = 0;
+        let mut subreason_size = subreason.len();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `reason` is an output parameter. It is not retained, and it outlives the call.
+        // `subreason_size` is an in-out parameter. It is not retained, and it outlives the call.
+        // `subreason` remains valid during the call.
+        unsafe {
+            efi_call!(
+                @bufsize subreason_size,
+                self.interface()?.get_boot_reason,
+                self.interface,
+                &mut reason,
+                &mut subreason_size,
+                subreason.as_mut_ptr(),
+            )?
+        }
+
+        let reason: GblEfiBootReason = reason.try_into().or(Err(Error::InvalidInput))?;
+        Ok((reason, subreason_size))
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_boot_reason()`
+    pub fn set_boot_reason(&self, reason: GblEfiBootReason, subreason: &[u8]) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `subreason` is not modified or retained. It outlives the call.
+        unsafe {
+            efi_call!(
+                self.interface()?.set_boot_reason,
+                self.interface,
+                reason.try_into().or(Err(Error::InvalidInput))?,
+                subreason.len(),
+                subreason.as_ptr(),
+            )
+        }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.flush()`
+    pub fn flush(&self) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.flush, self.interface) }
+    }
+
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.version`
+    pub fn version(&self) -> Result<u32> {
+        Ok(self.interface()?.version)
+    }
+}
diff --git a/gbl/libefi/src/protocol/gbl_efi_fastboot.rs b/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
new file mode 100644
index 0000000..226c4ff
--- /dev/null
+++ b/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
@@ -0,0 +1,606 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `GBL_EFI_FASTBOOT_PROTOCOL`
+
+use crate::{
+    efi_call,
+    protocol::{Protocol, ProtocolInfo},
+};
+use arrayvec::ArrayVec;
+use core::str::{from_utf8, Split};
+use efi_types::{
+    EfiGuid, GblEfiFastbootArg, GblEfiFastbootPolicy, GblEfiFastbootProtocol, GblEfiFastbootToken,
+};
+use liberror::{Error, Result};
+
+/// GBL_EFI_FASTBOOT_PROTOCOL
+pub struct GblFastbootProtocol;
+
+// Note: this is an internal limitation due to the need to allocate
+// fixed sized buffers for storing args in the iterator
+// and in the wrapper for `GblEfiFastbootProtocol.get_var`.
+const MAX_ARGS: usize = 16;
+
+impl ProtocolInfo for GblFastbootProtocol {
+    type InterfaceType = GblEfiFastbootProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0xc67e48a0, 0x5eb8, 0x4127, [0xbe, 0x89, 0xdf, 0x2e, 0xd9, 0x3d, 0x8a, 0x9a]);
+}
+
+/// Wrapper type for get_next_var_args() tokens.
+///
+/// Tokens are opaque values used to store the iterator's position.
+/// They can also be passed in get_var() to give the backend a hint
+/// on where to find a variable entry.
+#[derive(Copy, Clone, Debug)]
+pub struct Token(GblEfiFastbootToken);
+
+impl Token {
+    const fn new() -> Self {
+        Self(core::ptr::null())
+    }
+}
+
+impl Protocol<'_, GblFastbootProtocol> {
+    /// Hint-free wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var()`
+    pub fn get_var(&self, args: Split<'_, char>, buffer: &mut [u8]) -> Result<usize> {
+        self.get_var_with_hint(args, buffer, Token::new())
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var() with hint.`
+    pub fn get_var_with_hint(
+        &self,
+        args: Split<'_, char>,
+        buffer: &mut [u8],
+        hint: Token,
+    ) -> Result<usize> {
+        let mut bufsize = buffer.len();
+        let mut call_args: [GblEfiFastbootArg; MAX_ARGS + 1] = Default::default();
+        let mut call_args_len = 0usize;
+        for (a, ca) in core::iter::zip(args, call_args.iter_mut()) {
+            ca.str_utf8 = a.as_ptr();
+            ca.len = a.len();
+            call_args_len += 1;
+        }
+
+        if call_args_len == MAX_ARGS + 1 {
+            return Err(Error::InvalidInput);
+        }
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // No parameter is Null except optionally `hint`, and all parameters outlive the call.
+        // Null is a valid value for hint.
+        unsafe {
+            efi_call!(
+                @bufsize bufsize,
+                self.interface()?.get_var,
+                self.interface,
+                call_args.as_ptr(),
+                call_args_len,
+                buffer.as_mut_ptr(),
+                &mut bufsize,
+                hint.0,
+            )?
+        };
+        Ok(bufsize)
+    }
+
+    fn start_var_iterator(&self) -> Result<Token> {
+        let mut token = Token::new();
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        // `token.0` is an output parameter. It is not retained, and it outlives the call.
+        // Null is a valid value for token.
+        unsafe { efi_call!(self.interface()?.start_var_iterator, self.interface, &mut token.0)? };
+
+        Ok(token)
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_next_var_args()`
+    fn get_next_var_args(
+        &self,
+        args: &mut [GblEfiFastbootArg],
+        token: Token,
+    ) -> Result<(usize, Token)> {
+        let mut bufsize = args.len();
+        let mut new_token = token;
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // No parameter is retained, and all parameters outlive the call.
+        // No parameter is Null except possibly `new_token.0`
+        // Null is a valid value for `new_token.0`.
+        unsafe {
+            efi_call!(
+                @bufsize bufsize,
+                self.interface()?.get_next_var_args,
+                self.interface,
+                args.as_mut_ptr(),
+                &mut bufsize,
+                &mut new_token.0
+            )?
+        };
+        Ok((bufsize, new_token))
+    }
+
+    /// Returns an iterator over backend fastboot variables.
+    pub fn var_iter(&self) -> Result<VarIterator> {
+        VarIterator::try_new(self)
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.run_oem_function()`
+    pub fn run_oem_function(&self, cmd: &str, buffer: &mut [u8]) -> Result<usize> {
+        let mut bufsize = buffer.len();
+        if !buffer.is_empty() {
+            buffer[0] = 0;
+        }
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // No parameter is retained, all parameters outlive the call,
+        // and no pointers are Null.
+        unsafe {
+            efi_call!(
+                @bufsize bufsize,
+                self.interface()?.run_oem_function,
+                self.interface,
+                cmd.as_ptr(),
+                cmd.len(),
+                buffer.as_mut_ptr(),
+                &mut bufsize,
+            )?
+        };
+        Ok(core::cmp::min(bufsize, buffer.iter().position(|c| *c == 0).unwrap_or(buffer.len())))
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_policy()`
+    pub fn get_policy(&self) -> Result<GblEfiFastbootPolicy> {
+        let mut policy: GblEfiFastbootPolicy = Default::default();
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // No parameters are retained, all parameters outlive the call,
+        // and no pointers are Null.
+        unsafe { efi_call!(self.interface()?.get_policy, self.interface, &mut policy)? };
+
+        Ok(policy)
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.set_lock()`
+    pub fn set_lock(&self, flags: u64) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.set_lock, self.interface, flags) }
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.clear_lock()`
+    pub fn clear_lock(&self, flags: u64) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.clear_lock, self.interface, flags) }
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_partition_permissions()`
+    pub fn get_partition_permissions(&self, part_name: &str) -> Result<u64> {
+        let mut permissions = 0u64;
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // No parameters are retained, all parameters outlive the call,
+        // and no pointers are Null.
+        unsafe {
+            efi_call!(
+                self.interface()?.get_partition_permissions,
+                self.interface,
+                part_name.as_ptr(),
+                part_name.len(),
+                &mut permissions
+            )?
+        };
+        Ok(permissions)
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.wipe_user_data()`
+    pub fn wipe_user_data(&self) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is an input parameter and will not be retained. It outlives the call.
+        unsafe { efi_call!(self.interface()?.wipe_user_data, self.interface) }
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.serial_number`
+    pub fn serial_number(&self) -> Result<&str> {
+        let serial_number = &self.interface()?.serial_number;
+        let null_idx = serial_number.iter().position(|c| *c == 0).unwrap_or(serial_number.len());
+        Ok(from_utf8(&serial_number[..null_idx])?)
+    }
+
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.version`
+    pub fn version(&self) -> Result<u32> {
+        Ok(self.interface()?.version)
+    }
+}
+
+/// Iterator over fastboot variables.
+pub struct VarIterator<'a> {
+    protocol: &'a Protocol<'a, GblFastbootProtocol>,
+    token: Token,
+}
+
+impl<'a> VarIterator<'a> {
+    /// Tries to construct a new iterator over fastboot variables.
+    /// Returns Err if the call to protocol.start_var_iterator fails.
+    pub fn try_new(protocol: &'a Protocol<'a, GblFastbootProtocol>) -> Result<Self> {
+        let token = protocol.start_var_iterator()?;
+        Ok(Self { protocol, token })
+    }
+}
+
+impl<'a> Iterator for VarIterator<'a> {
+    type Item = (ArrayVec<GblEfiFastbootArg, MAX_ARGS>, Token);
+    fn next(&mut self) -> Option<Self::Item> {
+        let mut args = [GblEfiFastbootArg::default(); MAX_ARGS];
+
+        let prev_token = self.token;
+        let (len, token) = self.protocol.get_next_var_args(&mut args, self.token).ok()?;
+        self.token = token;
+
+        if len == 0 {
+            None
+        } else {
+            let mut args = ArrayVec::from(args);
+            args.truncate(len);
+            Some((args, prev_token))
+        }
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::test::{generate_protocol, run_test};
+    use crate::EfiEntry;
+    use core::slice;
+    use core::{
+        ffi::{c_void, CStr},
+        ptr::addr_of,
+    };
+    use efi_types::{
+        EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_NOT_FOUND,
+        EFI_STATUS_SUCCESS,
+    };
+
+    #[derive(Copy, Clone, Debug)]
+    struct VarEntry<'a, 'b> {
+        var_args: &'a [GblEfiFastbootArg],
+        val: &'b CStr,
+    }
+
+    // SAFETY:
+    // All VarEntry entities are immutable and static.
+    unsafe impl Sync for VarEntry<'static, 'static> {}
+
+    fn count_bytes_cstr(cstr: &CStr) -> usize {
+        cstr.to_bytes_with_nul().iter().position(|c| *c == 0).unwrap()
+    }
+
+    unsafe fn join_args(args: &[GblEfiFastbootArg], conjunction: &str) -> String {
+        args.iter()
+            .map(|arg| {
+                // SAFETY: It is the caller's responsibility to verify that `arg.str_utf8`
+                // points to a byte slice of length `arg.len`.
+                core::str::from_utf8(unsafe { slice::from_raw_parts(arg.str_utf8, arg.len) })
+                    .unwrap()
+            })
+            .fold(String::new(), |mut acc, s| {
+                acc.push_str(s);
+                acc.push_str(conjunction);
+                acc
+            })
+    }
+
+    const fn from_str(s: &str) -> GblEfiFastbootArg {
+        GblEfiFastbootArg { str_utf8: s.as_ptr(), len: s.len() }
+    }
+
+    static VARS: &[VarEntry] = &[
+        VarEntry { var_args: &[from_str("bivalve")], val: c"clam" },
+        VarEntry { var_args: &[from_str("cephalopod"), from_str("nautiloid")], val: c"nautilus" },
+        VarEntry { var_args: &[from_str("cephalopod"), from_str("coleoid")], val: c"squid" },
+        VarEntry {
+            var_args: &[from_str("gastropod"), from_str("muricidae"), from_str("nucella")],
+            val: c"whelk",
+        },
+    ];
+
+    #[derive(Copy, Clone, Debug)]
+    struct PtrWrapper<T> {
+        ptr: *const T,
+    }
+
+    impl<T> PtrWrapper<T> {
+        const fn new(ptr: *const T) -> Self {
+            Self { ptr }
+        }
+        const fn get(&self) -> *const T {
+            self.ptr
+        }
+    }
+
+    static VARS_ADDR: PtrWrapper<VarEntry> = PtrWrapper::new(addr_of!(VARS[0]));
+    // SAFETY
+    // `VARS_ADDR` is a known valid pointer to a known-length array of VarEntry.
+    // `VARS_ADDR + VARS.len()` is extremely unlikely to overwrap,
+    // and `VARS_END` is never dereferenced.
+    static VARS_END: PtrWrapper<VarEntry> =
+        PtrWrapper::new(unsafe { VARS_ADDR.get().add(VARS.len()) });
+
+    // SAFETY
+    // PtrWrapper and the pointer it wraps are immutable.
+    unsafe impl<T> Sync for PtrWrapper<T> {}
+
+    unsafe fn arg_slices_equal_p(lhs: &[GblEfiFastbootArg], rhs: &[GblEfiFastbootArg]) -> bool {
+        if lhs.len() != rhs.len() {
+            return false;
+        }
+
+        // SAFETY:
+        // It is the caller's responsibility to guarantee that for each element
+        // 'arg' of `lhs`, `arg.str_utf8` is a valid UTF-8 encoded string of length `arg.len`.
+        let lhs = lhs.iter().map(|arg| unsafe {
+            core::str::from_utf8_unchecked(core::slice::from_raw_parts(arg.str_utf8, arg.len))
+        });
+        // SAFETY:
+        // It is the caller's responsibility to guarantee that for each element
+        // 'arg' of `rhs`, `arg.str_utf8` is a valid UTF-8 encoded string of length `arg.len`.
+        let rhs = rhs.iter().map(|arg| unsafe {
+            core::str::from_utf8_unchecked(core::slice::from_raw_parts(arg.str_utf8, arg.len))
+        });
+
+        core::iter::zip(lhs, rhs).all(|(l, r)| l == r)
+    }
+
+    unsafe extern "C" fn get_var(
+        _: *mut GblEfiFastbootProtocol,
+        args: *const GblEfiFastbootArg,
+        args_len: usize,
+        buffer: *mut u8,
+        bufsize: *mut usize,
+        _token: GblEfiFastbootToken,
+    ) -> EfiStatus {
+        if args.is_null() || buffer.is_null() || bufsize.is_null() {
+            return EFI_STATUS_INVALID_PARAMETER;
+        }
+        // SAFETY:
+        // The check at the beginning of the function guarantees that `args` is not Null.
+        // It is the caller's responsibility to guarantee that `args` points to a valid
+        // array of initialized GblEfiFastbootArg structs of length `args_len`.
+        let args = unsafe { core::slice::from_raw_parts(args, args_len) };
+
+        // SAFETY:
+        // All elements of `VARS` contain valid UTF-8 encoded strings.
+        // It is the caller's responsibility to guarantee that all elements of `args`
+        // contain valid UTF-8 encoded strings.
+        let entry = VARS.iter().find(|entry| unsafe { arg_slices_equal_p(args, &entry.var_args) });
+        if let Some(entry) = entry {
+            let val_len = count_bytes_cstr(entry.val);
+            // SAFETY:
+            // `bufsize` is not Null due to check at beginning of function.
+            // Caller is responsible for passing a well-aligned pointer to a valid usize.
+            let bs = unsafe { *bufsize };
+            // SAFETY:
+            // `bufsize` is not Null due to check at beginning of function.
+            // It is the caller's responsibility to pass a valid, well-aligned pointer as `bufsize`.
+            unsafe { *bufsize = val_len };
+            if val_len > bs {
+                EFI_STATUS_BUFFER_TOO_SMALL
+            } else {
+                // SAFETY:
+                // `buffer` is not Null due to check at beginning of function.
+                // It is the caller's responsibiltiy to pass a valid, well-aligned pointer
+                // to an array of `u8` at least as long as the initial value of `bufsize`.
+                unsafe { buffer.copy_from(entry.val.to_bytes().as_ptr(), *bufsize) };
+                EFI_STATUS_SUCCESS
+            }
+        } else {
+            EFI_STATUS_NOT_FOUND
+        }
+    }
+
+    unsafe extern "C" fn start_var_iterator(
+        _: *mut GblEfiFastbootProtocol,
+        token: *mut GblEfiFastbootToken,
+    ) -> EfiStatus {
+        if token.is_null() {
+            return EFI_STATUS_INVALID_PARAMETER;
+        }
+
+        // SAFETY:
+        // `token` is not Null.
+        // It is the caller's responsibility to pass a valid,
+        // well aligned pointer as `token`.
+        // `VARS_ADDR` contains a valid pointer to a static array.
+        unsafe { *token = VARS_ADDR.get() as *const c_void };
+        EFI_STATUS_SUCCESS
+    }
+
+    unsafe extern "C" fn get_next_var_args(
+        _: *mut GblEfiFastbootProtocol,
+        args: *mut GblEfiFastbootArg,
+        args_len: *mut usize,
+        token: *mut GblEfiFastbootToken,
+    ) -> EfiStatus {
+        if args.is_null() || args_len.is_null() || token.is_null() {
+            return EFI_STATUS_INVALID_PARAMETER;
+        }
+
+        // SAFETY:
+        // `token` is not Null due to check at beginning of function.
+        // caller is responsible for passing a valid, well-aligned pointer.
+        let pos = unsafe { *token.cast::<*const VarEntry>() };
+        if pos == VARS_END.get() {
+            // SAFETY:
+            // `args_len` is not null due to check at beginning of funcion.
+            // caller is responsible for passing a valid, well-aligned pointer as `args_len`.
+            unsafe { *args_len = 0 };
+            return EFI_STATUS_SUCCESS;
+        } else if pos < VARS_ADDR.get() || pos > VARS_END.get() {
+            return EFI_STATUS_INVALID_PARAMETER;
+        }
+
+        // SAFETY:
+        // `args_len` is not Null due to check at beginning of function.
+        // caller is responsible for passing a valid, well-aligned pointer for args_len.
+        let args_max_len = unsafe { *args_len };
+
+        // SAFETY:
+        // `pos` is between `&VARS` inclusive and `&VARS + VARS.len()` exclusive
+        // due to check earlier.
+        let elt = unsafe { *pos };
+        // SAFETY:
+        // `args_len` is not Null.
+        // caller is responsible for passing a valid, well-aligned pointer.
+        unsafe { *args_len = elt.var_args.len() };
+        if args_max_len < elt.var_args.len() {
+            return EFI_STATUS_BUFFER_TOO_SMALL;
+        }
+
+        for (i, varg) in elt.var_args.iter().enumerate() {
+            // SAFETY:
+            // `args` is not Null due to check at beginning of function.
+            // `args_len` is at least as large as as `elt.var_args.len()`
+            // due to check before returning BUFFER_TOO_SMALL.
+            // It is the caller's responsibility to guarantee that `args` is a valid
+            // array of at least `args_len` length.
+            unsafe { *args.add(i) = *varg };
+        }
+        // SAFETY:
+        // `token` is not Null due to check at beginning of function.
+        // `pos.add(1)` either points to a valid entry in `VARS` or
+        // one past the end of `VARS`, which is a valid pointer to construct
+        // for the purpose of checking for the end of iteration.
+        unsafe { *token = pos.add(1).cast::<c_void>() };
+
+        EFI_STATUS_SUCCESS
+    }
+
+    #[test]
+    fn test_var_iterator() {
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol {
+                start_var_iterator: Some(start_var_iterator),
+                get_next_var_args: Some(get_next_var_args),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+            let var_iter = protocol.var_iter().unwrap();
+
+            // SAFETY:
+            // All elements of `VARS`, and therefore all elements of `var_iter`,
+            // contain valid UTF-8 encoded strings.
+            let actual: Vec<String> = var_iter
+                .map(|(args, _token): (_, Token)| unsafe { join_args(&args, ":") })
+                .collect();
+
+            let expected = &[
+                "bivalve:",
+                "cephalopod:nautiloid:",
+                "cephalopod:coleoid:",
+                "gastropod:muricidae:nucella:",
+            ];
+
+            assert_eq!(expected, actual.as_slice());
+        });
+    }
+
+    #[test]
+    fn test_get_var() {
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol { get_var: Some(get_var), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+
+            let args = "cephalopod:coleoid".split(':');
+            let mut buffer = [0u8; 32];
+            let len = protocol.get_var(args, &mut buffer).unwrap();
+            let actual = std::str::from_utf8(&buffer[..len]).unwrap();
+            assert_eq!(actual, "squid");
+
+            let args = "cephalopod:nautiloid".split(':');
+            let len = protocol.get_var_with_hint(args, &mut buffer, Token::new()).unwrap();
+            let actual = std::str::from_utf8(&buffer[..len]).unwrap();
+            assert_eq!(actual, "nautilus");
+        });
+    }
+
+    #[test]
+    fn test_serial_number() {
+        run_test(|image_handle, systab_ptr| {
+            // Serial number is shorter than max length and contains non-ASCII unicode.
+            let austria = "sterreich";
+
+            let mut fb = GblEfiFastbootProtocol { ..Default::default() };
+            fb.serial_number.as_mut_slice()[..austria.len()].copy_from_slice(austria.as_bytes());
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+
+            // Don't include trailing Null terminators.
+            assert_eq!(protocol.serial_number().unwrap().len(), 11);
+            assert_eq!(protocol.serial_number().unwrap(), austria);
+        });
+    }
+
+    #[test]
+    fn test_serial_number_max_length() {
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol { serial_number: [71u8; 32], ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+
+            assert_eq!(protocol.serial_number().unwrap().len(), 32);
+            assert_eq!(protocol.serial_number().unwrap(), "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
+        });
+    }
+
+    #[test]
+    fn test_serial_number_invalid_utf8() {
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol { serial_number: [0xF8; 32], ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+
+            assert_eq!(protocol.serial_number(), Err(Error::InvalidInput));
+        });
+    }
+}
diff --git a/gbl/libefi/src/protocol/android_boot.rs b/gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs
similarity index 53%
rename from gbl/libefi/src/protocol/android_boot.rs
rename to gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs
index 931d6e6..7b37ef7 100644
--- a/gbl/libefi/src/protocol/android_boot.rs
+++ b/gbl/libefi/src/protocol/gbl_efi_fastboot_usb.rs
@@ -12,24 +12,31 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{EfiAndroidBootProtocol, EfiGuid, EFI_STATUS_NOT_FOUND};
-use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiResult, Event};
+//! Rust wrapper for `GBL_EFI_FASTBOOT_USB_PROTOCOL`.
 
-/// EFI_ANDROID_BOOT_PROTOCOL
-pub struct AndroidBootProtocol;
+use crate::{
+    protocol::{Protocol, ProtocolInfo},
+    utils::with_timeout,
+    {efi_call, Event},
+};
+use efi_types::{EfiGuid, GblEfiFastbootUsbProtocol};
+use gbl_async::yield_now;
+use liberror::{Error, Result};
 
-impl ProtocolInfo for AndroidBootProtocol {
-    type InterfaceType = EfiAndroidBootProtocol;
+/// GBL_EFI_FASTBOOT_USB_PROTOCOL
+pub struct GblFastbootUsbProtocol;
+
+impl ProtocolInfo for GblFastbootUsbProtocol {
+    type InterfaceType = GblEfiFastbootUsbProtocol;
 
     const GUID: EfiGuid =
         EfiGuid::new(0x6281a893, 0xac23, 0x4ca7, [0xb2, 0x81, 0x34, 0x0e, 0xf8, 0x16, 0x89, 0x55]);
 }
 
 // Protocol interface wrappers.
-impl Protocol<'_, AndroidBootProtocol> {
-    /// Wrapper of `EFI_ANDROID_BOOT_PROTOCOL.fastboot_usb_interface_start()`
-    pub fn fastboot_usb_interface_start(&self) -> EfiResult<usize> {
+impl Protocol<'_, GblFastbootUsbProtocol> {
+    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_interface_start()`
+    pub fn fastboot_usb_interface_start(&self) -> Result<usize> {
         let mut max_packet_size = 0;
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
@@ -46,8 +53,8 @@ impl Protocol<'_, AndroidBootProtocol> {
         Ok(max_packet_size)
     }
 
-    /// Wrapper of `EFI_ANDROID_BOOT_PROTOCOL.fastboot_usb_interface_stop()`
-    pub fn fastboot_usb_interface_stop(&self) -> EfiResult<()> {
+    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_interface_stop()`
+    pub fn fastboot_usb_interface_stop(&self) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -55,9 +62,9 @@ impl Protocol<'_, AndroidBootProtocol> {
         unsafe { efi_call!(self.interface()?.fastboot_usb_interface_stop, self.interface,) }
     }
 
-    /// Wrapper of `EFI_ANDROID_BOOT_PROTOCOL.fastboot_usb_receive()`
-    pub fn fastboot_usb_receive(&self, out: &mut [u8], out_size: &mut usize) -> EfiResult<()> {
-        *out_size = out.len();
+    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_receive()`
+    pub fn fastboot_usb_receive(&self, out: &mut [u8]) -> Result<usize> {
+        let mut out_size = out.len();
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -65,17 +72,20 @@ impl Protocol<'_, AndroidBootProtocol> {
         // and will not be retained.
         unsafe {
             efi_call!(
+                @bufsize out_size,
                 self.interface()?.fastboot_usb_receive,
                 self.interface,
-                out_size,
+                &mut out_size,
                 out.as_mut_ptr() as _,
-            )
+            )?;
         }
+
+        Ok(out_size)
     }
 
-    /// Wrapper of `EFI_ANDROID_BOOT_PROTOCOL.fastboot_usb_send()`
-    pub fn fastboot_usb_send(&self, data: &[u8], out_size: &mut usize) -> EfiResult<()> {
-        *out_size = data.len();
+    /// Wrapper of `GBL_EFI_FASTBOOT_USB_PROTOCOL.fastboot_usb_send()`
+    pub fn fastboot_usb_send(&self, data: &[u8]) -> Result<usize> {
+        let mut out_size = data.len();
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -83,16 +93,45 @@ impl Protocol<'_, AndroidBootProtocol> {
         // and will not be retained.
         unsafe {
             efi_call!(
+                @bufsize out_size,
                 self.interface()?.fastboot_usb_send,
                 self.interface,
-                out_size,
+                &mut out_size,
                 data.as_ptr() as _,
-            )
+            )?;
         }
+
+        Ok(out_size)
     }
 
-    /// Returns the `EFI_ANDROID_BOOT_PROTOCOL.wait_for_send_completion` EFI event.
-    pub fn wait_for_send_completion(&self) -> EfiResult<Event> {
+    /// Returns the `GBL_EFI_FASTBOOT_USB_PROTOCOL.wait_for_send_completion` EFI event.
+    pub fn wait_for_send_completion(&self) -> Result<Event> {
         Ok(Event::new_unowned(self.interface()?.wait_for_send_completion))
     }
+
+    /// Receives the next packet from the USB.
+    pub async fn receive_packet(&self, out: &mut [u8]) -> Result<usize> {
+        loop {
+            match self.fastboot_usb_receive(out) {
+                Ok(out_size) => return Ok(out_size),
+                Err(Error::NotReady) => yield_now().await,
+                Err(e) => return Err(e),
+            }
+        }
+    }
+
+    /// A helper to wait for the send event to signal.
+    async fn wait_send(&self) -> Result<()> {
+        let bs = self.efi_entry().system_table().boot_services();
+        while !bs.check_event(&self.wait_for_send_completion()?)? {
+            yield_now().await;
+        }
+        Ok(())
+    }
+
+    /// Sends a packet over the USB.
+    pub async fn send_packet(&self, data: &[u8], timeout_ms: u64) -> Result<()> {
+        self.fastboot_usb_send(data)?;
+        with_timeout(self.efi_entry(), self.wait_send(), timeout_ms).await?.ok_or(Error::Timeout)?
+    }
 }
diff --git a/gbl/libefi/src/protocol/gbl_efi_image_loading.rs b/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
new file mode 100644
index 0000000..d5e2343
--- /dev/null
+++ b/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
@@ -0,0 +1,1027 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `EFI_IMAGE_LOADING_PROTOCOL`.
+
+use crate::efi_call;
+use crate::protocol::{Protocol, ProtocolInfo};
+use arrayvec::ArrayVec;
+use core::mem::{size_of, MaybeUninit};
+use efi_types::{
+    EfiGuid, GblEfiImageBuffer, GblEfiImageInfo, GblEfiImageLoadingProtocol, GblEfiPartitionName,
+    PARTITION_NAME_LEN_U16,
+};
+use liberror::{Error, Result};
+use spin::Mutex;
+
+/// GBL_IMAGE_LOADING_PROTOCOL
+pub struct GblImageLoadingProtocol;
+
+impl ProtocolInfo for GblImageLoadingProtocol {
+    type InterfaceType = GblEfiImageLoadingProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0xdb84b4fa, 0x53bd, 0x4436, [0x98, 0xa7, 0x4e, 0x02, 0x71, 0x42, 0x8b, 0xa8]);
+}
+
+/// Max length of partition name in UTF8 in bytes.
+pub const PARTITION_NAME_LEN_U8: usize = size_of::<char>() * PARTITION_NAME_LEN_U16;
+
+const MAX_ARRAY_SIZE: usize = 100;
+static RETURNED_BUFFERS: Mutex<ArrayVec<usize, MAX_ARRAY_SIZE>> = Mutex::new(ArrayVec::new_const());
+
+/// Wrapper class for buffer received with [get_buffer] function.
+///
+/// Helps to keep track of allocated memory and avoid getting same buffer more than once.
+#[derive(Debug)]
+pub struct EfiImageBuffer {
+    buffer: Option<&'static mut [MaybeUninit<u8>]>,
+}
+
+impl EfiImageBuffer {
+    // SAFETY:
+    // `gbl_buffer` must represent valid buffer.
+    //
+    // # Return
+    // Err(EFI_STATUS_INVALID_PARAMETER) - If `gbl_buffer.Memory` == NULL
+    // Err(EFI_STATUS_ALREADY_STARTED) - Requested buffer was already returned and is still in use.
+    // Err(err) - on error
+    // Ok(_) - on success
+    unsafe fn new(gbl_buffer: GblEfiImageBuffer) -> Result<EfiImageBuffer> {
+        if gbl_buffer.Memory.is_null() {
+            return Err(Error::InvalidInput);
+        }
+
+        let addr = gbl_buffer.Memory as usize;
+        let mut returned_buffers = RETURNED_BUFFERS.lock();
+        if returned_buffers.contains(&addr) {
+            return Err(Error::AlreadyStarted);
+        }
+        returned_buffers.push(addr);
+
+        // SAFETY:
+        // `gbl_buffer.Memory` is guarantied to be not null
+        // This code is relying on EFI protocol implementation to provide valid buffer pointer
+        // to memory region of size `gbl_buffer.SizeBytes`.
+        Ok(EfiImageBuffer {
+            buffer: Some(unsafe {
+                core::slice::from_raw_parts_mut(
+                    gbl_buffer.Memory as *mut MaybeUninit<u8>,
+                    gbl_buffer.SizeBytes,
+                )
+            }),
+        })
+    }
+
+    /// Move buffer ownership out of EfiImageBuffer, and consume it.
+    pub fn take(mut self) -> &'static mut [MaybeUninit<u8>] {
+        self.buffer.take().unwrap()
+    }
+}
+
+impl Drop for EfiImageBuffer {
+    fn drop(&mut self) {
+        if self.buffer.is_none() {
+            return;
+        }
+
+        let mut returned_buffers = RETURNED_BUFFERS.lock();
+        if let Some(pos) = returned_buffers
+            .iter()
+            .position(|&val| val == (*self.buffer.as_ref().unwrap()).as_ptr() as usize)
+        {
+            returned_buffers.swap_remove(pos);
+        }
+    }
+}
+
+// Protocol interface wrappers.
+impl Protocol<'_, GblImageLoadingProtocol> {
+    /// Wrapper of `GBL_IMAGE_LOADING_PROTOCOL.get_buffer()`
+    ///
+    /// # Return
+    /// Ok(Some(EfiImageBuffer)) if buffer was successfully provided,
+    /// Ok(None) if buffer was not provided
+    /// Err(Error::EFI_STATUS_BUFFER_TOO_SMALL) if provided buffer is too small
+    /// Err(Error::EFI_STATUS_INVALID_PARAMETER) if received buffer is NULL
+    /// Err(Error::EFI_STATUS_ALREADY_STARTED) buffer was already returned and is still in use.
+    /// Err(err) if `err` occurred
+    pub fn get_buffer(&self, gbl_image_info: &GblEfiImageInfo) -> Result<EfiImageBuffer> {
+        let mut gbl_buffer: GblEfiImageBuffer = Default::default();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` and `gbl_buffer` are input/output parameters, outlive the call and
+        // will not be retained.
+        // `gbl_buffer` returned by this call must not overlap, and will be checked by
+        // `EfiImageBuffer`
+        unsafe {
+            efi_call!(
+                @bufsize gbl_image_info.SizeBytes,
+                self.interface()?.get_buffer,
+                self.interface,
+                gbl_image_info,
+                &mut gbl_buffer
+            )?;
+        }
+
+        if gbl_buffer.SizeBytes < gbl_image_info.SizeBytes {
+            return Err(Error::BufferTooSmall(Some(gbl_image_info.SizeBytes)));
+        }
+
+        // SAFETY:
+        // `gbl_buffer.Memory` must be not null. This checked in `new()` call
+        // `gbl_buffer.Size` must be valid size of the buffer.
+        // This protocol is relying on EFI protocol implementation to provide valid buffer pointer
+        // to memory region of size `gbl_buffer.SizeBytes`.
+        let image_buffer = unsafe { EfiImageBuffer::new(gbl_buffer)? };
+
+        Ok(image_buffer)
+    }
+
+    /// Wrapper of `GBL_IMAGE_LOADING_PROTOCOL.get_verify_partitions()`
+    ///
+    /// # Result
+    /// Err(BufferTooSmall(Some(size))) - when provided `partition_names` is less than expected
+    /// `size`
+    /// Err(err) - if error occurred.
+    /// Ok(len) - will return number of `GblEfiPartitionName`s copied to `partition_names` slice.
+    pub fn get_verify_partitions(
+        &self,
+        partition_names: &mut [GblEfiPartitionName],
+    ) -> Result<usize> {
+        let partition_count_in: usize = partition_names.len();
+        let mut partition_count: usize = partition_count_in;
+
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface` is input parameter, outlives the call, and will not be retained.
+        // `partition_count` must be set to valid length of `partition_names` array after the call.
+        // `partition_names` must be valid array of length `partition_count` after the call.
+        unsafe {
+            efi_call!(
+                @bufsize partition_count,
+                self.interface()?.get_verify_partitions,
+                self.interface,
+                &mut partition_count,
+                partition_names.as_mut_ptr(),
+            )?;
+        }
+
+        Ok(partition_count)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::{
+        protocol::gbl_efi_image_loading::GblImageLoadingProtocol, test::run_test, DeviceHandle,
+        EfiEntry,
+    };
+    use core::{ffi::c_void, iter::zip, ptr::null_mut};
+    use efi_types::{
+        EfiStatus, EFI_STATUS_BAD_BUFFER_SIZE, EFI_STATUS_BUFFER_TOO_SMALL,
+        EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
+    };
+
+    const UCS2_STR: [u16; 8] = [0x2603, 0x0073, 0x006e, 0x006f, 0x0077, 0x006d, 0x0061, 0x006e];
+    const UTF8_STR: &str = "snowman";
+    const PARTITIONS_MAX: usize = 128;
+
+    fn get_buffer_utf8() -> [[u8; PARTITION_NAME_LEN_U8]; PARTITIONS_MAX] {
+        [[0; PARTITION_NAME_LEN_U8]; PARTITIONS_MAX]
+    }
+
+    fn get_printable_utf16() -> Vec<u16> {
+        (0x0021..0x007e).collect::<Vec<u16>>()
+    }
+
+    fn get_printable_string() -> String {
+        String::from_utf8((0x21..0x7e).collect::<Vec<u8>>()).unwrap()
+    }
+
+    #[test]
+    fn test_partition_name_get_str() {
+        let mut buffer = [0u8; 100];
+        // empty string
+        assert_eq!(GblEfiPartitionName::from([0u16]).get_str(&mut buffer).unwrap(), "");
+        assert_eq!(GblEfiPartitionName::from([0u16]).get_str(&mut buffer).unwrap(), "");
+        assert_eq!(GblEfiPartitionName::from([0x0000]).get_str(&mut buffer[..0]).unwrap(), "");
+
+        // Special characters
+        assert_eq!(GblEfiPartitionName::from(UCS2_STR).get_str(&mut buffer).unwrap(), UTF8_STR);
+
+        // Null character in the middle
+        assert_eq!(
+            GblEfiPartitionName::from([0x006d, 0x0075, 0x0000, 0x0073, 0x0069, 0x0063])
+                .get_str(&mut buffer),
+            Ok("mu")
+        );
+
+        // Null character at the end
+        assert_eq!(
+            GblEfiPartitionName::from([0x006d, 0x0075, 0x0073, 0x0069, 0x0063, 0x0000])
+                .get_str(&mut buffer),
+            Ok("music")
+        );
+
+        // exact buffer size
+        assert_eq!(
+            GblEfiPartitionName::from([0x006d, 0x0075, 0x0073, 0x0069, 0x0063])
+                .get_str(&mut buffer[..5]),
+            Ok("music")
+        );
+        assert_eq!(
+            GblEfiPartitionName::from([0x006d, 0x0075, 0x0000, 0x0073, 0x0069, 0x0063])
+                .get_str(&mut buffer[..2]),
+            Ok("mu")
+        );
+    }
+
+    #[test]
+    fn test_partition_name_get_str_small_buffer() {
+        let mut buffer = [0u8; 8];
+        let partition_name: GblEfiPartitionName = UCS2_STR.into();
+        assert_eq!(partition_name.get_str(&mut buffer), Err(10usize));
+    }
+
+    fn generate_protocol<'a, P: ProtocolInfo>(
+        efi_entry: &'a EfiEntry,
+        proto: &'a mut P::InterfaceType,
+    ) -> Protocol<'a, P> {
+        // SAFETY:
+        // proto is a valid pointer and lasts at least as long as efi_entry.
+        unsafe { Protocol::<'a, P>::new(DeviceHandle::new(null_mut()), proto, efi_entry) }
+    }
+
+    #[test]
+    fn test_proto_get_partitions_count() {
+        const EXPECTED_PARTITIONS_NUM: usize = 2;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            _: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            assert!(!number_of_partitions.is_null());
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+
+            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+            EFI_STATUS_BUFFER_TOO_SMALL
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
+            assert_eq!(
+                protocol.get_verify_partitions(&mut partitions).unwrap_err(),
+                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
+            );
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_count_error() {
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            _: *mut usize,
+            _: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
+            assert_eq!(
+                protocol.get_verify_partitions(&mut partitions).unwrap_err(),
+                Error::InvalidInput
+            );
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_len_and_value() {
+        const EXPECTED_PARTITIONS_NUM: usize = 1;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            partitions: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+
+            match *number_of_partitions {
+                n if n < EXPECTED_PARTITIONS_NUM => {
+                    *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+                    EFI_STATUS_BUFFER_TOO_SMALL
+                }
+                _ => {
+                    // SAFETY
+                    // `partitions` must be valid array of size `number_of_partitions`
+                    let partitions = unsafe {
+                        core::slice::from_raw_parts_mut(partitions, *number_of_partitions)
+                    };
+                    *number_of_partitions = 1;
+                    partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
+                    EFI_STATUS_SUCCESS
+                }
+            }
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut buffer_utf8 = get_buffer_utf8();
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
+
+            assert_eq!(
+                protocol.get_verify_partitions(&mut partitions[..0]).unwrap_err(),
+                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
+            );
+            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
+            assert_eq!(verify_partitions_len, 1);
+            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_zero_len() {
+        const EXPECTED_PARTITIONS_NUM: usize = 1;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            _: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+            assert_eq!(*number_of_partitions, 0);
+            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+            EFI_STATUS_BUFFER_TOO_SMALL
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; 0] = Default::default();
+
+            let verify_partitions_res = protocol.get_verify_partitions(&mut partitions);
+            assert_eq!(
+                verify_partitions_res.unwrap_err(),
+                Error::BufferTooSmall(Some(EXPECTED_PARTITIONS_NUM))
+            );
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_less_than_buffer() {
+        const EXPECTED_PARTITIONS_NUM: usize = 1;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            partitions: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+
+            assert!(!partitions.is_null());
+            assert!(*number_of_partitions > 0);
+
+            // SAFETY
+            // `partitions` must be valid array of size `number_of_partitions`
+            let partitions =
+                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
+            partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
+            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut buffer_utf8 = get_buffer_utf8();
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
+
+            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
+            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
+            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_name_max() {
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            partitions: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            let printable_utf16 = get_printable_utf16();
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+
+            assert!(!partitions.is_null());
+            assert!(*number_of_partitions > 0);
+
+            // SAFETY
+            // `partitions` must be valid array of size `number_of_partitions`
+            let partitions =
+                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
+
+            let partition_names: [GblEfiPartitionName; PARTITIONS_MAX] = (0
+                ..PARTITION_NAME_LEN_U16)
+                .cycle()
+                .take(PARTITIONS_MAX)
+                .map(|i| printable_utf16[i..i + PARTITION_NAME_LEN_U16].into())
+                .collect::<Vec<_>>()
+                .try_into()
+                .unwrap();
+
+            *number_of_partitions = partition_names.len();
+
+            for (p_out, p_gen) in zip(partitions.iter_mut(), partition_names.iter()) {
+                *p_out = *p_gen;
+            }
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut buffer_utf8 = get_buffer_utf8();
+            let printable_str = get_printable_string();
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions = [GblEfiPartitionName::default(); PARTITIONS_MAX];
+            let expected_strs: Vec<&str> = (0..PARTITION_NAME_LEN_U16)
+                .cycle()
+                .take(PARTITIONS_MAX)
+                .map(|i| &printable_str[i..i + PARTITION_NAME_LEN_U16])
+                .collect();
+
+            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
+            assert_eq!(verify_partitions_len, PARTITIONS_MAX);
+
+            assert!(zip(partitions.iter(), expected_strs.iter())
+                .all(|(p, expected_str)| { p.get_str(&mut buffer_utf8[0]) == Ok(*expected_str) }));
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions() {
+        const EXPECTED_PARTITIONS_NUM: usize = 2;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            partitions: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+
+            assert!(!partitions.is_null());
+            assert!(*number_of_partitions > 0);
+
+            // SAFETY
+            // `partitions` must be valid array of size `number_of_partitions`
+            let partitions =
+                unsafe { core::slice::from_raw_parts_mut(partitions, *number_of_partitions) };
+            partitions[0].StrUtf16[..UCS2_STR.len()].copy_from_slice(&UCS2_STR);
+            partitions[1].StrUtf16[..UCS2_STR.len() - 1].copy_from_slice(&UCS2_STR[1..]);
+            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut buffer_utf8 = get_buffer_utf8();
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; EXPECTED_PARTITIONS_NUM] = Default::default();
+
+            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
+            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
+
+            let mut char_idx = UTF8_STR.char_indices();
+            char_idx.next();
+            let (next_char_pos, _) = char_idx.next().unwrap();
+
+            assert_eq!(partitions[0].get_str(&mut buffer_utf8[0]), Ok(UTF8_STR));
+            assert_eq!(partitions[1].get_str(&mut buffer_utf8[1]), Ok(&UTF8_STR[next_char_pos..]));
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_empty() {
+        const EXPECTED_PARTITIONS_NUM: usize = 0;
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            number_of_partitions: *mut usize,
+            partitions: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            // SAFETY
+            // `number_of_partitions` must be valid pointer to usize
+            let number_of_partitions = unsafe { number_of_partitions.as_mut() }.unwrap();
+            assert!(!partitions.is_null());
+            *number_of_partitions = EXPECTED_PARTITIONS_NUM;
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; 2] = Default::default();
+
+            let verify_partitions_len = protocol.get_verify_partitions(&mut partitions).unwrap();
+            assert_eq!(verify_partitions_len, EXPECTED_PARTITIONS_NUM);
+        });
+    }
+
+    #[test]
+    fn test_proto_get_partitions_error() {
+        unsafe extern "C" fn get_verify_partitions(
+            _: *mut GblEfiImageLoadingProtocol,
+            _: *mut usize,
+            _: *mut GblEfiPartitionName,
+        ) -> EfiStatus {
+            EFI_STATUS_BAD_BUFFER_SIZE
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_loading = GblEfiImageLoadingProtocol {
+                get_verify_partitions: Some(get_verify_partitions),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+            let mut partitions: [GblEfiPartitionName; 1] = Default::default();
+
+            assert!(protocol.get_verify_partitions(&mut partitions).is_err());
+        });
+    }
+
+    // Mutex to make sure tests that use `static RETURNED_BUFFERS` do not run in parallel to avoid
+    // unexpected results since this is global static that would be shared between tests.
+    static GET_BUFFER_MUTEX: Mutex<()> = Mutex::new(());
+    #[test]
+    fn test_proto_get_buffer_error() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            _: *const GblEfiImageInfo,
+            _: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo = Default::default();
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            assert!(protocol.get_buffer(&gbl_image_info).is_err());
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer_not_provided() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            buffer.Memory = null_mut();
+            buffer.SizeBytes = 10;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo = Default::default();
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let res = protocol.get_buffer(&gbl_image_info);
+            assert_eq!(res.unwrap_err(), Error::InvalidInput);
+        });
+    }
+
+    fn get_memory() -> Box<[u8; 100]> {
+        Box::new([0; 100])
+    }
+
+    #[test]
+    fn test_proto_get_buffer_zero_size() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+            buffer.SizeBytes = 0;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo = Default::default();
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let res = protocol.get_buffer(&gbl_image_info).unwrap();
+            assert!(res.buffer.as_ref().unwrap().is_empty());
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer_small() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            // SAFETY
+            // `image_info` must be valid pointer to `GblEfiImageInfo`
+            let image_info = unsafe { image_info.as_ref() }.unwrap();
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+            buffer.SizeBytes = image_info.SizeBytes - 1;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 10 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let res = protocol.get_buffer(&gbl_image_info);
+            assert_eq!(res.unwrap_err(), Error::BufferTooSmall(Some(10)));
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            let mem = get_memory();
+            buffer.SizeBytes = mem.len();
+            buffer.Memory = Box::leak(mem).as_mut_ptr() as *mut c_void;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let buf = protocol.get_buffer(&gbl_image_info).unwrap();
+            assert_ne!(buf.buffer.as_ref().unwrap().as_ptr(), null_mut());
+            assert_eq!(buf.buffer.as_ref().unwrap().len(), 100);
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer_image_type() {
+        const IMAGE_TYPE_STR: &'static str = "test";
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            // SAFETY
+            // `image_info` must be valid pointer to `GblEfiImageInfo`
+            let image_info = unsafe { image_info.as_ref() }.unwrap();
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            let mut buffer_utf8 = [0u8; 100];
+            assert_eq!(
+                GblEfiPartitionName::from(image_info.ImageType).get_str(&mut buffer_utf8).unwrap(),
+                IMAGE_TYPE_STR
+            );
+
+            let mem = get_memory();
+            buffer.SizeBytes = mem.len();
+            buffer.Memory = Box::leak(mem).as_mut_ptr() as *mut c_void;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut image_type = [0u16; PARTITION_NAME_LEN_U16];
+            image_type[..4].copy_from_slice(&IMAGE_TYPE_STR.encode_utf16().collect::<Vec<u16>>());
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: image_type, SizeBytes: 100 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let res = protocol.get_buffer(&gbl_image_info);
+            assert!(res.is_ok());
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer_double_call() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            let mem = get_memory();
+            buffer.SizeBytes = mem.len();
+            buffer.Memory = 0x1000 as *mut c_void;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let _buf = protocol.get_buffer(&gbl_image_info).unwrap();
+            assert_eq!(protocol.get_buffer(&gbl_image_info).unwrap_err(), Error::AlreadyStarted);
+        });
+    }
+
+    #[test]
+    fn test_proto_get_buffer_double_call_after_drop() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            let mem = get_memory();
+            buffer.SizeBytes = mem.len();
+            buffer.Memory = 0x2000 as *mut c_void;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            protocol.get_buffer(&gbl_image_info).unwrap();
+            protocol.get_buffer(&gbl_image_info).unwrap();
+        });
+    }
+
+    #[test]
+    #[should_panic]
+    fn test_proto_get_buffer_too_many_times() {
+        unsafe extern "C" fn get_buffer(
+            _: *mut GblEfiImageLoadingProtocol,
+            image_info: *const GblEfiImageInfo,
+            buffer: *mut GblEfiImageBuffer,
+        ) -> EfiStatus {
+            assert!(!image_info.is_null());
+            assert!(!buffer.is_null());
+            // SAFETY
+            // `buffer` must be valid pointer to `GblEfiImageBuffer`
+            let buffer = unsafe { buffer.as_mut() }.unwrap();
+
+            let mem = get_memory();
+            buffer.SizeBytes = mem.len();
+            // Make sure to return different memory
+            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let gbl_image_info: GblEfiImageInfo =
+                GblEfiImageInfo { ImageType: [0; PARTITION_NAME_LEN_U16], SizeBytes: 100 };
+            let mut image_loading =
+                GblEfiImageLoadingProtocol { get_buffer: Some(get_buffer), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol =
+                generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
+
+            let _guard = GET_BUFFER_MUTEX.lock();
+            let mut keep_alive: Vec<EfiImageBuffer> = vec![];
+            for _ in 1..=MAX_ARRAY_SIZE + 1 {
+                keep_alive.push(protocol.get_buffer(&gbl_image_info).unwrap());
+            }
+        });
+    }
+
+    #[test]
+    fn test_efi_image_buffer() {
+        let mut v = vec![0u8; 1];
+        let gbl_buffer =
+            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
+
+        let _guard = GET_BUFFER_MUTEX.lock();
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert!(res.is_ok());
+    }
+
+    #[test]
+    fn test_efi_image_buffer_null() {
+        let gbl_buffer = GblEfiImageBuffer { Memory: null_mut(), SizeBytes: 1 };
+
+        let _guard = GET_BUFFER_MUTEX.lock();
+        // SAFETY:
+        // 'gbl_buffer` contains Memory == NULL, which is valid input value. And we expect Error as
+        // a result
+        let res = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert_eq!(res.unwrap_err(), Error::InvalidInput);
+    }
+
+    #[test]
+    fn test_efi_image_buffer_same_buffer() {
+        let mut v = vec![0u8; 1];
+        let gbl_buffer =
+            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
+
+        let _guard = GET_BUFFER_MUTEX.lock();
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert!(res1.is_ok());
+
+        // Since we keep `res1`, second return of same buffer should fail
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert_eq!(res2.unwrap_err(), Error::AlreadyStarted);
+    }
+
+    #[test]
+    fn test_efi_image_buffer_same_buffer_after_drop() {
+        let mut v = vec![0u8; 1];
+        let gbl_buffer =
+            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
+
+        let _guard = GET_BUFFER_MUTEX.lock();
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        drop(res1);
+
+        // Since `res1` was dropped same buffer can be returned.
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert!(res2.is_ok());
+    }
+
+    #[test]
+    fn test_efi_image_buffer_take() {
+        let mut v = vec![0u8; 1];
+        let gbl_buffer =
+            GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
+
+        let _guard = GET_BUFFER_MUTEX.lock();
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) }.unwrap();
+        let _tmp = res1.take();
+
+        // Since `res1` was taken, we can't reuse same buffer.
+        // SAFETY:
+        // 'gbl_buffer` represents valid buffer created by vector.
+        let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
+        assert_eq!(res2.unwrap_err(), Error::AlreadyStarted);
+    }
+}
diff --git a/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs b/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
new file mode 100644
index 0000000..d482ca5
--- /dev/null
+++ b/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
@@ -0,0 +1,256 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `GBL_EFI_OS_CONFIGURATION_PROTOCOL`.
+
+use crate::efi_call;
+use crate::protocol::{Protocol, ProtocolInfo};
+use efi_types::{EfiGuid, GblEfiOsConfigurationProtocol};
+use liberror::Result;
+
+/// `GBL_EFI_OS_CONFIGURATION_PROTOCOL` implementation.
+pub struct GblOsConfigurationProtocol;
+
+impl ProtocolInfo for GblOsConfigurationProtocol {
+    type InterfaceType = GblEfiOsConfigurationProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0xdda0d135, 0xaa5b, 0x42ff, [0x85, 0xac, 0xe3, 0xad, 0x6e, 0xfb, 0x46, 0x19]);
+}
+
+// Protocol interface wrappers.
+impl Protocol<'_, GblOsConfigurationProtocol> {
+    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupKernelCommandline()`
+    pub fn fixup_kernel_commandline(&self, data: &mut [u8]) -> Result<usize> {
+        let mut buffer_size = data.len();
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * all arguments are only borrowed for the call and will not be retained.
+        unsafe {
+            efi_call!(
+                @bufsize buffer_size,
+                self.interface()?.fixup_kernel_commandline,
+                self.interface,
+                data.as_mut_ptr(),
+                &mut buffer_size
+            )?;
+        }
+
+        Ok(buffer_size)
+    }
+
+    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootconfig()`
+    pub fn fixup_bootconfig(&self, data: &mut [u8]) -> Result<usize> {
+        let mut buffer_size = data.len();
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * all arguments are only borrowed for the call and will not be retained.
+        unsafe {
+            efi_call!(
+                @bufsize buffer_size,
+                self.interface()?.fixup_bootconfig,
+                self.interface,
+                data.as_mut_ptr(),
+                &mut buffer_size
+            )?;
+        }
+
+        // TODO(b/354021403): figure out how to report EFI_BUFFER_TOO_SMALL buffer size. For now
+        // we just drop the updated `buffer_size`.
+
+        Ok(buffer_size)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use crate::test::run_test_with_mock_protocol;
+    use efi_types::{EfiStatus, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS};
+    use liberror::Error;
+    use std::{
+        ffi::{CStr, CString},
+        slice,
+    };
+
+    #[test]
+    fn fixup_kernel_commandline_no_op() {
+        // No-op C callback implementation.
+        unsafe extern "C" fn c_return_success(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *mut u8,
+            _: *mut usize,
+        ) -> EfiStatus {
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_kernel_commandline: Some(c_return_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut commandline = CString::new("foo=bar baz").unwrap().into_bytes_with_nul();
+            assert!(os_config_protocol.fixup_kernel_commandline(&mut commandline[..]).is_ok());
+        });
+    }
+
+    #[test]
+    fn fixup_kernel_commandline_add_arg() {
+        // C callback implementation to add " 123" to the given command line.
+        unsafe extern "C" fn c_add_123(
+            _: *mut GblEfiOsConfigurationProtocol,
+            data: *mut u8,
+            buffer_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * we pass a valid `data` buffer of length `buffer_size`
+            // * this function has exclusive access to the buffer while it's executing
+            let commandline =
+                unsafe { slice::from_raw_parts_mut(data, *buffer_size.as_ref().unwrap()) };
+
+            let nul_pos = commandline.iter().position(|c| *c == b'\0').unwrap();
+            commandline[nul_pos..nul_pos + 5].copy_from_slice(b" 123\0");
+
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_kernel_commandline: Some(c_add_123),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut commandline = CString::new("foo=bar baz").unwrap().into_bytes_with_nul();
+            // Add 4 extra bytes to the command line buffer so the C callback can add its data.
+            commandline.extend_from_slice(b"\0\0\0\0");
+            assert_eq!(
+                os_config_protocol.fixup_kernel_commandline(&mut commandline[..]),
+                Ok(commandline.len()),
+            );
+            assert_eq!(
+                CStr::from_bytes_until_nul(&commandline[..]).unwrap(),
+                CString::new("foo=bar baz 123").unwrap().as_c_str()
+            );
+        });
+    }
+
+    #[test]
+    fn fixup_kernel_commandline_error() {
+        // C callback implementation to return an error.
+        unsafe extern "C" fn c_error(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *mut u8,
+            _: *mut usize,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_kernel_commandline: Some(c_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            assert_eq!(
+                os_config_protocol.fixup_kernel_commandline(&mut []),
+                Err(Error::InvalidInput),
+            );
+        });
+    }
+
+    #[test]
+    fn fixup_bootconfig_no_op() {
+        // No-op C callback implementation.
+        unsafe extern "C" fn c_return_success(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *mut u8,
+            _: *mut usize,
+        ) -> EfiStatus {
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_bootconfig: Some(c_return_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut bootconfig = CString::new("foo=bar\nbaz").unwrap().into_bytes_with_nul();
+            assert!(os_config_protocol.fixup_bootconfig(&mut bootconfig[..]).is_ok());
+        });
+    }
+
+    #[test]
+    fn fixup_fixup_bootconfig_add_arg() {
+        // C callback implementation to add "\n123" to the given bootconfig.
+        unsafe extern "C" fn c_add_123(
+            _: *mut GblEfiOsConfigurationProtocol,
+            data: *mut u8,
+            buffer_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * we pass a valid `data` buffer of length `buffer_size`
+            // * this function has exclusive access to the buffer while it's executing
+            let bootconfig =
+                unsafe { slice::from_raw_parts_mut(data, *buffer_size.as_ref().unwrap()) };
+
+            let nul_pos = bootconfig.iter().position(|c| *c == b'\0').unwrap();
+            bootconfig[nul_pos..nul_pos + 5].copy_from_slice(b"\n123\0");
+
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_bootconfig: Some(c_add_123),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut bootconfig = CString::new("foo=bar\nbaz").unwrap().into_bytes_with_nul();
+            // Add 4 extra bytes to the command line buffer so the C callback can add its data.
+            bootconfig.extend_from_slice(b"\0\0\0\0");
+            assert_eq!(
+                os_config_protocol.fixup_bootconfig(&mut bootconfig[..]),
+                Ok(bootconfig.len()),
+            );
+            assert_eq!(
+                CStr::from_bytes_until_nul(&bootconfig[..]).unwrap(),
+                CString::new("foo=bar\nbaz\n123").unwrap().as_c_str()
+            );
+        });
+    }
+
+    #[test]
+    fn fixup_bootconfig_error() {
+        // C callback implementation to return an error.
+        unsafe extern "C" fn c_error(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *mut u8,
+            _: *mut usize,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface =
+            GblEfiOsConfigurationProtocol { fixup_bootconfig: Some(c_error), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            assert_eq!(os_config_protocol.fixup_bootconfig(&mut []), Err(Error::InvalidInput),);
+        });
+    }
+}
diff --git a/gbl/libefi/src/protocol/loaded_image.rs b/gbl/libefi/src/protocol/loaded_image.rs
index bc7cfad..979c17b 100644
--- a/gbl/libefi/src/protocol/loaded_image.rs
+++ b/gbl/libefi/src/protocol/loaded_image.rs
@@ -12,9 +12,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{EfiGuid, EfiLoadedImageProtocol};
+//! Rust wrapper for `EFI_LOADED_IMAGE_PROTOCOL`.
+
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{DeviceHandle, EfiResult};
+use crate::DeviceHandle;
+use efi_types::{EfiGuid, EfiLoadedImageProtocol};
+use liberror::Result;
 
 /// EFI_LOADED_IMAGE_PROTOCOL
 pub struct LoadedImageProtocol;
@@ -27,7 +30,8 @@ impl ProtocolInfo for LoadedImageProtocol {
 }
 
 impl<'a> Protocol<'a, LoadedImageProtocol> {
-    pub fn device_handle(&self) -> EfiResult<DeviceHandle> {
+    /// Wraps `EFI_LOADED_IMAGE_PROTOCOL.DeviceHandle`.
+    pub fn device_handle(&self) -> Result<DeviceHandle> {
         Ok(DeviceHandle(self.interface()?.device_handle))
     }
 }
diff --git a/gbl/libefi/src/protocol/riscv.rs b/gbl/libefi/src/protocol/riscv.rs
index d3ab138..dc01626 100644
--- a/gbl/libefi/src/protocol/riscv.rs
+++ b/gbl/libefi/src/protocol/riscv.rs
@@ -12,9 +12,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{EfiGuid, EfiRiscvBootProtocol, EFI_STATUS_NOT_FOUND};
+//! Rust wrapper for `RISCV_EFI_BOOT_PROTOCOL`.
+
+use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiResult};
+use efi_types::{EfiGuid, EfiRiscvBootProtocol};
+use liberror::Result;
 
 /// RISCV_EFI_BOOT_PROTOCOL
 pub struct RiscvBootProtocol;
@@ -27,7 +30,8 @@ impl ProtocolInfo for RiscvBootProtocol {
 }
 
 impl<'a> Protocol<'a, RiscvBootProtocol> {
-    pub fn get_boot_hartid(&self) -> EfiResult<usize> {
+    /// Wraps `RISCV_EFI_BOOT_PROTOCOL.GetBootHartId()`.
+    pub fn get_boot_hartid(&self) -> Result<usize> {
         let mut boot_hart_id: usize = 0;
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
@@ -40,7 +44,8 @@ impl<'a> Protocol<'a, RiscvBootProtocol> {
         Ok(boot_hart_id)
     }
 
-    pub fn revision(&self) -> EfiResult<u64> {
+    /// Wraps `RISCV_EFI_BOOT_PROTOCOL.Revision`.
+    pub fn revision(&self) -> Result<u64> {
         Ok(self.interface()?.revision)
     }
 }
diff --git a/gbl/libefi/src/protocol/simple_network.rs b/gbl/libefi/src/protocol/simple_network.rs
index 1a621e0..ad8b695 100644
--- a/gbl/libefi/src/protocol/simple_network.rs
+++ b/gbl/libefi/src/protocol/simple_network.rs
@@ -12,13 +12,18 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{
-    EfiGuid, EfiMacAddress, EfiSimpleNetworkMode, EfiSimpleNetworkProtocol, EFI_STATUS_NOT_FOUND,
-};
+//! Rust wrapper for `EFI_SIMPLE_NETWORK_PROTOCOL`.
+
+use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiResult};
 use core::ffi::c_void;
 use core::ptr::null_mut;
+use efi_types::{
+    EfiGuid, EfiMacAddress, EfiSimpleNetworkMode, EfiSimpleNetworkProtocol,
+    EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS, EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST,
+    EFI_SIMPLE_NETWORK_RECEIVE_UNICAST,
+};
+use liberror::{Error, Result};
 
 /// EFI_SIMPLE_NETWORK_PROTOCOL
 pub struct SimpleNetworkProtocol;
@@ -32,7 +37,7 @@ impl ProtocolInfo for SimpleNetworkProtocol {
 
 impl<'a> Protocol<'a, SimpleNetworkProtocol> {
     /// Wrapper of `EFI_SIMPLE_NETWORK.Start()`
-    pub fn start(&self) -> EfiResult<()> {
+    pub fn start(&self) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees to return a valid object pointer as established by
         // `Protocol::new()`.
@@ -41,13 +46,13 @@ impl<'a> Protocol<'a, SimpleNetworkProtocol> {
     }
 
     /// Wrapper of `EFI_SIMPLE_NETWORK.Stop()`
-    pub fn stop(&self) -> EfiResult<()> {
+    pub fn stop(&self) -> Result<()> {
         // SAFETY: See safety reasoning of `start()`.
         unsafe { efi_call!(self.interface()?.stop, self.interface) }
     }
 
     /// Wrapper of `EFI_SIMPLE_NETWORK.Initialize()`
-    pub fn initialize(&self, extra_rx_buf_size: usize, extra_tx_buf_size: usize) -> EfiResult<()> {
+    pub fn initialize(&self, extra_rx_buf_size: usize, extra_tx_buf_size: usize) -> Result<()> {
         // SAFETY: See safety reasoning of `start()`.
         unsafe {
             efi_call!(
@@ -60,23 +65,49 @@ impl<'a> Protocol<'a, SimpleNetworkProtocol> {
     }
 
     /// Wrapper of `EFI_SIMPLE_NETWORK.Reset()`
-    pub fn reset(&self, extended_verification: bool) -> EfiResult<()> {
+    pub fn reset(&self, extended_verification: bool) -> Result<()> {
         // SAFETY: See safety reasoning of `start()`.
         unsafe { efi_call!(self.interface()?.reset, self.interface, extended_verification) }
     }
 
     /// Wrapper of `EFI_SIMPLE_NETWORK.Shutdown()`
-    pub fn shutdown(&self) -> EfiResult<()> {
+    pub fn shutdown(&self) -> Result<()> {
         // SAFETY: See safety reasoning of `start()`.
         unsafe { efi_call!(self.interface()?.shutdown, self.interface) }
     }
 
+    /// Wrapper of `EFI_SIMPLE_NETWORK.ReceiveFilters()`
+    pub fn receive_filters(
+        &self,
+        enable: u32,
+        disable: u32,
+        reset_mcast_filter: bool,
+        mcast_filter: &mut [EfiMacAddress],
+    ) -> Result<()> {
+        // SAFETY:
+        // `self.interface()?` guarantees to return a valid object pointer as established by
+        // `Protocol::new()`.
+        // `self.interface` outlives the call and will not be retained.
+        // `mcast_filter` is for input only. It outlives the call and will not be retained.
+        unsafe {
+            efi_call!(
+                self.interface()?.receive_filters,
+                self.interface,
+                enable,
+                disable,
+                reset_mcast_filter,
+                mcast_filter.len(),
+                mcast_filter.as_mut_ptr()
+            )
+        }
+    }
+
     /// Wrapper of `EFI_SIMPLE_NETWORK.GetStatus()`
     pub fn get_status(
         &self,
         interrupt_status: Option<&mut u32>,
         recycle_buffer: Option<&mut *mut c_void>,
-    ) -> EfiResult<()> {
+    ) -> Result<()> {
         // SAFETY:
         // See safety reasoning of `start()`.
         // Pointers to `interrupt_status`, `recycled_buffer` are valid during the call and for
@@ -109,8 +140,9 @@ impl<'a> Protocol<'a, SimpleNetworkProtocol> {
         mut src: EfiMacAddress,
         mut dest: EfiMacAddress,
         mut protocol: u16,
-    ) -> EfiResult<()> {
-        let buf = buf.as_mut().unwrap();
+    ) -> Result<()> {
+        // SAFETY: function safety docs require valid `buf`.
+        let buf = unsafe { buf.as_mut() }.unwrap();
         // SAFETY:
         // See safety reasoning of `start()`.
         // All pointers passed are valid, outlive the call and are not retained by the call.
@@ -137,7 +169,7 @@ impl<'a> Protocol<'a, SimpleNetworkProtocol> {
         src: Option<&mut EfiMacAddress>,
         dest: Option<&mut EfiMacAddress>,
         protocol: Option<&mut u16>,
-    ) -> EfiResult<()> {
+    ) -> Result<()> {
         // SAFETY:
         // See safety reasoning of `start()`.
         // All pointers passed are valid, outlive the call and are not retained by the call.
@@ -157,9 +189,21 @@ impl<'a> Protocol<'a, SimpleNetworkProtocol> {
     }
 
     /// Returns `EFI_SIMPLE_NETWORK.Mode` structure
-    pub fn mode(&self) -> EfiResult<EfiSimpleNetworkMode> {
+    pub fn mode(&self) -> Result<EfiSimpleNetworkMode> {
         // SAFETY: Non-null pointer from UEFI interface points to valid object.
-        unsafe { self.interface()?.mode.as_ref() }.ok_or(EFI_STATUS_NOT_FOUND.into()).copied()
+        unsafe { self.interface()?.mode.as_ref() }.ok_or(Error::NotFound).copied()
+    }
+
+    /// Sets to promiscuous mode to receive all packets over the network.
+    pub fn set_promiscuous_mode(&self) -> Result<()> {
+        self.receive_filters(
+            EFI_SIMPLE_NETWORK_RECEIVE_UNICAST
+                | EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS
+                | EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST,
+            0,
+            false,
+            &mut [],
+        )
     }
 }
 
diff --git a/gbl/libefi/src/protocol/simple_text_input.rs b/gbl/libefi/src/protocol/simple_text_input.rs
index 61f4be2..4fbba23 100644
--- a/gbl/libefi/src/protocol/simple_text_input.rs
+++ b/gbl/libefi/src/protocol/simple_text_input.rs
@@ -12,11 +12,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{
-    EfiGuid, EfiInputKey, EfiSimpleTextInputProtocol, EFI_STATUS_NOT_FOUND, EFI_STATUS_NOT_READY,
-};
+//! Rust wrapper for `EFI_SIMPLE_TEXT_INPUT_PROTOCOL`.
+
+use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiResult};
+use efi_types::{EfiGuid, EfiInputKey, EfiSimpleTextInputProtocol};
+use liberror::{Error, Result};
 
 /// EFI_SIMPLE_TEXT_INPUT_PROTOCOL
 pub struct SimpleTextInputProtocol;
@@ -30,7 +31,7 @@ impl ProtocolInfo for SimpleTextInputProtocol {
 
 impl Protocol<'_, SimpleTextInputProtocol> {
     /// Wrapper of `EFI_SIMPLE_TEXT_INPUT_PROTOCOL.reset()`
-    pub fn reset(&self, extendend_verification: bool) -> EfiResult<()> {
+    pub fn reset(&self, extendend_verification: bool) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -42,7 +43,7 @@ impl Protocol<'_, SimpleTextInputProtocol> {
     ///
     /// Returns `Ok(Some(EfiInputKey))` if there is a key stroke, Ok(None) if no key stroke is
     /// pressed.
-    pub fn read_key_stroke(&self) -> EfiResult<Option<EfiInputKey>> {
+    pub fn read_key_stroke(&self) -> Result<Option<EfiInputKey>> {
         let mut key: EfiInputKey = Default::default();
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
@@ -51,7 +52,7 @@ impl Protocol<'_, SimpleTextInputProtocol> {
         // `key` is an output argument. It outlives the call and will not be taken.
         match unsafe { efi_call!(self.interface()?.read_key_stroke, self.interface, &mut key) } {
             Ok(()) => Ok(Some(key)),
-            Err(e) if e.is_efi_err(EFI_STATUS_NOT_READY) => Ok(None),
+            Err(Error::NotReady) => Ok(None),
             Err(e) => Err(e),
         }
     }
diff --git a/gbl/libefi/src/protocol/simple_text_output.rs b/gbl/libefi/src/protocol/simple_text_output.rs
index ac27601..3e22847 100644
--- a/gbl/libefi/src/protocol/simple_text_output.rs
+++ b/gbl/libefi/src/protocol/simple_text_output.rs
@@ -12,12 +12,13 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::defs::{
-    char16_t, EfiGuid, EfiSimpleTextOutputProtocol, EFI_STATUS_NOT_FOUND, EFI_STATUS_UNSUPPORTED,
-};
+//! Rust wrapper for `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL`.
+
+use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use crate::{efi_call, map_efi_err, EfiError, EfiResult};
 use core::fmt::Write;
+use efi_types::{char16_t, EfiGuid, EfiSimpleTextOutputProtocol};
+use liberror::Result;
 
 /// EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL
 pub struct SimpleTextOutputProtocol;
@@ -31,7 +32,7 @@ impl ProtocolInfo for SimpleTextOutputProtocol {
 
 impl Protocol<'_, SimpleTextOutputProtocol> {
     /// Wrapper of `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.OutputString()`
-    pub fn output_string(&self, msg: *mut char16_t) -> EfiResult<()> {
+    pub fn output_string(&self, msg: *mut char16_t) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees `self.interface` is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -58,11 +59,3 @@ impl Write for Protocol<'_, SimpleTextOutputProtocol> {
         Ok(())
     }
 }
-
-// A convenient convert to forward error when using write!() on
-// Protocol<SimpleTextOutputProtocol>.
-impl From<core::fmt::Error> for EfiError {
-    fn from(_: core::fmt::Error) -> EfiError {
-        EFI_STATUS_UNSUPPORTED.into()
-    }
-}
diff --git a/gbl/libefi/src/utils.rs b/gbl/libefi/src/utils.rs
new file mode 100644
index 0000000..f226687
--- /dev/null
+++ b/gbl/libefi/src/utils.rs
@@ -0,0 +1,84 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file provides some utilities built on EFI APIs.
+
+use crate::{EfiEntry, Event, EventType};
+use core::future::Future;
+use efi_types::EFI_TIMER_DELAY_TIMER_RELATIVE;
+use gbl_async::{select, yield_now};
+use liberror::Result;
+use safemath::SafeNum;
+
+/// Converts 1 ms to number of 100 nano seconds
+pub fn ms_to_100ns(ms: u64) -> Result<u64> {
+    Ok((SafeNum::from(ms) * 10 * 1000).try_into()?)
+}
+
+/// `Timeout` provide APIs for checking timeout.
+pub struct Timeout<'a> {
+    efi_entry: &'a EfiEntry,
+    timer: Event<'a, 'static>,
+}
+
+impl<'a> Timeout<'a> {
+    /// Creates a new instance and starts the timeout timer.
+    pub fn new(efi_entry: &'a EfiEntry, timeout_ms: u64) -> Result<Self> {
+        let bs = efi_entry.system_table().boot_services();
+        let timer = bs.create_event(EventType::Timer)?;
+        bs.set_timer(&timer, EFI_TIMER_DELAY_TIMER_RELATIVE, ms_to_100ns(timeout_ms)?)?;
+        Ok(Self { efi_entry, timer })
+    }
+
+    /// Checks if it has timeout.
+    pub fn check(&self) -> Result<bool> {
+        Ok(self.efi_entry.system_table().boot_services().check_event(&self.timer)?)
+    }
+
+    /// Resets the timeout.
+    pub fn reset(&self, timeout_ms: u64) -> Result<()> {
+        let bs = self.efi_entry.system_table().boot_services();
+        bs.set_timer(&self.timer, EFI_TIMER_DELAY_TIMER_RELATIVE, ms_to_100ns(timeout_ms)?)?;
+        Ok(())
+    }
+}
+
+/// Waits for a given amount of time.
+pub async fn wait(efi_entry: &EfiEntry, duration_ms: u64) -> Result<()> {
+    // EFI boot service has a `stall` API. But it's not async.
+    let timeout = Timeout::new(efi_entry, duration_ms)?;
+    while !timeout.check()? {
+        yield_now().await;
+    }
+    Ok(())
+}
+
+/// Runs a future with timeout.
+///
+/// # Returns
+///
+/// * Returns Ok(Some(R)) if the future finishes before timeout.
+/// * Returns Ok(None) if the future didn't finish before timeout.
+/// * Returns Err if internal error occurs while handling EFI timer event.
+pub async fn with_timeout<F: Future<Output = R>, R>(
+    efi_entry: &EfiEntry,
+    fut: F,
+    timeout_ms: u64,
+) -> Result<Option<R>> {
+    let (timeout_res, res) = select(wait(efi_entry, timeout_ms), fut).await;
+    match timeout_res {
+        Some(Err(e)) => return Err(e),
+        _ => Ok(res),
+    }
+}
diff --git a/gbl/libefi_types/BUILD b/gbl/libefi_types/BUILD
new file mode 100644
index 0000000..f689b9d
--- /dev/null
+++ b/gbl/libefi_types/BUILD
@@ -0,0 +1,105 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
+load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
+
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+# Newer version of `rust_bindgen` requires a `cc_library` target that actually produces a static
+# library and instead of only headers. Thus we generate a placeholder source file to meet the
+# requirement.
+genrule(
+    name = "bindgen_noop_cc",
+    outs = ["bindgen_noop_cc.cc"],
+    cmd = "touch $(OUTS)",
+)
+
+cc_library(
+    name = "efi_c_headers",
+    srcs = [":bindgen_noop_cc"],
+    hdrs = glob(["defs/**/*.h"]),
+    includes = ["defs"],
+)
+
+# Side note: function pointers for UEFI interfaces need to specify the "efiapi" ABI. i.e.
+# "unsafe extern "efiapi" fn(...)". bindgen uses "extern "C"" by default. We are currently fine
+# because for x86_64/x86_32/aarch64, we use dedicated rust UEFI compiler which uses EFIAPI ABI by
+# default. For riscv64 which we use ELF compiler, the efiapi calling convention is the same as C
+# calling convention according to the UEFI spec at the time of writing. If we do eventually run
+# into problems, we need to use a newer version of bindgen 0.65.0 or above, which offers
+# "--override-abi" with "efiapi" option.
+rust_bindgen(
+    name = "efi_defs_bindgen",
+    bindgen_flags = [
+        "--ctypes-prefix",
+        "core::ffi",
+        "--use-core",
+        "--with-derive-partialeq",
+        "--with-derive-default",
+        "--with-derive-custom-struct=EfiMemoryDescriptor=AsBytes,FromBytes,FromZeroes",
+        "--allowlist-type",
+        "(Efi.*)|(GblEfi.*)|(GBL_EFI_.*)",
+        "--allowlist-var",
+        "PARTITION_NAME_LEN_U16|EFI_.*",
+        "--raw-line",
+        """
+#![allow(non_camel_case_types)]
+#![allow(non_snake_case)]
+#![allow(missing_docs)]
+use zerocopy::{AsBytes, FromBytes, FromZeroes};""",
+    ],
+    cc_lib = ":efi_c_headers",
+    # For x86_32, we need to explicitly specify 32bit architecture.
+    clang_flags = select(
+        {
+            "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
+            "//conditions:default": ["-m64"],
+        },
+    ) + [
+        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
+        "-nostdinc",
+    ],
+    header = "defs/efi.h",
+)
+
+# Copy the generated source to "src/defs.rs" in the output assembly, so that libefi can include it
+# as a source.
+genrule(
+    name = "efi_defs_genrule",
+    srcs = [":efi_defs_bindgen"],
+    outs = ["src/defs.rs"],
+    cmd = "cat $(location :efi_defs_bindgen) > $@",
+)
+
+rust_library(
+    name = "libefi_types",
+    srcs = glob(["**/*.rs"]) + ["src/defs.rs"],
+    crate_name = "efi_types",
+    data = [":efi_defs_genrule"],
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@zerocopy",
+    ],
+)
+
+rust_test(
+    name = "libefi_types_test",
+    crate = ":libefi_types",
+    rustc_flags = ANDROID_RUST_LINTS,
+)
diff --git a/gbl/libefi/defs/boot_service.h b/gbl/libefi_types/defs/boot_service.h
similarity index 100%
rename from gbl/libefi/defs/boot_service.h
rename to gbl/libefi_types/defs/boot_service.h
diff --git a/gbl/libefi/defs/efi.h b/gbl/libefi_types/defs/efi.h
similarity index 77%
rename from gbl/libefi/defs/efi.h
rename to gbl/libefi_types/defs/efi.h
index 2bbe5e3..a58b9b6 100644
--- a/gbl/libefi/defs/efi.h
+++ b/gbl/libefi_types/defs/efi.h
@@ -23,9 +23,15 @@
 #include <stdint.h>
 
 #include "boot_service.h"
-#include "protocols/android_boot_protocol.h"
+#include "gbl_efi_common.h"
+#include "protocols/block_io2_protocol.h"
 #include "protocols/block_io_protocol.h"
 #include "protocols/device_path_protocol.h"
+#include "protocols/gbl_efi_ab_slot_protocol.h"
+#include "protocols/gbl_efi_fastboot_protocol.h"
+#include "protocols/gbl_efi_fastboot_usb.h"
+#include "protocols/gbl_efi_image_loading_protocol.h"
+#include "protocols/gbl_efi_os_configuration_protocol.h"
 #include "protocols/loaded_image_protocol.h"
 #include "protocols/riscv_efi_boot_protocol.h"
 #include "protocols/simple_network_protocol.h"
diff --git a/gbl/libefi_types/defs/gbl_efi_common.h b/gbl/libefi_types/defs/gbl_efi_common.h
new file mode 100644
index 0000000..d1a218e
--- /dev/null
+++ b/gbl/libefi_types/defs/gbl_efi_common.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef __GBL_EFI_COMMON_H__
+#define __GBL_EFI_COMMON_H__
+
+#include <types.h>
+
+#define GBL_EFI_VENDOR_GUID                                     \
+  EfiGuid {                                                     \
+    .data1=0x5a6d92f3,                                          \
+      .data2=0xa2d0,                                            \
+      .data3=0x4083,                                            \
+      .data4=[0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]   \
+  }
+#define GBL_EFI_OS_BOOT_TARGET_VARNAME "gbl_os_boot_target"
+
+#endif  /* __GBL_EFI_COMMON_H__ */
diff --git a/gbl/libefi_types/defs/protocols/block_io2_protocol.h b/gbl/libefi_types/defs/protocols/block_io2_protocol.h
new file mode 100644
index 0000000..d25ee67
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/block_io2_protocol.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef __BLOCK_IO2_PROTOCOL_H__
+#define __BLOCK_IO2_PROTOCOL_H__
+
+#include "protocols/block_io_protocol.h"
+#include "types.h"
+
+typedef struct EfiBlockIoMedia EfiBlockIoMedia;
+typedef struct EfiBlockIo2Protocol EfiBlockIo2Protocol;
+
+typedef struct {
+  EfiEvent event;
+  EfiStatus transaction_status;
+} EfiBlockIo2Token;
+
+struct EfiBlockIo2Protocol {
+  EfiBlockIoMedia* media;
+  EfiStatus (*reset)(EfiBlockIo2Protocol* self, bool extended_verification);
+  EfiStatus (*read_blocks_ex)(EfiBlockIo2Protocol* self, uint32_t media_id,
+                              uint64_t lba, EfiBlockIo2Token* token,
+                              size_t buffer_size, void* buffer);
+  EfiStatus (*write_blocks_ex)(EfiBlockIo2Protocol* self, uint32_t media_id,
+                               uint64_t lba, EfiBlockIo2Token* token,
+                               size_t buffer_size, const void* buffer);
+  EfiStatus (*flush_blocks_ex)(EfiBlockIo2Protocol* self,
+                               EfiBlockIo2Token* token);
+};
+
+#endif  //__BLOCK_IO2_PROTOCOL_H__
diff --git a/gbl/libefi/defs/protocols/block_io_protocol.h b/gbl/libefi_types/defs/protocols/block_io_protocol.h
similarity index 100%
rename from gbl/libefi/defs/protocols/block_io_protocol.h
rename to gbl/libefi_types/defs/protocols/block_io_protocol.h
index dbbd94d..7655c50 100644
--- a/gbl/libefi/defs/protocols/block_io_protocol.h
+++ b/gbl/libefi_types/defs/protocols/block_io_protocol.h
@@ -15,11 +15,11 @@
  *
  */
 
-#include "types.h"
-
 #ifndef __BLOCK_IO_PROTOCOL_H__
 #define __BLOCK_IO_PROTOCOL_H__
 
+#include "types.h"
+
 typedef struct EfiBlockIoMedia EfiBlockIoMedia;
 typedef struct EfiBlockIoProtocol EfiBlockIoProtocol;
 
diff --git a/gbl/libefi/defs/protocols/device_path_protocol.h b/gbl/libefi_types/defs/protocols/device_path_protocol.h
similarity index 100%
rename from gbl/libefi/defs/protocols/device_path_protocol.h
rename to gbl/libefi_types/defs/protocols/device_path_protocol.h
index 874e833..8c9da3b 100644
--- a/gbl/libefi/defs/protocols/device_path_protocol.h
+++ b/gbl/libefi_types/defs/protocols/device_path_protocol.h
@@ -15,11 +15,11 @@
  *
  */
 
-#include "types.h"
-
 #ifndef __DEVICE_PATH_PROTOCOL_H__
 #define __DEVICE_PATH_PROTOCOL_H__
 
+#include "types.h"
+
 typedef struct EfiDevicePathProtocol {
   uint8_t type;
   uint8_t sub_type;
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
new file mode 100644
index 0000000..df5dde7
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef __GBL_EFI_AB_SLOT_PROTOCOL_H__
+#define __GBL_EFI_AB_SLOT_PROTOCOL_H__
+
+#include "system_table.h"
+#include "types.h"
+
+typedef enum GBL_EFI_SLOT_MERGE_STATUS {
+  GBL_EFI_SLOT_MERGE_STATUS_NONE = 0,
+  GBL_EFI_SLOT_MERGE_STATUS_UNKNOWN,
+  GBL_EFI_SLOT_MERGE_STATUS_SNAPSHOTTED,
+  GBL_EFI_SLOT_MERGE_STATUS_MERGING,
+  GBL_EFI_SLOT_MERGE_STATUS_CANCELLED,
+} GblEfiSlotMergeStatus;
+
+typedef enum GBL_EFI_UNBOOTABLE_REASON {
+  GBL_EFI_UNKNOWN_REASON = 0,
+  GBL_EFI_NO_MORE_TRIES,
+  GBL_EFI_SYSTEM_UPDATE,
+  GBL_EFI_USER_REQUESTED,
+  GBL_EFI_VERIFICATION_FAILURE,
+} GblEfiUnbootableReason;
+
+typedef enum GBL_EFI_BOOT_REASON {
+  GBL_EFI_EMPTY_BOOT_REASON = 0,
+  GBL_EFI_UNKNOWN_EFI_BOOT_REASON = 1,
+  GBL_EFI_WATCHDOG = 14,
+  GBL_EFI_KERNEL_PANIC = 15,
+  GBL_EFI_RECOVERY = 3,
+  GBL_EFI_BOOTLOADER = 55,
+  GBL_EFI_COLD = 56,
+  GBL_EFI_HARD = 57,
+  GBL_EFI_WARM = 58,
+  GBL_EFI_SHUTDOWN,
+  GBL_EFI_REBOOT = 18,
+} GblEfiBootReason;
+
+typedef struct {
+  // One UTF-8 encoded single character
+  uint32_t suffix;
+  // Any value other than those explicitly enumerated in EFI_UNBOOTABLE_REASON
+  // will be interpreted as UNKNOWN_REASON.
+  uint32_t unbootable_reason;
+  uint8_t priority;
+  uint8_t tries;
+  // Value of 1 if slot has successfully booted.
+  uint8_t successful;
+} GblEfiSlotInfo;
+
+typedef struct {
+  // Value of 1 if persistent metadata tracks slot unbootable reasons.
+  uint8_t unbootable_metadata;
+  uint8_t max_retries;
+  uint8_t slot_count;
+  // See GblEFiSlotMergeStatus for enum values.
+  uint8_t merge_status;
+} GblEfiSlotMetadataBlock;
+
+typedef struct GblEfiABSlotProtocol {
+  // Currently must contain 0x00010000
+  uint32_t version;
+  // Slot metadata query methods
+  EfiStatus (*load_boot_data)(struct GblEfiABSlotProtocol*,
+                              GblEfiSlotMetadataBlock* /* out param*/);
+  EfiStatus (*get_slot_info)(struct GblEfiABSlotProtocol*, uint8_t,
+                             GblEfiSlotInfo* /* out param */);
+  EfiStatus (*get_current_slot)(struct GblEfiABSlotProtocol*,
+                                GblEfiSlotInfo* /* out param */);
+  // Slot metadata manipulation methods
+  EfiStatus (*set_active_slot)(struct GblEfiABSlotProtocol*, uint8_t);
+  EfiStatus (*set_slot_unbootable)(struct GblEfiABSlotProtocol*, uint8_t,
+                                   uint32_t);
+  EfiStatus (*mark_boot_attempt)(struct GblEfiABSlotProtocol*);
+  EfiStatus (*reinitialize)(struct GblEfiABSlotProtocol*);
+  // Miscellaneous methods
+  EfiStatus (*get_boot_reason)(struct GblEfiABSlotProtocol*,
+                               uint32_t* /* out param */,
+                               size_t* /* in-out param */,
+                               uint8_t* /* out param*/);
+  EfiStatus (*set_boot_reason)(struct GblEfiABSlotProtocol*, uint32_t, size_t,
+                               const uint8_t*);
+  EfiStatus (*flush)(struct GblEfiABSlotProtocol*);
+} GblEfiABSlotProtocol;
+
+#endif  // __GBL_EFI_AB_SLOT_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
new file mode 100644
index 0000000..1cf9388
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// This is a custom protocol introduced by GBL.
+// See gbl/docs/GBL_EFI_FASTBOOT_PROTOCOL.md for details.
+
+#ifndef __GBL_EFI_FASTBOOT_PROTOCOL_H__
+#define __GBL_EFI_FASTBOOT_PROTOCOL_H__
+
+#include "types.h"
+
+#define GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8 32
+
+typedef struct GblEfiFastbootArg {
+  const char8_t* str_utf8;
+  size_t len;
+} GblEfiFastbootArg;
+
+typedef struct GblEfiFastbootPolicy {
+  // Indicates whether device can be unlocked
+  bool can_unlock;
+  // Device firmware supports 'critical' partition locking
+  bool has_critical_lock;
+  // Indicates whether device allows booting from image loaded directly from
+  // RAM.
+  bool can_ram_boot;
+} GblEfiFastbootPolicy;
+
+typedef enum GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS {
+  // Firmware can read the given partition and send its data to fastboot client.
+  GBL_EFI_FASTBOOT_PARTITION_READ = 0x1 << 0,
+  // Firmware can overwrite the given partition.
+  GBL_EFI_FASTBOOT_PARTITION_WRITE = 0x1 << 1,
+  // Firmware can erase the given partition.
+  GBL_EFI_FASTBOOT_PARTITION_ERASE = 0x1 << 2,
+} GblEfiFastbootPartitionPermissionFlags;
+
+typedef enum GBL_EFI_FASTBOOT_LOCK_FLAGS {
+  // All device partitions are locked.
+  GBL_EFI_FASTBOOT_GBL_EFI_LOCKED = 0x1 << 0,
+  // All 'critical' device partitions are locked.
+  GBL_EFI_FASTBOOT_GBL_EFI_CRITICAL_LOCKED = 0x1 << 1,
+} GblEfiFastbootLockFlags;
+
+typedef void const* GblEfiFastbootToken;
+
+typedef struct GblEfiFastbootProtocol {
+  // Revision of the protocol supported.
+  uint32_t version;
+  // Null-terminated UTF-8 encoded string
+  char8_t serial_number[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
+
+  // Fastboot variable methods
+  EfiStatus (*get_var)(struct GblEfiFastbootProtocol* this,
+                       const GblEfiFastbootArg* args, size_t num_args,
+                       char8_t* buf, size_t* bufsize, GblEfiFastbootToken hint);
+  EfiStatus (*start_var_iterator)(struct GblEfiFastbootProtocol* this,
+                                  GblEfiFastbootToken* token);
+  EfiStatus (*get_next_var_args)(struct GblEfiFastbootProtocol* this,
+                                 GblEfiFastbootArg* args, size_t* num_args,
+                                 GblEfiFastbootToken* token);
+
+  // Fastboot oem function methods
+  EfiStatus (*run_oem_function)(struct GblEfiFastbootProtocol* this,
+                                const char8_t* command, size_t command_len,
+                                char8_t* buf, size_t* bufsize);
+
+  // Device lock methods
+  EfiStatus (*get_policy)(struct GblEfiFastbootProtocol* this,
+                          GblEfiFastbootPolicy* policy);
+  EfiStatus (*set_lock)(struct GblEfiFastbootProtocol* this,
+                        uint64_t lock_state);
+  EfiStatus (*clear_lock)(struct GblEfiFastbootProtocol* this,
+                          uint64_t lock_state);
+
+  // Misc methods
+  EfiStatus (*get_partition_permissions)(struct GblEfiFastbootProtocol* this,
+                                         const char8_t* part_name,
+                                         size_t part_name_len,
+                                         uint64_t* permissions);
+  EfiStatus (*wipe_user_data)(struct GblEfiFastbootProtocol* this);
+} GblEfiFastbootProtocol;
+
+#endif  // __GBL_EFI_FASTBOOT_PROTOCOL_H__
diff --git a/gbl/libefi/defs/protocols/android_boot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h
similarity index 64%
rename from gbl/libefi/defs/protocols/android_boot_protocol.h
rename to gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h
index 14c727b..28197c0 100644
--- a/gbl/libefi/defs/protocols/android_boot_protocol.h
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_usb.h
@@ -16,23 +16,23 @@
  */
 
 // This is a custom protocol introduced by GBL.
-// See gbl/docs/EFI_ANDROID_BOOT_PROTOCOL.md for details.
+// See gbl/docs/GBL_EFI_FASTBOOT_USB_PROTOCOL.md for details.
 
-#include "types.h"
+#ifndef __GBL_EFI_FASTBOOT_USB_H__
+#define __GBL_EFI_FASTBOOT_USB_H__
 
-#ifndef __ANDROID_BOOT_PROTOCOL_H__
-#define __ANDROID_BOOT_PROTOCOL_H__
+#include "types.h"
 
-typedef struct EfiAndroidBootProtocol {
+typedef struct GblEfiFastbootUsbProtocol {
   uint64_t revision;
-  EfiStatus (*fastboot_usb_interface_start)(struct EfiAndroidBootProtocol* self,
+  EfiStatus (*fastboot_usb_interface_start)(struct GblEfiFastbootUsbProtocol* self,
                                             size_t* max_packet_size);
-  EfiStatus (*fastboot_usb_interface_stop)(struct EfiAndroidBootProtocol* self);
-  EfiStatus (*fastboot_usb_receive)(struct EfiAndroidBootProtocol* self,
+  EfiStatus (*fastboot_usb_interface_stop)(struct GblEfiFastbootUsbProtocol* self);
+  EfiStatus (*fastboot_usb_receive)(struct GblEfiFastbootUsbProtocol* self,
                                     size_t* buffer_size, void* buffer);
-  EfiStatus (*fastboot_usb_send)(struct EfiAndroidBootProtocol* self,
+  EfiStatus (*fastboot_usb_send)(struct GblEfiFastbootUsbProtocol* self,
                                  size_t* buffer_size, const void* buffer);
   EfiEvent wait_for_send_completion;
-} EfiAndroidBootProtocol;
+} GblEfiFastbootUsbProtocol;
 
-#endif  //__ANDROID_BOOT_PROTOCOL_H__
+#endif  //__GBL_EFI_FASTBOOT_USB_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h
new file mode 100644
index 0000000..5a6557a
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_image_loading_protocol.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef __GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
+#define __GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
+
+#include <stddef.h>
+
+#include "types.h"
+
+const uint64_t GBL_EFI_IMAGE_LOADING_PROTOCOL_REVISION = 0x00010000;
+
+const size_t PARTITION_NAME_LEN_U16 = 36;
+
+typedef struct GblEfiImageInfo {
+  char16_t ImageType[PARTITION_NAME_LEN_U16];
+  size_t SizeBytes;
+} GblEfiImageInfo;
+
+typedef struct GblEfiImageBuffer {
+  void* Memory;
+  size_t SizeBytes;
+} GblEfiImageBuffer;
+
+typedef struct GblEfiPartitionName {
+  char16_t StrUtf16[PARTITION_NAME_LEN_U16];
+} GblEfiPartitionName;
+
+typedef struct GblEfiImageLoadingProtocol {
+  uint64_t revision;
+  EfiStatus (*get_buffer)(struct GblEfiImageLoadingProtocol* self,
+                          const GblEfiImageInfo* ImageInfo,
+                          GblEfiImageBuffer* Buffer);
+  EfiStatus (*get_verify_partitions)(struct GblEfiImageLoadingProtocol* self,
+                                     size_t* NumberOfPartitions,
+                                     GblEfiPartitionName* Partitions);
+} GblEfiImageLoadingProtocol;
+
+#endif  //__GBL_EFI_IMAGE_LOADING_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
new file mode 100644
index 0000000..c734311
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// This is a custom protocol introduced by GBL.
+// See gbl/docs/gbl_efi_os_configuration_protocol.md for details.
+
+#ifndef __GBL_OS_CONFIGURATION_PROTOCOL_H__
+#define __GBL_OS_CONFIGURATION_PROTOCOL_H__
+
+#include "types.h"
+
+typedef struct GblEfiOsConfigurationProtocol {
+  uint64_t revision;
+  EfiStatus (*fixup_kernel_commandline)(
+      struct GblEfiOsConfigurationProtocol* self, char8_t* data,
+      size_t* buffer_size);
+  EfiStatus (*fixup_bootconfig)(struct GblEfiOsConfigurationProtocol* self,
+                                char8_t* data, size_t* buffer_size);
+  // TODO(b/353272981): remaining fields.
+} GblEfiOsConfigurationProtocol;
+
+#endif  //__GBL_OS_CONFIGURATION_PROTOCOL_H__
diff --git a/gbl/libefi/defs/protocols/loaded_image_protocol.h b/gbl/libefi_types/defs/protocols/loaded_image_protocol.h
similarity index 93%
rename from gbl/libefi/defs/protocols/loaded_image_protocol.h
rename to gbl/libefi_types/defs/protocols/loaded_image_protocol.h
index 820907a..69a46f2 100644
--- a/gbl/libefi/defs/protocols/loaded_image_protocol.h
+++ b/gbl/libefi_types/defs/protocols/loaded_image_protocol.h
@@ -15,6 +15,9 @@
  *
  */
 
+#ifndef __LOADED_IMAGE_PROTOCOL_H__
+#define __LOADED_IMAGE_PROTOCOL_H__
+
 #include "system_table.h"
 #include "types.h"
 
@@ -36,3 +39,5 @@ typedef struct {
 
   EfiStatus (*unload)(EfiHandle img);
 } EfiLoadedImageProtocol;
+
+#endif
diff --git a/gbl/libefi/defs/protocols/riscv_efi_boot_protocol.h b/gbl/libefi_types/defs/protocols/riscv_efi_boot_protocol.h
similarity index 100%
rename from gbl/libefi/defs/protocols/riscv_efi_boot_protocol.h
rename to gbl/libefi_types/defs/protocols/riscv_efi_boot_protocol.h
diff --git a/gbl/libefi/defs/protocols/simple_network_protocol.h b/gbl/libefi_types/defs/protocols/simple_network_protocol.h
similarity index 94%
rename from gbl/libefi/defs/protocols/simple_network_protocol.h
rename to gbl/libefi_types/defs/protocols/simple_network_protocol.h
index 7c29b84..dac43dd 100644
--- a/gbl/libefi/defs/protocols/simple_network_protocol.h
+++ b/gbl/libefi_types/defs/protocols/simple_network_protocol.h
@@ -26,6 +26,11 @@
 #include "types.h"
 
 #define EFI_SIMPLE_NETWORK_PROTOCOL_REVISION 0x00010000
+#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST 0x01
+#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST 0x02
+#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST 0x04
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS 0x08
+#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
 
 #define MAX_MCAST_FILTER_CNT 16
 
diff --git a/gbl/libefi/defs/protocols/simple_text_input_protocol.h b/gbl/libefi_types/defs/protocols/simple_text_input_protocol.h
similarity index 100%
rename from gbl/libefi/defs/protocols/simple_text_input_protocol.h
rename to gbl/libefi_types/defs/protocols/simple_text_input_protocol.h
diff --git a/gbl/libefi/defs/protocols/simple_text_output_protocol.h b/gbl/libefi_types/defs/protocols/simple_text_output_protocol.h
similarity index 100%
rename from gbl/libefi/defs/protocols/simple_text_output_protocol.h
rename to gbl/libefi_types/defs/protocols/simple_text_output_protocol.h
diff --git a/gbl/libefi/defs/runtime_service.h b/gbl/libefi_types/defs/runtime_service.h
similarity index 95%
rename from gbl/libefi/defs/runtime_service.h
rename to gbl/libefi_types/defs/runtime_service.h
index 1d0aa2e..dbff3ad 100644
--- a/gbl/libefi/defs/runtime_service.h
+++ b/gbl/libefi_types/defs/runtime_service.h
@@ -22,7 +22,7 @@ typedef struct {
                                       EfiGuid* vendor_guid);
   EfiStatus (*set_variable)(const char16_t* variable_name,
                             const EfiGuid* vendor_guid, uint32_t attributes,
-                            size_t data_size, void* data);
+                            size_t data_size, const void* data);
   EfiStatus (*get_next_high_monotonic_count)(uint32_t* high_count);
   void (*reset_system)(EfiResetType reset_type, EfiStatus reset_status,
                        size_t data_size, void* reset_data);
@@ -38,4 +38,4 @@ typedef struct {
                                    uint64_t* maximum_variable_size);
 } EfiRuntimeService;
 
-#endif  // __RUNTIME_SERVICE_H__
\ No newline at end of file
+#endif  // __RUNTIME_SERVICE_H__
diff --git a/gbl/libefi/defs/system_table.h b/gbl/libefi_types/defs/system_table.h
similarity index 100%
rename from gbl/libefi/defs/system_table.h
rename to gbl/libefi_types/defs/system_table.h
diff --git a/gbl/libefi/defs/types.h b/gbl/libefi_types/defs/types.h
similarity index 100%
rename from gbl/libefi/defs/types.h
rename to gbl/libefi_types/defs/types.h
diff --git a/gbl/libefi_types/src/lib.rs b/gbl/libefi_types/src/lib.rs
new file mode 100644
index 0000000..8d9e2fa
--- /dev/null
+++ b/gbl/libefi_types/src/lib.rs
@@ -0,0 +1,75 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Syntax error: unmatched thing in thing from
+//! std::nonstd::__map<_Cyrillic, _$$$dollars>const basic_string<epic_mystery,
+//! mongoose_traits &lt; char>, __default_alloc_<casual_Fridays = maybe>>
+
+#![cfg_attr(not(test), no_std)]
+
+#[rustfmt::skip]
+pub mod defs;
+pub use defs::*;
+
+impl EfiGuid {
+    /// Returns a new `[EfiGuid]` using the given data.
+    pub const fn new(data1: u32, data2: u16, data3: u16, data4: [u8; 8usize]) -> Self {
+        EfiGuid { data1, data2, data3, data4 }
+    }
+}
+
+impl GblEfiPartitionName {
+    /// Decodes the UCS2 GblEfiPartitionName using buffer, and returns &str of UTF8 representation.
+    ///
+    /// Buffer must be big enough to contain UTF8 representation of the UCS2 partition name.
+    ///
+    /// Maximum partition name as UCS2 is PARTITION_NAME_LEN_U16.
+    /// And [PARTITION_NAME_LEN_U8] bytes is maximum buffer size needed for UTF8 representation.
+    ///
+    /// # Result
+    /// Ok(&str) - On success return UTF8 representation of the partition name
+    /// Err(usize) if provided buffer is too small, with the minimum buffer size as the payload.
+    pub fn get_str<'a>(&self, buffer_utf8: &'a mut [u8]) -> Result<&'a str, usize> {
+        let mut index = 0;
+        let chars_iter = char::decode_utf16(self.StrUtf16.iter().copied())
+            .map(|c_res| c_res.unwrap_or(char::REPLACEMENT_CHARACTER))
+            .take_while(|c| *c != '\0');
+        for c in chars_iter.clone() {
+            if c.len_utf8() <= buffer_utf8[index..].len() {
+                index += c.encode_utf8(&mut buffer_utf8[index..]).len();
+            } else {
+                let buffer_min_len = chars_iter.clone().map(char::len_utf8).sum();
+                return Err(buffer_min_len);
+            }
+        }
+        // SAFETY:
+        // _unchecked should be OK here since we wrote each utf8 byte ourselves,
+        // but it's just an optimization, checked version would be fine also.
+        unsafe { Ok(core::str::from_utf8_unchecked(&buffer_utf8[..index])) }
+    }
+}
+
+impl From<&[u16]> for GblEfiPartitionName {
+    fn from(value: &[u16]) -> Self {
+        let mut res: GblEfiPartitionName = Default::default();
+        res.StrUtf16[..value.len()].copy_from_slice(value);
+        res
+    }
+}
+
+impl<const N: usize> From<[u16; N]> for GblEfiPartitionName {
+    fn from(value: [u16; N]) -> Self {
+        value[..].into()
+    }
+}
diff --git a/gbl/android_external_rust_crates/BUILD.syn.bazel b/gbl/liberror/BUILD
similarity index 58%
rename from gbl/android_external_rust_crates/BUILD.syn.bazel
rename to gbl/liberror/BUILD
index f04acaf..1fdb664 100644
--- a/gbl/android_external_rust_crates/BUILD.syn.bazel
+++ b/gbl/liberror/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,29 +12,25 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@rules_rust//rust:defs.bzl", "rust_library")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 rust_library(
-    name = "syn",
-    srcs = glob(["**/*.rs"]),
-    crate_features = [
-        "clone-impls",
-        "default",
-        "derive",
-        "extra-traits",
-        "full",
-        "parsing",
-        "printing",
-        "proc-macro",
-        "quote",
-        "visit",
-        "visit-mut",
-    ],
+    name = "liberror",
+    srcs = glob(
+        ["**/*.rs"],
+    ),
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     visibility = ["//visibility:public"],
     deps = [
-        "@proc-macro2",
-        "@quote",
-        "@unicode-ident",
+        "@gbl//libefi_types",
+        "@gbl//libsafemath",
     ],
 )
+
+rust_test(
+    name = "liberror_test",
+    crate = ":liberror",
+    rustc_flags = ANDROID_RUST_LINTS,
+)
diff --git a/gbl/liberror/src/lib.rs b/gbl/liberror/src/lib.rs
new file mode 100644
index 0000000..32e1a8e
--- /dev/null
+++ b/gbl/liberror/src/lib.rs
@@ -0,0 +1,287 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Unified error type library
+//!
+//! This crate defines a common error type for all of GBL.
+//! It is intended to reduce conversion boilerplate and to make
+//! the various GBL libraries interoperate more cleanly.
+//!
+//! Because of its intended broad application, certain error types will
+//! be highly specific to particular libraries.
+//! More specific errors can be useful when writing unit tests or when defining
+//! APIs that third party code may interact with.
+//! It's a judgement call whether a new variant should be added,
+//! but if possible try to use an existing variant.
+//!
+//! It is a further judgement call whether a new variant should wrap a payload.
+//! The rule of thumb is that a payload requires one of the following conditions:
+//! 1) The error will be logged and the payload will help with debugging.
+//! 2) The error is transient or retriable, and the payload helps with the retry.
+//!
+//! New error variants should be inserted alphabetically.
+
+#![cfg_attr(not(any(test, android_dylib)), no_std)]
+
+use core::ffi::{FromBytesUntilNulError, FromBytesWithNulError};
+use core::str::Utf8Error;
+
+use efi_types as efi;
+
+/// Common, universal error type
+#[derive(Copy, Clone, Debug, PartialEq, Eq)]
+pub enum Error {
+    /// An operation has been aborted. Useful for async or IO operations.
+    Aborted,
+    /// Access was denied.
+    AccessDenied,
+    /// The protocol has already been started.
+    AlreadyStarted,
+    /// A checked arithmetic operation has overflowed.
+    ArithmeticOverflow(safemath::Error),
+    /// The buffer was not the proper size for the request (different from BufferTooSmall).
+    BadBufferSize,
+    /// Data verification has encountered an invalid checksum.
+    BadChecksum,
+    /// An operation attempted to access data outside of the valid range.
+    /// Includes the problematic index.
+    BadIndex(usize),
+    /// Data verification has encountered an invalid magic number.
+    BadMagic,
+    /// Generic BlockIO error.
+    BlockIoError,
+    /// Generic boot failure has occurred.
+    BootFailed,
+    /// Buffers provided by third party code overlap.
+    BufferOverlap,
+    /// The provided buffer is too small.
+    /// If Some(n), provides the minimum required buffer size.
+    BufferTooSmall(Option<usize>),
+    /// The security status of the data is unknown or compromised
+    /// and the data must be updated or replaced to restore a valid security status.
+    CompromisedData,
+    /// The remote peer has reset the network connection.
+    ConnectionReset,
+    /// A relevant device encountered an error.
+    DeviceError,
+    /// The connected peripheral or network peer has disconnected.
+    Disconnected,
+    /// The end of the file was reached.
+    EndOfFile,
+    /// Beginning or end of media was reached
+    EndOfMedia,
+    /// A polled operation has finished
+    Finished,
+    /// A HTTP error occurred during a network operation.
+    HttpError,
+    /// An ICMP error occurred during a network operation.
+    IcmpError,
+    /// The provided buffer or data structure is invalidly aligned.
+    InvalidAlignment,
+    /// A connected agent failed a multi-stage handshake.
+    InvalidHandshake,
+    /// At least one parameter fails preconditions.
+    InvalidInput,
+    /// The language specified was invalid.
+    InvalidLanguage,
+    /// A state machine has entered an invalid state.
+    InvalidState,
+    /// There was a conflict in IP address allocation.
+    IpAddressConflict,
+    /// Image failed to load
+    LoadError,
+    /// The medium in the device has changed since the last access.
+    MediaChanged,
+    /// Memory map error with error code.
+    MemoryMapCallbackError(i64),
+    /// An image required for system boot is missing.
+    MissingImage,
+    /// A valid Flattened Device Tree was not found.
+    NoFdt,
+    /// The block device does not have a valid GUID Partition Table.
+    NoGpt,
+    /// A mapping to a device does not exist.
+    NoMapping,
+    /// The device does not contain any medium to perform the operation.
+    NoMedia,
+    /// The server was not found or did not respond to the request.
+    NoResponse,
+    /// The requested element (e.g. device, partition, or value) was not found.
+    NotFound,
+    /// The default implementation for a trait method has not been overridden.
+    NotImplemented,
+    /// The polled device or future is not ready.
+    NotReady,
+    /// The protocol has not been started.
+    NotStarted,
+    /// The provided name does not uniquely describe a partition.
+    NotUnique,
+    /// Generic permissions failure.
+    OperationProhibited,
+    /// Catch-all error with optional debugging string.
+    Other(Option<&'static str>),
+    /// A resource has run out.
+    OutOfResources,
+    /// A protocol error occurred during the network operation.
+    ProtocolError,
+    /// The function was not performed due to a security violation.
+    SecurityViolation,
+    /// A TFTP error occurred during a network operation.
+    TftpError,
+    /// Operation has timed out.
+    Timeout,
+    /// The remote network endpoint is not addressable.
+    Unaddressable,
+    /// An unknown, unexpected EFI_STATUS error code was returned,
+    UnexpectedEfiError(efi::EfiStatus),
+    /// Operation is unsupported
+    Unsupported,
+    /// Data verification has encountered a version number that is not supported.
+    UnsupportedVersion,
+    /// An inconstancy was detected on the file system causing the operating to fail.
+    VolumeCorrupted,
+    /// There is no more space on the file system.
+    VolumeFull,
+    /// The device cannot be written to.
+    WriteProtected,
+}
+
+impl From<Option<&'static str>> for Error {
+    fn from(val: Option<&'static str>) -> Self {
+        Self::Other(val)
+    }
+}
+
+impl From<&'static str> for Error {
+    fn from(val: &'static str) -> Self {
+        Self::Other(Some(val))
+    }
+}
+
+impl From<safemath::Error> for Error {
+    fn from(err: safemath::Error) -> Self {
+        Self::ArithmeticOverflow(err)
+    }
+}
+
+impl From<core::num::TryFromIntError> for Error {
+    #[track_caller]
+    fn from(err: core::num::TryFromIntError) -> Self {
+        Self::ArithmeticOverflow(err.into())
+    }
+}
+
+impl From<FromBytesUntilNulError> for Error {
+    fn from(_: FromBytesUntilNulError) -> Self {
+        Self::InvalidInput
+    }
+}
+
+impl From<FromBytesWithNulError> for Error {
+    fn from(_: FromBytesWithNulError) -> Self {
+        Self::InvalidInput
+    }
+}
+
+impl From<Utf8Error> for Error {
+    fn from(_: Utf8Error) -> Self {
+        Self::InvalidInput
+    }
+}
+
+impl core::fmt::Display for Error {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        write!(f, "{:#?}", self)
+    }
+}
+
+impl From<core::fmt::Error> for Error {
+    fn from(_: core::fmt::Error) -> Self {
+        Self::Unsupported
+    }
+}
+
+/// Helper type alias.
+pub type Result<T> = core::result::Result<T, Error>;
+
+/// Workaround for orphan rule.
+pub fn efi_status_to_result(e: efi::EfiStatus) -> Result<()> {
+    match e {
+        efi::EFI_STATUS_SUCCESS => Ok(()),
+        efi::EFI_STATUS_CRC_ERROR => Err(Error::BadChecksum),
+        efi::EFI_STATUS_ABORTED => Err(Error::Aborted),
+        efi::EFI_STATUS_ACCESS_DENIED => Err(Error::AccessDenied),
+        efi::EFI_STATUS_ALREADY_STARTED => Err(Error::AlreadyStarted),
+        efi::EFI_STATUS_BAD_BUFFER_SIZE => Err(Error::BadBufferSize),
+        efi::EFI_STATUS_BUFFER_TOO_SMALL => Err(Error::BufferTooSmall(None)),
+        efi::EFI_STATUS_COMPROMISED_DATA => Err(Error::CompromisedData),
+        efi::EFI_STATUS_CONNECTION_FIN => Err(Error::Disconnected),
+        efi::EFI_STATUS_CONNECTION_REFUSED => Err(Error::OperationProhibited),
+        efi::EFI_STATUS_CONNECTION_RESET => Err(Error::ConnectionReset),
+        efi::EFI_STATUS_DEVICE_ERROR => Err(Error::DeviceError),
+        efi::EFI_STATUS_END_OF_FILE => Err(Error::EndOfFile),
+        efi::EFI_STATUS_END_OF_MEDIA => Err(Error::EndOfMedia),
+        efi::EFI_STATUS_HTTP_ERROR => Err(Error::HttpError),
+        efi::EFI_STATUS_ICMP_ERROR => Err(Error::IcmpError),
+        efi::EFI_STATUS_INCOMPATIBLE_VERSION => Err(Error::UnsupportedVersion),
+        efi::EFI_STATUS_INVALID_LANGUAGE => Err(Error::InvalidLanguage),
+        efi::EFI_STATUS_INVALID_PARAMETER => Err(Error::InvalidInput),
+        efi::EFI_STATUS_IP_ADDRESS_CONFLICT => Err(Error::IpAddressConflict),
+        efi::EFI_STATUS_LOAD_ERROR => Err(Error::LoadError),
+        efi::EFI_STATUS_MEDIA_CHANGED => Err(Error::MediaChanged),
+        efi::EFI_STATUS_NOT_FOUND => Err(Error::NotFound),
+        efi::EFI_STATUS_NOT_READY => Err(Error::NotReady),
+        efi::EFI_STATUS_NOT_STARTED => Err(Error::NotStarted),
+        efi::EFI_STATUS_NO_MAPPING => Err(Error::NoMapping),
+        efi::EFI_STATUS_NO_MEDIA => Err(Error::NoMedia),
+        efi::EFI_STATUS_NO_RESPONSE => Err(Error::NoResponse),
+        efi::EFI_STATUS_OUT_OF_RESOURCES => Err(Error::OutOfResources),
+        efi::EFI_STATUS_PROTOCOL_ERROR => Err(Error::ProtocolError),
+        efi::EFI_STATUS_SECURITY_VIOLATION => Err(Error::SecurityViolation),
+        efi::EFI_STATUS_TFTP_ERROR => Err(Error::TftpError),
+        efi::EFI_STATUS_TIMEOUT => Err(Error::Timeout),
+        efi::EFI_STATUS_UNSUPPORTED => Err(Error::Unsupported),
+        efi::EFI_STATUS_VOLUME_CORRUPTED => Err(Error::VolumeCorrupted),
+        efi::EFI_STATUS_VOLUME_FULL => Err(Error::VolumeFull),
+        efi::EFI_STATUS_WRITE_PROTECTED => Err(Error::WriteProtected),
+        // The UEFI spec reserves part of the error space for
+        // OEM defined errors and warnings.
+        // We can't know in advance what these are or what they mean,
+        // so just preserve them as is.
+        e => Err(Error::UnexpectedEfiError(e)),
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    #[test]
+    fn test_from_safemath_error() {
+        let n = u8::try_from(safemath::SafeNum::ZERO - 1).unwrap_err();
+        let _e: Error = n.into();
+    }
+
+    #[test]
+    fn test_from_str() {
+        let _e: Error = "error string".into();
+    }
+
+    #[test]
+    fn test_from_str_option() {
+        let _e: Error = Some("error string").into();
+        let n: Option<&str> = None;
+        let _e2: Error = n.into();
+    }
+}
diff --git a/gbl/libfastboot/BUILD b/gbl/libfastboot/BUILD
index f1955a9..8804e0f 100644
--- a/gbl/libfastboot/BUILD
+++ b/gbl/libfastboot/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
@@ -23,9 +24,15 @@ rust_library(
     srcs = ["src/lib.rs"],
     crate_name = "fastboot",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libasync",
+        "@gbl//liberror",
+    ],
 )
 
 rust_test(
     name = "libfastboot_test",
     crate = ":libfastboot",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libfastboot/src/lib.rs b/gbl/libfastboot/src/lib.rs
index 4b5f18b..0dd4988 100644
--- a/gbl/libfastboot/src/lib.rs
+++ b/gbl/libfastboot/src/lib.rs
@@ -45,7 +45,7 @@
 //!         var: &str,
 //!         args: Split<char>,
 //!         out: &mut [u8],
-//!     ) -> Result<usize, CommandError> {
+//!     ) -> CommandResult<usize> {
 //!         todo!();
 //!     }
 //!
@@ -60,37 +60,39 @@
 //! let mut fastboot_impl: FastbootCommand = ...;
 //! let mut transport: TestTransport = ...;
 //! let download_buffer: &mut [u8] = ...;
-//! let mut fastboot = Fastboot::new(&mut download_buffer[..]);
-//! let result = fastboot.run(&mut transport, &mut fastboot_impl, &[]);
+//! let mut fastboot = Fastboot::new();
+//! let result = run(&mut transport, &mut fastboot_impl, &[]);
 //! ```
 
 #![cfg_attr(not(test), no_std)]
+#![allow(async_fn_in_trait)]
 
-use core::fmt::{Debug, Display, Error, Formatter, Write};
-use core::str::{from_utf8, Split};
+use core::{
+    cmp::min,
+    fmt::{Debug, Display, Formatter, Write},
+    str::{from_utf8, Split},
+};
+use gbl_async::{block_on, yield_now};
+use liberror::{Error, Result};
 
+/// Maximum packet size that can be accepted from the host.
+///
+/// The transport layer may have its own size limits that reduce the packet size further.
 pub const MAX_COMMAND_SIZE: usize = 4096;
+/// Maximum packet size that will be sent to the host.
+///
+/// The `fastboot` host tool originally had a 64-byte packet size max, but this was increased
+/// to 256 in 2020, so any reasonably recent host binary should be able to support 256.
+///
+/// The transport layer may have its own size limits that reduce the packet size further.
 pub const MAX_RESPONSE_SIZE: usize = 256;
-const OKAY: &'static str = "OKAY";
-
-/// Transport errors.
-#[derive(Debug, PartialEq, Eq, Copy, Clone)]
-pub enum TransportError {
-    InvalidHanshake,
-    InvalidState,
-    PacketSizeOverflow,
-    PacketSizeExceedMaximum,
-    NotEnoughUpload,
-    Others(&'static str),
-}
-
-impl Display for TransportError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
-        write!(f, "{:?}", self)
-    }
-}
 
-/// Implementation for Fastboot transport interfaces.
+/// Trait to provide the transport layer for a fastboot implementation.
+///
+/// Fastboot supports these transports:
+/// * USB
+/// * TCP
+/// * UDP
 pub trait Transport {
     /// Fetches the next fastboot packet into `out`.
     ///
@@ -99,13 +101,13 @@ pub trait Transport {
     /// TODO(b/322540167): In the future, we may want to support using `[MaybeUninit<u8>]` as the
     /// download buffer to avoid expensive initialization at the beginning. This would require an
     /// interface where the implementation provides the buffer for us to copy instead of us.
-    fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, TransportError>;
+    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize>;
 
     /// Sends a fastboot packet.
     ///
     /// The method assumes `packet` is sent or at least copied to queue after it returns, where
     /// the buffer can go out of scope without affecting anything.
-    fn send_packet(&mut self, packet: &[u8]) -> Result<(), TransportError>;
+    async fn send_packet(&mut self, packet: &[u8]) -> Result<()>;
 }
 
 /// For now, we hardcode the expected version, until we need to distinguish between multiple
@@ -118,51 +120,45 @@ const TCP_HANDSHAKE_MESSAGE: &[u8] = b"FB01";
 /// to perform fastboot over TCP. It internally handles handshake and wire message parsing.
 pub trait TcpStream {
     /// Reads to `out` for exactly `out.len()` number bytes from the TCP connection.
-    fn read_exact(&mut self, out: &mut [u8]) -> Result<(), TransportError>;
+    async fn read_exact(&mut self, out: &mut [u8]) -> Result<()>;
 
     /// Sends exactly `data.len()` number bytes from `data` to the TCP connection.
-    fn write_exact(&mut self, data: &[u8]) -> Result<(), TransportError>;
+    async fn write_exact(&mut self, data: &[u8]) -> Result<()>;
 }
 
-/// `TcpTransport` implements `Transport` with a `TcpStream` object.
-pub struct TcpTransport<'a>(&'a mut dyn TcpStream);
+/// Implements [Transport] on a [TcpStream].
+pub struct TcpTransport<'a, T: TcpStream>(&'a mut T);
 
-impl<'a> TcpTransport<'a> {
+impl<'a, T: TcpStream> TcpTransport<'a, T> {
     /// Creates an instance from a newly connected TcpStream and performs handshake.
-    pub fn new_and_handshake(tcp_stream: &'a mut dyn TcpStream) -> Result<Self, TransportError> {
+    pub fn new_and_handshake(tcp_stream: &'a mut T) -> Result<Self> {
         let mut handshake = [0u8; 4];
-        tcp_stream.write_exact(TCP_HANDSHAKE_MESSAGE)?;
-        tcp_stream.read_exact(&mut handshake[..])?;
+        block_on(tcp_stream.write_exact(TCP_HANDSHAKE_MESSAGE))?;
+        block_on(tcp_stream.read_exact(&mut handshake[..]))?;
         match handshake == *TCP_HANDSHAKE_MESSAGE {
             true => Ok(Self(tcp_stream)),
-            _ => Err(TransportError::InvalidHanshake),
+            _ => Err(Error::InvalidHandshake),
         }
     }
 }
 
-impl Transport for TcpTransport<'_> {
-    fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, TransportError> {
+impl<'a, T: TcpStream> Transport for TcpTransport<'a, T> {
+    async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
         let mut length_prefix = [0u8; 8];
-        self.0.read_exact(&mut length_prefix[..])?;
-        let packet_size: usize = u64::from_be_bytes(length_prefix)
-            .try_into()
-            .map_err(|_| TransportError::PacketSizeOverflow)?;
+        self.0.read_exact(&mut length_prefix[..]).await?;
+        let packet_size: usize = u64::from_be_bytes(length_prefix).try_into()?;
         match out.len() < packet_size {
-            true => Err(TransportError::PacketSizeExceedMaximum),
+            true => Err(Error::InvalidInput),
             _ => {
-                self.0.read_exact(&mut out[..packet_size])?;
+                self.0.read_exact(&mut out[..packet_size]).await?;
                 Ok(packet_size)
             }
         }
     }
 
-    fn send_packet(&mut self, packet: &[u8]) -> Result<(), TransportError> {
-        self.0.write_exact(
-            &mut u64::try_from(packet.len())
-                .map_err(|_| TransportError::PacketSizeOverflow)?
-                .to_be_bytes()[..],
-        )?;
-        self.0.write_exact(packet)
+    async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
+        self.0.write_exact(&mut u64::try_from(packet.len())?.to_be_bytes()[..]).await?;
+        self.0.write_exact(packet).await
     }
 }
 
@@ -181,10 +177,15 @@ impl CommandError {
     pub fn to_str(&self) -> &str {
         from_utf8(&self.0 .0[..self.0 .1]).unwrap_or("")
     }
+
+    /// Clones the error.
+    pub fn clone(&self) -> Self {
+        self.to_str().into()
+    }
 }
 
 impl Debug for CommandError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
         write!(f, "{}", self.to_str())
     }
 }
@@ -197,6 +198,9 @@ impl<T: Display> From<T> for CommandError {
     }
 }
 
+/// Type alias for Result that wraps a CommandError
+pub type CommandResult<T> = core::result::Result<T, CommandError>;
+
 /// Implementation for Fastboot command backends.
 pub trait FastbootImplementation {
     /// Backend for `fastboot getvar ...`
@@ -214,23 +218,23 @@ pub trait FastbootImplementation {
     /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
     ///
     /// TODO(b/322540167): Figure out other reserved variables.
-    fn get_var(
+    async fn get_var(
         &mut self,
         var: &str,
         args: Split<char>,
         out: &mut [u8],
-        utils: &mut FastbootUtils,
-    ) -> Result<usize, CommandError>;
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<usize>;
 
     /// A helper API for getting the value of a fastboot variable and decoding it into string.
-    fn get_var_as_str<'s>(
+    async fn get_var_as_str<'s>(
         &mut self,
         var: &str,
-        args: Split<char>,
+        args: Split<'_, char>,
         out: &'s mut [u8],
-        utils: &mut FastbootUtils,
-    ) -> Result<&'s str, CommandError> {
-        let size = self.get_var(var, args, out, utils)?;
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<&'s str> {
+        let size = self.get_var(var, args, out, utils).await?;
         Ok(from_utf8(out.get(..size).ok_or("Invalid variable size")?)
             .map_err(|_| "Value is not string")?)
     }
@@ -242,17 +246,16 @@ pub trait FastbootImplementation {
     ///
     /// # Args
     ///
-    /// * `f`: A closure that takes 3 arguments: 1. variable name, 2. an array of string
-    ///   arguments and 3. the corresponding variable value. Implementation should call this for
-    ///   all combinations that need to be returned for `fastboot getvar all`. If `f` returns
-    ///   error, the implementation should return it immediately. For example the following
-    ///   implementation:
+    /// * `sender`: An implementation VarSender. Implementation should call `VarSender::send` for
+    ///   all combinations of Fastboot variable/argument/value that needs to be included in the
+    ///   response to `fastboot getvarl all`:
     ///
-    ///   fn get_var_all(&mut self, f: F, utils: &mut FastbootUtils) -> Result<(), CommandError> {
-    ///       f("partition-size", &["boot_a"], /* size string of boot_a */)?;
-    ///       f("partition-size", &["boot_b"], /* size string of boot_b */)?;
-    ///       f("partition-size", &["init_boot_a"], /* size string of init_boot_a */)?;
-    ///       f("partition-size", &["init_boot_b"], /* size string of init_boot_b */)?;
+    ///   async fn get_var_all(&mut self, f: F, utils: &mut impl FastbootUtils)
+    ///     -> CommandResult<()> {
+    ///       sender.send("partition-size", &["boot_a"], /* size of boot_a */).await?;
+    ///       sender.send("partition-size", &["boot_b"], /* size of boot_b */).await?;
+    ///       sender.send("partition-size", &["init_boot_a"], /* size of init_boot_a */).await?;
+    ///       sender.send("partition-size", &["init_boot_b"], /* size of init_boot_b */).await?;
     ///       Ok(())
     ///   }
     ///
@@ -269,11 +272,17 @@ pub trait FastbootImplementation {
     ///
     /// TODO(b/322540167): This and `get_var()` contain duplicated logic. Investigate if there can
     /// be better solutions for doing the combination traversal.
-    fn get_var_all(
+    async fn get_var_all(
         &mut self,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
-        utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError>;
+        sender: &mut impl VarSender,
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<()>;
+
+    /// Backend for getting download buffer
+    async fn get_download_buffer(&mut self) -> &mut [u8];
+
+    /// Notifies that a download is completed.
+    async fn download_complete(&mut self, download_size: usize) -> CommandResult<()>;
 
     /// Backend for `fastboot flash ...`
     ///
@@ -281,7 +290,7 @@ pub trait FastbootImplementation {
     ///
     /// * `part`: Name of the partition.
     /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    fn flash(&mut self, part: &str, utils: &mut FastbootUtils) -> Result<(), CommandError>;
+    async fn flash(&mut self, part: &str, utils: &mut impl FastbootUtils) -> CommandResult<()>;
 
     /// Backend for `fastboot get_staged ...`
     ///
@@ -291,16 +300,16 @@ pub trait FastbootImplementation {
     ///   example:
     ///
     ///   ```
-    ///   fn upload(
+    ///   async fn upload(
     ///       &mut self,
     ///       upload_builder: UploadBuilder,
-    ///       utils: &mut FastbootUtils,
-    ///   ) -> Result<(), CommandError> {
+    ///       utils: &mut impl FastbootUtils,
+    ///   ) -> CommandResult<()> {
     ///       // Sends a total of 1024 bytes data.
-    ///       let mut uploader = upload_builder.start(1024)?;
+    ///       let mut uploader = upload_builder.start(1024).await?;
     ///       // Can upload in multiple batches.
-    ///       uploader.upload(&utils.download_buffer[..512])?;
-    ///       uploader.upload(&utils.download_buffer[512..])?;
+    ///       uploader.upload(&utils.download_buffer[..512]).await?;
+    ///       uploader.upload(&utils.download_buffer[512..]).await?;
     ///       Ok(())
     ///   }
     ///   ```
@@ -309,11 +318,11 @@ pub trait FastbootImplementation {
     ///   with `Uploader::upload()`, an error will be returned.
     ///
     /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    fn upload(
+    async fn upload(
         &mut self,
-        upload_builder: UploadBuilder,
-        utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError>;
+        upload_builder: impl UploadBuilder,
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<()>;
 
     /// Backend for `fastboot fetch ...`
     ///
@@ -324,14 +333,14 @@ pub trait FastbootImplementation {
     /// * `size`: The number of bytes to upload.
     /// * `upload_builder`: An instance of `UploadBuilder` for initiating and uploading data.
     /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    fn fetch(
+    async fn fetch(
         &mut self,
         part: &str,
         offset: u64,
         size: u64,
-        upload_builder: UploadBuilder,
-        utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError>;
+        upload_builder: impl UploadBuilder,
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<()>;
 
     /// Backend for `fastboot oem ...`.
     ///
@@ -345,12 +354,12 @@ pub trait FastbootImplementation {
     /// # Returns
     ///
     /// On success, returns the portion of `res` used by the construction of string message.
-    fn oem<'a>(
+    async fn oem<'a>(
         &mut self,
         cmd: &str,
-        utils: &mut FastbootUtils,
+        utils: &mut impl FastbootUtils,
         res: &'a mut [u8],
-    ) -> Result<&'a [u8], CommandError>;
+    ) -> CommandResult<&'a [u8]>;
 
     // TODO(b/322540167): Add methods for other commands.
 }
@@ -383,539 +392,426 @@ macro_rules! fastboot_info {
     ( $arr:expr, $( $x:expr ),* ) => { fastboot_msg!($arr, "INFO", $($x,)*) };
 }
 
-/// `FastbootInfoSender` defines a method for sending Fastboot INFO messages.
-///
-/// The trait is for user to implement their mock `FastbootUtils` for testing implementation
-/// of the `FastbootImplementation` trait.
-pub trait FastbootInfoSend {
-    /// Sends a Fastboot "INFO<`msg`>" packet
-    fn send(&mut self, msg: &str) -> Result<(), CommandError>;
+/// `VarSender` provides interfaces for sending variable/args/value combination during the
+/// processing of `fastboot getvar all`
+pub trait VarSender {
+    /// Send a combination of variable name, arguments and value.
+    ///
+    /// In actual fastboot context, the method should send an "INFO<var>:<args>:<val>" message to
+    /// the host.
+    async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()>;
 }
 
-/// `FastbootUtils` contains download data/buffer and a `FastbootInfoSend` trait object for sending
-/// Fastboot INFO messages. It can be used in the implementation of `FastbootImplementation`.
-pub struct FastbootUtils<'a> {
-    // TODO(b/328784766): Consider using arrayvec crate or similar instead of passing download
-    // buffer and size separately.
-    // The total download buffer.
-    download_buffer: &'a mut [u8],
-    // Current downloaded data size.
-    download_data_size: &'a mut usize,
-    /// When available, a trait object `FastbootInfoSend` for sending Fastboot INFO messages.
-    fb_info: Option<&'a mut dyn FastbootInfoSend>,
+/// `FbVarSender` wraps a fastboot transport and implements `VarSender`
+struct FbVarSender<'a, T: Transport> {
+    transport: &'a mut T,
+    transport_error: &'a mut Result<()>,
 }
 
-impl<'a> FastbootUtils<'a> {
-    /// Creates a new instance.
-    pub fn new(
-        download_buffer: &'a mut [u8],
-        download_data_size: &'a mut usize,
-        fb_info: Option<&'a mut dyn FastbootInfoSend>,
-    ) -> Self {
-        Self { download_buffer, download_data_size, fb_info }
+impl<'a, T: Transport> VarSender for FbVarSender<'a, T> {
+    async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()> {
+        // Sends a "INFO<var>:<':'-separated args>:<val>" packet to the host.
+        let mut res = [0u8; MAX_RESPONSE_SIZE];
+        let mut formatted_bytes = FormattedBytes::new(&mut res);
+        write!(formatted_bytes, "INFO{}", name).unwrap();
+        args.iter().for_each(|arg| write!(formatted_bytes, ":{}", arg).unwrap());
+        write!(formatted_bytes, ": {}", val).unwrap();
+        let size = formatted_bytes.size();
+        *self.transport_error = self.transport.send_packet(&res[..size]).await;
+        Ok((*self.transport_error)?)
     }
+}
 
-    /// Returns the current downloaded data.
-    pub fn download_data(&mut self) -> &mut [u8] {
-        &mut self.download_buffer[..*self.download_data_size]
-    }
+/// `FastbootUtil` provides utilities APIs for getting the current downloaded data size and sending
+/// fastboot INFO messages.
+pub trait FastbootUtils {
+    /// Sends a Fastboot "INFO<`msg`>" packet.
+    async fn send_info(&mut self, msg: &str) -> CommandResult<()>;
 
-    /// Returns the entire download buffer and the size of the download data. The method assumes
-    /// that callers will modify the download buffer and therefore will no longer consider the
-    /// download data valid, i.e. future calls of FastbootUtils::download_data() will only return
-    /// an empty slice.
-    pub fn take_download_buffer(&mut self) -> (&mut [u8], usize) {
-        let download_data_size = *self.download_data_size;
-        *self.download_data_size = 0;
-        (self.download_buffer, download_data_size)
-    }
+    /// Returns transport errors if there are any.
+    fn transport_error(&self) -> Result<()>;
+}
 
-    /// Sends a Fastboot INFO message.
-    ///
-    /// Returns Ok(true) if successful, Ok(false) if INFO messages are not supported in the context
-    /// of the current command, error otherwise.
-    pub fn info_send(&mut self, msg: &str) -> Result<bool, CommandError> {
-        match self.fb_info {
-            Some(ref mut send) => send.send(msg).map(|_| true),
-            _ => Ok(false),
-        }
-    }
+/// `FastbootUtilData` implements the FastbootUtil trait for user backend to use.
+struct FastbootUtilData<'a, T: Transport> {
+    transport: &'a mut T,
+    transport_error: Result<()>,
 }
 
-/// `FastbootInfoSender` is an internal type that implements `FastbootInfoSend` with a `Transport`
-/// trait object.
-struct FastbootInfoSender<'a> {
-    transport: &'a mut dyn Transport,
-    transport_error: Result<(), TransportError>,
+impl<'a, T: Transport> FastbootUtilData<'a, T> {
+    fn new(transport: &'a mut T) -> Self {
+        Self { transport, transport_error: Ok(()) }
+    }
 }
 
-impl<'a> FastbootInfoSender<'a> {
-    /// Creates an new instance
-    fn new(transport: &'a mut dyn Transport) -> Self {
-        Self { transport: transport, transport_error: Ok(()) }
+impl<T: Transport> FastbootUtils for FastbootUtilData<'_, T> {
+    async fn send_info(&mut self, msg: &str) -> CommandResult<()> {
+        self.transport_error?;
+        let mut res = [0u8; MAX_RESPONSE_SIZE];
+        self.transport_error = self.transport.send_packet(fastboot_info!(res, "{}", msg)).await;
+        Ok(self.transport_error?)
     }
 
     /// Returns the `Self:;transport_error`.
-    fn transport_error(&self) -> Result<(), TransportError> {
+    fn transport_error(&self) -> Result<()> {
         self.transport_error
     }
 }
 
-impl FastbootInfoSend for FastbootInfoSender<'_> {
-    fn send(&mut self, msg: &str) -> Result<(), CommandError> {
-        self.transport_error?;
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        self.transport_error = self.transport.send_packet(fastboot_info!(res, "{}", msg));
-        Ok(self.transport_error?)
+/// A noop Transport to pass to `FastbootUtilData` when info send is not allowed.
+struct NoopTransport {}
+
+impl Transport for NoopTransport {
+    async fn receive_packet(&mut self, _: &mut [u8]) -> Result<usize> {
+        Ok(0)
     }
+
+    async fn send_packet(&mut self, _: &[u8]) -> Result<()> {
+        Ok(())
+    }
+}
+
+/// `UploadBuilder` provides API for initiating a fastboot upload.
+pub trait UploadBuilder {
+    /// Starts the upload.
+    ///
+    /// In a real fastboot context, the method should send `DATA0xXXXXXXXX` to the remote host to
+    /// start the download. An `Uploader` implementation should be returned for uploading payload.
+    async fn start(self, data_size: u64) -> CommandResult<impl Uploader>;
+}
+
+/// `UploadBuilder` provides API for uploading payload.
+pub trait Uploader {
+    /// Uploads data to the Fastboot host.
+    async fn upload(&mut self, data: &[u8]) -> CommandResult<()>;
 }
 
-/// `UploadBuilder` can be consumed to create an `Uploader` for sending data to the host during
-/// handling of command `fastboot get_staged`.
-pub struct UploadBuilder<'a> {
+/// `FbUploadBuilder` implements the `UploadBuilder`/`Uploader` traits for uploading user payload.
+struct FbUploadBuilder<'a, T: Transport> {
+    transport: &'a mut T,
+    error: &'a mut Result<()>,
     remaining: &'a mut u64,
-    // `send` sends a bytes array as fastboot packet.
-    send: &'a mut dyn FnMut(&[u8]) -> Result<(), CommandError>,
 }
 
-impl<'a> UploadBuilder<'a> {
-    /// Consumes the builder to create an `Uploader` to start uploading data.
-    pub fn start(self, data_size: u64) -> Result<Uploader<'a>, CommandError> {
+impl<'a, T: Transport> UploadBuilder for FbUploadBuilder<'a, T> {
+    async fn start(self, data_size: u64) -> CommandResult<impl Uploader> {
         let mut res = [0u8; 16];
-        (self.send)(snprintf!(res, "DATA{:08x}", data_size).as_bytes())?;
+        self.transport.send_packet(snprintf!(res, "DATA{:08x}", data_size).as_bytes()).await?;
         *self.remaining = data_size;
-        Ok(Uploader { remaining: self.remaining, send: self.send })
+        Ok(self)
     }
 }
 
-/// `UploadBuilder` provides APIs for sending data from the device in response to
-/// `fastboot get_staged`
-pub struct Uploader<'a> {
-    remaining: &'a mut u64,
-    send: &'a mut dyn FnMut(&[u8]) -> Result<(), CommandError>,
-}
-
-impl<'a> Uploader<'a> {
+impl<'a, T: Transport> Uploader for FbUploadBuilder<'a, T> {
     /// Uploads data. Returns error if accumulative amount exceeds `data_size` passed to
     /// `UploadBuilder::start()`.
-    pub fn upload(&mut self, data: &[u8]) -> Result<(), CommandError> {
+    async fn upload(&mut self, data: &[u8]) -> CommandResult<()> {
+        (*self.error)?;
         *self.remaining = self
             .remaining
             .checked_sub(data.len().try_into().map_err(|_| "")?)
             .ok_or::<CommandError>("".into())?;
-        (self.send)(data)
-    }
-}
-
-/// A helper function that creates an `UploadBuilder` from a `Transport` and runs a closure with
-/// it. The helper internally checks that the closure uploads enough data it specifies.
-fn with_upload_builder<F, R>(
-    transport: &mut impl Transport,
-    mut f: F,
-) -> Result<Result<R, CommandError>, TransportError>
-where
-    F: FnMut(UploadBuilder) -> Result<R, CommandError>,
-{
-    let mut transport_error = Ok(());
-    let mut remaining = 0u64;
-    let mut send = |data: &[u8]| -> Result<(), CommandError> {
-        transport_error?;
-        transport_error = transport.send_packet(data);
-        Ok(transport_error?)
-    };
-    let upload_builder = UploadBuilder { remaining: &mut remaining, send: &mut send };
-    let res = f(upload_builder);
-    transport_error?;
-    // Failing to upload enough data should be considered a transport error. Because the remote
-    // host will hang as long as the connection is still active.
-    match remaining > 0 {
-        true => Err(TransportError::NotEnoughUpload),
-        _ => Ok(res),
+        *self.error = self.transport.send_packet(data).await;
+        Ok(())
     }
 }
 
 pub mod test_utils {
-    use crate::{CommandError, UploadBuilder};
+    //! Test utilities to help users of this library write unit tests.
 
-    /// Runs a closure with a mock uploader for user implementation to test
+    use crate::{CommandResult, UploadBuilder, Uploader};
+
+    /// A test implementation of `UploadBuilder` for unittesting
     /// `FastbootImplementation::upload()`.
     ///
-    /// The mock uploader simply uploads to a user provided buffer.
-    ///
-    /// Returns the total uploaded size and remaining size.
-    pub fn with_mock_upload_builder<F>(buffer: &mut [u8], mut f: F) -> (usize, usize)
-    where
-        F: FnMut(UploadBuilder),
-    {
-        let mut remaining = 0u64;
-        let mut sent = 0;
-        let mut send = |data: &[u8]| -> Result<(), CommandError> {
-            // Skips the first 12 bytes "DATAXXXXXXXX" fastboot message.
-            match sent == 0 {
-                true => {
-                    assert_eq!(data.len(), 12);
-                    assert!(data.starts_with(b"DATA"));
-                    sent += data.len()
-                }
-                _ => {
-                    buffer[sent - 12..][..data.len()].clone_from_slice(data);
-                    sent += data.len();
-                }
-            };
+    /// The test uploader simply uploads to a user provided buffer.
+    pub struct TestUploadBuilder<'a>(pub &'a mut [u8]);
+
+    impl<'a> UploadBuilder for TestUploadBuilder<'a> {
+        async fn start(self, _: u64) -> CommandResult<impl Uploader> {
+            Ok(TestUploader(0, self.0))
+        }
+    }
+
+    // (Bytes sent, upload buffer)
+    struct TestUploader<'a>(usize, &'a mut [u8]);
+
+    impl Uploader for TestUploader<'_> {
+        async fn upload(&mut self, data: &[u8]) -> CommandResult<()> {
+            self.1[self.0..][..data.len()].clone_from_slice(data);
+            self.0 = self.0.checked_add(data.len()).unwrap();
             Ok(())
-        };
-        f(UploadBuilder { remaining: &mut remaining, send: &mut send });
-        (core::cmp::max(sent, 12) - 12, remaining.try_into().unwrap())
+        }
     }
 }
 
 const MAX_DOWNLOAD_SIZE_NAME: &'static str = "max-download-size";
 
-/// State of the fastboot protocol.
-enum ProtocolState {
-    Command,
-    Download,
+/// A helper for getting the string version of a fastboot variable value.
+async fn get_var_str<'s>(
+    var: &str,
+    args: Split<'_, char>,
+    out: &'s mut [u8],
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> CommandResult<&'s str> {
+    let mut utils = FastbootUtilData::new(transport);
+    fb_impl.get_var_as_str(var, args, out, &mut utils).await
 }
 
-/// `Fastboot` provides methods for receiving/processing/replying fastboot commands from a
-/// transport.
-pub struct Fastboot<'a> {
-    state: ProtocolState,
-    download_buffer: &'a mut [u8],
-    downloaded_size: usize,
-    total_download_size: usize,
-}
+/// Helper for handling "fastboot getvar ..."
+async fn get_var(
+    mut args: Split<'_, char>,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let Some(var) = args.next() else {
+        return transport.send_packet(fastboot_fail!(res, "Missing variable")).await;
+    };
 
-impl<'a> Fastboot<'a> {
-    /// Creates an instance with a given download buffer.
-    pub fn new(download_buffer: &'a mut [u8]) -> Self {
-        Self {
-            state: ProtocolState::Command,
-            download_buffer: download_buffer,
-            downloaded_size: 0,
-            total_download_size: 0,
+    match var {
+        "all" => return get_var_all(transport, fb_impl).await,
+        MAX_DOWNLOAD_SIZE_NAME => {
+            let msg = fastboot_okay!(res, "{:#x}", fb_impl.get_download_buffer().await.len());
+            return transport.send_packet(msg).await;
         }
-    }
-
-    /// Processes the next fastboot packet from a transport.
-    ///
-    /// # Args
-    ///
-    /// * `transport`: An implementation of `Transport`
-    /// * `fb_impl`: An implementation of `FastbootImplementation`.
-    ///
-    /// # Returns
-    ///
-    /// Returns error if any calls to `transport` methods return error.
-    /// Returns Ok(()) if transport doesn't have any next packet.
-    pub fn process_next_packet(
-        &mut self,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        match self.state {
-            ProtocolState::Command => {
-                let mut packet = [0u8; MAX_COMMAND_SIZE];
-                let cmd_size = transport.receive_packet(&mut packet[..])?;
-                if cmd_size == 0 {
-                    return Ok(());
-                }
-
-                let mut res = [0u8; MAX_RESPONSE_SIZE];
-                let cmd_str = match from_utf8(&packet[..cmd_size]) {
-                    Ok(s) => s,
-                    _ => {
-                        return transport.send_packet(fastboot_fail!(res, "Invalid Command"));
-                    }
-                };
-                let mut args = cmd_str.split(':');
-                let Some(cmd) = args.next() else {
-                    return transport.send_packet(fastboot_fail!(res, "No command"));
-                };
-                match cmd {
-                    "getvar" => self.get_var(args, transport, fb_impl)?,
-                    "download" => self.download(args, transport, fb_impl)?,
-                    "flash" => self.flash(cmd_str, transport, fb_impl)?,
-                    "upload" => self.upload(transport, fb_impl)?,
-                    "fetch" => self.fetch(&cmd_str, args, transport, fb_impl)?,
-                    _ if cmd_str.starts_with("oem ") => {
-                        self.oem(&cmd_str[4..], transport, fb_impl)?;
-                    }
-                    _ => {
-                        return transport.send_packet(fastboot_fail!(res, "Command not found"));
-                    }
-                }
+        v => {
+            let mut val = [0u8; MAX_RESPONSE_SIZE];
+            match get_var_str(v, args, &mut val[..], transport, fb_impl).await {
+                Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)).await,
+                Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
             }
-            ProtocolState::Download => {
-                let (_, remains) = &mut self.download_buffer[..self.total_download_size]
-                    .split_at_mut(self.downloaded_size);
-                match transport.receive_packet(remains) {
-                    Ok(size) if size > remains.len() => {
-                        let mut res = [0u8; MAX_RESPONSE_SIZE];
-                        transport.send_packet(
-                            snprintf!(res, "FAILMore data received then expected").as_bytes(),
-                        )?;
-                        self.total_download_size = 0;
-                        self.downloaded_size = 0;
-                        self.state = ProtocolState::Command;
-                    }
-                    Ok(size) => {
-                        self.downloaded_size = self.downloaded_size.checked_add(size).unwrap();
-                        if self.downloaded_size == self.total_download_size {
-                            self.state = ProtocolState::Command;
-                            transport.send_packet(OKAY.as_bytes())?;
-                        }
-                    }
-                    Err(e) => {
-                        self.total_download_size = 0;
-                        self.downloaded_size = 0;
-                        return Err(e);
-                    }
-                }
-            }
-        };
-        Ok(())
-    }
-
-    /// Fetches and processes the next fastboot command from the transport.
-    ///
-    /// Returns Ok(()) if transport doesn't have any next packet.
-    pub fn process_next_command(
-        &mut self,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        if !matches!(self.state, ProtocolState::Command) {
-            return Err(TransportError::InvalidState);
-        }
-        self.process_next_packet(transport, fb_impl)?;
-        // Keep processing until it is back to the command state.
-        while !matches!(self.state, ProtocolState::Command) {
-            self.process_next_packet(transport, fb_impl)?;
         }
-        Ok(())
     }
+}
 
-    /// Keeps polling and processing fastboot commands from the transport.
-    pub fn run(
-        &mut self,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        loop {
-            self.process_next_command(transport, fb_impl)?;
-        }
-    }
+/// A wrapper of `get_var_all()` that first iterates reserved variables.
+async fn get_var_all_with_native(
+    fb_impl: &mut impl FastbootImplementation,
+    sender: &mut impl VarSender,
+) -> CommandResult<()> {
+    // Process the built-in MAX_DOWNLOAD_SIZE_NAME variable.
+    let mut size_str = [0u8; 32];
+    let size_str = snprintf!(size_str, "{:#x}", fb_impl.get_download_buffer().await.len());
+    sender.send(MAX_DOWNLOAD_SIZE_NAME, &[], size_str).await?;
+    // Don't allow other custom INFO messages because variable values are sent as INFO messages.
+    fb_impl.get_var_all(sender, &mut FastbootUtilData::new(&mut NoopTransport {})).await
+}
 
-    /// Runs a fastboot over TCP session.
-    ///
-    /// The method performs fastboot over TCP handshake and then call `Self::run(...)`.
-    pub fn run_tcp_session(
-        &mut self,
-        tcp_stream: &mut dyn TcpStream,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        self.run(&mut TcpTransport::new_and_handshake(tcp_stream)?, fb_impl)
+/// Method for handling "fastboot getvar all"
+async fn get_var_all(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let transport_error = &mut Ok(());
+    let mut sender = FbVarSender { transport, transport_error };
+    let get_res = get_var_all_with_native(fb_impl, &mut sender).await;
+    (*transport_error)?;
+    match get_res {
+        Ok(()) => transport.send_packet(fastboot_okay!(res, "")).await,
+        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
     }
+}
 
-    /// Method for handling "fastboot getvar ..."
-    fn get_var(
-        &mut self,
-        mut args: Split<char>,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        let Some(var) = args.next() else {
-            return transport.send_packet(fastboot_fail!(res, "Missing variable"));
+/// Helper for handling "fastboot download:...".
+async fn download(
+    mut args: Split<'_, char>,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let total_download_size = match (|| -> CommandResult<usize> {
+        usize::try_from(next_arg_u64(&mut args, Err("Not enough argument".into()))?)
+            .map_err(|_| "Download size overflow".into())
+    })() {
+        Err(e) => return transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+        Ok(v) => v,
+    };
+    let download_buffer = &mut fb_impl.get_download_buffer().await;
+    if total_download_size > download_buffer.len() {
+        return transport.send_packet(fastboot_fail!(res, "Download size is too big")).await;
+    } else if total_download_size == 0 {
+        return transport.send_packet(fastboot_fail!(res, "Zero download size")).await;
+    }
+
+    // Starts the download
+    let download_buffer = &mut download_buffer[..total_download_size];
+    transport.send_packet(snprintf!(res, "DATA{:#x}", total_download_size).as_bytes()).await?;
+    let mut downloaded = 0;
+    while downloaded < total_download_size {
+        let (_, remains) = &mut download_buffer.split_at_mut(downloaded);
+        match transport.receive_packet(remains).await? {
+            0 => yield_now().await,
+            v => match downloaded.checked_add(v) {
+                Some(v) if v > total_download_size => {
+                    let msg = snprintf!(res, "FAILMore data received then expected");
+                    return transport.send_packet(msg.as_bytes()).await;
+                }
+                Some(v) => downloaded = v,
+                _ => return Err(Error::Other(Some("Invalid read size from transport"))),
+            },
         };
-
-        if var == "all" {
-            return self.get_var_all(transport, fb_impl);
-        } else if var == MAX_DOWNLOAD_SIZE_NAME {
-            return transport.send_packet(fastboot_okay!(res, "{:#x}", self.download_buffer.len()));
-        }
-
-        let mut val = [0u8; MAX_RESPONSE_SIZE];
-        match self.get_var_str(var, args, &mut val[..], transport, fb_impl) {
-            Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)),
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-        }
     }
-
-    /// A helper for getting the string version of a fastboot variable value.
-    fn get_var_str<'s>(
-        &mut self,
-        var: &str,
-        args: Split<char>,
-        out: &'s mut [u8],
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<&'s str, CommandError> {
-        let mut info_sender = FastbootInfoSender::new(transport);
-        let mut utils = self.utils(Some(&mut info_sender));
-        fb_impl.get_var_as_str(var, args, out, &mut utils)
-    }
-
-    /// A wrapper of `get_var_all()` that first iterates reserved variables.
-    fn get_var_all_with_native(
-        &mut self,
-        fb_impl: &mut impl FastbootImplementation,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
-    ) -> Result<(), CommandError> {
-        // Process the built-in MAX_DOWNLOAD_SIZE_NAME variable.
-        let mut size_str = [0u8; 32];
-        f(MAX_DOWNLOAD_SIZE_NAME, &[], snprintf!(size_str, "{:#x}", self.download_buffer.len()))?;
-        // Don't allow other custom INFO messages because variable values are sent as INFO
-        // messages.
-        fb_impl.get_var_all(f, &mut self.utils(None))
-    }
-
-    /// Method for handling "fastboot getvar all"
-    fn get_var_all(
-        &mut self,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        let mut transport_error = Ok(());
-        let get_res = self.get_var_all_with_native(fb_impl, &mut |name, args, val| {
-            let mut formatted_bytes = FormattedBytes::new(&mut res);
-            write!(formatted_bytes, "INFO{}", name).unwrap();
-            args.iter().for_each(|arg| write!(formatted_bytes, ":{}", arg).unwrap());
-            write!(formatted_bytes, ": {}", val).unwrap();
-            let size = formatted_bytes.size();
-            transport_error = transport.send_packet(&res[..size]);
-            Ok(transport_error?)
-        });
-        transport_error?;
-        match get_res {
-            Ok(()) => transport.send_packet(fastboot_okay!(res, "")),
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-        }
+    match fb_impl.download_complete(downloaded).await {
+        Ok(()) => transport.send_packet(fastboot_okay!(res, "")).await,
+        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
     }
+}
 
-    /// Method for handling "fastboot download:...".
-    fn download(
-        &mut self,
-        mut args: Split<char>,
-        transport: &mut impl Transport,
-        _: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        let total_download_size = match (|| -> Result<usize, CommandError> {
-            usize::try_from(next_arg_u64(&mut args, Err("Not enough argument".into()))?)
-                .map_err(|_| "Download size overflow".into())
-        })() {
-            Err(e) => return transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-            Ok(v) => v,
+/// Helper for handling "fastboot flash ...".
+async fn flash(
+    cmd: &str,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let flash_res =
+        match cmd.strip_prefix("flash:").ok_or::<CommandError>("Missing partition".into()) {
+            Ok(part) => fb_impl.flash(part, &mut FastbootUtilData::new(transport)).await,
+            Err(e) => Err(e),
         };
-        if total_download_size > self.download_buffer.len() {
-            return transport.send_packet(fastboot_fail!(res, "Download size is too big"));
-        } else if total_download_size == 0 {
-            return transport.send_packet(fastboot_fail!(res, "Zero download size"));
-        }
-
-        transport.send_packet(snprintf!(res, "DATA{:#x}", total_download_size).as_bytes())?;
-        self.total_download_size = total_download_size;
-        self.downloaded_size = 0;
-        self.state = ProtocolState::Download;
-        Ok(())
+    match flash_res {
+        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+        _ => transport.send_packet(fastboot_okay!(res, "")).await,
     }
+}
 
-    /// Method for handling "fastboot flash ...".
-    fn flash(
-        &mut self,
-        cmd: &str,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        match (|| -> Result<(), CommandError> {
-            let part =
-                cmd.strip_prefix("flash:").ok_or::<CommandError>("Missing partition".into())?;
-            fb_impl.flash(part, &mut self.utils(Some(&mut FastbootInfoSender::new(transport))))
-        })() {
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-            _ => transport.send_packet(fastboot_okay!(res, "")),
-        }
+/// Helper for handling "fastboot get_staged ...".
+async fn upload(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    // No INFO message should be sent during upload.
+    let noop_transport = &mut NoopTransport {};
+    let mut utils = FastbootUtilData::new(noop_transport);
+    let mut upload_error = Ok(());
+    let mut remaining = 0;
+    let upload_builder =
+        FbUploadBuilder { transport, error: &mut upload_error, remaining: &mut remaining };
+    let upload_res = fb_impl.upload(upload_builder, &mut utils).await;
+    upload_error?;
+    match remaining > 0 {
+        true => return Err(Error::InvalidInput),
+        _ => match upload_res {
+            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+            _ => transport.send_packet(fastboot_okay!(res, "")).await,
+        },
     }
+}
 
-    /// Method for handling "fastboot get_staged ...".
-    fn upload(
-        &mut self,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        match with_upload_builder(transport, |upload_builder| {
-            // No INFO message should be sent during upload.
-            let mut utils = self.utils(None);
-            fb_impl.upload(upload_builder, &mut utils)
-        })? {
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-            _ => transport.send_packet(fastboot_okay!(res, "")),
+/// Helper for handling "fastboot fetch ...".
+async fn fetch(
+    cmd: &str,
+    args: Split<'_, char>,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let mut upload_error = Ok(());
+    let mut remaining = 0;
+    let upload_builder =
+        FbUploadBuilder { transport, error: &mut upload_error, remaining: &mut remaining };
+    let fetch_res = async {
+        let cmd = cmd.strip_prefix("fetch:").ok_or::<CommandError>("Missing arguments".into())?;
+        if args.clone().count() < 3 {
+            return Err("Not enough argments".into());
         }
+        // Parses backward. Parses size, offset first and treats the remaining string as
+        // partition name. This allows ":" in partition name.
+        let mut rev = args.clone().rev();
+        let sz = next_arg(&mut rev, Err("Invalid argument".into()))?;
+        let off = next_arg(&mut rev, Err("Invalid argument".into()))?;
+        let part = &cmd[..cmd.len() - (off.len() + sz.len() + 2)];
+        // No INFO message should be sent during upload.
+        let noop_transport = &mut NoopTransport {};
+        let mut utils = FastbootUtilData::new(noop_transport);
+        fb_impl.fetch(part, hex_to_u64(off)?, hex_to_u64(sz)?, upload_builder, &mut utils).await
+    }
+    .await;
+    upload_error?;
+    match remaining > 0 {
+        true => return Err(Error::InvalidInput),
+        _ => match fetch_res {
+            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+            _ => transport.send_packet(fastboot_okay!(res, "")).await,
+        },
     }
+}
 
-    /// Method for handling "fastboot fetch ...".
-    pub fn fetch(
-        &mut self,
-        cmd: &str,
-        args: Split<char>,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        match with_upload_builder(transport, |upload_builder| -> Result<(), CommandError> {
-            let cmd =
-                cmd.strip_prefix("fetch:").ok_or::<CommandError>("Missing arguments".into())?;
-            if args.clone().count() < 3 {
-                return Err("Not enough argments".into());
+/// Helper for handling "fastboot oem ...".
+async fn oem(
+    cmd: &str,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut utils = FastbootUtilData::new(transport);
+    let mut oem_out = [0u8; MAX_RESPONSE_SIZE - 4];
+    let oem_res = fb_impl.oem(cmd, &mut utils, &mut oem_out[..]).await;
+    utils.transport_error()?;
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    match oem_res {
+        Ok(msg) => match from_utf8(msg) {
+            Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)).await,
+            Err(e) => {
+                transport.send_packet(fastboot_fail!(res, "Invalid return string {}", e)).await
             }
-            // Parses backward. Parses size, offset first and treats the remaining string as
-            // partition name. This allows ":" in partition name.
-            let mut rev = args.clone().rev();
-            let sz = next_arg(&mut rev, Err("Invalid argument".into()))?;
-            let off = next_arg(&mut rev, Err("Invalid argument".into()))?;
-            let part = &cmd[..cmd.len() - (off.len() + sz.len() + 2)];
-            // No INFO message should be sent during upload.
-            let mut utils = self.utils(None);
-            fb_impl.fetch(part, hex_to_u64(off)?, hex_to_u64(sz)?, upload_builder, &mut utils)
-        })? {
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-            _ => transport.send_packet(fastboot_okay!(res, "")),
-        }
+        },
+        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
     }
+}
 
-    /// Method for handling "fastboot oem ...".
-    fn oem(
-        &mut self,
-        cmd: &str,
-        transport: &mut impl Transport,
-        fb_impl: &mut impl FastbootImplementation,
-    ) -> Result<(), TransportError> {
-        let mut info_sender = FastbootInfoSender::new(transport);
-        let mut utils = self.utils(Some(&mut info_sender));
-        let mut oem_out = [0u8; MAX_RESPONSE_SIZE - 4];
-        let oem_res = fb_impl.oem(cmd, &mut utils, &mut oem_out[..]);
-        info_sender.transport_error()?;
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        match oem_res {
-            Ok(msg) => match from_utf8(msg) {
-                Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)),
-                Err(e) => transport.send_packet(fastboot_fail!(res, "Invalid return string {}", e)),
-            },
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())),
-        }
+/// Process the next Fastboot command from the transport.
+pub async fn process_next_command(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut packet = [0u8; MAX_COMMAND_SIZE];
+    let cmd_size = match transport.receive_packet(&mut packet[..]).await? {
+        0 => return Ok(()),
+        v => v,
+    };
+    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let Ok(cmd_str) = from_utf8(&packet[..cmd_size]) else {
+        return transport.send_packet(fastboot_fail!(res, "Invalid Command")).await;
+    };
+    let mut args = cmd_str.split(':');
+    let Some(cmd) = args.next() else {
+        return transport.send_packet(fastboot_fail!(res, "No command")).await;
+    };
+    match cmd {
+        "getvar" => get_var(args, transport, fb_impl).await,
+        "download" => download(args, transport, fb_impl).await,
+        "flash" => flash(cmd_str, transport, fb_impl).await,
+        "upload" => upload(transport, fb_impl).await,
+        "fetch" => fetch(cmd_str, args, transport, fb_impl).await,
+        _ if cmd_str.starts_with("oem ") => oem(&cmd_str[4..], transport, fb_impl).await,
+        _ => transport.send_packet(fastboot_fail!(res, "Command not found")).await,
     }
+}
 
-    /// Helper method to create an instance of `FastbootUtils`.
-    fn utils<'b>(&'b mut self, info: Option<&'b mut dyn FastbootInfoSend>) -> FastbootUtils<'b> {
-        FastbootUtils::new(self.download_buffer, &mut self.total_download_size, info.map(|v| v))
+/// Keeps polling and processing fastboot commands from the transport.
+pub async fn run(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    loop {
+        process_next_command(transport, fb_impl).await?;
     }
 }
 
+/// Runs a fastboot over TCP session.
+///
+/// The method performs fastboot over TCP handshake and then call `Self::run(...)`.
+pub async fn run_tcp_session(
+    tcp_stream: &mut impl TcpStream,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    run(&mut TcpTransport::new_and_handshake(tcp_stream)?, fb_impl).await
+}
+
 /// A helper data structure for writing formatted string to fixed size bytes array.
 #[derive(Debug)]
 pub struct FormattedBytes<T: AsMut<[u8]>>(T, usize);
@@ -931,11 +827,16 @@ impl<T: AsMut<[u8]>> FormattedBytes<T> {
         self.1
     }
 
+    /// Appends the given `bytes` to the contents.
+    ///
+    /// If `bytes` exceeds the remaining buffer space, any excess bytes are discarded.
+    ///
+    /// Returns the resulting contents.
     pub fn append(&mut self, bytes: &[u8]) -> &mut [u8] {
         let buf = &mut self.0.as_mut()[self.1..];
         // Only write as much as the size of the bytes buffer. Additional write is silently
         // ignored.
-        let to_write = core::cmp::min(buf.len(), bytes.len());
+        let to_write = min(buf.len(), bytes.len());
         buf[..to_write].clone_from_slice(&bytes[..to_write]);
         self.1 += to_write;
         &mut self.0.as_mut()[..self.1]
@@ -963,7 +864,7 @@ macro_rules! snprintf {
 }
 
 /// A helper to convert a hex string into u64.
-pub(crate) fn hex_to_u64(s: &str) -> Result<u64, CommandError> {
+pub(crate) fn hex_to_u64(s: &str) -> CommandResult<u64> {
     Ok(u64::from_str_radix(s.strip_prefix("0x").unwrap_or(s), 16)?)
 }
 
@@ -977,8 +878,8 @@ pub(crate) fn hex_to_u64(s: &str) -> Result<u64, CommandError> {
 ///   requiring that the next argument is mandatory.
 pub fn next_arg<'a, T: Iterator<Item = &'a str>>(
     args: &mut T,
-    default: Result<&'a str, CommandError>,
-) -> Result<&'a str, CommandError> {
+    default: CommandResult<&'a str>,
+) -> CommandResult<&'a str> {
     args.next().filter(|v| *v != "").ok_or("").or(default.map_err(|e| e.into()))
 }
 
@@ -994,8 +895,8 @@ pub fn next_arg<'a, T: Iterator<Item = &'a str>>(
 /// Returns error if the next argument is not a valid hex string.
 pub fn next_arg_u64<'a, T: Iterator<Item = &'a str>>(
     args: &mut T,
-    default: Result<u64, CommandError>,
-) -> Result<u64, CommandError> {
+    default: CommandResult<u64>,
+) -> CommandResult<u64> {
     match next_arg(args, Err("".into())) {
         Ok(v) => hex_to_u64(v),
         _ => default.map_err(|e| e.into()),
@@ -1008,35 +909,30 @@ mod test {
     use std::collections::{BTreeMap, VecDeque};
 
     #[derive(Default)]
-    struct FastbootTest<'a> {
+    struct FastbootTest {
         // A mapping from (variable name, argument) to variable value.
         vars: BTreeMap<(&'static str, &'static [&'static str]), &'static str>,
-        flash_cb: Option<&'a mut dyn FnMut(&str, &mut FastbootUtils) -> Result<(), CommandError>>,
-        upload_cb: Option<
-            &'a mut dyn FnMut(UploadBuilder, &mut FastbootUtils) -> Result<(), CommandError>,
-        >,
-        fetch_cb: Option<
-            &'a mut dyn FnMut(
-                &str,
-                u64,
-                u64,
-                UploadBuilder,
-                &mut FastbootUtils,
-            ) -> Result<(), CommandError>,
-        >,
-        oem_cb: Option<
-            &'a mut dyn FnMut(&str, &mut FastbootUtils, &mut [u8]) -> Result<usize, CommandError>,
-        >,
-    }
-
-    impl FastbootImplementation for FastbootTest<'_> {
-        fn get_var(
+        // The partition arg from Fastboot command
+        flash_partition: String,
+        // Upload size, batches of data to upload,
+        upload_config: (u64, Vec<Vec<u8>>),
+        // A map from partition name to (upload size override, partition data)
+        fetch_data: BTreeMap<&'static str, (u64, Vec<u8>)>,
+        // result string, INFO strings.
+        oem_output: (String, Vec<String>),
+        oem_command: String,
+        download_buffer: Vec<u8>,
+        downloaded_size: usize,
+    }
+
+    impl FastbootImplementation for FastbootTest {
+        async fn get_var(
             &mut self,
             var: &str,
-            args: Split<char>,
+            args: Split<'_, char>,
             out: &mut [u8],
-            _: &mut FastbootUtils,
-        ) -> Result<usize, CommandError> {
+            _: &mut impl FastbootUtils,
+        ) -> CommandResult<usize> {
             let args = args.collect::<Vec<_>>();
             match self.vars.get(&(var, &args[..])) {
                 Some(v) => {
@@ -1047,48 +943,69 @@ mod test {
             }
         }
 
-        fn get_var_all(
+        async fn get_var_all(
             &mut self,
-            f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
-            _: &mut FastbootUtils,
-        ) -> Result<(), CommandError> {
+            sender: &mut impl VarSender,
+            _: &mut impl FastbootUtils,
+        ) -> CommandResult<()> {
             for ((var, config), value) in &self.vars {
-                f(var, config, value)?;
+                sender.send(var, config, value).await?;
             }
             Ok(())
         }
 
-        fn flash(&mut self, part: &str, utils: &mut FastbootUtils) -> Result<(), CommandError> {
-            (self.flash_cb.as_mut().unwrap())(part, utils)
+        async fn get_download_buffer(&mut self) -> &mut [u8] {
+            self.download_buffer.as_mut_slice()
         }
 
-        fn upload(
+        async fn download_complete(&mut self, download_size: usize) -> CommandResult<()> {
+            self.downloaded_size = download_size;
+            Ok(())
+        }
+
+        async fn flash(&mut self, part: &str, _: &mut impl FastbootUtils) -> CommandResult<()> {
+            self.flash_partition = part.into();
+            Ok(())
+        }
+
+        async fn upload(
             &mut self,
-            upload_builder: UploadBuilder,
-            utils: &mut FastbootUtils,
-        ) -> Result<(), CommandError> {
-            (self.upload_cb.as_mut().unwrap())(upload_builder, utils)
+            upload_builder: impl UploadBuilder,
+            _utils: &mut impl FastbootUtils,
+        ) -> CommandResult<()> {
+            let (size, batches) = &self.upload_config;
+            let mut uploader = upload_builder.start(*size).await?;
+            for ele in batches {
+                uploader.upload(&ele[..]).await?;
+            }
+            Ok(())
         }
 
-        fn fetch(
+        async fn fetch(
             &mut self,
             part: &str,
             offset: u64,
             size: u64,
-            upload_builder: UploadBuilder,
-            utils: &mut FastbootUtils,
-        ) -> Result<(), CommandError> {
-            (self.fetch_cb.as_mut().unwrap())(part, offset, size, upload_builder, utils)
+            upload_builder: impl UploadBuilder,
+            _utils: &mut impl FastbootUtils,
+        ) -> CommandResult<()> {
+            let (size_override, data) = self.fetch_data.get(part).ok_or("Not Found")?;
+            let mut uploader = upload_builder.start(*size_override).await?;
+            uploader.upload(&data[offset.try_into().unwrap()..][..size.try_into().unwrap()]).await
         }
 
-        fn oem<'b>(
+        async fn oem<'b>(
             &mut self,
             cmd: &str,
-            utils: &mut FastbootUtils,
+            utils: &mut impl FastbootUtils,
             res: &'b mut [u8],
-        ) -> Result<&'b [u8], CommandError> {
-            let sz = (self.oem_cb.as_mut().unwrap())(cmd, utils, res)?;
-            Ok(&res[..sz])
+        ) -> CommandResult<&'b [u8]> {
+            let (res_str, infos) = &mut self.oem_output;
+            self.oem_command = cmd.into();
+            for ele in infos {
+                utils.send_info(ele.as_str()).await?;
+            }
+            Ok(snprintf!(res, "{}", *res_str).as_bytes())
         }
     }
 
@@ -1108,19 +1025,19 @@ mod test {
     }
 
     impl Transport for TestTransport {
-        fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, TransportError> {
+        async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
             match self.in_queue.pop_front() {
                 Some(v) => {
-                    let size = core::cmp::min(out.len(), v.len());
+                    let size = min(out.len(), v.len());
                     out[..size].clone_from_slice(&v[..size]);
                     // Returns the input length so that we can test bogus download size.
                     Ok(v.len())
                 }
-                _ => Err(TransportError::Others("No more data")),
+                _ => Err(Error::Other(Some("No more data"))),
             }
         }
 
-        fn send_packet(&mut self, packet: &[u8]) -> Result<(), TransportError> {
+        async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
             self.out_queue.push_back(packet.into());
             Ok(())
         }
@@ -1146,14 +1063,14 @@ mod test {
     }
 
     impl TcpStream for TestTcpStream {
-        fn read_exact(&mut self, out: &mut [u8]) -> Result<(), TransportError> {
+        async fn read_exact(&mut self, out: &mut [u8]) -> Result<()> {
             for ele in out {
-                *ele = self.in_queue.pop_front().ok_or(TransportError::Others("No more data"))?;
+                *ele = self.in_queue.pop_front().ok_or(Error::OperationProhibited)?;
             }
             Ok(())
         }
 
-        fn write_exact(&mut self, data: &[u8]) -> Result<(), TransportError> {
+        async fn write_exact(&mut self, data: &[u8]) -> Result<()> {
             data.iter().for_each(|v| self.out_queue.push_back(*v));
             Ok(())
         }
@@ -1162,33 +1079,30 @@ mod test {
     #[test]
     fn test_non_exist_command() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"non_exist");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, [b"FAILCommand not found"]);
     }
 
     #[test]
     fn test_non_ascii_command_string() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"\xff\xff\xff");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, [b"FAILInvalid Command"]);
     }
 
     #[test]
     fn test_get_var_max_download_size() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"getvar:max-download-size");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, [b"OKAY0x400"]);
     }
 
@@ -1203,8 +1117,7 @@ mod test {
         ];
         fastboot_impl.vars = BTreeMap::from(vars);
 
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"getvar:var_0");
         transport.add_input(b"getvar:var_1:a:b");
@@ -1214,7 +1127,7 @@ mod test {
         transport.add_input(b"getvar:var_3"); // Not Found
         transport.add_input(b"getvar"); // Not Found
 
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
@@ -1240,11 +1153,10 @@ mod test {
         ];
         fastboot_impl.vars = BTreeMap::from(vars);
 
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"getvar:all");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
@@ -1261,54 +1173,51 @@ mod test {
     #[test]
     fn test_download() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let download_content: Vec<u8> =
-            (0..download_buffer.len()).into_iter().map(|v| v as u8).collect();
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+            (0..fastboot_impl.download_buffer.len()).into_iter().map(|v| v as u8).collect();
         let mut transport = TestTransport::new();
         // Splits download into two batches.
         let (first, second) = download_content.as_slice().split_at(download_content.len() / 2);
         transport.add_input(format!("download:{:#x}", download_content.len()).as_bytes());
         transport.add_input(first);
         transport.add_input(second);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([b"DATA0x400".into(), b"OKAY".into(),])
         );
-        assert_eq!(download_buffer, download_content);
+        assert_eq!(fastboot_impl.downloaded_size, download_content.len());
+        assert_eq!(fastboot_impl.download_buffer, download_content);
     }
 
     #[test]
     fn test_download_not_enough_args() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"download");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, [b"FAILNot enough argument"]);
     }
 
     #[test]
     fn test_download_invalid_hex_string() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut transport = TestTransport::new();
         transport.add_input(b"download:hhh");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue.len(), 1);
         assert!(transport.out_queue[0].starts_with(b"FAIL"));
     }
 
     fn test_download_size(download_buffer_size: usize, download_size: usize, msg: &str) {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; download_buffer_size];
+        fastboot_impl.download_buffer = vec![0u8; download_buffer_size];
         let mut transport = TestTransport::new();
         transport.add_input(format!("download:{:#x}", download_size).as_bytes());
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([msg.as_bytes().into()]));
     }
 
@@ -1325,15 +1234,14 @@ mod test {
     #[test]
     fn test_download_more_than_expected() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let download_content: Vec<u8> = vec![0u8; download_buffer.len()];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
+        let download_content: Vec<u8> = vec![0u8; fastboot_impl.download_buffer.len()];
         let mut transport = TestTransport::new();
         transport.add_input(format!("download:{:#x}", download_content.len() - 1).as_bytes());
         transport.add_input(&download_content[..]);
         // State should be reset to command state.
         transport.add_input(b"getvar:max-download-size");
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
@@ -1347,30 +1255,16 @@ mod test {
     #[test]
     fn test_oem_cmd() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        const DOWNLOAD_BUFFER_LEN: usize = 2048;
-        let mut download_buffer = vec![0u8; DOWNLOAD_BUFFER_LEN];
-        let download_content: Vec<u8> = (0..1024).into_iter().map(|v| v as u8).collect();
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
-        transport.add_input(format!("download:{:#x}", download_content.len()).as_bytes());
-        transport.add_input(&download_content[..]);
         transport.add_input(b"oem oem-command");
-
-        let mut oem_cb = |cmd: &str, utils: &mut FastbootUtils, res: &mut [u8]| {
-            assert_eq!(cmd, "oem-command");
-            assert_eq!(utils.download_buffer.len(), DOWNLOAD_BUFFER_LEN);
-            assert_eq!(utils.download_data().to_vec(), download_content);
-            assert!(utils.info_send("oem-info-1").unwrap());
-            assert!(utils.info_send("oem-info-2").unwrap());
-            Ok(snprintf!(res, "oem-return").len())
-        };
-        fastboot_impl.oem_cb = Some(&mut oem_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        fastboot_impl.oem_output =
+            ("oem-return".into(), vec!["oem-info-1".into(), "oem-info-2".into()]);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert_eq!(fastboot_impl.oem_command, "oem-command");
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
-                b"DATA0x400".into(),
-                b"OKAY".into(),
                 b"INFOoem-info-1".into(),
                 b"INFOoem-info-2".into(),
                 b"OKAYoem-return".into(),
@@ -1381,74 +1275,43 @@ mod test {
     #[test]
     fn test_flash() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        const DOWNLOAD_BUFFER_LEN: usize = 2048;
-        let mut download_buffer = vec![0u8; DOWNLOAD_BUFFER_LEN];
-        let download_content: Vec<u8> = (0..1024).into_iter().map(|v| v as u8).collect();
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
-        transport.add_input(format!("download:{:#x}", download_content.len()).as_bytes());
-        transport.add_input(&download_content[..]);
         transport.add_input(b"flash:boot_a:0::");
-
-        let mut flash_cb = |part: &str, utils: &mut FastbootUtils| {
-            assert_eq!(part, "boot_a:0::");
-            assert_eq!(utils.download_data().to_vec(), download_content);
-            Ok(())
-        };
-        fastboot_impl.flash_cb = Some(&mut flash_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
-        assert_eq!(
-            transport.out_queue,
-            VecDeque::<Vec<u8>>::from([b"DATA0x400".into(), b"OKAY".into(), b"OKAY".into(),])
-        );
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert_eq!(fastboot_impl.flash_partition, "boot_a:0::");
+        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
     }
 
     #[test]
     fn test_flash_missing_partition() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut fastboot = Fastboot::new(&mut []);
         let mut transport = TestTransport::new();
         transport.add_input(b"flash");
-        let mut flash_cb = |_: &str, _: &mut FastbootUtils| Ok(());
-        fastboot_impl.flash_cb = Some(&mut flash_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(transport.out_queue, [b"FAILMissing partition"]);
     }
 
     #[test]
     fn test_upload() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        const DOWNLOAD_BUFFER_LEN: usize = 2048;
-        let mut download_buffer = vec![0u8; DOWNLOAD_BUFFER_LEN];
-        let download_content: Vec<u8> = (0..1024).into_iter().map(|v| v as u8).collect();
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        let upload_content: Vec<u8> = (0..1024).into_iter().map(|v| v as u8).collect();
         let mut transport = TestTransport::new();
-        transport.add_input(format!("download:{:#x}", download_content.len()).as_bytes());
-        transport.add_input(&download_content[..]);
         transport.add_input(b"upload");
-
-        let mut upload_cb = |upload_builder: UploadBuilder, utils: &mut FastbootUtils| {
-            assert_eq!(utils.download_buffer.len(), DOWNLOAD_BUFFER_LEN);
-            assert_eq!(utils.download_data().to_vec(), download_content);
-            let (download_buffer, download_len) = utils.take_download_buffer();
-            let to_send = &mut download_buffer[..download_len];
-            let mut uploader = upload_builder.start(u64::try_from(to_send.len()).unwrap()).unwrap();
-            uploader.upload(&to_send[..download_len / 2]).unwrap();
-            uploader.upload(&to_send[download_len / 2..]).unwrap();
-            assert!(!utils.info_send("").unwrap());
-            assert_eq!(utils.download_data().len(), 0);
-            Ok(())
-        };
-        fastboot_impl.upload_cb = Some(&mut upload_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        fastboot_impl.upload_config = (
+            upload_content.len().try_into().unwrap(),
+            vec![
+                upload_content[..upload_content.len() / 2].to_vec(),
+                upload_content[upload_content.len() / 2..].to_vec(),
+            ],
+        );
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
-                b"DATA0x400".into(),
-                b"OKAY".into(),
                 b"DATA00000400".into(),
-                download_content[..download_content.len() / 2].to_vec(),
-                download_content[download_content.len() / 2..].to_vec(),
+                upload_content[..upload_content.len() / 2].to_vec(),
+                upload_content[upload_content.len() / 2..].to_vec(),
                 b"OKAY".into(),
             ])
         );
@@ -1457,74 +1320,73 @@ mod test {
     #[test]
     fn test_upload_not_enough_data() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 2048];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
         transport.add_input(b"upload");
-
-        let mut upload_cb = |upload_builder: UploadBuilder, _: &mut FastbootUtils| {
-            let mut uploader = upload_builder.start(0x400).unwrap();
-            uploader.upload(&[0u8; 0x400 - 1]).unwrap();
-            Ok(())
-        };
-        fastboot_impl.upload_cb = Some(&mut upload_cb);
-        assert!(fastboot.run(&mut transport, &mut fastboot_impl).is_err());
+        fastboot_impl.upload_config = (0x400, vec![vec![0u8; 0x400 - 1]]);
+        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
     }
 
     #[test]
     fn test_upload_more_data() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 2048];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
         transport.add_input(b"upload");
-
-        let mut upload_cb = |upload_builder: UploadBuilder, _: &mut FastbootUtils| {
-            let mut uploader = upload_builder.start(0x400).unwrap();
-            uploader.upload(&[0u8; 0x400 + 1])?;
-            Ok(())
-        };
-        fastboot_impl.upload_cb = Some(&mut upload_cb);
-        assert!(fastboot.run(&mut transport, &mut fastboot_impl).is_err());
+        fastboot_impl.upload_config = (0x400, vec![vec![0u8; 0x400 + 1]]);
+        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
     }
 
     #[test]
     fn test_fetch() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 2048];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
         transport.add_input(b"fetch:boot_a:0:::200:400");
-
-        let mut fetch_cb = |part: &str,
-                            offset: u64,
-                            size: u64,
-                            upload_builder: UploadBuilder,
-                            _: &mut FastbootUtils| {
-            assert_eq!(part, "boot_a:0::");
-            assert_eq!(offset, 0x200);
-            assert_eq!(size, 0x400);
-            let mut uploader = upload_builder.start(size)?;
-            uploader.upload(&vec![0u8; size.try_into().unwrap()][..])?;
-            Ok(())
-        };
-        fastboot_impl.fetch_cb = Some(&mut fetch_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        fastboot_impl
+            .fetch_data
+            .insert("boot_a:0::", (0x400, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
                 b"DATA00000400".into(),
-                [0u8; 0x400].to_vec(),
+                [1u8; 0x400].to_vec(),
                 b"OKAY".into(),
             ])
         );
     }
 
+    #[test]
+    fn test_fetch_not_enough_data() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 2048];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"fetch:boot_a:0:::200:400");
+        fastboot_impl
+            .fetch_data
+            .insert("boot_a:0::", (0x400 - 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
+    }
+
+    #[test]
+    fn test_fetch_more_data() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 2048];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"fetch:boot_a:0:::200:400");
+        fastboot_impl
+            .fetch_data
+            .insert("boot_a:0::", (0x400 + 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
+    }
+
     #[test]
     fn test_fetch_invalid_args() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 2048];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 2048];
         let mut transport = TestTransport::new();
         transport.add_input(b"fetch");
         transport.add_input(b"fetch:");
@@ -1534,20 +1396,16 @@ mod test {
         transport.add_input(b"fetch:boot_a::");
         transport.add_input(b"fetch:boot_a:xxx:400");
         transport.add_input(b"fetch:boot_a:200:xxx");
-        let mut fetch_cb =
-            |_: &str, _: u64, _: u64, _: UploadBuilder, _: &mut FastbootUtils| Ok(());
-        fastboot_impl.fetch_cb = Some(&mut fetch_cb);
-        let _ = fastboot.run(&mut transport, &mut fastboot_impl);
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert!(transport.out_queue.iter().all(|v| v.starts_with(b"FAIL")));
     }
 
     #[test]
     fn test_fastboot_tcp() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let download_content: Vec<u8> =
-            (0..download_buffer.len()).into_iter().map(|v| v as u8).collect();
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+            (0..fastboot_impl.download_buffer.len()).into_iter().map(|v| v as u8).collect();
         let mut tcp_stream: TestTcpStream = Default::default();
         tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
         // Add two commands and verify both are executed.
@@ -1556,7 +1414,7 @@ mod test {
             format!("download:{:#x}", download_content.len()).as_bytes(),
         );
         tcp_stream.add_length_prefixed_input(&download_content[..]);
-        let _ = fastboot.run_tcp_session(&mut tcp_stream, &mut fastboot_impl);
+        let _ = block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl));
         let expected: &[&[u8]] = &[
             b"FB01",
             b"\x00\x00\x00\x00\x00\x00\x00\x09OKAY0x400",
@@ -1564,33 +1422,31 @@ mod test {
             b"\x00\x00\x00\x00\x00\x00\x00\x04OKAY",
         ];
         assert_eq!(tcp_stream.out_queue, VecDeque::from(expected.concat()));
-        assert_eq!(download_buffer, download_content);
+        assert_eq!(fastboot_impl.download_buffer, download_content);
     }
 
     #[test]
     fn test_fastboot_tcp_invalid_handshake() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut tcp_stream: TestTcpStream = Default::default();
         tcp_stream.add_input(b"ABCD");
         assert_eq!(
-            fastboot.run_tcp_session(&mut tcp_stream, &mut fastboot_impl).unwrap_err(),
-            TransportError::InvalidHanshake
+            block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap_err(),
+            Error::InvalidHandshake
         );
     }
 
     #[test]
     fn test_fastboot_tcp_packet_size_exceeds_maximum() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        let mut download_buffer = vec![0u8; 1024];
-        let mut fastboot = Fastboot::new(&mut download_buffer[..]);
+        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut tcp_stream: TestTcpStream = Default::default();
         tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
         tcp_stream.add_input(&(MAX_COMMAND_SIZE + 1).to_be_bytes());
         assert_eq!(
-            fastboot.run_tcp_session(&mut tcp_stream, &mut fastboot_impl).unwrap_err(),
-            TransportError::PacketSizeExceedMaximum
+            block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap_err(),
+            Error::InvalidInput
         );
     }
 }
diff --git a/gbl/libfdt/BUILD b/gbl/libfdt/BUILD
index a2b1814..abc5782 100644
--- a/gbl/libfdt/BUILD
+++ b/gbl/libfdt/BUILD
@@ -13,6 +13,7 @@
 # limitations under the License.
 
 load("@gbl//toolchain:gbl_toolchain.bzl", "link_static_cc_library")
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@gbl_llvm_prebuilts//:info.bzl", "LLVM_PREBUILTS_C_INCLUDE")
 load("@rules_rust//bindgen:defs.bzl", "rust_bindgen")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
@@ -21,6 +22,8 @@ package(
     default_visibility = ["//visibility:public"],
 )
 
+exports_files(glob(["**/*"]))
+
 rust_bindgen(
     name = "libfdt_c_bindgen",
     bindgen_flags = [
@@ -55,40 +58,92 @@ use zerocopy::{AsBytes, FromBytes, FromZeroes};
     header = "@libfdt_c//:libfdt.h",
 )
 
-genrule(
-    name = "bindgen_source",
-    srcs = [":libfdt_c_bindgen"],
-    outs = ["src/libfdt_c_Def.rs"],
-    cmd = "cp $(SRCS) $(OUTS)",
+rust_bindgen(
+    name = "libufdt_c_bindgen",
+    bindgen_flags = [
+        "--ctypes-prefix",
+        "core::ffi",
+        "--use-core",
+        "--opaque-type",
+        "fdt_header",
+        "--allowlist-function",
+        "ufdt_apply_multioverlay",
+        "--raw-line",
+        """
+# ![cfg_attr(not(test), no_std)]
+""",
+    ],
+    cc_lib = "@libufdt_c",
+    # For x86_32, we need to explicitly specify 32bit architecture.
+    clang_flags = select({
+        "@gbl//toolchain:gbl_rust_uefi_x86_32": ["-m32"],
+        "//conditions:default": ["-m64"],
+    }) + [
+        "-I{}".format(LLVM_PREBUILTS_C_INCLUDE),
+        "-nostdinc",
+    ],
+    header = "@libufdt_c//:include/ufdt_overlay.h",
 )
 
 rust_library(
-    name = "libfdt_c_def",
-    srcs = [":bindgen_source"],
-    crate_root = ":bindgen_source",
+    name = "libfdt_bindgen",
+    srcs = [":libfdt_c_bindgen"],
     deps = ["@zerocopy"],
 )
 
+rust_library(
+    name = "libufdt_bindgen",
+    srcs = [":libufdt_c_bindgen"],
+)
+
+rust_library(
+    name = "libfdt_sysdeps",
+    srcs = ["deps/lib.rs"],
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//libc",
+    ],
+)
+
+link_static_cc_library(
+    name = "libfdt_sysdeps_static",
+    cc_library = ":libfdt_sysdeps",
+)
+
 rust_library(
     name = "libfdt",
     srcs = ["src/lib.rs"],
     crate_name = "fdt",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
-        ":libfdt_c_def",
+        ":libfdt_bindgen",
         ":libfdt_c_static",
+        ":libfdt_sysdeps_static",
+        ":libufdt_bindgen",
+        ":libufdt_c_static",
         "@gbl//libc",
+        "@gbl//liberror",
+        "@gbl//libsafemath",
         "@zerocopy",
     ],
 )
 
 rust_test(
     name = "libfdt_test",
-    compile_data = ["@gbl//libfdt/test:test.dtb"],
+    compile_data = [
+        "@gbl//libfdt/test/data:all",
+    ],
     crate = ":libfdt",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 link_static_cc_library(
     name = "libfdt_c_static",
     cc_library = "@libfdt_c",
 )
+
+link_static_cc_library(
+    name = "libufdt_c_static",
+    cc_library = "@libufdt_c",
+)
diff --git a/gbl/libfdt/BUILD.libufdt_c.bazel b/gbl/libfdt/BUILD.libufdt_c.bazel
new file mode 100644
index 0000000..492ed2d
--- /dev/null
+++ b/gbl/libfdt/BUILD.libufdt_c.bazel
@@ -0,0 +1,61 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "libufdt_c",
+    srcs = [
+        "ufdt_convert.c",
+        "ufdt_node.c",
+        "ufdt_node_pool.c",
+        "ufdt_overlay.c",
+        "ufdt_prop_dict.c",
+    ] + select({
+        "@gbl//toolchain:gbl_rust_host_x86_64": ["sysdeps/libufdt_sysdeps_posix.c"],
+        "//conditions:default": [
+            "sysdeps/libufdt_sysdeps_vendor.c",
+            # Contains noop placeholder for dto_print from libufdt_sysdeps_vendor.c
+            "@gbl//libfdt:deps/print.c",
+        ],
+    }),
+    hdrs = [
+        "include/libufdt.h",
+        "include/ufdt_node_pool.h",
+        "include/ufdt_overlay.h",
+        "include/ufdt_overlay_internal.h",
+        "include/ufdt_types.h",
+        "sysdeps/include/libufdt_sysdeps.h",
+        "ufdt_prop_dict.h",
+    ],
+    copts = [
+        # Disable default dto_print implementation to include libufdt_sysdeps_vendor.c
+        "-DDTO_DISABLE_DEFAULT_VENDOR_LIBC_PRINT",
+        # Disable default dto_malloc, dto_free implementations to include libufdt_sysdeps_vendor.c
+        "-DDTO_DISABLE_DEFAULT_VENDOR_LIBC_ALLOCATION",
+        # Disable default dto_malloc, dto_free implementations to include libufdt_sysdeps_posix.c
+        "-DDTO_DISABLE_DEFAULT_POSIX_LIBC_ALLOCATION",
+    ],
+    includes = [
+        ".",
+        "include",
+        "sysdeps/include",
+    ],
+    deps = [
+        "@gbl//libc:headers",
+        "@libfdt_c",
+    ],
+)
diff --git a/gbl/libfdt/deps/lib.rs b/gbl/libfdt/deps/lib.rs
new file mode 100644
index 0000000..65fa302
--- /dev/null
+++ b/gbl/libfdt/deps/lib.rs
@@ -0,0 +1,47 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file provides one possible implementation of the sysdeps functions for libufdt.
+//! Global allocator is required.
+
+#![cfg_attr(not(test), no_std)]
+
+use core::ffi::c_void;
+use libc::{gbl_free, gbl_malloc};
+
+const DTO_MALLOC_ALIGNMENT: usize = 8;
+
+/// void *malloc(size_t size)
+///
+/// # Safety:
+///
+/// * `return value` pointing buffer must be used within provided `size`
+#[no_mangle]
+pub unsafe extern "C" fn dto_malloc(size: usize) -> *mut c_void {
+    // SAFETY: libufdt calls are compatible with libc counterparts, alignment the same as
+    // dto_free
+    unsafe { gbl_malloc(size, DTO_MALLOC_ALIGNMENT) }
+}
+
+/// void free(void *ptr)
+///
+/// # Safety:
+///
+/// * `ptr` must be a pointer allocated by `dto_malloc` or null
+#[no_mangle]
+pub unsafe extern "C" fn dto_free(ptr: *mut c_void) {
+    // SAFETY: libufdt calls are compatible with libc counterparts, alignment the same as
+    // dto_malloc
+    unsafe { gbl_free(ptr, DTO_MALLOC_ALIGNMENT) }
+}
diff --git a/gbl/efi/arch/x86_64/deps.S b/gbl/libfdt/deps/print.c
similarity index 65%
rename from gbl/efi/arch/x86_64/deps.S
rename to gbl/libfdt/deps/print.c
index dbe78d9..0cd2a72 100644
--- a/gbl/efi/arch/x86_64/deps.S
+++ b/gbl/libfdt/deps/print.c
@@ -12,16 +12,9 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
  */
 
-/*
- * LLVM mangles the "void __chkstk()" function from rust libcompiler_builtins
- * with an additional underscore, making it "___chkstk" and causing the linker
- * to fail finding "__chkstk". We workaround by defining the magled symbol that
- * simply jumps to the correct target.
- */
-
-.global __chkstk
+// Noop placeholder for dto_print from libufdt
 
-__chkstk:
-    jmp ___chkstk
+void dto_print(const char *fmt, ...) {}
\ No newline at end of file
diff --git a/gbl/libfdt/src/lib.rs b/gbl/libfdt/src/lib.rs
index 791d163..269562e 100644
--- a/gbl/libfdt/src/lib.rs
+++ b/gbl/libfdt/src/lib.rs
@@ -1,4 +1,4 @@
-// Copyright 2023, The Android Open Source Project
+// Copyright 2023-2024, The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -16,84 +16,82 @@
 
 #![cfg_attr(not(test), no_std)]
 
+extern crate alloc;
 extern crate libc;
 
-use core::ffi::CStr;
+use alloc::vec::Vec;
+use core::ffi::{c_int, CStr};
 use core::mem::size_of;
 use core::slice::{from_raw_parts, from_raw_parts_mut};
 
-use libfdt_c_def::{
-    fdt_add_subnode_namelen, fdt_header, fdt_setprop, fdt_setprop_placeholder, fdt_strerror,
-    fdt_subnode_offset_namelen,
+use libfdt_bindgen::{
+    fdt_add_subnode_namelen, fdt_del_node, fdt_get_property, fdt_header, fdt_move, fdt_setprop,
+    fdt_setprop_placeholder, fdt_strerror, fdt_subnode_offset_namelen,
 };
+use libufdt_bindgen::ufdt_apply_multioverlay;
 
-use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
-
-/// libfdt error type.
-#[derive(Debug)]
-pub enum FdtError {
-    CLibError(&'static str),
-    InvalidInput,
-    IntegerOverflow,
-}
+use liberror::{Error, Result};
 
-/// libfdt result type,
-pub type Result<T> = core::result::Result<T, FdtError>;
+use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
 /// Convert libfdt_c error code to Result
-fn map_result(code: core::ffi::c_int) -> Result<core::ffi::c_int> {
+fn map_result(code: c_int) -> Result<c_int> {
     match code {
         // SAFETY: Static null terminated string returned from libfdt_c API.
-        v if v < 0 => Err(FdtError::CLibError(unsafe {
-            core::ffi::CStr::from_ptr(fdt_strerror(v)).to_str().unwrap()
-        })),
+        v if v < 0 => {
+            Err(Error::Other(Some(unsafe { CStr::from_ptr(fdt_strerror(v)).to_str().unwrap() })))
+        }
+        v => Ok(v),
+    }
+}
+
+/// Convert libufdt_c error code to Result
+fn map_result_libufdt(code: c_int) -> Result<c_int> {
+    match code {
+        v if v < 0 => Err(Error::Other(Some("Failed to execute libufdt call"))),
         v => Ok(v),
     }
 }
 
 /// Check header and verified that totalsize does not exceed buffer size.
 fn fdt_check_header(fdt: &[u8]) -> Result<()> {
-    map_result(unsafe { libfdt_c_def::fdt_check_header(fdt.as_ptr() as *const _) })?;
+    // SAFETY:
+    // `fdt_check_header` is only access the memory pointed to by `fdt` during this call and
+    // not store the pointer for later use. `fdt` remains valid for the duration of this call.
+    map_result(unsafe { libfdt_bindgen::fdt_check_header(fdt.as_ptr() as *const _) })?;
     match FdtHeader::from_bytes_ref(fdt)?.totalsize() <= fdt.len() {
         true => Ok(()),
-        _ => Err(FdtError::InvalidInput),
+        _ => Err(Error::InvalidInput),
     }
 }
 
 /// Wrapper of fdt_add_subnode_namelen()
-fn fdt_add_subnode(
-    fdt: &mut [u8],
-    parent: core::ffi::c_int,
-    name: &str,
-) -> Result<core::ffi::c_int> {
+fn fdt_add_subnode(fdt: &mut [u8], parent: c_int, name: &str) -> Result<c_int> {
     // SAFETY: API from libfdt_c.
     map_result(unsafe {
         fdt_add_subnode_namelen(
             fdt.as_mut_ptr() as *mut _,
             parent,
             name.as_ptr() as *const _,
-            name.len().try_into().map_err(|_| FdtError::IntegerOverflow)?,
+            name.len().try_into()?,
         )
     })
 }
 
 /// Wrapper of fdt_subnode_offset_namelen()
-fn fdt_subnode_offset(
-    fdt: &[u8],
-    parent: core::ffi::c_int,
-    name: &str,
-) -> Result<core::ffi::c_int> {
+fn fdt_subnode_offset(fdt: &[u8], parent: c_int, name: &str) -> Result<c_int> {
     // SAFETY: API from libfdt_c.
     map_result(unsafe {
         fdt_subnode_offset_namelen(
             fdt.as_ptr() as *const _,
             parent,
             name.as_ptr() as *const _,
-            name.len().try_into().map_err(|_| FdtError::IntegerOverflow)?,
+            name.len().try_into()?,
         )
     })
 }
 
+/// Rust wrapper for the FDT header data.
 #[repr(transparent)]
 #[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq)]
 pub struct FdtHeader(fdt_header);
@@ -119,7 +117,7 @@ impl FdtHeader {
     /// Cast a bytes into a reference of FDT header
     pub fn from_bytes_ref(buffer: &[u8]) -> Result<&FdtHeader> {
         Ok(Ref::<_, FdtHeader>::new_from_prefix(buffer)
-            .ok_or_else(|| FdtError::InvalidInput)?
+            .ok_or(Error::BufferTooSmall(Some(size_of::<FdtHeader>())))?
             .0
             .into_ref())
     }
@@ -127,7 +125,7 @@ impl FdtHeader {
     /// Cast a bytes into a mutable reference of FDT header.
     pub fn from_bytes_mut(buffer: &mut [u8]) -> Result<&mut FdtHeader> {
         Ok(Ref::<_, FdtHeader>::new_from_prefix(buffer)
-            .ok_or_else(|| FdtError::InvalidInput)?
+            .ok_or(Error::BufferTooSmall(Some(size_of::<FdtHeader>())))?
             .0
             .into_mut())
     }
@@ -141,7 +139,7 @@ impl FdtHeader {
         // SAFETY: By safety requirement of this function, `ptr` points to a valid FDT and remains
         // valid when in use.
         unsafe {
-            map_result(libfdt_c_def::fdt_check_header(ptr as *const _))?;
+            map_result(libfdt_bindgen::fdt_check_header(ptr as *const _))?;
             let header_bytes = from_raw_parts(ptr, size_of::<FdtHeader>());
             let header = Self::from_bytes_ref(header_bytes)?;
             Ok((header, from_raw_parts(ptr, header.totalsize())))
@@ -153,12 +151,14 @@ impl FdtHeader {
 pub struct Fdt<T>(T);
 
 /// Read only APIs.
-impl<T: AsRef<[u8]>> Fdt<T> {
+impl<'a, T: AsRef<[u8]> + 'a> Fdt<T> {
+    /// Creates a new [Fdt] wrapping the contents of `init`.
     pub fn new(init: T) -> Result<Self> {
         fdt_check_header(init.as_ref())?;
         Ok(Fdt(init))
     }
 
+    /// Returns the [FdtHeader], or an error if the underlying buffer was invalid.
     pub fn header_ref(&self) -> Result<&FdtHeader> {
         FdtHeader::from_bytes_ref(self.0.as_ref())
     }
@@ -169,12 +169,12 @@ impl<T: AsRef<[u8]>> Fdt<T> {
     }
 
     /// Get a property from an existing node.
-    pub fn get_property<'a>(&'a self, path: &str, name: &CStr) -> Result<&'a [u8]> {
+    pub fn get_property(&self, path: &str, name: &CStr) -> Result<&'a [u8]> {
         let node = self.find_node(path)?;
-        let mut len: core::ffi::c_int = 0;
+        let mut len: c_int = 0;
         // SAFETY: API from libfdt_c.
         let ptr = unsafe {
-            libfdt_c_def::fdt_get_property(
+            fdt_get_property(
                 self.0.as_ref().as_ptr() as *const _,
                 node,
                 name.to_bytes_with_nul().as_ptr() as *const _,
@@ -187,7 +187,7 @@ impl<T: AsRef<[u8]>> Fdt<T> {
             Some(v) => Ok(unsafe {
                 from_raw_parts(
                     v.data.as_ptr() as *const u8,
-                    u32::from_be(v.len).try_into().map_err(|_| FdtError::IntegerOverflow)?,
+                    u32::from_be(v.len).try_into().or(Err(Error::Other(None)))?,
                 )
             }),
             _ => Err(map_result(len).unwrap_err()),
@@ -195,8 +195,8 @@ impl<T: AsRef<[u8]>> Fdt<T> {
     }
 
     /// Find the offset of a node by a given node path.
-    fn find_node(&self, path: &str) -> Result<core::ffi::c_int> {
-        let mut curr: core::ffi::c_int = 0;
+    fn find_node(&self, path: &str) -> Result<c_int> {
+        let mut curr: c_int = 0;
         for name in path.split('/') {
             if name.len() == 0 {
                 continue;
@@ -209,17 +209,18 @@ impl<T: AsRef<[u8]>> Fdt<T> {
 
 /// APIs when data can be modified.
 impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
+    /// Creates a mutable [Fdt] copied from `init`.
     pub fn new_from_init(mut fdt: T, init: &[u8]) -> Result<Self> {
         fdt_check_header(init)?;
         // SAFETY: API from libfdt_c.
         map_result(unsafe {
-            libfdt_c_def::fdt_move(
+            fdt_move(
                 init.as_ptr() as *const _,
                 fdt.as_mut().as_ptr() as *mut _,
-                fdt.as_mut().len().try_into().map_err(|_| FdtError::IntegerOverflow)?,
+                fdt.as_mut().len().try_into().or(Err(Error::Other(None)))?,
             )
         })?;
-        let new_size: u32 = fdt.as_mut().len().try_into().map_err(|_| FdtError::IntegerOverflow)?;
+        let new_size: u32 = fdt.as_mut().len().try_into().or(Err(Error::Other(None)))?;
         let mut ret = Fdt::new(fdt)?;
         ret.header_mut()?.set_totalsize(new_size);
         Ok(ret)
@@ -240,6 +241,16 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
         Ok(())
     }
 
+    /// Delete node by `path``. Fail if node doesn't exist.
+    pub fn delete_node(&mut self, path: &str) -> Result<()> {
+        let node = self.find_node(path)?;
+        // SAFETY:
+        // * `self.0` is guaranteed to be a proper fdt header reference
+        // * `node` is offset of the node to delete within `self.0` fdt buffer
+        map_result(unsafe { fdt_del_node(self.0.as_mut().as_mut_ptr() as *mut _, node) })?;
+        Ok(())
+    }
+
     /// Set the value of a node's property. Create the node and property if it doesn't exist.
     pub fn set_property(&mut self, path: &str, name: &CStr, val: &[u8]) -> Result<()> {
         let node = self.find_or_add_node(path)?;
@@ -250,7 +261,7 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
                 node,
                 name.to_bytes_with_nul().as_ptr() as *const _,
                 val.as_ptr() as *const _,
-                val.len().try_into().map_err(|_| FdtError::IntegerOverflow)?,
+                val.len().try_into().or(Err(Error::Other(None)))?,
             )
         })?;
         Ok(())
@@ -273,7 +284,7 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
                 self.0.as_mut().as_mut_ptr() as *mut _,
                 node,
                 name.to_bytes_with_nul().as_ptr() as *const _,
-                len.try_into().map_err(|_| FdtError::IntegerOverflow)?,
+                len.try_into().or(Err(Error::Other(None)))?,
                 &mut out_ptr as *mut *mut u8 as *mut _,
             )
         })?;
@@ -282,9 +293,32 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
         Ok(unsafe { from_raw_parts_mut(out_ptr, len) })
     }
 
+    /// Wrapper/equivalent of ufdt_apply_multioverlay.
+    /// It extend current FDT buffer by applying passed overlays.
+    pub fn multioverlay_apply(&mut self, overlays: &[&[u8]]) -> Result<()> {
+        self.shrink_to_fit()?;
+
+        // Have to allocate vector to convert input fat references into the raw pointers
+        let pointers: Vec<_> = overlays.iter().map(|&slice| slice.as_ptr()).collect();
+
+        // SAFETY: The `ufdt_apply_multioverlay` function guarantees that `self.0` is accessed
+        // within the specified length boundaries. The `pointers` are non-null and are accessed
+        // by indexes only within the provided length.
+        map_result_libufdt(unsafe {
+            ufdt_apply_multioverlay(
+                self.0.as_mut().as_mut_ptr() as *mut _,
+                self.0.as_ref().len(),
+                pointers.as_ptr().cast(),
+                overlays.len(),
+            )
+        })?;
+
+        Ok(())
+    }
+
     /// Find the offset of a node by a given node path. Add if node does not exist.
-    fn find_or_add_node(&mut self, path: &str) -> Result<core::ffi::c_int> {
-        let mut curr: core::ffi::c_int = 0;
+    fn find_or_add_node(&mut self, path: &str) -> Result<c_int> {
+        let mut curr: c_int = 0;
         for name in path.split('/') {
             if name.len() == 0 {
                 continue;
@@ -301,15 +335,67 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
 #[cfg(test)]
 mod test {
     use super::*;
-    use std::ffi::CString;
 
-    fn to_cstr(s: &str) -> CString {
-        CString::new(s).unwrap()
+    /// Checks to verify `overlay_*_by_path`/`overlay_*_by_reference` are successfully applied
+    fn check_overlays_are_applied(fdt: &[u8]) {
+        let fdt = Fdt::new(fdt).unwrap();
+
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "overlay1-property-1-value",
+            "overlay_modify: failed to modify \"property-1\" in \"/dev-2/dev-2.2/dev-2.2.1\""
+        );
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-1/overlay1-new-node", c"overlay1-new-node-property")
+                    .unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "overlay1-new-node-property-value",
+            "overlay_modify: failed to add \"overlay1-new-node\" to \"/dev-1\""
+        );
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-4", c"overlay1-root-node-property").unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "overlay1-root-node-property-value",
+            "overlay_modify: failed to add \"/dev-4/overlay1-root-node-property\""
+        );
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"overlay1-new-property").unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "overlay2-new-property-value",
+            "overlay_modify2: failed to modify \"overlay1-new-property\" in \"/dev-2/dev-2.2/dev-2.2.1\""
+        );
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-4", c"overlay2-root-node-property").unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "overlay2-root-node-property-value",
+            "overlay_modify2: failed to add \"overlay2-root-node-property\" to \"/dev-4\""
+        );
     }
 
     #[test]
     fn test_new_from_invalid_fdt() {
-        let mut init = include_bytes!("../test/test.dtb").to_vec();
+        let mut init = include_bytes!("../test/data/base.dtb").to_vec();
         let mut fdt_buf = vec![0u8; init.len()];
         // Invalid total size
         assert!(Fdt::new_from_init(&mut fdt_buf[..], &init[..init.len() - 1]).is_err());
@@ -320,12 +406,12 @@ mod test {
 
     #[test]
     fn test_get_property() {
-        let init = include_bytes!("../test/test.dtb").to_vec();
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
         let mut fdt_buf = vec![0u8; init.len()];
         let fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
 
         assert_eq!(
-            CStr::from_bytes_with_nul(fdt.get_property("/", &to_cstr("info")).unwrap())
+            CStr::from_bytes_with_nul(fdt.get_property("/", c"info").unwrap())
                 .unwrap()
                 .to_str()
                 .unwrap(),
@@ -333,7 +419,7 @@ mod test {
         );
         assert_eq!(
             CStr::from_bytes_with_nul(
-                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", &to_cstr("property-1")).unwrap()
+                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
             )
             .unwrap()
             .to_str()
@@ -342,34 +428,69 @@ mod test {
         );
 
         // Non eixsts
-        assert!(fdt.get_property("/", &to_cstr("non-exist")).is_err());
+        assert!(fdt.get_property("/", c"non-existent").is_err());
     }
 
     #[test]
     fn test_set_property() {
-        let init = include_bytes!("../test/test.dtb").to_vec();
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
         let mut fdt_buf = vec![0u8; init.len() + 512];
         let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
         let data = vec![0x11u8, 0x22u8, 0x33u8];
-        fdt.set_property("/new-node", &to_cstr("custom"), &data).unwrap();
-        assert_eq!(fdt.get_property("/new-node", &to_cstr("custom")).unwrap().to_vec(), data);
+        fdt.set_property("/new-node", c"custom", &data).unwrap();
+        assert_eq!(fdt.get_property("/new-node", c"custom").unwrap().to_vec(), data);
+    }
+
+    #[test]
+    fn test_delete_node() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let mut fdt_buf = vec![0u8; init.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert_eq!(
+            CStr::from_bytes_with_nul(
+                fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").unwrap()
+            )
+            .unwrap()
+            .to_str()
+            .unwrap(),
+            "dev-2.2.1-property-1"
+        );
+
+        fdt.delete_node("dev-2").unwrap();
+
+        assert!(
+            fdt.get_property("/dev-2/dev-2.2/dev-2.2.1", c"property-1").is_err(),
+            "dev-2.2.1-property-1 expected to be deleted"
+        );
+    }
+
+    #[test]
+    fn test_delete_nost_existed_node_is_failed() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let mut fdt_buf = vec![0u8; init.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert!(
+            fdt.delete_node("/non-existent").is_err(),
+            "expected failed to delete non existent node"
+        );
     }
 
     #[test]
     fn test_set_property_placeholder() {
-        let init = include_bytes!("../test/test.dtb").to_vec();
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
         let mut fdt_buf = vec![0u8; init.len() + 512];
         let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
         let data = vec![0x11u8, 0x22u8, 0x33u8, 0x44u8, 0x55u8];
-        let payload =
-            fdt.set_property_placeholder("/new-node", &to_cstr("custom"), data.len()).unwrap();
+        let payload = fdt.set_property_placeholder("/new-node", c"custom", data.len()).unwrap();
         payload.clone_from_slice(&data[..]);
-        assert_eq!(fdt.get_property("/new-node", &to_cstr("custom")).unwrap().to_vec(), data);
+        assert_eq!(fdt.get_property("/new-node", c"custom").unwrap().to_vec(), data);
     }
 
     #[test]
     fn test_header_from_raw() {
-        let init = include_bytes!("../test/test.dtb").to_vec();
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
         // Pointer points to `init`
         let (header, bytes) = unsafe { FdtHeader::from_raw(init.as_ptr()).unwrap() };
         assert_eq!(header.totalsize(), init.len());
@@ -378,7 +499,7 @@ mod test {
 
     #[test]
     fn test_header_from_raw_invalid() {
-        let mut init = include_bytes!("../test/test.dtb").to_vec();
+        let mut init = include_bytes!("../test/data/base.dtb").to_vec();
         init[..4].fill(0);
         // Pointer points to `init`
         assert!(unsafe { FdtHeader::from_raw(init.as_ptr()).is_err() });
@@ -386,7 +507,7 @@ mod test {
 
     #[test]
     fn test_fdt_shrink_to_fit() {
-        let init = include_bytes!("../test/test.dtb").to_vec();
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
         let mut fdt_buf = vec![0u8; init.len() + 512];
         let fdt_buf_len = fdt_buf.len();
         let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
@@ -394,4 +515,119 @@ mod test {
         fdt.shrink_to_fit().unwrap();
         assert_eq!(fdt.size().unwrap(), init.len());
     }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_by_path() {
+        let base = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_modify = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
+        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_path.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
+
+        fdt.multioverlay_apply(&[&overlay_modify[..] as _, &overlay_modify2[..] as _]).unwrap();
+        fdt.shrink_to_fit().unwrap();
+
+        check_overlays_are_applied(fdt.0);
+    }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_by_path_separately() {
+        let base = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_modify = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
+        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_path.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
+
+        fdt.multioverlay_apply(&[&overlay_modify[..] as _]).unwrap();
+        fdt.multioverlay_apply(&[&overlay_modify2[..] as _]).unwrap();
+        fdt.shrink_to_fit().unwrap();
+
+        check_overlays_are_applied(fdt.0);
+    }
+
+    // TODO(b/362486327): symbols from overlay are not added to the result tree
+    // so cannot refer to them.
+    #[ignore]
+    #[test]
+    fn test_fdt_multioverlay_apply_by_reference() {
+        let base = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_modify = include_bytes!("../test/data/overlay_by_reference.dtbo").to_vec();
+        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_reference.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
+
+        fdt.multioverlay_apply(&[&overlay_modify[..] as _, &overlay_modify2[..] as _]).unwrap();
+        fdt.shrink_to_fit().unwrap();
+
+        check_overlays_are_applied(fdt.0);
+    }
+
+    // TODO(b/362486327): symbols from overlay are not added to the result tree
+    // so cannot refer to them.
+    #[ignore]
+    #[test]
+    fn test_fdt_multioverlay_apply_by_reference_separately() {
+        let base = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_modify = include_bytes!("../test/data/overlay_by_reference.dtbo").to_vec();
+        let overlay_modify2 = include_bytes!("../test/data/overlay_2_by_reference.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; base.len() + overlay_modify.len() + overlay_modify2.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &base[..]).unwrap();
+
+        fdt.multioverlay_apply(&[&overlay_modify[..] as _]).unwrap();
+        fdt.multioverlay_apply(&[&overlay_modify2[..] as _]).unwrap();
+        fdt.shrink_to_fit().unwrap();
+
+        check_overlays_are_applied(fdt.0);
+    }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_not_enough_space() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_basic = include_bytes!("../test/data/overlay_by_path.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; init.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert!(
+            fdt.multioverlay_apply(&[&overlay_basic[..]]).is_err(),
+            "expected the problem is catched when not enough space in the main fdt buffer"
+        );
+    }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_corrupted() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_corrupted: Vec<u8> = include_bytes!("../test/data/overlay_by_path.dtbo")
+            .to_vec()
+            .iter()
+            .copied()
+            .rev()
+            .collect();
+
+        let mut fdt_buf = vec![0u8; init.len() + overlay_corrupted.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert!(
+            fdt.multioverlay_apply(&[&overlay_corrupted[..]]).is_err(),
+            "expected the problem is catched when applying corrupted overlay"
+        );
+    }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_with_wrong_target_path() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let overlay_wrong_path = include_bytes!("../test/data/overlay_wrong_path.dtbo").to_vec();
+
+        let mut fdt_buf = vec![0u8; init.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert!(
+            fdt.multioverlay_apply(&[&overlay_wrong_path[..]]).is_err(),
+            "expected the problem is catched when applying overlay with wrong target path"
+        );
+    }
 }
diff --git a/gbl/libfdt/test/test.dts b/gbl/libfdt/test/base.dts
similarity index 61%
rename from gbl/libfdt/test/test.dts
rename to gbl/libfdt/test/base.dts
index f4df645..b02a9f9 100644
--- a/gbl/libfdt/test/test.dts
+++ b/gbl/libfdt/test/base.dts
@@ -1,15 +1,16 @@
 /dts-v1/;
 
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
 / {
 	info = "test device tree";
 
-    dev-1 {};
+    dev1: dev-1 {};
 
     dev-2 {
         dev-2.1 {};
 
         dev-2.2 {
-            dev-2.2.1 {
+            dev221: dev-2.2.1 {
                 property-1 = "dev-2.2.1-property-1";
             };
         };
diff --git a/gbl/patches/BUILD b/gbl/libfdt/test/data/BUILD
similarity index 86%
rename from gbl/patches/BUILD
rename to gbl/libfdt/test/data/BUILD
index 7509dde..8012128 100644
--- a/gbl/patches/BUILD
+++ b/gbl/libfdt/test/data/BUILD
@@ -12,8 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-package(
-    default_visibility = ["//visibility:public"],
+filegroup(
+    name = "all",
+    srcs = glob(["**/*"]),
+    visibility = ["//visibility:public"],
 )
-
-exports_files(glob(["**/*"]))
diff --git a/gbl/libfdt/test/data/base.dtb b/gbl/libfdt/test/data/base.dtb
new file mode 100644
index 0000000..18e587c
Binary files /dev/null and b/gbl/libfdt/test/data/base.dtb differ
diff --git a/gbl/libfdt/test/data/overlay_2_by_path.dtbo b/gbl/libfdt/test/data/overlay_2_by_path.dtbo
new file mode 100644
index 0000000..397e7a6
Binary files /dev/null and b/gbl/libfdt/test/data/overlay_2_by_path.dtbo differ
diff --git a/gbl/libfdt/test/data/overlay_2_by_reference.dtbo b/gbl/libfdt/test/data/overlay_2_by_reference.dtbo
new file mode 100644
index 0000000..7ee1f7d
Binary files /dev/null and b/gbl/libfdt/test/data/overlay_2_by_reference.dtbo differ
diff --git a/gbl/libfdt/test/data/overlay_by_path.dtbo b/gbl/libfdt/test/data/overlay_by_path.dtbo
new file mode 100644
index 0000000..4fb94a9
Binary files /dev/null and b/gbl/libfdt/test/data/overlay_by_path.dtbo differ
diff --git a/gbl/libfdt/test/data/overlay_by_reference.dtbo b/gbl/libfdt/test/data/overlay_by_reference.dtbo
new file mode 100644
index 0000000..0b72ff0
Binary files /dev/null and b/gbl/libfdt/test/data/overlay_by_reference.dtbo differ
diff --git a/gbl/libfdt/test/data/overlay_wrong_path.dtbo b/gbl/libfdt/test/data/overlay_wrong_path.dtbo
new file mode 100644
index 0000000..04cef77
Binary files /dev/null and b/gbl/libfdt/test/data/overlay_wrong_path.dtbo differ
diff --git a/gbl/libfdt/test/gen_test_dtb.sh b/gbl/libfdt/test/gen_test_dtb.sh
index a514265..5d4764a 100755
--- a/gbl/libfdt/test/gen_test_dtb.sh
+++ b/gbl/libfdt/test/gen_test_dtb.sh
@@ -17,5 +17,14 @@
 set -e
 
 readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
+readonly DATA_DIR="${SCRIPT_DIR}/data/"
 
-dtc -I dts -O dtb -o ${SCRIPT_DIR}/test.dtb ${SCRIPT_DIR}/test.dts
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/base.dtb ${SCRIPT_DIR}/base.dts
+
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_by_path.dtbo ${SCRIPT_DIR}/overlay_by_path.dts
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_2_by_path.dtbo ${SCRIPT_DIR}/overlay_2_by_path.dts
+
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_by_reference.dtbo ${SCRIPT_DIR}/overlay_by_reference.dts
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_2_by_reference.dtbo ${SCRIPT_DIR}/overlay_2_by_reference.dts
+
+dtc -@ -I dts -O dtb -o ${DATA_DIR}/overlay_wrong_path.dtbo ${SCRIPT_DIR}/overlay_wrong_path.dts
diff --git a/gbl/libfdt/test/overlay_2_by_path.dts b/gbl/libfdt/test/overlay_2_by_path.dts
new file mode 100644
index 0000000..c23e54e
--- /dev/null
+++ b/gbl/libfdt/test/overlay_2_by_path.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
+/ {
+    // change the value of a property added by a previous overlay
+    fragment@1 {
+        target-path = "/dev-2/dev-2.2/dev-2.2.1";
+        __overlay__ {
+            overlay1-new-property = "overlay2-new-property-value";
+        };
+    };
+
+    // add a new property to the node added by a previous overlay
+    fragment@2 {
+        target-path = "/dev-4";
+        __overlay__ {
+            overlay2-root-node-property = "overlay2-root-node-property-value";
+        };
+    };
+};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_2_by_reference.dts b/gbl/libfdt/test/overlay_2_by_reference.dts
new file mode 100644
index 0000000..489ac5c
--- /dev/null
+++ b/gbl/libfdt/test/overlay_2_by_reference.dts
@@ -0,0 +1,22 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
+/ {
+    // change the value of a property added by a previous overlay
+    fragment@1 {
+        target = <&dev221>;
+        __overlay__ {
+            overlay1-new-property = "overlay2-new-property-value";
+        };
+    };
+
+    // add a new property to the node added by a previous overlay
+    fragment@2 {
+        // TODO(b/362486327): failed to refer dev4 added by previous overlay
+        target = <&dev4>;
+        __overlay__ {
+            overlay2-root-node-property = "overlay2-root-node-property-value";
+        };
+    };
+};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_by_path.dts b/gbl/libfdt/test/overlay_by_path.dts
new file mode 100644
index 0000000..ad483a0
--- /dev/null
+++ b/gbl/libfdt/test/overlay_by_path.dts
@@ -0,0 +1,41 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
+/ {
+    // modify a property in an existing node
+    fragment@0 {
+        target-path = "/dev-2/dev-2.2/dev-2.2.1";
+        __overlay__ {
+            property-1 = "overlay1-property-1-value";
+        };
+    };
+
+    // add a new property to an existing node
+    fragment@1 {
+        target-path = "/dev-2/dev-2.2/dev-2.2.1";
+        __overlay__ {
+            overlay1-new-property = "overlay1-new-property-value";
+        };
+    };
+
+    // add a new node under an existing node
+    fragment@2 {
+        target-path = "/dev-1";
+        __overlay__ {
+            overlay1-new-node {
+                overlay1-new-node-property = "overlay1-new-node-property-value";
+            };
+        };
+    };
+
+    // add a new node at the root level
+    fragment@3 {
+        target-path = "/";
+        __overlay__ {
+            dev4: dev-4 {
+                overlay1-root-node-property = "overlay1-root-node-property-value";
+            };
+        };
+    };
+};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_by_reference.dts b/gbl/libfdt/test/overlay_by_reference.dts
new file mode 100644
index 0000000..ac46bfd
--- /dev/null
+++ b/gbl/libfdt/test/overlay_by_reference.dts
@@ -0,0 +1,42 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
+/ {
+    // modify a property in an existing node
+    fragment@0 {
+        target = <&dev221>;
+        __overlay__ {
+            property-1 = "overlay1-property-1-value";
+        };
+    };
+
+    // add a new property to an existing node
+    fragment@1 {
+        target = <&dev221>;
+        __overlay__ {
+            overlay1-new-property = "overlay1-new-property-value";
+        };
+    };
+
+    // add a new node under an existing node
+    fragment@2 {
+        target = <&dev1>;
+        __overlay__ {
+            overlay1-new-node {
+                overlay1-new-node-property = "overlay1-new-node-property-value";
+            };
+        };
+    };
+
+    // add a new node at the root level
+    fragment@3 {
+        target-path = "/";
+        __overlay__ {
+            // TODO(b/362486327): failed to refer dev4 in the following overlays
+            dev4: dev-4 {
+                overlay1-root-node-property = "overlay1-root-node-property-value";
+            };
+        };
+    };
+};
\ No newline at end of file
diff --git a/gbl/libfdt/test/overlay_wrong_path.dts b/gbl/libfdt/test/overlay_wrong_path.dts
new file mode 100644
index 0000000..7f1a4e7
--- /dev/null
+++ b/gbl/libfdt/test/overlay_wrong_path.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+// re-generate and push test artifacts using ./gen_test_dtb.sh after change in this file
+/ {
+    // check wrong target-path
+    fragment@0 {
+        target-path = "/doesnt-exist";
+        __overlay__ {
+            property-1 = "overlay1-property-1-value";
+        };
+    };
+};
\ No newline at end of file
diff --git a/gbl/libfdt/test/test.dtb b/gbl/libfdt/test/test.dtb
deleted file mode 100644
index 4aa1685..0000000
Binary files a/gbl/libfdt/test/test.dtb and /dev/null differ
diff --git a/gbl/libgbl/BUILD b/gbl/libgbl/BUILD
index 0555d47..2132066 100644
--- a/gbl/libgbl/BUILD
+++ b/gbl/libgbl/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 rust_library(
@@ -22,12 +23,18 @@ rust_library(
     ),
     aliases = {"@itertools_noalloc": "itertools_noalloc"},
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     visibility = ["//visibility:public"],
     deps = [
         "@avb",
+        "@avb//:avb_bindgen",
         "@bitflags",
         "@crc32fast",
         "@cstr",
+        "@gbl//libabr",
+        "@gbl//libasync",
+        "@gbl//libboot",
+        "@gbl//liberror",
         "@gbl//libfastboot",
         "@gbl//libsafemath",
         "@gbl//libstorage",
@@ -35,6 +42,7 @@ rust_library(
         "@itertools_noalloc",
         "@spin",
         "@static_assertions",
+        "@uuid",
         "@zerocopy",
     ],
 )
@@ -42,21 +50,38 @@ rust_library(
 rust_test(
     name = "libgbl_test",
     aliases = {"@itertools_noalloc": "itertools_noalloc"},
-    compile_data = ["@gbl//libstorage/test:test_data"],
+    compile_data = [
+        "@gbl//libstorage/test:test_data",
+    ],
     crate = ":libgbl",
     crate_features = ["uuid"],
     data = [
+        "@gbl//libgbl/testdata:cert_metadata.bin",
+        "@gbl//libgbl/testdata:cert_permanent_attributes.bad.bin",
+        "@gbl//libgbl/testdata:cert_permanent_attributes.bad.hash",
+        "@gbl//libgbl/testdata:cert_permanent_attributes.bin",
+        "@gbl//libgbl/testdata:cert_permanent_attributes.hash",
         "@gbl//libgbl/testdata:sparse_test.bin",
         "@gbl//libgbl/testdata:sparse_test_blk1024.bin",
         "@gbl//libgbl/testdata:sparse_test_raw.bin",
         "@gbl//libgbl/testdata:testkey_rsa4096_pub.bin",
+        "@gbl//libgbl/testdata:vbmeta_a.bin",
+        "@gbl//libgbl/testdata:vbmeta_b.bin",
+        "@gbl//libgbl/testdata:vbmeta_r.bin",
+        "@gbl//libgbl/testdata:vbmeta_slotless.bin",
         "@gbl//libgbl/testdata:writeback_test_disk.bin",
-        "@gbl//libgbl/testdata:zircon_a.bin",
         "@gbl//libgbl/testdata:zircon_a.vbmeta",
+        "@gbl//libgbl/testdata:zircon_a.vbmeta.cert",
+        "@gbl//libgbl/testdata:zircon_a.zbi",
+        "@gbl//libgbl/testdata:zircon_b.zbi",
+        "@gbl//libgbl/testdata:zircon_r.zbi",
+        "@gbl//libgbl/testdata:zircon_slotless.zbi",
     ],
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         "@avb//:avb_crypto_ops_sha_impl_staticlib",
         "@avb//:avb_test",
+        "@gbl//libasync:cyclic_executor",
         "@gbl//libavb:sysdeps",
         "@gbl//libstorage:libstorage_testlib",
         "@itertools",
@@ -65,21 +90,3 @@ rust_test(
         "@uuid",
     ],
 )
-
-rust_test(
-    name = "integration_test",
-    srcs = ["tests/integration_tests.rs"],
-    compile_data = [
-        "@gbl//libgbl/testdata:zircon_a.bin",
-        "@gbl//libgbl/testdata:zircon_b.bin",
-        "@gbl//libgbl/testdata:zircon_r.bin",
-        "@gbl//libgbl/testdata:zircon_gpt.bin",
-    ],
-    deps = [
-        ":libgbl",
-        "@avb//:avb_crypto_ops_sha_impl_staticlib",
-        "@gbl//libavb:sysdeps",
-        "@gbl//libstorage",
-        "@gbl//libstorage:libstorage_testlib",
-    ],
-)
diff --git a/gbl/libgbl/src/error.rs b/gbl/libgbl/src/error.rs
index acfe8be..2e9ac12 100644
--- a/gbl/libgbl/src/error.rs
+++ b/gbl/libgbl/src/error.rs
@@ -14,53 +14,8 @@
 
 //! Error types used in libgbl.
 
-use crate::GblOpsError;
-use avb::{DescriptorError, SlotVerifyError};
-use core::ffi::{FromBytesUntilNulError, FromBytesWithNulError};
+use avb::{DescriptorError, IoError, SlotVerifyError};
 use core::fmt::{Debug, Display, Formatter};
-use gbl_storage::StorageError;
-
-/// Helper type GBL functions will return.
-pub type Result<T> = core::result::Result<T, IntegrationError>;
-
-#[derive(Debug, PartialEq, Eq)]
-/// Errors originating from GBL native logic.
-pub enum Error {
-    ArithmeticOverflow,
-    /// Fail to hand off to kernel.
-    BootFailed,
-    /// Generic error
-    Error,
-    /// Missing all images required to boot system
-    MissingImage,
-    /// Functionality is not implemented
-    NotImplemented,
-    /// Some combination of parameters and global state prohibits the operation
-    OperationProhibited,
-    /// Internal error
-    Internal,
-    /// AvbOps were already borrowed. This would happen on second `load_and_verify_image()` call
-    /// unless `reuse()` is called before.
-    AvbOpsBusy,
-    /// Buffers overlap and can cause undefined behavior and data corruption.
-    BufferOverlap,
-}
-
-impl Display for Error {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        match self {
-            Error::ArithmeticOverflow => write!(f, "Arithmetic Overflow"),
-            Error::BootFailed => write!(f, "Failed to boot"),
-            Error::Error => write!(f, "Generic error"),
-            Error::MissingImage => write!(f, "Missing image required to boot system"),
-            Error::NotImplemented => write!(f, "Functionality is not implemented"),
-            Error::OperationProhibited => write!(f, "Operation is prohibited"),
-            Error::Internal => write!(f, "Internal error"),
-            Error::AvbOpsBusy => write!(f, "AvbOps were already borrowed"),
-            Error::BufferOverlap => write!(f, "Buffers overlap"),
-        }
-    }
-}
 
 /// A helper macro for declaring a composite enum type that simply wraps other types as entries.
 /// It auto-generate `From<...>` implementation for each entry type. The type for each entry must
@@ -107,6 +62,7 @@ macro_rules! composite_enum {
             $(,)*
         }
     ) => {
+        #[allow(missing_docs)]
         // Copy over enum declaration as it is.
         $(#[$outer])*
         $vis enum $name {
@@ -140,15 +96,12 @@ composite_enum! {
     pub enum IntegrationError {
         /// Failed to get descriptor from AvbMeta
         AvbDescriptorError(DescriptorError),
+        AvbIoError(IoError),
         /// Avb slot verification failed.
         /// SlotVerifyError is used without verify data.
         AvbSlotVerifyError(SlotVerifyError<'static>),
-        GblNativeError(Error),
-        GblOpsError(GblOpsError),
-        FromBytesUntilNulError(FromBytesUntilNulError),
-        FromBytesWithNulError(FromBytesWithNulError),
-        StorageError(StorageError),
-        SafeMathError(safemath::Error),
+        UnificationError(liberror::Error),
+        ZbiError(zbi::ZbiError),
     }
 }
 
@@ -157,3 +110,6 @@ impl Display for IntegrationError {
         write!(f, "{:?}", self)
     }
 }
+
+/// Helper type GBL functions will return.
+pub type Result<T> = core::result::Result<T, IntegrationError>;
diff --git a/gbl/libgbl/src/fastboot/mod.rs b/gbl/libgbl/src/fastboot/mod.rs
index dcdb081..22c731b 100644
--- a/gbl/libgbl/src/fastboot/mod.rs
+++ b/gbl/libgbl/src/fastboot/mod.rs
@@ -12,283 +12,360 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use core::cmp::min;
-use core::ffi::CStr;
-use core::str::Split;
+//! Fastboot backend for libgbl.
+
+use crate::{partition::check_part_unique, GblOps};
+use core::{
+    cmp::min,
+    fmt::Write,
+    future::Future,
+    mem::take,
+    str::{from_utf8, Split},
+};
 use fastboot::{
-    next_arg, next_arg_u64, CommandError, FastbootImplementation, FastbootUtils, UploadBuilder,
+    next_arg, next_arg_u64, snprintf, CommandResult, FastbootImplementation, FastbootUtils,
+    FormattedBytes, UploadBuilder, Uploader, VarSender,
 };
-use gbl_storage::{AsBlockDevice, AsMultiBlockDevices, GPT_NAME_LEN_U16};
+use gbl_async::yield_now;
+use safemath::SafeNum;
+use spin::{Mutex, MutexGuard};
 
 mod vars;
-use vars::{BlockDevice, Partition, Variable};
-
-mod sparse;
-use sparse::{is_sparse_image, write_sparse_image};
-
-pub(crate) const GPT_NAME_LEN_U8: usize = GPT_NAME_LEN_U16 * 2;
-
-/// `GblFbPartition` represents a GBL Fastboot partition, which is defined as any sub window of a
-/// GPT partition or raw storage.
-#[derive(Debug, Copy, Clone)]
-pub(crate) struct GblFbPartition {
-    // GPT partition if it is a non-null string, raw block otherwise.
-    part: [u8; GPT_NAME_LEN_U8],
-    blk_id: u64,
-    // The offset where the window starts.
-    window_start: u64,
-    // The size of the window.
-    window_size: u64,
-}
-
-impl GblFbPartition {
-    pub fn part(&self) -> &str {
-        // The construction is guaranteed to give a valid UTF8 string.
-        CStr::from_bytes_until_nul(&self.part[..]).unwrap().to_str().unwrap()
-    }
-}
-
-/// `GblFbPartitionIo` provides read/write/size methods for a GBL Fastboot partition.
-pub(crate) struct GblFbPartitionIo<'a> {
-    part: GblFbPartition,
-    devs: &'a mut dyn AsMultiBlockDevices,
-}
-
-impl GblFbPartitionIo<'_> {
-    /// Checks read/write offset/size and returns the absolute offset.
-    fn check_range(&self, rw_off: u64, rw_size: usize) -> Result<u64, CommandError> {
-        if add(rw_off, u64::try_from(rw_size)?)? > self.part.window_size {
-            return Err("Read/Write range overflow".into());
-        }
-        Ok(add(rw_off, self.part.window_start)?)
-    }
-
-    /// Reads from the GBL Fastboot partition.
-    pub fn read(&mut self, offset: u64, out: &mut [u8]) -> Result<(), CommandError> {
-        let offset = self.check_range(offset, out.len())?;
-        let mut dev = (&mut self.devs).get(self.part.blk_id)?;
-        Ok(match self.part.part() {
-            "" => dev.read(offset, out),
-            part => dev.read_gpt_partition(part, offset, out),
-        }?)
-    }
+use vars::{fb_vars_get, fb_vars_get_all};
 
-    /// Writes to the GBL Fastboot partition.
-    pub fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<(), CommandError> {
-        let offset = self.check_range(offset, data.len())?;
-        let mut dev = (&mut self.devs).get(self.part.blk_id)?;
-        Ok(match self.part.part() {
-            "" => dev.write(offset, data),
-            part => dev.write_gpt_partition(part, offset, data),
-        }?)
-    }
+pub(crate) mod sparse;
+use sparse::is_sparse_image;
 
-    /// Returns the size of the GBL Fastboot partition.
-    pub fn size(&mut self) -> u64 {
-        self.part.window_size
-    }
+/// `TasksExecutor` provides interfaces for spawning and scheduling async tasks.
+pub trait TasksExecutor<'a> {
+    /// Spawns a new task.
+    fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()>;
 }
 
 /// `GblFastboot` implements fastboot commands in the GBL context.
-pub struct GblFastboot<'a> {
-    pub storage: &'a mut dyn AsMultiBlockDevices,
+pub struct GblFastboot<'a, 'b, T: TasksExecutor<'b>, G> {
+    blk_io_executor: &'a T,
+    pub(crate) gbl_ops: &'b mut G,
+    download_buffers: &'b [Mutex<&'b mut [u8]>],
+    current_download_buffer: Option<MutexGuard<'b, &'b mut [u8]>>,
+    current_download_size: usize,
+    enable_async_block_io: bool,
+    default_block: Option<usize>,
 }
 
-impl<'a> GblFastboot<'a> {
-    /// Native GBL fastboot variables.
-    const NATIVE_VARS: &'static [&'static dyn Variable] = &[
-        &("version-bootloader", "1.0"), // Placeholder for now.
-        // GBL Fastboot can internally handle uploading in batches, thus there is no limit on
-        // max-fetch-size.
-        &("max-fetch-size", "0xffffffffffffffff"),
-        &BlockDevice {},
-        &Partition {},
-    ];
-
+impl<'a, 'b, T: TasksExecutor<'b>, G: GblOps<'b>> GblFastboot<'a, 'b, T, G> {
     /// Creates a new instance.
-    pub fn new(storage: &'a mut dyn AsMultiBlockDevices) -> Self {
-        Self { storage: storage }
+    pub fn new(
+        blk_io_executor: &'a T,
+        gbl_ops: &'b mut G,
+        download_buffers: &'b [Mutex<&'b mut [u8]>],
+    ) -> Self {
+        Self {
+            blk_io_executor,
+            gbl_ops,
+            download_buffers,
+            current_download_buffer: None,
+            current_download_size: 0,
+            enable_async_block_io: false,
+            default_block: None,
+        }
     }
 
-    /// Returns the storage object.
-    ///
-    /// `AsMultiBlockDevices` has methods with `Self: Sized` constraint. Thus we return a
-    /// `&mut &mut dyn AsMultiBlockDevices` which also implements `AsMultiBlockDevices` but meets
-    /// the `Sized` bound.
-    pub fn storage(&mut self) -> &mut &'a mut dyn AsMultiBlockDevices {
-        &mut self.storage
+    /// Returns the block IO task executor.
+    pub fn blk_io_executor(&self) -> &'a T {
+        self.blk_io_executor
     }
 
-    /// Parses and checks partition name, block device ID and offset from the arguments and
-    /// returns an instance of `GblFbPartition`.
-    pub(crate) fn parse_partition<'b>(
-        &mut self,
-        mut args: Split<'b, char>,
-    ) -> Result<GblFbPartition, CommandError> {
-        let devs = self.storage();
-        // Copies over partition name string
-        let part = next_arg(&mut args, Ok(""))?;
-        let mut part_str = [0u8; GPT_NAME_LEN_U8];
-        part_str
-            .get_mut(..part.len())
-            .ok_or("Partition name too long")?
-            .clone_from_slice(part.as_bytes());
+    /// Parses and checkds the partition argument and returns the partition name, block device
+    /// index, start offset and size.
+    pub(crate) fn parse_partition<'s>(
+        &self,
+        mut args: Split<'s, char>,
+    ) -> CommandResult<(Option<&'s str>, usize, u64, u64)> {
+        let devs = self.gbl_ops.partitions()?;
+        // Parses partition name.
+        let part = next_arg(&mut args, Err("".into())).ok();
         // Parses block device ID.
         let blk_id = next_arg_u64(&mut args, Err("".into())).ok();
-        // Parses offset
-        let window_start = next_arg_u64(&mut args, Ok(0))?;
-        // Checks blk_id and computes maximum partition size.
-        let (blk_id, max_size) = match part {
-            "" => {
-                let blk_id = blk_id.ok_or("Must provide a block device ID")?;
-                (blk_id, devs.get(blk_id)?.total_size()?)
-            }
-            gpt => match blk_id {
-                Some(id) => (id, devs.get(id)?.find_partition(gpt)?.size()?),
-                _ => {
-                    devs.check_part(gpt).map(|(id, p)| Ok::<_, CommandError>((id, p.size()?)))??
-                }
-            },
+        let blk_id = blk_id.map(|v| usize::try_from(v)).transpose()?;
+        let blk_id = blk_id.or(self.default_block);
+        // Parses sub window offset.
+        let window_offset = next_arg_u64(&mut args, Ok(0))?;
+        // Parses sub window size.
+        let window_size = next_arg_u64(&mut args, Err("".into())).ok();
+        // Checks and resolves blk_id and partition size
+        let (blk_id, partition) = match blk_id {
+            None => check_part_unique(devs, part.ok_or("Must provide a partition")?)?,
+            Some(v) => (v, devs.get(v).ok_or("Invalid block ID")?.find_partition(part)?),
         };
-        let max_size = max_size.checked_sub(window_start).ok_or("Offset overflows")?;
-        // Parses size or uses `max_size`
-        let window_size = next_arg_u64(&mut args, Ok(max_size))?;
-        match window_size > max_size {
-            true => Err("Size overflows".into()),
-            _ => Ok(GblFbPartition {
-                part: part_str,
-                blk_id: blk_id,
-                window_start: window_start,
-                window_size: window_size,
-            }),
+        let part_sz = SafeNum::from(partition.size()?);
+        let window_size = window_size.unwrap_or((part_sz - window_offset).try_into()?);
+        u64::try_from(part_sz - window_size - window_offset)?;
+        Ok((part, blk_id, window_offset, window_size))
+    }
+
+    /// Checks and waits until a download buffer is allocated.
+    async fn ensure_download_buffer(&mut self) -> &mut [u8] {
+        while self.current_download_buffer.is_none() {
+            self.current_download_buffer = self.download_buffers.iter().find_map(|v| v.try_lock());
+            match self.current_download_buffer.is_some() {
+                true => break,
+                _ => yield_now().await,
+            }
         }
+        self.current_download_buffer.as_mut().unwrap()
     }
 
-    /// Creates an instance of `GblFbPartitionIO`
-    pub(crate) fn partition_io(&mut self, part: GblFbPartition) -> GblFbPartitionIo {
-        GblFbPartitionIo { part: part, devs: self.storage() }
+    /// Waits for all block devices to be ready.
+    async fn sync_all_blocks(&self) -> CommandResult<()> {
+        for ele in self.gbl_ops.partitions()? {
+            let _ = ele.wait_partition_io(None).await;
+        }
+        Ok(())
+    }
+
+    /// Implementation for "fastboot oem gbl-sync-blocks".
+    async fn oem_sync_blocks<'c>(
+        &self,
+        utils: &mut impl FastbootUtils,
+        res: &'c mut [u8],
+    ) -> CommandResult<&'c [u8]> {
+        self.sync_all_blocks().await?;
+        // Checks error.
+        let mut has_error = false;
+        for (i, ele) in self.gbl_ops.partitions()?.iter().enumerate() {
+            match ele.partition_io(None)?.last_err() {
+                Ok(_) => {}
+                Err(e) => {
+                    has_error = true;
+                    utils.send_info(snprintf!(res, "Block #{} error: {:?}.", i, e)).await?;
+                }
+            }
+        }
+        match has_error {
+            true => Err("Errors during async block IO. Please reset device.".into()),
+            _ => Ok(b""),
+        }
     }
 }
 
-impl FastbootImplementation for GblFastboot<'_> {
-    fn get_var(
+impl<'b, T: TasksExecutor<'b>, G: GblOps<'b>> FastbootImplementation for GblFastboot<'_, 'b, T, G> {
+    async fn get_var(
         &mut self,
         var: &str,
-        args: Split<char>,
+        args: Split<'_, char>,
         out: &mut [u8],
-        _utils: &mut FastbootUtils,
-    ) -> Result<usize, CommandError> {
-        Self::NATIVE_VARS
-            .iter()
-            .find_map(|v| v.get(self, var, args.clone(), out).transpose())
-            .ok_or::<CommandError>("No such variable".into())?
+        _utils: &mut impl FastbootUtils,
+    ) -> CommandResult<usize> {
+        Ok(fb_vars_get(self, var, args, out).await?.ok_or("No such variable")?)
     }
 
-    fn get_var_all(
+    async fn get_var_all(
         &mut self,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
-        _utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError> {
-        Self::NATIVE_VARS.iter().find_map(|v| v.get_all(self, f).err()).map_or(Ok(()), |e| Err(e))
-    }
-
-    fn flash(&mut self, part: &str, utils: &mut FastbootUtils) -> Result<(), CommandError> {
-        let part = self.parse_partition(part.split(':'))?;
-        match is_sparse_image(utils.download_data()) {
-            // Passes the entire download buffer so that more can be used as fill buffer.
-            Ok(_) => write_sparse_image(utils.take_download_buffer().0, |off, data| {
-                self.partition_io(part).write(off, data)
-            })
-            .map(|_| ()),
-            _ => self.partition_io(part).write(0, utils.download_data()),
+        var_logger: &mut impl VarSender,
+        _utils: &mut impl FastbootUtils,
+    ) -> CommandResult<()> {
+        fb_vars_get_all(self, var_logger).await
+    }
+
+    async fn get_download_buffer(&mut self) -> &mut [u8] {
+        self.ensure_download_buffer().await
+    }
+
+    async fn download_complete(&mut self, download_size: usize) -> CommandResult<()> {
+        self.current_download_size = download_size;
+        Ok(())
+    }
+
+    async fn flash(&mut self, part: &str, utils: &mut impl FastbootUtils) -> CommandResult<()> {
+        let (part, blk_idx, start, sz) = self.parse_partition(part.split(':'))?;
+        let partitions = self.gbl_ops.partitions()?;
+        let mut part_io = partitions[blk_idx].wait_partition_io(part).await?.sub(start, sz)?;
+        part_io.last_err()?;
+        let mut download_buffer = self.current_download_buffer.take().ok_or("No download")?;
+        let data_size = take(&mut self.current_download_size);
+        let write_task = async move {
+            let _ = match is_sparse_image(&download_buffer) {
+                Ok(_) => part_io.write_sparse(0, &mut download_buffer).await,
+                _ => part_io.write(0, &mut download_buffer[..data_size]).await,
+            };
+        };
+        match self.enable_async_block_io {
+            true => {
+                self.blk_io_executor.spawn_task(write_task)?;
+                let info = "An IO task is launched. To sync manually, run \"oem gbl-sync-blocks\".";
+                utils.send_info(info).await?
+            }
+            _ => write_task.await,
+        };
+        // Checks if block is ready already and returns errors. This can be the case when the
+        // operation is synchronous or runs into early errors.
+        match partitions[blk_idx].partition_io(part) {
+            Ok(v) => Ok(v.last_err()?),
+            _ => Ok(()),
         }
     }
 
-    fn upload(
+    async fn upload(
         &mut self,
-        _upload_builder: UploadBuilder,
-        _utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError> {
+        _: impl UploadBuilder,
+        _: &mut impl FastbootUtils,
+    ) -> CommandResult<()> {
         Err("Unimplemented".into())
     }
 
-    fn fetch(
+    async fn fetch(
         &mut self,
         part: &str,
         offset: u64,
         size: u64,
-        upload_builder: UploadBuilder,
-        utils: &mut FastbootUtils,
-    ) -> Result<(), CommandError> {
-        let part = self.parse_partition(part.split(':'))?;
-        let (buffer, _) = utils.take_download_buffer();
-        let buffer_len = u64::try_from(buffer.len())
-            .map_err::<CommandError, _>(|_| "buffer size overflow".into())?;
-        let end = add(offset, size)?;
+        upload_builder: impl UploadBuilder,
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<()> {
+        let (part, blk_idx, start, sz) = self.parse_partition(part.split(':'))?;
+        let partitions = self.gbl_ops.partitions()?;
+        let mut part_io = partitions[blk_idx].wait_partition_io(part).await?.sub(start, sz)?;
+        part_io.last_err()?;
+        let buffer = self.ensure_download_buffer().await;
+        let end = u64::try_from(SafeNum::from(offset) + size)?;
         let mut curr = offset;
-        let mut uploader = upload_builder.start(size)?;
+        let mut uploader = upload_builder.start(size).await?;
         while curr < end {
-            let to_send = min(end - curr, buffer_len);
-            self.partition_io(part).read(curr, &mut buffer[..to_usize(to_send)?])?;
-            uploader.upload(&mut buffer[..to_usize(to_send)?])?;
-            curr += to_send;
+            let to_send = min(usize::try_from(end - curr)?, buffer.len());
+            part_io.read(curr, &mut buffer[..to_send]).await?;
+            uploader.upload(&mut buffer[..to_send]).await?;
+            curr += u64::try_from(to_send)?;
         }
         Ok(())
     }
 
-    fn oem<'a>(
+    async fn oem<'a>(
         &mut self,
-        _cmd: &str,
-        utils: &mut FastbootUtils,
-        _res: &'a mut [u8],
-    ) -> Result<&'a [u8], CommandError> {
-        let _ = utils.info_send("GBL OEM not implemented yet")?;
-        Err("Unimplemented".into())
+        cmd: &str,
+        utils: &mut impl FastbootUtils,
+        res: &'a mut [u8],
+    ) -> CommandResult<&'a [u8]> {
+        match cmd {
+            "gbl-sync-blocks" => self.oem_sync_blocks(utils, res).await,
+            "gbl-enable-async-block-io" => {
+                self.enable_async_block_io = true;
+                Ok(b"")
+            }
+            "gbl-disable-async-block-io" => {
+                self.enable_async_block_io = false;
+                Ok(b"")
+            }
+            "gbl-unset-default-block" => {
+                self.default_block = None;
+                Ok(b"")
+            }
+            _ if cmd.starts_with("gbl-set-default-block ") => {
+                let mut args = cmd.split(' ');
+                let _ = args.next();
+                let id = next_arg_u64(&mut args, Err("Missing block device ID".into()))?;
+                self.default_block = Some(id.try_into()?);
+                Ok(b"")
+            }
+            _ => Err("Unknown oem command".into()),
+        }
     }
 }
 
-/// Check and convert u64 into usize
-fn to_usize(val: u64) -> Result<usize, CommandError> {
-    val.try_into().map_err(|_| "Overflow".into())
-}
-
-/// Add two u64 integers and check overflow
-fn add(lhs: u64, rhs: u64) -> Result<u64, CommandError> {
-    lhs.checked_add(rhs).ok_or("Overflow".into())
-}
-
-/// Subtracts two u64 integers and check overflow
-fn sub(lhs: u64, rhs: u64) -> Result<u64, CommandError> {
-    lhs.checked_sub(rhs).ok_or("Overflow".into())
-}
-
 #[cfg(test)]
 mod test {
     use super::*;
-    use fastboot::test_utils::with_mock_upload_builder;
-    use gbl_storage_testlib::{TestBlockDeviceBuilder, TestMultiBlockDevices};
-    use std::string::String;
-    use Vec;
+    use crate::{
+        ops::test::{FakeGblOps, FakeGblOpsStorage},
+        partition::PartitionBlockDevice,
+    };
+    use core::{cmp::max, future::Future, pin::pin};
+    use fastboot::{test_utils::TestUploadBuilder, MAX_RESPONSE_SIZE};
+    use gbl_async::{block_on, poll};
+    use gbl_cyclic_executor::CyclicExecutor;
+    use gbl_storage_testlib::{BackingStore, TestBlockDeviceBuilder, TestBlockIo};
+    use liberror::Error;
+
+    /// A test implementation of FastbootUtils.
+    #[derive(Default)]
+    struct TestFastbootUtils {}
+
+    impl FastbootUtils for TestFastbootUtils {
+        /// Sends a Fastboot "INFO<`msg`>" packet.
+        async fn send_info(&mut self, _: &str) -> CommandResult<()> {
+            Ok(())
+        }
+
+        /// Returns transport errors if there are any.
+        fn transport_error(&self) -> Result<(), Error> {
+            Ok(())
+        }
+    }
+
+    type TestGblFastboot<'a, 'b> = GblFastboot<'a, 'b, TestGblFbExecutor<'b>, FakeGblOps<'b>>;
 
     /// Helper to test fastboot variable value.
-    fn check_var(gbl_fb: &mut GblFastboot, var: &str, args: &str, expected: &str) {
-        let mut dl_size = 0;
-        let mut utils = FastbootUtils::new(&mut [], &mut dl_size, None);
-        let mut out = vec![0u8; fastboot::MAX_RESPONSE_SIZE];
-        assert_eq!(
-            gbl_fb.get_var_as_str(var, args.split(':'), &mut out[..], &mut utils).unwrap(),
-            expected
-        );
+    fn check_var(gbl_fb: &mut TestGblFastboot, var: &str, args: &str, expected: &str) {
+        let mut utils: TestFastbootUtils = Default::default();
+        let mut out = vec![0u8; MAX_RESPONSE_SIZE];
+        let val = block_on(gbl_fb.get_var_as_str(var, args.split(':'), &mut out[..], &mut utils))
+            .unwrap();
+        assert_eq!(val, expected, "var {}:{} = {} != {}", var, args, val, expected,);
+    }
+
+    /// A helper to set the download content.
+    fn set_download(gbl_fb: &mut TestGblFastboot, data: &[u8]) {
+        block_on(gbl_fb.ensure_download_buffer());
+        gbl_fb.current_download_buffer.as_mut().unwrap()[..data.len()].clone_from_slice(data);
+        gbl_fb.current_download_size = data.len();
+    }
+
+    /// `TestGblFbExecutor` wraps a `CyclicExecutor` and implements `TasksExecutor` trait.
+    #[derive(Default)]
+    struct TestGblFbExecutor<'a>(Mutex<CyclicExecutor<'a>>);
+
+    impl<'a> TasksExecutor<'a> for TestGblFbExecutor<'a> {
+        fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()> {
+            Ok(self.0.try_lock().unwrap().spawn_task(task))
+        }
+    }
+
+    /// A Helper type for preparing test data such as block devices AND download buffers for
+    /// Fastboot tests.
+    struct TestData {
+        /// Fake backing storage.
+        storage: FakeGblOpsStorage,
+        /// Download buffers.
+        download: Vec<Vec<u8>>,
+    }
+
+    impl TestData {
+        /// Creates a new instance.
+        ///
+        /// Initializes `dl_n` number of download buffers with size `dl_sz`.
+        fn new(dl_sz: usize, dl_n: usize) -> Self {
+            Self { storage: Default::default(), download: vec![vec![0u8; dl_sz]; dl_n] }
+        }
+
+        /// Creates an array of `PartitionBlockDevice` and fastboot download buffers.
+        fn get(&mut self) -> (Vec<PartitionBlockDevice<&mut TestBlockIo>>, Vec<Mutex<&mut [u8]>>) {
+            (
+                self.storage.as_partition_block_devices(),
+                self.download.iter_mut().map(|v| (&mut v[..]).into()).collect::<Vec<_>>(),
+            )
+        }
     }
 
     #[test]
     fn test_get_var_partition_info() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../../../libstorage/test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../../../libstorage/test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        let mut gbl_fb = GblFastboot::new(&mut devs);
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
+        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
 
         // Check different semantics
         check_var(&mut gbl_fb, "partition-size", "boot_a", "0x2000");
@@ -304,45 +381,64 @@ mod test {
         check_var(&mut gbl_fb, "partition-size", "boot_b:0", "0x3000");
         check_var(&mut gbl_fb, "partition-size", "vendor_boot_a:1", "0x1000");
         check_var(&mut gbl_fb, "partition-size", "vendor_boot_b:1", "0x1800");
+        check_var(&mut gbl_fb, "partition-size", "boot_a::0x1000", "0x1000");
+        check_var(&mut gbl_fb, "partition-size", "raw_0", "0x1000");
+        check_var(&mut gbl_fb, "partition-size", "raw_1", "0x2000");
+
+        let mut utils: TestFastbootUtils = Default::default();
+        let mut out = vec![0u8; MAX_RESPONSE_SIZE];
+        assert!(block_on(gbl_fb.get_var_as_str(
+            "partition",
+            "non-existent".split(':'),
+            &mut out[..],
+            &mut utils
+        ))
+        .is_err());
+    }
+
+    /// `TestVarSender` implements `TestVarSender`. It stores outputs in a vector of string.
+    struct TestVarSender(Vec<String>);
 
-        let mut dl_size = 0;
-        let mut utils = FastbootUtils::new(&mut [], &mut dl_size, None);
-        let mut out = vec![0u8; fastboot::MAX_RESPONSE_SIZE];
-        assert!(gbl_fb
-            .get_var_as_str("partition", "non-existent".split(':'), &mut out[..], &mut utils)
-            .is_err());
+    impl VarSender for TestVarSender {
+        async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()> {
+            self.0.push(format!("{}:{}: {}", name, args.join(":"), val));
+            Ok(())
+        }
     }
 
     #[test]
     fn test_get_var_all() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../../../libstorage/test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../../../libstorage/test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        let mut gbl_fb = GblFastboot::new(&mut devs);
-
-        let mut dl_size = 0;
-        let mut utils = FastbootUtils::new(&mut [], &mut dl_size, None);
-        let mut out: Vec<String> = Default::default();
-        gbl_fb
-            .get_var_all(
-                &mut |name, args, val| {
-                    out.push(format!("{}:{}: {}", name, args.join(":"), val));
-                    Ok(())
-                },
-                &mut utils,
-            )
-            .unwrap();
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
+        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+
+        let mut utils: TestFastbootUtils = Default::default();
+        let mut logger = TestVarSender(vec![]);
+        block_on(gbl_fb.get_var_all(&mut logger, &mut utils)).unwrap();
         assert_eq!(
-            out,
+            logger.0,
             [
                 "version-bootloader:: 1.0",
                 "max-fetch-size:: 0xffffffffffffffff",
                 "block-device:0:total-blocks: 0x80",
                 "block-device:0:block-size: 0x200",
+                "block-device:0:status: idle",
                 "block-device:1:total-blocks: 0x100",
                 "block-device:1:block-size: 0x200",
+                "block-device:1:status: idle",
+                "block-device:2:total-blocks: 0x8",
+                "block-device:2:block-size: 0x200",
+                "block-device:2:status: idle",
+                "block-device:3:total-blocks: 0x10",
+                "block-device:3:block-size: 0x200",
+                "block-device:3:status: idle",
+                "gbl-default-block:: None",
                 "partition-size:boot_a:0: 0x2000",
                 "partition-type:boot_a:0: raw",
                 "partition-size:boot_b:0: 0x3000",
@@ -350,63 +446,65 @@ mod test {
                 "partition-size:vendor_boot_a:1: 0x1000",
                 "partition-type:vendor_boot_a:1: raw",
                 "partition-size:vendor_boot_b:1: 0x1800",
-                "partition-type:vendor_boot_b:1: raw"
+                "partition-type:vendor_boot_b:1: raw",
+                "partition-size:raw_0:2: 0x1000",
+                "partition-type:raw_0:2: raw",
+                "partition-size:raw_1:3: 0x2000",
+                "partition-type:raw_1:3: raw",
             ]
         );
     }
 
     /// A helper for fetching partition from a `GblFastboot`
-    fn fetch(
-        fb: &mut GblFastboot,
+    fn fetch<EOff: core::fmt::Debug, ESz: core::fmt::Debug>(
+        fb: &mut TestGblFastboot,
         part: String,
-        off: u64,
-        size: u64,
-    ) -> Result<Vec<u8>, CommandError> {
-        let mut dl_size = 0;
+        off: impl TryInto<u64, Error = EOff>,
+        size: impl TryInto<u64, Error = ESz>,
+    ) -> CommandResult<Vec<u8>> {
+        let off = off.try_into().unwrap();
+        let size = size.try_into().unwrap();
         // Forces upload in two batches for testing.
-        let mut download_buffer =
-            vec![0u8; core::cmp::max(1, usize::try_from(size).unwrap() / 2usize)];
-        let mut utils = FastbootUtils::new(&mut download_buffer[..], &mut dl_size, None);
+        let download_buffer = vec![0u8; max(1, usize::try_from(size).unwrap() / 2usize)];
+        let mut utils: TestFastbootUtils = Default::default();
         let mut upload_out = vec![0u8; usize::try_from(size).unwrap()];
-        let mut res = Ok(());
-        let (uploaded, _) = with_mock_upload_builder(&mut upload_out[..], |upload_builder| {
-            res = fb.fetch(part.as_str(), off, size, upload_builder, &mut utils)
-        });
-        assert!(res.is_err() || uploaded == usize::try_from(size).unwrap());
-        res.map(|_| upload_out)
+        let test_uploader = TestUploadBuilder(&mut upload_out[..]);
+        block_on(fb.fetch(part.as_str(), off, size, test_uploader, &mut utils))?;
+        Ok(upload_out)
     }
 
     #[test]
     fn test_fetch_invalid_partition_arg() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../../../libstorage/test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../../../libstorage/test/gpt_test_2.bin").as_slice().into(),
-            include_bytes!("../../../libstorage/test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        let mut fb = GblFastboot::new(&mut devs);
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
 
         // Missing mandatory block device ID for raw block partition.
-        assert!(fetch(&mut fb, "::0:0".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "::0:0".into(), 0, 0).is_err());
 
         // GPT partition does not exist.
-        assert!(fetch(&mut fb, "non:::".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "non:::".into(), 0, 0).is_err());
 
         // GPT Partition is not unique.
-        assert!(fetch(&mut fb, "vendor_boot_a:::".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "vendor_boot_a:::".into(), 0, 0).is_err());
 
         // Offset overflows.
-        assert!(fetch(&mut fb, "boot_a::0x2001:".into(), 0, 1).is_err());
-        assert!(fetch(&mut fb, "boot_a".into(), 0x2000, 1).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a::0x2001:".into(), 0, 1).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0x2000, 1).is_err());
 
         // Size overflows.
-        assert!(fetch(&mut fb, "boot_a:::0x2001".into(), 0, 0).is_err());
-        assert!(fetch(&mut fb, "boot_a".into(), 0, 0x2001).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a:::0x2001".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, 0x2001).is_err());
     }
 
     /// A helper for testing raw block upload. It verifies that data read from block device
     /// `blk_id` in range [`off`, `off`+`size`) is the same as `disk[off..][..size]`
-    fn check_blk_upload(fb: &mut GblFastboot, blk_id: u64, off: u64, size: u64, disk: &[u8]) {
+    fn check_blk_upload(fb: &mut TestGblFastboot, blk_id: u64, off: u64, size: u64, disk: &[u8]) {
         let expected = disk[off.try_into().unwrap()..][..size.try_into().unwrap()].to_vec();
         // offset/size as part of the partition string.
         let part = format!(":{:#x}:{:#x}:{:#x}", blk_id, off, size);
@@ -418,12 +516,15 @@ mod test {
 
     #[test]
     fn test_fetch_raw_block() {
+        let mut test_data = TestData::new(128 * 1024, 1);
         let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
         let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        let mut devs =
-            TestMultiBlockDevices(vec![disk_0.as_slice().into(), disk_1.as_slice().into()]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        let mut gbl_fb = GblFastboot::new(&mut devs);
+        test_data.storage.add_gpt_device(disk_0);
+        test_data.storage.add_gpt_device(disk_1);
+        let (parts, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&parts);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
 
         let off = 512;
         let size = 512;
@@ -434,8 +535,8 @@ mod test {
     /// A helper for testing uploading GPT partition. It verifies that data read from GPT partition
     /// `part` at disk `blk_id` in range [`off`, `off`+`size`) is the same as
     /// `partition_data[off..][..size]`.
-    fn check_gpt_upload(
-        fb: &mut GblFastboot,
+    fn check_part_upload(
+        fb: &mut TestGblFastboot,
         part: &str,
         off: u64,
         size: u64,
@@ -454,13 +555,16 @@ mod test {
     }
 
     #[test]
-    fn test_fetch_gpt_partition() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../../../libstorage/test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../../../libstorage/test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        let mut gbl_fb = GblFastboot::new(&mut devs);
+    fn test_fetch_partition() {
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
+        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
 
         let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
         let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
@@ -470,48 +574,65 @@ mod test {
         let size = 512;
         let off = 512;
 
-        check_gpt_upload(&mut gbl_fb, "boot_a", off, size, Some(0), expect_boot_a);
-        check_gpt_upload(&mut gbl_fb, "boot_b", off, size, Some(0), expect_boot_b);
-        check_gpt_upload(&mut gbl_fb, "vendor_boot_a", off, size, Some(1), expect_vendor_boot_a);
-        check_gpt_upload(&mut gbl_fb, "vendor_boot_b", off, size, Some(1), expect_vendor_boot_b);
+        check_part_upload(&mut gbl_fb, "boot_a", off, size, Some(0), expect_boot_a);
+        check_part_upload(&mut gbl_fb, "boot_b", off, size, Some(0), expect_boot_b);
+        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, Some(1), expect_vendor_boot_a);
+        check_part_upload(&mut gbl_fb, "vendor_boot_b", off, size, Some(1), expect_vendor_boot_b);
+        check_part_upload(&mut gbl_fb, "raw_0", off, size, Some(2), &[0xaau8; 4 * 1024]);
+        check_part_upload(&mut gbl_fb, "raw_1", off, size, Some(3), &[0x55u8; 8 * 1024]);
 
         // No block device id
-        check_gpt_upload(&mut gbl_fb, "boot_a", off, size, None, expect_boot_a);
-        check_gpt_upload(&mut gbl_fb, "boot_b", off, size, None, expect_boot_b);
-        check_gpt_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, expect_vendor_boot_a);
-        check_gpt_upload(&mut gbl_fb, "vendor_boot_b", off, size, None, expect_vendor_boot_b);
+        check_part_upload(&mut gbl_fb, "boot_a", off, size, None, expect_boot_a);
+        check_part_upload(&mut gbl_fb, "boot_b", off, size, None, expect_boot_b);
+        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, expect_vendor_boot_a);
+        check_part_upload(&mut gbl_fb, "vendor_boot_b", off, size, None, expect_vendor_boot_b);
+        check_part_upload(&mut gbl_fb, "raw_0", off, size, None, &[0xaau8; 4 * 1024]);
+        check_part_upload(&mut gbl_fb, "raw_1", off, size, None, &[0x55u8; 8 * 1024]);
     }
 
-    /// A helper for testing GPT partition flashing.
-    fn check_flash_part(fb: &mut GblFastboot, part: &str, expected: &[u8]) {
+    /// A helper function to get a bit-flipped copy of the input data.
+    fn flipped_bits(data: &[u8]) -> Vec<u8> {
+        data.iter().map(|v| !(*v)).collect::<Vec<_>>()
+    }
+
+    /// A helper function to flash data to a partition
+    fn flash_part(fb: &mut TestGblFastboot, part: &str, data: &[u8]) {
         // Prepare a download buffer.
-        let mut dl_size = expected.len();
-        let mut download = expected.to_vec();
-        let mut utils = FastbootUtils::new(&mut download[..], &mut dl_size, None);
-        fb.flash(part, &mut utils).unwrap();
-        assert_eq!(fetch(fb, part.into(), 0, dl_size.try_into().unwrap()).unwrap(), download);
+        let dl_size = data.len();
+        let download = data.to_vec();
+        let mut utils: TestFastbootUtils = Default::default();
+        set_download(fb, &download[..]);
+        block_on(fb.flash(part, &mut utils)).unwrap();
+        assert_eq!(fetch(fb, part.into(), 0, dl_size).unwrap(), download);
+    }
 
+    /// A helper for testing partition flashing.
+    fn check_flash_part(fb: &mut TestGblFastboot, part: &str, expected: &[u8]) {
+        flash_part(fb, part, expected);
         // Also flashes bit-wise reversed version in case the initial content is the same.
-        let mut download = expected.iter().map(|v| !(*v)).collect::<Vec<_>>();
-        let mut utils = FastbootUtils::new(&mut download[..], &mut dl_size, None);
-        fb.flash(part, &mut utils).unwrap();
-        assert_eq!(fetch(fb, part.into(), 0, dl_size.try_into().unwrap()).unwrap(), download);
+        flash_part(fb, part, &flipped_bits(expected));
     }
 
     #[test]
     fn test_flash_partition() {
         let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
         let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        let mut devs =
-            TestMultiBlockDevices(vec![disk_0.as_slice().into(), disk_1.as_slice().into()]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-
-        let mut gbl_fb = GblFastboot::new(&mut devs);
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(disk_0);
+        test_data.storage.add_gpt_device(disk_1);
+        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
+        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
 
         let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
         let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
         check_flash_part(&mut gbl_fb, "boot_a", expect_boot_a);
         check_flash_part(&mut gbl_fb, "boot_b", expect_boot_b);
+        check_flash_part(&mut gbl_fb, "raw_0", &[0xaau8; 4 * 1024]);
+        check_flash_part(&mut gbl_fb, "raw_1", &[0x55u8; 8 * 1024]);
         check_flash_part(&mut gbl_fb, ":0", disk_0);
         check_flash_part(&mut gbl_fb, ":1", disk_1);
 
@@ -528,14 +649,249 @@ mod test {
     fn test_flash_partition_sparse() {
         let raw = include_bytes!("../../testdata/sparse_test_raw.bin");
         let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let mut devs =
-            TestMultiBlockDevices(vec![TestBlockDeviceBuilder::new().set_size(raw.len()).build()]);
-        let mut fb = GblFastboot::new(&mut devs);
-
-        let mut dl_size = sparse.len();
-        let mut download = sparse.to_vec();
-        let mut utils = FastbootUtils::new(&mut download[..], &mut dl_size, None);
-        fb.flash(":0", &mut utils).unwrap();
-        assert_eq!(fetch(&mut fb, ":0".into(), 0, raw.len().try_into().unwrap()).unwrap(), raw);
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_raw_device("raw", vec![0u8; raw.len()]);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+
+        let download = sparse.to_vec();
+        let mut utils: TestFastbootUtils = Default::default();
+        set_download(&mut gbl_fb, &download[..]);
+        block_on(gbl_fb.flash(":0", &mut utils)).unwrap();
+        assert_eq!(fetch(&mut gbl_fb, ":0".into(), 0, raw.len()).unwrap(), raw);
+    }
+
+    /// A helper to invoke OEM commands.
+    ///
+    /// Returns the result and INFO strings.
+    async fn oem(
+        fb: &mut TestGblFastboot<'_, '_>,
+        oem_cmd: &str,
+        utils: &mut impl FastbootUtils,
+    ) -> CommandResult<String> {
+        let mut res = [0u8; MAX_RESPONSE_SIZE];
+        fb.oem(oem_cmd, utils, &mut res[..]).await?;
+        Ok(from_utf8(&mut res[..]).unwrap().into())
+    }
+
+    #[test]
+    fn test_async_flash() {
+        // Creates two block devices for writing raw and sparse image.
+        let sparse_raw = include_bytes!("../../testdata/sparse_test_raw.bin");
+        let sparse = include_bytes!("../../testdata/sparse_test.bin");
+        let dev_sparse = TestBlockDeviceBuilder::new()
+            .add_partition("sparse", BackingStore::Size(sparse_raw.len()))
+            .build();
+        let mut test_data = TestData::new(128 * 1024, 2);
+        test_data.storage.add_gpt_device(dev_sparse.io.storage);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let mut utils: TestFastbootUtils = Default::default();
+
+        // "oem gbl-sync-blocks" should return immediately when there is no pending IOs.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils))).unwrap().is_ok());
+        // Enable async IO.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
+            .unwrap()
+            .is_ok());
+
+        // Flashes "boot_a".
+        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+
+        // Flashes the "sparse" partition on the different block device.
+        set_download(&mut gbl_fb, sparse);
+        block_on(gbl_fb.flash("sparse", &mut utils)).unwrap();
+
+        // The two blocks should be in the pending state.
+        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
+        check_var(&mut gbl_fb, "block-device", "1:status", "IO pending");
+
+        // There should be two disk IO tasks spawned.
+        assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 2);
+        {
+            // "oem gbl-sync-blocks" should block.
+            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils));
+            assert!(poll(oem_sync_blk_fut).is_none());
+            // Schedules the disk IO tasks to completion.
+            blk_io_executor.0.try_lock().unwrap().run();
+            // "oem gbl-sync-blocks" should now be able to finish.
+            assert!(poll(oem_sync_blk_fut).unwrap().is_ok());
+        }
+
+        // The two blocks should be in the idle state.
+        check_var(&mut gbl_fb, "block-device", "0:status", "idle");
+        check_var(&mut gbl_fb, "block-device", "1:status", "idle");
+
+        // Verifies flashed image.
+        assert_eq!(
+            fetch(&mut gbl_fb, "boot_a".into(), 0, expect_boot_a.len()).unwrap(),
+            expect_boot_a
+        );
+        assert_eq!(fetch(&mut gbl_fb, "sparse".into(), 0, sparse_raw.len()).unwrap(), sparse_raw);
+    }
+
+    #[test]
+    fn test_async_flash_block_on_busy_blk() {
+        let mut test_data = TestData::new(128 * 1024, 2);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let mut utils: TestFastbootUtils = Default::default();
+
+        // Enable async IO.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
+            .unwrap()
+            .is_ok());
+
+        // Flashes boot_a partition.
+        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+
+        // Flashes boot_b partition.
+        let expect_boot_b = flipped_bits(include_bytes!("../../../libstorage/test/boot_b.bin"));
+        set_download(&mut gbl_fb, expect_boot_b.as_slice());
+        {
+            let flash_boot_b_fut = &mut pin!(gbl_fb.flash("boot_b", &mut utils));
+            // Previous IO has not completed. Block is busy.
+            assert!(poll(flash_boot_b_fut).is_none());
+            // There should only be the previous disk IO task for "boot_a".
+            assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 1);
+            // Schedule the disk IO task for "flash boot_a" to completion.
+            blk_io_executor.0.try_lock().unwrap().run();
+            // The blocked "flash boot_b" should now be able to finish.
+            assert!(poll(flash_boot_b_fut).is_some());
+            // There should be a disk IO task spawned for "flash boot_b".
+            assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 1);
+            // Schedule the disk IO tasks for "flash boot_b" to completion.
+            blk_io_executor.0.try_lock().unwrap().run();
+        }
+
+        // Verifies flashed image.
+        assert_eq!(
+            fetch(&mut gbl_fb, "boot_a".into(), 0, expect_boot_a.len()).unwrap(),
+            expect_boot_a
+        );
+        assert_eq!(
+            fetch(&mut gbl_fb, "boot_b".into(), 0, expect_boot_b.len()).unwrap(),
+            expect_boot_b
+        );
+    }
+
+    #[test]
+    fn test_async_flash_error() {
+        let mut test_data = TestData::new(128 * 1024, 2);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        // Injects an error.
+        partitions[0].partition_io(None).unwrap().dev().io().errors =
+            [liberror::Error::Other(None)].into();
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let mut utils: TestFastbootUtils = Default::default();
+
+        // Enable async IO.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
+            .unwrap()
+            .is_ok());
+        // Flashes boot_a partition.
+        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+        // Schedules the disk IO tasks to completion.
+        blk_io_executor.0.try_lock().unwrap().run();
+        // New flash to "boot_a" should fail due to previous error
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        assert!(block_on(gbl_fb.flash("boot_a", &mut utils)).is_err());
+        // "oem gbl-sync-blocks" should fail.
+        assert!(block_on(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils)).is_err());
+    }
+
+    #[test]
+    fn test_default_block() {
+        let mut test_data = TestData::new(128 * 1024, 1);
+        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let disk_dup = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
+        test_data.storage.add_gpt_device(disk_dup);
+        test_data.storage.add_gpt_device(disk_dup);
+        let raw_a = [0xaau8; 4 * 1024];
+        let raw_b = [0x55u8; 8 * 1024];
+        test_data.storage.add_raw_device("raw", raw_a);
+        test_data.storage.add_raw_device("raw", raw_b);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let mut utils: TestFastbootUtils = Default::default();
+
+        let boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
+        // Flips the bits on partition "vendor_boot_a" on block device #2 to make it different from
+        // block #1.
+        let vendor_boot_a =
+            flipped_bits(include_bytes!("../../../libstorage/test/vendor_boot_a.bin"));
+        flash_part(&mut gbl_fb, "vendor_boot_a:2", &vendor_boot_a);
+
+        let size = 512;
+        let off = 512;
+
+        check_var(&mut gbl_fb, "gbl-default-block", "", "None");
+        // Sets default block to #2
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 2", &mut utils)).unwrap();
+        check_var(&mut gbl_fb, "gbl-default-block", "", "0x2");
+        // The following fetch should succeed and fetch from "vendor_boot_a" on block 2.
+        check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, &vendor_boot_a);
+
+        // Sets default block to #4 (raw_b)
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 4", &mut utils)).unwrap();
+        check_var(&mut gbl_fb, "gbl-default-block", "", "0x4");
+        // The following fetch should succeed and fetch from "raw" on block 4.
+        check_part_upload(&mut gbl_fb, "raw", off, size, None, &raw_b);
+
+        // Fetches with explicit storage ID shouldn't be affected.
+        check_part_upload(&mut gbl_fb, "boot_a", off, size, Some(0), boot_a);
+        check_part_upload(&mut gbl_fb, "raw", off, size, Some(3), &raw_a);
+        check_blk_upload(&mut gbl_fb, 1, off, size, disk_dup);
+
+        // Fetching without storage ID should use default ID and thus the following should fail.
+        assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, boot_a.len()).is_err());
+
+        // Sets default block to #1 (unmodified `disk_dup`)
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 1", &mut utils)).unwrap();
+        check_var(&mut gbl_fb, "gbl-default-block", "", "0x1");
+        // Fetches whole raw block but without block ID should use the default block.
+        check_part_upload(&mut gbl_fb, "", off, size, None, disk_dup);
+
+        // Unset default block
+        block_on(oem(&mut gbl_fb, "gbl-unset-default-block", &mut utils)).unwrap();
+        check_var(&mut gbl_fb, "gbl-default-block", "", "None");
+        // Fetching non-unique partitions should now fail.
+        assert!(fetch(&mut gbl_fb, "raw".into(), 0, raw_a.len()).is_err());
+        assert!(fetch(&mut gbl_fb, "vendor_boot_a".into(), 0, vendor_boot_a.len()).is_err());
+        assert!(fetch(&mut gbl_fb, ":".into(), 0, 512).is_err());
+    }
+
+    #[test]
+    fn test_set_default_block_invalid_arg() {
+        let mut test_data = TestData::new(128 * 1024, 2);
+        let (partitions, dl_buffers) = test_data.get();
+        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let blk_io_executor: TestGblFbExecutor = Default::default();
+        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let mut utils: TestFastbootUtils = Default::default();
+        // Missing block device ID.
+        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block ", &mut utils)).is_err());
+        // Invalid block device ID.
+        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block zzz", &mut utils)).is_err());
     }
 }
diff --git a/gbl/libgbl/src/fastboot/sparse.rs b/gbl/libgbl/src/fastboot/sparse.rs
index ec45b34..725f1ee 100644
--- a/gbl/libgbl/src/fastboot/sparse.rs
+++ b/gbl/libgbl/src/fastboot/sparse.rs
@@ -12,10 +12,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use core::cmp::{max, min};
-use core::mem::size_of;
+use core::{
+    cmp::{max, min},
+    mem::size_of,
+};
 use fastboot::CommandError;
-
 use static_assertions::const_assert;
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
@@ -45,6 +46,13 @@ pub struct SparseHeader {
     pub image_checksum: u32,
 }
 
+impl SparseHeader {
+    /// Returns the total size in bytes for the data after unsparsified.
+    pub fn data_size(&self) -> u64 {
+        (self.total_blks as u64) * (self.blk_sz as u64)
+    }
+}
+
 #[repr(C)]
 #[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
 pub struct ChunkHeader {
@@ -124,21 +132,27 @@ impl FillInfo {
 
 const_assert!(size_of::<FillInfo>() < size_of::<ChunkHeader>());
 
+/// `SparseRawWriter` defines an interface for writing to raw storage used by `write_sparse_image`.
+pub(crate) trait SparseRawWriter {
+    /// Writes bytes from `data` to the destination storage at offset `off`
+    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError>;
+}
+
 /// Write a sparse image in `sparse_img`.
 ///
 /// # Args
 //
 /// * `sparse_img`: The input buffer containing the sparse image. The API modifes input buffer for
 ///   internal optimization.
-/// * `write`: A closure as the writer. It takes an offset and a `&mut [u8]` as the write data.
+/// * `writer`: An implementation of `SparseRawWriter`.
 ///
 /// # Returns
 ///
 /// Returns the total number of bytes written, including don't care chunks.
-pub fn write_sparse_image<F>(sparse_img: &mut [u8], mut write: F) -> Result<u64, CommandError>
-where
-    F: FnMut(u64, &mut [u8]) -> Result<(), CommandError>,
-{
+pub async fn write_sparse_image(
+    sparse_img: &mut [u8],
+    writer: &mut impl SparseRawWriter,
+) -> Result<u64, CommandError> {
     let sparse_header: SparseHeader = is_sparse_image(sparse_img)?;
     let mut curr: usize = size_of::<SparseHeader>();
     let mut write_offset = 0u64;
@@ -151,7 +165,9 @@ where
         let payload_sz = u64_mul(header.chunk_sz, sparse_header.blk_sz)?;
         let mut fill = FillInfo::new_skip(header.chunk_sz);
         match header.chunk_type {
-            CHUNK_TYPE_RAW => write(write_offset, get_mut(payload, 0, to_usize(payload_sz)?)?)?,
+            CHUNK_TYPE_RAW => {
+                writer.write(write_offset, get_mut(payload, 0, to_usize(payload_sz)?)?).await?;
+            }
             CHUNK_TYPE_FILL if header.chunk_sz != 0 => {
                 let fill_val = u32::from_le_bytes(get_mut(payload, 0, 4)?.try_into().unwrap());
                 fill = FillInfo::new_fill(header.chunk_sz, fill_val);
@@ -184,7 +200,7 @@ where
                 let end = u64_add(write_offset, sz)?;
                 while write_offset < end {
                     let to_write = min(buffer_len, end - write_offset);
-                    write(write_offset, &mut buffer[..to_usize(to_write).unwrap()])?;
+                    writer.write(write_offset, &mut buffer[..to_usize(to_write).unwrap()]).await?;
                     write_offset += to_write;
                 }
             }
@@ -276,6 +292,14 @@ fn u64_mul<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, Comm
 #[cfg(test)]
 mod test {
     use super::*;
+    use gbl_async::block_on;
+
+    impl SparseRawWriter for Vec<u8> {
+        async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError> {
+            self[off.try_into().unwrap()..][..data.len()].clone_from_slice(data);
+            Ok(())
+        }
+    }
 
     #[test]
     fn test_sparse_write() {
@@ -284,11 +308,7 @@ mod test {
         // Gives a larger output buffer.
         let mut out = vec![0u8; 2 * raw.len()];
         assert_eq!(
-            write_sparse_image(&mut sparse.to_vec()[..], |off, data| {
-                out[off.try_into().unwrap()..][..data.len()].clone_from_slice(data);
-                Ok(())
-            })
-            .unwrap(),
+            block_on(write_sparse_image(&mut sparse.to_vec()[..], &mut out)).unwrap(),
             raw.len().try_into().unwrap()
         );
         assert_eq!(out[..raw.len()].to_vec(), raw);
@@ -301,11 +321,7 @@ mod test {
         // Gives a larger output buffer.
         let mut out = vec![0u8; 2 * raw.len()];
         assert_eq!(
-            write_sparse_image(&mut sparse.to_vec()[..], |off, data| {
-                out[off.try_into().unwrap()..][..data.len()].clone_from_slice(data);
-                Ok(())
-            })
-            .unwrap(),
+            block_on(write_sparse_image(&mut sparse.to_vec()[..], &mut out)).unwrap(),
             raw.len().try_into().unwrap()
         );
         assert_eq!(out[..raw.len()].to_vec(), raw);
@@ -322,7 +338,7 @@ mod test {
         let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
         sparse_header.magic = 0;
         copy_to(&sparse_header, &mut sparse[..]);
-        assert!(write_sparse_image(&mut sparse[..], |_, _| panic!()).is_err());
+        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
     }
 
     #[test]
@@ -331,7 +347,7 @@ mod test {
         let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
         sparse_header.major_version = SPARSE_HEADER_MAJOR_VER + 1;
         copy_to(&sparse_header, &mut sparse[..]);
-        assert!(write_sparse_image(&mut sparse[..], |_, _| panic!()).is_err());
+        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
     }
 
     #[test]
@@ -340,6 +356,6 @@ mod test {
         let mut sparse_header: SparseHeader = copy_from(&sparse[..]).unwrap();
         sparse_header.minor_version = SPARSE_HEADER_MINOR_VER + 1;
         copy_to(&sparse_header, &mut sparse[..]);
-        assert!(write_sparse_image(&mut sparse[..], |_, _| panic!()).is_err());
+        assert!(block_on(write_sparse_image(&mut sparse[..], &mut vec![])).is_err());
     }
 }
diff --git a/gbl/libgbl/src/fastboot/vars.rs b/gbl/libgbl/src/fastboot/vars.rs
index 521205a..f46b134 100644
--- a/gbl/libgbl/src/fastboot/vars.rs
+++ b/gbl/libgbl/src/fastboot/vars.rs
@@ -12,11 +12,13 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::fastboot::{GblFastboot, GPT_NAME_LEN_U8};
+use crate::{
+    fastboot::{GblFastboot, TasksExecutor},
+    GblOps,
+};
 use core::fmt::Write;
 use core::str::{from_utf8, Split};
-use fastboot::{next_arg, next_arg_u64, snprintf, CommandError, FormattedBytes};
-use gbl_storage::{AsBlockDevice, AsMultiBlockDevices};
+use fastboot::{next_arg, next_arg_u64, snprintf, CommandError, FormattedBytes, VarSender};
 
 /// Internal trait that provides methods for getting and enumerating values for one or multiple
 /// related fastboot variables.
@@ -25,40 +27,40 @@ pub(crate) trait Variable {
     ///
     /// Return Ok(Some(`size`)) where `size` is the number of bytes written to `out`. Return
     /// `Ok(None)` if the variable is not supported.
-    fn get(
+    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
         name: &str,
-        args: Split<char>,
+        args: Split<'_, char>,
         out: &mut [u8],
     ) -> Result<Option<usize>, CommandError>;
 
     /// Iterates and calls `f` on all values/arguments combinations.
-    fn get_all(
+    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+        sender: &mut impl VarSender,
     ) -> Result<(), CommandError>;
 }
 
-// Constant fastboot variable
+// Constant fastboot variableGblFbResource,101
 impl Variable for (&'static str, &'static str) {
-    fn get(
+    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        _: &mut GblFastboot,
+        _: &mut GblFastboot<'_, 'b, T, G>,
         name: &str,
-        _: Split<char>,
+        _: Split<'_, char>,
         out: &mut [u8],
     ) -> Result<Option<usize>, CommandError> {
         Ok((name == self.0).then_some(snprintf!(out, "{}", self.1).len()))
     }
 
-    fn get_all(
+    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        _: &mut GblFastboot,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
+        _: &mut GblFastboot<'_, 'b, T, G>,
+        sender: &mut impl VarSender,
     ) -> Result<(), CommandError> {
-        f(self.0, &[], self.1)
+        sender.send(self.0, &[], self.1).await
     }
 }
 
@@ -71,50 +73,42 @@ pub(crate) struct Partition {}
 const PARTITION_SIZE: &str = "partition-size";
 const PARTITION_TYPE: &str = "partition-type";
 impl Variable for Partition {
-    fn get(
+    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
         name: &str,
-        args: Split<char>,
+        args: Split<'_, char>,
         out: &mut [u8],
     ) -> Result<Option<usize>, CommandError> {
-        let part = gbl_fb.parse_partition(args)?;
+        let (_, _, start, sz) = gbl_fb.parse_partition(args.clone())?;
         Ok(match name {
-            PARTITION_SIZE => Some(snprintf!(out, "{:#x}", gbl_fb.partition_io(part).size()).len()),
+            PARTITION_SIZE => Some(snprintf!(out, "{:#x}", sz).len()),
             PARTITION_TYPE => Some(snprintf!(out, "raw").len()), // Image type not supported yet.
             _ => None,
         })
     }
 
-    fn get_all(
+    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+        sender: &mut impl VarSender,
     ) -> Result<(), CommandError> {
         // Though any sub range of a GPT partition or raw block counts as a partition in GBL
         // Fastboot, for "getvar all" we only enumerate whole range GPT partitions.
-        let mut res: Result<(), CommandError> = Ok(());
-        let part_name = &mut [0u8; GPT_NAME_LEN_U8][..];
+        let partitions = gbl_fb.gbl_ops.partitions()?;
         let mut size_str = [0u8; 32];
-        gbl_fb.storage().for_each_until(&mut |mut v, id| {
-            // `AsBlockDevice::partition_iter()` has `Self:Sized` constraint thus we make it into a
-            // `&mut &mut dyn AsBlockDevice` to meet the bound requirement.
-            let v = &mut v;
-            let mut id_str = [0u8; 32];
-            let id = snprintf!(id_str, "{:x}", id);
-            res = (|| {
-                for ptn in v.partition_iter() {
-                    let sz: u64 = ptn.size()?;
-                    let part = ptn.gpt_entry().name_to_str(part_name)?;
-                    f(PARTITION_SIZE, &[part, id], snprintf!(size_str, "{:#x}", sz))?;
-                    // Image type is not supported yet.
-                    f(PARTITION_TYPE, &[part, id], snprintf!(size_str, "raw"))?;
-                }
-                Ok(())
-            })();
-            res.is_err()
-        })?;
-        res
+        for (idx, blk) in partitions.iter().enumerate() {
+            for ptn in blk.partition_iter() {
+                let sz: u64 = ptn.size()?;
+                let part = ptn.name()?;
+                let mut id_str = [0u8; 32];
+                let id = snprintf!(id_str, "{:x}", idx);
+                sender.send(PARTITION_SIZE, &[part, id], snprintf!(size_str, "{:#x}", sz)).await?;
+                // Image type is not supported yet.
+                sender.send(PARTITION_TYPE, &[part, id], snprintf!(size_str, "raw")).await?;
+            }
+        }
+        Ok(())
     }
 }
 
@@ -127,45 +121,198 @@ pub(crate) struct BlockDevice {}
 const BLOCK_DEVICE: &str = "block-device";
 const TOTAL_BLOCKS: &str = "total-blocks";
 const BLOCK_SIZE: &str = "block-size";
+const BLOCK_DEVICE_STATUS: &str = "status";
+
 impl Variable for BlockDevice {
-    fn get(
+    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
         name: &str,
-        mut args: Split<char>,
+        mut args: Split<'_, char>,
         out: &mut [u8],
     ) -> Result<Option<usize>, CommandError> {
         Ok(match name {
             BLOCK_DEVICE => {
                 let id = next_arg_u64(&mut args, Err("Missing block device ID".into()))?;
+                let id = usize::try_from(id)?;
                 let val_type = next_arg(&mut args, Err("Missing value type".into()))?;
-                let val = match val_type {
-                    TOTAL_BLOCKS => gbl_fb.storage().get(id)?.num_blocks()?,
-                    BLOCK_SIZE => gbl_fb.storage().get(id)?.block_size()?,
-                    _ => return Err("Invalid type".into()),
-                };
-                Some(snprintf!(out, "{:#x}", val).len())
+                let blk = &gbl_fb.gbl_ops.partitions()?[id];
+                let info = blk.block_info();
+                Some(
+                    match val_type {
+                        TOTAL_BLOCKS => snprintf!(out, "{:#x}", info.num_blocks),
+                        BLOCK_SIZE => snprintf!(out, "{:#x}", info.block_size),
+                        BLOCK_DEVICE_STATUS => {
+                            snprintf!(out, "{}", blk.status().to_str())
+                        }
+                        _ => return Err("Invalid type".into()),
+                    }
+                    .len(),
+                )
             }
             _ => None,
         })
     }
 
-    fn get_all(
+    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
         &self,
-        gbl_fb: &mut GblFastboot,
-        f: &mut dyn FnMut(&str, &[&str], &str) -> Result<(), CommandError>,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+        sender: &mut impl VarSender,
     ) -> Result<(), CommandError> {
         let mut val = [0u8; 32];
-        let mut res: Result<(), CommandError> = Ok(());
-        gbl_fb.storage().for_each_until(&mut |blk, id| {
+        for (idx, blk) in gbl_fb.gbl_ops.partitions()?.iter().enumerate() {
             let mut id_str = [0u8; 32];
-            let id = snprintf!(id_str, "{:x}", id);
-            res = (|| {
-                f(BLOCK_DEVICE, &[id, "total-blocks"], snprintf!(val, "{:#x}", blk.num_blocks()?))?;
-                f(BLOCK_DEVICE, &[id, "block-size"], snprintf!(val, "{:#x}", blk.block_size()?))
-            })();
-            res.is_err()
-        })?;
-        res
+            let id = snprintf!(id_str, "{:x}", idx);
+            let info = blk.block_info();
+            sender
+                .send(BLOCK_DEVICE, &[id, TOTAL_BLOCKS], snprintf!(val, "{:#x}", info.num_blocks))
+                .await?;
+            sender
+                .send(BLOCK_DEVICE, &[id, BLOCK_SIZE], snprintf!(val, "{:#x}", info.block_size))
+                .await?;
+            sender
+                .send(
+                    BLOCK_DEVICE,
+                    &[id, BLOCK_DEVICE_STATUS],
+                    snprintf!(val, "{}", blk.status().to_str()),
+                )
+                .await?;
+        }
+        Ok(())
     }
 }
+
+/// Gives the value of current default block device ID set by "oem gbl-set-default-block".
+///
+/// `fastboot getvar gbl-default-block`
+pub(crate) struct DefaultBlock {}
+
+const DEFAULT_BLOCK: &str = "gbl-default-block";
+
+impl Variable for DefaultBlock {
+    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
+        &self,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+        name: &str,
+        _: Split<'_, char>,
+        out: &mut [u8],
+    ) -> Result<Option<usize>, CommandError> {
+        Ok(match name {
+            DEFAULT_BLOCK => Some(
+                match gbl_fb.default_block {
+                    Some(v) => snprintf!(out, "{:#x}", v),
+                    _ => snprintf!(out, "None"),
+                }
+                .len(),
+            ),
+            _ => None,
+        })
+    }
+
+    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
+        &self,
+        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+        sender: &mut impl VarSender,
+    ) -> Result<(), CommandError> {
+        let mut val = [0u8; 32];
+        match gbl_fb.default_block {
+            Some(v) => sender.send(DEFAULT_BLOCK, &[], snprintf!(val, "{:#x}", v)).await,
+            _ => sender.send(DEFAULT_BLOCK, &[], snprintf!(val, "None")).await,
+        }
+    }
+}
+
+/// `fb_vars_api` generates a `fn fb_vars_get()` and `fn fb_vars_get_all()` helper API for all
+/// registered Fastboot variables.
+macro_rules! fb_vars_api {
+    ($($vars:expr),+ $(,)?) => {
+        /// Gets a Fastboot variable.
+        ///
+        /// The macro simply generates `var.get()` calls for each variable. i.e.:
+        ///
+        ///   pub(crate) async fn fb_vars_get<G: GblOps<'b>>(
+        ///       gbl_fb: &mut GblFastboot<'_, '_, B>,
+        ///       name: &str,
+        ///       args: Split<'_, char>,
+        ///       out: &mut [u8],
+        ///   ) -> Result<Option<usize>, CommandError> {
+        ///       match ("version-bootloader", "1.0").get(gbl_fb, name, args, out).await? {
+        ///           Some(v) => return Ok(Some(v)),
+        ///           _ => {}
+        ///       }
+        ///
+        ///       match BlockDevice {}.get(gbl_fb, name, args, out).await? {
+        ///           Some(v) => return Ok(Some(v)),
+        ///           _ => {}
+        ///       }
+        ///
+        ///       Ok(None)
+        ///   }
+        pub(crate) async fn fb_vars_get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
+            gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+            name: &str,
+            args: Split<'_, char>,
+            out: &mut [u8],
+        ) -> Result<Option<usize>, CommandError> {
+            fb_vars_get_body!(gbl_fb, name, args.clone(), out, $($vars),*);
+            Ok(None)
+        }
+
+        /// Gets all Fastboot variable values.
+        ///
+        /// The macro simply generates `var.get_all()` calls for each variable.
+        ///
+        ///   pub(crate) async fn fb_vars_get_all<G: GblOps<'b>>(
+        ///       gbl_fb: &mut GblFastboot<'_, '_, B>,
+        ///       sender: &mut impl VarSender,
+        ///   ) -> Result<(), CommandError> {
+        ///       ("version-bootloader", "1.0").get_all(gbl_fb, sender).await?;
+        ///       ("max-fetch-size", "0xffffffffffffffff").get_all(gbl_fb, sender).await?;
+        ///       BlockDevice {}.get_all(gbl_fb, sender).await?;
+        ///       Partition {}.get_all(gbl_fb, sender).await?;
+        ///       Ok(())
+        ///   }
+        pub(crate) async fn fb_vars_get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
+            gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
+            sender: &mut impl VarSender,
+        ) -> Result<(), CommandError> {
+            fb_vars_get_all_body!(gbl_fb, sender, $($vars),*);
+            Ok(())
+        }
+    }
+}
+
+// `fb_vars_get_body` generates the body for `fn fb_vars_get()`
+macro_rules! fb_vars_get_body {
+    ($gbl_fb:expr, $name:expr, $args:expr, $out:expr, $var:expr) => {
+        match $var.get($gbl_fb, $name, $args, $out).await? {
+            Some(v) => return Ok(Some(v)),
+            _ => {}
+        }
+    };
+    ($gbl_fb:expr, $name:expr, $args:expr, $out:expr, $var:expr, $($remains:expr),+ $(,)?) => {
+        fb_vars_get_body!($gbl_fb, $name, $args, $out, $var);
+        fb_vars_get_body!($gbl_fb, $name, $args, $out, $($remains),*)
+    };
+}
+
+// `fb_vars_get_all_body` generates the body for `fn fb_vars_get_all()`
+macro_rules! fb_vars_get_all_body {
+    ($gbl_fb:expr, $sender:expr, $var:expr) => {
+        $var.get_all($gbl_fb, $sender).await?
+    };
+    ($gbl_fb:expr, $sender:expr, $var:expr, $($remains:expr),+ $(,)?) => {
+        fb_vars_get_all_body!($gbl_fb, $sender, $var);
+        fb_vars_get_all_body!($gbl_fb, $sender, $($remains),*)
+    };
+}
+
+fb_vars_api! {
+    ("version-bootloader", "1.0"),
+    // GBL Fastboot can internally handle uploading in batches, thus there is no limit on
+    // max-fetch-size.
+    ("max-fetch-size", "0xffffffffffffffff"),
+    BlockDevice {},
+    DefaultBlock {},
+    Partition {},
+}
diff --git a/gbl/libgbl/src/fuchsia_boot/mod.rs b/gbl/libgbl/src/fuchsia_boot/mod.rs
new file mode 100644
index 0000000..bae47ec
--- /dev/null
+++ b/gbl/libgbl/src/fuchsia_boot/mod.rs
@@ -0,0 +1,621 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file provides APIs for loading, verifying and booting Fuchsia/Zircon.
+
+use crate::{gbl_print, gbl_println, GblOps, Result as GblResult};
+pub use abr::{get_boot_slot, Ops as AbrOps, SlotIndex};
+use core::fmt::Write;
+use liberror::{Error, Result};
+use safemath::SafeNum;
+use zbi::{ZbiContainer, ZbiFlags, ZbiHeader, ZbiType};
+use zerocopy::AsBytes;
+
+mod vboot;
+use vboot::zircon_verify_kernel;
+
+/// Kernel load address alignment. Value taken from
+/// https://fuchsia.googlesource.com/fuchsia/+/4f204d8a0243e84a86af4c527a8edcc1ace1615f/zircon/kernel/target/arm64/boot-shim/BUILD.gn#38
+pub const ZIRCON_KERNEL_ALIGN: usize = 64 * 1024;
+
+const DURABLE_BOOT_PARTITION: &str = "durable_boot";
+
+/// `GblAbrOps` wraps an object implementing `GblOps` and implements the `abr::Ops` trait.
+struct GblAbrOps<'a, T>(&'a mut T);
+
+impl<'b, T: GblOps<'b>> AbrOps for GblAbrOps<'_, T> {
+    fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
+        self.0.read_from_partition_sync(DURABLE_BOOT_PARTITION, 0, out)
+    }
+
+    fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
+        self.0.write_to_partition_sync(DURABLE_BOOT_PARTITION, 0, data)
+    }
+
+    fn console(&mut self) -> Option<&mut dyn Write> {
+        self.0.console_out()
+    }
+}
+
+/// A helper for getting the smallest offset in a slice with aligned address.
+fn aligned_offset(buffer: &[u8], alignment: usize) -> Result<usize> {
+    let addr = SafeNum::from(buffer.as_ptr() as usize);
+    (addr.round_up(alignment) - addr).try_into().map_err(From::from)
+}
+
+/// A helper for getting a subslice with an aligned address.
+fn aligned_subslice(buffer: &mut [u8], alignment: usize) -> Result<&mut [u8]> {
+    let aligned_offset = aligned_offset(buffer, alignment)?;
+    let len = buffer.len();
+    Ok(buffer.get_mut(aligned_offset..).ok_or(Error::BufferTooSmall(Some(aligned_offset)))?)
+}
+
+/// A helper for splitting the trailing unused portion of a ZBI container buffer.
+///
+/// Returns a tuple of used subslice and unused subslice
+fn zbi_split_unused_buffer(zbi: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])> {
+    Ok(zbi.split_at_mut(ZbiContainer::parse(&zbi[..])?.container_size()))
+}
+
+/// Relocates a ZBI kernel to a different buffer.
+///
+/// * `dest` must be aligned to `ZIRCON_KERNEL_ALIGN`.
+/// * `dest` will be a ZBI container containing only the kernel item.
+pub fn relocate_kernel(kernel: &[u8], dest: &mut [u8]) -> GblResult<()> {
+    if (dest.as_ptr() as usize % ZIRCON_KERNEL_ALIGN) != 0 {
+        return Err(Error::InvalidAlignment.into());
+    }
+
+    let kernel = ZbiContainer::parse(&kernel[..])?;
+    let kernel_item = kernel.is_bootable()?;
+    let hdr = kernel_item.header;
+    // Creates a new ZBI kernel item at the destination.
+    let mut relocated = ZbiContainer::new(&mut dest[..])?;
+    let zbi_type = ZbiType::try_from(hdr.type_)?;
+    relocated.create_entry_with_payload(
+        zbi_type,
+        hdr.extra,
+        hdr.get_flags() & !ZbiFlags::CRC32,
+        kernel_item.payload.as_bytes(),
+    )?;
+    let (_, reserved_memory_size) = relocated.get_kernel_entry_and_reserved_memory_size()?;
+    let buf_len = u64::try_from(zbi_split_unused_buffer(dest)?.1.len()).map_err(Error::from)?;
+    match reserved_memory_size > buf_len {
+        true => Err(Error::BufferTooSmall(None).into()),
+        _ => Ok(()),
+    }
+}
+
+/// Relocate a ZBI kernel to the trailing unused buffer.
+///
+/// Returns the original kernel subslice and relocated kernel subslice.
+pub fn relocate_to_tail(kernel: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])> {
+    let reloc_size = ZbiContainer::parse(&kernel[..])?.get_buffer_size_for_kernel_relocation()?;
+    let (original, relocated) = zbi_split_unused_buffer(kernel)?;
+    let relocated = aligned_subslice(relocated, ZIRCON_KERNEL_ALIGN)?;
+    let off = (SafeNum::from(relocated.len()) - reloc_size)
+        .round_down(ZIRCON_KERNEL_ALIGN)
+        .try_into()
+        .map_err(Error::from)?;
+    let relocated = &mut relocated[off..];
+    relocate_kernel(original, relocated)?;
+    let reloc_addr = relocated.as_ptr() as usize;
+    Ok(kernel.split_at_mut(reloc_addr.checked_sub(kernel.as_ptr() as usize).unwrap()))
+}
+
+/// Gets the slotted/slotless standard zircon partition name.
+pub fn zircon_part_name(slot: Option<SlotIndex>) -> &'static str {
+    match slot {
+        Some(slot) => match slot {
+            SlotIndex::A => "zircon_a",
+            SlotIndex::B => "zircon_b",
+            SlotIndex::R => "zircon_r",
+        },
+        _ => "zircon",
+    }
+}
+
+/// Gets the ZBI command line string for the current slot.
+fn slot_cmd_line(slot: SlotIndex) -> &'static str {
+    match slot {
+        SlotIndex::A => "zvb.current_slot=a",
+        SlotIndex::B => "zvb.current_slot=b",
+        SlotIndex::R => "zvb.current_slot=r",
+    }
+}
+
+/// Loads and verifies a kernel of the given slot or slotless.
+///
+/// # Args
+///
+/// * `ops`: A reference to an object that implements `GblOps`.
+/// * `slot`: None if slotless. Otherwise the target slot to boot.
+/// * `load`: Buffer for loading the kernel.
+///
+/// On success returns a pair containing: 1. the slice of the ZBI container with device ZBI items
+/// and 2. the slice of the relocated kernel at the tail.
+pub fn zircon_load_verify<'a, 'b>(
+    ops: &mut impl GblOps<'b>,
+    slot: Option<SlotIndex>,
+    slot_booted_successfully: bool,
+    load: &'a mut [u8],
+) -> GblResult<(&'a mut [u8], &'a mut [u8])> {
+    let load = aligned_subslice(load, ZIRCON_KERNEL_ALIGN)?;
+    let zircon_part = zircon_part_name(slot);
+
+    // Reads ZBI header to computes the total size of kernel.
+    let mut zbi_header: ZbiHeader = Default::default();
+    ops.read_from_partition_sync(zircon_part, 0, zbi_header.as_bytes_mut())?;
+    let image_length = (SafeNum::from(zbi_header.as_bytes_mut().len()) + zbi_header.length)
+        .try_into()
+        .map_err(Error::from)?;
+
+    // Reads the entire kernel
+    let kernel = load.get_mut(..image_length).ok_or(Error::BufferTooSmall(Some(image_length)))?;
+    ops.read_from_partition_sync(zircon_part, 0, kernel)?;
+
+    // Performs AVB verification.
+    zircon_verify_kernel(ops, slot, slot_booted_successfully, &mut load[..])?;
+
+    // Append additional ZBI items.
+    let mut zbi_kernel = ZbiContainer::parse(&mut load[..])?;
+
+    match slot {
+        Some(slot) => {
+            // Appends current slot item.
+            zbi_kernel.create_entry_with_payload(
+                ZbiType::CmdLine,
+                0,
+                ZbiFlags::default(),
+                slot_cmd_line(slot).as_bytes(),
+            )?;
+        }
+        _ => {}
+    }
+
+    // Relocates the kernel to the tail to reserved extra memory that the kernel may require.
+    let (zbi_items, relocated) = relocate_to_tail(&mut load[..])?;
+
+    // Appends device specific ZBI items.
+    ops.zircon_add_device_zbi_items(&mut ZbiContainer::parse(&mut zbi_items[..])?)?;
+
+    Ok((zbi_items, relocated))
+}
+
+/// Loads and verifies the active slot kernel according to A/B/R.
+///
+/// On disk A/B/R metadata will be updated.
+///
+/// # Args
+///
+/// * `ops`: A reference to an object that implements `GblOps`.
+/// * `buffer`: Buffer for loading the kernel.
+///
+/// Returns a tuple containing: 1. the slice of the ZBI container with device ZBI items, 2. the
+/// slice of the relocated kernel, and 3. the selected slot index.
+pub fn zircon_load_verify_abr<'a, 'b>(
+    ops: &mut impl GblOps<'b>,
+    buffer: &'a mut [u8],
+) -> GblResult<(&'a mut [u8], &'a mut [u8], SlotIndex)> {
+    let (slot, successful) = get_boot_slot(&mut GblAbrOps(ops), true);
+    gbl_println!(ops, "Loading kernel from {}...", zircon_part_name(Some(slot)));
+    let (zbi_items, kernel) = zircon_load_verify(ops, Some(slot), successful, buffer)?;
+    gbl_println!(ops, "Successfully loaded slot: {}", zircon_part_name(Some(slot)));
+    Ok((zbi_items, kernel, slot))
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::{
+        ops::{
+            test::{FakeGblOps, FakeGblOpsStorage},
+            CertPermanentAttributes,
+        },
+        partition::PartitionBlockDevice,
+    };
+    use abr::{mark_slot_active, mark_slot_unbootable, ABR_MAX_TRIES_REMAINING};
+    use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
+    use gbl_storage_testlib::TestBlockIo;
+    use std::{
+        collections::{BTreeSet, HashMap},
+        fs,
+        ops::{Deref, DerefMut},
+        path::Path,
+    };
+    use zbi::ZBI_ALIGNMENT_USIZE;
+    use zerocopy::FromBytes;
+
+    // The cert test keys were both generated with rollback version 42.
+    const TEST_CERT_PIK_VERSION: u64 = 42;
+    const TEST_CERT_PSK_VERSION: u64 = 42;
+
+    // The `reserve_memory_size` value in the test ZBI kernel.
+    // See `gen_zircon_test_images()` in libgbl/testdata/gen_test_data.py.
+    const TEST_KERNEL_RESERVED_MEMORY_SIZE: usize = 1024;
+
+    // The rollback index value and location in the generated test vbmetadata.
+    // See `gen_zircon_test_images()` in libgbl/testdata/gen_test_data.py.
+    const TEST_ROLLBACK_INDEX_LOCATION: usize = 1;
+    const TEST_ROLLBACK_INDEX_VALUE: u64 = 2;
+
+    pub(crate) const ZIRCON_A_ZBI_FILE: &str = "zircon_a.zbi";
+    pub(crate) const ZIRCON_B_ZBI_FILE: &str = "zircon_b.zbi";
+    pub(crate) const ZIRCON_R_ZBI_FILE: &str = "zircon_r.zbi";
+    pub(crate) const ZIRCON_SLOTLESS_ZBI_FILE: &str = "zircon_slotless.zbi";
+    pub(crate) const VBMETA_A_FILE: &str = "vbmeta_a.bin";
+    pub(crate) const VBMETA_B_FILE: &str = "vbmeta_b.bin";
+    pub(crate) const VBMETA_R_FILE: &str = "vbmeta_r.bin";
+    pub(crate) const VBMETA_SLOTLESS_FILE: &str = "vbmeta_slotless.bin";
+
+    /// Reads a data file under libgbl/testdata/
+    pub(crate) fn read_test_data(file: &str) -> Vec<u8> {
+        fs::read(Path::new(format!("external/gbl/libgbl/testdata/{}", file).as_str())).unwrap()
+    }
+
+    /// Returns a default [FakeGblOpsStorage] with valid test images.
+    ///
+    /// Rather than the typical use case of partitions on a single GPT device, this structures data
+    /// as separate raw single-partition devices. This is easier for tests since we don't need to
+    /// generate a GPT, and should be functionally equivalent since our code looks for partitions
+    /// on all devices.
+    pub(crate) fn create_storage() -> FakeGblOpsStorage {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device_padded("zircon_a", read_test_data(ZIRCON_A_ZBI_FILE));
+        storage.add_raw_device_padded("zircon_b", read_test_data(ZIRCON_B_ZBI_FILE));
+        storage.add_raw_device_padded("zircon_r", read_test_data(ZIRCON_R_ZBI_FILE));
+        storage.add_raw_device_padded("zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
+        storage.add_raw_device_padded("vbmeta_a", read_test_data(VBMETA_A_FILE));
+        storage.add_raw_device_padded("vbmeta_b", read_test_data(VBMETA_B_FILE));
+        storage.add_raw_device_padded("vbmeta_r", read_test_data(VBMETA_R_FILE));
+        storage.add_raw_device_padded("vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
+        storage.add_raw_device_padded("durable_boot", vec![0u8; 64 * 1024]);
+        storage
+    }
+
+    pub(crate) fn create_gbl_ops<'a>(
+        partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>],
+    ) -> FakeGblOps<'a> {
+        let mut ops = FakeGblOps::new(&partitions);
+        ops.avb_ops.unlock_state = Ok(false);
+        ops.avb_ops.rollbacks = HashMap::from([
+            (TEST_ROLLBACK_INDEX_LOCATION, 0),
+            (AVB_CERT_PSK_VERSION_LOCATION.try_into().unwrap(), 0),
+            (AVB_CERT_PIK_VERSION_LOCATION.try_into().unwrap(), 0),
+        ]);
+        ops.avb_ops.use_cert = true;
+        ops.avb_ops.cert_permanent_attributes = Some(
+            CertPermanentAttributes::read_from(
+                &read_test_data("cert_permanent_attributes.bin")[..],
+            )
+            .unwrap(),
+        );
+        ops.avb_ops.cert_permanent_attributes_hash =
+            Some(read_test_data("cert_permanent_attributes.hash").try_into().unwrap());
+        ops
+    }
+
+    // Helper object for allocating aligned buffer.
+    pub(crate) struct AlignedBuffer {
+        buffer: Vec<u8>,
+        size: usize,
+        alignment: usize,
+    }
+
+    impl AlignedBuffer {
+        /// Allocates a buffer.
+        pub(crate) fn new(size: usize, alignment: usize) -> Self {
+            Self { buffer: vec![0u8; alignment + size - 1], size, alignment }
+        }
+
+        /// Allocates a buffer and initializes with data.
+        pub(crate) fn new_with_data(data: &[u8], alignment: usize) -> Self {
+            let mut res = Self::new(data.len(), alignment);
+            res.clone_from_slice(data);
+            res
+        }
+    }
+
+    impl Deref for AlignedBuffer {
+        type Target = [u8];
+
+        fn deref(&self) -> &Self::Target {
+            let off = aligned_offset(&self.buffer, self.alignment).unwrap();
+            &self.buffer[off..][..self.size]
+        }
+    }
+
+    impl DerefMut for AlignedBuffer {
+        fn deref_mut(&mut self) -> &mut Self::Target {
+            let off = aligned_offset(&self.buffer, self.alignment).unwrap();
+            &mut self.buffer[off..][..self.size]
+        }
+    }
+
+    /// Normalizes a ZBI container by converting each ZBI item into raw bytes and storing them in
+    /// an ordered set. The function is mainly used for comparing two ZBI containers have identical
+    /// set of items, disregarding order.
+    pub(crate) fn normalize_zbi(zbi: &[u8]) -> BTreeSet<Vec<u8>> {
+        let zbi = ZbiContainer::parse(zbi).unwrap();
+        BTreeSet::from_iter(zbi.iter().map(|v| {
+            let mut hdr = *v.header;
+            hdr.crc32 = 0; // ignores crc32 field.
+            hdr.flags &= !ZbiFlags::CRC32.bits();
+            [hdr.as_bytes(), v.payload.as_bytes()].concat()
+        }))
+    }
+
+    /// Helper to append a command line ZBI item to a ZBI container
+    pub(crate) fn append_cmd_line(zbi: &mut [u8], cmd: &[u8]) {
+        let mut container = ZbiContainer::parse(zbi).unwrap();
+        container.create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), cmd).unwrap();
+    }
+
+    /// Helper for testing `zircon_load_verify`.
+    fn test_load_verify(
+        ops: &mut FakeGblOps,
+        slot: Option<SlotIndex>,
+        expected_zbi_items: &[u8],
+        expected_kernel: &[u8],
+    ) {
+        // Test load buffer layout:
+        // |  zircon_x.zbi + items| ~~ |~64k~| relocated kernel + reserved |
+        // | ---------- 64K -----------|~~~~~| ----------------------------|
+        let sz = 2 * ZIRCON_KERNEL_ALIGN + expected_kernel.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE;
+        let mut load = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
+        let original_rb = ops.avb_ops.rollbacks.clone();
+        // Loads and verifies with unsuccessful slot flag first.
+        let (zbi_items, relocated) = zircon_load_verify(ops, slot, false, &mut load).unwrap();
+        // Verifies loaded ZBI kernel/items
+        assert_eq!(normalize_zbi(expected_zbi_items), normalize_zbi(zbi_items));
+        // Verifies relocated kernel
+        assert_eq!(normalize_zbi(expected_kernel), normalize_zbi(relocated));
+        // Relocated kernel is at the latest aligned address
+        let off = (relocated.as_ptr() as usize) - (load.as_ptr() as usize);
+        assert_eq!(off, 2 * ZIRCON_KERNEL_ALIGN);
+
+        // Verifies that the slot successful flag is passed correctly.
+        // Unsuccessful slot, rollback not updated.
+        assert_eq!(ops.avb_ops.rollbacks, original_rb);
+        // Loads and verifies with successful slot flag.
+        zircon_load_verify(ops, slot, true, &mut load).unwrap();
+        // Successful slot, rollback updated.
+        assert_eq!(
+            ops.avb_ops.rollbacks,
+            [
+                (TEST_ROLLBACK_INDEX_LOCATION, TEST_ROLLBACK_INDEX_VALUE),
+                (usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION),
+                (usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION)
+            ]
+            .into()
+        );
+    }
+
+    #[test]
+    fn test_zircon_load_verify_slotless() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zbi = &read_test_data(ZIRCON_SLOTLESS_ZBI_FILE);
+        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
+        // Adds extra bytes for device ZBI items.
+        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
+        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        test_load_verify(&mut ops, None, &expected_zbi_items, &expected_kernel);
+    }
+
+    /// Helper for testing `zircon_load_verify` using A/B/R.
+    fn test_load_verify_slotted_helper(
+        ops: &mut FakeGblOps,
+        slot: SlotIndex,
+        zbi: &[u8],
+        slot_item: &str,
+    ) {
+        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
+        // Adds extra bytes for device ZBI items.
+        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
+        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        append_cmd_line(&mut expected_zbi_items, slot_item.as_bytes());
+        test_load_verify(ops, Some(slot), &expected_zbi_items, &expected_kernel);
+    }
+
+    #[test]
+    fn test_load_verify_slot_a() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zircon_a_zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        test_load_verify_slotted_helper(&mut ops, SlotIndex::A, zircon_a_zbi, "zvb.current_slot=a");
+    }
+
+    #[test]
+    fn test_load_verify_slot_b() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zircon_b_zbi = &read_test_data(ZIRCON_B_ZBI_FILE);
+        test_load_verify_slotted_helper(&mut ops, SlotIndex::B, zircon_b_zbi, "zvb.current_slot=b");
+    }
+
+    #[test]
+    fn test_load_verify_slot_r() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zircon_r_zbi = &read_test_data(ZIRCON_R_ZBI_FILE);
+        test_load_verify_slotted_helper(&mut ops, SlotIndex::R, zircon_r_zbi, "zvb.current_slot=r");
+    }
+
+    #[test]
+    fn test_not_enough_buffer_for_reserved_memory() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        let sz = ZIRCON_KERNEL_ALIGN + zbi.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE - 1;
+        let mut load = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
+        assert!(zircon_load_verify(&mut ops, Some(SlotIndex::A), true, &mut load).is_err());
+    }
+
+    /// A helper for assembling a set of test needed data. These include:
+    ///
+    /// * The original partition ZBI kernel image set in the given `FakeGblOps`.
+    /// * A buffer for loading and verifying the kernel.
+    /// * The expected ZBI item buffer, if successfully loaded.
+    /// * The expected ZBI kernel buffer, if successfully loaded.
+    fn load_verify_test_data(
+        ops: &mut FakeGblOps,
+        slot: SlotIndex,
+    ) -> (Vec<u8>, AlignedBuffer, AlignedBuffer, AlignedBuffer) {
+        let slot_info_map: HashMap<core::ffi::c_uint, (&str, &[u8], &str)> = [
+            (SlotIndex::A.into(), ("zircon_a", &b"zvb.current_slot=a"[..], ZIRCON_A_ZBI_FILE)),
+            (SlotIndex::B.into(), ("zircon_b", &b"zvb.current_slot=b"[..], ZIRCON_B_ZBI_FILE)),
+            (SlotIndex::R.into(), ("zircon_r", &b"zvb.current_slot=r"[..], ZIRCON_R_ZBI_FILE)),
+        ]
+        .into();
+        let (name, slot_item, original_file_name) = slot_info_map.get(&slot.into()).unwrap();
+        // Read the (possibly modified) ZBI from disk, using the original unmodified ZBI to
+        // determine the size.
+        let mut zbi = ops.copy_partition(name);
+        zbi.truncate(read_test_data(original_file_name).len());
+        // Test load buffer layout:
+        // |  zircon_x.zbi + items| ~~ | relocated kernel + reserved |
+        // | ---------- 64K -----------| ----------------------------|
+        let sz = ZIRCON_KERNEL_ALIGN + zbi.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE;
+        let load_buffer = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
+        let expected_kernel = AlignedBuffer::new_with_data(&zbi, ZBI_ALIGNMENT_USIZE);
+        // Adds extra bytes for device ZBI items.
+        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
+        expected_zbi_items[..zbi.len()].clone_from_slice(&zbi);
+        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        append_cmd_line(&mut expected_zbi_items, slot_item);
+        (zbi, load_buffer, expected_zbi_items, expected_kernel)
+    }
+
+    // Calls `zircon_load_verify_abr` and checks that the specified slot is loaded.
+    fn expect_load_verify_abr_ok(ops: &mut FakeGblOps, slot: SlotIndex) {
+        let (zbi, mut load, expected_items, expected_kernel) = load_verify_test_data(ops, slot);
+        let (zbi_items, kernel, active) = zircon_load_verify_abr(ops, &mut load).unwrap();
+        assert_eq!(normalize_zbi(&expected_items), normalize_zbi(&zbi_items));
+        assert_eq!(normalize_zbi(&expected_kernel), normalize_zbi(&kernel));
+        assert_eq!(active, slot);
+    }
+
+    #[test]
+    fn test_load_verify_abr_slot_a() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+    }
+
+    #[test]
+    fn test_load_verify_abr_slot_b() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        mark_slot_active(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+    }
+
+    #[test]
+    fn test_load_verify_abr_slot_r() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::A).unwrap();
+        mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+    }
+
+    #[test]
+    fn test_load_verify_abr_exhaust_retries() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+        }
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+        }
+        // Tests that load falls back to R eventually.
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+    }
+
+    /// Modifies data in the given partition.
+    pub(crate) fn corrupt_data(ops: &mut FakeGblOps, part_name: &str) {
+        let mut data = [0u8];
+        assert!(ops.read_from_partition_sync(part_name, 64, &mut data[..]).is_ok());
+        data[0] ^= 0x01;
+        assert!(ops.write_to_partition_sync(part_name, 64, &mut data[..]).is_ok());
+    }
+
+    #[test]
+    fn test_load_verify_abr_verify_failure_a_b() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        corrupt_data(&mut ops, "zircon_a");
+        corrupt_data(&mut ops, "zircon_b");
+
+        let (_, mut load, _, _) = load_verify_test_data(&mut ops, SlotIndex::A);
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            assert!(zircon_load_verify_abr(&mut ops, &mut load).is_err());
+        }
+        let (_, mut load, _, _) = load_verify_test_data(&mut ops, SlotIndex::B);
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            assert!(zircon_load_verify_abr(&mut ops, &mut load).is_err());
+        }
+        // Tests that load falls back to R eventually.
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+    }
+
+    #[test]
+    fn test_load_verify_abr_verify_failure_unlocked() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        ops.avb_ops.unlock_state = Ok(true);
+        corrupt_data(&mut ops, "zircon_a");
+        corrupt_data(&mut ops, "zircon_b");
+
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+        }
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+        }
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+    }
+}
diff --git a/gbl/libgbl/src/fuchsia_boot/vboot.rs b/gbl/libgbl/src/fuchsia_boot/vboot.rs
new file mode 100644
index 0000000..7394e04
--- /dev/null
+++ b/gbl/libgbl/src/fuchsia_boot/vboot.rs
@@ -0,0 +1,517 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use crate::{
+    fuchsia_boot::{zbi_split_unused_buffer, zircon_part_name, SlotIndex},
+    gbl_print, GblOps, Result as GblResult,
+};
+use avb::{
+    cert_validate_vbmeta_public_key, slot_verify, CertOps, CertPermanentAttributes, Descriptor,
+    HashtreeErrorMode, IoError as AvbIoError, IoResult as AvbIoResult, Ops as AvbOps,
+    PublicKeyForPartitionInfo, SlotVerifyError, SlotVerifyFlags, SHA256_DIGEST_SIZE,
+};
+use core::{
+    cmp::{max, min},
+    ffi::CStr,
+};
+use safemath::SafeNum;
+use uuid::Uuid;
+use zbi::{merge_within, ZbiContainer};
+
+// For Fuchsia, maximum number of key version is 2.
+const AVB_ATX_NUM_KEY_VERSIONS: usize = 2;
+
+/// `GblZirconBootAvbOps` implements `avb::Ops` for GBL Zircon boot flow.
+struct GblZirconBootAvbOps<'a, T> {
+    gbl_ops: &'a mut T,
+    preloaded_partitions: &'a [(&'a str, &'a [u8])],
+    // Used for storing key versions to be set. (location, version).
+    // If `array_map` is imported in the future, consider switching to it.
+    key_versions: [Option<(usize, u64)>; AVB_ATX_NUM_KEY_VERSIONS],
+}
+
+impl<'a, T: GblOps<'a>> GblZirconBootAvbOps<'_, T> {
+    /// Returns the size of a partition.
+    fn partition_size(&mut self, partition: &str) -> AvbIoResult<u64> {
+        Ok(self
+            .gbl_ops
+            .partition_size(partition)
+            .or(Err(AvbIoError::Io))?
+            .ok_or(AvbIoError::NoSuchPartition)?)
+    }
+}
+
+/// A helper function for converting `CStr` to `str`
+fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
+    Ok(s.to_str().or(Err(err))?)
+}
+
+impl<'a, 'b, T: GblOps<'b>> AvbOps<'a> for GblZirconBootAvbOps<'a, T> {
+    fn read_from_partition(
+        &mut self,
+        partition: &CStr,
+        offset: i64,
+        buffer: &mut [u8],
+    ) -> AvbIoResult<usize> {
+        let part_str = cstr_to_str(partition, AvbIoError::NoSuchPartition)?;
+        let partition_size = SafeNum::from(self.partition_size(part_str)?);
+        let read_off = match offset < 0 {
+            true => partition_size - offset.abs(),
+            _ => SafeNum::from(offset),
+        };
+        let read_sz = partition_size - read_off;
+        let read_off = read_off.try_into().map_err(|_| AvbIoError::Io)?;
+        let read_sz: usize = min(buffer.len(), read_sz.try_into().map_err(|_| AvbIoError::Io)?);
+        self.gbl_ops
+            .read_from_partition_sync(part_str, read_off, &mut buffer[..read_sz])
+            .map_err(|_| AvbIoError::Io)?;
+        Ok(read_sz)
+    }
+
+    fn get_preloaded_partition(&mut self, partition: &CStr) -> AvbIoResult<&'a [u8]> {
+        let part_str = cstr_to_str(partition, AvbIoError::NotImplemented)?;
+        Ok(self
+            .preloaded_partitions
+            .iter()
+            .find(|(name, _)| *name == part_str)
+            .ok_or(AvbIoError::NotImplemented)?
+            .1)
+    }
+
+    fn validate_vbmeta_public_key(
+        &mut self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> AvbIoResult<bool> {
+        cert_validate_vbmeta_public_key(self, public_key, public_key_metadata)
+    }
+
+    fn read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
+        self.gbl_ops.avb_read_rollback_index(rollback_index_location)
+    }
+
+    fn write_rollback_index(
+        &mut self,
+        rollback_index_location: usize,
+        index: u64,
+    ) -> AvbIoResult<()> {
+        self.gbl_ops.avb_write_rollback_index(rollback_index_location, index)
+    }
+
+    fn read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
+        self.gbl_ops.avb_read_is_device_unlocked()
+    }
+
+    fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> AvbIoResult<Uuid> {
+        // The ops is only used to check that a partition exists. GUID is not used.
+        self.partition_size(cstr_to_str(partition, AvbIoError::NoSuchPartition)?)?;
+        Ok(Uuid::nil())
+    }
+
+    fn get_size_of_partition(&mut self, partition: &CStr) -> AvbIoResult<u64> {
+        match self.get_preloaded_partition(partition) {
+            Ok(img) => Ok(img.len().try_into().unwrap()),
+            _ => {
+                let part_str = cstr_to_str(partition, AvbIoError::NoSuchPartition)?;
+                self.partition_size(part_str)
+            }
+        }
+    }
+
+    fn read_persistent_value(&mut self, _name: &CStr, _value: &mut [u8]) -> AvbIoResult<usize> {
+        // Fuchsia might need this in the future.
+        unimplemented!();
+    }
+
+    fn write_persistent_value(&mut self, _name: &CStr, _value: &[u8]) -> AvbIoResult<()> {
+        // Not needed by Fuchsia.
+        unreachable!();
+    }
+
+    fn erase_persistent_value(&mut self, _name: &CStr) -> AvbIoResult<()> {
+        // Not needed by Fuchsia.
+        unreachable!();
+    }
+
+    fn validate_public_key_for_partition(
+        &mut self,
+        _partition: &CStr,
+        _public_key: &[u8],
+        _public_key_metadata: Option<&[u8]>,
+    ) -> AvbIoResult<PublicKeyForPartitionInfo> {
+        // Not needed by Fuchsia.
+        unreachable!();
+    }
+
+    fn cert_ops(&mut self) -> Option<&mut dyn CertOps> {
+        Some(self)
+    }
+}
+
+impl<'a, T: GblOps<'a>> CertOps for GblZirconBootAvbOps<'_, T> {
+    fn read_permanent_attributes(
+        &mut self,
+        attributes: &mut CertPermanentAttributes,
+    ) -> AvbIoResult<()> {
+        self.gbl_ops.avb_cert_read_permanent_attributes(attributes)
+    }
+
+    fn read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
+        self.gbl_ops.avb_cert_read_permanent_attributes_hash()
+    }
+
+    fn set_key_version(&mut self, rollback_index_location: usize, key_version: u64) {
+        // Checks if there is already an allocated slot for this location.
+        let existing = self
+            .key_versions
+            .iter_mut()
+            .find_map(|v| v.as_mut().filter(|(loc, _)| *loc == rollback_index_location));
+        match existing {
+            Some((_, val)) => *val = max(*val, key_version),
+            _ => {
+                // Finds an empty slot and stores the rollback index.
+                *self.key_versions.iter_mut().find(|v| v.is_none()).unwrap() =
+                    Some((rollback_index_location, key_version))
+            }
+        }
+    }
+
+    fn get_random(&mut self, bytes: &mut [u8]) -> AvbIoResult<()> {
+        unimplemented!()
+    }
+}
+
+/// Helper for getting the A/B/R suffix.
+fn slot_suffix(slot: Option<SlotIndex>) -> Option<&'static CStr> {
+    Some(match slot? {
+        SlotIndex::A => c"_a",
+        SlotIndex::B => c"_b",
+        SlotIndex::R => c"_r",
+    })
+}
+
+/// Verifies a loaded ZBI kernel.
+pub(crate) fn zircon_verify_kernel<'a, 'b>(
+    gbl_ops: &mut impl GblOps<'b>,
+    slot: Option<SlotIndex>,
+    slot_booted_successfully: bool,
+    zbi_kernel: &'a mut [u8],
+) -> GblResult<()> {
+    let (kernel, desc_buf) = zbi_split_unused_buffer(&mut zbi_kernel[..])?;
+    let desc_zbi_off = kernel.len();
+
+    // Determines verify flags and error mode.
+    let unlocked = gbl_ops.avb_read_is_device_unlocked()?;
+    let mode = HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO; // Don't care for fuchsia
+    let flag = match unlocked {
+        true => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,
+        _ => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
+    };
+
+    {
+        // Verifies the kernel.
+        let part = zircon_part_name(slot);
+        let preloaded = [(part, &kernel[..])];
+        let mut avb_ops = GblZirconBootAvbOps {
+            gbl_ops,
+            preloaded_partitions: &preloaded[..],
+            key_versions: [None; AVB_ATX_NUM_KEY_VERSIONS],
+        };
+        // TODO(b/334962583): Supports optional additional partitions to verify.
+        let verify_res = slot_verify(&mut avb_ops, &[c"zircon"], slot_suffix(slot), flag, mode);
+        let verified_success = verify_res.is_ok();
+        let verify_data = match verify_res {
+            Ok(v) => {
+                gbl_print!(avb_ops.gbl_ops, "{} successfully verified.\r\n", part);
+                v
+            }
+            Err(SlotVerifyError::Verification(Some(v))) if unlocked => {
+                gbl_print!(avb_ops.gbl_ops, "Verification failed. Device is unlocked. Ignore.\r\n");
+                v
+            }
+            Err(_) if unlocked => {
+                gbl_print!(
+                    avb_ops.gbl_ops,
+                    "Verification failed. No valid verify metadata. \
+                    Device is unlocked. Ignore.\r\n"
+                );
+                return Ok(());
+            }
+            Err(e) => {
+                gbl_print!(avb_ops.gbl_ops, "Verification failed {:?}.\r\n", e);
+                return Err(e.without_verify_data().into());
+            }
+        };
+
+        // Collects ZBI items from vbmetadata and appends to the `desc_buf` buffer.
+        let mut desc_container = ZbiContainer::new(&mut desc_buf[..])?;
+        for vbmeta_data in verify_data.vbmeta_data() {
+            for prop in vbmeta_data.descriptors()?.iter().filter_map(|d| match d {
+                Descriptor::Property(p) if p.key.starts_with("zbi") => Some(p),
+                _ => None,
+            }) {
+                desc_container.extend_unaligned(prop.value)?;
+            }
+        }
+
+        // Increases rollback indices if the slot has successfully booted.
+        if verified_success && slot_booted_successfully {
+            for (loc, val) in verify_data.rollback_indexes().iter().enumerate() {
+                if *val > 0 && avb_ops.read_rollback_index(loc)? != *val {
+                    avb_ops.write_rollback_index(loc, *val)?;
+                }
+            }
+
+            // Increases rollback index values for Fuchsia key version locations.
+            for key_version in avb_ops.key_versions {
+                match key_version {
+                    Some((loc, rollback)) if avb_ops.read_rollback_index(loc)? != rollback => {
+                        avb_ops.write_rollback_index(loc, rollback)?;
+                    }
+                    _ => {}
+                }
+            }
+        }
+    }
+
+    // Merges the vbmeta descriptor ZBI container into the ZBI kernel container.
+    Ok(merge_within(zbi_kernel, desc_zbi_off).map(|_| ())?)
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::fuchsia_boot::{
+        test::{
+            append_cmd_line, corrupt_data, create_gbl_ops, create_storage, normalize_zbi,
+            read_test_data, AlignedBuffer, ZIRCON_A_ZBI_FILE,
+        },
+        ZIRCON_KERNEL_ALIGN,
+    };
+    use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
+
+    // The cert test keys were both generated with rollback version 42.
+    const TEST_CERT_PIK_VERSION: u64 = 42;
+    const TEST_CERT_PSK_VERSION: u64 = 42;
+
+    #[test]
+    fn test_avb_ops_read_from_partition_positive_off() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let gbl_ops = &mut create_gbl_ops(&partitions);
+
+        let zircon_a = gbl_ops.copy_partition("zircon_a");
+
+        let mut avb_ops =
+            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
+        let mut out = vec![0u8; 512];
+        // Positive offset.
+        avb_ops.read_from_partition(c"zircon_a", 1, &mut out[..]).unwrap();
+        assert_eq!(out, zircon_a[1..][..out.len()]);
+    }
+
+    #[test]
+    fn test_avb_ops_read_from_partition_negative_off() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let gbl_ops = &mut create_gbl_ops(&partitions);
+
+        let zircon_a = gbl_ops.copy_partition("zircon_a");
+
+        let mut avb_ops =
+            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
+        let mut out = vec![0u8; 512];
+        // Negative offset.
+        avb_ops.read_from_partition(c"zircon_a", -1024, &mut out[..]).unwrap();
+        assert_eq!(out, zircon_a[zircon_a.len() - 1024..][..out.len()]);
+    }
+
+    #[test]
+    fn test_avb_ops_read_from_partition_partial_read() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let gbl_ops = &mut create_gbl_ops(&partitions);
+
+        let zircon_a = gbl_ops.copy_partition("zircon_a");
+
+        let mut avb_ops =
+            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
+        let mut out = vec![0u8; 512];
+        // Partial read.
+        avb_ops.read_from_partition(c"zircon_a", -256, &mut out[..]).unwrap();
+        assert_eq!(out[..256], zircon_a[zircon_a.len() - 256..]);
+    }
+
+    #[test]
+    fn test_verify_success() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), false, &mut load_buffer).unwrap();
+
+        // Verifies that vbmeta ZBI items are appended. Non-zbi items are ignored.
+        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, 8);
+        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        assert_eq!(normalize_zbi(&load_buffer), normalize_zbi(&expected_zbi_items));
+
+        // Slot is not successful, rollback index should not be updated.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+
+    #[test]
+    fn test_verify_update_rollback_index_for_successful_slot() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+
+        // Slot is successful, rollback index should be updated.
+        // vbmeta_a has rollback index value 2 at location 1.
+        assert_eq!(
+            ops.avb_ops.rollbacks,
+            [
+                (1, 2),
+                (usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION),
+                (usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION)
+            ]
+            .into()
+        );
+    }
+
+    #[test]
+    fn test_verify_failed_on_corrupted_image() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        // Corrupts a random kernel bytes. Skips pass two ZBI headers.
+        load_buffer[64] = !load_buffer[64];
+        let expect_load = load_buffer.to_vec();
+        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).is_err());
+        // Failed while device is locked. ZBI items should not be appended.
+        assert_eq!(expect_load, &load_buffer[..]);
+        // Rollback index should not be updated on verification failure.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+
+    #[test]
+    fn test_verify_failed_on_corrupted_vbmetadata() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load[..zbi.len()].clone_from_slice(zbi);
+        let expect_load = load.to_vec();
+        // Corrupts vbmetadata
+        corrupt_data(&mut ops, "vbmeta_a");
+        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load).is_err());
+        // Failed while device is locked. ZBI items should not be appended.
+        assert_eq!(expect_load, &load[..]);
+        // Rollback index should not be updated on verification failure.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+
+    #[test]
+    fn test_verify_failed_on_rollback_protection() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let expect_load = load_buffer.to_vec();
+        // vbmeta_a has rollback index value 2 at location 1. Setting min rollback value of 3 should
+        // cause rollback protection failure.
+        ops.avb_ops.rollbacks.insert(1, 3);
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).is_err());
+        // Failed while device is locked. ZBI items should not be appended.
+        assert_eq!(expect_load, &load_buffer[..]);
+        // Rollback index should not be updated on verification failure.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+
+    #[test]
+    fn test_verify_failure_when_unlocked() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        ops.avb_ops.unlock_state = Ok(true);
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        // Corrupts a random kernel bytes. Skips pass two ZBI headers.
+        load_buffer[64] = !load_buffer[64];
+        // Verification should proceeds OK.
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+        // Verifies that vbmeta ZBI items are appended as long as unlocked.
+        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), 8);
+        expected_zbi_items[..load_buffer.len()].clone_from_slice(&load_buffer);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        assert_eq!(normalize_zbi(&load_buffer), normalize_zbi(&expected_zbi_items));
+        // Rollback index should not be updated in any failure cases, even when unlocked.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+
+    #[test]
+    fn test_verify_failure_by_corrupted_vbmetadata_unlocked() {
+        let mut storage = create_storage();
+        let partitions = storage.as_partition_block_devices();
+        let mut ops = create_gbl_ops(&partitions);
+
+        ops.avb_ops.unlock_state = Ok(true);
+        let expect_rollback = ops.avb_ops.rollbacks.clone();
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        // Adds extra bytes for device ZBI items.
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let expect_load = load_buffer.to_vec();
+        // Corrupts vbmetadata
+        corrupt_data(&mut ops, "vbmeta_a");
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+        // Unlocked but vbmetadata is invalid so no ZBI items should be appended.
+        assert_eq!(expect_load, &load_buffer[..]);
+        // Rollback index should not be updated on verification failure.
+        assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
+    }
+}
diff --git a/gbl/libgbl/src/image_buffer.rs b/gbl/libgbl/src/image_buffer.rs
new file mode 100644
index 0000000..0255829
--- /dev/null
+++ b/gbl/libgbl/src/image_buffer.rs
@@ -0,0 +1,205 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! ImageBuffer is helper to store uninitialized memory buffer. And work with it allowing to read
+//! into the buffer and retrieve initialized part.
+//!
+//! Similar to [ReadBuf](https://docs.rs/tokio/latest/tokio/io/struct.ReadBuf.html) but works in
+//! `no_std`.
+
+use core::mem::MaybeUninit;
+use liberror::{Error, Result};
+
+/// Wrapper class for buffer received with [get_buffer] function.
+///
+/// Helps to keep track of allocated/init memory and avoid getting same buffer more than once.
+#[derive(Debug)]
+pub struct ImageBuffer<'a> {
+    buffer: Option<&'a mut [MaybeUninit<u8>]>,
+    // number of initialized and filled bytes.
+    used_bytes: usize,
+}
+
+// Unstable MaybeUninit API
+// feature = "maybe_uninit_slice", issue = "63569"
+
+// Assuming all the elements are initialized, get a mutable slice to them.
+//
+// # Safety
+//
+// It is up to the caller to guarantee that the `MaybeUninit<T>` elements
+// really are in an initialized state.
+// Calling this when the content is not yet fully initialized causes undefined behavior.
+#[inline(always)]
+unsafe fn slice_assume_init_mut<T>(slice: &mut [MaybeUninit<T>]) -> &mut [T] {
+    // SAFETY: similar to safety notes for `slice_get_ref`, but we have a
+    // mutable reference which is also guaranteed to be valid for writes.
+    unsafe { &mut *(slice as *mut [MaybeUninit<T>] as *mut [T]) }
+}
+
+impl ImageBuffer<'_> {
+    /// Create new ImageBuffer from buffer and used_bytes
+    pub fn new(buffer: &mut [MaybeUninit<u8>]) -> ImageBuffer {
+        ImageBuffer { buffer: Some(buffer), used_bytes: 0 }
+    }
+
+    /// Total buffer capacity.
+    pub fn capacity(&self) -> usize {
+        self.buffer.as_ref().unwrap().len()
+    }
+
+    /// Increase used part of the buffer by `len`
+    ///
+    /// Return:
+    /// Error() - if current used_bytes + len > capacity, or causes arithmetic overflow.
+    /// Ok(()) - on success
+    ///
+    /// SAFETY:
+    /// It is up to the user to guarantee that `len` bytes for tail was initialized and filled.
+    pub unsafe fn advance_used(&mut self, len: usize) -> Result<()> {
+        let Some(new_len) = self.used_bytes.checked_add(len) else {
+            return Err(Error::Other(Some("Used bytes overflow")));
+        };
+        if new_len > self.capacity() {
+            return Err(Error::BufferTooSmall(Some(new_len)));
+        }
+        self.used_bytes = new_len;
+        Ok(())
+    }
+
+    /// Return used and tail parts of the buffer
+    pub fn get_split(&mut self) -> (&mut [u8], &mut [MaybeUninit<u8>]) {
+        let (used, tail) = self.buffer.as_mut().unwrap().split_at_mut(self.used_bytes);
+        // SAFETY
+        //
+        // ImageBuffer user guaranties that changing used elements means they were initialized.
+        // And object assumes initialized only for slice [..used_bytes]
+        let initialized = unsafe { slice_assume_init_mut(used) };
+        (initialized, tail)
+    }
+
+    /// Slice of the buffer that is used
+    pub fn used(&mut self) -> &mut [u8] {
+        let (used, _) = self.get_split();
+        used
+    }
+
+    /// Return part of the buffer that is not used
+    pub fn tail(&mut self) -> &mut [MaybeUninit<u8>] {
+        let (_, tail) = self.get_split();
+        tail
+    }
+}
+
+impl AsRef<[MaybeUninit<u8>]> for ImageBuffer<'_> {
+    fn as_ref(&self) -> &[MaybeUninit<u8>] {
+        self.buffer.as_ref().unwrap()
+    }
+}
+
+impl AsMut<[MaybeUninit<u8>]> for ImageBuffer<'_> {
+    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
+        self.buffer.as_mut().unwrap()
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    // Helper to create ImageBuffers from Vec<u8>
+    struct ImageBufferVec {
+        buf: Vec<u8>,
+    }
+
+    fn slice_assume_not_init_mut<T>(slice: &mut [T]) -> &mut [MaybeUninit<T>] {
+        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a
+        // mutable reference which is also guaranteed to be valid for writes.
+        unsafe { &mut *(slice as *mut [T] as *mut [MaybeUninit<T>]) }
+    }
+
+    impl ImageBufferVec {
+        fn new(buf: Vec<u8>) -> Self {
+            Self { buf }
+        }
+
+        fn get(&mut self) -> ImageBuffer {
+            ImageBuffer::new(slice_assume_not_init_mut(self.buf.as_mut_slice()))
+        }
+    }
+
+    #[test]
+    fn test_image_buffer_capacity() {
+        assert_eq!(ImageBufferVec::new(vec![0u8; 0]).get().capacity(), 0);
+        assert_eq!(ImageBufferVec::new(vec![0u8; 0]).get().capacity(), 0);
+        assert_eq!(ImageBufferVec::new(vec![0u8; 1]).get().capacity(), 1);
+        assert_eq!(ImageBufferVec::new(vec![0u8; 100]).get().capacity(), 100);
+        assert_eq!(
+            ImageBufferVec::new(vec![0u8; 128 * 1024 * 1024]).get().capacity(),
+            128 * 1024 * 1024
+        );
+    }
+
+    #[test]
+    fn test_image_buffer_used() {
+        let mut img_buf_vec = ImageBufferVec::new(vec![0u8; 100]);
+        let mut img_buf = img_buf_vec.get();
+        assert_eq!(img_buf.used().len(), 0);
+        // SAFETY:
+        // All data in img_buf is initialized since it was created from vec
+        unsafe { img_buf.advance_used(1).unwrap() };
+        assert_eq!(img_buf.used().len(), 1);
+        // SAFETY:
+        // All data in img_buf is initialized since it was created from vec
+        unsafe { img_buf.advance_used(3).unwrap() };
+        assert_eq!(img_buf.used().len(), 4);
+        assert_eq!(
+            // SAFETY:
+            // All data in img_buf is initialized since it was created from vec
+            unsafe { img_buf.advance_used(1024) },
+            Err(Error::BufferTooSmall(Some(1028)))
+        );
+        assert_eq!(img_buf.used().len(), 4);
+    }
+
+    #[test]
+    fn test_image_buffer_get_split() {
+        let mut img_buf_vec = ImageBufferVec::new(vec![0u8, 1, 2, 3]);
+        let mut img_buf = img_buf_vec.get();
+
+        assert_eq!(img_buf.used(), [].as_mut_slice());
+        assert_eq!(img_buf.tail().len(), 4);
+        let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [].as_mut_slice());
+        assert_eq!(tail.len(), 4);
+
+        // SAFETY:
+        // All data in img_buf is initialized since it was created from vec
+        unsafe { img_buf.advance_used(2).unwrap() };
+        assert_eq!(img_buf.used(), [0, 1].as_mut_slice());
+        assert_eq!(img_buf.tail().len(), 2);
+        let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [0, 1].as_mut_slice());
+        assert_eq!(tail.len(), 2);
+
+        // SAFETY:
+        // All data in img_buf is initialized since it was created from vec
+        unsafe { img_buf.advance_used(2).unwrap() };
+        assert_eq!(img_buf.used(), [0, 1, 2, 3].as_mut_slice());
+        assert_eq!(img_buf.tail().len(), 0);
+        let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [0, 1, 2, 3].as_mut_slice());
+        assert_eq!(tail.len(), 0);
+    }
+}
diff --git a/gbl/libgbl/src/lib.rs b/gbl/libgbl/src/lib.rs
index c170e4e..236a426 100644
--- a/gbl/libgbl/src/lib.rs
+++ b/gbl/libgbl/src/lib.rs
@@ -27,43 +27,41 @@
 #![cfg_attr(not(any(test, android_dylib)), no_std)]
 // TODO: b/312610985 - return warning for unused partitions
 #![allow(unused_variables, dead_code)]
+#![allow(async_fn_in_trait)]
+#![feature(associated_type_defaults)]
 // TODO: b/312608163 - Adding ZBI library usage to check dependencies
 extern crate avb;
 extern crate core;
-extern crate cstr;
 extern crate gbl_storage;
 extern crate spin;
 extern crate zbi;
 
-use avb::{HashtreeErrorMode, SlotVerifyData, SlotVerifyError, SlotVerifyFlags, SlotVerifyResult};
+use avb::{HashtreeErrorMode, SlotVerifyData, SlotVerifyError, SlotVerifyFlags};
 use core::ffi::CStr;
-use core::fmt::Debug;
-use cstr::cstr;
-use gbl_storage::AsMultiBlockDevices;
-use spin::Mutex;
 
 pub mod boot_mode;
 pub mod boot_reason;
 pub mod error;
 pub mod fastboot;
+pub mod fuchsia_boot;
+mod image_buffer;
 pub mod ops;
 mod overlap;
+pub mod partition;
 
 /// The 'slots' module, containing types and traits for
 /// querying and modifying slotted boot behavior.
 pub mod slots;
 
-use slots::{BootTarget, BootToken, Cursor, Manager, OneShot, SuffixBytes, UnbootableReason};
+use slots::{BootTarget, BootToken, Cursor, OneShot, SuffixBytes, UnbootableReason};
 
 pub use avb::Descriptor;
 pub use boot_mode::BootMode;
 pub use boot_reason::KnownBootReason;
-pub use error::{Error, IntegrationError, Result};
-pub use ops::{
-    AndroidBootImages, BootImages, DefaultGblOps, FuchsiaBootImages, GblOps, GblOpsError,
-};
+pub use error::{IntegrationError, Result};
+use liberror::Error;
+pub use ops::{AndroidBootImages, BootImages, FuchsiaBootImages, GblOps};
 
-use ops::GblUtils;
 use overlap::is_overlap;
 
 // TODO: b/312607649 - Replace placeholders with actual structures: https://r.android.com/2721974, etc
@@ -72,10 +70,6 @@ pub struct Partition {}
 /// TODO: b/312607649 - placeholder type
 pub struct InfoStruct {}
 
-/// Data structure holding verified slot data.
-#[derive(Debug)]
-pub struct VerifiedData<'a>(SlotVerifyData<'a>);
-
 /// Structure representing partition and optional address it is required to be loaded.
 /// If no address is provided GBL will use default one.
 pub struct PartitionRamMap<'b, 'c> {
@@ -112,7 +106,7 @@ pub struct Dtb<'a>(&'a mut [u8]);
 /// Create Boot Image from corresponding partition for `partitions_ram_map` and `avb_descriptors`
 /// lists
 pub fn get_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut VerifiedData<'d>,
+    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<BootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -127,7 +121,7 @@ pub fn get_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 /// Create Vendor Boot Image from corresponding partition for `partitions_ram_map` and
 /// `avb_descriptors` lists
 pub fn get_vendor_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut VerifiedData<'d>,
+    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<VendorBootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -141,7 +135,7 @@ pub fn get_vendor_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 
 /// Create Init Boot Image from corresponding partition for `partitions` and `avb_descriptors` lists
 pub fn get_init_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut VerifiedData<'d>,
+    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<InitBootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -155,7 +149,7 @@ pub fn get_init_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 
 /// Create separate image types from [avb::Descriptor]
 pub fn get_images<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut VerifiedData<'d>,
+    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (
     Option<BootImage<'c>>,
@@ -171,72 +165,60 @@ pub fn get_images<'a: 'b, 'b: 'c, 'c, 'd>(
     (boot_image, init_boot_image, vendor_boot_image, partitions_ram_map)
 }
 
-static BOOT_TOKEN: Mutex<Option<BootToken>> = Mutex::new(Some(BootToken(())));
-
-type AvbVerifySlot = for<'b> fn(
-    ops: &mut dyn avb::Ops<'b>,
-    requested_partitions: &[&CStr],
-    ab_suffix: Option<&CStr>,
-    flags: SlotVerifyFlags,
-    hashtree_error_mode: HashtreeErrorMode,
-) -> SlotVerifyResult<'b, SlotVerifyData<'b>>;
-
 /// GBL object that provides implementation of helpers for boot process.
-///
-/// To create this object use [GblBuilder].
 pub struct Gbl<'a, G>
 where
-    G: GblOps,
+    G: GblOps<'a>,
 {
     ops: &'a mut G,
-    verify_slot: AvbVerifySlot,
+    boot_token: Option<BootToken>,
 }
 
 impl<'a, G> Gbl<'a, G>
 where
-    G: GblOps,
+    G: GblOps<'a>,
 {
+    /// Returns a new [Gbl] object.
+    ///
+    /// # Arguments
+    /// * `ops` - the [GblOps] callbacks to use
+    pub fn new(ops: &'a mut G) -> Self {
+        Self { ops, boot_token: Some(BootToken(())) }
+    }
+
     /// Verify + Load Image Into memory
     ///
     /// Load from disk, validate with AVB
     ///
     /// # Arguments
-    ///   * `avb_ops` - implementation for `avb::Ops` that would be borrowed in result to prevent
-    ///   changes to partitions until it is out of scope.
-    ///   * `partitions_ram_map` - Partitions to verify with optional address to load image to.
-    ///   * `slot_verify_flags` - AVB slot verification flags
-    ///   * `boot_target` - [Optional] Boot Target
+    /// * `avb_ops` - implementation for `avb::Ops`
+    /// * `partitions_to_verify` - names of all the partitions to verify with libavb.
+    /// * `slot_verify_flags` - AVB slot verification flags
+    /// * `boot_target` - [Optional] Boot Target
     ///
     /// # Returns
-    ///
-    /// * `Ok(&[avb_descriptor])` - Array of AVB Descriptors - AVB return codes, partition name,
-    /// image load address, image size, AVB Footer contents (version details, etc.)
+    /// * `Ok(SlotVerifyData)` - avb verification data
     /// * `Err(Error)` - on failure
     pub fn load_and_verify_image<'b>(
         &mut self,
         avb_ops: &mut impl avb::Ops<'b>,
-        partitions_ram_map: &mut [PartitionRamMap],
+        partitions_to_verify: &[&CStr],
         slot_verify_flags: SlotVerifyFlags,
         boot_target: Option<BootTarget>,
-    ) -> Result<VerifiedData<'b>> {
+    ) -> Result<SlotVerifyData<'b>> {
         let bytes: SuffixBytes =
             if let Some(tgt) = boot_target { tgt.suffix().into() } else { Default::default() };
 
-        let requested_partitions = [cstr!("")];
-        let avb_suffix = CStr::from_bytes_until_nul(&bytes)?;
+        let avb_suffix = CStr::from_bytes_until_nul(&bytes).map_err(Error::from)?;
 
-        let verified_data = VerifiedData(
-            (self.verify_slot)(
-                avb_ops,
-                &requested_partitions,
-                Some(avb_suffix),
-                slot_verify_flags,
-                HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO,
-            )
-            .map_err(|v| v.without_verify_data())?,
-        );
-
-        Ok(verified_data)
+        Ok(avb::slot_verify(
+            avb_ops,
+            partitions_to_verify,
+            Some(avb_suffix),
+            slot_verify_flags,
+            HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO,
+        )
+        .map_err(|v| v.without_verify_data())?)
     }
 
     /// Load Slot Manager Interface
@@ -248,14 +230,12 @@ where
     ///
     /// * `Ok(Cursor)` - Cursor object that manages a Manager
     /// * `Err(Error)` - on failure
-    pub fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice, M: Manager>(
-        &mut self,
-        block_device: &'b mut B,
-    ) -> Result<Cursor<'b, B, M>> {
-        let boot_token = BOOT_TOKEN.lock().take().ok_or(Error::OperationProhibited)?;
-        self.ops
-            .load_slot_interface::<B, M>(block_device, boot_token)
-            .map_err(|_| Error::OperationProhibited.into())
+    pub fn load_slot_interface<B: gbl_storage::AsBlockDevice>(
+        &'a mut self,
+        block_device: &'a mut B,
+    ) -> Result<Cursor<'a, B>> {
+        let boot_token = self.boot_token.take().ok_or(Error::OperationProhibited)?;
+        self.ops.load_slot_interface::<B>(block_device, boot_token)
     }
 
     /// Info Load
@@ -384,19 +364,18 @@ where
     ///          Callers MAY log the error, enter an interactive mode,
     ///          or take other actions before rebooting.
     ///
-    ///
     /// # Arguments
-    ///   * `avb_ops` - implementation for `avb::Ops` that would be borrowed in result to prevent
+    /// * `avb_ops` - implementation for `avb::Ops` that would be borrowed in result to prevent
     ///   changes to partitions until it is out of scope.
-    ///   * `partitions_ram_map` - Partitions to verify and optional address for them to be loaded.
-    ///   * `slot_verify_flags` - AVB slot verification flags
-    ///   * `slot_cursor` - Cursor object that manages interactions with boot slot management
-    ///   * `kernel_load_buffer` - Buffer for loading the kernel.
-    ///   * `ramdisk_load_buffer` - Buffer for loading the ramdisk.
-    ///   * `fdt` - Buffer containing a flattened device tree blob.
+    /// * `partitions_to_verify` - names of all the partitions to verify with libavb.
+    /// * `partitions_ram_map` - Partitions to verify and optional address for them to be loaded.
+    /// * `slot_verify_flags` - AVB slot verification flags
+    /// * `slot_cursor` - Cursor object that manages interactions with boot slot management
+    /// * `kernel_load_buffer` - Buffer for loading the kernel.
+    /// * `ramdisk_load_buffer` - Buffer for loading the ramdisk.
+    /// * `fdt` - Buffer containing a flattened device tree blob.
     ///
     /// # Returns
-    ///
     /// * doesn't return on success
     /// * `Err(Error)` - on failure
     // Nevertype could be used here when it is stable https://github.com/serde-rs/serde/issues/812
@@ -404,9 +383,10 @@ where
     pub fn load_verify_boot<'b: 'c, 'c, 'd: 'b, B: gbl_storage::AsBlockDevice>(
         &mut self,
         avb_ops: &mut impl avb::Ops<'b>,
+        partitions_to_verify: &[&CStr],
         partitions_ram_map: &'d mut [PartitionRamMap<'b, 'c>],
         slot_verify_flags: SlotVerifyFlags,
-        slot_cursor: Cursor<B, impl Manager>,
+        slot_cursor: Cursor<B>,
         kernel_load_buffer: &mut [u8],
         ramdisk_load_buffer: &mut [u8],
         fdt: &mut [u8],
@@ -421,6 +401,7 @@ where
             avb_ops,
             &mut ramdisk,
             kernel_load_buffer,
+            partitions_to_verify,
             partitions_ram_map,
             slot_verify_flags,
             slot_cursor,
@@ -453,9 +434,10 @@ where
         avb_ops: &mut impl avb::Ops<'b>,
         ramdisk: &mut Ramdisk,
         kernel_load_buffer: &'e mut [u8],
+        partitions_to_verify: &[&CStr],
         partitions_ram_map: &'d mut [PartitionRamMap<'b, 'c>],
         slot_verify_flags: SlotVerifyFlags,
-        mut slot_cursor: Cursor<B, impl Manager>,
+        mut slot_cursor: Cursor<B>,
     ) -> Result<(KernelImage<'e>, BootToken)> {
         let mut oneshot_status = slot_cursor.ctx.get_oneshot_status();
         slot_cursor.ctx.clear_oneshot_status();
@@ -463,20 +445,20 @@ where
         if oneshot_status == Some(OneShot::Bootloader) {
             match self.ops.do_fastboot(&mut slot_cursor) {
                 Ok(_) => oneshot_status = slot_cursor.ctx.get_oneshot_status(),
-                Err(IntegrationError::GblNativeError(Error::NotImplemented)) => (),
+                Err(IntegrationError::UnificationError(Error::NotImplemented)) => (),
                 Err(e) => return Err(e),
             }
         }
 
         let boot_target = match oneshot_status {
-            None | Some(OneShot::Bootloader) => slot_cursor.ctx.get_boot_target(),
+            None | Some(OneShot::Bootloader) => slot_cursor.ctx.get_boot_target()?,
             Some(OneShot::Continue(recovery)) => BootTarget::Recovery(recovery),
         };
 
         let mut verify_data = self
             .load_and_verify_image(
                 avb_ops,
-                partitions_ram_map,
+                partitions_to_verify,
                 slot_verify_flags,
                 Some(boot_target),
             )
@@ -513,7 +495,7 @@ where
             &ramdisk.0,
             kernel_load_buffer,
         ]) {
-            return Err(IntegrationError::GblNativeError(Error::BufferOverlap));
+            return Err(IntegrationError::UnificationError(Error::BufferOverlap));
         }
 
         let info_struct = self.unpack_boot_image(&boot_image, Some(boot_target))?;
@@ -533,59 +515,6 @@ where
 
         Ok((kernel_image, token))
     }
-
-    /// Loads and boots a Zircon kernel according to ABR + AVB.
-    pub fn zircon_load_and_boot(&mut self, load_buffer: &mut [u8]) -> Result<()> {
-        let (mut block_devices, load_buffer) = GblUtils::new(self.ops, load_buffer)?;
-        block_devices.sync_gpt_all(&mut |_, _, _| {});
-        // TODO(b/334962583): Implement zircon ABR + AVB.
-        // The following are place holder for test of invocation in the integration test only.
-        let ptn_size = block_devices
-            .find_partition("zircon_a")?
-            .size()
-            .map_err(|e: gbl_storage::StorageError| IntegrationError::StorageError(e))?
-            .try_into()
-            .or(Err(Error::ArithmeticOverflow))?;
-        let (kernel, remains) = load_buffer.split_at_mut(ptn_size);
-        block_devices.read_gpt_partition("zircon_a", 0, kernel)?;
-        self.ops.boot(BootImages::Fuchsia(FuchsiaBootImages {
-            zbi_kernel: kernel,
-            zbi_items: &mut [],
-        }))?;
-        Err(Error::BootFailed.into())
-    }
-}
-
-/// Builder for GBL object
-#[derive(Debug)]
-pub struct GblBuilder<'a, G>
-where
-    G: GblOps,
-{
-    ops: &'a mut G,
-    verify_slot: AvbVerifySlot,
-}
-
-impl<'a, G> GblBuilder<'a, G>
-where
-    G: GblOps,
-{
-    /// Start Gbl object creation, with default GblOps implementation
-    pub fn new(ops: &'a mut G) -> Self {
-        GblBuilder { ops, verify_slot: avb::slot_verify }
-    }
-
-    // Override [avb::slot_verify] for testing only
-    #[cfg(test)]
-    fn verify_slot(mut self, verify_slot: AvbVerifySlot) -> Self {
-        self.verify_slot = verify_slot;
-        self
-    }
-
-    /// Finish Gbl object construction and return it as the result
-    pub fn build(self) -> Gbl<'a, G> {
-        Gbl { ops: self.ops, verify_slot: self.verify_slot }
-    }
 }
 
 #[cfg(test)]
@@ -593,75 +522,25 @@ mod tests {
     extern crate avb_sysdeps;
     extern crate avb_test;
     use super::*;
-    use avb::IoError;
-    use avb::IoResult as AvbIoResult;
-    use avb::PublicKeyForPartitionInfo;
+    use crate::ops::test::FakeGblOps;
+    use avb::{CertPermanentAttributes, SlotVerifyError};
     use avb_test::{FakeVbmetaKey, TestOps};
     use std::{fs, path::Path};
-
-    struct AvbOpsUnimplemented {}
-    impl avb::Ops<'_> for AvbOpsUnimplemented {
-        fn validate_vbmeta_public_key(&mut self, _: &[u8], _: Option<&[u8]>) -> AvbIoResult<bool> {
-            Err(IoError::NotImplemented)
-        }
-        fn read_from_partition(&mut self, _: &CStr, _: i64, _: &mut [u8]) -> AvbIoResult<usize> {
-            Err(IoError::NotImplemented)
-        }
-        fn read_rollback_index(&mut self, _: usize) -> AvbIoResult<u64> {
-            Err(IoError::NotImplemented)
-        }
-        fn write_rollback_index(&mut self, _: usize, _: u64) -> AvbIoResult<()> {
-            Err(IoError::NotImplemented)
-        }
-        fn read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-            Err(IoError::NotImplemented)
-        }
-        #[cfg(feature = "uuid")]
-        fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> AvbIoResult<uuid::Uuid> {
-            Err(IoError::NotImplemented)
-        }
-        fn get_size_of_partition(&mut self, partition: &CStr) -> AvbIoResult<u64> {
-            Err(IoError::NotImplemented)
-        }
-        fn read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize> {
-            Err(IoError::NotImplemented)
-        }
-        fn write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()> {
-            Err(IoError::NotImplemented)
-        }
-        fn erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()> {
-            Err(IoError::NotImplemented)
-        }
-        fn validate_public_key_for_partition(
-            &mut self,
-            partition: &CStr,
-            public_key: &[u8],
-            public_key_metadata: Option<&[u8]>,
-        ) -> AvbIoResult<PublicKeyForPartitionInfo> {
-            Err(IoError::NotImplemented)
-        }
-    }
-
-    #[test]
-    fn test_load_and_verify_image_avb_io_error() {
-        let mut gbl_ops = DefaultGblOps {};
-        let mut gbl = GblBuilder::new(&mut gbl_ops).build();
-        let mut avb_ops = AvbOpsUnimplemented {};
-        let mut partitions_ram_map: [PartitionRamMap; 0] = [];
-        let res = gbl.load_and_verify_image(
-            &mut avb_ops,
-            &mut partitions_ram_map,
-            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-            None,
-        );
-        assert_eq!(res.unwrap_err(), IntegrationError::AvbSlotVerifyError(SlotVerifyError::Io));
-    }
+    use zerocopy::FromBytes;
 
     const TEST_ZIRCON_PARTITION_NAME: &str = "zircon_a";
-    const TEST_ZIRCON_IMAGE_PATH: &str = "zircon_a.bin";
+    const TEST_ZIRCON_PARTITION_NAME_CSTR: &CStr = c"zircon_a";
+    const TEST_ZIRCON_IMAGE_PATH: &str = "zircon_a.zbi";
     const TEST_ZIRCON_VBMETA_PATH: &str = "zircon_a.vbmeta";
+    const TEST_ZIRCON_VBMETA_CERT_PATH: &str = "zircon_a.vbmeta.cert";
     const TEST_PUBLIC_KEY_PATH: &str = "testkey_rsa4096_pub.bin";
+    const TEST_PERMANENT_ATTRIBUTES_PATH: &str = "cert_permanent_attributes.bin";
+    const TEST_PERMANENT_ATTRIBUTES_HASH_PATH: &str = "cert_permanent_attributes.hash";
+    const TEST_BAD_PERMANENT_ATTRIBUTES_PATH: &str = "cert_permanent_attributes.bad.bin";
+    const TEST_BAD_PERMANENT_ATTRIBUTES_HASH_PATH: &str = "cert_permanent_attributes.bad.hash";
     const TEST_VBMETA_ROLLBACK_LOCATION: usize = 0; // Default value, we don't explicitly set this.
+    pub const TEST_CERT_PIK_VERSION: u64 = 42;
+    pub const TEST_CERT_PSK_VERSION: u64 = 42;
 
     /// Returns the contents of a test data file.
     ///
@@ -674,10 +553,19 @@ mod tests {
         fs::read(full_path).unwrap()
     }
 
-    #[test]
-    fn test_load_and_verify_image_stub() {
-        let mut gbl_ops = DefaultGblOps {};
-        let mut gbl = GblBuilder::new(&mut gbl_ops).build();
+    /// Creates and returns a configured avb `TestOps`.
+    ///
+    /// The initial state will verify successfully with:
+    /// * a valid vbmeta image in the `vbmeta` partition, containing a hash descriptor for the
+    ///   `TEST_ZIRCON_PARTITION_NAME` partition
+    /// * an image in the `TEST_ZIRCON_PARTITION_NAME` partition matching the vbmeta hash
+    /// * no preloaded partition data
+    /// * a public key matching the vbmeta image
+    /// * a valid vbmeta rollback index
+    /// * a locked bootloader state
+    ///
+    /// The caller can modify any of this state as needed for their particular test.
+    fn test_avb_ops() -> TestOps<'static> {
         let mut avb_ops = TestOps::default();
 
         avb_ops.add_partition(TEST_ZIRCON_PARTITION_NAME, testdata(TEST_ZIRCON_IMAGE_PATH));
@@ -689,10 +577,98 @@ mod tests {
         avb_ops.rollbacks.insert(TEST_VBMETA_ROLLBACK_LOCATION, 0);
         avb_ops.unlock_state = Ok(false);
 
-        let mut partitions_ram_map: [PartitionRamMap; 0] = [];
+        avb_ops
+    }
+
+    /// Similar to `test_avb_ops()`, but with the avb_cert extension enabled.
+    fn test_avb_cert_ops() -> TestOps<'static> {
+        let mut avb_ops = test_avb_ops();
+
+        // Replace vbmeta with the cert-signed version.
+        avb_ops.add_partition("vbmeta", testdata(TEST_ZIRCON_VBMETA_CERT_PATH));
+
+        // Tell `avb_ops` to use cert APIs and to route the default key through cert validation.
+        avb_ops.use_cert = true;
+        avb_ops.default_vbmeta_key = Some(FakeVbmetaKey::Cert);
+
+        // Add the permanent attributes.
+        let perm_attr_bytes = testdata(TEST_PERMANENT_ATTRIBUTES_PATH);
+        let perm_attr_hash = testdata(TEST_PERMANENT_ATTRIBUTES_HASH_PATH);
+        avb_ops.cert_permanent_attributes =
+            Some(CertPermanentAttributes::read_from(&perm_attr_bytes[..]).unwrap());
+        avb_ops.cert_permanent_attributes_hash = Some(perm_attr_hash.try_into().unwrap());
+
+        // Add the rollbacks for the cert keys.
+        avb_ops.rollbacks.insert(avb::CERT_PIK_VERSION_LOCATION, TEST_CERT_PIK_VERSION);
+        avb_ops.rollbacks.insert(avb::CERT_PSK_VERSION_LOCATION, TEST_CERT_PSK_VERSION);
+
+        avb_ops
+    }
+
+    #[test]
+    fn test_load_and_verify_image_success() {
+        let mut gbl_ops = FakeGblOps::default();
+        let mut gbl = Gbl::new(&mut gbl_ops);
+        let mut avb_ops = test_avb_ops();
+
+        let res = gbl.load_and_verify_image(
+            &mut avb_ops,
+            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
+            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
+            None,
+        );
+        assert!(res.is_ok());
+    }
+
+    #[test]
+    fn test_load_and_verify_image_verification_error() {
+        let mut gbl_ops = FakeGblOps::default();
+        let mut gbl = Gbl::new(&mut gbl_ops);
+        let mut avb_ops = test_avb_ops();
+
+        // Modify the kernel image, it should now fail to validate against the vbmeta image.
+        avb_ops.partitions.get_mut(TEST_ZIRCON_PARTITION_NAME).unwrap().contents.as_mut_vec()[0] ^=
+            0x01;
+
         let res = gbl.load_and_verify_image(
             &mut avb_ops,
-            &mut partitions_ram_map,
+            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
+            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
+            None,
+        );
+        assert_eq!(
+            res.unwrap_err(),
+            IntegrationError::AvbSlotVerifyError(SlotVerifyError::Verification(None))
+        );
+    }
+
+    #[test]
+    fn test_load_and_verify_image_io_error() {
+        let mut gbl_ops = FakeGblOps::default();
+        let mut gbl = Gbl::new(&mut gbl_ops);
+        let mut avb_ops = test_avb_ops();
+
+        // Erase the fake rollbacks, which will result in an I/O error when attempting to access.
+        avb_ops.rollbacks.clear();
+
+        let res = gbl.load_and_verify_image(
+            &mut avb_ops,
+            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
+            SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
+            None,
+        );
+        assert_eq!(res.unwrap_err(), IntegrationError::AvbSlotVerifyError(SlotVerifyError::Io));
+    }
+
+    #[test]
+    fn test_load_and_verify_image_with_cert_success() {
+        let mut gbl_ops = FakeGblOps::default();
+        let mut gbl = Gbl::new(&mut gbl_ops);
+        let mut avb_ops = test_avb_cert_ops();
+
+        let res = gbl.load_and_verify_image(
+            &mut avb_ops,
+            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
             SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
             None,
         );
@@ -700,20 +676,28 @@ mod tests {
     }
 
     #[test]
-    fn test_load_and_verify_image_avb_error() {
-        const TEST_ERROR: SlotVerifyError<'static> = SlotVerifyError::Verification(None);
-        let expected_error = SlotVerifyError::Verification(None);
-        let mut gbl_ops = DefaultGblOps {};
-        let mut gbl =
-            GblBuilder::new(&mut gbl_ops).verify_slot(|_, _, _, _, _| Err(TEST_ERROR)).build();
-        let mut avb_ops = AvbOpsUnimplemented {};
-        let mut partitions_ram_map: [PartitionRamMap; 0] = [];
+    fn test_load_and_verify_image_with_cert_permanent_attribute_mismatch_error() {
+        let mut gbl_ops = FakeGblOps::default();
+        let mut gbl = Gbl::new(&mut gbl_ops);
+        let mut avb_ops = test_avb_cert_ops();
+
+        // Swap in the corrupted permanent attributes, which should cause the vbmeta image to fail
+        // validation due to key mismatch.
+        let perm_attr_bytes = testdata(TEST_BAD_PERMANENT_ATTRIBUTES_PATH);
+        let perm_attr_hash = testdata(TEST_BAD_PERMANENT_ATTRIBUTES_HASH_PATH);
+        avb_ops.cert_permanent_attributes =
+            Some(CertPermanentAttributes::read_from(&perm_attr_bytes[..]).unwrap());
+        avb_ops.cert_permanent_attributes_hash = Some(perm_attr_hash.try_into().unwrap());
+
         let res = gbl.load_and_verify_image(
             &mut avb_ops,
-            &mut partitions_ram_map,
+            &mut [&TEST_ZIRCON_PARTITION_NAME_CSTR],
             SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
             None,
         );
-        assert_eq!(res.unwrap_err(), IntegrationError::AvbSlotVerifyError(TEST_ERROR));
+        assert_eq!(
+            res.unwrap_err(),
+            IntegrationError::AvbSlotVerifyError(SlotVerifyError::PublicKeyRejected)
+        );
     }
 }
diff --git a/gbl/libgbl/src/ops.rs b/gbl/libgbl/src/ops.rs
index 20e04c6..f4a9a3c 100644
--- a/gbl/libgbl/src/ops.rs
+++ b/gbl/libgbl/src/ops.rs
@@ -17,43 +17,54 @@
 #[cfg(feature = "alloc")]
 extern crate alloc;
 
-use crate::error::{Error, Result as GblResult};
+pub use crate::image_buffer::ImageBuffer;
+use crate::{
+    error::Result as GblResult,
+    partition::{
+        check_part_unique, read_unique_partition, write_unique_partition, PartitionBlockDevice,
+    },
+};
 #[cfg(feature = "alloc")]
 use alloc::ffi::CString;
-use core::{
-    fmt::{Debug, Write},
-    result::Result,
-};
-use gbl_storage::{
-    required_scratch_size, AsBlockDevice, AsMultiBlockDevices, BlockDevice, BlockIo,
+use core::{fmt::Write, num::NonZeroUsize, result::Result};
+use gbl_async::block_on;
+use gbl_storage::{BlockIoAsync, BlockIoNull};
+
+// Re-exports of types from other dependencies that appear in the APIs of this library.
+pub use avb::{
+    CertPermanentAttributes, IoError as AvbIoError, IoResult as AvbIoResult, SHA256_DIGEST_SIZE,
 };
-use safemath::SafeNum;
+use liberror::Error;
+pub use zbi::ZbiContainer;
 
 use super::slots;
 
 /// `AndroidBootImages` contains references to loaded images for booting Android.
 pub struct AndroidBootImages<'a> {
+    /// Kernel image.
     pub kernel: &'a mut [u8],
+    /// Ramdisk to pass to the kernel.
     pub ramdisk: &'a mut [u8],
+    /// FDT To pass to the kernel.
     pub fdt: &'a mut [u8],
 }
 
 /// `FuchsiaBootImages` contains references to loaded images for booting Zircon.
 pub struct FuchsiaBootImages<'a> {
+    /// Kernel image.
     pub zbi_kernel: &'a mut [u8],
+    /// ZBI container with items to pass to the kernel.
     pub zbi_items: &'a mut [u8],
 }
 
-/// `BootImages` contains images for booting Android/Zircon kernel.
+/// Images required to boot the supported kernels.
 pub enum BootImages<'a> {
+    /// Android boot images.
     Android(AndroidBootImages<'a>),
+    /// Fuchsia boot images.
     Fuchsia(FuchsiaBootImages<'a>),
 }
 
-/// `GblOpsError` is the error type returned by required methods in `GblOps`.
-#[derive(Default, Debug, PartialEq, Eq)]
-pub struct GblOpsError(Option<&'static str>);
-
 // https://stackoverflow.com/questions/41081240/idiomatic-callbacks-in-rust
 // should we use traits for this? or optional/box FnMut?
 //
@@ -63,32 +74,94 @@ missing:
 - key management => atx extension in callback =>  atx_ops: ptr::null_mut(), // support optional ATX.
 */
 /// Trait that defines callbacks that can be provided to Gbl.
-pub trait GblOps {
-    /// Iterates block devices on the platform.
-    ///
-    /// For each block device, implementation should call `f` with its 1) `BlockIo` trait
-    /// implementation, 2) a unique u64 ID and 3) maximum number of gpt entries. If the maximum
-    /// entries is 0, it is considered that the block should not use GPT.
-    ///
-    /// The list of block devices and visit order should remain the same for the life time of the
-    /// object that implements this trait. If this can not be met due to media change, error should
-    /// be returned. Dynamic media change is not supported for now.
-    fn visit_block_devices(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn BlockIo, u64, u64),
-    ) -> Result<(), GblOpsError>;
+pub trait GblOps<'a>
+where
+    Self: 'a,
+{
+    /// Type that implements `BlockIoAsync` for the array of `PartitionBlockDevice` returned by]
+    /// `partitions()`.
+    type PartitionBlockIo: BlockIoAsync = BlockIoNull;
 
-    /// Prints a ASCII character to the platform console.
-    fn console_put_char(&mut self, ch: u8) -> Result<(), GblOpsError>;
+    /// Gets a console for logging messages.
+    fn console_out(&mut self) -> Option<&mut dyn Write>;
+
+    /// The string to use for console line termination with [gbl_println!].
+    ///
+    /// Defaults to "\n" if not overridden.
+    fn console_newline(&self) -> &'static str {
+        "\n"
+    }
 
     /// This method can be used to implement platform specific mechanism for deciding whether boot
     /// should abort and enter Fastboot mode.
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, GblOpsError>;
+    fn should_stop_in_fastboot(&mut self) -> Result<bool, Error>;
 
-    /// Platform specific kernel boot implementation.
+    /// Platform specific processing of boot images before booting.
+    fn preboot(&mut self, boot_images: BootImages) -> Result<(), Error>;
+
+    /// Returns the list of partition block devices.
     ///
-    /// Implementation is not expected to return on success.
-    fn boot(&mut self, boot_images: BootImages) -> Result<(), GblOpsError>;
+    /// Notes that the return slice doesn't capture the life time of `&self`, meaning that the slice
+    /// reference must be producible without borrowing the `GblOps`. This is intended and necessary
+    /// in order to parallelize fastboot flash, download and other commands. For implementation,
+    /// this typically means that the `GblOps` object should hold a reference of the array instead
+    /// of owning it.
+    fn partitions(&self) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>], Error>;
+
+    /// Reads data from a partition.
+    async fn read_from_partition(
+        &mut self,
+        part: &str,
+        off: u64,
+        out: &mut [u8],
+    ) -> Result<(), Error> {
+        read_unique_partition(self.partitions()?, part, off, out).await
+    }
+
+    /// Reads data from a partition synchronously.
+    fn read_from_partition_sync(
+        &mut self,
+        part: &str,
+        off: u64,
+        out: &mut [u8],
+    ) -> Result<(), Error> {
+        block_on(self.read_from_partition(part, off, out))
+    }
+
+    /// Writes data to a partition.
+    async fn write_to_partition(
+        &mut self,
+        part: &str,
+        off: u64,
+        data: &mut [u8],
+    ) -> Result<(), Error> {
+        write_unique_partition(self.partitions()?, part, off, data).await
+    }
+
+    /// Writes data to a partition synchronously.
+    fn write_to_partition_sync(
+        &mut self,
+        part: &str,
+        off: u64,
+        data: &mut [u8],
+    ) -> Result<(), Error> {
+        block_on(self.write_to_partition(part, off, data))
+    }
+
+    /// Returns the size of a partiiton. Returns Ok(None) if partition doesn't exist.
+    fn partition_size(&mut self, part: &str) -> Result<Option<u64>, Error> {
+        match check_part_unique(self.partitions()?, part) {
+            Ok((_, p)) => Ok(Some(p.size()?)),
+            Err(Error::NotFound) => Ok(None),
+            Err(e) => Err(e),
+        }
+    }
+
+    /// Adds device specific ZBI items to the given `container`
+    fn zircon_add_device_zbi_items(
+        &mut self,
+        container: &mut ZbiContainer<&mut [u8]>,
+    ) -> Result<(), Error>;
 
     // TODO(b/334962570): figure out how to plumb ops-provided hash implementations into
     // libavb. The tricky part is that libavb hashing APIs are global with no way to directly
@@ -102,116 +175,302 @@ pub trait GblOps {
     // Nevertype could be used here when it is stable https://github.com/serde-rs/serde/issues/812
     fn do_fastboot<B: gbl_storage::AsBlockDevice>(
         &self,
-        cursor: &mut slots::Cursor<B, impl slots::Manager>,
-    ) -> GblResult<()> {
-        Err(Error::NotImplemented.into())
-    }
-
-    /// TODO: b/312607649 - placeholder interface for Gbl specific callbacks that uses alloc.
-    #[cfg(feature = "alloc")]
-    fn gbl_alloc_extra_action(&mut self, s: &str) -> GblResult<()> {
-        let _c_string = CString::new(s);
-        Err(Error::NotImplemented.into())
-    }
+        cursor: &mut slots::Cursor<B>,
+    ) -> GblResult<()>;
 
     /// Load and initialize a slot manager and return a cursor over the manager on success.
-    fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice, M: slots::Manager>(
-        &mut self,
+    fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+        &'b mut self,
         block_device: &'b mut B,
         boot_token: slots::BootToken,
-    ) -> GblResult<slots::Cursor<'b, B, M>> {
-        Err(Error::OperationProhibited.into())
-    }
+    ) -> GblResult<slots::Cursor<'b, B>>;
 
-    /// Computes the sum of required scratch size for all block devices.
-    fn required_scratch_size(&mut self) -> GblResult<usize> {
-        let mut total = SafeNum::ZERO;
-        let mut res = Ok(());
-        self.visit_block_devices(&mut |io, id, max_gpt_entries| {
-            res = (|| {
-                total += required_scratch_size(io, max_gpt_entries).unwrap();
-                Ok(())
-            })();
-        })?;
-
-        let total = usize::try_from(total).map_err(|e| e.into());
-        res.and(total)
-    }
-}
+    // The following is a selective subset of the interfaces in `avb::Ops` and `avb::CertOps` needed
+    // by GBL's usage of AVB. The rest of the APIs are either not relevant to or are implemented and
+    // managed by GBL APIs.
 
-/// `GblUtils` takes a reference to `GblOps` and implements various traits.
-pub(crate) struct GblUtils<'a, 'b, T: GblOps> {
-    ops: &'a mut T,
-    scratch: &'b mut [u8],
-}
+    /// Returns if device is in an unlocked state.
+    ///
+    /// The interface has the same requirement as `avb::Ops::read_is_device_unlocked`.
+    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool>;
 
-impl<'a, 'b, T: GblOps> GblUtils<'a, 'b, T> {
-    /// Create a new instance with user provided scratch buffer.
+    /// Reads the AVB rollback index at the given location
     ///
-    /// # Args
+    /// The interface has the same requirement as `avb::Ops::read_rollback_index`.
+    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64>;
+
+    /// Writes the AVB rollback index at the given location.
     ///
-    /// * `ops`: A reference to a `GblOps`,
-    /// * `scratch`: A scratch buffer.
+    /// The interface has the same requirement as `avb::Ops::write_rollback_index`.
+    fn avb_write_rollback_index(
+        &mut self,
+        _rollback_index_location: usize,
+        _index: u64,
+    ) -> AvbIoResult<()>;
+
+    /// Reads AVB certificate extension permanent attributes.
     ///
-    /// # Returns
+    /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes`.
+    fn avb_cert_read_permanent_attributes(
+        &mut self,
+        attributes: &mut CertPermanentAttributes,
+    ) -> AvbIoResult<()>;
+
+    /// Reads AVB certificate extension permanent attributes hash.
     ///
-    /// Returns a new instance and the trailing unused part of the input scratch buffer.
-    pub fn new(ops: &'a mut T, scratch: &'b mut [u8]) -> GblResult<(Self, &'b mut [u8])> {
-        let total_scratch_size = ops.required_scratch_size()?;
-        let (scratch, remaining) = scratch.split_at_mut(total_scratch_size);
-        Ok((Self { ops: ops, scratch: scratch }, remaining))
-    }
-}
+    /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes_hash`.
+    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]>;
 
-impl<T: GblOps> AsMultiBlockDevices for GblUtils<'_, '_, T> {
-    fn for_each(
+    /// Get buffer for specific image of requested size.
+    fn get_image_buffer<'c>(
         &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64),
-    ) -> core::result::Result<(), Option<&'static str>> {
-        let mut scratch_offset = SafeNum::ZERO;
-        self.ops
-            .visit_block_devices(&mut |io, id, max_gpt_entries| {
-                // Not expected to fail as `Self::new()` should have checked any overflow.
-                let scratch_size: usize = required_scratch_size(io, max_gpt_entries).unwrap();
-                let scratch =
-                    &mut self.scratch[scratch_offset.try_into().unwrap()..][..scratch_size];
-                scratch_offset += scratch_size;
-                f(&mut BlockDevice::new(io, scratch, max_gpt_entries), id);
-            })
-            .map_err(|v| v.0)
-    }
+        image_name: &str,
+        size: NonZeroUsize,
+    ) -> GblResult<ImageBuffer<'c>>;
+
+    /// Returns the custom device tree to use, if any.
+    ///
+    /// If this returns a device tree, it will be used instead of any on-disk contents. This is
+    /// currently needed for Cuttlefish, but should not be used in production devices because this
+    /// data cannot be verified with libavb.
+    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]>;
 }
 
-impl<T: GblOps> Write for GblUtils<'_, '_, T> {
-    fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        for ch in s.as_bytes() {
-            self.ops.console_put_char(*ch).map_err(|_| core::fmt::Error {})?;
+/// Prints with `GblOps::console_out()`.
+#[macro_export]
+macro_rules! gbl_print {
+    ( $ops:expr, $( $x:expr ),* $(,)? ) => {
+        {
+            match $ops.console_out() {
+                Some(v) => write!(v, $($x,)*).unwrap(),
+                _ => {}
+            }
         }
-        Ok(())
-    }
+    };
 }
 
-/// Default [GblOps] implementation that returns errors and does nothing.
-#[derive(Debug)]
-pub struct DefaultGblOps {}
+/// Prints the given text plus a newline termination with `GblOps::console_out()`.
+#[macro_export]
+macro_rules! gbl_println {
+    ( $ops:expr, $( $x:expr ),* $(,)? ) => {
+        let newline = $ops.console_newline();
+        gbl_print!($ops, $($x,)*);
+        gbl_print!($ops, "{}", newline);
+    };
+}
 
-impl GblOps for DefaultGblOps {
-    fn visit_block_devices(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn BlockIo, u64, u64),
-    ) -> Result<(), GblOpsError> {
-        Err(GblOpsError(Some("unimplemented")))
+#[cfg(test)]
+pub(crate) mod test {
+    use super::*;
+    use crate::partition::sync_gpt;
+    use avb::{CertOps, Ops};
+    use avb_test::TestOps as AvbTestOps;
+    use gbl_storage_testlib::{TestBlockDevice, TestBlockDeviceBuilder, TestBlockIo};
+    use safemath::SafeNum;
+    use zbi::{ZbiFlags, ZbiType};
+
+    /// Backing storage for [FakeGblOps].
+    ///
+    /// This needs to be a separate object because [GblOps] has designed its lifetimes to borrow
+    /// the [PartitionBlockDevice] objects rather than own it, so that they can outlive the ops
+    /// object when necessary.
+    ///
+    /// # Example usage
+    /// ```
+    /// let storage = FakeGblOpsStorage::default();
+    /// storage.add_gpt_device(&gpt_disk_contents);
+    /// storage.add_raw_device("raw", &raw_disk_contents);
+    ///
+    /// let partitions = storage.as_partition_block_devices();
+    /// let fake_ops = FakeGblOps(&partitions);
+    /// ```
+    #[derive(Default)]
+    pub(crate) struct FakeGblOpsStorage {
+        /// GPT block devices.
+        gpt_devices: Vec<TestBlockDevice>,
+        /// Raw partition block devices.
+        raw_devices: Vec<(&'static str, TestBlockDevice)>,
     }
 
-    fn console_put_char(&mut self, ch: u8) -> Result<(), GblOpsError> {
-        Err(GblOpsError(Some("unimplemented")))
+    impl FakeGblOpsStorage {
+        /// Adds a GPT block device.
+        pub fn add_gpt_device(&mut self, data: impl AsRef<[u8]>) {
+            self.gpt_devices.push(data.as_ref().into())
+        }
+
+        /// Adds a raw partition block device.
+        pub fn add_raw_device(&mut self, name: &'static str, data: impl AsRef<[u8]>) {
+            self.raw_devices.push((name, data.as_ref().into()))
+        }
+
+        /// Similar to [add_raw_device] but pads `data` with zeros up to the next
+        /// [TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE].
+        pub(crate) fn add_raw_device_padded(&mut self, name: &'static str, mut data: Vec<u8>) {
+            let padded_size = SafeNum::from(data.len())
+                .round_up(TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE)
+                .try_into()
+                .unwrap();
+            data.resize(padded_size, 0);
+            self.add_raw_device(name, data);
+        }
+
+        /// Returns a vector of [PartitionBlockDevice]s wrapping the added devices.
+        pub fn as_partition_block_devices(
+            &mut self,
+        ) -> Vec<PartitionBlockDevice<&mut TestBlockIo>> {
+            let mut parts = Vec::default();
+            // Convert GPT devices.
+            for device in self.gpt_devices.iter_mut() {
+                let (gpt_blk, gpt) = device.as_gpt_dev().into_blk_and_gpt();
+                parts.push(PartitionBlockDevice::new_gpt(gpt_blk, gpt));
+            }
+            // Convert raw devices.
+            for (name, device) in self.raw_devices.iter_mut() {
+                parts.push(PartitionBlockDevice::new_raw(device.as_blk_dev(), name).unwrap());
+            }
+            block_on(sync_gpt(&mut parts[..])).unwrap();
+            parts
+        }
     }
 
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, GblOpsError> {
-        Err(GblOpsError(Some("unimplemented")))
+    /// Fake [GblOps] implementation for testing.
+    #[derive(Default)]
+    pub(crate) struct FakeGblOps<'a> {
+        /// Partition data to expose.
+        pub partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>],
+
+        /// Test fixture for [avb::Ops] and [avb::CertOps], provided by libavb.
+        ///
+        /// We don't use all the available functionality here, in particular the backing storage
+        /// is provided by `partitions` and our custom storage APIs rather than the [AvbTestOps]
+        /// fake storage, so that we can more accurately test our storage implementation.
+        pub avb_ops: AvbTestOps<'static>,
     }
 
-    fn boot(&mut self, boot_images: BootImages) -> Result<(), GblOpsError> {
-        Err(GblOpsError(Some("unimplemented")))
+    /// Print `console_out` output, which can be useful for debugging.
+    impl Write for FakeGblOps<'_> {
+        fn write_str(&mut self, s: &str) -> Result<(), std::fmt::Error> {
+            Ok(print!("{s}"))
+        }
+    }
+
+    impl<'a> FakeGblOps<'a> {
+        /// For now we've just hardcoded the `zircon_add_device_zbi_items()` callback to add a
+        /// single commandline ZBI item with these contents; if necessary we can generalize this
+        /// later and allow tests to configure the ZBI modifications.
+        pub const ADDED_ZBI_COMMANDLINE_CONTENTS: &'static [u8] = b"test_zbi_item";
+
+        pub fn new(partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>]) -> Self {
+            Self { partitions, ..Default::default() }
+        }
+
+        /// Copies an entire partition contents into a vector.
+        ///
+        /// This is a common enough operation in tests that it's worth a small wrapper to provide
+        /// a more convenient API using [Vec].
+        ///
+        /// Panics if the given partition name doesn't exist.
+        pub fn copy_partition(&mut self, name: &str) -> Vec<u8> {
+            let mut contents =
+                vec![0u8; self.partition_size(name).unwrap().unwrap().try_into().unwrap()];
+            assert!(self.read_from_partition_sync(name, 0, &mut contents[..]).is_ok());
+            contents
+        }
+    }
+
+    impl<'a> GblOps<'a> for FakeGblOps<'a>
+    where
+        Self: 'a,
+    {
+        type PartitionBlockIo = &'a mut TestBlockIo;
+
+        fn console_out(&mut self) -> Option<&mut dyn Write> {
+            Some(self)
+        }
+
+        fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
+            unimplemented!();
+        }
+
+        fn preboot(&mut self, boot_images: BootImages) -> Result<(), Error> {
+            unimplemented!();
+        }
+
+        fn partitions(
+            &self,
+        ) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>], Error> {
+            Ok(self.partitions)
+        }
+
+        fn zircon_add_device_zbi_items(
+            &mut self,
+            container: &mut ZbiContainer<&mut [u8]>,
+        ) -> Result<(), Error> {
+            container
+                .create_entry_with_payload(
+                    ZbiType::CmdLine,
+                    0,
+                    ZbiFlags::default(),
+                    Self::ADDED_ZBI_COMMANDLINE_CONTENTS,
+                )
+                .unwrap();
+            Ok(())
+        }
+
+        fn do_fastboot<B: gbl_storage::AsBlockDevice>(
+            &self,
+            cursor: &mut slots::Cursor<B>,
+        ) -> GblResult<()> {
+            unimplemented!();
+        }
+
+        fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+            &'b mut self,
+            block_device: &'b mut B,
+            boot_token: slots::BootToken,
+        ) -> GblResult<slots::Cursor<'b, B>> {
+            unimplemented!();
+        }
+
+        fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
+            self.avb_ops.read_is_device_unlocked()
+        }
+
+        fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
+            self.avb_ops.read_rollback_index(rollback_index_location)
+        }
+
+        fn avb_write_rollback_index(
+            &mut self,
+            rollback_index_location: usize,
+            index: u64,
+        ) -> AvbIoResult<()> {
+            self.avb_ops.write_rollback_index(rollback_index_location, index)
+        }
+
+        fn avb_cert_read_permanent_attributes(
+            &mut self,
+            attributes: &mut CertPermanentAttributes,
+        ) -> AvbIoResult<()> {
+            self.avb_ops.read_permanent_attributes(attributes)
+        }
+
+        fn avb_cert_read_permanent_attributes_hash(
+            &mut self,
+        ) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
+            self.avb_ops.read_permanent_attributes_hash()
+        }
+
+        fn get_image_buffer<'c>(
+            &mut self,
+            image_name: &str,
+            size: NonZeroUsize,
+        ) -> GblResult<ImageBuffer<'c>> {
+            unimplemented!();
+        }
+
+        fn get_custom_device_tree(&mut self) -> Option<&'static [u8]> {
+            None
+        }
     }
 }
diff --git a/gbl/libgbl/src/partition.rs b/gbl/libgbl/src/partition.rs
new file mode 100644
index 0000000..c411658
--- /dev/null
+++ b/gbl/libgbl/src/partition.rs
@@ -0,0 +1,784 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file implements storage and partition logic for libgbl.
+
+use crate::fastboot::sparse::{is_sparse_image, write_sparse_image, SparseRawWriter};
+use core::mem::swap;
+use fastboot::CommandError;
+use gbl_async::yield_now;
+use gbl_storage::{AsyncBlockDevice, BlockInfo, BlockIoAsync, GptCache, Partition as GptPartition};
+use liberror::Error;
+use safemath::SafeNum;
+use spin::mutex::{Mutex, MutexGuard};
+
+/// Represents a GBL partition.
+#[derive(Copy, Clone, PartialEq, Debug)]
+pub enum Partition<'a> {
+    /// Raw storage partition.
+    Raw(&'a str, u64),
+    /// Gpt Partition.
+    Gpt(GptPartition),
+}
+
+impl Partition<'_> {
+    /// Returns the size.
+    pub fn size(&self) -> Result<u64, Error> {
+        let (start, end) = self.absolute_range()?;
+        Ok((SafeNum::from(end) - start).try_into()?)
+    }
+
+    /// Returns the name.
+    pub fn name(&self) -> Result<&str, Error> {
+        Ok(match self {
+            Partition::Gpt(gpt) => gpt.name().ok_or(Error::InvalidInput)?,
+            Partition::Raw(name, _) => name,
+        })
+    }
+
+    /// Computes the absolute start and end offset for the partition in the whole block device.
+    pub fn absolute_range(&self) -> Result<(u64, u64), Error> {
+        Ok(match self {
+            Partition::Gpt(gpt) => gpt.absolute_range()?,
+            Partition::Raw(_, size) => (0, *size),
+        })
+    }
+}
+
+/// Represents the partition table for a block device. It can either be a GPT partition table or a
+/// single whole device raw partition.
+enum PartitionTable<'a> {
+    Raw(&'a str, u64),
+    Gpt(GptCache<'a>),
+}
+
+/// Internal partition entry iterator type.
+enum PartitionIter<'a, G> {
+    /// Raw partition block device is simply a 1-partition device.
+    Raw(Option<Partition<'a>>),
+    /// Gpt partition block device holds a `GptPartition` iterator.
+    Gpt(G),
+}
+
+impl<'a, G: Iterator<Item = GptPartition>> Iterator for PartitionIter<'a, G> {
+    type Item = Partition<'a>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        match self {
+            PartitionIter::Raw(part) => part.take(),
+            PartitionIter::Gpt(gpt) => gpt.next().map(|v| Partition::Gpt(v)),
+        }
+    }
+}
+
+/// The status of block device
+pub enum BlockStatus {
+    /// Idle,
+    Idle,
+    /// An IO in progress.
+    Pending,
+    /// Error.
+    Error,
+}
+
+impl BlockStatus {
+    /// Converts to str.
+    pub fn to_str(&self) -> &'static str {
+        match self {
+            BlockStatus::Idle => "idle",
+            BlockStatus::Pending => "IO pending",
+            BlockStatus::Error => "error",
+        }
+    }
+}
+
+/// Represents a block device that contains either GPT partitions or a single whole raw storage
+/// partition.
+pub struct PartitionBlockDevice<'a, B: BlockIoAsync> {
+    // Contains an `AsyncBlockDevice` for block IO and `Result` to track the most recent error.
+    // Wraps in `Mutex` as it will be used in parallel fastboot task.
+    blk: Mutex<(AsyncBlockDevice<'a, B>, Result<(), Error>)>,
+    partitions: PartitionTable<'a>,
+    info_cache: BlockInfo,
+}
+
+impl<'a, B: BlockIoAsync> PartitionBlockDevice<'a, B> {
+    /// Creates a new instance as a GPT device.
+    pub fn new_gpt(mut blk: AsyncBlockDevice<'a, B>, gpt: GptCache<'a>) -> Self {
+        let info_cache = blk.io().info();
+        Self { blk: (blk, Ok(())).into(), info_cache, partitions: PartitionTable::Gpt(gpt) }
+    }
+
+    /// Creates a new instance as a raw storage partition.
+    pub fn new_raw(mut blk: AsyncBlockDevice<'a, B>, name: &'a str) -> Result<Self, Error> {
+        let info_cache = blk.io().info();
+        Ok(Self {
+            blk: (blk, Ok(())).into(),
+            info_cache,
+            partitions: PartitionTable::Raw(name, info_cache.total_size()?),
+        })
+    }
+
+    /// Gets the cached `BlockInfo`.
+    pub fn block_info(&self) -> BlockInfo {
+        self.info_cache
+    }
+
+    /// Gets the block status.
+    pub fn status(&self) -> BlockStatus {
+        match self.blk.try_lock() {
+            None => BlockStatus::Pending,
+            Some(v) if v.1.is_err() => BlockStatus::Error,
+            _ => BlockStatus::Idle,
+        }
+    }
+
+    /// Gets an instance of `PartitionIo` for a partition.
+    ///
+    /// If `part` is `None`, an IO for the whole block device is returned.
+    pub fn partition_io(&self, part: Option<&str>) -> Result<PartitionIo<'a, '_, B>, Error> {
+        let (part_start, part_end) = self.find_partition(part)?.absolute_range()?;
+        Ok(PartitionIo { blk: self.blk.try_lock().ok_or(Error::NotReady)?, part_start, part_end })
+    }
+
+    /// Same as `partition_io` except that the method will spin wait asynchronously if the IO is not
+    /// ready.
+    pub async fn wait_partition_io(
+        &self,
+        part: Option<&str>,
+    ) -> Result<PartitionIo<'a, '_, B>, Error> {
+        loop {
+            match self.partition_io(part) {
+                Err(Error::NotReady) => yield_now().await,
+                v => return v,
+            }
+        }
+    }
+
+    /// Finds a partition.
+    ///
+    /// * If `part` is none, the method returns an unnamed `Partition` that represents the whole
+    //    raw storage.
+    pub fn find_partition(&self, part: Option<&str>) -> Result<Partition<'a>, Error> {
+        let Some(part) = part else {
+            return Ok(Partition::Raw("", self.info_cache.total_size()?));
+        };
+
+        match &self.partitions {
+            PartitionTable::Gpt(gpt) => Ok(Partition::Gpt(gpt.find_partition(part)?)),
+            PartitionTable::Raw(name, size) if *name == part => Ok(Partition::Raw(name, *size)),
+            _ => Err(Error::NotFound),
+        }
+    }
+
+    /// Gets an iterator to partition entries.
+    pub fn partition_iter(&self) -> impl Iterator<Item = Partition<'a>> + '_ {
+        match &self.partitions {
+            PartitionTable::Gpt(gpt) => PartitionIter::Gpt(gpt.partition_iter()),
+            PartitionTable::Raw(name, size) => {
+                PartitionIter::Raw(Some(Partition::Raw(name, *size)))
+            }
+        }
+    }
+
+    /// Syncs GPT if the partition type is GPT.
+    ///
+    /// # Returns
+    ///
+    /// * Returns `Ok(true)` if partition type is GPT and sync is successful.
+    /// * Returns `Ok(false)` if partition type is not GPT.
+    /// * Returns `Err` in other cases.
+    pub async fn sync_gpt(&mut self) -> Result<bool, Error> {
+        match &mut self.partitions {
+            PartitionTable::Raw(name, _) => Ok(false),
+            PartitionTable::Gpt(ref mut gpt) => {
+                let mut blk = self.blk.try_lock().ok_or(Error::NotReady)?;
+                blk.0.sync_gpt(gpt).await?;
+                Ok(true)
+            }
+        }
+    }
+}
+
+/// `PartitionIo` provides read/write APIs to a partition.
+pub struct PartitionIo<'a, 'b, B: BlockIoAsync> {
+    blk: MutexGuard<'b, (AsyncBlockDevice<'a, B>, Result<(), Error>)>,
+    part_start: u64,
+    part_end: u64,
+}
+
+impl<'a, B: BlockIoAsync> PartitionIo<'a, '_, B> {
+    /// Returns the size of the partition.
+    pub fn size(&self) -> u64 {
+        // Corrects by construction. Should not fail.
+        self.part_end.checked_sub(self.part_start).unwrap()
+    }
+
+    /// Gets the block device.
+    pub fn dev(&mut self) -> &mut AsyncBlockDevice<'a, B> {
+        &mut self.blk.0
+    }
+
+    /// Checks the read/write parameters and returns the absolute offset in the block.
+    fn check_rw_range(&self, off: u64, size: impl Into<SafeNum>) -> Result<u64, Error> {
+        let ab_range_end = SafeNum::from(self.part_start) + off + size.into();
+        // Checks overflow by computing the difference between range end and partition end and
+        // making sure it succeeds.
+        let _end_diff: u64 = (SafeNum::from(self.part_end) - ab_range_end).try_into()?;
+        Ok((SafeNum::from(self.part_start) + off).try_into()?)
+    }
+
+    /// A helper to do write for simplifying error handling.
+    async fn do_write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
+        self.check_rw_range(off, data.len()).map(|v| self.blk.0.write(v, data))?.await
+    }
+
+    /// Writes to the partition.
+    pub async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
+        let res = self.do_write(off, data).await;
+        self.blk.1 = res.and(self.blk.1);
+        res
+    }
+
+    /// A helper to do read for simplifying error handling.
+    async fn do_read(&mut self, off: u64, out: &mut [u8]) -> Result<(), Error> {
+        self.check_rw_range(off, out.len()).map(|v| self.blk.0.read(v, out))?.await
+    }
+
+    /// Reads from the partition.
+    pub async fn read(&mut self, off: u64, out: &mut [u8]) -> Result<(), Error> {
+        let res = self.do_read(off, out).await;
+        self.blk.1 = res.and(self.blk.1);
+        res
+    }
+
+    /// A helper to do sparse write for simplifying error handling.
+    async fn do_write_sparse(&mut self, off: u64, img: &mut [u8]) -> Result<(), Error> {
+        let off = self.check_rw_range(
+            off,
+            is_sparse_image(img).map_err(|_| Error::InvalidInput)?.data_size(),
+        )?;
+        write_sparse_image(img, &mut (off, &mut self.blk.0))
+            .await
+            .map_err(|_| "Sparse write failed")?;
+        Ok(())
+    }
+
+    /// Writes sparse image to the partition.
+    pub async fn write_sparse(&mut self, off: u64, img: &mut [u8]) -> Result<(), Error> {
+        let res = self.do_write_sparse(off, img).await;
+        self.blk.1 = res.and(self.blk.1);
+        res
+    }
+
+    /// Turns this IO into one for a subrange in the partition.
+    pub fn sub(self, off: u64, sz: u64) -> Result<Self, Error> {
+        self.check_rw_range(off, sz)?;
+        let mut sub = self;
+        sub.part_start += off;
+        sub.part_end = sub.part_start + sz;
+        Ok(sub)
+    }
+
+    /// Returns the most recent error.
+    pub fn last_err(&self) -> Result<(), Error> {
+        self.blk.1
+    }
+
+    /// Takes the error and resets it.
+    pub fn take_err(&mut self) -> Result<(), Error> {
+        let mut err = Ok(());
+        swap(&mut self.blk.1, &mut err);
+        err
+    }
+}
+
+// Implements `SparseRawWriter` for tuple (<flash offset>, <block device>)
+impl<B: BlockIoAsync> SparseRawWriter for (u64, &mut AsyncBlockDevice<'_, B>) {
+    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError> {
+        Ok(self.1.write((SafeNum::from(off) + self.0).try_into()?, data).await?)
+    }
+}
+
+/// Checks that a partition is unique.
+///
+/// Returns a pair `(<block device index>, `Partition`)` if the partition exists and is unique.
+pub fn check_part_unique<'a>(
+    devs: &[PartitionBlockDevice<'a, impl BlockIoAsync>],
+    part: &str,
+) -> Result<(usize, Partition<'a>), Error> {
+    let mut filtered = devs
+        .iter()
+        .enumerate()
+        .filter_map(|(i, v)| v.find_partition(Some(part)).ok().map(|v| (i, v)));
+    match (filtered.next(), filtered.next()) {
+        (Some(v), None) => Ok(v),
+        (Some(_), Some(_)) => Err(Error::NotUnique),
+        _ => Err(Error::NotFound),
+    }
+}
+
+/// Checks that a partition is unique among all block devices and reads from it.
+pub async fn read_unique_partition(
+    devs: &'_ [PartitionBlockDevice<'_, impl BlockIoAsync>],
+    part: &str,
+    off: u64,
+    out: &mut [u8],
+) -> Result<(), Error> {
+    devs[check_part_unique(devs, part)?.0].partition_io(Some(part))?.read(off, out).await
+}
+
+/// Checks that a partition is unique among all block devices and writes to it.
+pub async fn write_unique_partition(
+    devs: &'_ [PartitionBlockDevice<'_, impl BlockIoAsync>],
+    part: &str,
+    off: u64,
+    data: &mut [u8],
+) -> Result<(), Error> {
+    devs[check_part_unique(devs, part)?.0].partition_io(Some(part))?.write(off, data).await
+}
+
+/// Syncs all GPT type partition devices.
+pub async fn sync_gpt(
+    devs: &'_ mut [PartitionBlockDevice<'_, impl BlockIoAsync>],
+) -> Result<(), Error> {
+    for ele in &mut devs[..] {
+        ele.sync_gpt().await?;
+    }
+    Ok(())
+}
+
+#[cfg(test)]
+pub(crate) mod test {
+    use super::*;
+    use core::fmt::Debug;
+    use gbl_async::block_on;
+    use gbl_storage_testlib::{TestBlockDevice, TestBlockIo};
+
+    /// Absolute start/end offset and size of "boot_a/b" partitions in
+    /// "../../libstorage/test/gpt_test_1.bin"
+    const BOOT_A_OFF: u64 = 17 * 1024;
+    const BOOT_A_END: u64 = 25 * 1024;
+    const BOOT_A_SZ: u64 = BOOT_A_END - BOOT_A_OFF;
+    const BOOT_B_OFF: u64 = 25 * 1024;
+    const BOOT_B_END: u64 = 37 * 1024;
+    const BOOT_B_SZ: u64 = BOOT_B_END - BOOT_B_OFF;
+    /// Total size of disk "../../libstorage/test/gpt_test_1.bin"
+    const GPT_DISK_1_SZ: u64 = 64 * 1024;
+
+    /// A helper to convert an integer into usize and panics on error.
+    fn to_usize(val: impl TryInto<usize, Error = impl Debug>) -> usize {
+        val.try_into().unwrap()
+    }
+
+    /// A helper to convert a `TestBlockDevice` into a raw partition device.
+    pub fn as_raw_part<'a>(
+        test_blk: &'a mut TestBlockDevice,
+        name: &'a str,
+    ) -> PartitionBlockDevice<'a, &'a mut TestBlockIo> {
+        PartitionBlockDevice::new_raw(test_blk.as_blk_dev(), name).unwrap()
+    }
+
+    /// A helper to convert a `TestBlockDevice` into a gpt partition device.
+    pub fn as_gpt_part<'a>(
+        test_blk: &'a mut TestBlockDevice,
+    ) -> PartitionBlockDevice<'a, &'a mut TestBlockIo> {
+        let (gpt_blk, gpt) = test_blk.as_gpt_dev().into_blk_and_gpt();
+        PartitionBlockDevice::new_gpt(gpt_blk, gpt)
+    }
+
+    #[test]
+    fn test_find_partition_gpt() {
+        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        assert!(block_on(gpt.sync_gpt()).unwrap());
+
+        let boot_a = gpt.find_partition(Some("boot_a")).unwrap();
+        assert_eq!(boot_a.name().unwrap(), "boot_a");
+        assert_eq!(boot_a.size().unwrap(), BOOT_A_SZ);
+        assert_eq!(boot_a.absolute_range().unwrap(), (BOOT_A_OFF, BOOT_A_END));
+
+        let boot_b = gpt.find_partition(Some("boot_b")).unwrap();
+        assert_eq!(boot_b.name().unwrap(), "boot_b");
+        assert_eq!(boot_b.size().unwrap(), BOOT_B_SZ);
+        assert_eq!(boot_b.absolute_range().unwrap(), (BOOT_B_OFF, BOOT_B_END));
+
+        let unnamed_whole = gpt.find_partition(None).unwrap();
+        assert_eq!(unnamed_whole.name().unwrap(), "");
+        assert_eq!(unnamed_whole.size().unwrap(), GPT_DISK_1_SZ);
+        assert_eq!(unnamed_whole.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
+
+        assert!(gpt.find_partition(Some("not-exist")).is_err());
+    }
+
+    #[test]
+    fn test_find_partition_raw() {
+        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
+        let mut raw = (&disk[..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+
+        let raw_part = raw.find_partition(Some("raw")).unwrap();
+        assert_eq!(raw_part.name().unwrap(), "raw");
+        assert_eq!(raw_part.size().unwrap(), GPT_DISK_1_SZ);
+        assert_eq!(raw_part.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
+
+        let unnamed_whole = raw.find_partition(None).unwrap();
+        assert_eq!(unnamed_whole.name().unwrap(), "");
+        assert_eq!(unnamed_whole.size().unwrap(), GPT_DISK_1_SZ);
+        assert_eq!(unnamed_whole.absolute_range().unwrap(), (0, GPT_DISK_1_SZ));
+
+        assert!(raw.find_partition(Some("boot_a")).is_err());
+    }
+
+    /// A helper for testing partition read.
+    ///
+    /// Tests that the content read at `off..off+sz` is the same as `part_content[off..off+sz]`.
+    fn test_part_read(
+        blk: &PartitionBlockDevice<impl BlockIoAsync>,
+        part: Option<&str>,
+        part_content: &[u8],
+        off: u64,
+        sz: u64,
+    ) {
+        let mut out = vec![0u8; to_usize(sz)];
+        block_on(blk.partition_io(part).unwrap().read(off, &mut out)).unwrap();
+        assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
+
+        // Reads using the `sub()` and then read approach.
+        let mut out = vec![0u8; to_usize(sz)];
+        let mut io = blk.partition_io(part).unwrap().sub(off, sz).unwrap();
+        block_on(io.read(0, &mut out)).unwrap();
+        assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
+    }
+
+    #[test]
+    fn test_read_partition_gpt() {
+        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
+        let mut gpt = (&disk[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        assert!(block_on(gpt.sync_gpt()).unwrap());
+
+        let expect_boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
+        test_part_read(&gpt, Some("boot_a"), expect_boot_a, 1, 1024);
+        let expect_boot_b = include_bytes!("../../libstorage/test/boot_b.bin");
+        test_part_read(&gpt, Some("boot_b"), expect_boot_b, 1, 1024);
+        // Whole block read.
+        test_part_read(&gpt, None, disk, 1, 1024);
+    }
+
+    #[test]
+    fn test_read_partition_raw() {
+        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
+        let mut raw = (&disk[..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        test_part_read(&raw, Some("raw"), disk, 1, 1024);
+        test_part_read(&raw, None, disk, 1, 1024);
+    }
+
+    /// A helper for testing partition write.
+    fn test_part_write(
+        blk: &PartitionBlockDevice<impl BlockIoAsync>,
+        part: Option<&str>,
+        off: u64,
+        sz: u64,
+    ) {
+        // Reads the current partition content
+        let mut part_content = vec![0u8; to_usize(blk.partition_io(part).unwrap().size())];
+        block_on(blk.partition_io(part).unwrap().read(0, &mut part_content)).unwrap();
+
+        // Flips all the bits in the target range and writes back.
+        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
+        seg.iter_mut().for_each(|v| *v = !(*v));
+        block_on(blk.partition_io(part).unwrap().write(off, seg)).unwrap();
+        // Checks that data is written.
+        test_part_read(blk, part, &part_content, off, sz);
+
+        // Writes using the `sub()` and then write approach.
+        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
+        seg.iter_mut().for_each(|v| *v = !(*v));
+        block_on(blk.partition_io(part).unwrap().sub(off, sz).unwrap().write(0, seg)).unwrap();
+        test_part_read(blk, part, &part_content, off, sz);
+    }
+
+    #[test]
+    fn test_write_partition_gpt() {
+        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        assert!(block_on(gpt.sync_gpt()).unwrap());
+        test_part_write(&gpt, Some("boot_a"), 1, 1024);
+        test_part_write(&gpt, Some("boot_b"), 1, 1024);
+        test_part_write(&gpt, None, 1, 1024);
+    }
+
+    #[test]
+    fn test_write_partition_raw() {
+        let mut raw = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut raw = as_raw_part(&mut raw, "raw");
+        test_part_write(&mut raw, Some("raw"), 1, 1024);
+        test_part_write(&mut raw, None, 1, 1024);
+    }
+
+    #[test]
+    fn test_read_write_partition_overflow() {
+        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
+        let mut gpt = (&disk[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        assert!(block_on(gpt.sync_gpt()).unwrap());
+
+        let mut part_io = gpt.partition_io(Some("boot_a")).unwrap();
+        assert!(block_on(part_io.read(BOOT_A_END, &mut vec![0u8; 1])).is_err());
+        assert!(
+            block_on(part_io.read(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1])).is_err()
+        );
+        assert!(block_on(part_io.write(BOOT_A_END, &mut vec![0u8; 1])).is_err());
+        assert!(
+            block_on(part_io.write(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1])).is_err()
+        );
+
+        let mut raw = (&disk[..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        let mut part_io = raw.partition_io(Some("raw")).unwrap();
+        assert!(block_on(part_io.read(GPT_DISK_1_SZ, &mut vec![0u8; 1])).is_err());
+        assert!(block_on(part_io.read(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1])).is_err());
+        assert!(block_on(part_io.write(GPT_DISK_1_SZ, &mut vec![0u8; 1])).is_err());
+        assert!(block_on(part_io.write(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1])).is_err());
+    }
+
+    #[test]
+    fn test_sub_overflow() {
+        let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
+        let mut gpt = (&disk[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        assert!(block_on(gpt.sync_gpt()).unwrap());
+        assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(0, BOOT_A_SZ + 1).is_err());
+        assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(1, BOOT_A_SZ).is_err());
+
+        let mut raw = (&disk[..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        assert!(raw.partition_io(Some("raw")).unwrap().sub(0, GPT_DISK_1_SZ + 1).is_err());
+        assert!(raw.partition_io(Some("raw")).unwrap().sub(1, GPT_DISK_1_SZ).is_err());
+    }
+
+    #[test]
+    fn test_write_sparse() {
+        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
+        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
+        let raw = &vec![0u8; sparse_raw.len() + 512][..];
+        let mut blk = raw.into();
+        let blk = as_raw_part(&mut blk, "raw");
+        block_on(
+            blk.partition_io(Some("raw"))
+                .unwrap()
+                .sub(1, u64::try_from(raw.len() - 1).unwrap())
+                .unwrap()
+                .write_sparse(1, &mut sparse),
+        )
+        .unwrap();
+        let mut expected = vec![0u8; raw.len()];
+        expected[1 + 1..][..sparse_raw.len()].clone_from_slice(sparse_raw);
+        test_part_read(&blk, Some("raw"), &expected, 1, sparse_raw.len().try_into().unwrap());
+    }
+
+    #[test]
+    fn test_write_sparse_not_sparse_image() {
+        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
+        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
+        sparse[0] = !sparse[0]; // Corrupt image.
+        let mut raw = (&vec![0u8; sparse_raw.len() + 512][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        assert!(
+            block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
+        );
+        assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
+    }
+
+    #[test]
+    fn test_write_sparse_overflow_size() {
+        let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
+        let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
+        let mut raw = (&vec![0u8; sparse_raw.len()][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        assert!(
+            block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
+        );
+        assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
+    }
+
+    #[test]
+    fn test_partiton_last_err_read() {
+        let mut raw = (&vec![0u8; 1024][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        let mut part_io = raw.partition_io(Some("raw")).unwrap();
+        // Causes some error by read
+        assert!(block_on(part_io.read(1024, &mut [0])).is_err());
+        assert!(part_io.last_err().is_err());
+    }
+
+    #[test]
+    fn test_partiton_last_err_write() {
+        let mut raw = (&vec![0u8; 1024][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        let mut part_io = raw.partition_io(Some("raw")).unwrap();
+        // Causes some error by write
+        assert!(block_on(part_io.write(1024, &mut [0])).is_err());
+        assert!(part_io.last_err().is_err());
+    }
+
+    #[test]
+    fn test_partiton_last_err_persist_through_operation() {
+        let mut raw = (&vec![0u8; 1024][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        // Causes some error by read
+        assert!(block_on(raw.partition_io(Some("raw")).unwrap().read(1024, &mut [0])).is_err());
+        // Tracked error should persist regardless of how many times we get partition io.
+        assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
+        assert!(raw.partition_io(None).unwrap().last_err().is_err());
+        // Should persist even after successful operations.
+        block_on(raw.partition_io(Some("raw")).unwrap().read(1023, &mut [0])).unwrap();
+        assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
+        block_on(raw.partition_io(Some("raw")).unwrap().write(1023, &mut [0])).unwrap();
+        assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
+        assert!(raw.partition_io(None).unwrap().last_err().is_err());
+        // Taking error should reset it.
+        assert!(raw.partition_io(None).unwrap().take_err().is_err());
+        assert!(raw.partition_io(None).unwrap().last_err().is_ok());
+    }
+
+    #[test]
+    fn test_partition_iter() {
+        let mut raw = (&vec![0u8; 1024][..]).into();
+        let raw = as_raw_part(&mut raw, "raw");
+        assert_eq!(raw.partition_iter().collect::<Vec<_>>(), [Partition::Raw("raw", 1024)]);
+
+        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt = as_gpt_part(&mut gpt);
+        block_on(gpt.sync_gpt()).unwrap();
+        let actual = gpt.partition_iter().collect::<Vec<_>>();
+        assert_eq!(actual.len(), 2);
+        assert_eq!(actual[0].name().unwrap(), "boot_a");
+        assert_eq!(actual[0].size().unwrap(), 0x2000);
+        assert_eq!(actual[1].name().unwrap(), "boot_b");
+        assert_eq!(actual[1].size().unwrap(), 0x3000);
+    }
+
+    /// A test helper for `read_unique_partition`
+    /// It verifies that data read from partition `part` at offset `off` is the same as
+    /// `part_content[off..off+sz]`.
+    fn check_read_partition(
+        devs: &[PartitionBlockDevice<impl BlockIoAsync>],
+        part: &str,
+        part_content: &[u8],
+        off: u64,
+        sz: u64,
+    ) {
+        let mut out = vec![0u8; to_usize(sz)];
+        block_on(read_unique_partition(devs, part, off, &mut out)).unwrap();
+        assert_eq!(out, part_content[to_usize(off)..][..out.len()]);
+    }
+
+    #[test]
+    fn test_read_unique_partition() {
+        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_2.bin")[..]).into();
+        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
+        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
+        let mut devs = vec![
+            as_gpt_part(&mut gpt_0),
+            as_gpt_part(&mut gpt_1),
+            as_raw_part(&mut raw_0, "raw_0"),
+            as_raw_part(&mut raw_1, "raw_1"),
+        ];
+        block_on(sync_gpt(&mut devs)).unwrap();
+
+        let boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
+        let boot_b = include_bytes!("../../libstorage/test/boot_b.bin");
+
+        let off = 512u64;
+        let sz = 1024u64;
+        check_read_partition(&mut devs, "boot_a", boot_a, off, sz);
+        check_read_partition(&mut devs, "boot_b", boot_b, off, sz);
+
+        let vendor_boot_a = include_bytes!("../../libstorage/test/vendor_boot_a.bin");
+        let vendor_boot_b = include_bytes!("../../libstorage/test/vendor_boot_b.bin");
+
+        check_read_partition(&mut devs, "vendor_boot_a", vendor_boot_a, off, sz);
+        check_read_partition(&mut devs, "vendor_boot_b", vendor_boot_b, off, sz);
+
+        check_read_partition(&mut devs, "raw_0", &[0xaau8; 4 * 1024][..], off, sz);
+        check_read_partition(&mut devs, "raw_1", &[0x55u8; 4 * 1024][..], off, sz);
+    }
+
+    /// A test helper for `write_unique_partition`
+    fn check_write_partition(
+        devs: &[PartitionBlockDevice<impl BlockIoAsync>],
+        part: &str,
+        off: u64,
+        sz: u64,
+    ) {
+        // Reads the current partition content
+        let (_, p) = check_part_unique(devs, part).unwrap();
+        let mut part_content = vec![0u8; to_usize(p.size().unwrap())];
+        block_on(read_unique_partition(devs, part, 0, &mut part_content)).unwrap();
+
+        // Flips all the bits in the target range and writes back.
+        let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
+        seg.iter_mut().for_each(|v| *v = !(*v));
+        block_on(write_unique_partition(devs, part, off, seg)).unwrap();
+        // Checks that data is written.
+        check_read_partition(devs, part, &part_content, off, sz);
+    }
+
+    #[test]
+    fn test_write_unique_partition() {
+        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_2.bin")[..]).into();
+        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
+        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
+        let mut devs = vec![
+            as_gpt_part(&mut gpt_0),
+            as_gpt_part(&mut gpt_1),
+            as_raw_part(&mut raw_0, "raw_0"),
+            as_raw_part(&mut raw_1, "raw_1"),
+        ];
+        block_on(sync_gpt(&mut devs)).unwrap();
+
+        let off = 512u64;
+        let sz = 1024u64;
+        check_write_partition(&mut devs, "boot_a", off, sz);
+        check_write_partition(&mut devs, "boot_b", off, sz);
+        check_write_partition(&mut devs, "vendor_boot_a", off, sz);
+        check_write_partition(&mut devs, "vendor_boot_b", off, sz);
+        check_write_partition(&mut devs, "raw_0", off, sz);
+        check_write_partition(&mut devs, "raw_1", off, sz);
+    }
+
+    #[test]
+    fn test_rw_fail_with_non_unique_partition() {
+        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
+        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
+        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
+        let mut devs = vec![
+            as_gpt_part(&mut gpt_0),
+            as_gpt_part(&mut gpt_1),
+            as_raw_part(&mut raw_0, "raw"),
+            as_raw_part(&mut raw_1, "raw"),
+        ];
+        block_on(sync_gpt(&mut devs)).unwrap();
+        assert!(block_on(read_unique_partition(&devs, "boot_a", 0, &mut [],)).is_err());
+        assert!(block_on(write_unique_partition(&devs, "boot_a", 0, &mut [],)).is_err());
+        assert!(block_on(read_unique_partition(&devs, "raw", 0, &mut [],)).is_err());
+        assert!(block_on(write_unique_partition(&devs, "raw", 0, &mut [],)).is_err());
+    }
+}
diff --git a/gbl/libgbl/src/slots.rs b/gbl/libgbl/src/slots.rs
index ddfa396..c88f380 100644
--- a/gbl/libgbl/src/slots.rs
+++ b/gbl/libgbl/src/slots.rs
@@ -22,6 +22,7 @@ pub mod android;
 pub mod partition;
 
 use core::mem::size_of;
+use liberror::Error;
 
 /// A type safe container for describing the number of retries a slot has left
 /// before it becomes unbootable.
@@ -85,7 +86,15 @@ impl TryFrom<usize> for Suffix {
     type Error = Error;
 
     fn try_from(value: usize) -> Result<Self, Self::Error> {
-        u32::try_from(value).ok().and_then(char::from_u32).ok_or(Error::Other).map(Self)
+        u32::try_from(value).ok().and_then(char::from_u32).ok_or(Error::InvalidInput).map(Self)
+    }
+}
+
+impl TryFrom<u32> for Suffix {
+    type Error = Error;
+
+    fn try_from(value: u32) -> Result<Self, Self::Error> {
+        char::from_u32(value).ok_or(Error::InvalidInput).map(Self)
     }
 }
 
@@ -266,17 +275,6 @@ pub mod private {
     }
 }
 
-/// Custom error type.
-#[derive(Debug, PartialEq, Eq)]
-pub enum Error {
-    /// An API method has attempted an operation on a slot that does not exist.
-    NoSuchSlot(Suffix),
-    /// The backend policy has denied permission for the given operation.
-    OperationProhibited,
-    /// Unspecified error.
-    Other,
-}
-
 /// A helper structure for iterating over slots.
 pub struct SlotIterator<'a> {
     count: usize,
@@ -329,14 +327,15 @@ pub trait Manager: private::SlotGet {
 
     /// Returns the current active slot,
     /// or Recovery if the system will try to boot to recovery.
-    fn get_boot_target(&self) -> BootTarget;
+    fn get_boot_target(&self) -> Result<BootTarget, Error>;
 
     /// Returns the slot last set active.
     /// Note that this is different from get_boot_target in that
     /// the slot last set active cannot be Recovery.
-    fn get_slot_last_set_active(&self) -> Slot {
-        // We can safely assume that we have at least one slot.
-        self.slots_iter().max_by_key(|slot| (slot.priority, slot.suffix.rank())).unwrap()
+    fn get_slot_last_set_active(&self) -> Result<Slot, Error> {
+        self.slots_iter()
+            .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
+            .ok_or(Error::Other(Some("Couldn't get slot last set active")))
     }
 
     /// Updates internal metadata (usually the retry count)
@@ -370,8 +369,8 @@ pub trait Manager: private::SlotGet {
     ) -> Result<(), Error>;
 
     /// Default for initial tries
-    fn get_max_retries(&self) -> Tries {
-        7u8.into()
+    fn get_max_retries(&self) -> Result<Tries, Error> {
+        Ok(7u8.into())
     }
 
     /// Optional oneshot boot support
@@ -406,19 +405,19 @@ pub trait Manager: private::SlotGet {
     /// This is useful for partition based slot setups,
     /// where we do not write back every interaction in order to coalesce writes
     /// and preserve disk lifetime.
-    fn write_back<B: gbl_storage::AsBlockDevice>(&mut self, block_dev: &mut B) {}
+    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {}
 }
 
 /// RAII helper object for coalescing changes.
-pub struct Cursor<'a, B: gbl_storage::AsBlockDevice, M: Manager> {
+pub struct Cursor<'a, B: gbl_storage::AsBlockDevice> {
     /// The backing manager for slot metadata.
-    pub ctx: M,
+    pub ctx: &'a mut dyn Manager,
     /// The backing disk. Used for partition-backed metadata implementations
     /// and for fastboot.
     pub block_dev: &'a mut B,
 }
 
-impl<'a, B: gbl_storage::AsBlockDevice, M: Manager> Drop for Cursor<'a, B, M> {
+impl<'a, B: gbl_storage::AsBlockDevice> Drop for Cursor<'a, B> {
     fn drop(&mut self) {
         self.ctx.write_back(&mut self.block_dev);
     }
diff --git a/gbl/libgbl/src/slots/android.rs b/gbl/libgbl/src/slots/android.rs
index bd6a819..d70faa1 100644
--- a/gbl/libgbl/src/slots/android.rs
+++ b/gbl/libgbl/src/slots/android.rs
@@ -12,10 +12,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::partition::{MetadataBytes, MetadataParseError, SlotBlock};
+use super::partition::{MetadataBytes, SlotBlock};
 use super::{
-    BootTarget, BootToken, Bootability, Error, Manager, OneShot, RecoveryTarget, Slot,
-    SlotIterator, Suffix, UnbootableReason,
+    BootTarget, BootToken, Bootability, Manager, OneShot, RecoveryTarget, Slot, SlotIterator,
+    Suffix, UnbootableReason,
 };
 
 use core::convert::TryInto;
@@ -23,6 +23,7 @@ use core::iter::zip;
 use core::mem::size_of;
 use core::ops::{BitAnd, BitOr, Not, Shl, Shr};
 use crc32fast::Hasher;
+use liberror::Error;
 use zerocopy::byteorder::little_endian::U32 as LittleEndianU32;
 use zerocopy::{AsBytes, ByteSlice, FromBytes, FromZeroes, Ref};
 
@@ -237,18 +238,19 @@ impl Default for BootloaderControl {
 }
 
 impl MetadataBytes for BootloaderControl {
-    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, Self>, MetadataParseError> {
-        let boot_control_data =
-            Ref::<B, Self>::new_from_prefix(buffer).ok_or(MetadataParseError::BufferTooSmall)?.0;
+    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, Self>, Error> {
+        let boot_control_data = Ref::<B, Self>::new_from_prefix(buffer)
+            .ok_or(Error::BufferTooSmall(Some(size_of::<BootloaderControl>())))?
+            .0;
 
         if boot_control_data.magic != BOOT_CTRL_MAGIC {
-            return Err(MetadataParseError::BadMagic);
+            return Err(Error::BadMagic);
         }
         if boot_control_data.version > BOOT_CTRL_VERSION {
-            return Err(MetadataParseError::BadVersion);
+            return Err(Error::UnsupportedVersion);
         }
         if boot_control_data.crc32.get() != boot_control_data.calculate_crc32() {
-            return Err(MetadataParseError::BadChecksum);
+            return Err(Error::BadChecksum);
         }
 
         Ok(boot_control_data)
@@ -267,7 +269,7 @@ impl super::private::SlotGet for SlotBlock<'_, BootloaderControl> {
             // Note: there may be fewer slots than the maximum possible
             .take(control.control_bits.nb_slots().into())
             .nth(number)
-            .ok_or_else(|| Suffix::try_from(number).map_or(Error::Other, Error::NoSuchSlot))?;
+            .ok_or(Error::BadIndex(number))?;
 
         let bootability = match (slot_data.successful(), slot_data.tries()) {
             (true, _) => Bootability::Successful,
@@ -284,15 +286,16 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
         SlotIterator::new(self)
     }
 
-    fn get_boot_target(&self) -> BootTarget {
-        self.slots_iter()
+    fn get_boot_target(&self) -> Result<BootTarget, Error> {
+        Ok(self
+            .slots_iter()
             .filter(Slot::is_bootable)
             .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
             .map_or(
                 // TODO(b/326253270): how is the recovery slot actually determined?
-                BootTarget::Recovery(RecoveryTarget::Slotted(self.get_slot_last_set_active())),
+                BootTarget::Recovery(RecoveryTarget::Slotted(self.get_slot_last_set_active()?)),
                 BootTarget::NormalBoot,
-            )
+            ))
     }
 
     fn set_slot_unbootable(
@@ -304,7 +307,7 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
             .slots_iter()
             .enumerate()
             .find(|(_, slot)| slot.suffix == slot_suffix)
-            .ok_or(Error::NoSuchSlot(slot_suffix))?;
+            .ok_or(Error::InvalidInput)?;
         if slot.bootability == Bootability::Unbootable(reason) {
             return Ok(());
         }
@@ -317,13 +320,11 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
     }
 
     fn mark_boot_attempt(&mut self) -> Result<BootToken, Error> {
-        let target_slot = match self.get_boot_target() {
+        let target_slot = match self.get_boot_target()? {
             BootTarget::NormalBoot(slot) => slot,
             BootTarget::Recovery(RecoveryTarget::Dedicated) => Err(Error::OperationProhibited)?,
             BootTarget::Recovery(RecoveryTarget::Slotted(slot)) => {
-                self.slots_iter()
-                    .find(|s| s.suffix == slot.suffix)
-                    .ok_or(Error::NoSuchSlot(slot.suffix))?;
+                self.slots_iter().find(|s| s.suffix == slot.suffix).ok_or(Error::InvalidInput)?;
                 return self.take_boot_token().ok_or(Error::OperationProhibited);
             }
         };
@@ -332,7 +333,7 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
             .slots_iter()
             .enumerate()
             .find(|(_, slot)| slot.suffix == target_slot.suffix)
-            .ok_or(Error::NoSuchSlot(target_slot.suffix))?;
+            .ok_or(Error::InvalidInput)?;
         match slot.bootability {
             Bootability::Unbootable(_) => Err(Error::OperationProhibited),
             Bootability::Retriable(_) => {
@@ -349,10 +350,8 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
     }
 
     fn set_active_slot(&mut self, slot_suffix: Suffix) -> Result<(), Error> {
-        let idx = self
-            .slots_iter()
-            .position(|s| s.suffix == slot_suffix)
-            .ok_or(Error::NoSuchSlot(slot_suffix))?;
+        let idx =
+            self.slots_iter().position(|s| s.suffix == slot_suffix).ok_or(Error::InvalidInput)?;
 
         let data = self.get_mut_data();
         for (i, slot) in data.slot_metadata.iter_mut().enumerate() {
@@ -377,7 +376,7 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
 
     fn clear_oneshot_status(&mut self) {}
 
-    fn write_back<B: gbl_storage::AsBlockDevice>(&mut self, block_dev: &mut B) {
+    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
         self.sync_to_disk(block_dev)
     }
 }
@@ -394,13 +393,13 @@ mod test {
             .map(|c| Slot {
                 suffix: c.into(),
                 priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries()),
+                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
             })
             .collect();
         let actual: Vec<Slot> = sb.slots_iter().collect();
         assert_eq!(actual, expected);
         assert_eq!(sb.get_oneshot_status(), None);
-        assert_eq!(sb.get_boot_target(), BootTarget::NormalBoot(expected[0]));
+        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(expected[0]));
         // Include the explicit null bytes for safety.
         assert_eq!(sb.get_data().slot_suffix.as_slice(), "_a\0\0".as_bytes());
     }
@@ -414,7 +413,7 @@ mod test {
             .map(|c| Slot {
                 suffix: c.into(),
                 priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries()),
+                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
             })
             .collect();
         let actual: Vec<Slot> = sb.slots_iter().collect();
@@ -446,7 +445,7 @@ mod test {
         let buffer: [u8; 0] = Default::default();
         assert_eq!(
             BootloaderControl::validate(buffer.as_slice()),
-            Err(MetadataParseError::BufferTooSmall)
+            Err(Error::BufferTooSmall(Some(size_of::<BootloaderControl>())))
         );
     }
 
@@ -454,10 +453,7 @@ mod test {
     fn test_slot_block_parse_bad_magic() {
         let mut boot_ctrl: BootloaderControl = Default::default();
         boot_ctrl.magic += 1;
-        assert_eq!(
-            BootloaderControl::validate(boot_ctrl.as_bytes()),
-            Err(MetadataParseError::BadMagic)
-        );
+        assert_eq!(BootloaderControl::validate(boot_ctrl.as_bytes()), Err(Error::BadMagic));
     }
 
     #[test]
@@ -466,7 +462,7 @@ mod test {
         boot_ctrl.version = 15;
         assert_eq!(
             BootloaderControl::validate(boot_ctrl.as_bytes()),
-            Err(MetadataParseError::BadVersion)
+            Err(Error::UnsupportedVersion)
         );
     }
 
@@ -475,10 +471,7 @@ mod test {
         let mut boot_ctrl: BootloaderControl = Default::default();
         let bad_crc = boot_ctrl.crc32.get() ^ LittleEndianU32::MAX_VALUE.get();
         boot_ctrl.crc32 = bad_crc.into();
-        assert_eq!(
-            BootloaderControl::validate(boot_ctrl.as_bytes()),
-            Err(MetadataParseError::BadChecksum)
-        );
+        assert_eq!(BootloaderControl::validate(boot_ctrl.as_bytes()), Err(Error::BadChecksum));
     }
 
     #[test]
@@ -487,7 +480,10 @@ mod test {
         sb.get_mut_data().slot_metadata.iter_mut().for_each(|bits| bits.set_tries(0));
         let a_slot = sb.slots_iter().next().unwrap();
 
-        assert_eq!(sb.get_boot_target(), BootTarget::Recovery(RecoveryTarget::Slotted(a_slot)));
+        assert_eq!(
+            sb.get_boot_target().unwrap(),
+            BootTarget::Recovery(RecoveryTarget::Slotted(a_slot))
+        );
     }
 
     #[test]
@@ -498,7 +494,10 @@ mod test {
         sb.get_mut_data().slot_metadata.iter_mut().for_each(|bits| bits.set_tries(0));
         let b_slot = sb.slots_iter().find(|s| s.suffix == b_suffix).unwrap();
 
-        assert_eq!(sb.get_boot_target(), BootTarget::Recovery(RecoveryTarget::Slotted(b_slot)));
+        assert_eq!(
+            sb.get_boot_target().unwrap(),
+            BootTarget::Recovery(RecoveryTarget::Slotted(b_slot))
+        );
     }
 
     #[test]
@@ -506,12 +505,12 @@ mod test {
         let mut sb: SlotBlock<BootloaderControl> = Default::default();
         let v: Vec<Slot> = sb.slots_iter().collect();
         assert_eq!(sb.set_active_slot(v[1].suffix), Ok(()));
-        assert_eq!(sb.get_slot_last_set_active(), v[1]);
+        assert_eq!(sb.get_slot_last_set_active().unwrap(), v[1]);
         for slot in v.iter() {
             assert_eq!(sb.set_slot_unbootable(slot.suffix, UnbootableReason::NoMoreTries), Ok(()));
         }
 
-        assert_eq!(sb.get_slot_last_set_active(), sb.slots_iter().nth(1).unwrap());
+        assert_eq!(sb.get_slot_last_set_active().unwrap(), sb.slots_iter().nth(1).unwrap());
         assert_eq!(sb.get_data().slot_suffix.as_slice(), "_b\0\0".as_bytes());
     }
 
@@ -573,8 +572,8 @@ mod test {
     #[test]
     fn test_mark_slot_tried_slotted_recovery() {
         let mut sb: SlotBlock<BootloaderControl> = Default::default();
-        sb.set_slot_unbootable('a'.into(), UnbootableReason::UserRequested);
-        sb.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested);
+        assert!(sb.set_slot_unbootable('a'.into(), UnbootableReason::UserRequested).is_ok());
+        assert!(sb.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested).is_ok());
         assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
     }
 
@@ -584,7 +583,7 @@ mod test {
         let oneshots = [
             OneShot::Bootloader,
             OneShot::Continue(RecoveryTarget::Dedicated),
-            OneShot::Continue(RecoveryTarget::Slotted(sb.get_slot_last_set_active())),
+            OneShot::Continue(RecoveryTarget::Slotted(sb.get_slot_last_set_active().unwrap())),
         ];
 
         for oneshot in oneshots {
diff --git a/gbl/libgbl/src/slots/fuchsia.rs b/gbl/libgbl/src/slots/fuchsia.rs
index c86e168..9325120 100644
--- a/gbl/libgbl/src/slots/fuchsia.rs
+++ b/gbl/libgbl/src/slots/fuchsia.rs
@@ -16,15 +16,16 @@ extern crate bitflags;
 extern crate crc32fast;
 extern crate zerocopy;
 
-use super::partition::{MetadataBytes, MetadataParseError, SlotBlock};
+use super::partition::{MetadataBytes, SlotBlock};
 use super::{
-    BootTarget, BootToken, Bootability, Error, Manager, OneShot, RecoveryTarget, Slot,
-    SlotIterator, Suffix, UnbootableReason,
+    BootTarget, BootToken, Bootability, Manager, OneShot, RecoveryTarget, Slot, SlotIterator,
+    Suffix, UnbootableReason,
 };
 use bitflags::bitflags;
 use core::iter::zip;
 use core::mem::size_of;
 use crc32fast::Hasher;
+use liberror::Error;
 use zerocopy::byteorder::big_endian::U32 as BigEndianU32;
 use zerocopy::{AsBytes, ByteSlice, FromBytes, FromZeroes, Ref};
 
@@ -118,18 +119,19 @@ impl AbrData {
 }
 
 impl MetadataBytes for AbrData {
-    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, AbrData>, MetadataParseError> {
-        let abr_data =
-            Ref::<B, AbrData>::new_from_prefix(buffer).ok_or(MetadataParseError::BufferTooSmall)?.0;
+    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, AbrData>, Error> {
+        let abr_data = Ref::<B, AbrData>::new_from_prefix(buffer)
+            .ok_or(Error::BufferTooSmall(Some(size_of::<AbrData>())))?
+            .0;
 
         if abr_data.magic != *ABR_MAGIC {
-            return Err(MetadataParseError::BadMagic);
+            return Err(Error::BadMagic);
         }
         if abr_data.version_major > ABR_VERSION_MAJOR {
-            return Err(MetadataParseError::BadVersion);
+            return Err(Error::UnsupportedVersion);
         }
         if abr_data.crc32.get() != abr_data.calculate_crc32() {
-            return Err(MetadataParseError::BadChecksum);
+            return Err(Error::BadChecksum);
         }
 
         Ok(abr_data)
@@ -163,7 +165,7 @@ impl super::private::SlotGet for SlotBlock<'_, AbrData> {
         let lower_ascii_suffixes = ('a'..='z').map(Suffix);
         let (suffix, &abr_slot) = zip(lower_ascii_suffixes, self.get_data().slot_data.iter())
             .nth(number)
-            .ok_or_else(|| Suffix::try_from(number).map_or(Error::Other, Error::NoSuchSlot))?;
+            .ok_or(Error::BadIndex(number))?;
 
         let bootability = match (abr_slot.successful, abr_slot.tries) {
             (s, _) if s != 0 => Bootability::Successful,
@@ -176,11 +178,12 @@ impl super::private::SlotGet for SlotBlock<'_, AbrData> {
 }
 
 impl Manager for SlotBlock<'_, AbrData> {
-    fn get_boot_target(&self) -> BootTarget {
-        self.slots_iter()
+    fn get_boot_target(&self) -> Result<BootTarget, Error> {
+        Ok(self
+            .slots_iter()
             .filter(Slot::is_bootable)
             .max_by_key(|slot| (slot.priority, slot.suffix.rank()))
-            .map_or(BootTarget::Recovery(RecoveryTarget::Dedicated), BootTarget::NormalBoot)
+            .map_or(BootTarget::Recovery(RecoveryTarget::Dedicated), BootTarget::NormalBoot))
     }
 
     fn slots_iter(&self) -> SlotIterator {
@@ -210,7 +213,7 @@ impl Manager for SlotBlock<'_, AbrData> {
         let target = if let Some(OneShot::Continue(r)) = self.get_oneshot_status() {
             BootTarget::Recovery(r)
         } else {
-            self.get_boot_target()
+            self.get_boot_target()?
         };
         let target_slot = match target {
             BootTarget::NormalBoot(slot) => slot,
@@ -267,10 +270,7 @@ impl Manager for SlotBlock<'_, AbrData> {
 
         let oneshot_flag = OneShotFlags::from(Some(oneshot));
         if oneshot_flag == OneShotFlags::NONE {
-            Err(match oneshot {
-                OneShot::Continue(RecoveryTarget::Slotted(_)) => Error::OperationProhibited,
-                _ => Error::Other,
-            })
+            Err(Error::OperationProhibited)
         } else {
             self.get_mut_data().oneshot_flag = oneshot_flag;
             Ok(())
@@ -283,7 +283,7 @@ impl Manager for SlotBlock<'_, AbrData> {
         }
     }
 
-    fn write_back<B: gbl_storage::AsBlockDevice>(&mut self, block_dev: &mut B) {
+    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
         self.sync_to_disk(block_dev);
     }
 }
@@ -293,7 +293,7 @@ impl<'a> SlotBlock<'a, AbrData> {
         self.slots_iter()
             .enumerate()
             .find(|(_, s)| s.suffix == slot_suffix)
-            .ok_or(Error::NoSuchSlot(slot_suffix))
+            .ok_or(Error::InvalidInput)
     }
 }
 
@@ -311,12 +311,12 @@ mod test {
             Slot {
                 suffix: 'a'.into(),
                 priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries()),
+                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
             },
             Slot {
                 suffix: 'b'.into(),
                 priority: DEFAULT_PRIORITY.into(),
-                bootability: Bootability::Retriable(sb.get_max_retries()),
+                bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
             },
         ];
         let actual: Vec<Slot> = sb.slots_iter().collect();
@@ -341,21 +341,24 @@ mod test {
     #[test]
     fn test_slot_block_parse_buffer_too_small() {
         let buffer: [u8; 0] = Default::default();
-        assert_eq!(AbrData::validate(&buffer[..]), Err(MetadataParseError::BufferTooSmall),);
+        assert_eq!(
+            AbrData::validate(&buffer[..]),
+            Err(Error::BufferTooSmall(Some(size_of::<AbrData>()))),
+        );
     }
 
     #[test]
     fn test_slot_block_parse_bad_magic() {
         let mut abr: AbrData = Default::default();
         abr.magic[0] += 1;
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(MetadataParseError::BadMagic));
+        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::BadMagic));
     }
 
     #[test]
     fn test_slot_block_parse_bad_version_major() {
         let mut abr: AbrData = Default::default();
         abr.version_major = 15;
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(MetadataParseError::BadVersion));
+        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::UnsupportedVersion));
     }
 
     #[test]
@@ -363,7 +366,7 @@ mod test {
         let mut abr: AbrData = Default::default();
         let bad_crc = abr.crc32.get() ^ BigEndianU32::MAX_VALUE.get();
         abr.crc32 = bad_crc.into();
-        assert_eq!(AbrData::validate(abr.as_bytes()), Err(MetadataParseError::BadChecksum));
+        assert_eq!(AbrData::validate(abr.as_bytes()), Err(Error::BadChecksum));
     }
 
     #[test]
@@ -390,7 +393,7 @@ mod test {
 
         assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
         assert_eq!(
-            sb.get_boot_target(),
+            sb.get_boot_target().unwrap(),
             BootTarget::NormalBoot(Slot {
                 suffix: 'b'.into(),
                 priority: DEFAULT_PRIORITY.into(),
@@ -424,7 +427,7 @@ mod test {
             bootability: Bootability::Successful,
         });
         assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
-        assert_eq!(sb.get_boot_target(), target);
+        assert_eq!(sb.get_boot_target().unwrap(), target);
     }
 
     #[test]
@@ -488,7 +491,7 @@ mod test {
                 Ok(())
             );
         }
-        assert_eq!(sb.get_boot_target(), BootTarget::Recovery(RecoveryTarget::Dedicated));
+        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::Recovery(RecoveryTarget::Dedicated));
     }
 
     #[test]
@@ -496,10 +499,10 @@ mod test {
         let mut sb: SlotBlock<AbrData> = Default::default();
         let v: Vec<Slot> = sb.slots_iter().collect();
 
-        assert_eq!(sb.get_boot_target(), BootTarget::NormalBoot(v[0]));
+        assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(v[0]));
         for slot in v.iter() {
             assert_eq!(sb.set_active_slot(slot.suffix), Ok(()));
-            assert_eq!(sb.get_boot_target(), BootTarget::NormalBoot(*slot));
+            assert_eq!(sb.get_boot_target().unwrap(), BootTarget::NormalBoot(*slot));
         }
     }
 
@@ -507,7 +510,7 @@ mod test {
     fn test_set_active_slot_no_such_slot() {
         let mut sb: SlotBlock<AbrData> = Default::default();
         let bad_suffix: Suffix = '$'.into();
-        assert_eq!(sb.set_active_slot(bad_suffix), Err(Error::NoSuchSlot(bad_suffix)));
+        assert_eq!(sb.set_active_slot(bad_suffix), Err(Error::InvalidInput));
     }
 
     #[test]
@@ -515,12 +518,12 @@ mod test {
         let mut sb: SlotBlock<AbrData> = Default::default();
         let v: Vec<Slot> = sb.slots_iter().collect();
         assert_eq!(sb.set_active_slot(v[0].suffix), Ok(()));
-        assert_eq!(sb.get_slot_last_set_active(), v[0]);
+        assert_eq!(sb.get_slot_last_set_active().unwrap(), v[0]);
         for slot in v.iter() {
             assert_eq!(sb.set_slot_unbootable(slot.suffix, NoMoreTries), Ok(()));
         }
 
-        assert_eq!(sb.get_slot_last_set_active(), sb.slots_iter().next().unwrap());
+        assert_eq!(sb.get_slot_last_set_active().unwrap(), sb.slots_iter().next().unwrap());
     }
 
     macro_rules! set_oneshot_tests {
@@ -532,12 +535,12 @@ mod test {
                             assert_eq!(sb.set_oneshot_status($value), Ok(()));
                             assert_eq!(sb.get_oneshot_status(), Some($value));
 
-                            assert_eq!(sb.get_boot_target(),
+                            assert_eq!(sb.get_boot_target().unwrap(),
                                        BootTarget::NormalBoot(
                                            Slot{
                                                suffix: 'a'.into(),
                                                priority: DEFAULT_PRIORITY.into(),
-                                               bootability: Bootability::Retriable(sb.get_max_retries()),
+                                               bootability: Bootability::Retriable(sb.get_max_retries().unwrap()),
                                            },
                                        ));
                         }
@@ -645,7 +648,6 @@ mod test {
             include_bytes!("../../testdata/writeback_test_disk.bin").as_slice().into();
         assert!(block_dev.sync_gpt().is_ok());
         let mut read_buffer: [u8; size_of::<AbrData>()] = Default::default();
-        let mut abr_data;
 
         let mut sb: SlotBlock<AbrData> = Default::default();
         sb.partition = PARTITION;
@@ -653,16 +655,12 @@ mod test {
 
         // New block to trigger drop on the cursor.
         {
-            let mut cursor = Cursor { ctx: sb, block_dev: &mut block_dev };
+            let cursor = Cursor { ctx: &mut sb, block_dev: &mut block_dev };
             assert!(cursor.ctx.set_active_slot('b'.into()).is_ok());
-            abr_data = cursor.ctx.get_data().clone();
         }
 
-        // Need to manually recalculate crc because the cursor updates that
-        // right before writing to disk.
-        abr_data.prepare_for_sync();
         let res = block_dev.read_gpt_partition(PARTITION, OFFSET, &mut read_buffer);
         assert!(res.is_ok());
-        assert_eq!(read_buffer, abr_data.as_bytes());
+        assert_eq!(read_buffer, sb.get_data().as_bytes());
     }
 }
diff --git a/gbl/libgbl/src/slots/partition.rs b/gbl/libgbl/src/slots/partition.rs
index 675b0c9..d10d8fa 100644
--- a/gbl/libgbl/src/slots/partition.rs
+++ b/gbl/libgbl/src/slots/partition.rs
@@ -15,6 +15,8 @@
 use super::BootToken;
 use zerocopy::{AsBytes, ByteSlice, FromBytes, FromZeroes, Ref};
 
+use liberror::Error;
+
 /// Tracks whether slot metadata differs from on-disk representation.
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum CacheStatus {
@@ -24,19 +26,6 @@ pub enum CacheStatus {
     Dirty,
 }
 
-/// Custom error type
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum MetadataParseError {
-    /// The magic number field was corrupted
-    BadMagic,
-    /// The version of the structure is unsupported
-    BadVersion,
-    /// The struct checksum check failed
-    BadChecksum,
-    /// The deserialization buffer is too small
-    BufferTooSmall,
-}
-
 /// Trait that describes the operations all slot metadata implementations must support
 /// to be used as the backing store in a SlotBlock.
 pub trait MetadataBytes: Copy + AsBytes + FromBytes + FromZeroes + Default {
@@ -46,7 +35,7 @@ pub trait MetadataBytes: Copy + AsBytes + FromBytes + FromZeroes + Default {
     /// e.g. checksums, magic numbers, and version numbers.
     ///
     /// Returns Err if the buffer does not represent a valid structure.
-    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, Self>, MetadataParseError>;
+    fn validate<B: ByteSlice>(buffer: B) -> Result<Ref<B, Self>, Error>;
 
     /// Called right before writing metadata back to disk.
     /// Implementors should restore invariants,
@@ -130,7 +119,7 @@ impl<'a, MB: MetadataBytes> SlotBlock<'a, MB> {
     ///
     /// Does NOT write back to disk if no changes have been made and the cache is clean.
     /// Panics if the write attempt fails.
-    pub fn sync_to_disk<BlockDev: gbl_storage::AsBlockDevice>(&mut self, block_dev: &mut BlockDev) {
+    pub fn sync_to_disk(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
         if self.cache_status == CacheStatus::Clean {
             return;
         }
diff --git a/gbl/libgbl/testdata/cert_metadata.bin b/gbl/libgbl/testdata/cert_metadata.bin
new file mode 100644
index 0000000..58666a1
Binary files /dev/null and b/gbl/libgbl/testdata/cert_metadata.bin differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin b/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin
new file mode 100644
index 0000000..c3a78bc
Binary files /dev/null and b/gbl/libgbl/testdata/cert_permanent_attributes.bad.bin differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash b/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash
new file mode 100644
index 0000000..fc86fd3
--- /dev/null
+++ b/gbl/libgbl/testdata/cert_permanent_attributes.bad.hash
@@ -0,0 +1 @@
+#`-0U)~	joZc>MP
\ No newline at end of file
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.bin b/gbl/libgbl/testdata/cert_permanent_attributes.bin
new file mode 100644
index 0000000..51ab594
Binary files /dev/null and b/gbl/libgbl/testdata/cert_permanent_attributes.bin differ
diff --git a/gbl/libgbl/testdata/cert_permanent_attributes.hash b/gbl/libgbl/testdata/cert_permanent_attributes.hash
new file mode 100644
index 0000000..c70ca95
Binary files /dev/null and b/gbl/libgbl/testdata/cert_permanent_attributes.hash differ
diff --git a/gbl/libgbl/testdata/gen_test_data.py b/gbl/libgbl/testdata/gen_test_data.py
index 2718571..ea0589c 100755
--- a/gbl/libgbl/testdata/gen_test_data.py
+++ b/gbl/libgbl/testdata/gen_test_data.py
@@ -15,6 +15,7 @@
 # limitations under the License.
 """Generate test data files for libgbl tests"""
 
+import argparse
 import os
 import pathlib
 import random
@@ -34,7 +35,7 @@ SZ_KB = 1024
 # reproducibility as much as possible; this will prevent adding a bunch of
 # unnecessary test binaries to the git history.
 RNG_SEED_SPARSE_TEST_RAW = 1
-RNG_SEED_ZIRCON = {"a": 2, "b": 3, "r": 4}
+RNG_SEED_ZIRCON = {"a": 2, "b": 3, "r": 4, "slotless": 5}
 
 
 # A helper for writing bytes to a file at a given offset.
@@ -65,7 +66,9 @@ def gen_sparse_test_file():
     # For now this requires that img2simg exists on $PATH.
     # It can be built from an Android checkout via `m img2simg`; the resulting
     # binary will be at out/host/linux-x86/bin/img2simg.
-    subprocess.run(["img2simg", "-s", out_file_raw, SCRIPT_DIR / "sparse_test.bin"])
+    subprocess.run(
+        ["img2simg", "-s", out_file_raw, SCRIPT_DIR / "sparse_test.bin"]
+    )
     subprocess.run(
         [
             "img2simg",
@@ -77,19 +80,106 @@ def gen_sparse_test_file():
     )
 
 
-# Generates GPT disk, kernel data for Zircon tests
-def gen_zircon_gpt():
-    gen_gpt_args = []
-    for suffix in ["a", "b", "r"]:
-        random.seed(RNG_SEED_ZIRCON[suffix])
-        zircon = random.randbytes(16 * SZ_KB)
-        out_file = SCRIPT_DIR / f"zircon_{suffix}.bin"
-        out_file.write_bytes(zircon)
-        gen_gpt_args.append(f"--partition=zircon_{suffix},16K,{str(out_file)}")
+def gen_zircon_test_images(zbi_tool):
+    if not zbi_tool:
+        print(
+            "Warning: ZBI tool not provided. Skip regenerating zircon test images"
+        )
+        return
 
-    subprocess.run(
-        [GPT_TOOL, SCRIPT_DIR / "zircon_gpt.bin", "128K"] + gen_gpt_args, check=True
-    )
+    PSK = AVB_TEST_DATA_DIR / "testkey_cert_psk.pem"
+    ATX_METADATA = AVB_TEST_DATA_DIR / "cert_metadata.bin"
+    TEST_ROLLBACK_INDEX_LOCATION = 1
+    TEST_ROLLBACK_INDEX = 2
+    with tempfile.TemporaryDirectory() as temp_dir:
+        for suffix in ["a", "b", "r", "slotless"]:
+            temp_dir = pathlib.Path(temp_dir)
+            random.seed(RNG_SEED_ZIRCON[suffix])
+            out_kernel_bin_file = temp_dir / f"zircon_{suffix}.bin"
+            # The first 16 bytes are two u64 integers representing `entry` and
+            # `reserve_memory_size`.
+            # Set `entry` value to 2048 and `reserve_memory_size` to 1024.
+            kernel_bytes = int(2048).to_bytes(8, "little") + int(1024).to_bytes(
+                8, "little"
+            )
+            kernel_bytes += random.randbytes(1 * SZ_KB - 16)
+            out_kernel_bin_file.write_bytes(kernel_bytes)
+            out_zbi_file = SCRIPT_DIR / f"zircon_{suffix}.zbi"
+            # Put image in a zbi container.
+            subprocess.run(
+                [
+                    zbi_tool,
+                    "--output",
+                    out_zbi_file,
+                    "--type=KERNEL_X64",
+                    out_kernel_bin_file,
+                ]
+            )
+
+            # Generate vbmeta descriptor.
+            vbmeta_desc = f"{temp_dir}/zircon_{suffix}.vbmeta.desc"
+            subprocess.run(
+                [
+                    AVB_TOOL,
+                    "add_hash_footer",
+                    "--image",
+                    out_zbi_file,
+                    "--partition_name",
+                    "zircon",
+                    "--do_not_append_vbmeta_image",
+                    "--output_vbmeta_image",
+                    vbmeta_desc,
+                    "--partition_size",
+                    "209715200",
+                ]
+            )
+            # Generate two cmdline ZBI items to add as property descriptors to
+            # vbmeta image for test.
+            vbmeta_prop_args = []
+            for i in range(2):
+                prop_zbi_payload = f"{temp_dir}/prop_zbi_payload_{i}.bin"
+                subprocess.run(
+                    [
+                        zbi_tool,
+                        "--output",
+                        prop_zbi_payload,
+                        "--type=CMDLINE",
+                        f"--entry=vb_prop_{i}=val",
+                    ]
+                )
+                vbmeta_prop_args += [
+                    "--prop_from_file",
+                    f"zbi_vb_prop_{i}:{prop_zbi_payload}",
+                ]
+                # Also adds a property where the key name does not starts with
+                # "zbi". The item should not be processed.
+                vbmeta_prop_args += [
+                    "--prop_from_file",
+                    f"vb_prop_{i}:{prop_zbi_payload}",
+                ]
+            # Generate vbmeta image
+            vbmeta_img = SCRIPT_DIR / f"vbmeta_{suffix}.bin"
+            subprocess.run(
+                [
+                    AVB_TOOL,
+                    "make_vbmeta_image",
+                    "--output",
+                    vbmeta_img,
+                    "--key",
+                    PSK,
+                    "--algorithm",
+                    "SHA512_RSA4096",
+                    "--public_key_metadata",
+                    ATX_METADATA,
+                    "--include_descriptors_from_image",
+                    vbmeta_desc,
+                    "--rollback_index",
+                    f"{TEST_ROLLBACK_INDEX}",
+                    "--rollback_index_location",
+                    f"{TEST_ROLLBACK_INDEX_LOCATION}",
+                ]
+                + vbmeta_prop_args
+            )
 
 
 # Generates test data for A/B slot Manager writeback test
@@ -105,12 +195,48 @@ def gen_writeback_test_bin():
     )
 
 
+def sha256_hash(path: pathlib.Path) -> bytes:
+    """Returns the SHA256 hash of the given file."""
+    hash_hex = (
+        subprocess.run(
+            ["sha256sum", path],
+            check=True,
+            capture_output=True,
+            text=True,
+        )
+        .stdout.split()[0]  # output is "<hash> <filename>".
+        .strip()
+    )
+    return bytes.fromhex(hash_hex)
+
+
 def gen_vbmeta():
     """Creates the vbmeta keys and signs some images."""
     # Use the test vbmeta keys from libavb.
-    for name in ["testkey_rsa4096.pem", "testkey_rsa4096_pub.pem"]:
+    for name in [
+        "testkey_rsa4096.pem",
+        "testkey_rsa4096_pub.pem",
+        "testkey_cert_psk.pem",
+        "cert_metadata.bin",
+        "cert_permanent_attributes.bin",
+    ]:
         shutil.copyfile(AVB_TEST_DATA_DIR / name, SCRIPT_DIR / name)
 
+    # We need the permanent attribute SHA256 hash for libavb_cert callbacks.
+    hash_bytes = sha256_hash(SCRIPT_DIR / "cert_permanent_attributes.bin")
+    (SCRIPT_DIR / "cert_permanent_attributes.hash").write_bytes(hash_bytes)
+
+    # Also create a corrupted version of the permanent attributes to test failure.
+    # This is a little bit of a pain but we don't have an easy way to do a SHA256 in Rust
+    # at the moment so we can't generate it on the fly.
+    bad_attrs = bytearray(
+        (SCRIPT_DIR / "cert_permanent_attributes.bin").read_bytes()
+    )
+    bad_attrs[4] ^= 0x01  # Bytes 0-3 = version, byte 4 starts the public key.
+    (SCRIPT_DIR / "cert_permanent_attributes.bad.bin").write_bytes(bad_attrs)
+    hash_bytes = sha256_hash(SCRIPT_DIR / "cert_permanent_attributes.bad.bin")
+    (SCRIPT_DIR / "cert_permanent_attributes.bad.hash").write_bytes(hash_bytes)
+
     # Convert the public key to raw bytes for use in verification.
     subprocess.run(
         [
@@ -139,7 +265,7 @@ def gen_vbmeta():
                 "--partition_name",
                 "zircon_a",
                 "--image",
-                SCRIPT_DIR / "zircon_a.bin",
+                SCRIPT_DIR / "zircon_a.zbi",
                 "--output_vbmeta_image",
                 hash_descriptor_path,
                 "--salt",
@@ -165,9 +291,41 @@ def gen_vbmeta():
             check=True,
         )
 
+        # Also create a vbmeta using the libavb_cert extension.
+        subprocess.run(
+            [
+                AVB_TOOL,
+                "make_vbmeta_image",
+                "--key",
+                SCRIPT_DIR / "testkey_cert_psk.pem",
+                "--public_key_metadata",
+                SCRIPT_DIR / "cert_metadata.bin",
+                "--algorithm",
+                "SHA512_RSA4096",
+                "--include_descriptors_from_image",
+                hash_descriptor_path,
+                "--output",
+                SCRIPT_DIR / "zircon_a.vbmeta.cert",
+            ]
+        )
+
+
+def _parse_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(
+        description=__doc__,
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+    )
+
+    parser.add_argument(
+        "--zbi_tool", default="", help="Path to the Fuchsia ZBI tool"
+    )
+
+    return parser.parse_args()
+
 
 if __name__ == "__main__":
+    args = _parse_args()
     gen_writeback_test_bin()
     gen_sparse_test_file()
-    gen_zircon_gpt()
+    gen_zircon_test_images(args.zbi_tool)
     gen_vbmeta()
diff --git a/gbl/libgbl/testdata/testkey_cert_psk.pem b/gbl/libgbl/testdata/testkey_cert_psk.pem
new file mode 100644
index 0000000..71bfebf
--- /dev/null
+++ b/gbl/libgbl/testdata/testkey_cert_psk.pem
@@ -0,0 +1,52 @@
+-----BEGIN PRIVATE KEY-----
+MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQCy2mHwjC3ylCFF
+dzNkZPKOiZzrUiPawe8OFcTJOySMv0/P4fILDiZuhC1VLwMHquR6kQhvyP9ffeHl
+W3JHliiIFOcS71bxlO1aqVYFt3qF8A/qFVruLjpwh47+WEPfWnCEeX2i8RGpUFh/
+oc2Ey1Dv+BuoHpNUFm2HsJgTe/R1EXadmGfTthvaVfWXb9nW/67YkMEWbH5MZ6BY
+bPXVpA+AN0IoQm+emSj2Ipve0TTGxgX3VQDzA8aTYimAVB+HuOq6p/UxiJu5GCyI
+AhqLsVVHd1qnxCn6eGKcaRACfy6n0mWLn/UXgi2h5hhI3TFGpFSU5ZXB6TfDfYNe
+uzE8njYZloWVrbSy0IascNK9JnQy9/ySy8l5Fw67QByNz9DDCRJJLE78e1ss73Dr
+pjOafwtE6P+koRZe6SbE8NS2v1qiSSoCiBt6lgjOIMR9+KMp7vk8oLEfBBTMc4JR
+4hiZkxPW6j8PYTuiJDs8h7ItZ5awisabbE5URvDc5DscWSE8KbGMa8iXHMJK1Eam
+uko4EIQ/fod5BQ1vpJeS4vPAMqeKMufBHJUcuBkUi0au5Ux8lSNkU0591RfFfmUL
+AodIqtXX39yHMN7SQqQAfAibdcDWmujN9F/Js4OHCWuhj1q6VUhSEEEqtDeX01sH
+xlghCFg8lNO5GeDG5SDyGsdxY+iObQIDAQABAoICAEQwEkr9hr8HTrAHRCawffFt
+8c+d32GVsqhyEDaQP90RS0J8aCVi3bAg4I+rfsI7myRHiynjPcmQWsFw3d8BFq7b
+GUYUzdcI6n04Nj2zuBi8b7TVM3e/VDR22kOKL0ZGWsOG9ilbM1qT8UmnzI0mXtM+
+inzMO2tBqbyjzTcQeSDw6YIoCt2ifnf9ccastCbOEEEs3xDHiFdk4rMTx54OEILX
+jnd+7MNQrVc51qdap35pHPkxBU2hUOH7+MqeR+8cxxEm28poxMYKu1+XPbuoflTi
+4kM3/LErmJz9SUdKaeU9x801zOGLlg41hWiyPAksubqS1Ue6vLHhdmZ1g84Sm5j+
+lABJXRBnc1YG/nyJZlFvMhp7gCXVDYQ4nUT4y2Ozd7ip9BweBzVoXQSMvjWfQvvb
+fzqJS0dNKqMQQU78x+B1g8iNgL9PCCkEeFN1YZwkJQMfQLdv+fgP9GEHlE/zz1Sv
+lZNpve0CARWZUg0Nbw1w9fsbeezJpCntZMs4wVMS0Vyn9TmFAEielILmmW/tkUyR
+WpZI7l4AYX4Rzx+nnVVwrSO9UDqp+2aiOODXpL3RboFi8qbblZWvNy7/mSKSKxwv
+E7Z7a8qMcaFsOy7LKSsbheZNWyyhQlfe3yNeYKMDj3rFmooNpJd0hU2kqt1fZKQK
+SIyutcEHQFP/p1LP1X9ZAoIBAQDdNg0o3FdYySCYTc5N6T+SUai8FyOlUhXvh7wn
+m28QmC8YBafjUAPXQYJYKiKtyb1/34FSgaBS9kv5nNL5HYxr15HW7aVrFUV3kSnT
+2+yuRrzHiN4B0ZuHlaRHd/fSmuOADM8b/s+CaYeWSWq0qE54uDRSa541OSENxIAq
+9f83rNcg8JF/eYaJQ4bAHzDdjCPS+nSJFtfVmswyoLFZBEeBdyR7zyXPBcLKPSvc
+4BfBbnrrh+boUvw6hgijDopAQVvyzuDECuA7+0Nsx/7M4p0154kxqgmP/ixuamrF
+0Wdx/VOOeXMZ7pEN8hInr4XJ3QEWcxHDl7Yj2Pk8jzduCBQfAoIBAQDO+v9Ax3RH
+E2kw+ce6k1K/u37Foku4EgAMuAHPtlEX0HjbC7t67p8mdqFfOLe3Gka8EFvwpmbr
+af1fWijErCLxv+JtVsQuv2cr4aFBjs+F/NRaNtY4fS5732O7kGML8y1qtLXGi6qS
+bdsdTjhjA2s65tU/lE7g6vJEhAFUtTA9PPZxFQfIv6mFtW0yvdgZcdi3wH7s/NAX
+SVkgxPnBwUpLnJ+NvK6dRt6dxr1d5cp2ghWhryt3FOUVl60e0dbJrykOedl/rWF6
+C3fCQnyWQx8Yzq1Lk/CTfzHln9YIDkyYT0DD6ccNJ2OBECsP0+zMKMfPUBYu2vep
+w3Yh826Hm+vzAoIBAEKBOI2bSOtZdGI1qhuET2d3A2qg7keKmSutPCUQNuDfT/FB
+6gqOCMmTWVOWP1zONRmXoXKjpAatI4RE4KyidJALfD4Irl22RG9BBjk6ejqe66x1
+eoFDeiXWGFCgQbJgfJsHvtBk2BAWF/xX0CvGGelzP8+zqRnJNiXEeN/xmywq23Z8
+vNF9QLRNx9pExlUlB7QrNhPs+TCv3EowQ4FGpxTGNALA8VX/HmPc5i3+dUXjKDNd
+ZU9de5VArKIRAgF1ZOZnye1Gc8m0rb2rlvAUBT2qgXWb8EoJGWSMu9MDNL1xcsh3
+vOID9joiF9E0lN1ugyAzshiCqPC4D55kVD7RUPMCggEBAIzg/GHcIEHMbXm/WXmd
+kuIbvTLJv53+6ne9usXlQxbhd5EoUChhSIQGlNnaIfmH8gNJYzrOGBk94A5JsJwE
+yhgf0f834norHw8YGQklKgz5xJPO5Uo3si7wItLkePYGQ7BwZZVJNQVLrqsotWp3
+RkImIZmP2YxvfgyyiLFeTgIwf1ECznSON9VhYnz6CJ9xBOA1Lm8huIVREFAkohaF
++Iq0hUkU1wkH1rgvMG872+2DpzOQphX8a9yhi10B2J8YEOrgdvDXUxSdv5rCZEhm
+UUEyU3OwszvBhHXVr/l1uh6lOuDeOvSyDaEoHxc72N4xF6b8zMyBj7bF6p87MM0u
+jI8CggEBAIzDR/EGdJEQJrm4ZFbBrWyxYzKQLCTQ3IpKVVzmaSEy6iXegsTfFbVz
+TgHMWh0lUBnokoFSQrPZ5fVng1+AfZOPRToBYLwjVM7mprsmnrjGevJK9VzejOrc
+O9NLOlnBL7lNUjDLl2vfzI3O9kwE0OKgfu/kjHNW4WtssQwexsu8kMLbd5sC1txI
+G4uHedf6AMwty1m4jLC0MAu40N/CGbyQMfQmAG1ozinFuKTUMgN5f3TjdKMdWx6u
+35hLzEgfvrNcu2/Awt6sdmfKPesbKrSBN/5I3NXfFbaI/4aUkjMKqTr2frDt6ZDJ
+PqPOQDQM7f0JPuFGA9kFRaKUQygQckw=
+-----END PRIVATE KEY-----
diff --git a/gbl/libgbl/testdata/vbmeta_a.bin b/gbl/libgbl/testdata/vbmeta_a.bin
new file mode 100644
index 0000000..fd2c81c
Binary files /dev/null and b/gbl/libgbl/testdata/vbmeta_a.bin differ
diff --git a/gbl/libgbl/testdata/vbmeta_b.bin b/gbl/libgbl/testdata/vbmeta_b.bin
new file mode 100644
index 0000000..079e385
Binary files /dev/null and b/gbl/libgbl/testdata/vbmeta_b.bin differ
diff --git a/gbl/libgbl/testdata/vbmeta_r.bin b/gbl/libgbl/testdata/vbmeta_r.bin
new file mode 100644
index 0000000..d9a8f5f
Binary files /dev/null and b/gbl/libgbl/testdata/vbmeta_r.bin differ
diff --git a/gbl/libgbl/testdata/vbmeta_slotless.bin b/gbl/libgbl/testdata/vbmeta_slotless.bin
new file mode 100644
index 0000000..51c7677
Binary files /dev/null and b/gbl/libgbl/testdata/vbmeta_slotless.bin differ
diff --git a/gbl/libgbl/testdata/zircon_a.bin b/gbl/libgbl/testdata/zircon_a.bin
deleted file mode 100644
index 10e7ce4..0000000
Binary files a/gbl/libgbl/testdata/zircon_a.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_a.vbmeta b/gbl/libgbl/testdata/zircon_a.vbmeta
index 13e15d1..f41a0c1 100644
Binary files a/gbl/libgbl/testdata/zircon_a.vbmeta and b/gbl/libgbl/testdata/zircon_a.vbmeta differ
diff --git a/gbl/libgbl/testdata/zircon_a.vbmeta.cert b/gbl/libgbl/testdata/zircon_a.vbmeta.cert
new file mode 100644
index 0000000..e34530e
Binary files /dev/null and b/gbl/libgbl/testdata/zircon_a.vbmeta.cert differ
diff --git a/gbl/libgbl/testdata/zircon_a.zbi b/gbl/libgbl/testdata/zircon_a.zbi
new file mode 100644
index 0000000..1d5b735
Binary files /dev/null and b/gbl/libgbl/testdata/zircon_a.zbi differ
diff --git a/gbl/libgbl/testdata/zircon_b.zbi b/gbl/libgbl/testdata/zircon_b.zbi
new file mode 100644
index 0000000..ff7877b
Binary files /dev/null and b/gbl/libgbl/testdata/zircon_b.zbi differ
diff --git a/gbl/libgbl/testdata/zircon_gpt.bin b/gbl/libgbl/testdata/zircon_gpt.bin
deleted file mode 100644
index f873c07..0000000
Binary files a/gbl/libgbl/testdata/zircon_gpt.bin and /dev/null differ
diff --git a/gbl/libgbl/testdata/zircon_r.zbi b/gbl/libgbl/testdata/zircon_r.zbi
new file mode 100644
index 0000000..bd04d98
Binary files /dev/null and b/gbl/libgbl/testdata/zircon_r.zbi differ
diff --git a/gbl/libgbl/testdata/zircon_slotless.zbi b/gbl/libgbl/testdata/zircon_slotless.zbi
new file mode 100644
index 0000000..6e83f65
Binary files /dev/null and b/gbl/libgbl/testdata/zircon_slotless.zbi differ
diff --git a/gbl/libgbl/tests/integration_tests.rs b/gbl/libgbl/tests/integration_tests.rs
deleted file mode 100644
index ebbdcb4..0000000
--- a/gbl/libgbl/tests/integration_tests.rs
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use gbl_storage::BlockIo;
-use gbl_storage_testlib::TestBlockIo;
-use libgbl::{BootImages, FuchsiaBootImages, GblBuilder, GblOps, GblOpsError};
-use std::{collections::VecDeque, vec::Vec};
-
-extern crate avb_sysdeps;
-
-struct GblTestBlockIo {
-    io: TestBlockIo,
-    max_gpt_entries: u64,
-}
-
-/// `TestGblOps` provides mock implementation of GblOps for integration test.
-#[derive(Default)]
-struct TestGblOps<'a> {
-    block_io: Vec<GblTestBlockIo>,
-    console_out: VecDeque<u8>,
-    boot_cb: Option<MustUse<&'a mut dyn FnMut(BootImages)>>,
-}
-
-impl TestGblOps<'_> {
-    /// Adds a new block device.
-    pub(crate) fn add_block_device<T: AsRef<[u8]>>(
-        &mut self,
-        alignment: u64,
-        block_size: u64,
-        max_gpt_entries: u64,
-        data: T,
-    ) {
-        self.block_io.push(GblTestBlockIo {
-            io: TestBlockIo::new(alignment, block_size, data.as_ref().into()),
-            max_gpt_entries,
-        })
-    }
-}
-
-impl GblOps for TestGblOps<'_> {
-    fn visit_block_devices(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn BlockIo, u64, u64),
-    ) -> Result<(), GblOpsError> {
-        for (idx, ele) in self.block_io.iter_mut().enumerate() {
-            f(&mut ele.io, idx.try_into().unwrap(), ele.max_gpt_entries);
-        }
-        Ok(())
-    }
-
-    fn console_put_char(&mut self, ch: u8) -> Result<(), GblOpsError> {
-        Ok(self.console_out.push_back(ch))
-    }
-
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, GblOpsError> {
-        Ok(false)
-    }
-
-    fn boot(&mut self, boot_images: BootImages) -> Result<(), GblOpsError> {
-        Ok((self.boot_cb.as_mut().unwrap().get())(boot_images))
-    }
-}
-
-/// `MustUse` wraps an object and checks that it is accessed at least once before it's dropped.
-/// In this integration test, it is mainly used to check that test provided ops callbacks are run.
-struct MustUse<T: ?Sized> {
-    used: bool,
-    val: T,
-}
-
-impl<T: ?Sized> MustUse<T> {
-    /// Create a new instance.
-    fn new(val: T) -> Self
-    where
-        T: Sized,
-    {
-        Self { used: false, val: val }
-    }
-
-    /// Returns a mutable reference to the object.
-    fn get(&mut self) -> &mut T {
-        self.used = true;
-        &mut self.val
-    }
-}
-
-impl<T: ?Sized> Drop for MustUse<T> {
-    fn drop(&mut self) {
-        assert!(self.used)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_zircon_load_and_boot() {
-        // TODO(b/334962583): Invocation test only. Update this test once
-        // `Gbl::zircon_load_and_boot()` is implemented.
-        let mut boot_cb = |boot_images: BootImages| {
-            let BootImages::Fuchsia(FuchsiaBootImages { zbi_kernel, zbi_items }) = boot_images
-            else {
-                panic!("Wrong image type");
-            };
-            assert_eq!(zbi_kernel, include_bytes!("../testdata/zircon_a.bin"));
-            assert_eq!(zbi_items, []);
-        };
-        let mut ops: TestGblOps = Default::default();
-        ops.add_block_device(512, 512, 128, include_bytes!("../testdata/zircon_gpt.bin"));
-        ops.boot_cb = Some(MustUse::new(&mut boot_cb));
-        let mut gbl = GblBuilder::new(&mut ops).build();
-        let mut load_buffer = vec![0u8; 64 * 1024];
-        let _ = gbl.zircon_load_and_boot(&mut load_buffer[..]);
-    }
-}
diff --git a/gbl/libmisc/BUILD b/gbl/libmisc/BUILD
index 65443be..c3af785 100644
--- a/gbl/libmisc/BUILD
+++ b/gbl/libmisc/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 package(
@@ -23,10 +24,15 @@ rust_library(
     srcs = ["src/lib.rs"],
     crate_name = "misc",
     edition = "2021",
-    deps = ["@zerocopy"],
+    rustc_flags = ANDROID_RUST_LINTS,
+    deps = [
+        "@gbl//liberror",
+        "@zerocopy",
+    ],
 )
 
 rust_test(
     name = "libmisc_test",
     crate = ":libmisc",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libmisc/src/lib.rs b/gbl/libmisc/src/lib.rs
index 258a567..7f913fb 100644
--- a/gbl/libmisc/src/lib.rs
+++ b/gbl/libmisc/src/lib.rs
@@ -26,21 +26,17 @@ use core::ffi::CStr;
 
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
-/// Libmisc BCB error type
-#[derive(Debug)]
-pub enum BcbError {
-    InvalidInput(&'static str),
-}
-
-/// Libmisc BCB result type
-pub type Result<T> = core::result::Result<T, BcbError>;
+use liberror::{Error, Result};
 
 /// Android boot modes type
 /// Usually obtained from BCB block of misc partition
 #[derive(PartialEq, Debug)]
 pub enum AndroidBootMode {
+    /// Boot normally using A/B slots.
     Normal = 0,
+    /// Boot into recovery mode using A/B slots.
     Recovery,
+    /// Stop in bootloader fastboot mode.
     BootloaderBootOnce,
 }
 
@@ -75,7 +71,7 @@ impl BootloaderMessage {
     /// Extract BootloaderMessage reference from bytes
     pub fn from_bytes_ref(buffer: &[u8]) -> Result<&BootloaderMessage> {
         Ok(Ref::<_, BootloaderMessage>::new_from_prefix(buffer)
-            .ok_or(BcbError::InvalidInput("Cannot read BCB message from buffer"))?
+            .ok_or(Error::BufferTooSmall(Some(core::mem::size_of::<BootloaderMessage>())))?
             .0
             .into_ref())
     }
@@ -83,15 +79,15 @@ impl BootloaderMessage {
     /// Extract AndroidBootMode from BCB command field
     pub fn boot_mode(&self) -> Result<AndroidBootMode> {
         let command = CStr::from_bytes_until_nul(&self.command)
-            .map_err(|_| BcbError::InvalidInput("Cannot read BCB command"))?
+            .map_err(|_| Error::Other(Some("Cannot read BCB command")))?
             .to_str()
-            .map_err(|_| BcbError::InvalidInput("Cannot convert BCB command to string"))?;
+            .map_err(|_| Error::InvalidInput)?;
 
         match command {
             "" => Ok(AndroidBootMode::Normal),
             "boot-recovery" | "boot-fastboot" => Ok(AndroidBootMode::Recovery),
             "bootonce-bootloader" => Ok(AndroidBootMode::BootloaderBootOnce),
-            _ => Err(BcbError::InvalidInput("Wrong BCB command")),
+            _ => Err(Error::Other(Some("Wrong BCB command"))),
         }
     }
 }
diff --git a/gbl/libsafemath/BUILD b/gbl/libsafemath/BUILD
index ea163f9..7a7bfa1 100644
--- a/gbl/libsafemath/BUILD
+++ b/gbl/libsafemath/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
 rust_library(
@@ -21,10 +22,12 @@ rust_library(
     ],
     crate_name = "safemath",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     visibility = ["//visibility:public"],
 )
 
 rust_test(
     name = "libsafemath_test",
     crate = ":libsafemath",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libsafemath/src/lib.rs b/gbl/libsafemath/src/lib.rs
index 0cdaa7a..cd849f7 100644
--- a/gbl/libsafemath/src/lib.rs
+++ b/gbl/libsafemath/src/lib.rs
@@ -144,9 +144,32 @@ use core::fmt;
 use core::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign};
 use core::panic::Location;
 
+/// The underlying primitive type used for [SafeNum] operations.
 pub type Primitive = u64;
-pub type Error = &'static Location<'static>;
+/// Safe math error type, which points to the location of the original failed operation.
+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct Error(&'static Location<'static>);
 
+impl From<&'static Location<'static>> for Error {
+    fn from(loc: &'static Location<'static>) -> Self {
+        Self(loc)
+    }
+}
+
+impl From<Error> for &'static Location<'static> {
+    fn from(err: Error) -> Self {
+        err.0
+    }
+}
+
+impl From<core::num::TryFromIntError> for Error {
+    #[track_caller]
+    fn from(_err: core::num::TryFromIntError) -> Self {
+        Self(Location::caller())
+    }
+}
+
+/// Wraps a raw [Primitive] type for safe-by-default math. See module docs for info and usage.
 #[derive(Copy, Clone, PartialEq, Eq)]
 pub struct SafeNum(Result<Primitive, Error>);
 
@@ -159,9 +182,18 @@ impl fmt::Debug for SafeNum {
     }
 }
 
+impl fmt::Display for Error {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        self.0.fmt(f)
+    }
+}
+
 impl SafeNum {
+    /// The maximum [SafeNum].
     pub const MAX: SafeNum = SafeNum(Ok(u64::MAX));
+    /// The minimum [SafeNum].
     pub const MIN: SafeNum = SafeNum(Ok(u64::MIN));
+    /// Zero as a [SafeNum].
     pub const ZERO: SafeNum = SafeNum(Ok(0));
 
     /// Round `self` down to the nearest multiple of `rhs`.
@@ -201,7 +233,7 @@ macro_rules! try_conversion_func {
 
             #[track_caller]
             fn try_from(val: SafeNum) -> Result<Self, Self::Error> {
-                Self::try_from(val.0?).map_err(|_| Location::caller())
+                Self::try_from(val.0?).map_err(|_| Location::caller().into())
             }
         }
     };
@@ -224,7 +256,7 @@ macro_rules! conversion_func_maybe_error {
         impl From<$from_type> for SafeNum {
             #[track_caller]
             fn from(val: $from_type) -> Self {
-                Self(Primitive::try_from(val).map_err(|_| Location::caller()))
+                Self(Primitive::try_from(val).map_err(|_| Location::caller().into()))
             }
         }
 
@@ -243,7 +275,9 @@ macro_rules! arithmetic_impl {
                 match (self.0, rhs.0) {
                     (Err(_), _) => self,
                     (_, Err(_)) => rhs,
-                    (Ok(lhs), Ok(rhs)) => Self(lhs.$func(rhs).ok_or_else(Location::caller)),
+                    (Ok(lhs), Ok(rhs)) => {
+                        Self(lhs.$func(rhs).ok_or_else(|| Location::caller().into()))
+                    }
                 }
             }
         }
diff --git a/gbl/libstorage/BUILD b/gbl/libstorage/BUILD
index 5982a33..bffb4a4 100644
--- a/gbl/libstorage/BUILD
+++ b/gbl/libstorage/BUILD
@@ -12,6 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_doc_test", "rust_library", "rust_test")
 
 package(
@@ -21,15 +22,17 @@ package(
 rust_library(
     name = "libstorage",
     srcs = [
+        "src/algorithm.rs",
         "src/gpt.rs",
         "src/lib.rs",
-        "src/multi_blocks.rs",
-        "src/non_blocking.rs",
     ],
     crate_name = "gbl_storage",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         "@crc32fast",
+        "@gbl//libasync",
+        "@gbl//liberror",
         "@gbl//libsafemath",
         "@zerocopy",
     ],
@@ -42,9 +45,12 @@ rust_library(
     ],
     crate_name = "gbl_storage_testlib",
     edition = "2021",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         ":libstorage",
         "@crc32fast",
+        "@gbl//libasync",
+        "@gbl//liberror",
         "@gbl//libsafemath",
         "@zerocopy",
     ],
@@ -54,6 +60,7 @@ rust_test(
     name = "libstorage_test",
     compile_data = ["@gbl//libstorage/test:test_data"],
     crate = ":libstorage",
+    rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         ":libstorage_testlib",
     ],
@@ -62,6 +69,7 @@ rust_test(
 rust_test(
     name = "libstorage_testlib_test",
     crate = ":libstorage_testlib",
+    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 rust_doc_test(
diff --git a/gbl/libstorage/src/algorithm.rs b/gbl/libstorage/src/algorithm.rs
new file mode 100644
index 0000000..79834ee
--- /dev/null
+++ b/gbl/libstorage/src/algorithm.rs
@@ -0,0 +1,399 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use crate::{
+    aligned_subslice, check_range, is_aligned, is_buffer_aligned, BlockInfo, BlockIoAsync,
+    BlockIoSync,
+};
+use core::cmp::min;
+use gbl_async::block_on;
+use liberror::Result;
+use safemath::SafeNum;
+
+/// Reads from a range at block boundary to an aligned buffer.
+async fn read_aligned_all(io: &mut impl BlockIoAsync, offset: u64, out: &mut [u8]) -> Result<()> {
+    let blk_offset = check_range(io.info(), offset, out)?.try_into()?;
+    Ok(io.read_blocks(blk_offset, out).await?)
+}
+
+/// Read with block-aligned offset and aligned buffer. Size don't need to be block aligned.
+///   |~~~~~~~~~read~~~~~~~~~|
+///   |---------|---------|---------|
+async fn read_aligned_offset_and_buffer(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    out: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    let block_size = SafeNum::from(io.info().block_size);
+    debug_assert!(is_aligned(offset.into(), block_size)?);
+    debug_assert!(is_buffer_aligned(out, io.info().alignment)?);
+
+    let aligned_read: usize = SafeNum::from(out.len()).round_down(block_size).try_into()?;
+
+    if aligned_read > 0 {
+        read_aligned_all(io, offset, &mut out[..aligned_read]).await?;
+    }
+    let unaligned = &mut out[aligned_read..];
+    if unaligned.is_empty() {
+        return Ok(());
+    }
+    // Read unalinged part.
+    let block_scratch = &mut scratch[..block_size.try_into()?];
+    let aligned_offset = SafeNum::from(offset) + aligned_read;
+    read_aligned_all(io, aligned_offset.try_into()?, block_scratch).await?;
+    unaligned.clone_from_slice(&block_scratch[..unaligned.len()]);
+    Ok(())
+}
+
+/// Read with aligned buffer. Offset and size don't need to be block aligned.
+/// Case 1:
+///            |~~~~~~read~~~~~~~|
+///        |------------|------------|
+/// Case 2:
+///          |~~~read~~~|
+///        |---------------|--------------|
+async fn read_aligned_buffer(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    out: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    debug_assert!(is_buffer_aligned(out, io.info().alignment)?);
+
+    if is_aligned(offset.into(), io.info().block_size.into())? {
+        return read_aligned_offset_and_buffer(io, offset, out, scratch).await;
+    }
+    let offset = SafeNum::from(offset);
+    let aligned_start: u64 =
+        min(offset.round_up(io.info().block_size).try_into()?, (offset + out.len()).try_into()?);
+
+    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
+    if aligned_relative_offset < out.len() {
+        if is_buffer_aligned(&out[aligned_relative_offset..], io.info().alignment)? {
+            // If new output address is aligned, read directly.
+            read_aligned_offset_and_buffer(
+                io,
+                aligned_start,
+                &mut out[aligned_relative_offset..],
+                scratch,
+            )
+            .await?;
+        } else {
+            // Otherwise read into `out` (assumed aligned) and memmove to the correct
+            // position
+            let read_len: usize =
+                (SafeNum::from(out.len()) - aligned_relative_offset).try_into()?;
+            read_aligned_offset_and_buffer(io, aligned_start, &mut out[..read_len], scratch)
+                .await?;
+            out.copy_within(..read_len, aligned_relative_offset);
+        }
+    }
+
+    // Now read the unaligned part
+    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
+    let round_down_offset = offset.round_down(io.info().block_size);
+    read_aligned_all(io, round_down_offset.try_into()?, block_scratch).await?;
+    let offset_relative = offset - round_down_offset;
+    let unaligned = &mut out[..aligned_relative_offset];
+    unaligned.clone_from_slice(
+        &block_scratch
+            [offset_relative.try_into()?..(offset_relative + unaligned.len()).try_into()?],
+    );
+    Ok(())
+}
+
+// Partition a scratch into two aligned parts: [u8; alignment()-1] and [u8; block_size())]
+// for handling block and buffer misalignment respecitvely.
+fn split_scratch<'a>(
+    info: BlockInfo,
+    scratch: &'a mut [u8],
+) -> Result<(&'a mut [u8], &'a mut [u8])> {
+    let (buffer_alignment, block_alignment) = aligned_subslice(scratch, info.alignment)?
+        .split_at_mut((SafeNum::from(info.alignment) - 1).try_into()?);
+    let block_alignment = aligned_subslice(block_alignment, info.alignment)?;
+    let block_alignment_scratch_size = match info.block_size {
+        1 => SafeNum::ZERO,
+        v => v.into(),
+    };
+    Ok((buffer_alignment, &mut block_alignment[..block_alignment_scratch_size.try_into()?]))
+}
+
+/// Read with no alignment requirement.
+pub async fn read_async(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    out: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(io.info(), scratch)?;
+
+    if is_buffer_aligned(out, io.info().alignment)? {
+        return read_aligned_buffer(io, offset, out, block_alignment_scratch).await;
+    }
+
+    // Buffer misalignment:
+    // Case 1:
+    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
+    //   |----------------------|---------------------|
+    //      io.info().alignment
+    //
+    // Case 2:
+    //    |~~~~~~buffer~~~~~|
+    //  |----------------------|---------------------|
+    //     io.info().alignment
+
+    let out_addr_value = SafeNum::from(out.as_ptr() as usize);
+    let unaligned_read: usize =
+        min((out_addr_value.round_up(io.info().alignment) - out_addr_value).try_into()?, out.len());
+
+    // Read unaligned part
+    let unaligned_out = &mut buffer_alignment_scratch[..unaligned_read];
+    read_aligned_buffer(io, offset, unaligned_out, block_alignment_scratch).await?;
+    out[..unaligned_read].clone_from_slice(unaligned_out);
+
+    if unaligned_read == out.len() {
+        return Ok(());
+    }
+    // Read aligned part
+    read_aligned_buffer(
+        io,
+        (SafeNum::from(offset) + unaligned_read).try_into()?,
+        &mut out[unaligned_read..],
+        block_alignment_scratch,
+    )
+    .await
+}
+
+/// Write bytes from aligned buffer to a block boundary range.
+async fn write_aligned_all(io: &mut impl BlockIoAsync, offset: u64, data: &mut [u8]) -> Result<()> {
+    let blk_offset = check_range(io.info(), offset, data)?.try_into()?;
+    Ok(io.write_blocks(blk_offset, data).await?)
+}
+
+/// Write with block-aligned offset and aligned buffer. `data.len()` can be unaligned.
+///   |~~~~~~~~~size~~~~~~~~~|
+///   |---------|---------|---------|
+async fn write_aligned_offset_and_buffer(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    data: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    debug_assert!(is_aligned(offset.into(), io.info().block_size.into())?);
+    debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
+
+    let aligned_write: usize =
+        SafeNum::from(data.len()).round_down(io.info().block_size).try_into()?;
+    if aligned_write > 0 {
+        write_aligned_all(io, offset, &mut data[..aligned_write]).await?;
+    }
+    let unaligned = &data[aligned_write..];
+    if unaligned.len() == 0 {
+        return Ok(());
+    }
+
+    // Perform read-modify-write for the unaligned part
+    let unaligned_start: u64 = (SafeNum::from(offset) + aligned_write).try_into()?;
+    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
+    read_aligned_all(io, unaligned_start, block_scratch).await?;
+    block_scratch[..unaligned.len()].clone_from_slice(unaligned);
+    write_aligned_all(io, unaligned_start, block_scratch).await
+}
+
+// Rotates buffer to the left.
+fn rotate_left(slice: &mut [u8], sz: usize, scratch: &mut [u8]) {
+    scratch[..sz].clone_from_slice(&slice[..sz]);
+    slice.copy_within(sz.., 0);
+    let off = slice.len().checked_sub(sz).unwrap();
+    slice[off..].clone_from_slice(&scratch[..sz]);
+}
+
+// Rotates buffer to the right.
+fn rotate_right(slice: &mut [u8], sz: usize, scratch: &mut [u8]) {
+    let off = slice.len().checked_sub(sz).unwrap();
+    scratch[..sz].clone_from_slice(&slice[off..]);
+    slice.copy_within(..off, sz);
+    slice[..sz].clone_from_slice(&scratch[..sz]);
+}
+
+/// Write with aligned buffer. Offset and size don't need to be block aligned.
+/// Case 1:
+///            |~~~~~~write~~~~~~~|
+///        |------------|------------|
+/// Case 2:
+///          |~~~write~~~|
+///        |---------------|--------------|
+async fn write_aligned_buffer(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    data: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
+
+    let offset = SafeNum::from(offset);
+    if is_aligned(offset, io.info().block_size.into())? {
+        return write_aligned_offset_and_buffer(io, offset.try_into()?, data, scratch).await;
+    }
+
+    let aligned_start: u64 =
+        min(offset.round_up(io.info().block_size).try_into()?, (offset + data.len()).try_into()?);
+    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
+    if aligned_relative_offset < data.len() {
+        if is_buffer_aligned(&data[aligned_relative_offset..], io.info().alignment)? {
+            // If new address is aligned, write directly.
+            write_aligned_offset_and_buffer(
+                io,
+                aligned_start,
+                &mut data[aligned_relative_offset..],
+                scratch,
+            )
+            .await?;
+        } else {
+            let write_len: usize =
+                (SafeNum::from(data.len()) - aligned_relative_offset).try_into()?;
+            // Swap the offset-aligned part to the beginning of the buffer (assumed aligned)
+            rotate_left(data, aligned_relative_offset, scratch);
+            let res =
+                write_aligned_offset_and_buffer(io, aligned_start, &mut data[..write_len], scratch)
+                    .await;
+            // Swap the two parts back before checking the result.
+            rotate_right(data, aligned_relative_offset, scratch);
+            res?;
+        }
+    }
+
+    // perform read-modify-write for the unaligned part.
+    let block_scratch = &mut scratch[..SafeNum::from(io.info().block_size).try_into()?];
+    let round_down_offset: u64 = offset.round_down(io.info().block_size).try_into()?;
+    read_aligned_all(io, round_down_offset, block_scratch).await?;
+    let offset_relative = offset - round_down_offset;
+    block_scratch
+        [offset_relative.try_into()?..(offset_relative + aligned_relative_offset).try_into()?]
+        .clone_from_slice(&data[..aligned_relative_offset]);
+    write_aligned_all(io, round_down_offset, block_scratch).await
+}
+
+/// Writes bytes to the block device.
+/// It does internal optimization that temporarily modifies `data` layout to minimize number of
+/// calls to `io.read_blocks()`/`io.write_blocks()` (down to O(1)).
+pub async fn write_async(
+    io: &mut impl BlockIoAsync,
+    offset: u64,
+    data: &mut [u8],
+    scratch: &mut [u8],
+) -> Result<()> {
+    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(io.info(), scratch)?;
+    if is_buffer_aligned(data, io.info().alignment)? {
+        return write_aligned_buffer(io, offset, data, block_alignment_scratch).await;
+    }
+
+    // Buffer misalignment:
+    // Case 1:
+    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
+    //   |----------------------|---------------------|
+    //      io.alignment()
+    //
+    // Case 2:
+    //    |~~~~~~buffer~~~~~|
+    //  |----------------------|---------------------|
+    //     io.alignment()
+
+    // Write unaligned part
+    let data_addr_value = SafeNum::from(data.as_ptr() as usize);
+    let unaligned_write: usize = min(
+        (data_addr_value.round_up(io.info().alignment) - data_addr_value).try_into()?,
+        data.len(),
+    );
+    let mut unaligned_data = &mut buffer_alignment_scratch[..unaligned_write];
+    unaligned_data.clone_from_slice(&data[..unaligned_write]);
+    write_aligned_buffer(io, offset, &mut unaligned_data, block_alignment_scratch).await?;
+    if unaligned_write == data.len() {
+        return Ok(());
+    }
+
+    // Write aligned part
+    write_aligned_buffer(
+        io,
+        (SafeNum::from(offset) + unaligned_write).try_into()?,
+        &mut data[unaligned_write..],
+        block_alignment_scratch,
+    )
+    .await
+}
+
+/// `AsyncAsSync` wraps a `BlockIoAsync` trait object and implement `BlockIoSync` interfaces. It
+/// simply blocks until IO completes.
+pub struct AsyncAsSync<T: BlockIoAsync>(T);
+
+impl<T: BlockIoAsync> AsyncAsSync<T> {
+    /// Creates a new instance
+    pub fn new(io: T) -> Self {
+        Self(io)
+    }
+
+    /// Returns the `BlockIoAsync`.
+    pub fn io(&mut self) -> &mut T {
+        &mut self.0
+    }
+}
+
+impl<T: BlockIoAsync> BlockIoSync for AsyncAsSync<T> {
+    fn info(&mut self) -> BlockInfo {
+        self.0.info()
+    }
+
+    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        block_on(self.0.read_blocks(blk_offset, out))
+    }
+
+    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        block_on(self.0.write_blocks(blk_offset, data))
+    }
+}
+
+/// `SyncAsAsync` wraps a `BlockIoSync` and implements `BlockIoAsync` interfaces with blocking
+/// operation under the hood.
+pub struct SyncAsAsync<T: BlockIoSync>(T);
+
+impl<T: BlockIoSync> SyncAsAsync<T> {
+    /// Creates a new instance
+    pub fn new(io: T) -> Self {
+        Self(io)
+    }
+
+    /// Returns the `BlockIoSync`.
+    pub fn io(&mut self) -> &mut T {
+        &mut self.0
+    }
+}
+
+// SAFETY:
+// * Implementation of `read_blocks()` and `write_blocks()` are blocking. It will not keep retaining
+//   the buffer after the function returns.
+// * `Self::check_status(buf)` does not dereference input pointer.
+impl<T: BlockIoSync> BlockIoAsync for SyncAsAsync<T> {
+    fn info(&mut self) -> BlockInfo {
+        self.0.info()
+    }
+
+    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        self.0.read_blocks(blk_offset, out)
+    }
+
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        self.0.write_blocks(blk_offset, data)
+    }
+}
diff --git a/gbl/libstorage/src/gpt.rs b/gbl/libstorage/src/gpt.rs
index 2f88d69..d9aa376 100644
--- a/gbl/libstorage/src/gpt.rs
+++ b/gbl/libstorage/src/gpt.rs
@@ -12,33 +12,56 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::{aligned_subslice, read, write_bytes_mut, BlockIo, Result, StorageError};
-use core::default::Default;
-use core::mem::{align_of, size_of};
-use core::num::NonZeroU64;
+use crate::{aligned_subslice, read_async, write_async, BlockIoAsync, Result};
+use core::{
+    convert::TryFrom,
+    default::Default,
+    mem::{align_of, size_of},
+    num::NonZeroU64,
+    str::from_utf8,
+};
 use crc32fast::Hasher;
 use safemath::SafeNum;
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
+use liberror::Error;
+
 const GPT_GUID_LEN: usize = 16;
+/// The maximum number of UTF-16 characters in a GPT partition name, including termination.
 pub const GPT_NAME_LEN_U16: usize = 36;
+const GPT_NAME_LEN_U8: usize = 2 * GPT_GUID_LEN;
 
+/// The top-level GPT header.
 #[repr(C, packed)]
 #[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
 pub struct GptHeader {
+    /// Magic bytes; must be [GPT_MAGIC].
     pub magic: u64,
+    /// Header version.
     pub revision: u32,
+    /// Header size in bytes.
     pub size: u32,
+    /// CRC of the first `size` bytes, calculated with this field zeroed.
     pub crc32: u32,
+    /// Reserved; must be set to 0.
     pub reserved0: u32,
+    /// The on-disk block location of this header.
     pub current: u64,
+    /// The on-disk block location of the other header.
     pub backup: u64,
+    /// First usable block for partition contents.
     pub first: u64,
+    /// Last usable block for partition contents (inclusive).
     pub last: u64,
+    /// Disk GUID.
     pub guid: [u8; GPT_GUID_LEN],
+    /// Starting block for the partition entries array.
     pub entries: u64,
+    /// Number of partition entries.
     pub entries_count: u32,
+    /// The size of each partition entry in bytes.
     pub entries_size: u32,
+    /// CRC of the partition entries array.
     pub entries_crc: u32,
 }
 
@@ -57,20 +80,28 @@ impl GptHeader {
 
 /// GptEntry is the partition entry data structure in the GPT.
 #[repr(C)]
-#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
+#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq)]
 pub struct GptEntry {
+    /// Partition type GUID.
     pub part_type: [u8; GPT_GUID_LEN],
+    /// Unique partition GUID.
     pub guid: [u8; GPT_GUID_LEN],
+    /// First block.
     pub first: u64,
+    /// Last block (inclusive).
     pub last: u64,
+    /// Partition flags.
     pub flags: u64,
+    /// Partition name in UTF-16.
     pub name: [u16; GPT_NAME_LEN_U16],
 }
 
 impl GptEntry {
     /// Return the partition entry size in blocks.
     pub fn blocks(&self) -> Result<u64> {
-        u64::try_from((SafeNum::from(self.last) - self.first) + 1).map_err(|e| e.into())
+        // Must perform "+1" first before subtracting `self.first`. Otherwise if partition size is
+        // zero, where `self.first > self.last`, arithmetic will overflow.
+        u64::try_from(SafeNum::from(self.last) + 1 - self.first).map_err(Into::into)
     }
 
     /// Return whether this is a `NULL` entry. The first null entry marks the end of the partition
@@ -89,7 +120,7 @@ impl GptEntry {
                 c if c.len_utf8() <= buffer[index..].len() => {
                     index += c.encode_utf8(&mut buffer[index..]).len()
                 }
-                _ => return Err(StorageError::InvalidInput), // Not enough space in `buffer`.
+                _ => return Err(Error::InvalidInput), // Not enough space in `buffer`.
             }
         }
         // SAFETY:
@@ -117,6 +148,7 @@ const GPT_MAX_NUM_ENTRIES: u64 = 128;
 const GPT_HEADER_SIZE: u64 = size_of::<GptHeader>() as u64; // 92 bytes.
 const GPT_HEADER_SIZE_PADDED: u64 =
     (GPT_HEADER_SIZE + GPT_ENTRY_ALIGNMENT - 1) / GPT_ENTRY_ALIGNMENT * GPT_ENTRY_ALIGNMENT;
+/// GPT header magic bytes ("EFI PART" in ASCII).
 pub const GPT_MAGIC: u64 = 0x5452415020494645;
 
 enum HeaderType {
@@ -124,6 +156,85 @@ enum HeaderType {
     Secondary,
 }
 
+/// `Partition` contains information about a GPT partition.
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub struct Partition {
+    entry: GptEntry,
+    block_size: u64,
+    decoded_name: Option<([u8; GPT_NAME_LEN_U8], usize)>,
+}
+
+impl Partition {
+    /// Creates a new instance.
+    fn new(entry: GptEntry, block_size: u64) -> Self {
+        let mut buf = [0u8; GPT_NAME_LEN_U8];
+        let decoded_name = match entry.name_to_str(&mut buf[..]).ok().map(|v| v.len()) {
+            Some(len) => Some((buf, len)),
+            _ => None,
+        };
+        Self { entry, block_size, decoded_name }
+    }
+
+    /// Gets the decoded partition name.
+    pub fn name(&self) -> Option<&str> {
+        // Correct by construction. `from_utf8` should not fail.
+        self.decoded_name.as_ref().map(|(buf, sz)| from_utf8(&buf[..*sz]).unwrap())
+    }
+
+    /// Returns the partition size in bytes.
+    pub fn size(&self) -> Result<u64> {
+        u64::try_from(SafeNum::from(self.entry.blocks()?) * self.block_size).map_err(Error::from)
+    }
+
+    /// Returns the block size of this partition.
+    pub fn block_size(&self) -> u64 {
+        self.block_size
+    }
+
+    /// Returns the partition entry structure in the GPT header.
+    pub fn gpt_entry(&self) -> &GptEntry {
+        &self.entry
+    }
+
+    /// Returns the partition's absolute start/end offset in number of bytes.
+    pub fn absolute_range(&self) -> Result<(u64, u64)> {
+        let start = SafeNum::from(self.entry.first) * self.block_size;
+        let end = (SafeNum::from(self.entry.last) + 1) * self.block_size;
+        Ok((start.try_into()?, end.try_into()?))
+    }
+
+    /// Checks a given sub range and returns its absolute offset.
+    pub fn check_range(&self, off: u64, size: u64) -> Result<u64> {
+        let off = SafeNum::from(off);
+        let end: u64 = (off + size).try_into()?;
+        match end > self.size()? {
+            true => Err(Error::BadIndex(end as usize)),
+            _ => Ok((off + self.absolute_range()?.0).try_into()?),
+        }
+    }
+}
+
+/// `PartitionIterator` iterates all GPT partition entries.
+pub struct PartitionIterator<'a, 'b> {
+    gpt_cache: &'b GptCache<'a>,
+    idx: usize,
+}
+
+impl Iterator for PartitionIterator<'_, '_> {
+    type Item = Partition;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        let res = self
+            .gpt_cache
+            .entries()
+            .ok()?
+            .get(self.idx)
+            .map(|v| Partition::new(*v, self.gpt_cache.info.block_size))?;
+        self.idx += 1;
+        Some(res)
+    }
+}
+
 #[repr(C)]
 #[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
 struct GptInfo {
@@ -145,12 +256,12 @@ impl GptInfo {
     }
 
     fn num_valid_entries(&self) -> Result<u64> {
-        Ok(self.num_valid_entries.ok_or_else(|| StorageError::InvalidInput)?.get())
+        Ok(self.num_valid_entries.ok_or(Error::InvalidInput)?.get())
     }
 }
 
-/// An object that contains the GPT header/entries information.
-pub(crate) struct Gpt<'a> {
+/// GptCache contains the GPT header/entries information loaded from storage.
+pub struct GptCache<'a> {
     info: &'a mut GptInfo,
     /// Raw bytes of primary GPT header.
     primary_header: &'a mut [u8],
@@ -162,20 +273,20 @@ pub(crate) struct Gpt<'a> {
     secondary_entries: &'a mut [u8],
 }
 
-impl<'a> Gpt<'a> {
-    /// Create an uninitialized Gpt instance from a provided buffer.
+impl<'a> GptCache<'a> {
+    /// Create an uninitialized GptCache instance from a provided buffer.
     ///
     /// # Args:
     ///
     /// * `max_entries`: Maximum number of entries allowed.
     ///
     /// * `buffer`: Buffer for creating the object. Must have a size at least
-    ///   `Gpt::required_buffer_size(max_entries)`.
-    pub(crate) fn new_from_buffer(max_entries: u64, buffer: &'a mut [u8]) -> Result<Gpt<'a>> {
+    ///   `GptCache::required_buffer_size(max_entries)`.
+    pub fn from_uninit(max_entries: u64, buffer: &'a mut [u8]) -> Result<GptCache<'a>> {
         if max_entries > GPT_MAX_NUM_ENTRIES
             || buffer.len() < Self::required_buffer_size(max_entries)?
         {
-            return Err(StorageError::InvalidInput);
+            return Err(Error::InvalidInput);
         }
         let buffer = aligned_subslice(buffer, GPT_ENTRY_ALIGNMENT)?;
         *GptInfo::from_bytes(buffer) =
@@ -183,12 +294,13 @@ impl<'a> Gpt<'a> {
         Self::from_existing(buffer)
     }
 
-    /// Reconstruct an existing Gpt struct from a buffer previously created with `new_from_buffer`.
+    /// Reconstructs an existing GptCache struct from a buffer previously created with
+    /// `Self::from_uninit()` and that has been initialized with `AsyncBlockDevice::sync_gpt()`.
     ///
     /// The method simply partitions the input buffer and populate the `GptInfo` struct and
     /// primary/secondary header/entries slices. It assumes that the buffer contains a valid
     /// GptInfo struct.
-    pub fn from_existing(buffer: &'a mut [u8]) -> Result<Gpt<'a>> {
+    pub fn from_existing(buffer: &'a mut [u8]) -> Result<GptCache<'a>> {
         let buffer = aligned_subslice(buffer, GPT_ENTRY_ALIGNMENT)?;
         let (info, remain) = Ref::<_, GptInfo>::new_from_prefix(buffer).unwrap();
         let entries_size = SafeNum::from(info.max_entries) * GPT_ENTRY_SIZE;
@@ -207,64 +319,100 @@ impl<'a> Gpt<'a> {
         })
     }
 
-    /// The minimum buffer size needed for `new_from_buffer()`
-    pub(crate) fn required_buffer_size(max_entries: u64) -> Result<usize> {
+    /// Creates a new `GptCache` instance that borrows the internal data of this instance.
+    pub fn as_mut_instance(&mut self) -> GptCache<'_> {
+        GptCache {
+            info: &mut self.info,
+            primary_header: &mut self.primary_header,
+            primary_entries: &mut self.primary_entries,
+            secondary_header: &mut self.secondary_header,
+            secondary_entries: &mut self.secondary_entries,
+        }
+    }
+
+    /// Returns an iterator to GPT partition entries.
+    pub fn partition_iter(&self) -> PartitionIterator {
+        PartitionIterator { gpt_cache: self, idx: 0 }
+    }
+
+    /// The minimum buffer size needed for `Self::from_uninit()`
+    pub fn required_buffer_size(max_entries: u64) -> Result<usize> {
         let entries_size = SafeNum::from(max_entries) * GPT_ENTRY_SIZE;
-        (((entries_size + GPT_HEADER_SIZE_PADDED) * 2) + size_of::<GptInfo>() + GPT_ENTRY_ALIGNMENT
-            - 1)
-        .try_into()
-        .map_err(|e: safemath::Error| e.into())
+        usize::try_from(
+            ((entries_size + GPT_HEADER_SIZE_PADDED) * 2)
+                + size_of::<GptInfo>()
+                + GPT_ENTRY_ALIGNMENT
+                - 1,
+        )
+        .map_err(Into::<Error>::into)
+    }
+
+    /// Checks if a read/write range into a GPT partition overflows and returns the range's absolute
+    /// offset in number of bytes.
+    pub fn check_range(&self, part_name: &str, offset: u64, size: usize) -> Result<u64> {
+        self.find_partition(part_name)?.check_range(offset, u64::try_from(size)?)
     }
 
     /// Return the list of GPT entries.
     ///
     /// If the object does not contain a valid GPT, the method returns Error.
-    pub(crate) fn entries(&self) -> Result<&[GptEntry]> {
+    fn entries(&self) -> Result<&[GptEntry]> {
         self.check_valid()?;
         Ok(&Ref::<_, [GptEntry]>::new_slice(&self.primary_entries[..]).unwrap().into_slice()
-            [..self.info.num_valid_entries()?.try_into()?])
+            [..usize::try_from(self.info.num_valid_entries()?)?])
     }
 
-    /// Search for a partition entry.
+    /// Returns the total number of partitions.
+    pub fn num_partitions(&self) -> Result<usize> {
+        Ok(self.entries()?.len())
+    }
+
+    /// Gets the `idx`th partition.
+    pub fn get_partition(&self, idx: usize) -> Result<Partition> {
+        let entry = *self.entries()?.get(idx).ok_or(Error::BadIndex(idx))?;
+        Ok(Partition::new(entry, self.info.block_size))
+    }
+
+    /// Returns the `Partition` for a partition.
     ///
-    /// If partition doesn't exist, the method returns `Ok(None)`.
+    /// # Args
     ///
-    /// If the object does not contain a valid GPT, the method returns Error.
-    pub(crate) fn find_partition(&self, part: &str) -> Result<&GptEntry> {
+    /// * `part`: Name of the partition.
+    pub fn find_partition(&self, part: &str) -> Result<Partition> {
         for entry in self.entries()? {
             let mut name_conversion_buffer = [0u8; GPT_NAME_LEN_U16 * 2];
             if entry.name_to_str(&mut name_conversion_buffer)? != part {
                 continue;
             }
-            return Ok(entry);
+            return Ok(Partition::new(*entry, self.info.block_size));
         }
-        Err(StorageError::NotExist)
+        Err(Error::NotFound)
     }
 
-    /// Check whether the Gpt has been initialized.
+    /// Checks whether the GptCache has been initialized.
     fn check_valid(&self) -> Result<()> {
         self.info.num_valid_entries()?;
         Ok(())
     }
 
     /// Helper function for loading and validating GPT header and entries.
-    fn validate_gpt(
+    async fn validate_gpt(
         &mut self,
-        blk_dev: &mut (impl BlockIo + ?Sized),
+        io: &mut impl BlockIoAsync,
         scratch: &mut [u8],
         header_type: HeaderType,
     ) -> Result<bool> {
         let (header_start, header_bytes, entries) = match header_type {
             HeaderType::Primary => {
-                (blk_dev.block_size().into(), &mut self.primary_header, &mut self.primary_entries)
+                (io.info().block_size.into(), &mut self.primary_header, &mut self.primary_entries)
             }
             HeaderType::Secondary => (
-                (SafeNum::from(blk_dev.num_blocks()) - 1) * blk_dev.block_size(),
+                (SafeNum::from(io.info().num_blocks) - 1) * io.info().block_size,
                 &mut self.secondary_header,
                 &mut self.secondary_entries,
             ),
         };
-        read(blk_dev, header_start.try_into()?, header_bytes, scratch)?;
+        read_async(io, header_start.try_into()?, header_bytes, scratch).await?;
         let header =
             Ref::<_, GptHeader>::new_from_prefix(header_bytes.as_bytes()).unwrap().0.into_ref();
 
@@ -273,10 +421,10 @@ impl<'a> Gpt<'a> {
         }
 
         let entries_size = SafeNum::from(header.entries_count) * GPT_ENTRY_SIZE;
-        let entries_offset = SafeNum::from(header.entries) * blk_dev.block_size();
+        let entries_offset = SafeNum::from(header.entries) * io.info().block_size;
         if self.info.max_entries < header.entries_count.into()
             || u64::try_from(entries_size + entries_offset)?
-                > ((SafeNum::from(blk_dev.num_blocks()) - 1) * blk_dev.block_size()).try_into()?
+                > ((SafeNum::from(io.info().num_blocks) - 1) * io.info().block_size).try_into()?
         {
             return Ok(false);
         }
@@ -292,21 +440,21 @@ impl<'a> Gpt<'a> {
 
         // Load the entries
         let out = &mut entries[..entries_size.try_into()?];
-        read(blk_dev, entries_offset.try_into()?, out, scratch)?;
+        read_async(io, entries_offset.try_into()?, out, scratch).await?;
         // Validate entries crc32.
         Ok(header.entries_crc == crc32(out))
     }
 
     /// Load and sync GPT from a block device.
-    fn load_and_sync(
+    pub(crate) async fn load_and_sync(
         &mut self,
-        blk_dev: &mut (impl BlockIo + ?Sized),
+        io: &mut impl BlockIoAsync,
         scratch: &mut [u8],
     ) -> Result<()> {
         self.info.num_valid_entries = None;
 
-        let block_size = blk_dev.block_size();
-        let total_blocks: SafeNum = blk_dev.num_blocks().into();
+        let block_size = io.info().block_size;
+        let total_blocks: SafeNum = io.info().num_blocks.into();
 
         let primary_header_blk = 1;
         let primary_header_pos = block_size;
@@ -316,14 +464,14 @@ impl<'a> Gpt<'a> {
         // Entries position for restoring.
         let primary_entries_blk = 2;
         let primary_entries_pos = SafeNum::from(primary_entries_blk) * block_size;
-        let primary_valid = self.validate_gpt(blk_dev, scratch, HeaderType::Primary)?;
-        let secondary_valid = self.validate_gpt(blk_dev, scratch, HeaderType::Secondary)?;
+        let primary_valid = self.validate_gpt(io, scratch, HeaderType::Primary).await?;
+        let secondary_valid = self.validate_gpt(io, scratch, HeaderType::Secondary).await?;
 
         let primary_header = GptHeader::from_bytes(self.primary_header);
         let secondary_header = GptHeader::from_bytes(self.secondary_header);
         if !primary_valid {
             if !secondary_valid {
-                return Err(StorageError::NoValidGpt);
+                return Err(Error::NoGpt);
             }
             // Restore to primary
             primary_header.as_bytes_mut().clone_from_slice(secondary_header.as_bytes());
@@ -333,13 +481,8 @@ impl<'a> Gpt<'a> {
             primary_header.entries = primary_entries_blk;
             primary_header.update_crc();
 
-            write_bytes_mut(blk_dev, primary_header_pos, primary_header.as_bytes_mut(), scratch)?;
-            write_bytes_mut(
-                blk_dev,
-                primary_entries_pos.try_into()?,
-                self.primary_entries,
-                scratch,
-            )?
+            write_async(io, primary_header_pos, primary_header.as_bytes_mut(), scratch).await?;
+            write_async(io, primary_entries_pos.try_into()?, self.primary_entries, scratch).await?
         } else if !secondary_valid {
             // Restore to secondary
             let secondary_entries_pos = secondary_header_pos
@@ -353,18 +496,15 @@ impl<'a> Gpt<'a> {
             secondary_header.entries = secondary_entries_blk.try_into()?;
             secondary_header.update_crc();
 
-            write_bytes_mut(
-                blk_dev,
+            write_async(
+                io,
                 secondary_header_pos.try_into()?,
                 secondary_header.as_bytes_mut(),
                 scratch,
-            )?;
-            write_bytes_mut(
-                blk_dev,
-                secondary_entries_pos.try_into()?,
-                self.secondary_entries,
-                scratch,
-            )?;
+            )
+            .await?;
+            write_async(io, secondary_entries_pos.try_into()?, self.secondary_entries, scratch)
+                .await?;
         }
 
         // Calculate actual number of GPT entries by finding the first invalid entry.
@@ -380,15 +520,6 @@ impl<'a> Gpt<'a> {
     }
 }
 
-/// Wrapper of gpt.load_and_sync(). Library internal helper for AsBlockDevice::sync_gpt().
-pub(crate) fn gpt_sync(
-    blk_dev: &mut (impl BlockIo + ?Sized),
-    gpt: &mut Gpt,
-    scratch: &mut [u8],
-) -> Result<()> {
-    gpt.load_and_sync(blk_dev, scratch)
-}
-
 /// Checks if a read/write range into a GPT partition overflows and returns the range's absolute
 /// offset in the block device.
 pub(crate) fn check_gpt_rw_params(
@@ -397,14 +528,7 @@ pub(crate) fn check_gpt_rw_params(
     offset: u64,
     size: usize,
 ) -> Result<u64> {
-    let gpt = Gpt::from_existing(gpt_cache_buffer)?;
-    let entry = gpt.find_partition(part_name)?;
-    let end: u64 = (SafeNum::from(offset) + size).try_into()?;
-    let total_size = SafeNum::from(entry.blocks()?) * gpt.info.block_size;
-    match end <= total_size.try_into()? {
-        true => Ok((SafeNum::from(entry.first) * gpt.info.block_size + offset).try_into()?),
-        false => Err(StorageError::OutOfRange),
-    }
+    GptCache::from_existing(gpt_cache_buffer)?.check_range(part_name, offset, size)
 }
 
 fn crc32(data: &[u8]) -> u32 {
@@ -417,26 +541,27 @@ fn crc32(data: &[u8]) -> u32 {
 pub(crate) mod test {
     use super::*;
     use gbl_storage_testlib::{
-        alignment_scratch_size, AsBlockDevice, TestBlockDevice, TestBlockDeviceBuilder,
+        alignment_scratch_size, AsBlockDevice, BackingStore, TestBlockDevice,
+        TestBlockDeviceBuilder,
     };
 
     /// Helper function to extract the gpt header from a test block device.
-    /// This function lives here and not as a method of TestBlockDevice so that
-    /// the Gpt type doesn't have to be exported.
-    fn gpt(dev: &mut TestBlockDevice) -> Gpt {
-        let (_, gpt) = dev.scratch.split_at_mut(alignment_scratch_size(&mut dev.io).unwrap());
-        Gpt::from_existing(gpt).unwrap()
+    fn gpt(dev: &mut TestBlockDevice) -> GptCache {
+        let info = dev.info();
+        let (_, gpt) = dev.scratch.split_at_mut(alignment_scratch_size(info).unwrap());
+        GptCache::from_existing(gpt).unwrap()
     }
 
     #[test]
-    fn test_new_from_buffer() {
+    fn test_load_and_sync() {
         let mut dev: TestBlockDevice = include_bytes!("../test/gpt_test_1.bin").as_slice().into();
         dev.sync_gpt().unwrap();
 
-        assert_eq!(dev.partition_iter().count(), 2);
-        dev.find_partition("boot_a").unwrap();
-        dev.find_partition("boot_b").unwrap();
-        assert!(dev.find_partition("boot_c").is_err());
+        let gpt_cache = gpt(&mut dev);
+        assert_eq!(gpt_cache.partition_iter().count(), 2);
+        gpt_cache.find_partition("boot_a").unwrap();
+        gpt_cache.find_partition("boot_b").unwrap();
+        assert!(gpt_cache.find_partition("boot_c").is_err());
     }
 
     #[test]
@@ -464,10 +589,11 @@ pub(crate) mod test {
         dev.io.storage[disk.len() - 512..].fill(0);
         dev.sync_gpt().unwrap();
 
-        assert_eq!(dev.partition_iter().count(), 2);
-        dev.find_partition("boot_a").unwrap();
-        dev.find_partition("boot_b").unwrap();
-        assert!(dev.find_partition("boot_c").is_err());
+        let gpt_cache = gpt(&mut dev);
+        assert_eq!(gpt_cache.partition_iter().count(), 2);
+        gpt_cache.find_partition("boot_a").unwrap();
+        gpt_cache.find_partition("boot_b").unwrap();
+        assert!(gpt_cache.find_partition("boot_c").is_err());
 
         // Check that secondary is restored
         assert_eq!(dev.io.storage, disk);
@@ -482,9 +608,10 @@ pub(crate) mod test {
         dev.io.storage[512..1024].fill(0);
         dev.sync_gpt().unwrap();
 
-        assert_eq!(dev.partition_iter().count(), 2);
-        dev.find_partition("boot_a").unwrap();
-        dev.find_partition("boot_b").unwrap();
+        let gpt_cache = gpt(&mut dev);
+        assert_eq!(gpt_cache.partition_iter().count(), 2);
+        gpt_cache.find_partition("boot_a").unwrap();
+        gpt_cache.find_partition("boot_b").unwrap();
 
         // Check that primary is restored
         assert_eq!(dev.io.storage, disk);
@@ -568,7 +695,7 @@ pub(crate) mod test {
         dev.io.storage[..64 * 1024].fill(0);
         // Load a bad GPT. Validate that the valid state is reset.
         assert!(dev.sync_gpt().is_err());
-        assert!(dev.find_partition("").is_err());
+        assert!(gpt(&mut dev).find_partition("").is_err());
     }
 
     #[test]
@@ -651,4 +778,12 @@ pub(crate) mod test {
         assert!(dev.read_gpt_partition("boot_b", 1, &mut boot_b).is_err());
         assert!(dev.write_gpt_partition("boot_b", 1, boot_b.as_mut_slice()).is_err());
     }
+
+    #[test]
+    fn test_zero_partition_size() {
+        let mut dev =
+            TestBlockDeviceBuilder::new().add_partition("zero_size", BackingStore::Size(0)).build();
+        dev.sync_gpt().unwrap();
+        assert_eq!(gpt(&mut dev).partition_iter().next().unwrap().size().unwrap(), 0);
+    }
 }
diff --git a/gbl/libstorage/src/lib.rs b/gbl/libstorage/src/lib.rs
index ee56515..13a7922 100644
--- a/gbl/libstorage/src/lib.rs
+++ b/gbl/libstorage/src/lib.rs
@@ -23,7 +23,7 @@
 //!
 //! ```rust
 //! use gbl_storage::{
-//!     AsBlockDevice, BlockIo, BlockDevice, required_scratch_size, BlockInfo, BlockIoError
+//!     AsBlockDevice, BlockIoSync, BlockDevice, required_scratch_size, BlockInfo,
 //! };
 //!
 //! /// Mocks a block device using a buffer.
@@ -31,7 +31,10 @@
 //!     storage: std::vec::Vec<u8>,
 //! }
 //!
-//! impl BlockIo for RamBlockIo {
+//! use liberror::Error;
+//!
+//! impl BlockIoSync for RamBlockIo {
+//!
 //!     fn info(&mut self) -> BlockInfo {
 //!         BlockInfo {
 //!             block_size: 512,
@@ -40,15 +43,15 @@
 //!         }
 //!     }
 //!
-//!     fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), BlockIoError> {
-//!         let start = blk_offset * self.block_size();
+//!     fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), Error> {
+//!         let start = blk_offset * self.info().block_size;
 //!         let end = start + out.len() as u64;
 //!         out.clone_from_slice(&self.storage[start as usize..end as usize]);
 //!         Ok(())
 //!     }
 //!
-//!     fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), BlockIoError> {
-//!         let start = blk_offset * self.block_size();
+//!     fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
+//!         let start = blk_offset * self.info().block_size;
 //!         let end = start + data.len() as u64;
 //!         self.storage[start as usize..end as usize].clone_from_slice(&data);
 //!         Ok(())
@@ -60,7 +63,7 @@
 //! let mut ram_block_io = RamBlockIo { storage: vec![0u8; 64 * 1024] };
 //! // Prepare a scratch buffer, size calculated with `required_scratch_size()`.
 //! let mut scratch =
-//!     vec![0u8; required_scratch_size(&mut ram_block_io, MAX_GPT_ENTRIES).unwrap()];
+//!     vec![0u8; required_scratch_size(ram_block_io.info(), MAX_GPT_ENTRIES).unwrap()];
 //! // Create a `BlockDevice`
 //! let mut ram_block_dev =
 //!     BlockDevice::new(&mut ram_block_io, &mut scratch[..], MAX_GPT_ENTRIES);
@@ -81,7 +84,7 @@
 //! let _ = ram_block_dev.write_gpt_partition("partition", 8765, data.as_mut_slice());
 //!
 //! // Alterantively, you can also define a custom type that internally owns and binds the
-//! // implementation of `BlockIo` and scratch buffer together, and then implement the
+//! // implementation of `BlockIoSync` and scratch buffer together, and then implement the
 //! // `AsBlockDevice` trait. This gives a cleaner management of resources.
 //! pub struct OwnedBlockDevice {
 //!     io: RamBlockIo,
@@ -89,7 +92,7 @@
 //! }
 //!
 //! impl AsBlockDevice for OwnedBlockDevice {
-//!     fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
+//!     fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
 //!         f(&mut self.io, &mut self.scratch[..], MAX_GPT_ENTRIES)
 //!     }
 //! }
@@ -99,69 +102,25 @@
 //! ```
 
 #![cfg_attr(not(test), no_std)]
+#![allow(async_fn_in_trait)]
 
-use core::cmp::min;
+use gbl_async::block_on;
 
 // Selective export of submodule types.
 mod gpt;
 use gpt::check_gpt_rw_params;
-use gpt::Gpt;
-pub use gpt::{GptEntry, GptHeader, GPT_MAGIC, GPT_NAME_LEN_U16};
-
+pub use gpt::{
+    GptCache, GptEntry, GptHeader, Partition, PartitionIterator, GPT_MAGIC, GPT_NAME_LEN_U16,
+};
 use safemath::SafeNum;
 
-mod multi_blocks;
-pub use multi_blocks::AsMultiBlockDevices;
-
-mod non_blocking;
-pub use non_blocking::{BlockDeviceEx, IoStatus, NonBlockingBlockIo, Transaction};
-
-/// The type of Result used in this library.
-pub type Result<T> = core::result::Result<T, StorageError>;
-
-/// Error code for this library.
-#[derive(Debug, Copy, Clone, PartialEq, Eq)]
-pub enum StorageError {
-    ArithmeticOverflow(safemath::Error),
-    BlockDeviceNotFound,
-    BlockIoError(BlockIoError),
-    BlockIoNotProvided,
-    FailedGettingBlockDevices(Option<&'static str>),
-    IoAborted,
-    InvalidInput,
-    NoValidGpt,
-    NotExist,
-    NotReady,
-    OutOfRange,
-    PartitionNotUnique,
-    ScratchTooSmall,
-}
+mod algorithm;
+pub use algorithm::{read_async, write_async, AsyncAsSync, SyncAsAsync};
 
-impl From<safemath::Error> for StorageError {
-    fn from(err: safemath::Error) -> Self {
-        Self::ArithmeticOverflow(err)
-    }
-}
-
-impl From<core::num::TryFromIntError> for StorageError {
-    fn from(_: core::num::TryFromIntError) -> Self {
-        Self::OutOfRange
-    }
-}
-
-impl From<BlockIoError> for StorageError {
-    fn from(val: BlockIoError) -> Self {
-        Self::BlockIoError(val)
-    }
-}
-
-impl core::fmt::Display for StorageError {
-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-        write!(f, "{:?}", self)
-    }
-}
+use liberror::{Error, Result};
 
 /// `BlockInfo` contains information for a block device.
+#[derive(Clone, Copy, Debug)]
 pub struct BlockInfo {
     /// Native block size of the block device.
     pub block_size: u64,
@@ -180,37 +139,75 @@ impl BlockInfo {
     }
 }
 
-/// `BlockIoError` represents the error code for returned by implementation of `BlockIo` and
-/// `NonBlockingBlockIo` interfaces.
-#[derive(Debug, Copy, Clone, PartialEq, Eq)]
-pub enum BlockIoError {
-    MediaBusy,
-    Others(Option<&'static str>),
+/// `BlockIoAsync` provides interfaces for asynchronous read and write.
+pub trait BlockIoAsync {
+    /// Returns the `BlockInfo` for this block device.
+    fn info(&mut self) -> BlockInfo;
+
+    /// Read blocks of data from the block device
+    ///
+    /// # Args
+    ///
+    /// * `blk_offset`: Offset in number of blocks.
+    ///
+    /// * `out`: Buffer to store the read data. Callers of this method ensure that it is
+    ///   aligned according to alignment() and `out.len()` is multiples of `block_size()`.
+    ///
+    /// # Returns
+    ///
+    /// Returns true if exactly out.len() number of bytes are read. Otherwise false.
+    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()>;
+
+    /// Write blocks of data to the block device
+    ///
+    /// # Args
+    ///
+    /// * `blk_offset`: Offset in number of blocks.
+    ///
+    /// * `data`: Data to write. Callers of this method ensure that it is aligned according to
+    ///   `alignment()` and `data.len()` is multiples of `block_size()`.
+    ///
+    /// # Returns
+    ///
+    /// Returns true if exactly data.len() number of bytes are written. Otherwise false.
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()>;
 }
 
-/// `BlockIo` contains methods for reading/writing blocks of data to a block device with aligned
-/// input/output buffers.
-pub trait BlockIo {
-    /// Gets the `BlockInfo` for this block device
-    fn info(&mut self) -> BlockInfo;
+impl<T: BlockIoAsync> BlockIoAsync for &mut T {
+    fn info(&mut self) -> BlockInfo {
+        (*self).info()
+    }
+
+    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        (*self).read_blocks(blk_offset, out).await
+    }
+
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        (*self).write_blocks(blk_offset, data).await
+    }
+}
+
+/// An implementation of `BlockIoAsync` of where all required methods are `unimplemented!()`
+pub struct BlockIoNull {}
 
-    /// Returns the block size of the block device.
-    fn block_size(&mut self) -> u64 {
-        self.info().block_size
+impl BlockIoAsync for BlockIoNull {
+    fn info(&mut self) -> BlockInfo {
+        unimplemented!();
     }
 
-    /// Returns the total number of blocks of the block device.
-    fn num_blocks(&mut self) -> u64 {
-        self.info().num_blocks
+    async fn read_blocks(&mut self, _: u64, _: &mut [u8]) -> Result<()> {
+        unimplemented!();
     }
 
-    /// Returns the alignment requirement for buffers passed to the `write_blocks()` and
-    /// `read_blocks()` methods. For example, many block device drivers use DMA for data transfer,
-    /// which typically requires that the buffer address for DMA be aligned to 16/32/64 bytes etc.
-    /// If the block device has no alignment requirement, it can return 1.
-    fn alignment(&mut self) -> u64 {
-        self.info().alignment
+    async fn write_blocks(&mut self, _: u64, _: &mut [u8]) -> Result<()> {
+        unimplemented!();
     }
+}
+
+/// `BlockIoSync` provide interfaces for synchronous read and write.
+pub trait BlockIoSync {
+    /// Gets the `BlockInfo` for this block device
+    fn info(&mut self) -> BlockInfo;
 
     /// Read blocks of data from the block device
     ///
@@ -224,11 +221,7 @@ pub trait BlockIo {
     /// # Returns
     ///
     /// Returns true if exactly out.len() number of bytes are read. Otherwise false.
-    fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError>;
+    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()>;
 
     /// Write blocks of data to the block device
     ///
@@ -242,77 +235,46 @@ pub trait BlockIo {
     /// # Returns
     ///
     /// Returns true if exactly data.len() number of bytes are written. Otherwise false.
-    fn write_blocks(
-        &mut self,
-        blk_offset: u64,
-        data: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError>;
-}
-
-/// `Partition` contains information about a GPT partition.
-#[derive(Debug, Copy, Clone)]
-pub struct Partition {
-    entry: GptEntry,
-    block_size: u64,
+    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()>;
 }
 
-impl Partition {
-    /// Creates a new instance.
-    fn new(entry: GptEntry, block_size: u64) -> Self {
-        Self { entry, block_size }
+impl BlockIoSync for &mut dyn BlockIoSync {
+    fn info(&mut self) -> BlockInfo {
+        (*self).info()
     }
 
-    /// Returns the partition size in bytes.
-    pub fn size(&self) -> Result<u64> {
-        (SafeNum::from(self.entry.blocks()?) * self.block_size)
-            .try_into()
-            .map_err(|e: safemath::Error| e.into())
+    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        (*self).read_blocks(blk_offset, out)
     }
 
-    /// Returns the block size of this partition.
-    pub fn block_size(&self) -> u64 {
-        self.block_size
+    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        (*self).write_blocks(blk_offset, data)
     }
+}
 
-    /// Returns the partition entry structure in the GPT header.
-    pub fn gpt_entry(&self) -> &GptEntry {
-        &self.entry
+impl<T: BlockIoAsync> BlockIoSync for T {
+    fn info(&mut self) -> BlockInfo {
+        (*self).info()
     }
-}
 
-/// `PartitionIterator` is returned by `AsBlockDevice::partition_iter()` and can be used to iterate
-/// all GPT partition entries.
-pub struct PartitionIterator<'a> {
-    dev: &'a mut dyn AsBlockDevice,
-    idx: usize,
-}
+    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        block_on((*self).read_blocks(blk_offset, out))
+    }
 
-impl Iterator for PartitionIterator<'_> {
-    type Item = Partition;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        let res = with_partitioned_scratch(
-            self.dev,
-            |io, _, gpt_buffer, _| -> Result<Option<Partition>> {
-                Ok(Gpt::from_existing(gpt_buffer)?
-                    .entries()?
-                    .get(self.idx)
-                    .map(|v| Partition::new(*v, io.block_size())))
-            },
-        )
-        .ok()?
-        .ok()??;
-        self.idx += 1;
-        Some(res)
+    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        block_on((*self).write_blocks(blk_offset, data))
     }
 }
 
-/// `AsBlockDevice` provides APIs for reading raw block content and GPT partitions with
-/// arbirary offset, size and input/output buffer.
+/// `AsBlockDevice` provides APIs for synchronous read/write of raw block storage or GPT
+/// partitions.
+///
+/// Users that need to perform asynchronous non-blocking read/write should use
+/// `read_async`, `write_async` APIs instead.
 pub trait AsBlockDevice {
     /// Runs the provided closure `f` with the following parameters:
     ///
-    ///   1. An implementation of block IO `&mut dyn BlockIo`.
+    ///   1. An implementation of block IO `&mut dyn BlockIoSync`.
     ///   2. A scratch buffer `&mut [u8]`.
     ///   3. A `u64` specifying the maximum allowed number of GPT entries.
     ///
@@ -320,11 +282,11 @@ pub trait AsBlockDevice {
     ///   offset, size that are not multiples of block size or input/output buffer that are not
     ///   aligned, and 2. to load and sync GPT headers.
     ///
-    /// * The necessary size for the scratch buffer depends on `BlockIo:alignment()`,
-    ///   `BlockIo:block_size()` and maximum allowed GPT entries. It can be computed using the
+    /// * The necessary size for the scratch buffer depends on `BlockInfo::alignment`,
+    ///   `BlockInfo::block_size` and maximum allowed GPT entries. It can be computed using the
     ///   helper API `required_scratch_size()`. If maximum allowed GPT entries is 0, GPT is
     ///   considered unavailable and no buffer will be reserved for GPT headers. If additionally,
-    ///   `BlockIo` has no alignment requirement, i.e. both alignment and block size are 1, the
+    ///   `BlockIoSync` has no alignment requirement, i.e. both alignment and block size are 1, the
     ///   total required scratch size is 0.
     ///
     /// * GPT headers will be cached in the scratch buffer after calling `Self::sync_gpt()` and
@@ -340,21 +302,13 @@ pub trait AsBlockDevice {
     ///   max value 128 regardless of the actual number of partition entries used. Thus unless you
     ///   have full control of GPT generation in your entire system where you can always ensure a
     ///   smaller bound on it, it is recommended to always return 128.
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64));
-
-    /// Returns the block size of the underlying `BlockIo`
-    fn block_size(&mut self) -> Result<u64> {
-        with_partitioned_scratch(self, |io, _, _, _| io.block_size())
-    }
-
-    /// Returns the number of blocks of the underlying `BlockIo`
-    fn num_blocks(&mut self) -> Result<u64> {
-        with_partitioned_scratch(self, |io, _, _, _| io.num_blocks())
-    }
+    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64));
 
-    /// Returns the total size in number of bytes.
-    fn total_size(&mut self) -> Result<u64> {
-        Ok((SafeNum::from(self.block_size()?) * self.num_blocks()?).try_into()?)
+    /// Returns the `BlockInfo` of the provided Block IO.
+    fn info(&mut self) -> BlockInfo {
+        let mut res = None;
+        self.with(&mut |io, _, _| res = Some(io.info()));
+        res.unwrap()
     }
 
     /// Read data from the block device.
@@ -367,7 +321,9 @@ pub trait AsBlockDevice {
     ///
     /// * Returns success when exactly `out.len()` number of bytes are read.
     fn read(&mut self, offset: u64, out: &mut [u8]) -> Result<()> {
-        with_partitioned_scratch(self, |io, alignment, _, _| read(io, offset, out, alignment))?
+        with_partitioned_scratch(self, |io, alignment, _, _| {
+            block_on(AsyncBlockDevice::new(SyncAsAsync::new(io), alignment)?.read(offset, out))
+        })?
     }
 
     /// Write data to the device.
@@ -384,8 +340,8 @@ pub trait AsBlockDevice {
     ///
     /// * Returns success when exactly `data.len()` number of bytes are written.
     fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        with_partitioned_scratch(self, |io, alignment_scratch, _, _| {
-            write_bytes_mut(io, offset, data, alignment_scratch)
+        with_partitioned_scratch(self, |io, alignment, _, _| {
+            block_on(AsyncBlockDevice::new(SyncAsAsync::new(io), alignment)?.write(offset, data))
         })?
     }
 
@@ -398,33 +354,21 @@ pub trait AsBlockDevice {
     /// Returns success if GPT is loaded/restored successfully.
     fn sync_gpt(&mut self) -> Result<()> {
         with_partitioned_scratch(self, |io, alignment_scratch, gpt_buffer, max_entries| {
-            gpt::gpt_sync(
-                io,
-                &mut Gpt::new_from_buffer(max_entries, gpt_buffer)?,
-                alignment_scratch,
+            block_on(
+                AsyncBlockDevice::new(SyncAsAsync::new(io), alignment_scratch)?
+                    .sync_gpt(&mut GptCache::from_uninit(max_entries, gpt_buffer)?),
             )
         })?
     }
 
-    /// Returns an iterator to GPT partition entries.
-    fn partition_iter(&mut self) -> PartitionIterator
-    where
-        Self: Sized,
-    {
-        PartitionIterator { dev: self, idx: 0 }
-    }
-
     /// Returns the `Partition` for a partition.
     ///
     /// # Args
     ///
     /// * `part`: Name of the partition.
     fn find_partition(&mut self, part: &str) -> Result<Partition> {
-        with_partitioned_scratch(self, |io, _, gpt_buffer, _| {
-            Ok(Partition::new(
-                *Gpt::from_existing(gpt_buffer)?.find_partition(part)?,
-                io.block_size(),
-            ))
+        with_partitioned_scratch(self, |_, _, gpt_buffer, _| {
+            GptCache::from_existing(gpt_buffer)?.find_partition(part)
         })?
     }
 
@@ -459,7 +403,7 @@ pub trait AsBlockDevice {
     ///
     /// * `offset`: Offset in number of bytes into the partition.
     ///
-    /// * `data`: Data to write. See `data` passed to `BlockIo::write()` for details.
+    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
     ///
     /// # Returns
     ///
@@ -473,59 +417,87 @@ pub trait AsBlockDevice {
 }
 
 impl<T: ?Sized + AsBlockDevice> AsBlockDevice for &mut T {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
+    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
         (*self).with(f)
     }
 }
 
-/// `BlockDevice` borrows a `BlockIo`, scratch buffer and implements `AsBlockDevice`.
+/// `BlockDevice` borrows a `BlockIoSync`, scratch buffer and implements `AsBlockDevice`.
 pub struct BlockDevice<'a, 'b> {
-    io: &'a mut dyn BlockIo,
+    io: &'a mut dyn BlockIoSync,
     scratch: &'b mut [u8],
     max_gpt_entries: u64,
 }
 
 impl<'a, 'b> BlockDevice<'a, 'b> {
-    pub fn new(io: &'a mut dyn BlockIo, scratch: &'b mut [u8], max_gpt_entries: u64) -> Self {
+    /// Creates a new [BlockDevice].
+    ///
+    /// # Arguments
+    /// * `io`: the [BlockIoSync] implementation to use.
+    /// * `scratch`: scratch buffer to use; if this is smaller than the size indicated by
+    ///              [required_scratch_size], operations on the returned device may return
+    ///              [Error::BufferTooSmall].
+    /// * `max_gpt_entries`: the maximum GPT entries to support.
+    pub fn new(io: &'a mut dyn BlockIoSync, scratch: &'b mut [u8], max_gpt_entries: u64) -> Self {
         Self { io, scratch, max_gpt_entries }
     }
 }
 
 impl AsBlockDevice for BlockDevice<'_, '_> {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
+    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
         f(self.io, self.scratch, self.max_gpt_entries)
     }
 }
 
-/// Calculates the required scratch buffer size for a `BlockIo` and number of maximum GPT entries.
-pub fn required_scratch_size(
-    io: &mut (impl BlockIo + ?Sized),
-    max_gpt_entries: u64,
-) -> Result<usize> {
-    let alignment_size: SafeNum = alignment_scratch_size(io)?.into();
+/// Iterates all partitions in a `AsBlockDevice`.
+pub fn for_each_partition<F: FnMut(&Partition) -> Result<()>>(
+    dev: &mut dyn AsBlockDevice,
+    mut f: F,
+) -> Result<Result<()>> {
+    with_partitioned_scratch(dev, |_, _, gpt_buffer, _| {
+        for ele in GptCache::from_existing(gpt_buffer)?.partition_iter() {
+            match f(&ele) {
+                Err(e) => return Ok(Err(e)),
+                _ => {}
+            }
+        }
+        Ok(Ok(()))
+    })?
+}
+
+/// Calculates the required scratch buffer size given a `BlockInfo` and maximum GPT entries.
+pub fn required_scratch_size(info: BlockInfo, max_gpt_entries: u64) -> Result<usize> {
+    let alignment_size: SafeNum = alignment_scratch_size(info)?.into();
     let gpt_buffer_size = match max_gpt_entries {
         0 => 0,
-        v => Gpt::required_buffer_size(v)?,
+        v => GptCache::required_buffer_size(v)?,
     };
-    (alignment_size + gpt_buffer_size).try_into().map_err(|e: safemath::Error| e.into())
+    (alignment_size + gpt_buffer_size).try_into().map_err(Into::into)
+}
+
+/// Partitions a raw buffer into scratch buffer and GPT cache buffer.
+fn partition_scratch(
+    info: BlockInfo,
+    max_gpt_entries: u64,
+    buffer: &mut [u8],
+) -> Result<(&mut [u8], &mut [u8])> {
+    let scratch_size = required_scratch_size(info, max_gpt_entries)?;
+    if buffer.len() < scratch_size {
+        return Err(Error::BufferTooSmall(Some(scratch_size)));
+    }
+    Ok(buffer.split_at_mut(alignment_scratch_size(info)?))
 }
 
 /// A helper that wraps `AsBlockDevice::with` and additionally partitions the scratch buffer into
 /// alignment scratch and GPT buffers.
-pub(crate) fn with_partitioned_scratch<F, R>(
-    dev: &mut (impl AsBlockDevice + ?Sized),
-    mut f: F,
-) -> Result<R>
+fn with_partitioned_scratch<F, R>(dev: &mut (impl AsBlockDevice + ?Sized), mut f: F) -> Result<R>
 where
-    F: FnMut(&mut dyn BlockIo, &mut [u8], &mut [u8], u64) -> R,
+    F: FnMut(&mut dyn BlockIoSync, &mut [u8], &mut [u8], u64) -> R,
 {
-    let mut res: Result<R> = Err(StorageError::BlockIoNotProvided);
+    let mut res: Result<R> = Err(Error::InvalidInput);
     dev.with(&mut |io, scratch, max_entries| {
         res = (|| {
-            if scratch.len() < required_scratch_size(io, max_entries)? {
-                return Err(StorageError::ScratchTooSmall);
-            }
-            let (alignment, gpt) = scratch.split_at_mut(alignment_scratch_size(io)?);
+            let (alignment, gpt) = partition_scratch(io.info(), max_entries, scratch)?;
             Ok(f(io, alignment, gpt, max_entries))
         })();
     });
@@ -545,128 +517,28 @@ pub fn is_buffer_aligned(buffer: &[u8], alignment: u64) -> Result<bool> {
 }
 
 /// Check read/write range and calculate offset in number of blocks.
-fn check_range(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    buffer: &[u8],
-) -> Result<SafeNum> {
+fn check_range(info: BlockInfo, offset: u64, buffer: &[u8]) -> Result<SafeNum> {
     let offset: SafeNum = offset.into();
-    let block_size: SafeNum = blk_io.block_size().into();
-    debug_assert!(is_aligned(offset, block_size)?);
+    let block_size: SafeNum = info.block_size.into();
+    debug_assert!(is_aligned(offset, block_size)?, "{:?}, {:?}", offset, block_size);
     debug_assert!(is_aligned(buffer.len().into(), block_size)?);
-    debug_assert!(is_buffer_aligned(buffer, blk_io.alignment().into())?);
+    debug_assert!(is_buffer_aligned(buffer, info.alignment)?);
     let blk_offset = offset / block_size;
     let blk_count = SafeNum::from(buffer.len()) / block_size;
-    match u64::try_from(blk_offset + blk_count)? <= blk_io.num_blocks() {
+    let end: u64 = (blk_offset + blk_count).try_into()?;
+    match end <= info.num_blocks {
         true => Ok(blk_offset),
-        false => Err(StorageError::OutOfRange),
+        false => Err(Error::BadIndex(end as usize)),
     }
 }
 
-/// Read with block-aligned offset, length and aligned buffer
-fn read_aligned_all(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    out: &mut [u8],
-) -> Result<()> {
-    let blk_offset = check_range(blk_io, offset, out).map(u64::try_from)??;
-    Ok(blk_io.read_blocks(blk_offset, out)?)
-}
-
-/// Read with block-aligned offset and aligned buffer. Size don't need to be block aligned.
-///   |~~~~~~~~~read~~~~~~~~~|
-///   |---------|---------|---------|
-fn read_aligned_offset_and_buffer(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    out: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    let block_size = SafeNum::from(blk_io.block_size());
-    debug_assert!(is_aligned(offset.into(), block_size)?);
-    debug_assert!(is_buffer_aligned(out, blk_io.alignment())?);
-
-    let aligned_read: usize = SafeNum::from(out.len()).round_down(block_size).try_into()?;
-
-    if aligned_read > 0 {
-        read_aligned_all(blk_io, offset, &mut out[..aligned_read])?;
-    }
-    let unaligned = &mut out[aligned_read..];
-    if unaligned.is_empty() {
-        return Ok(());
-    }
-    // Read unalinged part.
-    let block_scratch = &mut scratch[..block_size.try_into()?];
-    let aligned_offset = SafeNum::from(offset) + aligned_read;
-    read_aligned_all(blk_io, aligned_offset.try_into()?, block_scratch)?;
-    unaligned.clone_from_slice(&block_scratch[..unaligned.len()]);
-    Ok(())
-}
-
-/// Read with aligned buffer. Offset and size don't need to be block aligned.
-/// Case 1:
-///            |~~~~~~read~~~~~~~|
-///        |------------|------------|
-/// Case 2:
-///          |~~~read~~~|
-///        |---------------|--------------|
-fn read_aligned_buffer(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    out: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_buffer_aligned(out, blk_io.alignment())?);
-
-    if is_aligned(offset.into(), blk_io.block_size().into())? {
-        return read_aligned_offset_and_buffer(blk_io, offset, out, scratch);
-    }
-    let offset = SafeNum::from(offset);
-    let aligned_start: u64 =
-        min(offset.round_up(blk_io.block_size()).try_into()?, (offset + out.len()).try_into()?);
-
-    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
-    if aligned_relative_offset < out.len() {
-        if is_buffer_aligned(&out[aligned_relative_offset..], blk_io.alignment())? {
-            // If new output address is aligned, read directly.
-            read_aligned_offset_and_buffer(
-                blk_io,
-                aligned_start,
-                &mut out[aligned_relative_offset..],
-                scratch,
-            )?;
-        } else {
-            // Otherwise read into `out` (assumed aligned) and memmove to the correct
-            // position
-            let read_len: usize =
-                (SafeNum::from(out.len()) - aligned_relative_offset).try_into()?;
-            read_aligned_offset_and_buffer(blk_io, aligned_start, &mut out[..read_len], scratch)?;
-            out.copy_within(..read_len, aligned_relative_offset);
-        }
-    }
-
-    // Now read the unaligned part
-    let block_scratch = &mut scratch[..SafeNum::from(blk_io.block_size()).try_into()?];
-    let round_down_offset = offset.round_down(blk_io.block_size());
-    read_aligned_all(blk_io, round_down_offset.try_into()?, block_scratch)?;
-    let offset_relative = offset - round_down_offset;
-    let unaligned = &mut out[..aligned_relative_offset];
-    unaligned.clone_from_slice(
-        &block_scratch
-            [offset_relative.try_into()?..(offset_relative + unaligned.len()).try_into()?],
-    );
-    Ok(())
-}
-
 /// Calculates the necessary scratch buffer size for handling block and buffer misalignment.
-pub fn alignment_scratch_size(blk_io: &mut (impl BlockIo + ?Sized)) -> Result<usize> {
-    let block_alignment = match blk_io.block_size() {
+pub fn alignment_scratch_size(info: BlockInfo) -> Result<usize> {
+    let block_alignment = match info.block_size {
         1 => 0,
         v => v,
     };
-    ((SafeNum::from(blk_io.alignment()) - 1) * 2 + block_alignment)
-        .try_into()
-        .map_err(|e: safemath::Error| e.into())
+    ((SafeNum::from(info.alignment) - 1) * 2 + block_alignment).try_into().map_err(Into::into)
 }
 
 /// Gets a subslice of the given slice with aligned address according to `alignment`
@@ -675,226 +547,298 @@ fn aligned_subslice(buffer: &mut [u8], alignment: u64) -> Result<&mut [u8]> {
     Ok(&mut buffer[(addr.round_up(alignment) - addr).try_into()?..])
 }
 
-// Partition a scratch into two aligned parts: [u8; alignment()-1] and [u8; block_size())]
-// for handling block and buffer misalignment respecitvely.
-fn split_scratch<'a>(
-    blk_io: &mut (impl BlockIo + ?Sized),
+/// `AsyncBlockDevice` provides APIs for asynchronous read/write of raw block or GPT partitions.
+pub struct AsyncBlockDevice<'a, T: BlockIoAsync> {
+    io: T,
     scratch: &'a mut [u8],
-) -> Result<(&'a mut [u8], &'a mut [u8])> {
-    let (buffer_alignment, block_alignment) = aligned_subslice(scratch, blk_io.alignment())?
-        .split_at_mut((SafeNum::from(blk_io.alignment()) - 1).try_into()?);
-    let block_alignment = aligned_subslice(block_alignment, blk_io.alignment())?;
-    let block_alignment_scratch_size = match blk_io.block_size() {
-        1 => SafeNum::ZERO,
-        v => v.into(),
-    };
-    Ok((buffer_alignment, &mut block_alignment[..block_alignment_scratch_size.try_into()?]))
 }
 
-/// Read with no alignment requirement.
-fn read(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    out: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(blk_io, scratch)?;
-
-    if is_buffer_aligned(out, blk_io.alignment())? {
-        return read_aligned_buffer(blk_io, offset, out, block_alignment_scratch);
-    }
-
-    // Buffer misalignment:
-    // Case 1:
-    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
-    //   |----------------------|---------------------|
-    //      blk_io.alignment()
-    //
-    // Case 2:
-    //    |~~~~~~buffer~~~~~|
-    //  |----------------------|---------------------|
-    //     blk_io.alignment()
-
-    let out_addr_value = SafeNum::from(out.as_ptr() as usize);
-    let unaligned_read: usize =
-        min((out_addr_value.round_up(blk_io.alignment()) - out_addr_value).try_into()?, out.len());
-
-    // Read unaligned part
-    let unaligned_out = &mut buffer_alignment_scratch[..unaligned_read];
-    read_aligned_buffer(blk_io, offset, unaligned_out, block_alignment_scratch)?;
-    out[..unaligned_read].clone_from_slice(unaligned_out);
-
-    if unaligned_read == out.len() {
-        return Ok(());
-    }
-    // Read aligned part
-    read_aligned_buffer(
-        blk_io,
-        (SafeNum::from(offset) + unaligned_read).try_into()?,
-        &mut out[unaligned_read..],
-        block_alignment_scratch,
-    )
+impl<'a, T: BlockIoAsync> AsyncBlockDevice<'a, T> {
+    /// Creates a new instance with the given IO, scratch buffer and maximum GPT entries.
+    ///
+    /// * The scratch buffer is internally used for handling partial block read/write and unaligned
+    ///   input/output user buffers.
+    ///
+    /// * The necessary size for the scratch buffer depends on `BlockInfo::alignment`,
+    ///   `BlockInfo::block_size`. It can be computed using the helper API
+    ///   `Self::required_scratch_size()`. If the block device has no alignment requirement,
+    ///   i.e. both alignment and block size are 1, the total required scratch size is 0.
+    pub fn new(mut io: T, scratch: &'a mut [u8]) -> Result<Self> {
+        let scratch_size = Self::required_scratch_size(&mut io)?;
+        match scratch.len() < scratch_size {
+            true => Err(Error::BufferTooSmall(Some(scratch_size))),
+            _ => Ok(Self { io, scratch }),
+        }
+    }
+
+    /// Creates a new `AsyncBlockDevice` instance that borrows the internal data of this instance.
+    pub fn as_mut_instance(&mut self) -> AsyncBlockDevice<'_, &'_ mut T> {
+        AsyncBlockDevice::<&mut T>::new(&mut self.io, &mut self.scratch[..]).unwrap()
+    }
+
+    /// Computes the required scratch size.
+    pub fn required_scratch_size<B: BlockIoAsync>(io: &mut B) -> Result<usize> {
+        // `AsyncBlockDevice` doesn't manage GPT internally, thus max_entries passed here is 0.
+        required_scratch_size(io.info(), 0)
+    }
+
+    /// Returns the IO
+    pub fn io(&mut self) -> &mut T {
+        &mut self.io
+    }
+
+    /// Reads data from the block device.
+    ///
+    /// # Args
+    ///
+    /// * `offset`: Offset in number of bytes.
+    /// * `out`: Buffer to store the read data.
+    /// * Returns success when exactly `out.len()` number of bytes are read.
+    pub async fn read(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
+        read_async(&mut self.io, offset, data, self.scratch).await
+    }
+
+    /// Writes data to the device.
+    ///
+    /// # Args
+    ///
+    /// * `offset`: Offset in number of bytes.
+    /// * `data`: Data to write.
+    /// * The API enables an optimization which temporarily changes `data` layout internally and
+    ///   reduces the number of calls to `Self::write_blocks()` down to O(1) regardless of input's
+    ///   alignment. This is the recommended usage.
+    /// * Returns success when exactly `data.len()` number of bytes are written.
+    pub async fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
+        write_async(&mut self.io, offset, data, self.scratch).await
+    }
+
+    /// Loads and syncs GPT from a block device.
+    ///
+    /// The API validates and restores primary/secondary GPT header.
+    ///
+    /// # Returns
+    ///
+    /// Returns success if GPT is loaded/restored successfully.
+    pub async fn sync_gpt(&mut self, gpt_cache: &mut GptCache<'_>) -> Result<()> {
+        gpt_cache.load_and_sync(&mut self.io, self.scratch).await
+    }
+
+    /// Reads a GPT partition on a block device
+    ///
+    /// # Args
+    ///
+    /// * `gpt_cache`: A `GptCache` initialized with `Self::sync_gpt()`.
+    /// * `part_name`: Name of the partition.
+    /// * `offset`: Offset in number of bytes into the partition.
+    /// * `out`: Buffer to store the read data.
+    ///
+    /// # Returns
+    ///
+    /// Returns success when exactly `out.len()` of bytes are read successfully.
+    pub async fn read_gpt_partition(
+        &mut self,
+        gpt_cache: &GptCache<'_>,
+        part_name: &str,
+        offset: u64,
+        out: &mut [u8],
+    ) -> Result<()> {
+        let offset = gpt_cache.check_range(part_name, offset, out.len())?;
+        self.read(offset, out).await
+    }
+
+    /// Writes a GPT partition on a block device.
+    ///
+    ///
+    /// # Args
+    ///
+    /// * `gpt_cache`: A `GptCache` initialized with `Self::sync_gpt()`.
+    /// * `part_name`: Name of the partition.
+    /// * `offset`: Offset in number of bytes into the partition.
+    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
+    ///
+    /// # Returns
+    ///
+    /// Returns success when exactly `data.len()` of bytes are written successfully.
+    pub async fn write_gpt_partition(
+        &mut self,
+        gpt_cache: &GptCache<'_>,
+        part_name: &str,
+        offset: u64,
+        data: &mut [u8],
+    ) -> Result<()> {
+        let offset = gpt_cache.check_range(part_name, offset, data.len())?;
+        self.write(offset, data).await
+    }
 }
 
-fn write_aligned_all(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    data: &mut [u8],
-) -> Result<()> {
-    let blk_offset = check_range(blk_io, offset, data)?;
-    Ok(blk_io.write_blocks(blk_offset.try_into()?, data)?)
+/// `AsyncGptDevice` wraps a `AsyncBlockDevice` and `GptCache` and provides simpler APIs for
+/// reading/writing GPT partitions.
+pub struct AsyncGptDevice<'a, T: BlockIoAsync> {
+    blk: AsyncBlockDevice<'a, T>,
+    gpt_cache: GptCache<'a>,
 }
 
-/// Write with block-aligned offset and aligned buffer. `data.len()` can be unaligned.
-///   |~~~~~~~~~size~~~~~~~~~|
-///   |---------|---------|---------|
-fn write_aligned_offset_and_buffer(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    data: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_aligned(offset.into(), blk_io.block_size().into())?);
-    debug_assert!(is_buffer_aligned(data, blk_io.alignment())?);
+impl<'a, T: BlockIoAsync> AsyncGptDevice<'a, T> {
+    /// Creates a new instance.
+    pub fn new(blk: AsyncBlockDevice<'a, T>, gpt_cache: GptCache<'a>) -> Self {
+        Self { blk, gpt_cache }
+    }
+
+    /// Creates a new instance from a raw `BlockIoAsync` and a raw buffer. The API will attempt to
+    /// partition the `buffer` into scratch buffer and GPT cache buffer.
+    pub fn new_from_monotonic_buffer(
+        mut io: T,
+        buffer: &'a mut [u8],
+        max_gpt_entries: u64,
+    ) -> Result<Self> {
+        let (scratch, gpt) = partition_scratch(io.info(), max_gpt_entries, buffer)?;
+        Ok(Self::new(
+            AsyncBlockDevice::new(io, scratch)?,
+            GptCache::from_uninit(max_gpt_entries, gpt)?,
+        ))
+    }
+
+    /// Returns the `AsyncBlockDevice`.
+    pub fn blk(&mut self) -> &mut AsyncBlockDevice<'a, T> {
+        &mut self.blk
+    }
+
+    /// Returns the `GptCache`.
+    pub fn gpt_cache(&self) -> &GptCache<'a> {
+        &self.gpt_cache
+    }
+
+    /// Creates a new `AsyncGptDevice` instance that borrows the internal data of this instance.
+    pub fn as_mut_instance(&mut self) -> AsyncGptDevice<'_, &'_ mut T> {
+        AsyncGptDevice::new(self.blk.as_mut_instance(), self.gpt_cache.as_mut_instance())
+    }
+
+    /// Unpacks into an `AsyncBlockDevice` and `GptCache`
+    pub fn into_blk_and_gpt(self) -> (AsyncBlockDevice<'a, T>, GptCache<'a>) {
+        (self.blk, self.gpt_cache)
+    }
+
+    /// Loads and syncs GPT from a block device.
+    ///
+    /// The API validates and restores primary/secondary GPT header.
+    ///
+    /// # Returns
+    ///
+    /// Returns success if GPT is loaded/restored successfully.
+    pub async fn sync_gpt(&mut self) -> Result<()> {
+        self.blk.sync_gpt(&mut self.gpt_cache).await
+    }
 
-    let aligned_write: usize =
-        SafeNum::from(data.len()).round_down(blk_io.block_size()).try_into()?;
-    if aligned_write > 0 {
-        write_aligned_all(blk_io, offset, &mut data[..aligned_write])?;
+    /// Reads a GPT partition on a block device
+    ///
+    /// # Args
+    ///
+    /// * `part_name`: Name of the partition.
+    /// * `offset`: Offset in number of bytes into the partition.
+    /// * `out`: Buffer to store the read data.
+    ///
+    /// # Returns
+    ///
+    /// Returns success when exactly `out.len()` of bytes are read successfully.
+    pub async fn read_gpt_partition(
+        &mut self,
+        part_name: &str,
+        offset: u64,
+        out: &mut [u8],
+    ) -> Result<()> {
+        self.blk.read_gpt_partition(&mut self.gpt_cache, part_name, offset, out).await
     }
-    let unaligned = &data[aligned_write..];
-    if unaligned.len() == 0 {
-        return Ok(());
+
+    /// Writes a GPT partition on a block device.
+    ///
+    ///
+    /// # Args
+    ///
+    /// * `part_name`: Name of the partition.
+    /// * `offset`: Offset in number of bytes into the partition.
+    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
+    ///
+    /// # Returns
+    ///
+    /// Returns success when exactly `data.len()` of bytes are written successfully.
+    pub async fn write_gpt_partition(
+        &mut self,
+        part_name: &str,
+        offset: u64,
+        data: &mut [u8],
+    ) -> Result<()> {
+        self.blk.write_gpt_partition(&mut self.gpt_cache, part_name, offset, data).await
     }
+}
 
-    // Perform read-modify-write for the unaligned part
-    let unaligned_start: u64 = (SafeNum::from(offset) + aligned_write).try_into()?;
-    let block_scratch = &mut scratch[..SafeNum::from(blk_io.block_size()).try_into()?];
-    read_aligned_all(blk_io, unaligned_start, block_scratch)?;
-    block_scratch[..unaligned.len()].clone_from_slice(unaligned);
-    write_aligned_all(blk_io, unaligned_start, block_scratch)
+/// `AsAsyncGptDeviceIter` defines an iterface for getting an iterator of `AsyncGptDevice`.
+pub trait AsAsyncGptDeviceIter {
+    /// The type that implements the `BlockIoAsync` trait for `AsyncGptDevice`.
+    type BlockIo<'a>: BlockIoAsync
+    where
+        Self: 'a;
+
+    /// Gets an iterator for `AsyncGptDevice`.
+    fn iter(&mut self) -> impl IntoIterator<Item = AsyncGptDevice<'_, Self::BlockIo<'_>>>;
 }
 
-/// Swap the position of sub segment [0..pos] and [pos..]
-fn swap_slice(slice: &mut [u8], pos: usize) {
-    let (left, right) = slice.split_at_mut(pos);
-    left.reverse();
-    right.reverse();
-    slice.reverse();
+// Built-in implementation for an array of `AsyncGptDevice`.
+impl<B: BlockIoAsync> AsAsyncGptDeviceIter for [AsyncGptDevice<'_, B>] {
+    type BlockIo<'a> = &'a mut B where Self: 'a;
+
+    fn iter(&mut self) -> impl IntoIterator<Item = AsyncGptDevice<'_, Self::BlockIo<'_>>> {
+        self.iter_mut().map(move |v| v.as_mut_instance())
+    }
 }
 
-/// Write with aligned buffer. Offset and size don't need to be block aligned.
-/// Case 1:
-///            |~~~~~~write~~~~~~~|
-///        |------------|------------|
-/// Case 2:
-///          |~~~write~~~|
-///        |---------------|--------------|
-fn write_aligned_buffer(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
-    data: &mut [u8],
-    scratch: &mut [u8],
-) -> Result<()> {
-    debug_assert!(is_buffer_aligned(data, blk_io.alignment())?);
-
-    let offset = SafeNum::from(offset);
-    if is_aligned(offset, blk_io.block_size().into())? {
-        return write_aligned_offset_and_buffer(blk_io, offset.try_into()?, data, scratch);
-    }
-
-    let aligned_start: u64 =
-        min(offset.round_up(blk_io.block_size()).try_into()?, (offset + data.len()).try_into()?);
-    let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
-    if aligned_relative_offset < data.len() {
-        if is_buffer_aligned(&data[aligned_relative_offset..], blk_io.alignment())? {
-            // If new address is aligned, write directly.
-            write_aligned_offset_and_buffer(
-                blk_io,
-                aligned_start,
-                &mut data[aligned_relative_offset..],
-                scratch,
-            )?;
-        } else {
-            let write_len: usize =
-                (SafeNum::from(data.len()) - aligned_relative_offset).try_into()?;
-            // Swap the offset-aligned part to the beginning of the buffer (assumed aligned)
-            swap_slice(data, aligned_relative_offset);
-            let res = write_aligned_offset_and_buffer(
-                blk_io,
-                aligned_start,
-                &mut data[..write_len],
-                scratch,
-            );
-            // Swap the two parts back before checking the result.
-            swap_slice(data, write_len);
-            res?;
-        }
+/// Checks that a partition exists and is unique.
+///
+/// On Success, returns the offset of the block device in the list, the `Partition` and the
+/// corresponding `AsyncGptDevice<'a, B>`.
+pub fn check_part_unique<'a, B: BlockIoAsync>(
+    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
+    part: &str,
+) -> Result<(usize, Partition, AsyncGptDevice<'a, B>)> {
+    let mut idx = 0usize;
+    let mut res = Err(Error::NotFound);
+    for dev in devs.iter() {
+        res = match dev.gpt_cache().find_partition(part).map(|v| (idx, v, dev)) {
+            Ok(_) if res.is_ok() => return Err(Error::NotUnique),
+            v => v.or(res),
+        };
+        idx += 1;
     }
+    res
+}
 
-    // perform read-modify-write for the unaligned part.
-    let block_scratch = &mut scratch[..SafeNum::from(blk_io.block_size()).try_into()?];
-    let round_down_offset: u64 = offset.round_down(blk_io.block_size()).try_into()?;
-    read_aligned_all(blk_io, round_down_offset, block_scratch)?;
-    let offset_relative = offset - round_down_offset;
-    block_scratch
-        [offset_relative.try_into()?..(offset_relative + aligned_relative_offset).try_into()?]
-        .clone_from_slice(&data[..aligned_relative_offset]);
-    write_aligned_all(blk_io, round_down_offset, block_scratch)
+/// Checks that a partition is unique among a list of GPT devices and reads from it
+pub async fn read_unique_gpt_partition<'a, B: BlockIoAsync>(
+    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
+    part: &str,
+    off: u64,
+    out: &mut [u8],
+) -> Result<()> {
+    check_part_unique(devs, part)?.2.read_gpt_partition(part, off, out).await
 }
 
-/// Same as write_bytes(). Expcet that the API takes a mutable input bytes slice instead.
-/// It does internal optimization that temporarily modifies `data` layout to minimize number of
-/// calls to `blk_io.read_blocks()`/`blk_io.write_blocks()` (down to O(1)).
-fn write_bytes_mut(
-    blk_io: &mut (impl BlockIo + ?Sized),
-    offset: u64,
+/// Checks that a partition is unique among a list of GPT devices and writes to it.
+pub async fn write_unique_gpt_partition<'a, B: BlockIoAsync>(
+    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
+    part: &str,
+    off: u64,
     data: &mut [u8],
-    scratch: &mut [u8],
 ) -> Result<()> {
-    let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(blk_io, scratch)?;
-    if is_buffer_aligned(data, blk_io.alignment())? {
-        return write_aligned_buffer(blk_io, offset, data, block_alignment_scratch);
-    }
-
-    // Buffer misalignment:
-    // Case 1:
-    //     |~~~~~~~~~~~~buffer~~~~~~~~~~~~|
-    //   |----------------------|---------------------|
-    //      blk_io.alignment()
-    //
-    // Case 2:
-    //    |~~~~~~buffer~~~~~|
-    //  |----------------------|---------------------|
-    //     blk_io.alignment()
-
-    // Write unaligned part
-    let data_addr_value = SafeNum::from(data.as_ptr() as usize);
-    let unaligned_write: usize = min(
-        (data_addr_value.round_up(blk_io.alignment()) - data_addr_value).try_into()?,
-        data.len(),
-    );
-    let mut unaligned_data = &mut buffer_alignment_scratch[..unaligned_write];
-    unaligned_data.clone_from_slice(&data[..unaligned_write]);
-    write_aligned_buffer(blk_io, offset, &mut unaligned_data, block_alignment_scratch)?;
-    if unaligned_write == data.len() {
-        return Ok(());
-    }
-
-    // Write aligned part
-    write_aligned_buffer(
-        blk_io,
-        (SafeNum::from(offset) + unaligned_write).try_into()?,
-        &mut data[unaligned_write..],
-        block_alignment_scratch,
-    )
+    check_part_unique(devs, part)?.2.write_gpt_partition(part, off, data).await
 }
 
 #[cfg(test)]
 mod test {
     use core::mem::size_of;
+    use gbl_async::block_on;
     use gbl_storage_testlib::{
-        required_scratch_size, AsBlockDevice, TestBlockDevice, TestBlockDeviceBuilder,
+        read_unique_gpt_partition, required_scratch_size, write_unique_gpt_partition,
+        AsBlockDevice, AsyncGptDevice, TestBlockDevice, TestBlockDeviceBuilder, TestBlockIo,
+        TestMultiBlockDevices,
     };
     use safemath::SafeNum;
 
@@ -943,16 +887,16 @@ mod test {
         }
     }
 
-    /// Upper bound on the number of `BlockIo::read_blocks()/write_blocks()` calls by
-    /// `AsBlockDevice::read()` and `AsBlockDevice::write()` with mutable input buffer.
+    /// Upper bound on the number of `read_blocks_async()/write_blocks_async()` calls by
+    /// `AsBlockDevice::read()` and `AsBlockDevice::write()`.
     ///
-    /// * `fn read_aligned_all()`: At most 1 call to `BlockIo::read_blocks()`.
+    /// * `fn read_aligned_all()`: At most 1 call to `read_blocks_async()`.
     /// * `fn read_aligned_offset_and_buffer()`: At most 2 calls to `read_aligned_all()`.
     /// * `fn read_aligned_buffer()`: At most 1 call to `read_aligned_offset_and_buffer()` plus 1
-    ///   call to `BlockIo::read_blocks()`.
-    /// * `fn read()`: At most 2 calls to `read_aligned_buffer()`.
+    ///   call to `read_blocks_async()`.
+    /// * `fn read_async()`: At most 2 calls to `read_aligned_buffer()`.
     ///
-    /// Analysis is similar for `fn write()`.
+    /// Analysis is similar for `fn write_async()`.
     const READ_WRITE_BLOCKS_UPPER_BOUND: usize = 6;
 
     fn read_test_helper(case: &TestCase) {
@@ -1294,7 +1238,7 @@ mod test {
             .set_max_gpt_entries(0)
             .set_size(1)
             .build();
-        assert_eq!(required_scratch_size(&mut blk.io, 0).unwrap(), 0);
+        assert_eq!(required_scratch_size(blk.info(), 0).unwrap(), 0);
     }
 
     #[test]
@@ -1362,4 +1306,101 @@ mod test {
         assert!(size_of::<u64>() >= size_of::<*const u8>());
         assert!(size_of::<u64>() >= size_of::<usize>());
     }
+
+    /// A test helper for `read_unique_gpt_partition`
+    /// It verifies that data read partition `part` at offset `off` is the same as
+    /// `expected`.
+    fn check_read_partition(
+        devs: &mut [AsyncGptDevice<&mut TestBlockIo>],
+        part: &str,
+        off: usize,
+        expected: &[u8],
+    ) {
+        let mut out = vec![0u8; expected.len()];
+        block_on(read_unique_gpt_partition(devs, part, off.try_into().unwrap(), &mut out)).unwrap();
+        assert_eq!(out, expected.to_vec());
+    }
+
+    #[test]
+    fn test_multi_block_gpt_read() {
+        let off = 512usize; // Randomly selected offset.
+
+        let mut devs = TestMultiBlockDevices(vec![
+            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
+            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
+        ]);
+        let mut devs = devs.as_gpt_devs();
+        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
+
+        let expect_boot_a = include_bytes!("../test/boot_a.bin");
+        let expect_boot_b = include_bytes!("../test/boot_b.bin");
+
+        check_read_partition(&mut devs, "boot_a", off, &expect_boot_a[off..]);
+        check_read_partition(&mut devs, "boot_b", off, &expect_boot_b[off..]);
+
+        let expect_vendor_boot_a = include_bytes!("../test/vendor_boot_a.bin");
+        let expect_vendor_boot_b = include_bytes!("../test/vendor_boot_b.bin");
+
+        check_read_partition(&mut devs, "vendor_boot_a", off, &expect_vendor_boot_a[off..]);
+        check_read_partition(&mut devs, "vendor_boot_b", off, &expect_vendor_boot_b[off..]);
+    }
+
+    /// A test helper for `write_unique_gpt_partition`
+    /// It verifies that `data` is correctly written to partition `part` at offset `off`.
+    fn check_write_partition(
+        devs: &mut [AsyncGptDevice<&mut TestBlockIo>],
+        part: &str,
+        off: usize,
+        to_write: &mut [u8],
+    ) {
+        block_on(write_unique_gpt_partition(devs, part, off.try_into().unwrap(), to_write))
+            .unwrap();
+        check_read_partition(devs, part, off, &to_write);
+
+        to_write.reverse();
+        block_on(write_unique_gpt_partition(devs, part, off.try_into().unwrap(), to_write))
+            .unwrap();
+        check_read_partition(devs, part, off, &to_write);
+    }
+
+    #[test]
+    fn test_multi_block_gpt_write() {
+        let off = 512usize; // Randomly selected offset.
+
+        let mut devs = TestMultiBlockDevices(vec![
+            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
+            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
+        ]);
+        let mut devs = devs.as_gpt_devs();
+        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
+
+        let expect_boot_a = &mut include_bytes!("../test/boot_a.bin").to_vec();
+        let expect_boot_b = &mut include_bytes!("../test/boot_b.bin").to_vec();
+
+        expect_boot_a.reverse();
+        expect_boot_b.reverse();
+        check_write_partition(&mut devs, "boot_a", off, &mut expect_boot_a[off..]);
+        check_write_partition(&mut devs, "boot_b", off, &mut expect_boot_b[off..]);
+
+        let expect_vendor_boot_a = &mut include_bytes!("../test/vendor_boot_a.bin").to_vec();
+        let expect_vendor_boot_b = &mut include_bytes!("../test/vendor_boot_b.bin").to_vec();
+
+        expect_boot_a.reverse();
+        expect_boot_b.reverse();
+        check_write_partition(&mut devs, "vendor_boot_a", off, &mut expect_vendor_boot_a[off..]);
+        check_write_partition(&mut devs, "vendor_boot_b", off, &mut expect_vendor_boot_b[off..]);
+    }
+
+    #[test]
+    fn test_none_block_id_fail_with_non_unique_partition() {
+        let mut devs = TestMultiBlockDevices(vec![
+            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
+            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
+        ]);
+        let mut devs = devs.as_gpt_devs();
+        let devs = devs.as_mut_slice();
+        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
+        assert!(block_on(read_unique_gpt_partition(devs, "boot_a", 0, &mut [],)).is_err());
+        assert!(block_on(write_unique_gpt_partition(devs, "boot_a", 0, &mut [],)).is_err())
+    }
 }
diff --git a/gbl/libstorage/src/multi_blocks.rs b/gbl/libstorage/src/multi_blocks.rs
deleted file mode 100644
index 9525e31..0000000
--- a/gbl/libstorage/src/multi_blocks.rs
+++ /dev/null
@@ -1,328 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{AsBlockDevice, BlockIo, Partition, Result, StorageError};
-
-/// `AsMultiBlockDevices` provides APIs for finding/reading/writing raw data or GPT partitions from
-/// multiple block devices.
-pub trait AsMultiBlockDevices {
-    /// Calls closure `f` for each `AsBlockDevice` object and its unique `id` until reaching end.
-    fn for_each(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64),
-    ) -> core::result::Result<(), Option<&'static str>>;
-
-    /// Calls closure `f` for each `AsBlockDevice` object and its unique `id` until reaching end of
-    /// returnning true.
-    fn for_each_until(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64) -> bool,
-    ) -> Result<()> {
-        let mut stop = false;
-        self.for_each(&mut |io, id| {
-            stop = stop || f(io, id);
-        })
-        .map_err(|v| StorageError::FailedGettingBlockDevices(v))
-    }
-
-    /// Gets the block device with the given id.
-    fn get(&mut self, id: u64) -> Result<SelectedBlockDevice>
-    where
-        Self: Sized,
-    {
-        with_id(self, id, |_| {})?;
-        Ok(SelectedBlockDevice { devs: self, id: id })
-    }
-
-    /// Syncs gpt for all block devices. Caller provides a callback for handling sync error for
-    /// each block device.
-    fn sync_gpt_all(&mut self, f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64, StorageError)) {
-        let _ = self.for_each_until(&mut |v, id| {
-            match v.sync_gpt() {
-                Err(e) => f(v, id, e),
-                _ => {}
-            }
-            false
-        });
-    }
-
-    /// Checks that a partition exists and is unique among all block devices with GPT.
-    ///
-    /// Returns the block device ID for the partition.
-    fn check_part(&mut self, part: &str) -> Result<(u64, Partition)> {
-        let mut res = Err(StorageError::NotExist);
-        self.for_each_until(&mut |v, id| {
-            res = match v.find_partition(part).map(|v| (id, v)) {
-                Ok(_) if res.is_ok() => Err(StorageError::PartitionNotUnique),
-                v => v.or(res),
-            };
-            res.err() == Some(StorageError::PartitionNotUnique)
-        })?;
-        res
-    }
-
-    /// Returns the block size and `GptEntry` for a partition.
-    ///
-    /// Returns Ok(()) if the partition is found and unique among all block devices.
-    fn find_partition(&mut self, part: &str) -> Result<Partition> {
-        self.check_part(part)?;
-        until_ok(self, |dev, _| dev.find_partition(part))
-    }
-
-    /// Reads a GPT partition.
-    ///
-    /// Returns Ok(()) if the partition is unique among all block devices and read is successful.
-    fn read_gpt_partition(&mut self, part_name: &str, offset: u64, out: &mut [u8]) -> Result<()> {
-        self.check_part(part_name)?;
-        until_ok(self, |dev, _| dev.read_gpt_partition(part_name, offset, out))
-    }
-
-    /// Writes a GPT partition with mutable input buffer.
-    ///
-    /// Returns Ok(()) if the partition is unique among all block devices and write is successful.
-    fn write_gpt_partition(&mut self, part_name: &str, offset: u64, data: &mut [u8]) -> Result<()> {
-        self.check_part(part_name)?;
-        until_ok(self, |dev, _| dev.write_gpt_partition(part_name, offset, &mut data[..]))
-    }
-}
-
-impl<T: ?Sized + AsMultiBlockDevices> AsMultiBlockDevices for &mut T {
-    fn for_each(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64),
-    ) -> core::result::Result<(), Option<&'static str>> {
-        (*self).for_each(&mut |io, id| f(io, id))
-    }
-}
-
-/// Iterates and runs a closure on each block device until `Ok(R)` is returned.
-fn until_ok<F, R>(devs: &mut (impl AsMultiBlockDevices + ?Sized), mut f: F) -> Result<R>
-where
-    F: FnMut(&mut dyn AsBlockDevice, u64) -> Result<R>,
-{
-    let mut res: Result<R> = Err(StorageError::BlockDeviceNotFound);
-    devs.for_each_until(&mut |v, id| {
-        res = f(v, id);
-        res.is_ok()
-    })?;
-    res
-}
-
-/// Finds the first block device with the given ID and runs a closure with it.
-fn with_id<F, R>(devs: &mut (impl AsMultiBlockDevices + ?Sized), dev_id: u64, mut f: F) -> Result<R>
-where
-    F: FnMut(&mut dyn AsBlockDevice) -> R,
-{
-    until_ok(devs, |dev, id| match dev_id == id {
-        true => Ok(f(dev)),
-        _ => Err(StorageError::BlockDeviceNotFound),
-    })
-}
-
-/// `SelectedBlockDevice` is returned by `AsMultiBlockDevices::get()` and provides access to
-/// the `AsBlockDevice` object of the given id.
-pub struct SelectedBlockDevice<'a> {
-    devs: &'a mut dyn AsMultiBlockDevices,
-    id: u64,
-}
-
-impl AsBlockDevice for SelectedBlockDevice<'_> {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
-        let _ = with_id(self.devs, self.id, |dev| dev.with(f));
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use gbl_storage_testlib::{
-        AsBlockDevice, AsMultiBlockDevices, TestBlockDeviceBuilder, TestMultiBlockDevices,
-    };
-
-    #[test]
-    fn test_get() {
-        let mut devs: TestMultiBlockDevices = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        devs.get(0).unwrap();
-        devs.get(1).unwrap();
-        assert!(devs.get(2).is_err());
-    }
-
-    #[test]
-    fn test_multi_block_read() {
-        let off = 512; // Randomly selected offset.
-        let blk_0 = include_bytes!("../test/gpt_test_1.bin");
-        let blk_1 = include_bytes!("../test/gpt_test_2.bin");
-        let mut devs =
-            TestMultiBlockDevices(vec![blk_0.as_slice().into(), blk_1.as_slice().into()]);
-
-        let mut out = vec![0u8; blk_0[off..].len()];
-        devs.get(0).unwrap().read(u64::try_from(off).unwrap(), &mut out[..]).unwrap();
-        assert_eq!(out, blk_0[off..]);
-
-        let mut out = vec![0u8; blk_1[off..].len()];
-        devs.get(1).unwrap().read(u64::try_from(off).unwrap(), &mut out[..]).unwrap();
-        assert_eq!(out, blk_1[off..]);
-    }
-
-    #[test]
-    fn test_multi_block_write() {
-        let off = 512; // Randomly selected offset.
-        let mut blk_0 = include_bytes!("../test/gpt_test_1.bin").to_vec();
-        let mut blk_1 = include_bytes!("../test/gpt_test_2.bin").to_vec();
-        let mut devs = TestMultiBlockDevices(vec![
-            TestBlockDeviceBuilder::new().set_size(blk_0.len()).build(),
-            TestBlockDeviceBuilder::new().set_size(blk_1.len()).build(),
-        ]);
-
-        devs.get(0).unwrap().write(u64::try_from(off).unwrap(), &mut blk_0[off..]).unwrap();
-        assert_eq!(blk_0[off..], devs.0[0].io.storage[off..]);
-
-        devs.get(1).unwrap().write(u64::try_from(off).unwrap(), &mut blk_1[off..]).unwrap();
-        assert_eq!(blk_1[off..], devs.0[1].io.storage[off..]);
-    }
-
-    #[test]
-    fn test_multi_block_gpt_partition_size() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-
-        assert_eq!(devs.find_partition("boot_a").map(|v| v.size()).unwrap(), Ok(8 * 1024));
-        assert_eq!(
-            devs.get(0).unwrap().find_partition("boot_a").map(|v| v.size()).unwrap(),
-            Ok(8 * 1024)
-        );
-
-        assert_eq!(devs.find_partition("boot_b").map(|v| v.size()).unwrap(), Ok(12 * 1024));
-        assert_eq!(
-            devs.get(0).unwrap().find_partition("boot_b").map(|v| v.size()).unwrap(),
-            Ok(12 * 1024)
-        );
-
-        assert_eq!(devs.find_partition("vendor_boot_a").map(|v| v.size()).unwrap(), Ok(4 * 1024));
-        assert_eq!(
-            devs.get(1).unwrap().find_partition("vendor_boot_a").map(|v| v.size()).unwrap(),
-            Ok(4 * 1024)
-        );
-
-        assert_eq!(devs.find_partition("vendor_boot_b").map(|v| v.size()).unwrap(), Ok(6 * 1024));
-        assert_eq!(
-            devs.get(1).unwrap().find_partition("vendor_boot_b").map(|v| v.size()).unwrap(),
-            Ok(6 * 1024)
-        );
-    }
-
-    /// A test helper for `AsMultiBlockDevices::read_gpt_partition`
-    /// It verifies that data read partition `part` at offset `off` is the same as
-    /// `expected[off..]`.
-    fn check_read_partition(
-        devs: &mut TestMultiBlockDevices,
-        part: &str,
-        off: u64,
-        part_data: &[u8],
-    ) {
-        let expected = &part_data[off.try_into().unwrap()..];
-        let mut out = vec![0u8; expected.len()];
-        devs.read_gpt_partition(part, off, &mut out[..]).unwrap();
-        assert_eq!(out, expected.to_vec());
-    }
-
-    #[test]
-    fn test_multi_block_gpt_read() {
-        let off = 512u64; // Randomly selected offset.
-
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-
-        let expect_boot_a = include_bytes!("../test/boot_a.bin");
-        let expect_boot_b = include_bytes!("../test/boot_b.bin");
-
-        check_read_partition(&mut devs, "boot_a", off, expect_boot_a);
-        check_read_partition(&mut devs, "boot_b", off, expect_boot_b);
-
-        let expect_vendor_boot_a = include_bytes!("../test/vendor_boot_a.bin");
-        let expect_vendor_boot_b = include_bytes!("../test/vendor_boot_b.bin");
-
-        check_read_partition(&mut devs, "vendor_boot_a", off, expect_vendor_boot_a);
-        check_read_partition(&mut devs, "vendor_boot_b", off, expect_vendor_boot_b);
-    }
-
-    /// A test helper for `AsMultiBlockDevices::write_gpt_partition`
-    /// It verifies that `data[off..]` is correctly written to partition `part` at offset `off`.
-    fn check_write_partition(
-        devs: &mut TestMultiBlockDevices,
-        part: &str,
-        off: u64,
-        data: &mut [u8],
-    ) {
-        let to_write = &mut data[off.try_into().unwrap()..];
-
-        let mut out = vec![0u8; to_write.len()];
-        devs.write_gpt_partition(part, off, to_write).unwrap();
-        devs.read_gpt_partition(part, off, &mut out[..]).unwrap();
-        assert_eq!(out, to_write.to_vec());
-
-        to_write.reverse();
-        devs.write_gpt_partition(part, off, to_write).unwrap();
-        devs.read_gpt_partition(part, off, &mut out[..]).unwrap();
-        assert_eq!(out, to_write.to_vec());
-    }
-
-    #[test]
-    fn test_multi_block_gpt_write() {
-        let off = 512u64; // Randomly selected offset.
-
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-
-        let expect_boot_a = &mut include_bytes!("../test/boot_a.bin").to_vec();
-        let expect_boot_b = &mut include_bytes!("../test/boot_b.bin").to_vec();
-
-        expect_boot_a.reverse();
-        expect_boot_b.reverse();
-        check_write_partition(&mut devs, "boot_a", off, expect_boot_a);
-        check_write_partition(&mut devs, "boot_b", off, expect_boot_b);
-
-        let expect_vendor_boot_a = &mut include_bytes!("../test/vendor_boot_a.bin").to_vec();
-        let expect_vendor_boot_b = &mut include_bytes!("../test/vendor_boot_b.bin").to_vec();
-
-        expect_boot_a.reverse();
-        expect_boot_b.reverse();
-        check_write_partition(&mut devs, "vendor_boot_a", off, expect_vendor_boot_a);
-        check_write_partition(&mut devs, "vendor_boot_b", off, expect_vendor_boot_b);
-    }
-
-    #[test]
-    fn test_none_block_id_fail_with_non_unique_partition() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-        ]);
-        devs.sync_gpt_all(&mut |_, _, _| panic!("GPT sync failed"));
-        assert!(devs.read_gpt_partition("boot_a", 0, &mut []).is_err());
-        assert!(devs.write_gpt_partition("boot_a", 0, &mut []).is_err());
-        assert!(devs.find_partition("boot_a").is_err());
-    }
-}
diff --git a/gbl/libstorage/src/non_blocking.rs b/gbl/libstorage/src/non_blocking.rs
deleted file mode 100644
index 6aca840..0000000
--- a/gbl/libstorage/src/non_blocking.rs
+++ /dev/null
@@ -1,753 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use crate::{
-    is_aligned, is_buffer_aligned, BlockInfo, BlockIo, BlockIoError, Result, StorageError,
-};
-use core::{marker::PhantomData, mem::swap};
-
-/// `IoStatus` represents the status of a non-blocking IO.
-#[derive(Debug, Copy, Clone, PartialEq, Eq)]
-pub enum IoStatus {
-    /// The IO request is aborted due to error or user request.
-    Aborted,
-    /// The IO request is completed.
-    Completed,
-    /// The IO request is still pending.
-    Pending,
-    /// The IO request doesn't exist.
-    NotFound,
-}
-
-/// `NonBlockingBlockIo` provides interfaces for performing non-blocking read/write.
-///
-/// # Safety
-///
-/// * Implementation must guarantee that `Self::check_status(buffer)` returns `IoStatus::Pending`
-///   if and only if it is retaining `buffer`. Once the implementation stops returning
-///   `IoStatus::Pending` for a buffer, it must not retain the buffer again until a new read/write
-///   request using the buffer is made.
-/// * The buffer pointer passed to `Self::check_status(buffer)` should only be used as a key value
-///   for looking up previously made read/write IO requests being tracked. Implementation should not
-///   attempt to derefernce it without confirming that the corresponding IO exists. If caller passes
-///   an invalid buffer pointer, implementation should be able to safely return
-///   `IoStatus::NotFound`.
-/// * If `Self::write_blocks()`/`Self::read_blocks()` returns error, the input buffer must not be
-///   retained.
-pub unsafe trait NonBlockingBlockIo {
-    /// Returns the `BlockInfo` for this block device.
-    fn info(&mut self) -> BlockInfo;
-
-    /// Perform non-blocking writes of data to the block device.
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    /// * `buffer`: Pointer to the data buffer.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(()) if the IO request is accepted.
-    /// * Returns Err(BlockIoError::MediaBusy) if the device is busy and the caller should try
-    ////  again later.
-    /// * Returns Err(BlockIoError::Others()) for other errors.
-    ///
-    /// # Safety
-    ///
-    /// * Caller must ensure that `buffer` points to a valid buffer.
-    /// * If the method returns Ok(()), caller must ensure that `buffer` remains valid and has no
-    ///   other references until `Self::check_status(buffer)` no longer returns
-    ///   `IoStatus::Pending`.
-    unsafe fn write_blocks(
-        &mut self,
-        blk_offset: u64,
-        buffer: *mut [u8],
-    ) -> core::result::Result<(), BlockIoError>;
-
-    /// Perform non-blocking read of data from the block device.
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    /// * `buffer`: Pointer to the output buffer.
-    ///
-    /// # Returns
-    ///
-    /// * Returns Ok(()) if the IO request is accepted.
-    /// * Returns Err(BlockIoError::MediaBusy) if the device is busy and the caller should try again
-    ///   later.
-    /// * Returns Err(BlockIoError::Others()) for other errors.
-    ///
-    /// # Safety
-    ///
-    /// * Caller must ensure that `buffer` points to a valid buffer.
-    /// * If the method returns Ok(()), caller must ensure that `buffer` remains valid and has no
-    ///   other references until `Self::check_status(buffer)` no longer returns
-    ///   `IoStatus::Pending`.
-    unsafe fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        buffer: *mut [u8],
-    ) -> core::result::Result<(), BlockIoError>;
-
-    /// Checks the status of the non-blocking read/write associated with the given buffer.
-    ///
-    /// # Args
-    ///
-    /// * `buf`: The buffer previously passed to `read_blocks()` / `write_blocks()`.
-    ///
-    /// # Returns
-    ///
-    /// * Returns `IoStatus::NotFound` if the request is not found.
-    /// * Returns `IoStatus::Pending` if the request is still pending.
-    /// * Returns `IoStatus::Completed` if the request has been completed successfully.
-    ///   Implementation can stop tracking the request and should return `IoStatus::NotFound` on
-    ///   subsequent queries until a new read/write request is made with the same buffer.
-    /// * Returns `IoStatus::Aborted` if the request is aborted, due to error or caller invoking
-    ///   `Self::abort()`. Implementation can stop tracking the request and should return
-    ///   `IoStatus::NotFound` on subsequent queries until a new read/write request is made with
-    ///   the same buffer.
-    fn check_status(&mut self, buf: *mut [u8]) -> IoStatus;
-
-    /// Aborts pending non-blocking IO requests.
-    ///
-    /// For currently pending requests, `Self::check_status(buf)` should eventually return
-    /// `IoStatus::Aborted` at some point in the future. For already completed requests,
-    /// `Self::check_status(buf)` should continue to return `IoStatus::Completed`.
-    fn abort(&mut self) -> core::result::Result<(), BlockIoError>;
-}
-
-// Implements the blocking version `BlockIo` for a `&mut dyn NonBlockingBlockIo`
-impl BlockIo for &mut dyn NonBlockingBlockIo {
-    fn info(&mut self) -> BlockInfo {
-        (*self).info()
-    }
-
-    fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        out: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        let ptr = out as *mut [u8];
-        // SAFETY:
-        // * This function blocks until the non-blocking IO is no longer pending.
-        // * Buffer by `ptr` is not used elsewhere.
-        unsafe { (*self).read_blocks(blk_offset, ptr)? };
-        loop {
-            match self.check_status(ptr) {
-                IoStatus::Pending => {}
-                IoStatus::Completed => return Ok(()),
-                IoStatus::Aborted => return Err(BlockIoError::Others(Some("Read aborted"))),
-                IoStatus::NotFound => panic!("Unexpected IoStatus::NotFound"),
-            }
-        }
-    }
-
-    fn write_blocks(
-        &mut self,
-        blk_offset: u64,
-        data: &mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        let ptr = data as *mut [u8];
-        // SAFETY:
-        // * This function blocks until the non-blocking IO is no longer pending.
-        // * Buffer by `ptr` is not used elsewhere.
-        unsafe { (*self).write_blocks(blk_offset, ptr)? };
-        loop {
-            match self.check_status(ptr) {
-                IoStatus::Pending => {}
-                IoStatus::Completed => return Ok(()),
-                IoStatus::Aborted => return Err(BlockIoError::Others(Some("write aborted"))),
-                IoStatus::NotFound => panic!("Unexpected IoStatus::NotFound"),
-            }
-        }
-    }
-}
-
-/// `BlockDeviceIo` represents either a `BlockIo` or `NonBlockingBlockIo`.
-pub enum BlockDeviceIo<'a> {
-    Blocking(&'a mut dyn BlockIo),
-    NonBlocking(&'a mut dyn NonBlockingBlockIo),
-}
-
-impl<'a> From<&'a mut dyn BlockIo> for BlockDeviceIo<'a> {
-    fn from(val: &'a mut dyn BlockIo) -> Self {
-        Self::Blocking(val)
-    }
-}
-
-impl<'a> From<&'a mut dyn NonBlockingBlockIo> for BlockDeviceIo<'a> {
-    fn from(val: &'a mut dyn NonBlockingBlockIo) -> Self {
-        Self::NonBlocking(val)
-    }
-}
-
-impl<'a> BlockDeviceIo<'a> {
-    /// Casts to a `BlockIo` trait object.
-    fn as_block_io(&mut self) -> &mut dyn BlockIo {
-        match self {
-            Self::Blocking(v) => *v,
-            Self::NonBlocking(v) => v,
-        }
-    }
-
-    /// Creates a sub-instance that borrows internal fields.
-    ///
-    /// This creates an instance where its lifetime parameter 'a is coerced to the life time of the
-    /// current object. This will be used for creating a local instance for blocking operation.
-    fn scoped_instance(&mut self) -> BlockDeviceIo {
-        match self {
-            Self::Blocking(v) => BlockDeviceIo::Blocking(*v),
-            Self::NonBlocking(v) => BlockDeviceIo::NonBlocking(*v),
-        }
-    }
-}
-
-/// `IoBufferState` wraps a raw buffer and keeps track of its use state in non-blocking IO.
-#[derive(Debug)]
-enum IoBufferState<'a> {
-    Ready(&'a mut [u8], IoStatus),
-    // (Original buffer &mut [u8], subslice pointer passed to non-blocking IO, phantom)
-    Pending(*mut [u8], *mut [u8], PhantomData<&'a mut [u8]>),
-}
-
-/// `IoBuffer` wraps a `IoBufferState` and implements `Drop` to check that the buffer is not
-/// pending when going out of scope.
-#[derive(Debug)]
-struct IoBuffer<'a>(IoBufferState<'a>);
-
-impl Drop for IoBuffer<'_> {
-    fn drop(&mut self) {
-        // Panics if an `IoBuffer` goes out of scope in a pending state.
-        // This is merely used for safety reasoning in `read_io_buffer()`/`write_io_buffer()` and
-        // should not be triggered if implementation logic is incorrect. Specifically, `IoBuffer`
-        // is only used internally in `BlockDeviceEx`. When `BlockDeviceEx` goes out of scope, it
-        // performs abort() and sync() to make sure no buffer is pending.
-        assert!(!self.is_pending());
-    }
-}
-
-impl<'a> IoBuffer<'a> {
-    /// Creates a new instance.
-    fn new(buffer: &'a mut [u8]) -> Self {
-        Self(IoBufferState::Ready(buffer, IoStatus::Completed))
-    }
-
-    /// Gets the cached status.
-    ///
-    /// To update the cached status, caller should call `Self::update()` first.
-    fn status(&self) -> IoStatus {
-        match self.0 {
-            IoBufferState::Ready(_, status) => status,
-            _ => IoStatus::Pending,
-        }
-    }
-
-    /// Returns whether the buffer is pending in a non-blocking IO.
-    ///
-    /// The returned value is based on the cached status. To update the cached status, caller
-    /// should call `Self::update()` first.
-    fn is_pending(&self) -> bool {
-        matches!(self.status(), IoStatus::Pending)
-    }
-
-    /// Returns whether the corresponding IO is aborted.
-    ///
-    /// The returned value is based on the cached status. To update the cached status, caller
-    /// should call `Self::update()` first.
-    fn is_aborted(&self) -> bool {
-        matches!(self.status(), IoStatus::Aborted)
-    }
-
-    /// Sets buffer to the pending state.
-    ///
-    /// Returns the pointer to the specified subslice that can be passed to
-    /// `NonBlockingBlockIo:read_blocks()` and `NonBlockingBlockIo::write_blocks()` interfaces.
-    fn set_pending(&mut self, io_offset: usize, io_size: usize) -> *mut [u8] {
-        match &mut self.0 {
-            IoBufferState::Ready(b, _) => {
-                let ptr = &mut b[io_offset..][..io_size] as *mut [u8];
-                self.0 = IoBufferState::Pending(*b as _, ptr, PhantomData);
-                ptr
-            }
-            _ => unreachable!(),
-        }
-    }
-
-    /// Gets the buffer if not pending
-    fn get(&mut self) -> &mut [u8] {
-        match &mut self.0 {
-            IoBufferState::Ready(buffer, _) => buffer,
-            _ => unreachable!(),
-        }
-    }
-
-    /// Updates the IO status
-    fn update(&mut self, io: &mut dyn NonBlockingBlockIo) {
-        match &mut self.0 {
-            IoBufferState::Ready(_, _) => {}
-            IoBufferState::Pending(buffer, ptr, _) => {
-                match io.check_status(*ptr) {
-                    IoStatus::NotFound => unreachable!(), // Logic error.
-                    IoStatus::Pending => {}
-                    v => {
-                        // SAFETY:
-                        // * `buffer` is a valid pointer as it came from
-                        //   `IoBufferState::Ready(buffer, _)`
-                        // * status is no longer pending, buffer is not retained any more.
-                        self.0 = IoBufferState::Ready(unsafe { &mut **buffer }, v);
-                    }
-                }
-            }
-        }
-    }
-
-    /// Consumes and returns the raw buffer.
-    fn take(mut self) -> &'a mut [u8] {
-        match &mut self.0 {
-            IoBufferState::Ready(buffer, _) => {
-                // IoBuffer has a drop implementation, thus we can't move buffer out directly.
-                // The solution is to swap with an empty slice, which is valid for any lifetime.
-                let mut res = &mut [][..];
-                swap(&mut res, buffer);
-                res
-            }
-            _ => unreachable!(), // Logic error.
-        }
-    }
-}
-
-/// `Transaction` tracks the non-blocking read/write IO request made by
-/// `BlockDeviceEx::read_scoped()` and `BlockDeviceEx::write_scoped()`. It automatically performs
-/// sync when going out of scope.
-pub struct Transaction<'a, 'b> {
-    dev: BlockDeviceEx<'a, 'a>,
-    _phantom: PhantomData<&'b mut [u8]>,
-}
-
-impl Transaction<'_, '_> {
-    /// Wait until the IO request is either completed/aborted and consume the transaction.
-    pub fn sync(mut self) -> Result<()> {
-        self.do_sync()
-    }
-
-    /// Helper method for performing the sync.
-    fn do_sync(&mut self) -> Result<()> {
-        self.dev.sync()?;
-        match self.dev.is_aborted() {
-            true => Err(StorageError::IoAborted),
-            _ => Ok(()),
-        }
-    }
-}
-
-impl Drop for Transaction<'_, '_> {
-    fn drop(&mut self) {
-        // We expect caller to sync() themselves if they expect errors. If not the drop will
-        // perform the sync but panics on error.
-        self.do_sync().unwrap()
-    }
-}
-
-/// `BlockDeviceEx` provides safe APIs for performing blocking/non-blocking read/write.
-///
-/// `'a`: Lifetime of the borrow to BlockIo / NonBlockingBlockIo,
-/// `'b`: Lifetime of the external user buffers that will be passed to `Self::read()` and
-///       `Self::write()`.
-pub struct BlockDeviceEx<'a, 'b> {
-    io: BlockDeviceIo<'a>,
-    current_io: Option<IoBuffer<'b>>,
-}
-
-impl<'a, 'b> BlockDeviceEx<'a, 'b> {
-    /// Creates a new instance.
-    pub fn new(io: BlockDeviceIo<'a>) -> Self {
-        Self { io, current_io: None }
-    }
-
-    /// Checks if any IO buffer is pending.
-    pub fn is_pending(&self) -> bool {
-        self.current_io.as_ref().map(|v| v.is_pending()).unwrap_or(false)
-    }
-
-    /// Updates the IO status.
-    fn update_status(&mut self) {
-        let BlockDeviceIo::NonBlocking(ref mut io) = self.io else {
-            return;
-        };
-
-        match self.current_io.as_mut() {
-            Some(buffer) => buffer.update(*io),
-            _ => {}
-        }
-    }
-
-    /// Polls and updates IO status.
-    pub fn poll(&mut self) {
-        if self.current_io.is_some() {
-            self.update_status();
-        }
-    }
-
-    /// Aborts the current IO.
-    pub fn abort(&mut self) -> Result<()> {
-        match &mut self.io {
-            BlockDeviceIo::NonBlocking(io) => Ok(io.abort()?),
-            _ => Ok(()),
-        }
-    }
-
-    /// Checks if any IO is aborted.
-    pub fn is_aborted(&self) -> bool {
-        match self.current_io.as_ref() {
-            Some(buffer) => buffer.is_aborted(),
-            _ => false,
-        }
-    }
-
-    /// Waits until the IO is completed or aborted.
-    pub fn sync(&mut self) -> Result<()> {
-        while self.is_pending() {
-            self.poll();
-        }
-        Ok(())
-    }
-
-    /// Checks whether an IO is currently in progress.
-    fn check_busy(&self) -> Result<()> {
-        // No IO implies not pending.
-        match self.current_io.is_some() {
-            true => Err(StorageError::NotReady),
-            _ => Ok(()),
-        }
-    }
-
-    /// Writes data from `buffer[offset..][..size]` to the block device at offset `dst_offset`.
-    ///
-    /// # Args
-    ///
-    /// * `dst_offset`: Destination offset to write in the block device.
-    /// * `buffer`: On input, it must be a `Some(buffer)` that contains the data to write. On
-    ///   success, the buffer will be taken and it will be set to `None`. On error, `buffer` will
-    ///   remain the same so that caller can continue to access the buffer. When the IO completes
-    ///   or aborts, caller can retrieve the buffer via `Self::take_io_buffer()`.
-    /// * `offset`: Offset of the data to write in `buffer`.
-    /// * `size`: Size of the data to write.
-    pub fn write(
-        &mut self,
-        dst_offset: u64,
-        buffer: &mut Option<&'b mut [u8]>,
-        offset: usize,
-        size: usize,
-    ) -> Result<()> {
-        self.check_busy()?;
-        let blk_size = self.io.as_block_io().block_size();
-        // TODO(b/338439051): Implement support for arbitrarily aligned buffer and read range.
-        assert_eq!(dst_offset % blk_size, 0);
-        let buffer_raw = buffer.take().ok_or(StorageError::InvalidInput)?;
-        let mut io_buffer = IoBuffer::new(buffer_raw);
-        match write_io_buffer(&mut self.io, dst_offset / blk_size, &mut io_buffer, offset, size) {
-            Err(e) => {
-                // Error. Returns the buffer to caller.
-                *buffer = Some(io_buffer.take());
-                Err(e)
-            }
-            Ok(()) => {
-                self.current_io = Some(io_buffer);
-                Ok(())
-            }
-        }
-    }
-
-    /// Reads data from the block device at offset `dst_offset` into `buffer[offset..][..size]`.
-    ///
-    /// # Args
-    ///
-    /// * `dst_offset`: Destination offset to read from the block device.
-    /// * `buffer`: On input, it must be a `Some(buffer)` that contains the output buffer. On
-    ///   success, the buffer will be taken and it will be set to `None`. On error, `buffer` will
-    ///   remain the same so that caller can continue to access the buffer. When the IO completes
-    ///   or aborts, caller can retrieve the buffer via `Self::take_io_buffer()`.
-    /// * `offset`: Offset of `buffer` to read to.
-    /// * `size`: Size of the read.
-    pub fn read(
-        &mut self,
-        dst_offset: u64,
-        buffer: &mut Option<&'b mut [u8]>,
-        offset: usize,
-        size: usize,
-    ) -> Result<()> {
-        self.check_busy()?;
-        let blk_size = self.io.as_block_io().block_size();
-        // TODO(b/338439051): Implement support for arbitrarily aligned buffer and read range.
-        assert_eq!(dst_offset % blk_size, 0);
-        let buffer_raw = buffer.take().ok_or(StorageError::InvalidInput)?;
-        let mut io_buffer = IoBuffer::new(buffer_raw);
-        match read_io_buffer(&mut self.io, dst_offset / blk_size, &mut io_buffer, offset, size) {
-            Err(e) => {
-                // Error. Returns the buffer to caller.
-                *buffer = Some(io_buffer.take());
-                Err(e)
-            }
-            Ok(()) => {
-                self.current_io = Some(io_buffer);
-                Ok(())
-            }
-        }
-    }
-
-    /// Retrieves the IO buffer if it is completed/aborted.
-    pub fn take_io_buffer(&mut self) -> Result<&'b mut [u8]> {
-        match self.current_io {
-            None => Err(StorageError::NotExist),
-            Some(_) => match !self.is_pending() {
-                true => Ok(self.current_io.take().unwrap().take()),
-                _ => Err(StorageError::NotReady),
-            },
-        }
-    }
-
-    /// Returns an instance that borrows the internal field.
-    ///
-    /// This creates an instance where its lifetime parameter 'a/'b/'c is coerced to the life time
-    /// of the current object. This will be used for creating a local instance for blocking
-    /// operation.
-    fn scoped_instance(&mut self) -> Result<BlockDeviceEx> {
-        self.check_busy()?;
-        Ok(BlockDeviceEx { io: self.io.scoped_instance(), current_io: None })
-    }
-
-    /// Performs a non-blocking write and returns a `Transanction` object which automatically
-    /// performs sync when going out of scope.
-    pub fn write_scoped<'c, 'd: 'c>(
-        &'c mut self,
-        offset: u64,
-        data: &'d mut [u8],
-    ) -> Result<Transaction<'c, 'd>> {
-        let mut dev = self.scoped_instance()?;
-        let len = data.len();
-        dev.write(offset, &mut Some(data), 0, len)?;
-        Ok(Transaction { dev, _phantom: PhantomData })
-    }
-
-    /// Performs a non-blocking read and returns a `Transanction` object which automatically
-    /// performs sync when going out of scope.
-    pub fn read_scoped<'c, 'd: 'c>(
-        &'c mut self,
-        offset: u64,
-        out: &'d mut [u8],
-    ) -> Result<Transaction<'c, 'd>> {
-        let mut dev = self.scoped_instance()?;
-        let len = out.len();
-        dev.read(offset, &mut Some(out), 0, len)?;
-        Ok(Transaction { dev, _phantom: PhantomData })
-    }
-
-    /// Performs blocking write.
-    pub fn write_blocking(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        self.write_scoped(offset, data)?.sync()
-    }
-
-    /// Performs blocking read.
-    pub fn read_blocking(&mut self, offset: u64, out: &mut [u8]) -> Result<()> {
-        self.read_scoped(offset, out)?.sync()
-    }
-}
-
-impl Drop for BlockDeviceEx<'_, '_> {
-    fn drop(&mut self) {
-        self.abort().unwrap();
-        self.sync().unwrap();
-    }
-}
-
-/// A helper to write an IO buffer to the block device.
-fn write_io_buffer(
-    io: &mut BlockDeviceIo,
-    blk_offset: u64,
-    buffer: &mut IoBuffer,
-    offset: usize,
-    size: usize,
-) -> Result<()> {
-    let data = &mut buffer.get()[offset..][..size];
-    assert!(is_buffer_aligned(data, io.as_block_io().alignment().into())?);
-    assert!(is_aligned(size.into(), io.as_block_io().block_size().into())?);
-    Ok(match io {
-        BlockDeviceIo::Blocking(io) => io.write_blocks(blk_offset, data),
-        BlockDeviceIo::NonBlocking(io) => {
-            let ptr = buffer.set_pending(offset, size);
-            // SAFETY:
-            // * `buffer.set_pending()` makes sure that no safe code can use the buffer until it is
-            //   set ready by `IoBuffer::update_status()` when status is no longer
-            //   `IoStatus::Pending`.
-            // * When going out of scope, `IoBuffer` checks whether the buffer is still pending and
-            //   will panic if it is. Thus the buffer will remain valid with no other references
-            //   during the non-blocking IO.
-            unsafe { (*io).write_blocks(blk_offset, ptr) }
-        }
-    }?)
-}
-
-/// A helper to read data from a block device to an IO buffer.
-fn read_io_buffer(
-    io: &mut BlockDeviceIo,
-    blk_offset: u64,
-    buffer: &mut IoBuffer,
-    offset: usize,
-    size: usize,
-) -> Result<()> {
-    let out = &mut buffer.get()[offset..][..size];
-    assert!(is_buffer_aligned(out, io.as_block_io().alignment().into())?);
-    assert!(is_aligned(size.into(), io.as_block_io().block_size().into())?);
-    Ok(match io {
-        BlockDeviceIo::Blocking(io) => io.read_blocks(blk_offset, out),
-        BlockDeviceIo::NonBlocking(io) => {
-            let ptr = buffer.set_pending(offset, size);
-            // SAFETY:
-            // * `buffer.set_pending()` makes sure that no safe code can use the buffer until it is
-            //   set ready by `IoBuffer::update_status()` when status is no longer
-            //   `IoStatus::Pending`.
-            // * When going out of scope, `IoBuffer` checks whether the buffer is still pending and
-            //   will panic if it is. Thus the buffer will remain valid with no other references
-            //   during the non-blocking IO.
-            unsafe { (*io).read_blocks(blk_offset, ptr) }
-        }
-    }?)
-}
-
-#[cfg(test)]
-mod test {
-    use gbl_storage_testlib::{TestBlockDeviceBuilder, TimestampPauser};
-
-    #[test]
-    fn test_read() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_data(&[1, 2, 3, 4])
-            .build();
-        let mut io_buffer = [1, 0, 0, 1];
-        let mut to_write = Some(&mut io_buffer[..]);
-        {
-            let timestamp_pauser = TimestampPauser::new();
-            let mut blk_ex = blk.as_block_device_ex();
-            blk_ex.write(1, &mut to_write, 1, 2).unwrap();
-            assert!(to_write.is_none());
-            // Timestamp paused. IO not being processed. poll() should return false.
-            blk_ex.poll();
-            assert!(blk_ex.is_pending());
-
-            timestamp_pauser.resume();
-            blk_ex.sync().unwrap();
-            blk_ex.poll();
-        }
-        assert_eq!(blk.io.storage, [1, 0, 0, 4]);
-    }
-
-    #[test]
-    fn test_write() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_data(&[1, 2, 3, 4])
-            .build();
-        let mut io_buffer = [1, 0, 0, 1];
-        let mut to_read = Some(&mut io_buffer[..]);
-        {
-            let timestamp_pauser = TimestampPauser::new();
-            let mut blk_ex = blk.as_block_device_ex();
-            blk_ex.read(1, &mut to_read, 1, 2).unwrap();
-            assert!(to_read.is_none());
-            // Timestamp paused. IO not being processed.
-            blk_ex.poll();
-            assert!(blk_ex.is_pending());
-
-            timestamp_pauser.resume();
-            blk_ex.sync().unwrap();
-            blk_ex.poll();
-        }
-        assert_eq!(io_buffer, [1, 2, 3, 1]);
-    }
-
-    #[test]
-    fn test_read_write_blocking() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_data(&[1, 2, 3, 4])
-            .build();
-
-        let mut io_buffer = [0u8; 2];
-        blk.as_block_device_ex().read_blocking(1, &mut io_buffer[..]).unwrap();
-        assert_eq!(io_buffer, [2, 3]);
-
-        let mut io_buffer = [0u8; 2];
-        blk.as_block_device_ex().write_blocking(1, &mut io_buffer[..]).unwrap();
-        assert_eq!(blk.io.storage, [1, 0, 0, 4]);
-    }
-
-    #[test]
-    fn test_abort() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_data(&[1, 2, 3, 4])
-            .build();
-        let mut io_buffer = [1, 0, 0, 1];
-        let mut to_write = Some(&mut io_buffer[..]);
-        {
-            let _ = TimestampPauser::new();
-            let mut blk_ex = blk.as_block_device_ex();
-            blk_ex.write(1, &mut to_write, 1, 2).unwrap();
-            blk_ex.abort().unwrap();
-            blk_ex.sync().unwrap();
-            assert!(blk_ex.is_aborted())
-        }
-        assert_eq!(blk.io.storage, [1, 2, 3, 4]);
-
-        let mut to_read = Some(&mut io_buffer[..]);
-        {
-            let _ = TimestampPauser::new();
-            let mut blk_ex = blk.as_block_device_ex();
-            blk_ex.read(1, &mut to_read, 1, 2).unwrap();
-            blk_ex.abort().unwrap();
-            blk_ex.sync().unwrap();
-            assert!(blk_ex.is_aborted())
-        }
-        assert_eq!(io_buffer, [1, 0, 0, 1]);
-    }
-
-    #[test]
-    fn read_write_error_on_busy() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_data(&[1, 2, 3, 4])
-            .build();
-        let mut io_buffer = [1, 0, 0, 1];
-        let mut to_write = Some(&mut io_buffer[..]);
-
-        let mut io_buffer_other = [0u8; 4];
-        let mut io_other_ref = Some(&mut io_buffer_other[..]);
-        {
-            let _ = TimestampPauser::new();
-            let mut blk_ex = blk.as_block_device_ex();
-            blk_ex.write(1, &mut to_write, 1, 2).unwrap();
-            assert!(blk_ex.write(1, &mut io_other_ref, 1, 2).is_err());
-            assert!(io_other_ref.is_some());
-            assert!(blk_ex.read(1, &mut io_other_ref, 1, 2).is_err());
-            assert!(io_other_ref.is_some());
-        }
-    }
-}
diff --git a/gbl/libstorage/src/testlib.rs b/gbl/libstorage/src/testlib.rs
index 25a6219..246dd3f 100644
--- a/gbl/libstorage/src/testlib.rs
+++ b/gbl/libstorage/src/testlib.rs
@@ -11,65 +11,18 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-use core::cell::RefCell;
+
+//! Utilities for writing tests with libstorage, e.g. creating fake block devices.
+
 use crc32fast::Hasher;
-pub use gbl_storage::{
-    alignment_scratch_size, is_aligned, is_buffer_aligned, required_scratch_size, AsBlockDevice,
-    AsMultiBlockDevices, BlockDeviceEx, BlockInfo, BlockIo, BlockIoError, GptEntry, GptHeader,
-    IoStatus, NonBlockingBlockIo, GPT_MAGIC, GPT_NAME_LEN_U16,
-};
+use gbl_async::yield_now;
+pub use gbl_storage::*;
+use liberror::{Error, Result};
 use safemath::SafeNum;
-use std::collections::BTreeMap;
+use std::collections::{BTreeMap, VecDeque};
 use zerocopy::AsBytes;
 
-// Declares a per-thread global instance of timestamp. The timestamp is used to control the
-// execution of non-blocking IO.
-thread_local! {
-    static TIMESTAMP: RefCell<u64> = RefCell::new(Default::default());
-    /// Number of `TimestampPauser` in effect.
-    static NUM_TIMESTAMP_PAUSER: RefCell<u64> = RefCell::new(Default::default());
-}
-
-/// Increases the value of timestamp.
-pub fn advance_timestamp() {
-    TIMESTAMP.with(|ts| (*ts.borrow_mut()) += 1);
-}
-
-/// Queries the current value of timestamp.
-pub fn query_timestamp() -> u64 {
-    NUM_TIMESTAMP_PAUSER.with(|v| (*v.borrow() == 0).then(|| advance_timestamp()));
-    TIMESTAMP.with(|ts| *ts.borrow())
-}
-
-/// When a `TimestampPauser` is in scope, timestamp will not be increased by query.
-pub struct TimestampPauser {}
-
-impl Drop for TimestampPauser {
-    fn drop(&mut self) {
-        NUM_TIMESTAMP_PAUSER.with(|v| *v.borrow_mut() -= 1);
-    }
-}
-
-impl TimestampPauser {
-    /// Creates a new instance to pause the timestamp.
-    pub fn new() -> Self {
-        NUM_TIMESTAMP_PAUSER.with(|v| *v.borrow_mut() += 1);
-        Self {}
-    }
-
-    /// Consumes the pauser, causing it to go out of scope. When all pausers go out of scope,
-    /// timestamp resumes.
-    pub fn resume(self) {}
-}
-
-/// `NonBlockingIoState` tracks the non-blocking IO state.
-enum NonBlockingIoState {
-    // (timestamp when initiated, blk offset, buffer, is read)
-    Pending(u64, u64, &'static mut [u8], bool),
-    Ready(IoStatus),
-}
-
-/// Helper `gbl_storage::BlockIo` struct for TestBlockDevice.
+/// Helper `gbl_storage::BlockIoSync` struct for TestBlockDevice.
 pub struct TestBlockIo {
     /// The storage block size in bytes.
     pub block_size: u64,
@@ -81,45 +34,30 @@ pub struct TestBlockIo {
     pub num_writes: usize,
     /// The number of successful read calls.
     pub num_reads: usize,
-    /// Pending non-blocking IO
-    io: Option<NonBlockingIoState>,
+    /// Injected errors.
+    pub errors: VecDeque<Error>,
 }
 
 impl TestBlockIo {
+    /// Creates a new [TestBlockIo].
     pub fn new(block_size: u64, alignment: u64, data: Vec<u8>) -> Self {
-        Self { block_size, alignment, storage: data, num_writes: 0, num_reads: 0, io: None }
+        Self {
+            block_size,
+            alignment,
+            storage: data,
+            num_writes: 0,
+            num_reads: 0,
+            errors: Default::default(),
+        }
     }
 
     fn check_alignment(&mut self, buffer: &[u8]) -> bool {
-        matches!(is_buffer_aligned(buffer, self.alignment()), Ok(true))
-            && matches!(is_aligned(buffer.len().into(), self.block_size().into()), Ok(true))
+        matches!(is_buffer_aligned(buffer, self.alignment), Ok(true))
+            && matches!(is_aligned(buffer.len().into(), self.block_size.into()), Ok(true))
     }
 }
 
-impl BlockIo for TestBlockIo {
-    fn info(&mut self) -> BlockInfo {
-        NonBlockingBlockIo::info(self)
-    }
-
-    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), BlockIoError> {
-        // `BlockIo` is implemented for `&mut dyn NonBlockingBlockIo`
-        BlockIo::read_blocks(&mut (self as &mut dyn NonBlockingBlockIo), blk_offset, out)
-    }
-
-    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), BlockIoError> {
-        BlockIo::write_blocks(&mut (self as &mut dyn NonBlockingBlockIo), blk_offset, data)
-    }
-}
-
-// SAFETY:
-// * When `TestBlockIo::io` is `Some(NonBlockingIoState(Pending(_, _, buffer, _)))`,
-//   `check_status()` always returns `IoStatus::Pending`. `check_status()` returns other `IoStatus`
-//   values if and only if `TestBlockIo::io` is not `Some(NonBlockingIoState(Pending())`, in which
-//   case the buffer is not tracked anymore and thus will not be retained again.
-// * `Self::check_status()` does not dereference the input pointer.
-// * `TestBlockIo::io` is set to `Some(NonBlockingIoState(Pending(_, _, buffer, _)))` and retains
-//   the buffer only on success (returning Ok(())).
-unsafe impl NonBlockingBlockIo for TestBlockIo {
+impl BlockIoAsync for TestBlockIo {
     /// Returns a `BlockInfo` for the block device.
     fn info(&mut self) -> BlockInfo {
         BlockInfo {
@@ -129,97 +67,36 @@ unsafe impl NonBlockingBlockIo for TestBlockIo {
         }
     }
 
-    unsafe fn write_blocks(
-        &mut self,
-        blk_offset: u64,
-        buffer: *mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        match self.io {
-            Some(_) => Err(BlockIoError::MediaBusy),
-            _ => {
-                self.num_writes += 1;
-                // SAFETY: By safety requirement, trait implementation can retain the buffer until
-                // it no longer returns `IoStatus::Pending` in `Self::check_status()`.
-                let buffer = unsafe { &mut *buffer };
-                assert!(self.check_alignment(buffer));
-                self.io =
-                    Some(NonBlockingIoState::Pending(query_timestamp(), blk_offset, buffer, false));
-                Ok(())
-            }
+    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
+        assert!(self.check_alignment(out));
+        let offset = (SafeNum::from(blk_offset) * self.block_size).try_into().unwrap();
+        yield_now().await; // yield once to simulate IO pending.
+        match self.errors.pop_front() {
+            Some(e) => Err(e),
+            _ => Ok(out.clone_from_slice(&self.storage[offset..][..out.len()])),
         }
     }
 
-    unsafe fn read_blocks(
-        &mut self,
-        blk_offset: u64,
-        buffer: *mut [u8],
-    ) -> core::result::Result<(), BlockIoError> {
-        match self.io {
-            Some(_) => Err(BlockIoError::MediaBusy),
-            _ => {
-                self.num_reads += 1;
-                // SAFETY: By safety requirement, trait implementation can retain the buffer until
-                // it no longer returns `IoStatus::Pending` in `Self::check_status()`.
-                let buffer = unsafe { &mut *buffer };
-                assert!(self.check_alignment(buffer));
-                self.io =
-                    Some(NonBlockingIoState::Pending(query_timestamp(), blk_offset, buffer, true));
-                Ok(())
-            }
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
+        assert!(self.check_alignment(data));
+        let offset = (SafeNum::from(blk_offset) * self.block_size).try_into().unwrap();
+        yield_now().await; // yield once to simulate IO pending.
+        match self.errors.pop_front() {
+            Some(e) => Err(e),
+            _ => Ok(self.storage[offset..][..data.len()].clone_from_slice(data)),
         }
     }
-
-    fn check_status(&mut self, buf: *mut [u8]) -> IoStatus {
-        match self.io.as_mut() {
-            Some(NonBlockingIoState::Pending(ts, blk_offset, ref mut buffer, is_read))
-                if std::ptr::eq(*buffer as *const [u8], buf as _) =>
-            {
-                // Executes the IO if current timestamp is newer.
-                if query_timestamp() > *ts {
-                    let offset = (SafeNum::from(*blk_offset) * self.block_size).try_into().unwrap();
-                    match is_read {
-                        true => buffer.clone_from_slice(&self.storage[offset..][..buffer.len()]),
-                        _ => self.storage[offset..][..buffer.len()].clone_from_slice(buffer),
-                    }
-                    self.io = Some(NonBlockingIoState::Ready(IoStatus::Completed));
-                }
-                IoStatus::Pending
-            }
-            Some(NonBlockingIoState::Ready(v)) => {
-                let res = *v;
-                self.io.take();
-                res
-            }
-            _ => IoStatus::NotFound,
-        }
-    }
-
-    fn abort(&mut self) -> core::result::Result<(), BlockIoError> {
-        match self.io {
-            Some(NonBlockingIoState::Pending(_, _, _, _)) => {
-                self.io = Some(NonBlockingIoState::Ready(IoStatus::Aborted));
-            }
-            _ => {}
-        }
-        Ok(())
-    }
 }
 
 /// Simple RAM based block device used by unit tests.
 pub struct TestBlockDevice {
-    /// The BlockIo helper struct.
+    /// The mock block device.
     pub io: TestBlockIo,
     /// In-memory backing store.
     pub scratch: Vec<u8>,
     max_gpt_entries: u64,
 }
 
-impl TestBlockDevice {
-    pub fn as_block_device_ex(&mut self) -> BlockDeviceEx {
-        BlockDeviceEx::new((&mut self.io as &mut dyn NonBlockingBlockIo).into())
-    }
-}
-
 impl From<&[u8]> for TestBlockDevice {
     fn from(data: &[u8]) -> Self {
         TestBlockDeviceBuilder::new().set_data(data).build()
@@ -227,7 +104,7 @@ impl From<&[u8]> for TestBlockDevice {
 }
 
 impl AsBlockDevice for TestBlockDevice {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIo, &mut [u8], u64)) {
+    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
         f(&mut self.io, &mut self.scratch[..], self.max_gpt_entries)
     }
 }
@@ -238,12 +115,31 @@ impl Default for TestBlockDevice {
     }
 }
 
+impl TestBlockDevice {
+    /// Creates an instance of `AsyncGptDevice`
+    pub fn as_gpt_dev(&mut self) -> AsyncGptDevice<'_, &mut TestBlockIo> {
+        AsyncGptDevice::<&mut TestBlockIo>::new_from_monotonic_buffer(
+            &mut self.io,
+            &mut self.scratch[..],
+            self.max_gpt_entries,
+        )
+        .unwrap()
+    }
+
+    /// Creates an instance of `AsyncBlockDevice`
+    pub fn as_blk_dev(&mut self) -> AsyncBlockDevice<'_, &mut TestBlockIo> {
+        self.as_gpt_dev().into_blk_and_gpt().0
+    }
+}
+
 /// A description of the backing data store for a block device or partition.
 /// Can either describe explicit data the device or partition is initialized with
 /// OR a size in bytes if the device or partition can be initialized in a blank state.
 #[derive(Copy, Clone)]
 pub enum BackingStore<'a> {
+    /// Exact data to use for the storage.
     Data(&'a [u8]),
+    /// Data size to use, will be initialized as zeros.
     Size(usize),
 }
 
@@ -396,11 +292,13 @@ impl<'a> TestBlockDeviceBuilder<'a> {
                 partitions_to_disk_data(&partitions, self.block_size as usize)
             }
         };
-        assert!(storage.len() % (self.block_size as usize) == 0);
+        assert_eq!(storage.len() % (self.block_size as usize), 0);
         let mut io = TestBlockIo::new(self.block_size, self.alignment, storage);
         let scratch_size = match self.scratch_size {
             Some(s) => s,
-            None => required_scratch_size(&mut io, self.max_gpt_entries).unwrap(),
+            None => {
+                required_scratch_size(BlockIoSync::info(&mut io), self.max_gpt_entries).unwrap()
+            }
         };
         TestBlockDevice {
             io,
@@ -537,17 +435,10 @@ fn partitions_to_disk_data(
 /// Simple RAM based multi-block device used for unit tests.
 pub struct TestMultiBlockDevices(pub Vec<TestBlockDevice>);
 
-impl AsMultiBlockDevices for TestMultiBlockDevices {
-    fn for_each(
-        &mut self,
-        f: &mut dyn FnMut(&mut dyn AsBlockDevice, u64),
-    ) -> core::result::Result<(), Option<&'static str>> {
-        let _ = self
-            .0
-            .iter_mut()
-            .enumerate()
-            .for_each(|(idx, ele)| f(ele, u64::try_from(idx).unwrap()));
-        Ok(())
+impl TestMultiBlockDevices {
+    /// Creates a vector of `AsyncGptDevice`;
+    pub fn as_gpt_devs(&mut self) -> Vec<AsyncGptDevice<&mut TestBlockIo>> {
+        self.0.iter_mut().map(|v| v.as_gpt_dev()).collect::<Vec<_>>()
     }
 }
 
diff --git a/gbl/patches/rust-libcompiler-builtins-enable-chkstk-on-uefi.patch b/gbl/patches/rust-libcompiler-builtins-enable-chkstk-on-uefi.patch
deleted file mode 100644
index 9153f6e..0000000
--- a/gbl/patches/rust-libcompiler-builtins-enable-chkstk-on-uefi.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- /tmp/x86.rs	2024-04-25 23:47:26.697256628 +0000
-+++ x86.rs	2024-04-25 23:47:33.253251743 +0000
-@@ -11,8 +11,7 @@
- intrinsics! {
-     #[naked]
-     #[cfg(all(
--        windows,
--        target_env = "gnu",
-+        any(all(windows, target_env = "gnu"), target_os = "uefi"),
-         not(feature = "no-asm")
-     ))]
-     pub unsafe extern "C" fn ___chkstk_ms() {
-@@ -41,8 +40,7 @@
-     // FIXME: __alloca should be an alias to __chkstk
-     #[naked]
-     #[cfg(all(
--        windows,
--        target_env = "gnu",
-+        any(all(windows, target_env = "gnu"), target_os = "uefi"),
-         not(feature = "no-asm")
-     ))]
-     pub unsafe extern "C" fn __alloca() {
-@@ -54,8 +52,7 @@
-
-     #[naked]
-     #[cfg(all(
--        windows,
--        target_env = "gnu",
-+        any(all(windows, target_env = "gnu"), target_os = "uefi"),
-         not(feature = "no-asm")
-     ))]
-     pub unsafe extern "C" fn ___chkstk() {
diff --git a/gbl/readme.bzl b/gbl/readme.bzl
index cc8bdc9..515a2ee 100644
--- a/gbl/readme.bzl
+++ b/gbl/readme.bzl
@@ -51,6 +51,8 @@ fi
 
 ALL_INPUTS=$(echo ${INPUT} | sed 's/,/ /g')
 
+# Look for protocols in the source code that do not exist in the documentation.
+# The protocol name we match on here is the Rust struct name.
 DOCLESS_PROTOCOLS=""
 PROTOCOLS=($(grep -hE 'impl ProtocolInfo for .* \\{' ${ALL_INPUTS} | awk '{print $4}' | sort))
 for P in ${PROTOCOLS[@]}
@@ -63,8 +65,11 @@ if [ ! -z "${DOCLESS_PROTOCOLS}" ]; then
   exit 1
 fi
 
+# Look for protocols in the documentation that are not in the source, to try to
+# prevent stale docs referring to protocols we are no longer using.
+# Here we're matching on words ending in "Protocol", except "Protocol" itself.
 UNUSED_PROTOCOLS=""
-README_PROTOCOLS=($(grep -P " ?.*?Protocol$" ${README} | awk '{print $NF}' | sort | uniq))
+README_PROTOCOLS=($(grep -P " ?[^ ]+Protocol$" ${README} | awk '{print $NF}' | sort | uniq))
 for P in ${README_PROTOCOLS[@]}
 do
   grep -qhE "impl ProtocolInfo for $P" ${ALL_INPUTS} || UNUSED_PROTOCOLS+="\n\t$P"
diff --git a/gbl/tests/BUILD b/gbl/tests/BUILD
index e51b5cd..a20eccd 100644
--- a/gbl/tests/BUILD
+++ b/gbl/tests/BUILD
@@ -16,14 +16,22 @@ test_suite(
     name = "tests",
     tests = [
         "@gbl//:readme_test",
+        "@gbl//efi:test",
         "@gbl//libabr:libabr_tests",
+        "@gbl//libasync:cyclic_executor_test",
+        "@gbl//libasync:libasync_test",
         "@gbl//libbootconfig:libbootconfig_test",
         "@gbl//libbootimg:libbootimg_test",
+        "@gbl//libc:libc_test",
+        "@gbl//libdttable:libdttable_test",
         "@gbl//libefi:libefi_test",
+        "@gbl//libefi:mocks_test",
+        "@gbl//libefi_types:libefi_types_test",
+        "@gbl//liberror:liberror_test",
         "@gbl//libfastboot:libfastboot_test",
         "@gbl//libfdt:libfdt_test",
-        "@gbl//libgbl:integration_test",
         "@gbl//libgbl:libgbl_test",
+        "@gbl//libmisc:libmisc_test",
         "@gbl//libsafemath:libsafemath_test",
         "@gbl//libstorage:libstorage_doc_test",
         "@gbl//libstorage:libstorage_test",
diff --git a/gbl/third_party/libzbi/Cargo.toml b/gbl/third_party/libzbi/Cargo.toml
deleted file mode 100644
index 3141bb7..0000000
--- a/gbl/third_party/libzbi/Cargo.toml
+++ /dev/null
@@ -1,11 +0,0 @@
-[package]
-name = "zbi"
-version = "0.1.0"
-edition = "2021"
-
-[dependencies]
-zerocopy = { version = "0.7.11", default-features = false, features = ["derive"] }
-bitflags = "1"
-
-[dev-dependencies]
-hex = "0"
diff --git a/gbl/third_party/libzbi/README.md b/gbl/third_party/libzbi/README.md
index 858b5a5..f659781 100644
--- a/gbl/third_party/libzbi/README.md
+++ b/gbl/third_party/libzbi/README.md
@@ -24,7 +24,7 @@ To get just `zbi-rs` from Fuchsia following commands can be used:
 git clone -n --depth=1 --filter=tree:0 sso://fuchsia/fuchsia
 cd fuchsia/
 git sparse-checkout set --no-clone src/firmware/lib/zbi-rs
-git checkout 74345229e91646568d27c481e24ae53efb280dca
+git checkout 5f37c4635b672076b289dec4f01b7bd4bf147640
 ```
 
 Changing Licence in source files is required at the moment.
diff --git a/gbl/third_party/libzbi/src/lib.rs b/gbl/third_party/libzbi/src/lib.rs
index 529a87d..69e941f 100644
--- a/gbl/third_party/libzbi/src/lib.rs
+++ b/gbl/third_party/libzbi/src/lib.rs
@@ -1,4 +1,4 @@
-// Copyright 2023, The Android Open Source Project
+// Copyright 2024, The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -46,11 +46,9 @@
 mod zbi_format;
 
 use bitflags::bitflags;
-use core::{
-    fmt::{Debug, Display, Formatter},
-    mem::{size_of, take},
-    ops::DerefMut,
-};
+use core::fmt::{Debug, Display, Formatter};
+use core::mem::{size_of, take};
+use core::ops::DerefMut;
 use zbi_format::*;
 use zerocopy::{AsBytes, ByteSlice, ByteSliceMut, Ref};
 
@@ -303,6 +301,11 @@ impl<B: ByteSlice> ZbiContainer<B> {
         self.payload_length
     }
 
+    /// Returns the total size including the ZBI container header, payload length after padding.
+    pub fn container_size(&self) -> usize {
+        self.get_payload_length_usize() + size_of::<ZbiHeader>()
+    }
+
     /// Immutable iterator over ZBI elements. First element is first ZBI element after
     /// container header. Container header is not available via iterator.
     pub fn iter(&self) -> ZbiContainerIterator<impl ByteSlice + Default + Debug + PartialEq + '_> {
@@ -316,25 +319,56 @@ impl<B: ByteSlice> ZbiContainer<B> {
     ///
     /// # Returns
     ///
-    /// * `Ok(())` - if bootable
+    /// * `Ok(item)` - if bootable, where `item` is the ZBI kernel item.
     /// * Err([`ZbiError::IncompleteKernel`]) - if first element in container has type not bootable
     ///                                         on target platform.
     /// * Err([`ZbiError::Truncated`]) - if container is empty
-    pub fn is_bootable(&self) -> ZbiResult<()> {
+    pub fn is_bootable(
+        &self,
+    ) -> ZbiResult<ZbiItem<impl ByteSlice + Default + Debug + PartialEq + '_>> {
         let hdr = &self.header;
         if hdr.length == 0 {
             return Err(ZbiError::Truncated);
         }
 
         match self.iter().next() {
-            Some(ZbiItem { header, payload: _ }) if header.type_ == ZBI_ARCH_KERNEL_TYPE as u32 => {
-                Ok(())
-            }
+            Some(v) if v.header.type_ == ZBI_ARCH_KERNEL_TYPE as u32 => Ok(v),
             Some(_) => Err(ZbiError::IncompleteKernel),
             None => Err(ZbiError::Truncated),
         }
     }
 
+    /// Returns the ZBI kernel `entry` and `reserved_memory_size` field value if the container is a
+    /// bootable ZBI kernel.
+    ///
+    /// # Returns
+    ///
+    /// * Returns `Ok((entry, reserved_memory_size))` on success.
+    /// * Returns `Err` if container is not a bootable ZBI kernel or is truncated.
+    pub fn get_kernel_entry_and_reserved_memory_size(&self) -> ZbiResult<(u64, u64)> {
+        let kernel = self.is_bootable()?;
+        let vals = Ref::<_, [u64]>::new_slice_from_prefix(kernel.payload, 2)
+            .ok_or(ZbiError::IncompleteKernel)?
+            .0
+            .into_slice();
+        Ok((vals[0], vals[1]))
+    }
+
+    /// Computes the required buffer size needed for relocating this ZBI kernel.
+    ///
+    /// # Returns
+    ///
+    /// * Returns `Ok(size)` on success.
+    /// * Returns `Err` if container is not a valid bootable ZBI kernel.
+    pub fn get_buffer_size_for_kernel_relocation(&self) -> ZbiResult<usize> {
+        let kernel = self.is_bootable()?;
+        let (_, reserve_memory_size) = self.get_kernel_entry_and_reserved_memory_size()?;
+        let kernel_size = 2 * size_of::<ZbiHeader>() + kernel.payload.as_bytes().len();
+        let reserve_memory_size =
+            usize::try_from(reserve_memory_size).map_err(|_| ZbiError::LengthOverflow)?;
+        kernel_size.checked_add(reserve_memory_size).ok_or(ZbiError::LengthOverflow)
+    }
+
     /// Creates `ZbiContainer` from provided buffer.
     ///
     /// Buffer must be aligned to [`ZBI_ALIGNMENT_USIZE`] ([`align_buffer`] could be
@@ -633,6 +667,28 @@ impl<B: ByteSliceMut + PartialEq> ZbiContainer<B> {
         }
         Ok(())
     }
+
+    /// Extends with another ZBI container stored on a potentially unaligned buffer.
+    ///
+    /// The method copies `other` into the unused space first before checking validity and
+    /// extending. Thus if `other.len()` is greater than the remaining space in the container, it
+    /// it will be rejected, regardless of the actual container size.
+    pub fn extend_unaligned(&mut self, other: &[u8]) -> ZbiResult<()> {
+        let sz = self.get_payload_length_usize();
+        let remains = &mut self.buffer[sz..];
+        // Copies `other` to `dst` which is guaranteed aligned.
+        let dst = remains.get_mut(..other.len()).ok_or(ZbiError::TooBig)?;
+        dst.clone_from_slice(other);
+        // Checks the incoming container and extracts payload length (without padding).
+        let new_payload_len = ZbiContainer::parse(&mut dst[..])?.header.length;
+        // Shifts forward the payload to remove the ZBI header. This effectively appends the
+        // payload.
+        dst.copy_within(size_of::<ZbiHeader>().., 0);
+        self.set_payload_length_usize(
+            sz + usize::try_from(new_payload_len).map_err(|_| ZbiError::LengthOverflow)?,
+        )?;
+        self.align_tail()
+    }
 }
 
 impl<B: ByteSlice + PartialEq + DerefMut> ZbiContainer<B> {
@@ -755,7 +811,7 @@ pub enum ZbiType {
 
     /// Device-specific factory data, stored in BOOTFS format.
     //
-    // TODO(fxbug.dev/34597): This should not use the "STORAGE" infix.
+    // TODO(fxbug.dev/42109921): This should not use the "STORAGE" infix.
     //
     // 'BFSF'
     StorageBootFsFactory = ZBI_TYPE_STORAGE_BOOTFS_FACTORY,
@@ -1085,7 +1141,7 @@ impl ZbiHeader {
 /// The kernel assumes it was loaded at a fixed physical address of
 /// 0x100000 (1MB).  `ZbiKernel.entry` is the absolute physical address
 /// of the PC location where the kernel will start.
-/// TODO(fxbug.dev/24762): Perhaps this will change??
+/// TODO(https://fxbug.dev/42098994): Perhaps this will change??
 /// The processor is in 64-bit mode with direct virtual to physical
 /// mapping covering the physical memory where the kernel and
 /// bootloader-constructed ZBI were loaded.
@@ -1128,7 +1184,7 @@ impl ZbiHeader {
 /// ```
 pub type ZbiKernel = zbi_kernel_t;
 
-#[derive(Debug, PartialEq)]
+#[derive(Debug, PartialEq, Eq)]
 /// Error values that can be returned by function in this library
 pub enum ZbiError {
     /// Generic error
@@ -1202,6 +1258,43 @@ fn is_zbi_aligned(buffer: &impl ByteSlice) -> ZbiResult<()> {
     }
 }
 
+/// Merges two ZBI containers stored on the same buffer.
+///
+/// A typical use scenario is when the caller wants to append ZBI items that need to borrow the
+/// existing container in order to be created, but wants to resuse the unused buffer for memory
+/// optimization. The caller can split out the unused buffer, borrow the existing container,
+/// creates a new container in the unused buffer, and then use this API to merge them together.
+///
+/// # Args:
+///
+/// * `buffer`: The buffer that contains the two ZBI containers. The first container must start
+///   from the beginning.
+/// * `second_start`: The offset to the second container in the buffer. The offset must be aligned
+///   to `ZBI_ALIGNMENT_USIZE`.
+///
+/// # Returns
+///
+/// * On success returns an instance of `ZbiContainer` representing the merged container.
+pub fn merge_within(buffer: &mut [u8], second_start: usize) -> ZbiResult<ZbiContainer<&mut [u8]>> {
+    let first_container_size = ZbiContainer::parse(&mut buffer[..])?.container_size();
+    if first_container_size > second_start {
+        return Err(ZbiError::Error);
+    }
+    let second_payload_len =
+        ZbiContainer::parse(&mut buffer[second_start..])?.get_payload_length_usize();
+    // Copies the payload part directly to the end of the first container.
+    let second_payload_start = second_start + size_of::<ZbiHeader>();
+    let second_payload_end = second_payload_start + second_payload_len;
+    buffer.copy_within(second_payload_start..second_payload_end, first_container_size);
+    // Updates first ZBI header length
+    let hdr = Ref::<_, ZbiHeader>::new_from_prefix(&mut buffer[..]).unwrap().0.into_mut();
+    hdr.length = hdr
+        .length
+        .checked_add(u32::try_from(second_payload_len).unwrap())
+        .ok_or(ZbiError::LengthOverflow)?;
+    ZbiContainer::parse(buffer)
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -1305,13 +1398,13 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_align_overflow() {
+    fn test_zbi_align_overflow() {
         assert!(usize::MAX > ZBI_ALIGNMENT.try_into().unwrap());
         assert_eq!(u32::try_from(ZBI_ALIGNMENT_USIZE).unwrap(), ZBI_ALIGNMENT);
     }
 
     #[test]
-    fn zbi_test_item_new() {
+    fn test_zbi_item_new() {
         let mut buffer = ZbiAligned::default();
         let expect = get_test_zbi_headers(1)[0];
 
@@ -1339,7 +1432,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_item_new_too_small() {
+    fn test_zbi_item_new_too_small() {
         let mut buffer = ZbiAligned::default();
 
         assert_eq!(
@@ -1355,7 +1448,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_item_new_not_aligned() {
+    fn test_zbi_item_new_not_aligned() {
         let mut buffer = ZbiAligned::default();
         for offset in [1, 2, 4] {
             assert_eq!(
@@ -1372,7 +1465,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_item_parse() {
+    fn test_zbi_item_parse() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
         let buffer_hdr_extra_expected =
@@ -1384,7 +1477,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_item_edit() {
+    fn test_zbi_item_edit() {
         let mut buffer = ZbiAligned::default();
         let buffer_build = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
         let buffer_hdr_type =
@@ -1399,7 +1492,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new() {
+    fn test_zbi_container_new() {
         let mut buffer = ZbiAligned::default();
         let _container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
         let expect_hdr = ZbiHeader {
@@ -1418,13 +1511,13 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_too_small() {
+    fn test_zbi_container_new_too_small() {
         let mut buffer = ZbiAligned::default();
         assert_eq!(ZbiContainer::new(&mut buffer.0[..ZBI_HEADER_SIZE - 1]), Err(ZbiError::TooBig));
     }
 
     #[test]
-    fn zbi_test_container_new_unaligned() {
+    fn test_zbi_container_new_unaligned() {
         let mut buffer = ZbiAligned::default();
         for offset in [1, 2, 3, 4, 5, 6, 7] {
             assert_eq!(
@@ -1435,7 +1528,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_empty() {
+    fn test_zbi_container_parse_empty() {
         let mut buffer = ZbiAligned::default();
         let _container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
         let expect_hdr = ZbiHeader {
@@ -1455,7 +1548,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_type() {
+    fn test_zbi_container_parse_bad_type() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .item(
@@ -1476,7 +1569,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_magic() {
+    fn test_zbi_container_parse_bad_magic() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .item(
@@ -1497,7 +1590,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_version() {
+    fn test_zbi_container_parse_bad_version() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .item(
@@ -1518,7 +1611,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_crc32() {
+    fn test_zbi_container_parse_bad_crc32() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .item(
@@ -1539,7 +1632,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_entries_bad_magic() {
+    fn test_zbi_container_parse_entries_bad_magic() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .item(
@@ -1560,7 +1653,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse() {
+    fn test_zbi_container_parse() {
         let expected_payloads: [&[u8]; 9] = [
             &[1],
             &[1, 2],
@@ -1600,7 +1693,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_unaligned() {
+    fn test_zbi_container_parse_unaligned() {
         let buffer = ZbiAligned::default();
         for offset in [1, 2, 3, 4, 5, 6, 7] {
             assert_eq!(ZbiContainer::parse(&buffer.0[offset..]), Err(ZbiError::BadAlignment));
@@ -1608,7 +1701,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_without_last_padding_fail_truncated() {
+    fn test_zbi_container_parse_without_last_padding_fail_truncated() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1623,7 +1716,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_error_payload_truncated() {
+    fn test_zbi_container_parse_error_payload_truncated() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1635,7 +1728,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_error_truncated() {
+    fn test_zbi_container_parse_error_truncated() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1647,7 +1740,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_first_entry_marked() {
+    fn test_zbi_container_parse_bad_first_entry_marked() {
         let mut buffer = get_test_creference_buffer();
         let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
 
@@ -1662,7 +1755,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_entry_magic() {
+    fn test_zbi_container_parse_bad_entry_magic() {
         let mut buffer = get_test_creference_buffer();
         let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
 
@@ -1675,7 +1768,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_entry_version() {
+    fn test_zbi_container_parse_bad_entry_version() {
         let mut buffer = get_test_creference_buffer();
         let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
 
@@ -1688,7 +1781,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_bad_entry_crc() {
+    fn test_zbi_container_parse_bad_entry_crc() {
         let mut buffer = get_test_creference_buffer();
         let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
 
@@ -1703,7 +1796,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry() {
+    fn test_zbi_container_new_entry() {
         let mut buffer = ZbiAligned::default();
         let new_entries = get_test_entries_all();
 
@@ -1720,7 +1813,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_crc32_not_supported() {
+    fn test_zbi_container_new_entry_crc32_not_supported() {
         let mut buffer = ZbiAligned::default();
         let (new_entry, payload) = get_test_entry_nonempty_payload();
         let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
@@ -1736,7 +1829,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_no_space_left() {
+    fn test_zbi_container_new_entry_no_space_left() {
         let mut buffer = ZbiAligned::default();
         let new_entry = get_test_entry_empty_payload().0;
 
@@ -1766,7 +1859,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_no_space_for_header() {
+    fn test_zbi_container_new_entry_no_space_for_header() {
         let mut buffer = ZbiAligned::default();
         let new_entry = get_test_entry_empty_payload().0;
 
@@ -1786,7 +1879,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_no_space_for_payload() {
+    fn test_zbi_container_new_entry_no_space_for_payload() {
         let mut buffer = ZbiAligned::default();
         let (new_entry, payload) = get_test_entry_nonempty_payload();
 
@@ -1806,7 +1899,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_with_payload_just_enough_to_fit_no_align() {
+    fn test_zbi_container_new_entry_with_payload_just_enough_to_fit_no_align() {
         let mut buffer = ZbiAligned::default();
         let (new_entry, _payload) = get_test_entry_empty_payload();
         let payload = [0; ZBI_ALIGNMENT_USIZE];
@@ -1825,7 +1918,7 @@ mod tests {
         );
     }
     #[test]
-    fn zbi_test_container_new_entry_with_payload_just_enough_to_fit_with_alignment() {
+    fn test_zbi_container_new_entry_with_payload_just_enough_to_fit_with_alignment() {
         let mut buffer = ZbiAligned::default();
         let (new_entry, payload) = get_test_entry_nonempty_payload();
         let buf_len = 2 * core::mem::size_of::<ZbiHeader>()
@@ -1844,7 +1937,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_payload_too_big() {
+    fn test_zbi_container_new_entry_payload_too_big() {
         let mut buffer = ZbiAligned::default();
         let (new_entry, _payload) = get_test_entry_nonempty_payload();
         let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
@@ -1860,7 +1953,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_no_space_left_unaligned() {
+    fn test_zbi_container_new_entry_no_space_left_unaligned() {
         let mut buffer = ZbiAligned::default();
         let new_entry = get_test_entry_empty_payload().0;
 
@@ -1890,7 +1983,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_extend_new() {
+    fn test_zbi_container_extend_new() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1926,7 +2019,66 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_extend_with_empty() {
+    fn test_zbi_container_extend_unaligned() {
+        let mut buffer_0 = ZbiAligned::default();
+        let mut container_0 = ZbiContainer::new(&mut buffer_0.0[..]).unwrap();
+        container_0
+            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"0")
+            .unwrap();
+        let container_size_0 = container_0.container_size();
+        // Copies to unaligned address.
+        let mut unaligned_0 = ZbiAligned::default();
+        let unaligned_0 = &mut unaligned_0.0[1..][..container_size_0];
+        unaligned_0.clone_from_slice(&buffer_0.0[..unaligned_0.len()]);
+
+        let mut buffer_1 = ZbiAligned::default();
+        let mut container_1 = ZbiContainer::new(&mut buffer_1.0[..]).unwrap();
+        container_1
+            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"1")
+            .unwrap();
+        let container_size_1 = container_1.container_size();
+        // Copies to unaligned address.
+        let mut unaligned_1 = ZbiAligned::default();
+        let unaligned_1 = &mut unaligned_1.0[1..][..container_size_1];
+        unaligned_1.clone_from_slice(&buffer_1.0[..unaligned_1.len()]);
+
+        let mut buffer = ZbiAligned::default();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let container_0 = ZbiContainer::parse(&mut buffer_0.0[..]).unwrap();
+        let container_1 = ZbiContainer::parse(&mut buffer_1.0[..]).unwrap();
+        container.extend_unaligned(unaligned_0).unwrap();
+        container.extend_unaligned(unaligned_1).unwrap();
+        let mut it = container.iter();
+        assert_eq!(it.next().unwrap(), container_0.iter().next().unwrap());
+        assert_eq!(it.next().unwrap(), container_1.iter().next().unwrap());
+        assert!(it.next().is_none());
+    }
+
+    #[test]
+    fn test_zbi_container_extend_unaligned_too_big() {
+        let mut buffer = ZbiAligned::default();
+        let buffer_len = buffer.0.len();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let remains = buffer_len - container.container_size();
+        let mut extend = ZbiAligned::default();
+        ZbiContainer::new(&mut extend.0[..]).unwrap();
+        container.extend_unaligned(&extend.0[..remains]).unwrap();
+        // Should fail since there is not enough space to copy the incoming buffer first, despite
+        // that the container to extend has zero payload.
+        assert!(container.extend_unaligned(&extend.0[..remains + 1]).is_err());
+    }
+
+    #[test]
+    fn test_zbi_container_extend_unaligned_invalid_container() {
+        let mut buffer = ZbiAligned::default();
+        let buffer_len = buffer.0.len();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let remains = buffer_len - container.container_size();
+        assert!(container.extend_unaligned(&vec![0u8; remains][..]).is_err());
+    }
+
+    #[test]
+    fn test_zbi_container_extend_with_empty() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1946,7 +2098,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_extend_full() {
+    fn test_zbi_container_extend_full() {
         let mut buffer = ZbiAligned::default();
         let buffer = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1968,7 +2120,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_extend_1_byte_short() {
+    fn test_zbi_container_extend_1_byte_short() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -1992,7 +2144,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_extend_use_all_buffer() {
+    fn test_zbi_container_extend_use_all_buffer() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -2017,7 +2169,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_with_payload() {
+    fn test_zbi_container_new_entry_with_payload() {
         let mut buffer = ZbiAligned::default();
         let new_entries = get_test_entries_all();
 
@@ -2056,6 +2208,10 @@ mod tests {
                     })
                     .sum::<usize>()
         );
+        assert_eq!(
+            container.container_size(),
+            container.get_payload_length_usize() + size_of::<ZbiHeader>()
+        );
 
         // Check if container elements match provided items
         let mut it = expected_items.iter();
@@ -2068,7 +2224,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_get_next_paylad() {
+    fn test_zbi_container_get_next_paylad() {
         let mut buffer = ZbiAligned::default();
         let new_entries = get_test_entries_all();
 
@@ -2087,7 +2243,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_get_next_paylad_length() {
+    fn test_zbi_container_get_next_paylad_length() {
         let mut buffer = ZbiAligned::default();
         // Expected payload length is same as buffer - container header - item header
         let expected_payload_len = buffer.0.len() - 2 * core::mem::size_of::<ZbiHeader>();
@@ -2099,7 +2255,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_get_next_paylad_only_header_can_fit() {
+    fn test_zbi_container_get_next_paylad_only_header_can_fit() {
         let mut buffer = ZbiAligned::default();
         // Buffer length that only fits container and item header.
         let len = 2 * core::mem::size_of::<ZbiHeader>();
@@ -2111,7 +2267,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_get_next_paylad_header_cant_fit() {
+    fn test_zbi_container_get_next_paylad_header_cant_fit() {
         let mut buffer = ZbiAligned::default();
         // Buffer length that only fits container but not item header.
         let len = 2 * core::mem::size_of::<ZbiHeader>() - 1;
@@ -2121,7 +2277,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_get_next_paylad_length_overflow() {
+    fn test_zbi_container_get_next_paylad_length_overflow() {
         let mut buffer = ZbiAligned::default();
         // Buffer length that only fits container but not item header.
         let len = 2 * core::mem::size_of::<ZbiHeader>() - 1;
@@ -2160,7 +2316,7 @@ mod tests {
      * +}
      */
     #[test]
-    fn zbi_test_container_parse_c_reference() {
+    fn test_zbi_container_parse_c_reference() {
         let ref_buffer = get_test_creference_buffer_vec();
         let expected_container_hdr = ZbiHeader {
             type_: ZBI_TYPE_CONTAINER,
@@ -2184,7 +2340,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_iterate() {
+    fn test_zbi_container_new_entry_iterate() {
         let mut buffer = ZbiAligned::default();
         let new_entry = get_test_entry_nonempty_payload();
 
@@ -2203,7 +2359,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_new_entry_mut_iterate() {
+    fn test_zbi_container_new_entry_mut_iterate() {
         let mut buffer = ZbiAligned::default();
         let new_entry = get_test_entry_nonempty_payload();
 
@@ -2225,7 +2381,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_parse_new_entry_mut_iterate() {
+    fn test_zbi_container_parse_new_entry_mut_iterate() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -2254,7 +2410,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_iterate_empty() {
+    fn test_zbi_container_iterate_empty() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
 
@@ -2269,7 +2425,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_iterate_ref() {
+    fn test_zbi_container_iterate_ref() {
         let mut buffer = get_test_creference_buffer();
         let container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
 
@@ -2280,7 +2436,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_container_iterate_modify() {
+    fn test_zbi_container_iterate_modify() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -2301,7 +2457,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_bad_type() {
+    fn test_zbi_bad_type() {
         assert_eq!(ZbiType::try_from(0), Err(ZbiError::BadType));
     }
 
@@ -2358,12 +2514,12 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_type_is_kernel() {
+    fn test_zbi_type_is_kernel() {
         assert!(get_kernel_zbi_types().iter().all(|t| t.is_kernel()))
     }
 
     #[test]
-    fn zbi_test_type_is_not_kernel() {
+    fn test_zbi_type_is_not_kernel() {
         assert!(get_all_zbi_type_values()
             .iter()
             .filter(|v| !get_kernel_zbi_types().contains(v))
@@ -2371,12 +2527,12 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_type_is_driver_metadata() {
+    fn test_zbi_type_is_driver_metadata() {
         assert!(get_metadata_zbi_types().iter().all(|t| t.is_driver_metadata()));
     }
 
     #[test]
-    fn zbi_test_type_is_not_driver_metadata() {
+    fn test_zbi_type_is_not_driver_metadata() {
         assert!(get_all_zbi_type_values()
             .iter()
             .filter(|v| !get_metadata_zbi_types().contains(v))
@@ -2384,12 +2540,12 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_default_type_has_version() {
+    fn test_zbi_default_type_has_version() {
         assert!(ZbiFlags::default().contains(ZbiFlags::VERSION));
     }
 
     #[test]
-    fn zbi_test_is_bootable() {
+    fn test_zbi_is_bootable() {
         let mut buffer = ZbiAligned::default();
         let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
 
@@ -2402,7 +2558,7 @@ mod tests {
 
     #[cfg(target_arch = "x86_64")]
     #[test]
-    fn zbi_test_is_bootable_reference() {
+    fn test_zbi_is_bootable_reference() {
         let ref_buffer = get_test_creference_buffer_vec();
         let mut buffer = ZbiAligned::default();
         buffer.0[..ref_buffer.len()].clone_from_slice(&ref_buffer);
@@ -2411,14 +2567,14 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_is_bootable_empty_container() {
+    fn test_zbi_is_bootable_empty_container() {
         let mut buffer = ZbiAligned::default();
         let container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
         assert_eq!(container.is_bootable(), Err(ZbiError::Truncated));
     }
 
     #[test]
-    fn zbi_test_is_bootable_wrong_arch() {
+    fn test_zbi_is_bootable_wrong_arch() {
         let mut buffer = ZbiAligned::default();
         let _ = TestZbiBuilder::new(&mut buffer.0[..])
             .container_hdr(0)
@@ -2432,7 +2588,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_is_bootable_not_first_item_fail() {
+    fn test_zbi_is_bootable_not_first_item_fail() {
         let mut buffer = ZbiAligned::default();
         let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
 
@@ -2447,7 +2603,42 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_header_alignment() {
+    fn test_zbi_get_kernel_entry_and_reserved_memory_size() {
+        let mut buffer = ZbiAligned::default();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let bytes = [1u64.to_le_bytes(), 2u64.to_le_bytes()].concat();
+        container
+            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &bytes)
+            .unwrap();
+        assert_eq!(container.get_kernel_entry_and_reserved_memory_size().unwrap(), (1, 2));
+    }
+
+    #[test]
+    fn test_zbi_get_kernel_entry_and_reserved_memory_size_truncated() {
+        let mut buffer = ZbiAligned::default();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        container
+            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &[])
+            .unwrap();
+        assert!(container.get_kernel_entry_and_reserved_memory_size().is_err());
+    }
+
+    #[test]
+    fn zbi_get_buffer_size_for_kernel_relocation() {
+        let mut buffer = ZbiAligned::default();
+        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let bytes = [0u64.to_le_bytes(), 1024u64.to_le_bytes()].concat();
+        container
+            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &bytes)
+            .unwrap();
+        assert_eq!(
+            container.get_buffer_size_for_kernel_relocation().unwrap(),
+            container.container_size() + 1024
+        );
+    }
+
+    #[test]
+    fn test_zbi_header_alignment() {
         assert_eq!(core::mem::size_of::<ZbiHeader>() & ZBI_ALIGNMENT_USIZE, 0);
     }
 
@@ -2611,7 +2802,7 @@ mod tests {
     }
 
     #[test]
-    fn zbi_test_zbi_error() {
+    fn test_zbi_zbi_error() {
         let e = ZbiError::Error;
         println!("{e}");
         println!("{e:?}");
@@ -2619,7 +2810,7 @@ mod tests {
     }
 
     #[test]
-    fn zby_test_container_align_buffer() {
+    fn test_zbi_container_align_buffer() {
         let buffer = ZbiAligned::default();
         let original_len = buffer.0.len();
         let buffer = align_buffer(&buffer.0[1..]).unwrap();
@@ -2628,7 +2819,7 @@ mod tests {
     }
 
     #[test]
-    fn zby_test_container_align_buffer_empty() {
+    fn test_zbi_container_align_buffer_empty() {
         let buffer = ZbiAligned::default();
         let buffer = align_buffer(&buffer.0[..0]).unwrap();
         assert_eq!(buffer.as_ptr() as usize % ZBI_ALIGNMENT_USIZE, 0);
@@ -2636,16 +2827,66 @@ mod tests {
     }
 
     #[test]
-    fn zby_test_container_align_buffer_too_short() {
+    fn test_zbi_container_align_buffer_too_short() {
         let buffer = ZbiAligned::default();
         assert_eq!(align_buffer(&buffer.0[1..ZBI_ALIGNMENT_USIZE - 1]), Err(ZbiError::TooBig));
     }
 
     #[test]
-    fn zby_test_container_align_buffer_just_enough() {
+    fn test_zbi_container_align_buffer_just_enough() {
         let buffer = ZbiAligned::default();
         let buffer = align_buffer(&buffer.0[1..ZBI_ALIGNMENT_USIZE]).unwrap();
         assert_eq!(buffer.as_ptr() as usize % ZBI_ALIGNMENT_USIZE, 0);
         assert_eq!(buffer.len(), 0);
     }
+
+    #[test]
+    fn test_merge_within() {
+        let mut buffer = vec![0u8; 1024];
+        let buffer = align_buffer(&mut buffer[..]).unwrap();
+
+        let mut container_0 = ZbiContainer::new(&mut buffer[..]).unwrap();
+        container_0
+            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"0")
+            .unwrap();
+        let container_size_0 = container_0.container_size();
+        let mut container_1 = ZbiContainer::new(&mut buffer[container_size_0..]).unwrap();
+        container_1
+            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"1")
+            .unwrap();
+
+        // Makes a copy of the buffer for performing the merge.
+        let mut copy = buffer.to_vec();
+        let merged = merge_within(&mut copy[..], container_size_0).unwrap();
+
+        let (buffer_0, buffer_1) = buffer.split_at_mut(container_size_0);
+        let container_0 = ZbiContainer::parse(buffer_0).unwrap();
+        let container_1 = ZbiContainer::parse(buffer_1).unwrap();
+        let mut it = merged.iter();
+        assert_eq!(it.next().unwrap(), container_0.iter().next().unwrap());
+        assert_eq!(it.next().unwrap(), container_1.iter().next().unwrap());
+        assert!(it.next().is_none());
+    }
+
+    #[test]
+    fn test_merge_within_invalid_second_start() {
+        let mut buffer = ZbiAligned::default();
+        ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        assert!(merge_within(&mut buffer.0[..], 0).is_err());
+    }
+
+    #[test]
+    fn test_merge_within_invalid_first_container() {
+        let mut buffer = ZbiAligned::default();
+        ZbiContainer::new(&mut buffer.0[2 * ZBI_ALIGNMENT_USIZE..]).unwrap();
+        assert!(merge_within(&mut buffer.0[..], 2 * ZBI_ALIGNMENT_USIZE).is_err());
+    }
+
+    #[test]
+    fn test_merge_within_invalid_second_container() {
+        let mut buffer = ZbiAligned::default();
+        let first = ZbiContainer::new(&mut buffer.0[..]).unwrap();
+        let first_sz = first.container_size();
+        assert!(merge_within(&mut buffer.0[..], first_sz).is_err());
+    }
 }
diff --git a/gbl/third_party/libzbi/src/zbi_format.rs b/gbl/third_party/libzbi/src/zbi_format.rs
index 34f3653..534994e 100644
--- a/gbl/third_party/libzbi/src/zbi_format.rs
+++ b/gbl/third_party/libzbi/src/zbi_format.rs
@@ -1,4 +1,4 @@
-// Copyright 2023, The Android Open Source Project
+// Copyright 2024, The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -12,12 +12,16 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// Generated by ./bindgen.sh using bindgen 0.66.1
+// Generated by ./bindgen.sh using bindgen 0.70.1
 
 // Allow non-conventional naming for imports from C/C++.
 #![allow(non_camel_case_types)]
 #![allow(non_snake_case)]
 #![allow(clippy::undocumented_unsafe_blocks)]
+// Allow unused definitions
+#![allow(dead_code)]
+// Allow unused return values for buildtime tests
+#![allow(unused_must_use)]
 
 use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
@@ -27,42 +31,426 @@ use zerocopy::{AsBytes, FromBytes, FromZeroes};
 #[link(name = "CoreFoundation", kind = "framework")]
 extern "C" {}
 
+pub const ZBI_BOARD_NAME_LEN: u64 = 32;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_platform_id_t {
+    pub vid: u32,
+    pub pid: u32,
+    pub board_name: [::core::ffi::c_char; 32usize],
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_board_info_t {
+    pub revision: u32,
+}
+pub const ZBI_MAX_SMT: u64 = 4;
+pub type zbi_topology_processor_flags_t = u16;
+pub const ZBI_TOPOLOGY_PROCESSOR_FLAGS_PRIMARY: zbi_topology_processor_flags_t = 1;
+pub const ZBI_TOPOLOGY_PROCESSOR_FLAGS_INTERRUPT: zbi_topology_processor_flags_t = 2;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_arm64_info_t {
+    pub cluster_1_id: u8,
+    pub cluster_2_id: u8,
+    pub cluster_3_id: u8,
+    pub cpu_id: u8,
+    pub gic_id: u8,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_x64_info_t {
+    pub apic_ids: [u32; 4usize],
+    pub apic_id_count: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_riscv64_info_t {
+    pub hart_id: u64,
+    pub isa_strtab_index: u32,
+    pub reserved: u32,
+}
+pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_ARM64: u64 = 1;
+pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_X64: u64 = 2;
+pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_RISCV64: u64 = 3;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct zbi_topology_architecture_info_t {
+    pub discriminant: u64,
+    pub __bindgen_anon_1: zbi_topology_architecture_info_t__bindgen_ty_1,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union zbi_topology_architecture_info_t__bindgen_ty_1 {
+    pub arm64: zbi_topology_arm64_info_t,
+    pub x64: zbi_topology_x64_info_t,
+    pub riscv64: zbi_topology_riscv64_info_t,
+}
+impl Default for zbi_topology_architecture_info_t__bindgen_ty_1 {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_architecture_info_t__bindgen_ty_1 {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(f, "zbi_topology_architecture_info_t__bindgen_ty_1 {{ union }}")
+    }
+}
+impl Default for zbi_topology_architecture_info_t {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_architecture_info_t {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(
+            f,
+            "zbi_topology_architecture_info_t {{ __bindgen_anon_1: {:?} }}",
+            self.__bindgen_anon_1
+        )
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct zbi_topology_processor_t {
+    pub architecture_info: zbi_topology_architecture_info_t,
+    pub flags: zbi_topology_processor_flags_t,
+    pub logical_ids: [u16; 4usize],
+    pub logical_id_count: u8,
+}
+impl Default for zbi_topology_processor_t {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_processor_t {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(
+            f,
+            "zbi_topology_processor_t {{ architecture_info: {:?}, logical_ids: {:?} }}",
+            self.architecture_info, self.logical_ids
+        )
+    }
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_cluster_t {
+    pub performance_class: u8,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_cache_t {
+    pub cache_id: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_die_t {
+    pub reserved: u64,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_socket_t {
+    pub reserved: u64,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_topology_numa_region_t {
+    pub start: u64,
+    pub size: u64,
+}
+pub const ZBI_TOPOLOGY_ENTITY_PROCESSOR: u64 = 1;
+pub const ZBI_TOPOLOGY_ENTITY_CLUSTER: u64 = 2;
+pub const ZBI_TOPOLOGY_ENTITY_CACHE: u64 = 3;
+pub const ZBI_TOPOLOGY_ENTITY_DIE: u64 = 4;
+pub const ZBI_TOPOLOGY_ENTITY_SOCKET: u64 = 5;
+pub const ZBI_TOPOLOGY_ENTITY_NUMA_REGION: u64 = 6;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct zbi_topology_entity_t {
+    pub discriminant: u64,
+    pub __bindgen_anon_1: zbi_topology_entity_t__bindgen_ty_1,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union zbi_topology_entity_t__bindgen_ty_1 {
+    pub processor: zbi_topology_processor_t,
+    pub cluster: zbi_topology_cluster_t,
+    pub cache: zbi_topology_cache_t,
+    pub die: zbi_topology_die_t,
+    pub socket: zbi_topology_socket_t,
+    pub numa_region: zbi_topology_numa_region_t,
+}
+impl Default for zbi_topology_entity_t__bindgen_ty_1 {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_entity_t__bindgen_ty_1 {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(f, "zbi_topology_entity_t__bindgen_ty_1 {{ union }}")
+    }
+}
+impl Default for zbi_topology_entity_t {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_entity_t {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(f, "zbi_topology_entity_t {{ __bindgen_anon_1: {:?} }}", self.__bindgen_anon_1)
+    }
+}
+pub const ZBI_TOPOLOGY_NO_PARENT: u16 = 65535;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct zbi_topology_node_t {
+    pub entity: zbi_topology_entity_t,
+    pub parent_index: u16,
+}
+impl Default for zbi_topology_node_t {
+    fn default() -> Self {
+        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
+        unsafe {
+            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
+            s.assume_init()
+        }
+    }
+}
+impl ::core::fmt::Debug for zbi_topology_node_t {
+    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
+        write!(f, "zbi_topology_node_t {{ entity: {:?} }}", self.entity)
+    }
+}
+pub type zbi_kernel_driver_t = u32;
+pub const ZBI_KERNEL_DRIVER_ARM_PSCI: zbi_kernel_driver_t = 1229149008;
+pub const ZBI_KERNEL_DRIVER_ARM_GIC_V2: zbi_kernel_driver_t = 843270471;
+pub const ZBI_KERNEL_DRIVER_ARM_GIC_V3: zbi_kernel_driver_t = 860047687;
+pub const ZBI_KERNEL_DRIVER_ARM_GENERIC_TIMER: zbi_kernel_driver_t = 1296651329;
+pub const ZBI_KERNEL_DRIVER_PL011_UART: zbi_kernel_driver_t = 1429228624;
+pub const ZBI_KERNEL_DRIVER_AMLOGIC_UART: zbi_kernel_driver_t = 1431063873;
+pub const ZBI_KERNEL_DRIVER_AMLOGIC_HDCP: zbi_kernel_driver_t = 1212960065;
+pub const ZBI_KERNEL_DRIVER_DW8250_UART: zbi_kernel_driver_t = 1146566741;
+pub const ZBI_KERNEL_DRIVER_AMLOGIC_RNG_V1: zbi_kernel_driver_t = 1212960082;
+pub const ZBI_KERNEL_DRIVER_AMLOGIC_RNG_V2: zbi_kernel_driver_t = 1380732225;
+pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG: zbi_kernel_driver_t = 842220631;
+pub const ZBI_KERNEL_DRIVER_GENI_UART: zbi_kernel_driver_t = 1229866311;
+pub const ZBI_KERNEL_DRIVER_I8250_PIO_UART: zbi_kernel_driver_t = 808792632;
+pub const ZBI_KERNEL_DRIVER_I8250_MMIO32_UART: zbi_kernel_driver_t = 1295331896;
+pub const ZBI_KERNEL_DRIVER_I8250_MMIO8_UART: zbi_kernel_driver_t = 1110782520;
+pub const ZBI_KERNEL_DRIVER_MOTMOT_UART: zbi_kernel_driver_t = 1296913493;
+pub const ZBI_KERNEL_DRIVER_MOTMOT_POWER: zbi_kernel_driver_t = 1296913488;
+pub const ZBI_KERNEL_DRIVER_AS370_POWER: zbi_kernel_driver_t = 1345337139;
+pub const ZBI_KERNEL_DRIVER_IMX_UART: zbi_kernel_driver_t = 1431850313;
+pub const ZBI_KERNEL_DRIVER_RISCV_PLIC: zbi_kernel_driver_t = 1128877136;
+pub const ZBI_KERNEL_DRIVER_RISCV_GENERIC_TIMER: zbi_kernel_driver_t = 1296651346;
+pub const ZBI_KERNEL_DRIVER_PXA_UART: zbi_kernel_driver_t = 1347961173;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_simple_t {
+    pub mmio_phys: u64,
+    pub irq: u32,
+    pub flags: u32,
+}
+pub type zbi_kernel_driver_irq_flags_t = u32;
+pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_EDGE_TRIGGERED: zbi_kernel_driver_irq_flags_t = 1;
+pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_LEVEL_TRIGGERED: zbi_kernel_driver_irq_flags_t = 2;
+pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_POLARITY_LOW: zbi_kernel_driver_irq_flags_t = 4;
+pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_POLARITY_HIGH: zbi_kernel_driver_irq_flags_t = 8;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_simple_pio_t {
+    pub base: u16,
+    pub reserved: u16,
+    pub irq: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_arm_psci_driver_t {
+    pub use_hvc: u8,
+    pub reserved: [u8; 7usize],
+    pub shutdown_args: [u64; 3usize],
+    pub reboot_args: [u64; 3usize],
+    pub reboot_bootloader_args: [u64; 3usize],
+    pub reboot_recovery_args: [u64; 3usize],
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_arm_gic_v2_driver_t {
+    pub mmio_phys: u64,
+    pub msi_frame_phys: u64,
+    pub gicd_offset: u64,
+    pub gicc_offset: u64,
+    pub gich_offset: u64,
+    pub gicv_offset: u64,
+    pub ipi_base: u32,
+    pub optional: u8,
+    pub use_msi: u8,
+    pub reserved: u16,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_arm_gic_v3_driver_t {
+    pub mmio_phys: u64,
+    pub gicd_offset: u64,
+    pub gicr_offset: u64,
+    pub gicr_stride: u64,
+    pub reserved0: u64,
+    pub ipi_base: u32,
+    pub optional: u8,
+    pub reserved1: [u8; 3usize],
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_arm_generic_timer_driver_t {
+    pub irq_phys: u32,
+    pub irq_virt: u32,
+    pub irq_sphys: u32,
+    pub freq_override: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_amlogic_hdcp_driver_t {
+    pub preset_phys: u64,
+    pub hiu_phys: u64,
+    pub hdmitx_phys: u64,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_amlogic_rng_driver_t {
+    pub rng_data_phys: u64,
+    pub rng_status_phys: u64,
+    pub rng_refresh_interval_usec: u64,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_generic32_watchdog_action_t {
+    pub addr: u64,
+    pub clr_mask: u32,
+    pub set_mask: u32,
+}
+pub type zbi_kernel_driver_generic32_watchdog_flags_t = u32;
+pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG_FLAGS_ENABLED:
+    zbi_kernel_driver_generic32_watchdog_flags_t = 1;
+pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG_MIN_PERIOD: i64 = 1000000;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_generic32_watchdog_t {
+    pub pet_action: zbi_dcfg_generic32_watchdog_action_t,
+    pub enable_action: zbi_dcfg_generic32_watchdog_action_t,
+    pub disable_action: zbi_dcfg_generic32_watchdog_action_t,
+    pub watchdog_period_nsec: i64,
+    pub flags: zbi_kernel_driver_generic32_watchdog_flags_t,
+    pub reserved: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_riscv_plic_driver_t {
+    pub mmio_phys: u64,
+    pub num_irqs: u32,
+    pub reserved: u32,
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_dcfg_riscv_generic_timer_driver_t {
+    pub freq_hz: u32,
+    pub reserved: u32,
+}
+pub type zbi_pixel_format_t = u32;
+pub const ZBI_PIXEL_FORMAT_NONE: zbi_pixel_format_t = 0;
+pub const ZBI_PIXEL_FORMAT_RGB_565: zbi_pixel_format_t = 131073;
+pub const ZBI_PIXEL_FORMAT_RGB_332: zbi_pixel_format_t = 65538;
+pub const ZBI_PIXEL_FORMAT_RGB_2220: zbi_pixel_format_t = 65539;
+pub const ZBI_PIXEL_FORMAT_ARGB_8888: zbi_pixel_format_t = 262148;
+pub const ZBI_PIXEL_FORMAT_RGB_X888: zbi_pixel_format_t = 262149;
+pub const ZBI_PIXEL_FORMAT_MONO_8: zbi_pixel_format_t = 65543;
+pub const ZBI_PIXEL_FORMAT_NV12: zbi_pixel_format_t = 65544;
+pub const ZBI_PIXEL_FORMAT_I420: zbi_pixel_format_t = 65545;
+pub const ZBI_PIXEL_FORMAT_RGB_888: zbi_pixel_format_t = 196617;
+pub const ZBI_PIXEL_FORMAT_ABGR_8888: zbi_pixel_format_t = 262154;
+pub const ZBI_PIXEL_FORMAT_BGR_888_X: zbi_pixel_format_t = 262155;
+pub const ZBI_PIXEL_FORMAT_ARGB_2_10_10_10: zbi_pixel_format_t = 262156;
+pub const ZBI_PIXEL_FORMAT_ABGR_2_10_10_10: zbi_pixel_format_t = 262157;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_swfb_t {
+    pub base: u64,
+    pub width: u32,
+    pub height: u32,
+    pub stride: u32,
+    pub format: zbi_pixel_format_t,
+}
 #[repr(C)]
 #[derive(Debug, Default, Copy, Clone, PartialEq)]
 pub struct zbi_kernel_t {
     pub entry: u64,
     pub reserve_memory_size: u64,
 }
-#[test]
-fn bindgen_test_layout_zbi_kernel_t() {
-    const UNINIT: ::std::mem::MaybeUninit<zbi_kernel_t> = ::std::mem::MaybeUninit::uninit();
-    let ptr = UNINIT.as_ptr();
-    assert_eq!(
-        ::std::mem::size_of::<zbi_kernel_t>(),
-        16usize,
-        concat!("Size of: ", stringify!(zbi_kernel_t))
-    );
-    assert_eq!(
-        ::std::mem::align_of::<zbi_kernel_t>(),
-        8usize,
-        concat!("Alignment of ", stringify!(zbi_kernel_t))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
-        0usize,
-        concat!("Offset of field: ", stringify!(zbi_kernel_t), "::", stringify!(entry))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).reserve_memory_size) as usize - ptr as usize },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(zbi_kernel_t),
-            "::",
-            stringify!(reserve_memory_size)
-        )
-    );
+pub type zbi_mem_type_t = u32;
+pub const ZBI_MEM_TYPE_RAM: zbi_mem_type_t = 1;
+pub const ZBI_MEM_TYPE_PERIPHERAL: zbi_mem_type_t = 2;
+pub const ZBI_MEM_TYPE_RESERVED: zbi_mem_type_t = 3;
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_mem_range_t {
+    pub paddr: u64,
+    pub length: u64,
+    pub type_: zbi_mem_type_t,
+    pub reserved: u32,
 }
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_nvram_t {
+    pub base: u64,
+    pub length: u64,
+}
+pub const ZBI_PARTITION_NAME_LEN: u64 = 32;
+pub const ZBI_PARTITION_GUID_LEN: u64 = 16;
+pub type zbi_partition_guid_t = [u8; 16usize];
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_partition_t {
+    pub type_guid: zbi_partition_guid_t,
+    pub uniq_guid: zbi_partition_guid_t,
+    pub first_block: u64,
+    pub last_block: u64,
+    pub flags: u64,
+    pub name: [::core::ffi::c_char; 32usize],
+}
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone, PartialEq)]
+pub struct zbi_partition_map_t {
+    pub block_count: u64,
+    pub block_size: u64,
+    pub partition_count: u32,
+    pub reserved: u32,
+    pub guid: zbi_partition_guid_t,
+}
+pub type zbi_hw_reboot_reason_t = u32;
+pub const ZBI_HW_REBOOT_REASON_UNDEFINED: zbi_hw_reboot_reason_t = 0;
+pub const ZBI_HW_REBOOT_REASON_COLD: zbi_hw_reboot_reason_t = 1;
+pub const ZBI_HW_REBOOT_REASON_WARM: zbi_hw_reboot_reason_t = 2;
+pub const ZBI_HW_REBOOT_REASON_BROWNOUT: zbi_hw_reboot_reason_t = 3;
+pub const ZBI_HW_REBOOT_REASON_WATCHDOG: zbi_hw_reboot_reason_t = 4;
 pub const ZBI_ALIGNMENT: u32 = 8;
 pub const ZBI_TYPE_KERNEL_PREFIX: u32 = 5132875;
 pub const ZBI_TYPE_KERNEL_MASK: u32 = 16777215;
@@ -102,6 +490,7 @@ pub const ZBI_TYPE_BOOTLOADER_FILE: zbi_type_t = 1279677506;
 pub const ZBI_TYPE_DEVICETREE: zbi_type_t = 3490578157;
 pub const ZBI_TYPE_SECURE_ENTROPY: zbi_type_t = 1145979218;
 pub const ZBI_TYPE_DEBUGDATA: zbi_type_t = 1145520708;
+pub const ZBI_TYPE_RISCV64_ISA_STRTAB: zbi_type_t = 1095977302;
 pub const ZBI_CONTAINER_MAGIC: u32 = 2257385446;
 pub const ZBI_ITEM_MAGIC: u32 = 3044546345;
 pub type zbi_flags_t = u32;
@@ -120,58 +509,3 @@ pub struct zbi_header_t {
     pub magic: u32,
     pub crc32: u32,
 }
-#[test]
-fn bindgen_test_layout_zbi_header_t() {
-    const UNINIT: ::std::mem::MaybeUninit<zbi_header_t> = ::std::mem::MaybeUninit::uninit();
-    let ptr = UNINIT.as_ptr();
-    assert_eq!(
-        ::std::mem::size_of::<zbi_header_t>(),
-        32usize,
-        concat!("Size of: ", stringify!(zbi_header_t))
-    );
-    assert_eq!(
-        ::std::mem::align_of::<zbi_header_t>(),
-        4usize,
-        concat!("Alignment of ", stringify!(zbi_header_t))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
-        0usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(type_))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
-        4usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(length))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
-        8usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(extra))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
-        12usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(flags))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
-        16usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(reserved0))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
-        20usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(reserved1))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
-        24usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(magic))
-    );
-    assert_eq!(
-        unsafe { ::std::ptr::addr_of!((*ptr).crc32) as usize - ptr as usize },
-        28usize,
-        concat!("Offset of field: ", stringify!(zbi_header_t), "::", stringify!(crc32))
-    );
-}
diff --git a/gbl/toolchain/BUILD b/gbl/toolchain/BUILD
index 882b8ba..d936e4c 100644
--- a/gbl/toolchain/BUILD
+++ b/gbl/toolchain/BUILD
@@ -53,6 +53,11 @@ constraint_value(
     constraint_setting = ":firmware_image_type",
 )
 
+host_x86_64_constraint_values = [
+    "@platforms//os:linux",
+    "@platforms//cpu:x86_64",
+]
+
 uefi_x86_64_constraint_values = [
     ":uefi",
     "@platforms//os:none",
@@ -77,6 +82,11 @@ elf_riscv64_constraint_values = [
     "@platforms//cpu:riscv64",
 ]
 
+config_setting(
+    name = "gbl_rust_host_x86_64",
+    constraint_values = host_x86_64_constraint_values,
+)
+
 config_setting(
     name = "gbl_rust_uefi_x86_64",
     constraint_values = uefi_x86_64_constraint_values,
@@ -166,6 +176,8 @@ cc_flags_common = [
     "-fno-common",
     "-fno-exceptions",
     "-fno-rtti",
+    # Enable optimization otherwise software AVB hash will be too slow.
+    "-O3",
 ]
 
 # x86_64 UEFI targets
@@ -298,10 +310,7 @@ rust_toolchain(
 toolchain(
     name = "x86_64_unknown_linux_gnu_toolchain",
     exec_compatible_with = ["@platforms//os:linux"],
-    target_compatible_with = [
-        "@platforms//os:linux",
-        "@platforms//cpu:x86_64",
-    ],
+    target_settings = [":gbl_rust_host_x86_64"],
     toolchain = ":x86_64_unknown_linux_gnu",
     toolchain_type = "@rules_rust//rust:toolchain",
 )
diff --git a/gbl/toolchain/BUILD.android_rust_prebuilts.bazel b/gbl/toolchain/BUILD.android_rust_prebuilts.bazel
index ee65923..c2fb655 100644
--- a/gbl/toolchain/BUILD.android_rust_prebuilts.bazel
+++ b/gbl/toolchain/BUILD.android_rust_prebuilts.bazel
@@ -89,8 +89,7 @@ rust_library(
             "src/stdlibs/vendor/compiler_builtins/src/**/*.rs",
             "src/stdlibs/vendor/compiler_builtins/libm/src/**/*.rs",
         ],
-        exclude = [COMPILER_BUILTIN_X86_SRC],
-    ) + [":x86_uefi_chkstk_patch"],
+    ),
     compile_data = glob(["src/stdlibs/vendor/compiler_builtins/src/**/*.md"]),
     crate_features = [
         "compiler-builtins",
@@ -99,7 +98,6 @@ rust_library(
         "mem",
     ],
     crate_name = "compiler_builtins",
-    data = [":x86_uefi_chkstk_patch"],
     edition = "2015",
     rustc_flags = ["--cap-lints=allow"],
     deps = ["libcore"],
diff --git a/gbl/toolchain/gbl_workspace_util.bzl b/gbl/toolchain/gbl_workspace_util.bzl
index 75799ac..38ac1b3 100644
--- a/gbl/toolchain/gbl_workspace_util.bzl
+++ b/gbl/toolchain/gbl_workspace_util.bzl
@@ -125,9 +125,9 @@ gbl_llvm_prebuilts = repository_rule(
     environ = ["GBL_LLVM_PREBUILTS", "GBL_LINUX_SYSROOT"],
 )
 
-# The current rust version used by GBL. This needs to be manually udpated when new version of
+# The current rust version used by GBL. This needs to be manually updated when new version of
 # prebuilts is uploaded to https://android.googlesource.com/platform/prebuilts/rust/
-GBL_RUST_VERSION = "1.77.1.p1"
+GBL_RUST_VERSION = "1.80.1"
 
 def _android_rust_prebuilts_impl(repo_ctx):
     """Assemble a rust toolchain repo from the Android rust prebuilts repo.
@@ -161,3 +161,39 @@ android_rust_prebuilts = repository_rule(
         "build_file": attr.label(mandatory = True),
     },
 )
+
+# This should match upstream Android defaults at
+# https://cs.android.com/android/platform/superproject/main/+/main:build/soong/rust/config/lints.go.
+#
+# We can't add these to the global flags in //toolchain:common_lint_opts
+# because it breaks some third-party packages which don't use these lints.
+# The global options also come later on the commandline so can't be overriden
+# by a package.
+#
+# Instead we add these to `rustc_flags` for all our modules explicitly.
+ANDROID_RUST_LINTS = [
+    "-A",
+    "deprecated",
+    "-A",
+    "unknown_lints",
+    "-D",
+    "missing-docs",
+    "-D",
+    "warnings",
+    "-D",
+    "unsafe_op_in_unsafe_fn",
+    "-A",
+    "clippy::disallowed_names",
+    "-A",
+    "clippy::type-complexity",
+    "-A",
+    "clippy::unnecessary_fallible_conversions",
+    "-A",
+    "clippy::unnecessary-wraps",
+    "-A",
+    "clippy::unusual-byte-groupings",
+    "-A",
+    "clippy::upper-case-acronyms",
+    "-D",
+    "clippy::undocumented_unsafe_blocks",
+]
diff --git a/vts/VtsBootconfigTest.cpp b/vts/VtsBootconfigTest.cpp
index 285c180..705940a 100644
--- a/vts/VtsBootconfigTest.cpp
+++ b/vts/VtsBootconfigTest.cpp
@@ -22,11 +22,14 @@
 class VtsBootconfigTest : public testing::Test {};
 
 TEST_F(VtsBootconfigTest, ProcCmdlineAndroidbootTest) {
-  // This test only applies to devices launching with S(or greater) AND with
-  // kernel version 5.10(or greater)
-  bool kernel_support = android::bpf::isAtLeastKernelVersion(5, 10, 0);
-  if (std::stoi(android::base::GetProperty("ro.product.first_api_level", "0"))
-    < __ANDROID_API_S__ || !kernel_support) {
+  // This was supported in Android S with kernel version 5.10+, but really only
+  // required by Android T because Android still needs to support
+  // Android S devices that launched with 4.19 for as long as it supports
+  // Android S.
+  int first_api_level = android::base::GetIntProperty(
+        "ro.board.first_api_level",
+        android::base::GetIntProperty("ro.vendor.api_level", 1000000));
+  if (first_api_level < __ANDROID_API_T__) {
     GTEST_SKIP() << "Bootconfig requirements do not apply";
   }
 
```

