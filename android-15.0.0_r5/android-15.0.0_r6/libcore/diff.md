```diff
diff --git a/EXPECTED_UPSTREAM b/EXPECTED_UPSTREAM
index 85070b71895..2064bc55c3b 100644
--- a/EXPECTED_UPSTREAM
+++ b/EXPECTED_UPSTREAM
@@ -125,6 +125,7 @@ ojluni/src/main/java/java/lang/ArrayIndexOutOfBoundsException.java,jdk17u/jdk-17
 ojluni/src/main/java/java/lang/ArrayStoreException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ArrayStoreException.java
 ojluni/src/main/java/java/lang/AssertionError.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/AssertionError.java
 ojluni/src/main/java/java/lang/AutoCloseable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/AutoCloseable.java
+ojluni/src/main/java/java/lang/BaseVirtualThread.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/java/lang/BaseVirtualThread.java
 ojluni/src/main/java/java/lang/Boolean.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Boolean.java
 ojluni/src/main/java/java/lang/BootstrapMethodError.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/BootstrapMethodError.java
 ojluni/src/main/java/java/lang/Byte.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Byte.java
@@ -170,6 +171,7 @@ ojluni/src/main/java/java/lang/LinkageError.java,jdk17u/jdk-17.0.6-ga,src/java.b
 ojluni/src/main/java/java/lang/LiveStackFrame.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/LiveStackFrame.java
 ojluni/src/main/java/java/lang/LiveStackFrameInfo.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/LiveStackFrameInfo.java
 ojluni/src/main/java/java/lang/Long.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Long.java
+ojluni/src/main/java/java/lang/MatchException.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/lang/MatchException.java
 ojluni/src/main/java/java/lang/Math.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/lang/Math.java
 ojluni/src/main/java/java/lang/NegativeArraySizeException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/NegativeArraySizeException.java
 ojluni/src/main/java/java/lang/NoClassDefFoundError.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/NoClassDefFoundError.java
@@ -240,7 +242,7 @@ ojluni/src/main/java/java/lang/annotation/RetentionPolicy.java,jdk17u/jdk-17.0.6
 ojluni/src/main/java/java/lang/annotation/Target.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/annotation/Target.java
 ojluni/src/main/java/java/lang/annotation/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/annotation/package-info.java
 ojluni/src/main/java/java/lang/constant/AsTypeMethodHandleDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/AsTypeMethodHandleDesc.java
-ojluni/src/main/java/java/lang/constant/ClassDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ClassDesc.java
+ojluni/src/main/java/java/lang/constant/ClassDesc.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/lang/constant/ClassDesc.java
 ojluni/src/main/java/java/lang/constant/Constable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/Constable.java
 ojluni/src/main/java/java/lang/constant/ConstantDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ConstantDesc.java
 ojluni/src/main/java/java/lang/constant/ConstantDescs.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ConstantDescs.java
@@ -308,6 +310,7 @@ ojluni/src/main/java/java/lang/reflect/UndeclaredThrowableException.java,jdk11u/
 ojluni/src/main/java/java/lang/reflect/WeakCache.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/WeakCache.java
 ojluni/src/main/java/java/lang/reflect/WildcardType.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/WildcardType.java
 ojluni/src/main/java/java/lang/reflect/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/package-info.java
+ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
 ojluni/src/main/java/java/math/BigDecimal.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/BigDecimal.java
 ojluni/src/main/java/java/math/BigInteger.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/BigInteger.java
 ojluni/src/main/java/java/math/BitSieve.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/BitSieve.java
@@ -893,34 +896,34 @@ ojluni/src/main/java/java/time/zone/package-info.java,jdk17u/jdk-17.0.6-ga,src/j
 ojluni/src/main/java/java/util/AbstractCollection.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/AbstractCollection.java
 ojluni/src/main/java/java/util/AbstractList.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/AbstractList.java
 ojluni/src/main/java/java/util/AbstractMap.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/AbstractMap.java
-ojluni/src/main/java/java/util/AbstractQueue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/AbstractQueue.java
+ojluni/src/main/java/java/util/AbstractQueue.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/AbstractQueue.java
 ojluni/src/main/java/java/util/AbstractSequentialList.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/AbstractSequentialList.java
-ojluni/src/main/java/java/util/AbstractSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/AbstractSet.java
+ojluni/src/main/java/java/util/AbstractSet.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/AbstractSet.java
 ojluni/src/main/java/java/util/ArrayDeque.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/ArrayDeque.java
 ojluni/src/main/java/java/util/ArrayList.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/ArrayList.java
-ojluni/src/main/java/java/util/ArrayPrefixHelpers.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ArrayPrefixHelpers.java
-ojluni/src/main/java/java/util/Arrays.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Arrays.java
-ojluni/src/main/java/java/util/ArraysParallelSortHelpers.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java
+ojluni/src/main/java/java/util/ArrayPrefixHelpers.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ArrayPrefixHelpers.java
+ojluni/src/main/java/java/util/Arrays.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Arrays.java
+ojluni/src/main/java/java/util/ArraysParallelSortHelpers.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java
 ojluni/src/main/java/java/util/Base64.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Base64.java
-ojluni/src/main/java/java/util/BitSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/BitSet.java
+ojluni/src/main/java/java/util/BitSet.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/BitSet.java
 ojluni/src/main/java/java/util/Calendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Calendar.java
-ojluni/src/main/java/java/util/Collection.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Collection.java
+ojluni/src/main/java/java/util/Collection.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Collection.java
 ojluni/src/main/java/java/util/Collections.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/Collections.java
-ojluni/src/main/java/java/util/ComparableTimSort.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ComparableTimSort.java
-ojluni/src/main/java/java/util/Comparator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Comparator.java
-ojluni/src/main/java/java/util/Comparators.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Comparators.java
-ojluni/src/main/java/java/util/ConcurrentModificationException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ConcurrentModificationException.java
-ojluni/src/main/java/java/util/Currency.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Currency.java
-ojluni/src/main/java/java/util/Date.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Date.java
+ojluni/src/main/java/java/util/ComparableTimSort.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ComparableTimSort.java
+ojluni/src/main/java/java/util/Comparator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Comparator.java
+ojluni/src/main/java/java/util/Comparators.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Comparators.java
+ojluni/src/main/java/java/util/ConcurrentModificationException.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ConcurrentModificationException.java
+ojluni/src/main/java/java/util/Currency.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Currency.java
+ojluni/src/main/java/java/util/Date.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Date.java
 ojluni/src/main/java/java/util/Deque.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/Deque.java
 ojluni/src/main/java/java/util/Dictionary.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Dictionary.java
-ojluni/src/main/java/java/util/DoubleSummaryStatistics.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/DoubleSummaryStatistics.java
-ojluni/src/main/java/java/util/DualPivotQuicksort.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/DualPivotQuicksort.java
+ojluni/src/main/java/java/util/DoubleSummaryStatistics.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/DoubleSummaryStatistics.java
+ojluni/src/main/java/java/util/DualPivotQuicksort.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/DualPivotQuicksort.java
 ojluni/src/main/java/java/util/DuplicateFormatFlagsException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/DuplicateFormatFlagsException.java
 ojluni/src/main/java/java/util/EmptyStackException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EmptyStackException.java
-ojluni/src/main/java/java/util/EnumMap.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EnumMap.java
-ojluni/src/main/java/java/util/EnumSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EnumSet.java
-ojluni/src/main/java/java/util/Enumeration.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Enumeration.java
+ojluni/src/main/java/java/util/EnumMap.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/EnumMap.java
+ojluni/src/main/java/java/util/EnumSet.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/EnumSet.java
+ojluni/src/main/java/java/util/Enumeration.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Enumeration.java
 ojluni/src/main/java/java/util/EventListener.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EventListener.java
 ojluni/src/main/java/java/util/EventListenerProxy.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EventListenerProxy.java
 ojluni/src/main/java/java/util/EventObject.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EventObject.java
@@ -932,9 +935,9 @@ ojluni/src/main/java/java/util/FormatterClosedException.java,jdk17u/jdk-17.0.6-g
 ojluni/src/main/java/java/util/GregorianCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/GregorianCalendar.java
 ojluni/src/main/java/java/util/HashMap.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/HashMap.java
 ojluni/src/main/java/java/util/HashSet.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/HashSet.java
-ojluni/src/main/java/java/util/Hashtable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Hashtable.java
+ojluni/src/main/java/java/util/Hashtable.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Hashtable.java
 ojluni/src/main/java/java/util/HexFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/HexFormat.java
-ojluni/src/main/java/java/util/IdentityHashMap.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IdentityHashMap.java
+ojluni/src/main/java/java/util/IdentityHashMap.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/IdentityHashMap.java
 ojluni/src/main/java/java/util/IllegalFormatArgumentIndexException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatArgumentIndexException.java
 ojluni/src/main/java/java/util/IllegalFormatCodePointException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatCodePointException.java
 ojluni/src/main/java/java/util/IllegalFormatConversionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatConversionException.java
@@ -943,24 +946,24 @@ ojluni/src/main/java/java/util/IllegalFormatFlagsException.java,jdk17u/jdk-17.0.
 ojluni/src/main/java/java/util/IllegalFormatPrecisionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatPrecisionException.java
 ojluni/src/main/java/java/util/IllegalFormatWidthException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatWidthException.java
 ojluni/src/main/java/java/util/IllformedLocaleException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllformedLocaleException.java
-ojluni/src/main/java/java/util/ImmutableCollections.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ImmutableCollections.java
+ojluni/src/main/java/java/util/ImmutableCollections.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ImmutableCollections.java
 ojluni/src/main/java/java/util/InputMismatchException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/InputMismatchException.java
-ojluni/src/main/java/java/util/IntSummaryStatistics.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IntSummaryStatistics.java
+ojluni/src/main/java/java/util/IntSummaryStatistics.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/IntSummaryStatistics.java
 ojluni/src/main/java/java/util/InvalidPropertiesFormatException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/InvalidPropertiesFormatException.java
-ojluni/src/main/java/java/util/Iterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Iterator.java
+ojluni/src/main/java/java/util/Iterator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Iterator.java
 ojluni/src/main/java/java/util/JapaneseImperialCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
-ojluni/src/main/java/java/util/JumboEnumSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/JumboEnumSet.java
-ojluni/src/main/java/java/util/KeyValueHolder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/KeyValueHolder.java
+ojluni/src/main/java/java/util/JumboEnumSet.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/JumboEnumSet.java
+ojluni/src/main/java/java/util/KeyValueHolder.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/KeyValueHolder.java
 ojluni/src/main/java/java/util/LinkedHashMap.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/LinkedHashMap.java
 ojluni/src/main/java/java/util/LinkedHashSet.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/LinkedHashSet.java
 ojluni/src/main/java/java/util/LinkedList.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/LinkedList.java
 ojluni/src/main/java/java/util/List.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/List.java
-ojluni/src/main/java/java/util/ListIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ListIterator.java
+ojluni/src/main/java/java/util/ListIterator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/ListIterator.java
 ojluni/src/main/java/java/util/ListResourceBundle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ListResourceBundle.java
 ojluni/src/main/java/java/util/Locale.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Locale.java
 ojluni/src/main/java/java/util/LocaleISOData.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/LocaleISOData.java
-ojluni/src/main/java/java/util/LongSummaryStatistics.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/LongSummaryStatistics.java
-ojluni/src/main/java/java/util/Map.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Map.java
+ojluni/src/main/java/java/util/LongSummaryStatistics.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/LongSummaryStatistics.java
+ojluni/src/main/java/java/util/Map.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Map.java
 ojluni/src/main/java/java/util/MissingFormatArgumentException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingFormatArgumentException.java
 ojluni/src/main/java/java/util/MissingFormatWidthException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingFormatWidthException.java
 ojluni/src/main/java/java/util/MissingResourceException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingResourceException.java
@@ -970,19 +973,19 @@ ojluni/src/main/java/java/util/NoSuchElementException.java,jdk17u/jdk-17.0.6-ga,
 ojluni/src/main/java/java/util/Objects.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Objects.java
 ojluni/src/main/java/java/util/Observable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Observable.java
 ojluni/src/main/java/java/util/Observer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Observer.java
-ojluni/src/main/java/java/util/Optional.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Optional.java
-ojluni/src/main/java/java/util/OptionalDouble.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/OptionalDouble.java
-ojluni/src/main/java/java/util/OptionalInt.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/OptionalInt.java
-ojluni/src/main/java/java/util/OptionalLong.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/OptionalLong.java
-ojluni/src/main/java/java/util/PrimitiveIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PrimitiveIterator.java
-ojluni/src/main/java/java/util/PriorityQueue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PriorityQueue.java
+ojluni/src/main/java/java/util/Optional.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Optional.java
+ojluni/src/main/java/java/util/OptionalDouble.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/OptionalDouble.java
+ojluni/src/main/java/java/util/OptionalInt.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/OptionalInt.java
+ojluni/src/main/java/java/util/OptionalLong.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/OptionalLong.java
+ojluni/src/main/java/java/util/PrimitiveIterator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/PrimitiveIterator.java
+ojluni/src/main/java/java/util/PriorityQueue.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/PriorityQueue.java
 ojluni/src/main/java/java/util/Properties.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Properties.java
 ojluni/src/main/java/java/util/PropertyPermission.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PropertyPermission.java
 ojluni/src/main/java/java/util/PropertyResourceBundle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PropertyResourceBundle.java
-ojluni/src/main/java/java/util/Queue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Queue.java
+ojluni/src/main/java/java/util/Queue.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Queue.java
 ojluni/src/main/java/java/util/Random.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Random.java
-ojluni/src/main/java/java/util/RandomAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/RandomAccess.java
-ojluni/src/main/java/java/util/RegularEnumSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/RegularEnumSet.java
+ojluni/src/main/java/java/util/RandomAccess.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/RandomAccess.java
+ojluni/src/main/java/java/util/RegularEnumSet.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/RegularEnumSet.java
 ojluni/src/main/java/java/util/ResourceBundle.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/ResourceBundle.java
 ojluni/src/main/java/java/util/ReverseOrderDequeView.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/ReverseOrderDequeView.java
 ojluni/src/main/java/java/util/ReverseOrderListView.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/ReverseOrderListView.java
@@ -994,29 +997,29 @@ ojluni/src/main/java/java/util/SequencedMap.java,jdk21u/jdk-21.0.1-ga,src/java.b
 ojluni/src/main/java/java/util/SequencedSet.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/SequencedSet.java
 ojluni/src/main/java/java/util/ServiceConfigurationError.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ServiceConfigurationError.java
 ojluni/src/main/java/java/util/ServiceLoader.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ServiceLoader.java
-ojluni/src/main/java/java/util/Set.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Set.java
-ojluni/src/main/java/java/util/SimpleTimeZone.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/SimpleTimeZone.java
+ojluni/src/main/java/java/util/Set.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Set.java
+ojluni/src/main/java/java/util/SimpleTimeZone.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/SimpleTimeZone.java
 ojluni/src/main/java/java/util/SortedMap.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/SortedMap.java
 ojluni/src/main/java/java/util/SortedSet.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/SortedSet.java
-ojluni/src/main/java/java/util/Spliterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Spliterator.java
-ojluni/src/main/java/java/util/Spliterators.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Spliterators.java
+ojluni/src/main/java/java/util/Spliterator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Spliterator.java
+ojluni/src/main/java/java/util/Spliterators.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Spliterators.java
 ojluni/src/main/java/java/util/SplittableRandom.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/SplittableRandom.java
-ojluni/src/main/java/java/util/Stack.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Stack.java
+ojluni/src/main/java/java/util/Stack.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Stack.java
 ojluni/src/main/java/java/util/StringJoiner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/StringJoiner.java
 ojluni/src/main/java/java/util/StringTokenizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/StringTokenizer.java
 ojluni/src/main/java/java/util/TimSort.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/TimSort.java
-ojluni/src/main/java/java/util/TimeZone.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/TimeZone.java
+ojluni/src/main/java/java/util/TimeZone.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/TimeZone.java
 ojluni/src/main/java/java/util/Timer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Timer.java
 ojluni/src/main/java/java/util/TimerTask.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/TimerTask.java
 ojluni/src/main/java/java/util/TooManyListenersException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/TooManyListenersException.java
 ojluni/src/main/java/java/util/TreeMap.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/TreeMap.java
 ojluni/src/main/java/java/util/TreeSet.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/TreeSet.java
-ojluni/src/main/java/java/util/Tripwire.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Tripwire.java
+ojluni/src/main/java/java/util/Tripwire.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/Tripwire.java
 ojluni/src/main/java/java/util/UUID.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UUID.java
 ojluni/src/main/java/java/util/UnknownFormatConversionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UnknownFormatConversionException.java
 ojluni/src/main/java/java/util/UnknownFormatFlagsException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UnknownFormatFlagsException.java
 ojluni/src/main/java/java/util/Vector.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/java/util/Vector.java
-ojluni/src/main/java/java/util/WeakHashMap.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/WeakHashMap.java
+ojluni/src/main/java/java/util/WeakHashMap.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/WeakHashMap.java
 ojluni/src/main/java/java/util/XMLUtils.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/util/XMLUtils.java
 ojluni/src/main/java/java/util/concurrent/AbstractExecutorService.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/AbstractExecutorService.java
 ojluni/src/main/java/java/util/concurrent/ArrayBlockingQueue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java
@@ -1079,80 +1082,80 @@ ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java,jdk17u/jdk-17.
 ojluni/src/main/java/java/util/concurrent/TimeUnit.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/TimeUnit.java
 ojluni/src/main/java/java/util/concurrent/TimeoutException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/TimeoutException.java
 ojluni/src/main/java/java/util/concurrent/TransferQueue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/TransferQueue.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicBoolean.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicInteger.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongFieldUpdater.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicMarkableReference.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicMarkableReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicStampedReference.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicStampedReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/DoubleAccumulator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAccumulator.java
-ojluni/src/main/java/java/util/concurrent/atomic/DoubleAdder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAdder.java
-ojluni/src/main/java/java/util/concurrent/atomic/LongAccumulator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAccumulator.java
-ojluni/src/main/java/java/util/concurrent/atomic/LongAdder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java
-ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java
-ojluni/src/main/java/java/util/concurrent/atomic/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/package-info.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicBoolean.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicInteger.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongFieldUpdater.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicMarkableReference.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicMarkableReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicStampedReference.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicStampedReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/DoubleAccumulator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAccumulator.java
+ojluni/src/main/java/java/util/concurrent/atomic/DoubleAdder.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAdder.java
+ojluni/src/main/java/java/util/concurrent/atomic/LongAccumulator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAccumulator.java
+ojluni/src/main/java/java/util/concurrent/atomic/LongAdder.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java
+ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java
+ojluni/src/main/java/java/util/concurrent/atomic/package-info.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/atomic/package-info.java
 ojluni/src/main/java/java/util/concurrent/locks/AbstractOwnableSynchronizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java
-ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
-ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
+ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
+ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
 ojluni/src/main/java/java/util/concurrent/locks/Condition.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/Condition.java
 ojluni/src/main/java/java/util/concurrent/locks/Lock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/Lock.java
-ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
+ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
 ojluni/src/main/java/java/util/concurrent/locks/ReadWriteLock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReadWriteLock.java
 ojluni/src/main/java/java/util/concurrent/locks/ReentrantLock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java
 ojluni/src/main/java/java/util/concurrent/locks/ReentrantReadWriteLock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java
 ojluni/src/main/java/java/util/concurrent/locks/StampedLock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java
 ojluni/src/main/java/java/util/concurrent/locks/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/package-info.java
 ojluni/src/main/java/java/util/concurrent/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/concurrent/package-info.java
-ojluni/src/main/java/java/util/function/BiConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/BiConsumer.java
-ojluni/src/main/java/java/util/function/BiFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/BiFunction.java
-ojluni/src/main/java/java/util/function/BiPredicate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/BiPredicate.java
-ojluni/src/main/java/java/util/function/BinaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/BinaryOperator.java
-ojluni/src/main/java/java/util/function/BooleanSupplier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/BooleanSupplier.java
-ojluni/src/main/java/java/util/function/Consumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/Consumer.java
-ojluni/src/main/java/java/util/function/DoubleBinaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleBinaryOperator.java
-ojluni/src/main/java/java/util/function/DoubleConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleConsumer.java
-ojluni/src/main/java/java/util/function/DoubleFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleFunction.java
-ojluni/src/main/java/java/util/function/DoublePredicate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoublePredicate.java
-ojluni/src/main/java/java/util/function/DoubleSupplier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleSupplier.java
-ojluni/src/main/java/java/util/function/DoubleToIntFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleToIntFunction.java
-ojluni/src/main/java/java/util/function/DoubleToLongFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleToLongFunction.java
-ojluni/src/main/java/java/util/function/DoubleUnaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/DoubleUnaryOperator.java
-ojluni/src/main/java/java/util/function/Function.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/Function.java
-ojluni/src/main/java/java/util/function/IntBinaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntBinaryOperator.java
-ojluni/src/main/java/java/util/function/IntConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntConsumer.java
-ojluni/src/main/java/java/util/function/IntFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntFunction.java
-ojluni/src/main/java/java/util/function/IntPredicate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntPredicate.java
-ojluni/src/main/java/java/util/function/IntSupplier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntSupplier.java
-ojluni/src/main/java/java/util/function/IntToDoubleFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntToDoubleFunction.java
-ojluni/src/main/java/java/util/function/IntToLongFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntToLongFunction.java
-ojluni/src/main/java/java/util/function/IntUnaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/IntUnaryOperator.java
-ojluni/src/main/java/java/util/function/LongBinaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongBinaryOperator.java
-ojluni/src/main/java/java/util/function/LongConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongConsumer.java
-ojluni/src/main/java/java/util/function/LongFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongFunction.java
-ojluni/src/main/java/java/util/function/LongPredicate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongPredicate.java
-ojluni/src/main/java/java/util/function/LongSupplier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongSupplier.java
-ojluni/src/main/java/java/util/function/LongToDoubleFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongToDoubleFunction.java
-ojluni/src/main/java/java/util/function/LongToIntFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongToIntFunction.java
-ojluni/src/main/java/java/util/function/LongUnaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/LongUnaryOperator.java
-ojluni/src/main/java/java/util/function/ObjDoubleConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ObjDoubleConsumer.java
-ojluni/src/main/java/java/util/function/ObjIntConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ObjIntConsumer.java
-ojluni/src/main/java/java/util/function/ObjLongConsumer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ObjLongConsumer.java
-ojluni/src/main/java/java/util/function/Predicate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/Predicate.java
-ojluni/src/main/java/java/util/function/Supplier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/Supplier.java
-ojluni/src/main/java/java/util/function/ToDoubleBiFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToDoubleBiFunction.java
-ojluni/src/main/java/java/util/function/ToDoubleFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToDoubleFunction.java
-ojluni/src/main/java/java/util/function/ToIntBiFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToIntBiFunction.java
-ojluni/src/main/java/java/util/function/ToIntFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToIntFunction.java
-ojluni/src/main/java/java/util/function/ToLongBiFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToLongBiFunction.java
-ojluni/src/main/java/java/util/function/ToLongFunction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/ToLongFunction.java
-ojluni/src/main/java/java/util/function/UnaryOperator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/UnaryOperator.java
-ojluni/src/main/java/java/util/function/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/function/package-info.java
+ojluni/src/main/java/java/util/function/BiConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/BiConsumer.java
+ojluni/src/main/java/java/util/function/BiFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/BiFunction.java
+ojluni/src/main/java/java/util/function/BiPredicate.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/BiPredicate.java
+ojluni/src/main/java/java/util/function/BinaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/BinaryOperator.java
+ojluni/src/main/java/java/util/function/BooleanSupplier.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/BooleanSupplier.java
+ojluni/src/main/java/java/util/function/Consumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/Consumer.java
+ojluni/src/main/java/java/util/function/DoubleBinaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleBinaryOperator.java
+ojluni/src/main/java/java/util/function/DoubleConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleConsumer.java
+ojluni/src/main/java/java/util/function/DoubleFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleFunction.java
+ojluni/src/main/java/java/util/function/DoublePredicate.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoublePredicate.java
+ojluni/src/main/java/java/util/function/DoubleSupplier.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleSupplier.java
+ojluni/src/main/java/java/util/function/DoubleToIntFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleToIntFunction.java
+ojluni/src/main/java/java/util/function/DoubleToLongFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleToLongFunction.java
+ojluni/src/main/java/java/util/function/DoubleUnaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/DoubleUnaryOperator.java
+ojluni/src/main/java/java/util/function/Function.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/Function.java
+ojluni/src/main/java/java/util/function/IntBinaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntBinaryOperator.java
+ojluni/src/main/java/java/util/function/IntConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntConsumer.java
+ojluni/src/main/java/java/util/function/IntFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntFunction.java
+ojluni/src/main/java/java/util/function/IntPredicate.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntPredicate.java
+ojluni/src/main/java/java/util/function/IntSupplier.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntSupplier.java
+ojluni/src/main/java/java/util/function/IntToDoubleFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntToDoubleFunction.java
+ojluni/src/main/java/java/util/function/IntToLongFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntToLongFunction.java
+ojluni/src/main/java/java/util/function/IntUnaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/IntUnaryOperator.java
+ojluni/src/main/java/java/util/function/LongBinaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongBinaryOperator.java
+ojluni/src/main/java/java/util/function/LongConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongConsumer.java
+ojluni/src/main/java/java/util/function/LongFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongFunction.java
+ojluni/src/main/java/java/util/function/LongPredicate.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongPredicate.java
+ojluni/src/main/java/java/util/function/LongSupplier.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongSupplier.java
+ojluni/src/main/java/java/util/function/LongToDoubleFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongToDoubleFunction.java
+ojluni/src/main/java/java/util/function/LongToIntFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongToIntFunction.java
+ojluni/src/main/java/java/util/function/LongUnaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/LongUnaryOperator.java
+ojluni/src/main/java/java/util/function/ObjDoubleConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ObjDoubleConsumer.java
+ojluni/src/main/java/java/util/function/ObjIntConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ObjIntConsumer.java
+ojluni/src/main/java/java/util/function/ObjLongConsumer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ObjLongConsumer.java
+ojluni/src/main/java/java/util/function/Predicate.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/Predicate.java
+ojluni/src/main/java/java/util/function/Supplier.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/Supplier.java
+ojluni/src/main/java/java/util/function/ToDoubleBiFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToDoubleBiFunction.java
+ojluni/src/main/java/java/util/function/ToDoubleFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToDoubleFunction.java
+ojluni/src/main/java/java/util/function/ToIntBiFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToIntBiFunction.java
+ojluni/src/main/java/java/util/function/ToIntFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToIntFunction.java
+ojluni/src/main/java/java/util/function/ToLongBiFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToLongBiFunction.java
+ojluni/src/main/java/java/util/function/ToLongFunction.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/ToLongFunction.java
+ojluni/src/main/java/java/util/function/UnaryOperator.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/UnaryOperator.java
+ojluni/src/main/java/java/util/function/package-info.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/function/package-info.java
 ojluni/src/main/java/java/util/jar/Attributes.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/util/jar/Attributes.java
 ojluni/src/main/java/java/util/jar/JarEntry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/jar/JarEntry.java
 ojluni/src/main/java/java/util/jar/JarException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/jar/JarException.java
@@ -1207,42 +1210,42 @@ ojluni/src/main/java/java/util/regex/Matcher.java,jdk17u/jdk-17.0.6-ga,src/java.
 ojluni/src/main/java/java/util/regex/Pattern.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/Pattern.java
 ojluni/src/main/java/java/util/regex/PatternSyntaxException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/PatternSyntaxException.java
 ojluni/src/main/java/java/util/regex/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/package-info.java
-ojluni/src/main/java/java/util/stream/AbstractPipeline.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/AbstractPipeline.java
-ojluni/src/main/java/java/util/stream/AbstractShortCircuitTask.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/AbstractShortCircuitTask.java
-ojluni/src/main/java/java/util/stream/AbstractSpinedBuffer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/AbstractSpinedBuffer.java
-ojluni/src/main/java/java/util/stream/AbstractTask.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/AbstractTask.java
-ojluni/src/main/java/java/util/stream/BaseStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/BaseStream.java
-ojluni/src/main/java/java/util/stream/Collector.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Collector.java
-ojluni/src/main/java/java/util/stream/Collectors.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Collectors.java
-ojluni/src/main/java/java/util/stream/DistinctOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/DistinctOps.java
-ojluni/src/main/java/java/util/stream/DoublePipeline.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/DoublePipeline.java
-ojluni/src/main/java/java/util/stream/DoubleStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/DoubleStream.java
-ojluni/src/main/java/java/util/stream/FindOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/FindOps.java
-ojluni/src/main/java/java/util/stream/ForEachOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/ForEachOps.java
-ojluni/src/main/java/java/util/stream/IntPipeline.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/IntPipeline.java
-ojluni/src/main/java/java/util/stream/IntStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/IntStream.java
-ojluni/src/main/java/java/util/stream/LongPipeline.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/LongPipeline.java
-ojluni/src/main/java/java/util/stream/LongStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/LongStream.java
-ojluni/src/main/java/java/util/stream/MatchOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/MatchOps.java
-ojluni/src/main/java/java/util/stream/Node.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Node.java
-ojluni/src/main/java/java/util/stream/Nodes.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Nodes.java
-ojluni/src/main/java/java/util/stream/PipelineHelper.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/PipelineHelper.java
-ojluni/src/main/java/java/util/stream/ReduceOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/ReduceOps.java
-ojluni/src/main/java/java/util/stream/ReferencePipeline.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/ReferencePipeline.java
-ojluni/src/main/java/java/util/stream/Sink.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Sink.java
-ojluni/src/main/java/java/util/stream/SliceOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/SliceOps.java
-ojluni/src/main/java/java/util/stream/SortedOps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/SortedOps.java
-ojluni/src/main/java/java/util/stream/SpinedBuffer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/SpinedBuffer.java
-ojluni/src/main/java/java/util/stream/Stream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Stream.java
-ojluni/src/main/java/java/util/stream/StreamOpFlag.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/StreamOpFlag.java
-ojluni/src/main/java/java/util/stream/StreamShape.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/StreamShape.java
-ojluni/src/main/java/java/util/stream/StreamSpliterators.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/StreamSpliterators.java
-ojluni/src/main/java/java/util/stream/StreamSupport.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/StreamSupport.java
-ojluni/src/main/java/java/util/stream/Streams.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Streams.java
-ojluni/src/main/java/java/util/stream/TerminalOp.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/TerminalOp.java
-ojluni/src/main/java/java/util/stream/TerminalSink.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/TerminalSink.java
-ojluni/src/main/java/java/util/stream/Tripwire.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/Tripwire.java
-ojluni/src/main/java/java/util/stream/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/stream/package-info.java
+ojluni/src/main/java/java/util/stream/AbstractPipeline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/AbstractPipeline.java
+ojluni/src/main/java/java/util/stream/AbstractShortCircuitTask.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/AbstractShortCircuitTask.java
+ojluni/src/main/java/java/util/stream/AbstractSpinedBuffer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/AbstractSpinedBuffer.java
+ojluni/src/main/java/java/util/stream/AbstractTask.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/AbstractTask.java
+ojluni/src/main/java/java/util/stream/BaseStream.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/BaseStream.java
+ojluni/src/main/java/java/util/stream/Collector.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Collector.java
+ojluni/src/main/java/java/util/stream/Collectors.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Collectors.java
+ojluni/src/main/java/java/util/stream/DistinctOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/DistinctOps.java
+ojluni/src/main/java/java/util/stream/DoublePipeline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/DoublePipeline.java
+ojluni/src/main/java/java/util/stream/DoubleStream.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/DoubleStream.java
+ojluni/src/main/java/java/util/stream/FindOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/FindOps.java
+ojluni/src/main/java/java/util/stream/ForEachOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/ForEachOps.java
+ojluni/src/main/java/java/util/stream/IntPipeline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/IntPipeline.java
+ojluni/src/main/java/java/util/stream/IntStream.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/IntStream.java
+ojluni/src/main/java/java/util/stream/LongPipeline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/LongPipeline.java
+ojluni/src/main/java/java/util/stream/LongStream.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/LongStream.java
+ojluni/src/main/java/java/util/stream/MatchOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/MatchOps.java
+ojluni/src/main/java/java/util/stream/Node.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Node.java
+ojluni/src/main/java/java/util/stream/Nodes.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Nodes.java
+ojluni/src/main/java/java/util/stream/PipelineHelper.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/PipelineHelper.java
+ojluni/src/main/java/java/util/stream/ReduceOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/ReduceOps.java
+ojluni/src/main/java/java/util/stream/ReferencePipeline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/ReferencePipeline.java
+ojluni/src/main/java/java/util/stream/Sink.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Sink.java
+ojluni/src/main/java/java/util/stream/SliceOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/SliceOps.java
+ojluni/src/main/java/java/util/stream/SortedOps.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/SortedOps.java
+ojluni/src/main/java/java/util/stream/SpinedBuffer.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/SpinedBuffer.java
+ojluni/src/main/java/java/util/stream/Stream.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Stream.java
+ojluni/src/main/java/java/util/stream/StreamOpFlag.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/StreamOpFlag.java
+ojluni/src/main/java/java/util/stream/StreamShape.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/StreamShape.java
+ojluni/src/main/java/java/util/stream/StreamSpliterators.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/StreamSpliterators.java
+ojluni/src/main/java/java/util/stream/StreamSupport.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/StreamSupport.java
+ojluni/src/main/java/java/util/stream/Streams.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Streams.java
+ojluni/src/main/java/java/util/stream/TerminalOp.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/TerminalOp.java
+ojluni/src/main/java/java/util/stream/TerminalSink.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/TerminalSink.java
+ojluni/src/main/java/java/util/stream/Tripwire.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/Tripwire.java
+ojluni/src/main/java/java/util/stream/package-info.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/java/util/stream/package-info.java
 ojluni/src/main/java/java/util/zip/Adler32.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/Adler32.java
 ojluni/src/main/java/java/util/zip/CRC32.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/CRC32.java
 ojluni/src/main/java/java/util/zip/CRC32C.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/CRC32C.java
@@ -1407,9 +1410,15 @@ ojluni/src/main/java/javax/sql/StatementEventListener.java,jdk7u/jdk7u40-b60,jdk
 ojluni/src/main/java/jdk/internal/HotSpotIntrinsicCandidate.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/HotSpotIntrinsicCandidate.java
 ojluni/src/main/java/jdk/internal/ValueBased.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/ValueBased.java
 ojluni/src/main/java/jdk/internal/access/JavaIOFileDescriptorAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
+ojluni/src/main/java/jdk/internal/access/JavaLangAccess.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java
 ojluni/src/main/java/jdk/internal/access/JavaObjectInputStreamAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
 ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
 ojluni/src/main/java/jdk/internal/access/SharedSecrets.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
+ojluni/src/main/java/jdk/internal/event/Event.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/event/Event.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadEndEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadPinnedEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadStartEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadSubmitFailedEvent.java
 ojluni/src/main/java/jdk/internal/math/DoubleConsts.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/jdk/internal/math/DoubleConsts.java
 ojluni/src/main/java/jdk/internal/math/FDBigInteger.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/math/FDBigInteger.java
 ojluni/src/main/java/jdk/internal/math/FloatConsts.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/jdk/internal/math/FloatConsts.java
@@ -1420,6 +1429,7 @@ ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java,jdk17u/jdk-17
 ojluni/src/main/java/jdk/internal/misc/Unsafe.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/misc/Unsafe.java
 ojluni/src/main/java/jdk/internal/misc/UnsafeConstants.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/misc/UnsafeConstants.java
 ojluni/src/main/java/jdk/internal/misc/VM.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/misc/VM.java
+ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/jdk/internal/misc/VirtualThreads.java
 ojluni/src/main/java/jdk/internal/ref/Cleaner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/Cleaner.java
 ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java
 ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java
@@ -1429,10 +1439,18 @@ ojluni/src/main/java/jdk/internal/reflect/Reflection.java,jdk11u/jdk-11.0.13-ga,
 ojluni/src/main/java/jdk/internal/util/ArraysSupport.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
 ojluni/src/main/java/jdk/internal/util/NullableKeyValueHolder.java,jdk21u/jdk-21.0.1-ga,src/java.base/share/classes/jdk/internal/util/NullableKeyValueHolder.java
 ojluni/src/main/java/jdk/internal/util/Preconditions.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/Preconditions.java
+ojluni/src/main/java/jdk/internal/util/ReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferenceKey.java
+ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferencedKeyMap.java
+ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferencedKeySet.java
+ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/SoftReferenceKey.java
 ojluni/src/main/java/jdk/internal/util/StaticProperty.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/StaticProperty.java
+ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/StrongReferenceKey.java
+ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/WeakReferenceKey.java
 ojluni/src/main/java/jdk/internal/util/jar/JarIndex.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/jdk/internal/util/jar/JarIndex.java
 ojluni/src/main/java/jdk/internal/util/random/RandomSupport.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/random/RandomSupport.java
+ojluni/src/main/java/jdk/internal/vm/StackChunk.java,jdk21u/jdk-21.0.3-ga,src/java.base/share/classes/jdk/internal/vm/StackChunk.java
 ojluni/src/main/java/jdk/internal/vm/annotation/Contended.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Contended.java
+ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java,jdk21u/jdk-21.0.2-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ForceInline.java
 ojluni/src/main/java/jdk/internal/vm/annotation/IntrinsicCandidate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/IntrinsicCandidate.java
 ojluni/src/main/java/jdk/internal/vm/annotation/ReservedStackAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ReservedStackAccess.java
 ojluni/src/main/java/jdk/internal/vm/annotation/Stable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Stable.java
@@ -2340,24 +2358,37 @@ ojluni/src/test/java/time/test/java/time/temporal/TestJulianFields.java,jdk17u/j
 ojluni/src/test/java/time/test/java/time/zone/TestFixedZoneRules.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/zone/TestFixedZoneRules.java
 ojluni/src/test/java/time/test/java/time/zone/TestZoneRules.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/zone/TestZoneRules.java
 ojluni/src/test/java/time/test/java/util/TestFormatter.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/util/TestFormatter.java
-ojluni/src/test/java/util/ArrayList/AddAll.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/ArrayList/AddAll.java
-ojluni/src/test/java/util/ArrayList/ArrayManagement.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/ArrayList/ArrayManagement.java
-ojluni/src/test/java/util/ArrayList/Bug6533203.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/ArrayList/Bug6533203.java
-ojluni/src/test/java/util/ArrayList/EnsureCapacity.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/ArrayList/EnsureCapacity.java
-ojluni/src/test/java/util/ArrayList/SubListModCount.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/ArrayList/SubListModCount.java
-ojluni/src/test/java/util/Arrays/ArrayObjectMethods.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/ArrayObjectMethods.java
-ojluni/src/test/java/util/Arrays/ArraysEqCmpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/ArraysEqCmpTest.java
-ojluni/src/test/java/util/Arrays/AsList.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/AsList.java
-ojluni/src/test/java/util/Arrays/CopyMethods.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/CopyMethods.java
-ojluni/src/test/java/util/Arrays/Correct.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/Correct.java
-ojluni/src/test/java/util/Arrays/Fill.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/Fill.java
-ojluni/src/test/java/util/Arrays/FloatDoubleOrder.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/FloatDoubleOrder.java
-ojluni/src/test/java/util/Arrays/SetAllTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/SetAllTest.java
-ojluni/src/test/java/util/Arrays/Sorting.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/Sorting.java
-ojluni/src/test/java/util/Arrays/SortingHelper.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/java.base/java/util/SortingHelper.java
-ojluni/src/test/java/util/Arrays/SortingNearlySortedPrimitive.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/SortingNearlySortedPrimitive.java
-ojluni/src/test/java/util/Arrays/StreamAndSpliterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/StreamAndSpliterator.java
-ojluni/src/test/java/util/Arrays/TimSortStackSize.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Arrays/TimSortStackSize.java
+ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractCollection/ToArrayTest.java
+ojluni/src/test/java/util/AbstractCollection/ToString.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractCollection/ToString.java
+ojluni/src/test/java/util/AbstractList/CheckForComodification.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractList/CheckForComodification.java
+ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractList/CheckForIndexOutOfBoundsException.java
+ojluni/src/test/java/util/AbstractList/FailFastIterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractList/FailFastIterator.java
+ojluni/src/test/java/util/AbstractList/HasNextAfterException.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractList/HasNextAfterException.java
+ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractMap/AbstractMapClone.java
+ojluni/src/test/java/util/AbstractMap/Equals.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractMap/Equals.java
+ojluni/src/test/java/util/AbstractMap/SimpleEntries.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractMap/SimpleEntries.java
+ojluni/src/test/java/util/AbstractMap/ToString.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractMap/ToString.java
+ojluni/src/test/java/util/AbstractSequentialList/AddAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/AbstractSequentialList/AddAll.java
+ojluni/src/test/java/util/ArrayList/AddAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/ArrayList/AddAll.java
+ojluni/src/test/java/util/ArrayList/ArrayManagement.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/ArrayList/ArrayManagement.java
+ojluni/src/test/java/util/ArrayList/Bug6533203.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/ArrayList/Bug6533203.java
+ojluni/src/test/java/util/ArrayList/EnsureCapacity.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/ArrayList/EnsureCapacity.java
+ojluni/src/test/java/util/ArrayList/SubListModCount.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/ArrayList/SubListModCount.java
+ojluni/src/test/java/util/Arrays/ArrayObjectMethods.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/ArrayObjectMethods.java
+ojluni/src/test/java/util/Arrays/ArraysEqCmpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/ArraysEqCmpTest.java
+ojluni/src/test/java/util/Arrays/AsList.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/AsList.java
+ojluni/src/test/java/util/Arrays/CopyMethods.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/CopyMethods.java
+ojluni/src/test/java/util/Arrays/Correct.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/Correct.java
+ojluni/src/test/java/util/Arrays/Fill.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/Fill.java
+ojluni/src/test/java/util/Arrays/FloatDoubleOrder.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/FloatDoubleOrder.java
+ojluni/src/test/java/util/Arrays/HashCode.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/HashCode.java
+ojluni/src/test/java/util/Arrays/SetAllTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/SetAllTest.java
+ojluni/src/test/java/util/Arrays/Sorting.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/Sorting.java
+ojluni/src/test/java/util/Arrays/SortingHelper.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/java.base/java/util/SortingHelper.java
+ojluni/src/test/java/util/Arrays/SortingNearlySortedPrimitive.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/SortingNearlySortedPrimitive.java
+ojluni/src/test/java/util/Arrays/StreamAndSpliterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/StreamAndSpliterator.java
+ojluni/src/test/java/util/Arrays/TimSortStackSize.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/TimSortStackSize.java
+ojluni/src/test/java/util/Arrays/TimSortStackSize2.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Arrays/TimSortStackSize2.java
 ojluni/src/test/java/util/Base64/Base64GetEncoderTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Base64/Base64GetEncoderTest.java
 ojluni/src/test/java/util/Base64/TestBase64.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/Base64/TestBase64.java
 ojluni/src/test/java/util/Base64/TestBase64Golden.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Base64/TestBase64Golden.java
@@ -2365,92 +2396,114 @@ ojluni/src/test/java/util/Base64/baseEncode.txt,jdk17u/jdk-17.0.6-ga,test/jdk/ja
 ojluni/src/test/java/util/Base64/mimeEncode.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Base64/mimeEncode.txt
 ojluni/src/test/java/util/Base64/plain.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Base64/plain.txt
 ojluni/src/test/java/util/Base64/urlEncode.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Base64/urlEncode.txt
-ojluni/src/test/java/util/BitSet/And.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/And.java
-ojluni/src/test/java/util/BitSet/BSMethods.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/BSMethods.java
-ojluni/src/test/java/util/BitSet/ImportExport.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/ImportExport.java
-ojluni/src/test/java/util/BitSet/MemoryLeak.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/MemoryLeak.java
-ojluni/src/test/java/util/BitSet/PreviousBits.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/PreviousBits.java
-ojluni/src/test/java/util/BitSet/StickySize.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/StickySize.java
-ojluni/src/test/java/util/BitSet/stream/BitSetStreamTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/BitSet/stream/BitSetStreamTest.java
-ojluni/src/test/java/util/Collection/MOAT.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collection/MOAT.java
-ojluni/src/test/java/util/Collections/AddAll.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/AddAll.java
-ojluni/src/test/java/util/Collections/AsLifoQueue.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/AsLifoQueue.java
-ojluni/src/test/java/util/Collections/BigBinarySearch.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/BigBinarySearch.java
-ojluni/src/test/java/util/Collections/BinarySearchNullComparator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/BinarySearchNullComparator.java
-ojluni/src/test/java/util/Collections/CheckedIdentityMap.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedIdentityMap.java
-ojluni/src/test/java/util/Collections/CheckedListBash.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedListBash.java
-ojluni/src/test/java/util/Collections/CheckedListReplaceAll.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedListReplaceAll.java
-ojluni/src/test/java/util/Collections/CheckedMapBash.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedMapBash.java
-ojluni/src/test/java/util/Collections/CheckedMapReplaceAll.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedMapReplaceAll.java
-ojluni/src/test/java/util/Collections/CheckedNull.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedNull.java
-ojluni/src/test/java/util/Collections/CheckedQueue.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedQueue.java
-ojluni/src/test/java/util/Collections/CheckedSetBash.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/CheckedSetBash.java
-ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/DelegatingIteratorForEachRemaining.java
-ojluni/src/test/java/util/Collections/Disjoint.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Disjoint.java
-ojluni/src/test/java/util/Collections/EmptyCollectionSerialization.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EmptyCollectionSerialization.java
-ojluni/src/test/java/util/Collections/EmptyIterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EmptyIterator.java
-ojluni/src/test/java/util/Collections/EmptyNavigableMap.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EmptyNavigableMap.java
-ojluni/src/test/java/util/Collections/EmptyNavigableSet.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EmptyNavigableSet.java
-ojluni/src/test/java/util/Collections/Enum.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Enum.java
-ojluni/src/test/java/util/Collections/EnumerationAsIterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EnumerationAsIterator.java
-ojluni/src/test/java/util/Collections/EqualsTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/EqualsTest.java
-ojluni/src/test/java/util/Collections/FindSubList.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/FindSubList.java
-ojluni/src/test/java/util/Collections/Frequency.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Frequency.java
-ojluni/src/test/java/util/Collections/MinMax.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/MinMax.java
-ojluni/src/test/java/util/Collections/NCopies.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/NCopies.java
-ojluni/src/test/java/util/Collections/NullComparator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/NullComparator.java
-ojluni/src/test/java/util/Collections/RacingCollections.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/RacingCollections.java
-ojluni/src/test/java/util/Collections/ReplaceAll.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/ReplaceAll.java
-ojluni/src/test/java/util/Collections/ReverseOrder.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/ReverseOrder.java
-ojluni/src/test/java/util/Collections/ReverseOrder2.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/ReverseOrder2.java
-ojluni/src/test/java/util/Collections/Rotate.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Rotate.java
-ojluni/src/test/java/util/Collections/RotateEmpty.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/RotateEmpty.java
-ojluni/src/test/java/util/Collections/Ser.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Ser.java
-ojluni/src/test/java/util/Collections/SetFromMap.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/SetFromMap.java
-ojluni/src/test/java/util/Collections/SingletonIterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/SingletonIterator.java
-ojluni/src/test/java/util/Collections/Swap.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Swap.java
-ojluni/src/test/java/util/Collections/SyncSubMutexes.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/SyncSubMutexes.java
-ojluni/src/test/java/util/Collections/T6433170.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/T6433170.java
-ojluni/src/test/java/util/Collections/UnmodifiableMapEntrySet.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/UnmodifiableMapEntrySet.java
-ojluni/src/test/java/util/Collections/ViewSynch.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/ViewSynch.java
-ojluni/src/test/java/util/Collections/WrappedNull.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/WrappedNull.java
-ojluni/src/test/java/util/Collections/WrappedUnmodifiableCollections.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/WrappedUnmodifiableCollections.java
-ojluni/src/test/java/util/Collections/Wrappers.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Collections/Wrappers.java
-ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/DoubleStreamSums/CompensatedSums.java
-ojluni/src/test/java/util/DoubleSummaryStatistics/NegativeCompensation.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java
-ojluni/src/test/java/util/HashMap/HashMapCloneLeak.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/HashMapCloneLeak.java
-ojluni/src/test/java/util/HashMap/KeySetRemove.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/KeySetRemove.java
-ojluni/src/test/java/util/HashMap/NullKeyAtResize.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/NullKeyAtResize.java
-ojluni/src/test/java/util/HashMap/OverrideIsEmpty.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/OverrideIsEmpty.java
-ojluni/src/test/java/util/HashMap/PutNullKey.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/PutNullKey.java
-ojluni/src/test/java/util/HashMap/ReplaceExisting.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/ReplaceExisting.java
-ojluni/src/test/java/util/HashMap/SetValue.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/SetValue.java
-ojluni/src/test/java/util/HashMap/ToArray.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/ToArray.java
-ojluni/src/test/java/util/HashMap/ToString.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/ToString.java
-ojluni/src/test/java/util/HashMap/TreeBinAssert.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/TreeBinAssert.java
-ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashMap/WhiteBoxResizeTest.java
-ojluni/src/test/java/util/HashSet/Serialization.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HashSet/Serialization.java
+ojluni/src/test/java/util/BitSet/And.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/And.java
+ojluni/src/test/java/util/BitSet/BSMethods.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/BSMethods.java
+ojluni/src/test/java/util/BitSet/ImportExport.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/ImportExport.java
+ojluni/src/test/java/util/BitSet/MemoryLeak.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/MemoryLeak.java
+ojluni/src/test/java/util/BitSet/PreviousBits.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/PreviousBits.java
+ojluni/src/test/java/util/BitSet/StickySize.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/StickySize.java
+ojluni/src/test/java/util/BitSet/stream/BitSetStreamTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/BitSet/stream/BitSetStreamTest.java
+ojluni/src/test/java/util/Collection/MOAT.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collection/MOAT.java
+ojluni/src/test/java/util/Collections/AddAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/AddAll.java
+ojluni/src/test/java/util/Collections/AsLifoQueue.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/AsLifoQueue.java
+ojluni/src/test/java/util/Collections/BigBinarySearch.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/BigBinarySearch.java
+ojluni/src/test/java/util/Collections/BinarySearchNullComparator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/BinarySearchNullComparator.java
+ojluni/src/test/java/util/Collections/CheckedIdentityMap.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedIdentityMap.java
+ojluni/src/test/java/util/Collections/CheckedListBash.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedListBash.java
+ojluni/src/test/java/util/Collections/CheckedListReplaceAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedListReplaceAll.java
+ojluni/src/test/java/util/Collections/CheckedMapBash.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedMapBash.java
+ojluni/src/test/java/util/Collections/CheckedMapReplaceAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedMapReplaceAll.java
+ojluni/src/test/java/util/Collections/CheckedNull.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedNull.java
+ojluni/src/test/java/util/Collections/CheckedQueue.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedQueue.java
+ojluni/src/test/java/util/Collections/CheckedSetBash.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/CheckedSetBash.java
+ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/DelegatingIteratorForEachRemaining.java
+ojluni/src/test/java/util/Collections/Disjoint.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Disjoint.java
+ojluni/src/test/java/util/Collections/EmptyCollectionSerialization.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EmptyCollectionSerialization.java
+ojluni/src/test/java/util/Collections/EmptyIterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EmptyIterator.java
+ojluni/src/test/java/util/Collections/EmptyNavigableMap.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EmptyNavigableMap.java
+ojluni/src/test/java/util/Collections/EmptyNavigableSet.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EmptyNavigableSet.java
+ojluni/src/test/java/util/Collections/Enum.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Enum.java
+ojluni/src/test/java/util/Collections/EnumerationAsIterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EnumerationAsIterator.java
+ojluni/src/test/java/util/Collections/EqualsTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/EqualsTest.java
+ojluni/src/test/java/util/Collections/FindSubList.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/FindSubList.java
+ojluni/src/test/java/util/Collections/Frequency.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Frequency.java
+ojluni/src/test/java/util/Collections/MinMax.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/MinMax.java
+ojluni/src/test/java/util/Collections/NCopies.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/NCopies.java
+ojluni/src/test/java/util/Collections/NullComparator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/NullComparator.java
+ojluni/src/test/java/util/Collections/RacingCollections.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/RacingCollections.java
+ojluni/src/test/java/util/Collections/ReplaceAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/ReplaceAll.java
+ojluni/src/test/java/util/Collections/ReverseOrder.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/ReverseOrder.java
+ojluni/src/test/java/util/Collections/ReverseOrder2.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/ReverseOrder2.java
+ojluni/src/test/java/util/Collections/Rotate.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Rotate.java
+ojluni/src/test/java/util/Collections/RotateEmpty.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/RotateEmpty.java
+ojluni/src/test/java/util/Collections/Ser.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Ser.java
+ojluni/src/test/java/util/Collections/SetFromMap.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/SetFromMap.java
+ojluni/src/test/java/util/Collections/SingletonIterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/SingletonIterator.java
+ojluni/src/test/java/util/Collections/Swap.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Swap.java
+ojluni/src/test/java/util/Collections/SyncSubMutexes.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/SyncSubMutexes.java
+ojluni/src/test/java/util/Collections/T6433170.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/T6433170.java
+ojluni/src/test/java/util/Collections/UnmodifiableMapEntrySet.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/UnmodifiableMapEntrySet.java
+ojluni/src/test/java/util/Collections/ViewSynch.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/ViewSynch.java
+ojluni/src/test/java/util/Collections/WrappedNull.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/WrappedNull.java
+ojluni/src/test/java/util/Collections/WrappedUnmodifiableCollections.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/WrappedUnmodifiableCollections.java
+ojluni/src/test/java/util/Collections/Wrappers.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Collections/Wrappers.java
+ojluni/src/test/java/util/Comparator/BasicTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Comparator/BasicTest.java
+ojluni/src/test/java/util/Comparator/TypeTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/Comparator/TypeTest.java
+ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/DoubleStreamSums/CompensatedSums.java
+ojluni/src/test/java/util/DoubleSummaryStatistics/NegativeCompensation.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java
+ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/DistinctEntrySetElements.java
+ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
+ojluni/src/test/java/util/EnumMap/EnumMapBash.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/EnumMapBash.java
+ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/ProperEntrySetOnClone.java
+ojluni/src/test/java/util/EnumMap/SimpleSerialization.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/SimpleSerialization.java
+ojluni/src/test/java/util/EnumMap/ToArray.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/ToArray.java
+ojluni/src/test/java/util/EnumMap/UniqueNullValue.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumMap/UniqueNullValue.java
+ojluni/src/test/java/util/EnumSet/AllOf.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/AllOf.java
+ojluni/src/test/java/util/EnumSet/BogusEnumSet.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/BogusEnumSet.java
+ojluni/src/test/java/util/EnumSet/ComplementOf.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/ComplementOf.java
+ojluni/src/test/java/util/EnumSet/EnumSetBash.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/EnumSetBash.java
+ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/EnumSetClassSerialization.java
+ojluni/src/test/java/util/EnumSet/InsertWrongType.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/InsertWrongType.java
+ojluni/src/test/java/util/EnumSet/JumboRange.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/JumboRange.java
+ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
+ojluni/src/test/java/util/EnumSet/OneUniverse.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/OneUniverse.java
+ojluni/src/test/java/util/EnumSet/Range.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/Range.java
+ojluni/src/test/java/util/EnumSet/RetainAll.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/RetainAll.java
+ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
+ojluni/src/test/java/util/HashMap/HashMapCloneLeak.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/HashMapCloneLeak.java
+ojluni/src/test/java/util/HashMap/KeySetRemove.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/KeySetRemove.java
+ojluni/src/test/java/util/HashMap/NullKeyAtResize.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/NullKeyAtResize.java
+ojluni/src/test/java/util/HashMap/OverrideIsEmpty.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/OverrideIsEmpty.java
+ojluni/src/test/java/util/HashMap/PutNullKey.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/PutNullKey.java
+ojluni/src/test/java/util/HashMap/ReplaceExisting.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/ReplaceExisting.java
+ojluni/src/test/java/util/HashMap/SetValue.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/SetValue.java
+ojluni/src/test/java/util/HashMap/ToArray.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/ToArray.java
+ojluni/src/test/java/util/HashMap/ToString.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/ToString.java
+ojluni/src/test/java/util/HashMap/TreeBinAssert.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/TreeBinAssert.java
+ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/WhiteBoxResizeTest.java
+ojluni/src/test/java/util/HashSet/Serialization.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashSet/Serialization.java
 ojluni/src/test/java/util/HexFormat/HexFormatTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/HexFormat/HexFormatTest.java
+ojluni/src/test/java/util/IdentityHashMap/Basic.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/IdentityHashMap/Basic.java
 ojluni/src/test/java/util/IdentityHashMap/Capacity.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/IdentityHashMap/Capacity.java
 ojluni/src/test/java/util/IdentityHashMap/DistinctEntrySetElements.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/IdentityHashMap/DistinctEntrySetElements.java
 ojluni/src/test/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java
 ojluni/src/test/java/util/IdentityHashMap/ToArray.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/IdentityHashMap/ToArray.java
 ojluni/src/test/java/util/IdentityHashMap/ToString.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/IdentityHashMap/ToString.java
-ojluni/src/test/java/util/LinkedHashMap/Basic.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/LinkedHashMap/Basic.java
-ojluni/src/test/java/util/LinkedHashMap/Cache.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/LinkedHashMap/Cache.java
-ojluni/src/test/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java
-ojluni/src/test/java/util/LinkedHashMap/EmptyMapIterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/LinkedHashMap/EmptyMapIterator.java
-ojluni/src/test/java/util/LinkedHashSet/Basic.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/LinkedHashSet/Basic.java
+ojluni/src/test/java/util/LinkedHashMap/Basic.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/LinkedHashMap/Basic.java
+ojluni/src/test/java/util/LinkedHashMap/Cache.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/LinkedHashMap/Cache.java
+ojluni/src/test/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java
+ojluni/src/test/java/util/LinkedHashMap/EmptyMapIterator.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/LinkedHashMap/EmptyMapIterator.java
+ojluni/src/test/java/util/LinkedHashSet/Basic.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/LinkedHashSet/Basic.java
 ojluni/src/test/java/util/Optional/Basic.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Optional/Basic.java
 ojluni/src/test/java/util/Optional/BasicDouble.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Optional/BasicDouble.java
 ojluni/src/test/java/util/Optional/BasicInt.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Optional/BasicInt.java
 ojluni/src/test/java/util/Optional/BasicLong.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Optional/BasicLong.java
 ojluni/src/test/java/util/Optional/ObscureException.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Optional/ObscureException.java
-ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/PriorityQueue/AddNonComparable.java
-ojluni/src/test/java/util/PriorityQueue/ForgetMeNot.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/PriorityQueue/ForgetMeNot.java
-ojluni/src/test/java/util/PriorityQueue/NoNulls.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/PriorityQueue/NoNulls.java
-ojluni/src/test/java/util/PriorityQueue/PriorityQueueSort.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/PriorityQueue/PriorityQueueSort.java
-ojluni/src/test/java/util/PriorityQueue/RemoveContains.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/PriorityQueue/RemoveContains.java
+ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/PriorityQueue/AddNonComparable.java
+ojluni/src/test/java/util/PriorityQueue/ForgetMeNot.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/PriorityQueue/ForgetMeNot.java
+ojluni/src/test/java/util/PriorityQueue/NoNulls.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/PriorityQueue/NoNulls.java
+ojluni/src/test/java/util/PriorityQueue/PriorityQueueSort.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/PriorityQueue/PriorityQueueSort.java
+ojluni/src/test/java/util/PriorityQueue/RemoveContains.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/PriorityQueue/RemoveContains.java
 ojluni/src/test/java/util/Properties/BlankLines.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/BlankLines.java
 ojluni/src/test/java/util/Properties/Bug6609431.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/Bug6609431.java
 ojluni/src/test/java/util/Properties/Bug6609431.properties,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/Bug6609431.properties
@@ -2548,11 +2601,14 @@ ojluni/src/test/java/util/Vector/LastIndexOf.java,jdk17u/jdk-17.0.6-ga,test/jdk/
 ojluni/src/test/java/util/Vector/SerializationDeadlock.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Vector/SerializationDeadlock.java
 ojluni/src/test/java/util/Vector/SimpleSerialization.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Vector/SimpleSerialization.java
 ojluni/src/test/java/util/Vector/SyncLastIndexOf.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Vector/SyncLastIndexOf.java
-ojluni/src/test/java/util/WeakHashMap/GCDuringIteration.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/WeakHashMap/GCDuringIteration.java
-ojluni/src/test/java/util/WeakHashMap/Iteration.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/WeakHashMap/Iteration.java
-ojluni/src/test/java/util/WeakHashMap/ZeroInitCap.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/WeakHashMap/ZeroInitCap.java
+ojluni/src/test/java/util/WeakHashMap/GCDuringIteration.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/WeakHashMap/GCDuringIteration.java
+ojluni/src/test/java/util/WeakHashMap/Iteration.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/WeakHashMap/Iteration.java
+ojluni/src/test/java/util/WeakHashMap/ZeroInitCap.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/WeakHashMap/ZeroInitCap.java
 ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/concurrent/tck/CompletableFutureTest.java
 ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/concurrent/tck/SplittableRandomTest.java
+ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/function/BiFunction/BiFunctionTest.java
+ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/function/BinaryOperator/BasicTest.java
+ojluni/src/test/java/util/function/PredicateNotTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/function/PredicateNotTest.java
 ojluni/src/test/java/util/regex/BMPTestCases.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/BMPTestCases.txt
 ojluni/src/test/java/util/regex/GraphemeTestCases.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/GraphemeTestCases.txt
 ojluni/src/test/java/util/regex/POSIX_ASCII.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/POSIX_ASCII.java
@@ -2561,58 +2617,58 @@ ojluni/src/test/java/util/regex/PatternStreamTest.java,jdk17u/jdk-17.0.6-ga,test
 ojluni/src/test/java/util/regex/RegExTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/RegExTest.java
 ojluni/src/test/java/util/regex/SupplementaryTestCases.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/SupplementaryTestCases.txt
 ojluni/src/test/java/util/regex/TestCases.txt,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/TestCases.txt
-ojluni/src/test/java/util/stream/TestDoubleSumAverage.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/TestDoubleSumAverage.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapMultiOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/mapMultiOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java
+ojluni/src/test/java/util/stream/TestDoubleSumAverage.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/TestDoubleSumAverage.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapMultiOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/mapMultiOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java
 ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorOfIntDataBuilder.java,jdk17u/jdk-17.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorOfIntDataBuilder.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorTestHelper.java,jdk17u/jdk-17.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorTestHelper.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/DefaultMethodStreams.java,jdk17u/jdk-17.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/DefaultMethodStreams.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/ThrowableHelper.java,jdk17u/jdk-17.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/ThrowableHelper.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorOfIntDataBuilder.java,jdk21u/jdk-21.0.2-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorOfIntDataBuilder.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorTestHelper.java,jdk21u/jdk-21.0.2-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorTestHelper.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/DefaultMethodStreams.java,jdk21u/jdk-21.0.2-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/DefaultMethodStreams.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/ThrowableHelper.java,jdk21u/jdk-21.0.2-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/ThrowableHelper.java
 ojluni/src/test/java/util/zip/ChecksumBase.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/zip/ChecksumBase.java
 ojluni/src/test/java/util/zip/CloseInflaterDeflaterTest.java,jdk17u/jdk-17.0.10-ga,test/jdk/java/util/zip/CloseInflaterDeflaterTest.java
 ojluni/src/test/java/util/zip/DeInflate.java,jdk17u/jdk-17.0.10-ga,test/jdk/java/util/zip/DeInflate.java
diff --git a/JavaLibrary.bp b/JavaLibrary.bp
index fbe5e32e7dc..a24ab504564 100644
--- a/JavaLibrary.bp
+++ b/JavaLibrary.bp
@@ -220,6 +220,10 @@ java_library {
         // directly.
         ":okhttp_impl_files",
     ],
+    static_libs: [
+        "art-aconfig-flags-java-lib-for-core-all-only",
+        "libcore-aconfig-flags-lib-for-core-all-only",
+    ],
 
     sdk_version: "none",
     system_modules: "none",
@@ -237,8 +241,10 @@ java_library {
         "unsupportedappusage-annotation-processor",
     ],
     libs: [
-        "conscrypt.module.intra.core.api",
+        "conscrypt.module.intra.core.api.stubs",
     ],
+
+    java_version: "21",
 }
 
 platform_compat_config {
@@ -264,7 +270,10 @@ java_system_modules {
     // Visibility is deliberately restricted to a small set of build modules that
     // the core library team control.
     visibility: [
+        "//art/build/flags",
         "//art/test:__subpackages__",
+        "//build/make/tools/aconfig/aconfig_storage_file",
+        "//build/make/tools/aconfig/aconfig_storage_read_api",
         "//build/make/tools/aconfig/fake_device_config",
         "//external/apache-harmony:__subpackages__",
         "//external/apache-xml",
@@ -284,6 +293,8 @@ java_library {
     visibility: [
         "//art/build/apex",
         "//art/build/sdk",
+        "//art/tools/ahat",
+        "//art/tools/fuzzer",
         "//external/wycheproof",
         "//libcore/benchmarks",
         "//packages/modules/ArtPrebuilt",
@@ -346,6 +357,8 @@ java_library {
     visibility: [
         "//art/build/apex",
         "//art/build/sdk",
+        "//art/tools/ahat",
+        "//art/tools/fuzzer",
         "//external/wycheproof",
         "//libcore/benchmarks",
         "//packages/modules/ArtPrebuilt",
@@ -359,6 +372,10 @@ java_library {
     hostdex: true,
 
     srcs: [":core_libart_java_files"],
+    static_libs: [
+        "art-aconfig-flags-java-lib",
+        "libcore-aconfig-flags-lib",
+    ],
 
     sdk_version: "none",
     system_modules: "core-all-system-modules",
@@ -376,7 +393,7 @@ java_library {
             required: [
                 // Files used to simulate the /system, runtime APEX and tzdata
                 // APEX dir structure on host.
-                "icu_tzdata.dat_host_tzdata_apex",
+                "tzdata_icu_res_files_host_prebuilts",
                 "tzdata_host",
                 "tzdata_host_tzdata_apex",
                 "tzlookup.xml_host_tzdata_apex",
@@ -396,6 +413,8 @@ java_library {
             "-Xep:NullableOnContainingClass:WARN",
         ],
     },
+
+    java_version: "21",
 }
 
 // Java library for use on host, e.g. by robolectric or layoutlib.
@@ -479,6 +498,7 @@ java_library {
     // This jar is packaged as part of the SDK, use -target 8 so that it works
     // with old JDKs.
     java_version: "1.8",
+    is_stubs_module: true,
 }
 
 // An alternative to core-lambda-stubs that omits openjdk_lambda_duplicate_stub_files
@@ -564,6 +584,7 @@ java_library_static {
     name: "core-compat-test-rules",
     visibility: [
         "//art/build/sdk",
+        "//libcore:__subpackages__",
         "//frameworks/base/tests/PlatformCompatGating/test-rules",
         "//libcore:__subpackages__",
     ],
@@ -695,6 +716,14 @@ filegroup {
     visibility: ["//libcore/luni/src/test/java17language"],
 }
 
+// A filegroup that provides access to a source file for a toolchain test that
+// checks Java 21 language features are handled properly by JarJar.
+filegroup {
+    name: "core-java-21-language-features-source",
+    srcs: ["luni/src/main/java/libcore/internal/Java21LanguageFeatures.java"],
+    visibility: ["//libcore/luni/src/test/java21language"],
+}
+
 genrule {
     name: "core-tests-smali-dex",
     srcs: ["luni/src/test/java/**/*.smali"],
@@ -783,6 +812,7 @@ java_test {
         "core-java-9-language-tests",
         "core-java-11-language-tests",
         "core-java-17-language-tests",
+        "core-java-21-language-tests",
         "core-test-rules",
         "core-tests-support",
         "junit-params",
@@ -817,7 +847,12 @@ java_test {
             "-Xep:RandomModInteger:WARN",
             "-Xep:IdentityBinaryExpression:WARN",
             "-Xep:UnnecessaryStringBuilder:OFF", // https://github.com/google/error-prone/issues/4195
-            "-Xep:InvalidPatternSyntax:WARN",
+            // Some of the invalid regexes in the tests cause java to throw
+            // an exception that contains a null byte. The null byte is then
+            // printed by errorprone to the build log, causing some tools to
+            // think the build log is a binary file. Disable instead of demoting
+            // to a warning.
+            "-Xep:InvalidPatternSyntax:OFF",
         ],
     },
 
@@ -913,6 +948,12 @@ droiddoc_exported_dir {
     visibility: ["//visibility:private"],
 }
 
+droiddoc_exported_dir {
+    name: "toolchainapi-annotated-flagged-stubs",
+    path: "ojluni/annotations/flagged_toolchainapi",
+    visibility: ["//libcore/toolchainapi"],
+}
+
 // A file containing the list of tags that are "known" to us from the OpenJdk
 // source code and so should not cause an error or warning.
 filegroup {
@@ -1000,39 +1041,105 @@ java_system_modules {
 java_library {
     name: "framework-api-annotations-lib",
     srcs: [":framework-api-annotations"],
+    static_libs: ["aconfig-annotations-lib-sdk-none"],
     sdk_version: "none",
     patch_module: "java.base",
     system_modules: "core-all-system-modules",
     installable: false,
     visibility: [
-        "//visibility:private",
+        "//art/build/flags",
+        "//libcore:__subpackages__",
     ],
 }
 
 aconfig_declarations {
-    name: "libcore_aconfig_flags",
+    name: "libcore-aconfig-flags",
     package: "com.android.libcore",
     container: "com.android.art",
     exportable: true,
     srcs: ["libcore.aconfig"],
     visibility: [
+        "//libcore:__subpackages__",
         "//frameworks/base",
     ],
 }
 
+java_system_modules {
+    name: "libcore-bootstrap-core-current-from-text-system-modules",
+    libs: ["core.current.stubs.from-text"],
+    visibility: ["//visibility:private"],
+}
+
+java_library {
+    name: "libcore-bootstrap-lib-for-flags-lib",
+    srcs: [
+        // Needs @UnsupportedAppUsage definition from this source
+        ":app-compat-annotations-source",
+        // Needs @AssumeFalseForR8 and AconfigFlagAccessor from this source
+        ":framework-api-annotations",
+        // Needs LambdaMetafactory due to lambda usage in the lib
+        ":openjdk_lambda_stub_files",
+    ],
+    sdk_version: "none",
+    patch_module: "java.base",
+    system_modules: "libcore-bootstrap-core-current-from-text-system-modules",
+    installable: false,
+    visibility: [
+        "//visibility:private",
+    ],
+}
+
+// We need this system module because openjdk_lambda_stub_files and core.current.stubs.from-text
+// need to be in the same module. Otherwise, javac isn't happy to use the LambdaMetaFactory if
+// it's not in the system module.
+java_system_modules {
+    name: "libcore-bootstrap-lib-for-flags-lib-system-modules",
+    libs: [
+        "core.current.stubs.from-text",
+        "libcore-bootstrap-lib-for-flags-lib",
+    ],
+    visibility: ["//visibility:private"],
+}
+
 java_aconfig_library {
-    name: "libcore_aconfig_flags_lib",
-    aconfig_declarations: "libcore_aconfig_flags",
+    name: "libcore-aconfig-flags-lib-for-core-all-only",
+    aconfig_declarations: "libcore-aconfig-flags",
+    // This system module is specifically crafted to avoid a circular dependency on core-all.
+    // Instead of dependency on core-all, this system module contains the stubs generated from
+    // API files, e.g. libcore/api/current.txt. See "core.current.stubs.from-text" for more details.
+    // An alternative is to generate the .java source files of this lib without running javac,
+    // but it wasn't possible using java_aconfig_library when this comment is written.
+    system_modules: "libcore-bootstrap-lib-for-flags-lib-system-modules",
+    sdk_version: "none",
+    patch_module: "java.base",
+    installable: false,
+    visibility: ["//visibility:private"],
+}
+
+java_aconfig_library {
+    name: "art-aconfig-flags-java-lib-for-core-all-only",
+    aconfig_declarations: "art-aconfig-flags",
+    system_modules: "libcore-bootstrap-lib-for-flags-lib-system-modules",
+    sdk_version: "none",
+    patch_module: "java.base",
+    installable: false,
+    visibility: ["//visibility:private"],
+}
+
+java_aconfig_library {
+    name: "libcore-aconfig-flags-lib",
+    aconfig_declarations: "libcore-aconfig-flags",
     sdk_version: "none",
     patch_module: "java.base",
     system_modules: "core-all-system-modules",
+    libs: ["framework-api-annotations-lib"],
+    min_sdk_version: "31", // ART module is enabled on Android 12 or above.
     apex_available: [
         "com.android.art",
-        // Remove :platform until we allow platform codes to use libcore's @FlaggedApi APIs
-        // "//apex_available:platform",
+        "com.android.art.debug",
     ],
     visibility: [
-        "//visibility:private",
+        "//libcore:__subpackages__",
     ],
 }
 
@@ -1072,7 +1179,8 @@ java_sdk_library {
         // java.text.CollectionElementIterator.NULLORDER to be initialized from
         // android.icu.text.CollationElementIterator.NULLORDER.
         "i18n.module.intra.core.api.stubs",
-        "libcore_aconfig_flags_lib",
+        "art-aconfig-flags-java-lib",
+        "libcore-aconfig-flags-lib",
     ],
     stub_only_static_libs: ["notices-for-stubs-jar"],
 
@@ -1128,7 +1236,8 @@ java_sdk_library {
     dist_stem: "art",
     dist_group: "android",
     aconfig_declarations: [
-        "libcore_aconfig_flags",
+        "art-aconfig-flags",
+        "libcore-aconfig-flags",
     ],
 }
 
diff --git a/NativeCode.bp b/NativeCode.bp
index db337dce1da..e624e9cb239 100644
--- a/NativeCode.bp
+++ b/NativeCode.bp
@@ -55,6 +55,7 @@ cc_library_shared {
     visibility: [
         "//art/build/apex",
         "//art/runtime",
+        "//art/tools/ahat",
     ],
     apex_available: [
         "com.android.art",
@@ -85,6 +86,7 @@ cc_library_shared {
     visibility: [
         "//art/build/apex",
         "//art/build/sdk",
+        "//art/tools/ahat",
         "//external/conscrypt",
     ],
     apex_available: [
@@ -167,6 +169,7 @@ cc_library_shared {
     name: "libopenjdk",
     visibility: [
         "//art/build/apex",
+        "//art/tools/ahat",
     ],
     apex_available: [
         "com.android.art",
@@ -183,6 +186,7 @@ cc_library_shared {
     name: "libopenjdkd",
     visibility: [
         "//art/build/apex",
+        "//art/tools/ahat",
     ],
     apex_available: [
         "com.android.art.debug",
diff --git a/OWNERS b/OWNERS
index a6e71fee60b..058e0eaf7a7 100644
--- a/OWNERS
+++ b/OWNERS
@@ -17,7 +17,6 @@ vichang@google.com
 
 # Emeritus libcore team members; don't send review emails to them
 # unless you are in the libcore team.
-nfuller@google.com #{LAST_RESORT_SUGGESTION}
 paulduffin@google.com #{LAST_RESORT_SUGGESTION}
 
 # Don't send these folks any review emails for this project.
diff --git a/OWNERS_net b/OWNERS_net
new file mode 100644
index 00000000000..79e18e2aed2
--- /dev/null
+++ b/OWNERS_net
@@ -0,0 +1,5 @@
+# Owners of Libcore networking code.
+prb@google.com
+sorinbasca@google.com
+narayan@google.com
+ngeoffray@google.com
diff --git a/OWNERS_net_tests b/OWNERS_net_tests
index 29b65caf5c5..0be5cb1c487 100644
--- a/OWNERS_net_tests
+++ b/OWNERS_net_tests
@@ -1,5 +1 @@
-# Owners of Libcore networking tests.
-prb@google.com
-sorinbasca@google.com
-narayan@google.com
-ngeoffray@google.com
+include OWNERS_net
diff --git a/api/current.txt b/api/current.txt
index 44f27dbd01b..6d9004c49a2 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -13176,7 +13176,7 @@ package java.util {
     method public void trimToSize();
   }
 
-  public class Arrays {
+  public final class Arrays {
     method @NonNull @java.lang.SafeVarargs public static <T> java.util.List<T> asList(@NonNull T...);
     method public static int binarySearch(@NonNull long[], long);
     method public static int binarySearch(@NonNull long[], int, int, long);
@@ -14053,6 +14053,8 @@ package java.util {
     method public Object clone();
     method public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
     method public void forEach(java.util.function.BiConsumer<? super K,? super V>);
+    method @FlaggedApi("com.android.libcore.openjdk_21_v1_apis") public boolean remove(Object, Object);
+    method @FlaggedApi("com.android.libcore.openjdk_21_v1_apis") public boolean replace(K, V, V);
     method public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>);
   }
 
@@ -15298,6 +15300,7 @@ package java.util {
     ctor public WeakHashMap(@NonNull java.util.Map<? extends K,? extends V>);
     method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
     method public void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
+    method @FlaggedApi("com.android.libcore.openjdk_21_v1_apis") @NonNull public static <K, V> java.util.WeakHashMap<K,V> newWeakHashMap(int);
     method public void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
   }
 
diff --git a/api/module-lib-current.txt b/api/module-lib-current.txt
index 0da80c671e5..05beda4ab21 100644
--- a/api/module-lib-current.txt
+++ b/api/module-lib-current.txt
@@ -271,6 +271,7 @@ package dalvik.system {
     method public static void dumpHprofData(String) throws java.io.IOException;
     method public static void dumpHprofData(String, java.io.FileDescriptor) throws java.io.IOException;
     method public static void dumpHprofDataDdms();
+    method @FlaggedApi("com.android.art.flags.always_enable_profile_code") public static void dumpLowOverheadTrace(@NonNull dalvik.system.VMDebug.TraceDestination);
     method public static void dumpReferenceTables();
     method public static int getAllocCount(int);
     method public static int getLoadedClassCount();
@@ -289,10 +290,12 @@ package dalvik.system {
     method @FlaggedApi("com.android.libcore.appinfo") public static void setUserId(int);
     method @FlaggedApi("com.android.libcore.appinfo") public static void setWaitingForDebugger(boolean);
     method public static void startAllocCounting();
+    method @FlaggedApi("com.android.art.flags.always_enable_profile_code") public static void startLowOverheadTrace();
     method public static void startMethodTracing(String, int, int, boolean, int);
     method public static void startMethodTracing(String, java.io.FileDescriptor, int, int, boolean, int, boolean);
     method public static void startMethodTracingDdms(int, int, boolean, int);
     method public static void stopAllocCounting();
+    method @FlaggedApi("com.android.art.flags.always_enable_profile_code") public static void stopLowOverheadTrace();
     method public static void stopMethodTracing();
     method public static void suspendAllAndSendVmStart();
     method public static long threadCpuTimeNanos();
@@ -310,7 +313,13 @@ package dalvik.system {
     field public static final int TRACE_COUNT_ALLOCS = 1; // 0x1
   }
 
+  @FlaggedApi("com.android.art.flags.always_enable_profile_code") public static class VMDebug.TraceDestination {
+    method @FlaggedApi("com.android.art.flags.always_enable_profile_code") @NonNull public static dalvik.system.VMDebug.TraceDestination fromFileDescriptor(@NonNull java.io.FileDescriptor);
+    method @FlaggedApi("com.android.art.flags.always_enable_profile_code") @NonNull public static dalvik.system.VMDebug.TraceDestination fromFileName(@NonNull String);
+  }
+
   public final class VMRuntime {
+    method @FlaggedApi("com.android.libcore.post_cleanup_apis") public static void addPostCleanupCallback(@NonNull Runnable);
     method public long addressOf(Object);
     method public static void bootCompleted();
     method public void clampGrowthLimit();
@@ -335,6 +344,7 @@ package dalvik.system {
     method public void registerNativeFree(long);
     method @Deprecated public void registerNativeFree(int);
     method public static void registerSensitiveThread();
+    method @FlaggedApi("com.android.libcore.post_cleanup_apis") public static void removePostCleanupCallback(@NonNull Runnable);
     method public void requestConcurrentGC();
     method public static void resetJitCounters();
     method public static void setDedupeHiddenApiWarnings(boolean);
@@ -764,12 +774,24 @@ package libcore.util {
   public class NativeAllocationRegistry {
     ctor public NativeAllocationRegistry(@NonNull ClassLoader, long, long);
     method public static void applyFreeFunction(long, long);
-    method public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long, long);
-    method public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long);
-    method public static libcore.util.NativeAllocationRegistry createNonmalloced(@NonNull ClassLoader, long, long);
+    method @NonNull public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long, long);
+    method @NonNull public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long);
+    method @FlaggedApi("com.android.libcore.native_metrics") @NonNull public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull Class, long, long);
+    method @FlaggedApi("com.android.libcore.native_metrics") @NonNull public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull Class, long);
+    method @NonNull public static libcore.util.NativeAllocationRegistry createNonmalloced(@NonNull ClassLoader, long, long);
+    method @FlaggedApi("com.android.libcore.native_metrics") @NonNull public static libcore.util.NativeAllocationRegistry createNonmalloced(@NonNull Class, long, long);
+    method @FlaggedApi("com.android.libcore.native_metrics") @NonNull public static java.util.Collection<libcore.util.NativeAllocationRegistry.Metrics> getMetrics();
     method @NonNull public Runnable registerNativeAllocation(@NonNull Object, long);
   }
 
+  @FlaggedApi("com.android.libcore.native_metrics") public static final class NativeAllocationRegistry.Metrics {
+    method @NonNull public String getClassName();
+    method public long getMallocedBytes();
+    method public long getMallocedCount();
+    method public long getNonmallocedBytes();
+    method public long getNonmallocedCount();
+  }
+
   public class SneakyThrow {
     method public static void sneakyThrow(@NonNull Throwable);
   }
diff --git a/benchmarks/Android.bp b/benchmarks/Android.bp
index 196fdd846ee..ad8aaa5470a 100644
--- a/benchmarks/Android.bp
+++ b/benchmarks/Android.bp
@@ -31,7 +31,7 @@ java_test {
     system_modules: "core-all-system-modules",
     libs: [
         "caliper-api-target",
-        "android.test.base",
+        "android.test.base.stubs",
     ],
     errorprone: {
         javacflags: [
diff --git a/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java b/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java
index e1bd60d9e97..96414e2b7e0 100644
--- a/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java
+++ b/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java
@@ -39,10 +39,11 @@ import java.lang.annotation.Target;
  * suspend the thread for essential work and may become blocked. Use with caution. Do not use
  * this annotation for long-running methods, including usually-fast, but generally unbounded,
  * methods. In particular, the code should not perform significant I/O operations or acquire
- * native locks that can be held for a long time. (Some logging or native allocations, which
- * internally acquire native locks for a short time, are generally OK. However, as the cost
- * of several such operations adds up, the {@literal @}{@code CriticalNative} performance gain
- * can become insignificant and overshadowed by potential GC delays.)
+ * native locks that can be held for a long time. Never acquire a native lock that can also be held
+ * while a thread invokes Java code. That virtually guarantees deadlocks. (Otherwise some logging or
+ * native allocations, which internally acquire native locks for a short time, are generally OK.
+ * However, as the cost of several such operations adds up, the {@literal @}{@code CriticalNative}
+ * performance gain can become insignificant and overshadowed by potential GC delays.)
  * </p>
  *
  * <p>
diff --git a/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java b/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java
index 6b178f3fddc..8de052b48b2 100644
--- a/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java
+++ b/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java
@@ -29,15 +29,16 @@ import java.lang.annotation.Target;
  * that access the managed heap or call managed code also have faster internal transitions.
  *
  * <p>
- * While executing a {@literal @}{@code FastNative} method, the garbage collection cannot
- * suspend the thread for essential work and may become blocked. Use with caution. Do not use
- * this annotation for long-running methods, including usually-fast, but generally unbounded,
- * methods. In particular, the code should not perform significant I/O operations or acquire
- * native locks that can be held for a long time. (Some logging or native allocations, which
- * internally acquire native locks for a short time, are generally OK. However, as the cost
- * of several such operations adds up, the {@literal @}{@code FastNative} performance gain
- * can become insignificant and overshadowed by potential GC delays.)
- * Acquiring managed locks is OK as it internally allows thread suspension.
+ * While executing a {@literal @}{@code FastNative} method, the garbage collection cannot suspend
+ * the thread for essential work and may become blocked. Use with caution. Do not use this
+ * annotation for long-running methods, including usually-fast, but generally unbounded, methods.
+ * In particular, the code should not perform significant I/O operations or acquire native locks
+ * that can be held for a long time. Never acquire a native lock that can also be held while a
+ * thread invokes Java code. That virtually guarantees deadlocks. (Otherwise some logging or
+ * native allocations, which internally acquire native locks for a short time, are generally OK.
+ * However, as the cost of several such operations adds up, the {@literal @}{@code FastNative}
+ * performance gain can become insignificant and overshadowed by potential GC delays.) Acquiring
+ * managed locks is OK as it internally allows thread suspension.
  * </p>
  *
  * <p>
diff --git a/dalvik/src/main/java/dalvik/system/TEST_MAPPING b/dalvik/src/main/java/dalvik/system/TEST_MAPPING
index 5f4d46ceb26..b87c38ea8e1 100644
--- a/dalvik/src/main/java/dalvik/system/TEST_MAPPING
+++ b/dalvik/src/main/java/dalvik/system/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.dalvik.system"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_dalvik_system"
     }
   ]
 }
\ No newline at end of file
diff --git a/dalvik/src/main/java/dalvik/system/VMDebug.java b/dalvik/src/main/java/dalvik/system/VMDebug.java
index 9f0b23de675..83cf35b05d7 100644
--- a/dalvik/src/main/java/dalvik/system/VMDebug.java
+++ b/dalvik/src/main/java/dalvik/system/VMDebug.java
@@ -729,4 +729,95 @@ public final class VMDebug {
      */
     @SystemApi(client = MODULE_LIBRARIES)
     public static native void setWaitingForDebugger(boolean waiting);
+
+
+    /**
+     * A class to encapsulate different modes of trace output. Currently traceFileName and file
+     * descriptor are supported.
+     *
+     * @hide
+     */
+   @SystemApi(client = MODULE_LIBRARIES)
+    public static class TraceDestination {
+        private final String traceFileName;
+        private final FileDescriptor fd;
+
+        private TraceDestination(String traceFileName, FileDescriptor fd) {
+            this.traceFileName = traceFileName;
+            this.fd = fd;
+        }
+
+        /** @hide */
+        public int getFd() {
+            return fd.getInt$();
+        }
+
+        /** @hide */
+        public String getFileName() {
+            return traceFileName;
+        }
+
+        /**
+         * Returns a TraceDestination that uses a fileName. Use this to provide a fileName to dump
+         * the generated trace.
+         *
+         * @hide
+         */
+        @SystemApi(client = MODULE_LIBRARIES)
+        public static @NonNull TraceDestination fromFileName(@NonNull String traceFileName) {
+            return new TraceDestination(traceFileName,  null);
+        }
+
+        /**
+         * Returns a TraceDestination that uses a file descriptor. Use this to provide a file
+         * descriptor to dump the generated trace.
+         *
+         * @hide
+         */
+        @SystemApi(client = MODULE_LIBRARIES)
+        public static @NonNull TraceDestination fromFileDescriptor(@NonNull FileDescriptor fd) {
+            return new TraceDestination(null, fd);
+        }
+    }
+
+    /**
+     * Start an ART trace of executed dex methods. This uses a circular buffer to store entries
+     * so it will only hold the most recently executed ones. The tracing is not precise.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    public static void startLowOverheadTrace() {
+        startLowOverheadTraceImpl();
+    }
+
+    /**
+     * Stop an ongoing ART trace of executed dex methods.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    public static void stopLowOverheadTrace() {
+        stopLowOverheadTraceImpl();
+    }
+
+    /**
+     * Dump the collected trace into the trace file provided.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    public static void dumpLowOverheadTrace(@NonNull TraceDestination traceOutput) {
+        if (traceOutput.getFd() == -1) {
+            dumpLowOverheadTraceImpl(traceOutput.getFileName());
+        } else {
+            dumpLowOverheadTraceFdImpl(traceOutput.getFd());
+        }
+    }
+
+    private static native void startLowOverheadTraceImpl();
+    private static native void stopLowOverheadTraceImpl();
+    private static native void dumpLowOverheadTraceImpl(String traceFileName);
+    private static native void dumpLowOverheadTraceFdImpl(int fd);
+
 }
diff --git a/dalvik/src/test/java/libcore/dalvik/system/CloseGuardTest.java b/dalvik/src/test/java/libcore/dalvik/system/CloseGuardTest.java
index 92c29460cc0..964a9fab83a 100644
--- a/dalvik/src/test/java/libcore/dalvik/system/CloseGuardTest.java
+++ b/dalvik/src/test/java/libcore/dalvik/system/CloseGuardTest.java
@@ -208,4 +208,18 @@ public class CloseGuardTest {
             super.finalize();
         }
     }
+
+    private static class TestReporter implements CloseGuard.Reporter {
+
+        @Override
+        public void report(String message, Throwable allocationSite) {}
+    }
+
+    @Test
+    public void testReporterReport() {
+        TestReporter reporter = new TestReporter();
+        reporter.report("message");
+        reporter.report("message", new RuntimeException());
+    }
+
 }
diff --git a/harmony-tests/src/test/java/org/apache/harmony/tests/java/lang/reflect/FieldTest.java b/harmony-tests/src/test/java/org/apache/harmony/tests/java/lang/reflect/FieldTest.java
index da4637d820d..ca105699585 100644
--- a/harmony-tests/src/test/java/org/apache/harmony/tests/java/lang/reflect/FieldTest.java
+++ b/harmony-tests/src/test/java/org/apache/harmony/tests/java/lang/reflect/FieldTest.java
@@ -47,7 +47,14 @@ public class FieldTest extends junit.framework.TestCase {
         @AnnotationClass0
         @AnnotationSource0
         public int annotatedField;
-        class Inner{}
+        class Inner {
+            // BEGIN android-note
+            // When targeting Java 21 javac does not create the synthetic field that refers to
+            // TestClass since it doesn't need it. Force the creation of the synthetic field by
+            // using TestClass.annotatedField.
+            // END android-note
+            void inc() { annotatedField++; }
+        }
     }
 
 
diff --git a/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/ArraysTest.java b/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/ArraysTest.java
index d1089bec9d2..3aa4b513e5f 100644
--- a/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/ArraysTest.java
+++ b/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/ArraysTest.java
@@ -3274,8 +3274,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((byte[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3311,8 +3311,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((short[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3348,8 +3348,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((int[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3385,8 +3385,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((boolean[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3422,8 +3422,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((char[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3459,8 +3459,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((float[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3496,8 +3496,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((double[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3533,8 +3533,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOf((long[]) null, -1);
-            fail("should throw NegativeArraySizeException");
-        } catch (NegativeArraySizeException e) {
+            fail("should throw NegativeArraySizeException or NPE");
+        } catch (NegativeArraySizeException | NullPointerException e) {
             // expected
         }
     }
@@ -3685,8 +3685,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((byte[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -3738,8 +3738,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((short[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -3791,8 +3791,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((int[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -3844,8 +3844,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((long[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -3897,8 +3897,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((char[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -3947,8 +3947,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((float[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -4000,8 +4000,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((double[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
@@ -4053,8 +4053,8 @@ public class ArraysTest extends junit.framework.TestCase {
         }
         try {
             Arrays.copyOfRange((boolean[]) null, 0, -1);
-            fail("should throw IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
+            fail("should throw IllegalArgumentException or NPE");
+        } catch (IllegalArgumentException | NullPointerException e) {
             // expected
         }
         try {
diff --git a/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/TimerTest.java b/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/TimerTest.java
index ce0ff300fa4..99661260412 100644
--- a/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/TimerTest.java
+++ b/harmony-tests/src/test/java/org/apache/harmony/tests/java/util/TimerTest.java
@@ -17,10 +17,16 @@
 
 package org.apache.harmony.tests.java.util;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.lang.Thread.UncaughtExceptionHandler;
 import java.util.Date;
 import java.util.Timer;
 import java.util.TimerTask;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -28,7 +34,28 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import junit.framework.TestCase;
 
-public class TimerTest extends TestCase {
+import libcore.junit.util.compat.CoreCompatChangeRule;
+import libcore.junit.util.compat.CoreCompatChangeRule.DisableCompatChanges;
+import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// Android-changed: b/351566728 upgraded to JUnit4.
+// Added @RunWith class annotation, @Before and @After annotations, and @Test
+// annotations.
+// Changed assert* imports.
+@RunWith(JUnit4.class)
+public class TimerTest {
+
+    // Android-changed: b/351566728 need this to support added test cases.
+    @Rule
+    public final TestRule compatChangeRule = new CoreCompatChangeRule();
 
     int timerCounter = 0;
 
@@ -108,6 +135,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#Timer(boolean)
      */
+    @Test
     public void test_ConstructorZ() throws Exception {
         Timer t = null;
         try {
@@ -127,6 +155,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#Timer()
      */
+    @Test
     public void test_Constructor() throws Exception {
         Timer t = null;
         try {
@@ -146,6 +175,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#Timer(String, boolean)
      */
+    @Test
     public void test_ConstructorSZ() throws Exception {
         Timer t = null;
         try {
@@ -176,6 +206,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#Timer(String)
      */
+    @Test
     public void test_ConstructorS() throws Exception {
         Timer t = null;
         try {
@@ -200,6 +231,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#cancel()
      */
+    @Test
     public void test_cancel() throws Exception {
         Timer t = null;
         try {
@@ -272,6 +304,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#purge()
      */
+    @Test
     public void test_purge() throws Exception {
         Timer t = null;
         try {
@@ -306,6 +339,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#schedule(java.util.TimerTask, java.util.Date)
      */
+    @Test
     public void test_scheduleLjava_util_TimerTaskLjava_util_Date() throws Exception {
         Timer t = null;
         try {
@@ -414,6 +448,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#schedule(java.util.TimerTask, long)
      */
+    @Test
     public void test_scheduleLjava_util_TimerTaskJ() throws Exception {
         Timer t = null;
         try {
@@ -502,6 +537,7 @@ public class TimerTest extends TestCase {
     /**
      * java.util.Timer#schedule(java.util.TimerTask, long, long)
      */
+    @Test
     public void test_scheduleLjava_util_TimerTaskJJ() throws Exception {
         Timer t = null;
         try {
@@ -615,6 +651,7 @@ public class TimerTest extends TestCase {
      * java.util.Timer#schedule(java.util.TimerTask, java.util.Date,
      *        long)
      */
+    @Test
     public void test_scheduleLjava_util_TimerTaskLjava_util_DateJ() throws Exception {
         Timer t = null;
         try {
@@ -738,6 +775,7 @@ public class TimerTest extends TestCase {
      * java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, long,
      *        long)
      */
+    @Test
     public void test_scheduleAtFixedRateLjava_util_TimerTaskJJ() throws Exception {
         Timer t = null;
         try {
@@ -830,10 +868,103 @@ public class TimerTest extends TestCase {
         }
     }
 
+    // Android-changed: b/351566728 added this test case to test new behavior.
+    @DisableCompatChanges({Timer.SKIP_MULTIPLE_MISSED_PERIODIC_TASKS})
+    @Test
+    public void test_scheduleAtFixedRateLjava_util_TimerTaskJJ_SkipMultipleMissedFixedRateTasks_oldBehavior() throws Exception {
+        assertFalse(Timer.skipMultipleMissedPeriodicTasks());
+        Timer t = null;
+        final ConcurrentLinkedQueue<Long> executionTimes =
+                new ConcurrentLinkedQueue<>();
+        try {
+            final CountDownLatch latch = new CountDownLatch(10);
+
+            class SlowThenFastTask extends TimerTask {
+                boolean firstRun = true;
+
+                public void run() {
+                    if (firstRun) {
+                        firstRun = false;
+                        try {
+                            // Sleep through four periods
+                            Thread.sleep(400);
+                        } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                        }
+                    }
+                    executionTimes.add(System.currentTimeMillis());
+                    latch.countDown();
+                }
+            }
+
+            t = new Timer();
+            SlowThenFastTask slowThenFastTask = new SlowThenFastTask();
+
+            t.scheduleAtFixedRate(slowThenFastTask, 100, 100);
+            assertTrue("Fixed rate tasks didn't run 10 times within 10 periods;"
+                + " times: " + executionTimes,
+                latch.await(1_100, TimeUnit.MILLISECONDS));
+            t.cancel();
+        } finally {
+            if (t != null) {
+                t.cancel();
+            }
+        }
+    }
+
+    // Android-changed: b/351566728 added this test case to test new behavior.
+    @EnableCompatChanges({Timer.SKIP_MULTIPLE_MISSED_PERIODIC_TASKS})
+    @Test
+    public void test_scheduleAtFixedRateLjava_util_TimerTaskJJ_SkipMultipleMissedFixedRateTasks_newBehavior() throws Exception {
+        assertTrue(Timer.skipMultipleMissedPeriodicTasks());
+        Timer t = null;
+        final ConcurrentLinkedQueue<Long> executionTimes =
+                new ConcurrentLinkedQueue<>();
+        try {
+            final CountDownLatch latch = new CountDownLatch(6);
+
+            class SlowThenFastTask extends TimerTask {
+                boolean firstRun = true;
+
+                public void run() {
+                    if (firstRun) {
+                        firstRun = false;
+                        try {
+                            // Sleep through four periods
+                            Thread.sleep(400);
+                        } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                        }
+                    }
+                    executionTimes.add(System.currentTimeMillis());
+                    latch.countDown();
+                }
+            }
+
+            t = new Timer();
+            SlowThenFastTask slowThenFastTask = new SlowThenFastTask();
+
+            long startedAt = System.currentTimeMillis();
+            t.scheduleAtFixedRate(slowThenFastTask, 100, 100);
+            latch.await(1_000, TimeUnit.MILLISECONDS);
+            long finishedAt = System.currentTimeMillis();
+            assertTrue("Fixed rate schedule ran too fast, took only: "
+                    + (finishedAt - startedAt) + " ms;"
+                    + " times: " + executionTimes,
+                    finishedAt - startedAt > 700);
+            t.cancel();
+        } finally {
+            if (t != null) {
+                t.cancel();
+            }
+        }
+    }
+
     /**
      * java.util.Timer#scheduleAtFixedRate(java.util.TimerTask,
      *        java.util.Date, long)
      */
+    @Test
     public void test_scheduleAtFixedRateLjava_util_TimerTaskLjava_util_DateJ() throws Exception {
         Timer t = null;
         try {
@@ -964,6 +1095,7 @@ public class TimerTest extends TestCase {
      * let those exceptions bubble up, where they will both notify the thread's
      * uncaught exception handler and terminate the timer's thread.
      */
+    @Test
     public void testThrowingTaskKillsTimerThread() throws Exception {
         final AtomicReference<Thread> threadRef = new AtomicReference<Thread>();
         new Timer().schedule(new TimerTask() {
@@ -1019,6 +1151,7 @@ public class TimerTest extends TestCase {
         }
     };
 
+    @Test
     public void testOverdueTaskExecutesImmediately() throws Exception {
         Timer t = new Timer();
         Date date = new Date(System.currentTimeMillis());
@@ -1033,6 +1166,7 @@ public class TimerTest extends TestCase {
         assertTrue(actuallyExecutedOnTime.get());
     }
 
+    @Test
     public void testCanBeCancelledEvenIfTaskKeepsItPermanentlyBusy() throws Exception {
         final int timeSleeping = 200;
         Timer t = new Timer();
@@ -1071,6 +1205,7 @@ public class TimerTest extends TestCase {
         }
     }
 
+    @Test
     public void testTaskNotCancelledWhenTimerCancelled() throws Exception {
         final int timeSleeping = 200;
         Timer t = new Timer();
@@ -1093,6 +1228,7 @@ public class TimerTest extends TestCase {
         assertTrue(task.cancel());
     }
 
+    @Test
     public void testTaskNotCancelledWhenTimerCancelledAndPurged() throws Exception {
         final int timeSleeping = 200;
         Timer t = new Timer();
@@ -1153,6 +1289,7 @@ public class TimerTest extends TestCase {
         }
     }
 
+    @Test
     public void testTimerCancelledAfterException() throws Exception {
         UncaughtExceptionHandler excHandler = Thread.getDefaultUncaughtExceptionHandler();
         // Install an uncaught exception handler because we are
@@ -1210,6 +1347,7 @@ public class TimerTest extends TestCase {
         }
     }
 
+    @Test
     public void testTimerCancelledAfterExceptionAndTasksNotCancelledAfterPurge() throws Exception {
         UncaughtExceptionHandler excHandler = Thread.getDefaultUncaughtExceptionHandler();
         // Install an uncaught exception handler because we are
@@ -1267,6 +1405,7 @@ public class TimerTest extends TestCase {
         }
     }
 
+    @Test
     public void testTimerCancelledTasksRemovedFromQueue() throws Exception {
         Timer t = new Timer();
         TimerTask task1 = new TimerTask() {
@@ -1282,10 +1421,12 @@ public class TimerTest extends TestCase {
         assertEquals(0, t.purge());
     }
 
-    protected void setUp() {
+    @Before
+    public void setUp() {
         timerCounter = 0;
     }
 
-    protected void tearDown() {
+    @After
+    public void tearDown() {
     }
 }
diff --git a/json/src/main/java/org/json/TEST_MAPPING b/json/src/main/java/org/json/TEST_MAPPING
index 22c9a265ed7..0e947b89460 100644
--- a/json/src/main/java/org/json/TEST_MAPPING
+++ b/json/src/main/java/org/json/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.org.json"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_json"
     }
   ]
 }
\ No newline at end of file
diff --git a/libart/src/main/java/dalvik/system/VMRuntime.java b/libart/src/main/java/dalvik/system/VMRuntime.java
index 343b8283ad1..f03cb819abb 100644
--- a/libart/src/main/java/dalvik/system/VMRuntime.java
+++ b/libart/src/main/java/dalvik/system/VMRuntime.java
@@ -19,20 +19,27 @@ package dalvik.system;
 import static android.annotation.SystemApi.Client.MODULE_LIBRARIES;
 
 import android.annotation.SystemApi;
+import android.annotation.FlaggedApi;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.Disabled;
 import android.compat.annotation.UnsupportedAppUsage;
 
+import com.android.libcore.Flags;
+
 import dalvik.annotation.compat.VersionCodes;
 import dalvik.annotation.optimization.FastNative;
 
 import java.lang.ref.FinalizerReference;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
+import libcore.util.NonNull;
+
 /**
  * Provides an interface to VM-global, Dalvik-specific features.
  * An application cannot create its own Runtime instance, and must obtain
@@ -216,6 +223,8 @@ public final class VMRuntime {
 
     private long[] disabledCompatChanges = new long[0];
 
+    private static final List<Runnable> postCleanupCallbacks = new ArrayList<>();
+
     /**
      * Prevents this class from being instantiated.
      */
@@ -1009,6 +1018,44 @@ public final class VMRuntime {
         nonSdkApiUsageConsumer = consumer;
     }
 
+    /**
+     * Adds a callback that the runtime will call post-cleanup, i.e. when all the references
+     * marked by previous GC are cleaned up, and so ReferenceQueue is empty.
+     *
+     * @hide
+     */
+    @FlaggedApi(com.android.libcore.Flags.FLAG_POST_CLEANUP_APIS)
+    @SystemApi(client = MODULE_LIBRARIES)
+    public static void addPostCleanupCallback(@NonNull Runnable runnable) {
+        synchronized(postCleanupCallbacks) {
+            postCleanupCallbacks.add(runnable);
+        }
+    }
+
+    /**
+     * Removes a callback that the runtime will call post-cleanup
+     *
+     * @hide
+     */
+    @FlaggedApi(com.android.libcore.Flags.FLAG_POST_CLEANUP_APIS)
+    @SystemApi(client = MODULE_LIBRARIES)
+    public static void removePostCleanupCallback(@NonNull Runnable runnable) {
+        synchronized(postCleanupCallbacks) {
+            postCleanupCallbacks.remove(runnable);
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public static void onPostCleanup() {
+        synchronized(postCleanupCallbacks) {
+            for (Runnable runnable : postCleanupCallbacks) {
+                runnable.run();
+            }
+        }
+    }
+
     /**
      * Sets whether or not the runtime should dedupe detection and warnings for hidden API usage.
      *
@@ -1062,4 +1109,24 @@ public final class VMRuntime {
      * @hide
      */
     public static native DexFile.OptimizationInfo getBaseApkOptimizationInfo();
+
+    /**
+     * @hide for internal testing.
+     */
+    public static boolean isVTrunkStableFlagEnabled() {
+        return Flags.vApis();
+    }
+
+    /**
+     * @hide for internal testing.
+     */
+    public static boolean isArtTestFlagEnabled() {
+        return com.android.art.flags.Flags.test();
+    }
+
+    /**
+     * Returns the full GC count - how many times did full GC happen
+     * @hide
+     */
+    public static native long getFullGcCount();
 }
diff --git a/libart/src/main/java/java/lang/Daemons.java b/libart/src/main/java/java/lang/Daemons.java
index 36c1c746194..aa50185cb48 100644
--- a/libart/src/main/java/java/lang/Daemons.java
+++ b/libart/src/main/java/java/lang/Daemons.java
@@ -231,17 +231,30 @@ public final class Daemons {
             super("ReferenceQueueDaemon");
         }
 
+        private long lastGcCount = 0;
+
+        private void onRefQueueEmptyAfterGc() {
+            long gcCount = VMRuntime.getFullGcCount();
+            if (gcCount > lastGcCount) {
+                VMRuntime.onPostCleanup();
+                lastGcCount = gcCount;
+            }
+        }
+
         @Override public void runInternal() {
             FinalizerWatchdogDaemon.INSTANCE.monitoringNeeded(FinalizerWatchdogDaemon.RQ_DAEMON);
 
             // Call once early to reduce later allocation, and hence chance of OOMEs.
             FinalizerWatchdogDaemon.INSTANCE.resetTimeouts();
 
+            lastGcCount = VMRuntime.getFullGcCount();
+
             while (isRunning()) {
                 Reference<?> list;
                 try {
                     synchronized (ReferenceQueue.class) {
                         if (ReferenceQueue.unenqueued == null) {
+                            onRefQueueEmptyAfterGc();
                             FinalizerWatchdogDaemon.INSTANCE.monitoringNotNeeded(
                                     FinalizerWatchdogDaemon.RQ_DAEMON);
                             // Increment after above call. If watchdog saw it active, it should see
diff --git a/libart/src/main/java/java/lang/StringFactory.java b/libart/src/main/java/java/lang/StringFactory.java
index 364632cd3a4..9ffd3952e53 100644
--- a/libart/src/main/java/java/lang/StringFactory.java
+++ b/libart/src/main/java/java/lang/StringFactory.java
@@ -45,7 +45,7 @@ public final class StringFactory {
     }
 
     public static String newStringFromBytes(byte[] data, byte coder) {
-        if (coder == String.LATIN1) {
+        if (coder == String.CODER_LATIN1) {
             return newStringFromBytes(data, /*high=*/ 0);
         } else {
             return newStringFromUtf16Bytes(data, 0, data.length >>> 1);
diff --git a/libart/src/main/java/java/lang/TEST_MAPPING b/libart/src/main/java/java/lang/TEST_MAPPING
index 33332b257ab..b520abbbd10 100644
--- a/libart/src/main/java/java/lang/TEST_MAPPING
+++ b/libart/src/main/java/java/lang/TEST_MAPPING
@@ -1,26 +1,10 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "tests.java.lang"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.lang"
-        },
-        {
-          "include-filter": "libcore.java.lang"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_lang"
     },
     {
-      "name": "CtsLibcoreOjTestCases",
-      "options": [
-        {
-          "include-filter": "test.java.lang"
-        }
-      ]
+      "name": "CtsLibcoreOjTestCases_java_lang"
     }
   ]
 }
\ No newline at end of file
diff --git a/libart/src/main/java/java/lang/invoke/TEST_MAPPING b/libart/src/main/java/java/lang/invoke/TEST_MAPPING
index a5e285bbd11..2ad2aa04be4 100644
--- a/libart/src/main/java/java/lang/invoke/TEST_MAPPING
+++ b/libart/src/main/java/java/lang/invoke/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.lang.invoke"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases",
       "options": [
diff --git a/libcore.aconfig b/libcore.aconfig
index 92ee03ed594..cba267ab150 100644
--- a/libcore.aconfig
+++ b/libcore.aconfig
@@ -38,6 +38,17 @@ flag {
     is_fixed_read_only: true
 }
 
+flag {
+    namespace: "core_libraries"
+    name: "openjdk_21_v1_apis"
+    is_exported: true
+    description: "This flag includes OpenJDK 21 APIs released in 2025."
+    bug: "340486785"
+    # APIs provided by a mainline module can only use a frozen flag.
+    is_fixed_read_only: true
+}
+
+
 flag {
     namespace: "devtools"
     name: "appinfo"
@@ -47,3 +58,23 @@ flag {
     # APIs provided by a mainline module can only use a frozen flag.
     is_fixed_read_only: true
 }
+
+flag {
+    namespace: "core_libraries"
+    name: "post_cleanup_apis"
+    is_exported: true
+    description: "This flag includes APIs to add/remove/call callbacks post-cleanup"
+    bug: "331243037"
+    # APIs provided by a mainline module can only use a frozen flag.
+    is_fixed_read_only: true
+}
+
+flag {
+    namespace: "core_libraries"
+    name: "native_metrics"
+    is_exported: true
+    description: "This flag includes APIs fo maintaining and exposing native allocation metrics"
+    bug: "331243037"
+    # APIs provided by a mainline module can only use a frozen flag.
+    is_fixed_read_only: true
+}
diff --git a/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java b/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
index a8095639942..483b005e922 100644
--- a/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
+++ b/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
@@ -16,6 +16,7 @@
 
 
 package dalvik.system;
+import java.io.FileDescriptor;
 
 @SuppressWarnings({"unchecked", "deprecation", "all"})
 public final class VMDebug {
@@ -91,6 +92,25 @@ public static native void setUserId(int userId);
 @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_APPINFO)
 public static native void setWaitingForDebugger(boolean waiting);
 
+@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+public static class TraceDestination {
+
+  @android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+  public static @NonNull TraceDestination fromFileName(@NonNull String traceFileName);
+
+  @android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+  public static @NonNull TraceDestination fromFileDescriptor(@NonNull FileDescriptor fd);
+}
+
+@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+public static void startLowOverheadTrace();
+
+@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+public static void stopLowOverheadTrace();
+
+@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_ALWAYS_ENABLE_PROFILE_CODE)
+public static void dumpLowOverheadTrace(@NonNull VMDebug.TraceDestination traceFileName);
+
 public static final int KIND_ALL_COUNTS = -1; // 0xffffffff
 
 public static final int KIND_GLOBAL_ALLOCATED_BYTES = 2; // 0x2
diff --git a/luni/src/main/java/android/compat/TEST_MAPPING b/luni/src/main/java/android/compat/TEST_MAPPING
index c8b07b41a10..ace299aae89 100644
--- a/luni/src/main/java/android/compat/TEST_MAPPING
+++ b/luni/src/main/java/android/compat/TEST_MAPPING
@@ -2,12 +2,7 @@
   "presubmit": [
     // Unit tests for CoreCompatChangeRule
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.junit.util.compat"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_compat"
     },
     // CTS test for CompatChanges System
     {
diff --git a/luni/src/main/java/android/system/TEST_MAPPING b/luni/src/main/java/android/system/TEST_MAPPING
index 66e8d786dfd..c81bdc5bfc5 100644
--- a/luni/src/main/java/android/system/TEST_MAPPING
+++ b/luni/src/main/java/android/system/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.android.system"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_android_system"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/java/lang/ref/TEST_MAPPING b/luni/src/main/java/java/lang/ref/TEST_MAPPING
index 0614a12f8b6..48e2eda0a4f 100644
--- a/luni/src/main/java/java/lang/ref/TEST_MAPPING
+++ b/luni/src/main/java/java/lang/ref/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.lang.ref"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.lang.ref"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_lang_ref"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/java/net/TEST_MAPPING b/luni/src/main/java/java/net/TEST_MAPPING
index 3573294297c..1629a446ad3 100644
--- a/luni/src/main/java/java/net/TEST_MAPPING
+++ b/luni/src/main/java/java/net/TEST_MAPPING
@@ -1,29 +1,10 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.net"
-        },
-        {
-          "include-filter": "org.apache.harmony.luni.tests.internal.net.www.protocol.http"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.net"
-        },
-        {
-          "include-filter": "org.apache.harmony.luni.tests.java.net"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_java_net"
     },
     {
-      "name": "CtsLibcoreOjTestCases",
-      "options": [
-        {
-          "include-filter": "test.java.net"
-        }
-      ]
+      "name": "CtsLibcoreOjTestCases_java_net"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/java/nio/TEST_MAPPING b/luni/src/main/java/java/nio/TEST_MAPPING
index 3fe450ed9fe..01ed9e16cc9 100644
--- a/luni/src/main/java/java/nio/TEST_MAPPING
+++ b/luni/src/main/java/java/nio/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.java.nio"
-        },
-        {
-          "include-filter": "libcore.java.nio"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_nio"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/javax/xml/TEST_MAPPING b/luni/src/main/java/javax/xml/TEST_MAPPING
index d8c9759faeb..9a71ddfd656 100644
--- a/luni/src/main/java/javax/xml/TEST_MAPPING
+++ b/luni/src/main/java/javax/xml/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_xml"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/javax/xml/parsers/TEST_MAPPING b/luni/src/main/java/javax/xml/parsers/TEST_MAPPING
index a630fe1baf4..bd50dad5e88 100644
--- a/luni/src/main/java/javax/xml/parsers/TEST_MAPPING
+++ b/luni/src/main/java/javax/xml/parsers/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.xml.parsers"
-        },
-        {
-          "include-filter": "libcore.javax.xml.parsers"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_xml_parsers"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/content/type/TEST_MAPPING b/luni/src/main/java/libcore/content/type/TEST_MAPPING
index 712f4a287e2..bc882b1e08a 100644
--- a/luni/src/main/java/libcore/content/type/TEST_MAPPING
+++ b/luni/src/main/java/libcore/content/type/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.content.type"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_content_type"
     },
     {
       "name": "CtsMimeMapTestCases"
diff --git a/luni/src/main/java/libcore/icu/TEST_MAPPING b/luni/src/main/java/libcore/icu/TEST_MAPPING
index f3a0de87143..c2494f8ee11 100644
--- a/luni/src/main/java/libcore/icu/TEST_MAPPING
+++ b/luni/src/main/java/libcore/icu/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.icu"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_icu"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/internal/Java21LanguageFeatures.java b/luni/src/main/java/libcore/internal/Java21LanguageFeatures.java
new file mode 100644
index 00000000000..9f699313571
--- /dev/null
+++ b/luni/src/main/java/libcore/internal/Java21LanguageFeatures.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package libcore.internal;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * Proof of concept / fake code whose only purpose is to demonstrate that Java 21
+ * language features are supported in libcore.
+ */
+public class Java21LanguageFeatures {
+
+    public static int calculateApproximateArea(Shape s) {
+        // Language feature (Java 21): JEP-441 - Pattern Matching for switch
+        // Matching by type
+        return switch (s) {
+            case Triangle t -> (t.base * t.height / 2);
+            case Rectangle r -> (r.length * r.width);
+            case Circle c -> (c.radius * c.radius * 3);
+            default -> 0;
+        };
+    }
+
+    public static abstract class Shape {
+    }
+
+    public static class Triangle extends Shape {
+        public final int base;
+        public final int height;
+
+        public Triangle(int base, int height) {
+            this.base = base;
+            this.height = height;
+        }
+    }
+
+    public static class Rectangle extends Shape {
+        public final int length;
+        public final int width;
+
+        public Rectangle(int length, int width) {
+            this.length = length;
+            this.width = width;
+        }
+    }
+
+    public static class Circle extends Shape {
+        public final int radius;
+
+        public Circle(int radius) {
+            this.radius = radius;
+        }
+    }
+
+    public static String isDroid(String s) {
+        // Language feature (Java 21): JEP-441 - Pattern Matching for switch
+        // Matching with null check
+        return switch (s) {
+            case null -> "404";
+            case "Android", "Marvin" -> "Yes";
+            default -> "No";
+        };
+    }
+
+    public static String isDroidIgnoreCase(String s) {
+        // Language feature (Java 21): JEP-441 - Pattern Matching for switch
+        // Matching with case refinement
+        return switch (s) {
+            case null -> "404";
+            case String str when str.equalsIgnoreCase("android") -> "Yes";
+            case String str when str.equalsIgnoreCase("marvin") -> "Yes";
+            default -> "No";
+        };
+    }
+
+    public static boolean hasManySides(ShapeType t) {
+        // Language feature (Java 21): JEP-441 - Pattern Matching for switch
+        // Matching enum constants
+        return switch (t) {
+            case PointyShapeType.TRIANGLE -> false;
+            case PointyShapeType.RECTANGLE -> true;
+            case RoundedShapeType.CIRCLE -> false;
+        };
+    }
+
+    public sealed interface ShapeType permits PointyShapeType, RoundedShapeType {}
+    public enum PointyShapeType implements ShapeType { TRIANGLE, RECTANGLE }
+    public enum RoundedShapeType implements ShapeType { CIRCLE }
+
+    public static int getX(Object obj) {
+        // Language feature (Java 21): JEP-440 - Record Patterns
+        if (obj instanceof Point(int x, int y)) {
+            return x;
+        } else {
+            return 0;
+        }
+    }
+
+    public static int getY(Object obj) {
+        // Language feature (Java 21): JEP-440 - Record Patterns
+        // Pattern match with type inference for components
+        if (obj instanceof Point(var x, var y)) {
+            return y;
+        } else {
+            return 0;
+        }
+    }
+
+    public static boolean isLineVertical(Object obj) {
+        // Language feature (Java 21): JEP-440 - Record Patterns
+        // Nested record patterns
+        if (obj instanceof Line(Point(int xa, int ya),
+                                Point(int xb, int yb))) {
+            return xa == xb;
+        } else {
+            return false;
+        }
+    }
+
+    public record Point(int x, int y) { }
+
+    public record Line(Point a, Point b) { }
+
+    public static boolean isFirstItemLarger(Pair pair) {
+        // Language feature (Java 21): JEP-440 - Record Patterns
+        // Switch and record patterns
+        return switch (pair) {
+            case Pair(PairableInt(int xa), PairableInt(int xb)) -> xa > xb;
+            case Pair(PairableString a, Pairable b) -> false;
+            case Pair(PairableInt a, PairableString b) -> false;
+        };
+    }
+
+    public sealed interface Pairable permits PairableInt, PairableString { }
+
+    public record PairableInt(int x) implements Pairable { }
+
+    public record PairableString(String s) implements Pairable { }
+
+    public record Pair(Pairable a, Pairable b) { }
+
+    public static int sumOfMembers(AnyPair<Integer, Integer> pair) {
+        // Language feature (Java 21): JEP-440 - Record Patterns
+        // Pattern match with type inference type arguments
+        return switch (pair) {
+            case AnyPair(var a, var b) -> a.intValue() + b.intValue();
+        };
+    }
+
+    public record AnyPair<S, T>(S a, T b) { }
+
+
+    public sealed interface Blob permits SquishyBlob, ComplexBlob { }
+
+    public enum SquishyBlob implements Blob { SMALL, MEDIUM, LARGE }
+
+    public sealed interface ComplexBlob extends Blob permits MultiBlob, GeometricBlob { }
+
+    public enum Color { RED, GREEN, BLUE }
+
+    public record MultiBlob(ShapeType type, Color color, Integer count) implements ComplexBlob { }
+
+    public record GeometricBlob(int sides) implements ComplexBlob { }
+
+    public static Object getMainCharacteristic(Blob blob) {
+        return switch (blob) {
+            case SquishyBlob squishy -> squishy;
+            case MultiBlob (RoundedShapeType type, var color, var count)
+                when type == RoundedShapeType.CIRCLE -> RoundedShapeType.CIRCLE;
+            case MultiBlob (var type, Color color, var count)
+                when color == Color.RED -> Color.RED;
+            case MultiBlob (var type, var color, var count) -> count;
+            case GeometricBlob (int sides) when sides > 1000 -> Integer.valueOf(1000);
+            case GeometricBlob (int sides) -> Integer.valueOf(sides);
+        };
+    }
+}
diff --git a/luni/src/main/java/libcore/internal/TEST_MAPPING b/luni/src/main/java/libcore/internal/TEST_MAPPING
index 3ddd13a8da3..ba67e59a306 100644
--- a/luni/src/main/java/libcore/internal/TEST_MAPPING
+++ b/luni/src/main/java/libcore/internal/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.internal"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_internal"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/io/TEST_MAPPING b/luni/src/main/java/libcore/io/TEST_MAPPING
index 1e25459b5fc..6bb0ea311d2 100644
--- a/luni/src/main/java/libcore/io/TEST_MAPPING
+++ b/luni/src/main/java/libcore/io/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.io"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_libcore_io"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/net/TEST_MAPPING b/luni/src/main/java/libcore/net/TEST_MAPPING
index f31705e02e2..ece352360b8 100644
--- a/luni/src/main/java/libcore/net/TEST_MAPPING
+++ b/luni/src/main/java/libcore/net/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.net"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.net"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_libcore_net"
     }
   ]
 }
diff --git a/luni/src/main/java/libcore/net/event/TEST_MAPPING b/luni/src/main/java/libcore/net/event/TEST_MAPPING
deleted file mode 100644
index 866b3209229..00000000000
--- a/luni/src/main/java/libcore/net/event/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.net.event"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/reflect/TEST_MAPPING b/luni/src/main/java/libcore/reflect/TEST_MAPPING
index b57dc5557c8..f1db2eba043 100644
--- a/luni/src/main/java/libcore/reflect/TEST_MAPPING
+++ b/luni/src/main/java/libcore/reflect/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.reflect"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_reflect"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/libcore/util/NativeAllocationRegistry.java b/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
index d4e60992a73..a827a1e2cf7 100644
--- a/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
+++ b/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
@@ -19,11 +19,19 @@ package libcore.util;
 import static android.annotation.SystemApi.Client.MODULE_LIBRARIES;
 
 import android.annotation.SystemApi;
+import android.annotation.FlaggedApi;
 
 import dalvik.system.VMRuntime;
 import sun.misc.Cleaner;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
 import java.lang.ref.Reference;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.WeakHashMap;
 
 import libcore.util.NonNull;
 
@@ -44,12 +52,19 @@ import libcore.util.NonNull;
  * native function used to free the allocation and the estimated size of the
  * allocation. Once a NativeAllocationRegistry is instantiated, it can be
  * used to register any number of native allocations of that kind.
+ *
  * @hide
  */
 @SystemApi(client = MODULE_LIBRARIES)
 @libcore.api.IntraCoreApi
 public class NativeAllocationRegistry {
 
+    // Class associated with this NativeAllocationRegistry. If no class is explicitly
+    // specified, NativeAllocationRegistry.class will be used as default
+    private final Class clazz;
+
+    // ClassLoader for holding the freeFunction in place. If no ClassLoader is
+    // explicitly specified, it will be inferred from `clazz.getClassLoader()`.
     private final ClassLoader classLoader;
 
     // Pointer to native deallocation function of type void f(void* freeFunction).
@@ -68,13 +83,22 @@ public class NativeAllocationRegistry {
     // We use an even value close to 100 that is unlikely to be explicitly provided.
     private static final long DEFAULT_SIZE = 98;
 
+    private boolean isMalloced() {
+        return (size & IS_MALLOCED) == IS_MALLOCED;
+    }
+
+    // This is ONLY used to gather statistics.  A WeakHashMap is used here to track
+    // all registries created without holding strong references, therefore allow the
+    // unreferenced registries to be GC'ed.
+    private static final Map<NativeAllocationRegistry, Void> registries = new WeakHashMap<>();
+
     /**
      * Return a {@link NativeAllocationRegistry} for native memory that is mostly
      * allocated by means other than the system memory allocator. For example,
      * the memory may be allocated directly with mmap.
      * @param classLoader  ClassLoader that was used to load the native
      *                     library defining freeFunction.
-     *                     This ensures that the the native library isn't unloaded
+     *                     This ensures that the native library isn't unloaded
      *                     before {@code freeFunction} is called.
      * @param freeFunction address of a native function of type
      *                     {@code void f(void* nativePtr)} used to free this
@@ -90,9 +114,40 @@ public class NativeAllocationRegistry {
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
-    public static NativeAllocationRegistry createNonmalloced(
+    public static @NonNull NativeAllocationRegistry createNonmalloced(
             @NonNull ClassLoader classLoader, long freeFunction, long size) {
-        return new NativeAllocationRegistry(classLoader, freeFunction, size, false);
+        return new NativeAllocationRegistry(
+            classLoader, NativeAllocationRegistry.class, freeFunction, size, false);
+    }
+
+    /**
+     * Return a {@link NativeAllocationRegistry} for native memory that is mostly
+     * allocated by means other than the system memory allocator. This version requires
+     * a Class to be specified and its ClassLoader is implied.
+     * @param clazz        Class that is associated with the native memory allocation.
+     *                     This allows per-class metrics to be maintained.
+     *                     The ClassLoader will be obtained from this Class.
+     *                     This ensures that the native library isn't unloaded
+     *                     before {@code freeFunction} is called.
+     * @param freeFunction address of a native function of type
+     *                     {@code void f(void* nativePtr)} used to free this
+     *                     kind of native allocation
+     * @param size         estimated size in bytes of the part of the described
+     *                     native memory that is not allocated with system malloc.
+     *                     Used as input to the garbage collector triggering algorithm,
+     *                     and by heap analysis tools.
+     *                     Approximate values are acceptable.
+     * @return allocated {@link NativeAllocationRegistry}
+     * @throws IllegalArgumentException If {@code size} is negative
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @FlaggedApi(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public static @NonNull NativeAllocationRegistry createNonmalloced(
+            @NonNull Class clazz, long freeFunction, long size) {
+        return new NativeAllocationRegistry(
+            clazz.getClassLoader(), clazz, freeFunction, size, false);
     }
 
     /**
@@ -122,9 +177,10 @@ public class NativeAllocationRegistry {
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
-    public static NativeAllocationRegistry createMalloced(
+    public static @NonNull NativeAllocationRegistry createMalloced(
             @NonNull ClassLoader classLoader, long freeFunction, long size) {
-        return new NativeAllocationRegistry(classLoader, freeFunction, size, true);
+        return new NativeAllocationRegistry(
+            classLoader, NativeAllocationRegistry.class, freeFunction, size, true);
     }
 
     /**
@@ -144,9 +200,67 @@ public class NativeAllocationRegistry {
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.IntraCoreApi
-    public static NativeAllocationRegistry createMalloced(
+    public static @NonNull NativeAllocationRegistry createMalloced(
             @NonNull ClassLoader classLoader, long freeFunction) {
-        return new NativeAllocationRegistry(classLoader, freeFunction, DEFAULT_SIZE, true);
+        return new NativeAllocationRegistry(
+            classLoader, NativeAllocationRegistry.class, freeFunction, DEFAULT_SIZE, true);
+    }
+
+    /**
+     * Return a {@link NativeAllocationRegistry} for native memory that is mostly
+     * allocated by the system memory allocator.  This version requires a Class to
+     * be specified and its ClassLoader is implied.
+     * @param clazz        Class that is associated with the native memory allocation.
+     *                     This allows per-class metrics to be maintained.
+     *                     The ClassLoader will be obtained from this Class.
+     *                     This ensures that the native library isn't unloaded
+     *                     before {@code freeFunction} is called.
+     * @param freeFunction address of a native function of type
+     *                     {@code void f(void* nativePtr)} used to free this
+     *                     kind of native allocation
+     * @param size         estimated size in bytes of the part of the described
+     *                     native memory allocated with system malloc.
+     *                     Approximate values, including wild guesses, are acceptable.
+     *                     Unlike {@code createNonmalloced()}, this size is used
+     *                     only by heap analysis tools; garbage collector triggering
+     *                     instead looks directly at {@code mallinfo()} information.
+     * @return allocated {@link NativeAllocationRegistry}
+     * @throws IllegalArgumentException If {@code size} is negative
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @FlaggedApi(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public static @NonNull NativeAllocationRegistry createMalloced(
+            @NonNull Class clazz, long freeFunction, long size) {
+        return new NativeAllocationRegistry(
+            clazz.getClassLoader(), clazz, freeFunction, size, true);
+    }
+
+    /**
+     * Return a {@link NativeAllocationRegistry} for native memory that is mostly
+     * allocated by the system memory allocator.  This version uses a default size,
+     * thus providing less information than desired for heap analysis tools.
+     * It should only be used when the native allocation is expected to be small,
+     * but there is no reasonable way to provide a meaningful size estimate.
+     * @param clazz        Class that is associated with the native memory allocation.
+     *                     This allows per-class metrics to be maintained.
+     *                     The ClassLoader will be obtained from this Class.
+     *                     This ensures that the native library isn't unloaded
+     *                     before {@code freeFunction} is called.
+     * @param freeFunction address of a native function of type
+     *                     {@code void f(void* nativePtr)} used to free this
+     *                     kind of native allocation
+     * @return allocated {@link NativeAllocationRegistry}
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @FlaggedApi(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public static @NonNull NativeAllocationRegistry createMalloced(
+            @NonNull Class clazz, long freeFunction) {
+        return new NativeAllocationRegistry(
+            clazz.getClassLoader(), clazz, freeFunction, DEFAULT_SIZE, true);
     }
 
     /**
@@ -154,16 +268,15 @@ public class NativeAllocationRegistry {
      * allocation.
      * <p>
      * The <code>size</code> should be an estimate of the total number of
-     * native bytes this kind of native allocation takes up. Different
-     * NativeAllocationRegistrys must be used to register native allocations
-     * with different estimated sizes, even if they use the same
-     * <code>freeFunction</code>. This is used to help inform the garbage
-     * collector about the possible need for collection. Memory allocated with
-     * native malloc is implicitly included, and ideally should not be included in this
-     * argument.
+     * native bytes this kind of native allocation takes up.  This is used
+     * to help inform the garbage collector about the possible need for
+     * collection. Memory allocated with native malloc is implicitly
+     * included, and ideally should not be included in this argument.
      * <p>
      * @param classLoader  ClassLoader that was used to load the native
      *                     library freeFunction belongs to.
+     * @param clazz        Class that is associated with this registry. If no class is
+     *                     specified, it defaults to NativeAllocationRegistry.class.
      * @param freeFunction address of a native function used to free this
      *                     kind of native allocation
      * @param size         estimated size in bytes of this kind of native
@@ -177,14 +290,21 @@ public class NativeAllocationRegistry {
      *                     indicate an unknown non-huge size.
      * @param mallocAllocation the native object is primarily allocated via malloc.
      */
-    private NativeAllocationRegistry(ClassLoader classLoader, long freeFunction, long size,
-            boolean mallocAllocation) {
+    private NativeAllocationRegistry(@NonNull ClassLoader classLoader, @NonNull Class clazz,
+        long freeFunction, long size, boolean mallocAllocation) {
         if (size < 0) {
             throw new IllegalArgumentException("Invalid native allocation size: " + size);
         }
-        this.classLoader = classLoader;
+        this.clazz = Objects.requireNonNull(clazz);
+        this.classLoader = Objects.requireNonNull(classLoader);
         this.freeFunction = freeFunction;
         this.size = mallocAllocation ? (size | IS_MALLOCED) : (size & ~IS_MALLOCED);
+
+        if (KEEP_METRICS) {
+            synchronized(NativeAllocationRegistry.class) {
+                registries.put(this, null);
+            }
+        }
     }
 
     /**
@@ -196,13 +316,10 @@ public class NativeAllocationRegistry {
      * <p>
      * The {@code size} should be an estimate of the total number of
      * native bytes this kind of native allocation takes up excluding bytes allocated
-     * with system malloc. Different
-     * {@link NativeAllocationRegistry}s must be used to register native allocations
-     * with different estimated sizes, even if they use the same
-     * {@code freeFunction}. This is used to help inform the garbage
-     * collector about the possible need for collection. Memory allocated with
-     * native malloc is implicitly included, and ideally should not be included in this
-     * argument.
+     * with system malloc.
+     * This is used to help inform the garbage collector about the possible need for
+     * collection. Memory allocated with native malloc is implicitly included, and
+     * ideally should not be included in this argument.
      * <p>
      * @param classLoader  ClassLoader that was used to load the native
      *                     library {@code freeFunction} belongs to.
@@ -216,8 +333,128 @@ public class NativeAllocationRegistry {
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
-    public NativeAllocationRegistry(@NonNull ClassLoader classLoader, long freeFunction, long size) {
-        this(classLoader, freeFunction, size, size == 0);
+    public NativeAllocationRegistry(
+        @NonNull ClassLoader classLoader, long freeFunction, long size) {
+        this(classLoader, NativeAllocationRegistry.class, freeFunction, size, size == 0);
+    }
+
+    private static final boolean KEEP_METRICS = false;
+    private volatile int counter = 0;
+
+    private static final VarHandle COUNTER;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            COUNTER = l.findVarHandle(NativeAllocationRegistry.class,
+                "counter", int.class);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private void updateMetrics(long size) {
+        if (KEEP_METRICS) {
+            COUNTER.getAndAdd(this, size > 0 ? 1 : -1);
+        }
+    }
+
+    /**
+     * Per-class metrics of native allocations, which includes:
+     *   - class name
+     *   - number and memory used in bytes for native allocations that are
+     *     - registered but not yet released
+     *     - allocated from malloc (malloced) or not from malloc (nonmalloced)
+     *
+     * Metrics from different registries but of the same class will be aggregated.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @FlaggedApi(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public static final class Metrics {
+        private String className;
+        private long mallocedCount;
+        private long mallocedBytes;
+        private long nonmallocedCount;
+        private long nonmallocedBytes;
+
+        private Metrics(@NonNull String className) {
+            this.className = className;
+        }
+
+        private void add(NativeAllocationRegistry r) {
+            long count = r.counter;
+            long bytes = count * (r.size & ~IS_MALLOCED);
+            if (r.isMalloced()) {
+                mallocedCount += count;
+                mallocedBytes += bytes;
+            } else {
+                nonmallocedCount += count;
+                nonmallocedBytes += bytes;
+            }
+        }
+
+        /**
+         * Returns the name of the class this metrics is associated
+         */
+        public @NonNull String getClassName() {
+            return className;
+        }
+
+        /**
+         * Returns the number of malloced native allocations
+         */
+        public long getMallocedCount() {
+            return mallocedCount;
+        }
+
+        /**
+         * Returns the memory size in bytes of malloced native allocations
+         */
+        public long getMallocedBytes() {
+            return mallocedBytes;
+        }
+
+        /**
+         * Returns the accounted number of nonmalloced native allocations
+         */
+        public long getNonmallocedCount() {
+            return nonmallocedCount;
+        }
+
+        /**
+         * Returns the memory size in bytes of nonmalloced native allocations
+         */
+        public long getNonmallocedBytes() {
+            return nonmallocedBytes;
+        }
+    }
+
+    /**
+     * Returns per-class metrics in a Collection.
+     *
+     * Metrics of the same class (even through multiple registries) will be aggregated
+     * under the same class name.
+     *
+     * Metrics of the registries with no class explictily specified will be aggregated
+     * under the class name of `libcore.util.NativeAllocationRegistry` by default.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @FlaggedApi(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public static synchronized @NonNull Collection<Metrics> getMetrics() {
+        Map<String, Metrics> result = new HashMap<>();
+        for (NativeAllocationRegistry r : registries.keySet()) {
+            String className = r.clazz.getName();
+            Metrics m = result.get(className);
+            if (m == null) {
+                m = new Metrics(className);
+                result.put(className, m);
+            }
+            m.add(r);
+        }
+        return result.values();
     }
 
     /**
@@ -279,6 +516,7 @@ public class NativeAllocationRegistry {
         thunk.setNativePtr(nativePtr);
         // Ensure that cleaner doesn't get invoked before we enable it.
         Reference.reachabilityFence(referent);
+        updateMetrics(this.size);
         return result;
     }
 
@@ -293,6 +531,7 @@ public class NativeAllocationRegistry {
             if (nativePtr != 0) {
                 applyFreeFunction(freeFunction, nativePtr);
                 registerNativeFree(size);
+                updateMetrics(-size);
             }
         }
 
diff --git a/luni/src/main/java/libcore/util/TEST_MAPPING b/luni/src/main/java/libcore/util/TEST_MAPPING
index 670cd00f0a1..e0ffae6a12d 100644
--- a/luni/src/main/java/libcore/util/TEST_MAPPING
+++ b/luni/src/main/java/libcore/util/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.libcore.util"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_libcore_util"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/org/apache/harmony/xml/TEST_MAPPING b/luni/src/main/java/org/apache/harmony/xml/TEST_MAPPING
index d8c9759faeb..9a71ddfd656 100644
--- a/luni/src/main/java/org/apache/harmony/xml/TEST_MAPPING
+++ b/luni/src/main/java/org/apache/harmony/xml/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_xml"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/org/w3c/dom/TEST_MAPPING b/luni/src/main/java/org/w3c/dom/TEST_MAPPING
index 00e68f7854a..b9e99a0f60d 100644
--- a/luni/src/main/java/org/w3c/dom/TEST_MAPPING
+++ b/luni/src/main/java/org/w3c/dom/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        },
-        {
-          "include-filter": "tests.org.w3c.dom"
-        },
-        {
-          "include-filter": "org.w3c.domts"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_w3c_dom"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/org/xml/sax/TEST_MAPPING b/luni/src/main/java/org/xml/sax/TEST_MAPPING
index afedf2c13bf..d83fcfa9a65 100644
--- a/luni/src/main/java/org/xml/sax/TEST_MAPPING
+++ b/luni/src/main/java/org/xml/sax/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.org.xml.sax"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_xml_sax"
     }
   ]
 }
\ No newline at end of file
diff --git a/luni/src/main/java/org/xml/sax/ext/TEST_MAPPING b/luni/src/main/java/org/xml/sax/ext/TEST_MAPPING
deleted file mode 100644
index 50687abb9c1..00000000000
--- a/luni/src/main/java/org/xml/sax/ext/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.org.xml.sax.ext"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/luni/src/main/java/org/xml/sax/helpers/TEST_MAPPING b/luni/src/main/java/org/xml/sax/helpers/TEST_MAPPING
deleted file mode 100644
index f13e3f9cb80..00000000000
--- a/luni/src/main/java/org/xml/sax/helpers/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.org.xml.sax.helpers"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/luni/src/main/native/ZipUtilities.cpp b/luni/src/main/native/ZipUtilities.cpp
index a29d009d04b..28a86e2c9a4 100644
--- a/luni/src/main/native/ZipUtilities.cpp
+++ b/luni/src/main/native/ZipUtilities.cpp
@@ -44,7 +44,7 @@ NativeZipStream::~NativeZipStream() {
 
 void NativeZipStream::setDictionary(JNIEnv* env, jbyteArray javaDictionary, int off, int len,
     bool inflate) {
-  std::unique_ptr<jbyte[]> dictionaryBytes(new jbyte[len]);
+  std::unique_ptr<jbyte[]> dictionaryBytes(new(std::nothrow) jbyte[len]);
   if (dictionaryBytes.get() == NULL) {
     jniThrowOutOfMemoryError(env, NULL);
     return;
@@ -65,7 +65,7 @@ void NativeZipStream::setDictionary(JNIEnv* env, jbyteArray javaDictionary, int
 }
 
 void NativeZipStream::setInput(JNIEnv* env, jbyteArray buf, jint off, jint len) {
-  input.reset(new jbyte[len]);
+  input.reset(new(std::nothrow) jbyte[len]);
   if (input.get() == NULL) {
     inCap = 0;
     jniThrowOutOfMemoryError(env, NULL);
diff --git a/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp b/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
index fdabcf71591..ee8c182933e 100644
--- a/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
+++ b/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
@@ -75,7 +75,7 @@ public:
     void push(JNIEnv* env, jstring s) {
         if (size == capacity) {
             int newCapacity = capacity * 2;
-            jstring* newArray = new jstring[newCapacity];
+            jstring* newArray = new(std::nothrow) jstring[newCapacity];
             if (newArray == NULL) {
                 jniThrowOutOfMemoryError(env, NULL);
                 return;
@@ -259,7 +259,7 @@ static int hashString(const char* s) {
  */
 static InternedString* newInternedString(JNIEnv* env, const char* bytes, int hash) {
     // Allocate a new wrapper.
-    std::unique_ptr<InternedString> wrapper(new InternedString);
+    std::unique_ptr<InternedString> wrapper(new(std::nothrow) InternedString);
     if (wrapper.get() == NULL) {
         jniThrowOutOfMemoryError(env, NULL);
         return NULL;
@@ -267,7 +267,7 @@ static InternedString* newInternedString(JNIEnv* env, const char* bytes, int has
 
     // Create a copy of the UTF-8 bytes.
     // TODO: sometimes we already know the length. Reuse it if so.
-    char* copy = new char[strlen(bytes) + 1];
+    char* copy = new(std::nothrow) char[strlen(bytes) + 1];
     if (copy == NULL) {
         jniThrowOutOfMemoryError(env, NULL);
         return NULL;
@@ -308,7 +308,7 @@ static InternedString* newInternedString(JNIEnv* env, const char* bytes, int has
  * @returns a reference to the bucket
  */
 static InternedString** newInternedStringBucket(InternedString* entry) {
-    InternedString** bucket = new InternedString*[2];
+    InternedString** bucket = new(std::nothrow) InternedString*[2];
     if (bucket != NULL) {
         bucket[0] = entry;
         bucket[1] = NULL;
@@ -332,7 +332,7 @@ static InternedString** expandInternedStringBucket(
 
     // Allocate the new bucket with enough space for one more entry and
     // a null terminator.
-    InternedString** newBucket = new InternedString*[size + 2];
+    InternedString** newBucket = new(std::nothrow) InternedString*[size + 2];
     if (newBucket == NULL) return NULL;
 
     memcpy(newBucket, existingBucket, size * sizeof(InternedString*));
@@ -978,7 +978,7 @@ static void notationDecl(void* data, const char* name, const char* /*base*/, con
 static jlong ExpatParser_initialize(JNIEnv* env, jobject object, jstring javaEncoding,
         jboolean processNamespaces) {
     // Allocate parsing context.
-    std::unique_ptr<ParsingContext> context(new ParsingContext(object));
+    std::unique_ptr<ParsingContext> context(new(std::nothrow) ParsingContext(object));
     if (context.get() == NULL) {
         jniThrowOutOfMemoryError(env, NULL);
         return 0;
@@ -1270,7 +1270,7 @@ static jlong ExpatParser_cloneAttributes(JNIEnv* env, jobject, jlong address, ji
         totalSize += length + 1;
     }
 
-    char* buffer = new char[totalSize];
+    char* buffer = new(std::nothrow) char[totalSize];
     if (buffer == NULL) {
         jniThrowOutOfMemoryError(env, NULL);
         return 0;
diff --git a/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListTest.java b/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListTest.java
index b0b06ac168b..65865a5049a 100644
--- a/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListTest.java
+++ b/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListTest.java
@@ -18,13 +18,16 @@ package libcore.android34.java.util;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
@@ -228,4 +231,176 @@ public class ListTest {
         assertTrue(myList.removeLast());
         assertFalse(myList.removeFirst()); // False because the list is empty.
     }
+
+    @Test
+    public void testPackageProtectedOverriddenMethods() throws ReflectiveOperationException {
+        PackageProtectedList p = new PackageProtectedList();
+        p.addFirst("a");
+        // addFirst() method adds twice.
+        assertEquals(2, p.size());
+        assertEquals("a", p.get(0));
+        assertEquals("a", p.get(1));
+        assertSame(p, p.getFirst());
+
+        List<Object> list = new PackageProtectedList();
+        // Uses reflection API to simulate invoke-interface addFirst from the ART / frameworks.
+        // However, I don't see any usage of List.addFirst in ART, and we can't directly call the
+        // method here because the subclass can only be compiled when compiling SDK 34 or below.
+        Method addFirst = List.class.getMethod("addFirst", Object.class);
+        addFirst.invoke(list, "a");
+        // addFirst() method adds twice.
+        assertEquals(2, p.size());
+    }
+
+    @Test
+    public void testPrivateMethods() throws ReflectiveOperationException {
+        ListWithPrivateMethods p = new ListWithPrivateMethods();
+        p.externalAddFirst("a");
+        // addFirst() method adds twice.
+        assertEquals(2, p.size());
+        assertEquals("a", p.get(0));
+        assertEquals("a", p.get(1));
+        assertSame(p, p.externalGetFirst());
+
+        List<Object> list = new ListWithPrivateMethods();
+        // Uses reflection API to simulate invoke-interface addFirst from the ART / frameworks.
+        // However, I don't see any usage of List.addFirst in ART, and we can't directly call the
+        // method here because the subclass can only be compiled when compiling SDK 34 or below.
+        Method addFirst = List.class.getMethod("addFirst", Object.class);
+        addFirst.invoke(list, "a");
+        // addFirst() method adds twice.
+        assertEquals(2, p.size());
+    }
+
+    public interface ClashList<E> {
+        default void addFirst(E e) {}
+    }
+
+    /** This class doesn't override addFirst(E) */
+    public static class ClashClass implements List<Object>, ClashList<Object> {
+        @Override
+        public int size() {
+            return 0;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Iterator<Object> iterator() {
+            return null;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return new Object[0];
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return null;
+        }
+
+        @Override
+        public boolean add(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return false;
+        }
+
+        @Override
+        public boolean addAll(Collection<?> c) {
+            return false;
+        }
+
+        @Override
+        public boolean addAll(int index, Collection<?> c) {
+            return false;
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return false;
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return false;
+        }
+
+        @Override
+        public void clear() {
+
+        }
+
+        @Override
+        public Object get(int index) {
+            return null;
+        }
+
+        @Override
+        public Object set(int index, Object element) {
+            return null;
+        }
+
+        @Override
+        public void add(int index, Object element) {
+
+        }
+
+        @Override
+        public Object remove(int index) {
+            return null;
+        }
+
+        @Override
+        public int indexOf(Object o) {
+            return 0;
+        }
+
+        @Override
+        public int lastIndexOf(Object o) {
+            return 0;
+        }
+
+        @Override
+        public ListIterator<Object> listIterator() {
+            return null;
+        }
+
+        @Override
+        public ListIterator<Object> listIterator(int index) {
+            return null;
+        }
+
+        @Override
+        public List<Object> subList(int fromIndex, int toIndex) {
+            return null;
+        }
+    }
+
+    /**
+     * Test for 13.5.7. Interface Method Declarations. It's a known risk of adding
+     * a new default method.
+     */
+    @Test(expected=IncompatibleClassChangeError.class)
+    public void testDefaultMethodClash() {
+        ClashClass l = new ClashClass();
+        l.addFirst("a");
+    }
 }
diff --git a/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListWithPrivateMethods.java b/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListWithPrivateMethods.java
new file mode 100644
index 00000000000..c64e4aa9393
--- /dev/null
+++ b/luni/src/test/androidsdk34/src/libcore/android34/java/util/ListWithPrivateMethods.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package libcore.android34.java.util;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+class ListWithPrivateMethods implements List<Object> {
+    private final ArrayList<Object> l = new ArrayList<>();
+    @Override
+    public int size() {
+        return l.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return l.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return l.contains(o);
+    }
+
+    @Override
+    public Iterator<Object> iterator() {
+        return l.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return l.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return l.toArray(a);
+    }
+
+    @Override
+    public boolean add(Object s) {
+        return l.add(s);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return l.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return l.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Object> c) {
+        return l.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends Object> c) {
+        return l.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        return l.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return l.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        l.clear();
+    }
+
+    @Override
+    public Object get(int index) {
+        return l.get(index);
+    }
+
+    @Override
+    public Object set(int index, Object s) {
+        return l.set(index, s);
+    }
+
+    @Override
+    public void add(int index, Object s) {
+        l.add(index, s);
+    }
+
+    @Override
+    public Object remove(int index) {
+        return l.remove(index);
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return l.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return l.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<Object> listIterator() {
+        return l.listIterator();
+    }
+
+    @Override
+    public ListIterator<Object> listIterator(int index) {
+        return l.listIterator(index);
+    }
+
+    @Override
+    public List<Object> subList(int fromIndex, int toIndex) {
+        return l.subList(fromIndex, toIndex);
+    }
+
+    /* New methods in OpenJDK 21 begins */
+
+    /** vs void addFirst(E). It adds twice. */
+    private void addFirst(Object s) {
+        l.add(0, s);
+        l.add(0, s);
+    }
+
+    public void externalAddFirst(Object s) {
+        addFirst(s);
+    }
+
+    /** vs E getFirst(). It returns list, not an element. */
+    private Object getFirst() {
+        return this;
+    }
+
+    public Object externalGetFirst() {
+        return getFirst();
+    }
+}
diff --git a/luni/src/test/androidsdk34/src/libcore/android34/java/util/PackageProtectedList.java b/luni/src/test/androidsdk34/src/libcore/android34/java/util/PackageProtectedList.java
new file mode 100644
index 00000000000..3d7bbccd710
--- /dev/null
+++ b/luni/src/test/androidsdk34/src/libcore/android34/java/util/PackageProtectedList.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package libcore.android34.java.util;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+class PackageProtectedList implements List<Object> {
+    private final ArrayList<Object> l = new ArrayList<>();
+    @Override
+    public int size() {
+        return l.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return l.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return l.contains(o);
+    }
+
+    @Override
+    public Iterator<Object> iterator() {
+        return l.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return l.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return l.toArray(a);
+    }
+
+    @Override
+    public boolean add(Object s) {
+        return l.add(s);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return l.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return l.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Object> c) {
+        return l.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends Object> c) {
+        return l.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        return l.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return l.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        l.clear();
+    }
+
+    @Override
+    public Object get(int index) {
+        return l.get(index);
+    }
+
+    @Override
+    public Object set(int index, Object s) {
+        return l.set(index, s);
+    }
+
+    @Override
+    public void add(int index, Object s) {
+        l.add(index, s);
+    }
+
+    @Override
+    public Object remove(int index) {
+        return l.remove(index);
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return l.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return l.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<Object> listIterator() {
+        return l.listIterator();
+    }
+
+    @Override
+    public ListIterator<Object> listIterator(int index) {
+        return l.listIterator(index);
+    }
+
+    @Override
+    public List<Object> subList(int fromIndex, int toIndex) {
+        return l.subList(fromIndex, toIndex);
+    }
+
+    /* New methods in OpenJDK 21 begins */
+
+    /** vs void addFirst(E). It adds twice. */
+    void addFirst(Object s) {
+        l.add(0, s);
+        l.add(0, s);
+    }
+
+    /** vs void addLast(E). It adds twice. */
+    void addLast(Object s) {
+        l.add(s);
+        l.add(s);
+    }
+
+    /** vs E getFirst(). It returns list, not an element. */
+    Object getFirst() {
+        return this;
+    }
+    /** vs E getLast(). It returns list, not an element. */
+    Object getLast() {
+        return this;
+    }
+}
diff --git a/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java b/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
index 438a69a5051..4c1a080e137 100644
--- a/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
+++ b/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
@@ -16,15 +16,26 @@
 
 package libcore.dalvik.system;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
 import java.lang.reflect.Array;
-import junit.framework.TestCase;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import dalvik.system.VMRuntime;
 
+import org.junit.Assume;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 /**
  * Test VMRuntime behavior.
  */
-public final class VMRuntimeTest extends TestCase {
+@RunWith(JUnit4.class)
+public final class VMRuntimeTest {
 
     private void doTestNewNonMovableArray(Class<?> componentType, int step, int maxLength) {
         // Can't create negative sized arrays.
@@ -49,6 +60,7 @@ public final class VMRuntimeTest extends TestCase {
         }
     }
 
+    @Test
     public void testNewNonMovableArray() {
         // Can't create arrays with no component type.
         try {
@@ -103,6 +115,7 @@ public final class VMRuntimeTest extends TestCase {
         }
     }
 
+    @Test
     public void testNewUnpaddedArray() {
         // Can't create arrays with no component type.
         try {
@@ -133,5 +146,71 @@ public final class VMRuntimeTest extends TestCase {
         doTestNewUnpaddedArray(String.class, step, maxLengthForLoop);
         doTestNewUnpaddedArray(Runnable.class, step, maxLengthForLoop);
     }
+
+    @Test
+    public void testIsVTrunkStableFlagEnabled() {
+        // The flag should be on all stages, including trunk_staging and next.
+        assertTrue(VMRuntime.isVTrunkStableFlagEnabled());
+    }
+
+    @Test
+    public void testIsArtTestFlagEnabled() {
+        boolean b = VMRuntime.isArtTestFlagEnabled();
+        // TODO(b/352723620): The flag value depends on the release
+        // configurations. Don't assert the value until the flag is turned on in
+        // all configurations.
+        Assume.assumeTrue(b);
+    }
+
+    @Test
+    public void testGetFullGcCount() {
+        long gcCount = VMRuntime.getFullGcCount();
+        // full GC count needs to be larger or equal to 0
+        assertTrue("Full GC count needs to be non-negative", gcCount >= 0);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(com.android.libcore.Flags.FLAG_POST_CLEANUP_APIS)
+    public void testPostCleanup() {
+        AtomicInteger cleanupCounter = new AtomicInteger(0);
+
+        Runnable r1 = new Runnable() {
+            @Override
+            public void run() {
+                cleanupCounter.addAndGet(1);
+            }
+        };
+        Runnable r2 = new Runnable() {
+            @Override
+            public void run() {
+                cleanupCounter.addAndGet(2);
+            }
+        };
+
+        // test callbacks are called when explicitly trigger onPostCleanup()
+        VMRuntime.addPostCleanupCallback(r1);
+        VMRuntime.addPostCleanupCallback(r2);
+        VMRuntime.onPostCleanup();
+        assertTrue(cleanupCounter.get() == 3);
+
+        // test callbacks are called when GC is triggered and finalization is done
+        System.gc();
+        System.runFinalization();
+        try {
+            int nsleep = 5;
+            while (cleanupCounter.get() < 6 && (nsleep-- > 0)) {
+                Thread.sleep(1000);
+            }
+        } catch (InterruptedException e) {
+            assertTrue("Sleep in test interrupted", false);
+        }
+
+        // NOTE: post cleanup could happen more than 1 time, hence the counter could be >= 6
+        int counter = cleanupCounter.get();
+        assertTrue("cleanupCounter should be >=6, got " + counter + " instead", counter >= 6);
+
+        VMRuntime.removePostCleanupCallback(r1);
+        VMRuntime.removePostCleanupCallback(r2);
+    }
 }
 
diff --git a/luni/src/test/java/libcore/java/lang/StringBufferTest.java b/luni/src/test/java/libcore/java/lang/StringBufferTest.java
index 301d00178f8..a25f8f28002 100644
--- a/luni/src/test/java/libcore/java/lang/StringBufferTest.java
+++ b/luni/src/test/java/libcore/java/lang/StringBufferTest.java
@@ -79,4 +79,51 @@ public class StringBufferTest extends TestCase {
         sb1.append("a");
         assertEquals(0, new StringBuffer("a").compareTo(sb1));
     }
+
+    // Regression test for b/356007654.
+    public void testIndexOf_afterAppendChar() {
+        assertIndexOfAfterAppend('Z');
+        assertIndexOfAfterAppend(' ');
+        assertIndexOfAfterAppend('\u0010');
+        assertIndexOfAfterAppend('\u00B0');
+        assertIndexOfAfterAppend('\u0080');
+        assertIndexOfAfterAppend('\u00ff');
+        assertIndexOfAfterAppend('\u0100');
+        assertIndexOfAfterAppend('\u201f');
+        assertIndexOfAfterAppend('\uffff');
+    }
+
+    private static void assertIndexOfAfterAppend(char ch) {
+        String str = String.valueOf(ch);
+
+        StringBuffer sb = new StringBuffer("abc");
+        sb.append(ch);
+        sb.append("123");
+        sb.append(ch);
+        sb.append("abc");
+        assertEquals(3, sb.indexOf(str));
+    }
+    // Regression test for b/356007654.
+    public void testLastIndexOf_afterAppendChar() {
+        assertLastIndexOfAfterAppend('Z');
+        assertLastIndexOfAfterAppend(' ');
+        assertLastIndexOfAfterAppend('\u0010');
+        assertLastIndexOfAfterAppend('\u00B0');
+        assertLastIndexOfAfterAppend('\u0080');
+        assertLastIndexOfAfterAppend('\u00ff');
+        assertLastIndexOfAfterAppend('\u0100');
+        assertLastIndexOfAfterAppend('\u201f');
+        assertLastIndexOfAfterAppend('\uffff');
+    }
+
+    private static void assertLastIndexOfAfterAppend(char ch) {
+        String str = String.valueOf(ch);
+
+        StringBuffer sb = new StringBuffer("abc");
+        sb.append(ch);
+        sb.append("123");
+        sb.append(ch);
+        sb.append("abc");
+        assertEquals(7, sb.lastIndexOf(str));
+    }
 }
diff --git a/luni/src/test/java/libcore/java/lang/StringBuilderTest.java b/luni/src/test/java/libcore/java/lang/StringBuilderTest.java
index 7a45749e630..e00836139d8 100644
--- a/luni/src/test/java/libcore/java/lang/StringBuilderTest.java
+++ b/luni/src/test/java/libcore/java/lang/StringBuilderTest.java
@@ -196,4 +196,51 @@ public class StringBuilderTest extends junit.framework.TestCase {
         sb.append('a');
         assertFalse(sb.isEmpty());
     }
+
+    // Regression test for b/356007654.
+    public void testIndexOf_afterAppendChar() {
+        assertIndexOfAfterAppend('Z');
+        assertIndexOfAfterAppend(' ');
+        assertIndexOfAfterAppend('\u0010');
+        assertIndexOfAfterAppend('\u00B0');
+        assertIndexOfAfterAppend('\u0080');
+        assertIndexOfAfterAppend('\u00ff');
+        assertIndexOfAfterAppend('\u0100');
+        assertIndexOfAfterAppend('\u201f');
+        assertIndexOfAfterAppend('\uffff');
+    }
+
+    private static void assertIndexOfAfterAppend(char ch) {
+        String str = String.valueOf(ch);
+
+        StringBuilder sb = new StringBuilder("abc");
+        sb.append(ch);
+        sb.append("123");
+        sb.append(ch);
+        sb.append("abc");
+        assertEquals(3, sb.indexOf(str));
+    }
+    // Regression test for b/356007654.
+    public void testLastIndexOf_afterAppendChar() {
+        assertLastIndexOfAfterAppend('Z');
+        assertLastIndexOfAfterAppend(' ');
+        assertLastIndexOfAfterAppend('\u0010');
+        assertLastIndexOfAfterAppend('\u00B0');
+        assertLastIndexOfAfterAppend('\u0080');
+        assertLastIndexOfAfterAppend('\u00ff');
+        assertLastIndexOfAfterAppend('\u0100');
+        assertLastIndexOfAfterAppend('\u201f');
+        assertLastIndexOfAfterAppend('\uffff');
+    }
+
+    private static void assertLastIndexOfAfterAppend(char ch) {
+        String str = String.valueOf(ch);
+
+        StringBuilder sb = new StringBuilder("abc");
+        sb.append(ch);
+        sb.append("123");
+        sb.append(ch);
+        sb.append("abc");
+        assertEquals(7, sb.lastIndexOf(str));
+    }
 }
diff --git a/luni/src/test/java/libcore/java/net/ConcurrentCloseTest.java b/luni/src/test/java/libcore/java/net/ConcurrentCloseTest.java
index 440d2cd2f5f..f8ae6e471eb 100644
--- a/luni/src/test/java/libcore/java/net/ConcurrentCloseTest.java
+++ b/luni/src/test/java/libcore/java/net/ConcurrentCloseTest.java
@@ -33,6 +33,7 @@ import java.nio.channels.SocketChannel;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Test that Socket.close called on another thread interrupts a thread that's blocked doing
@@ -173,31 +174,45 @@ public class ConcurrentCloseTest extends junit.framework.TestCase {
 
     public void test_write() throws Exception {
         final SilentServer ss = new SilentServer(128); // Minimal receive buffer size.
-        Socket s = new Socket();
 
-        // Set the send buffer size really small, to ensure we block.
-        int sendBufferSize = 1024;
-        s.setSendBufferSize(sendBufferSize);
-        sendBufferSize = s.getSendBufferSize(); // How big is the buffer really, Linux?
+        // The test needs to send enough data to cause the write to block for long enough for
+        // the socket close to occur. Start with a large enough factor and, if that doesn't
+        // seem to be sufficient to cause the block, double it and try again. A factor of 2
+        // used to be OK, then that needed to be increased to 4 and now this is also not
+        // enough in some cases. (b/356850236)
+        int bufferFactor = 4;
 
-        // Linux still seems to accept more than it should.
-        // How much seems to differ from device to device. This used to be (sendBufferSize * 2)
-        // but that still failed on a bullhead (Nexus 5X).
-        sendBufferSize *= 4;
+        while (true) {
+            Socket s = new Socket();
 
-        s.connect(ss.getLocalSocketAddress());
-        new Killer(s).start();
-        try {
-            System.err.println("write...");
-            // Write too much so the buffer is full and we block,
-            // waiting for the server to read (which it never will).
-            // If the asynchronous close fails, we'll see a test timeout here.
-            byte[] buf = new byte[sendBufferSize];
-            s.getOutputStream().write(buf);
-            fail();
-        } catch (SocketException expected) {
-            // We throw "Connection reset by peer", which I don't _think_ is a problem.
-            // assertEquals("Socket closed", expected.getMessage());
+            // Set the send buffer size really small, to ensure we block.
+            int sendBufferSize = 1024;
+            s.setSendBufferSize(sendBufferSize);
+            sendBufferSize = s.getSendBufferSize(); // How big is the buffer really, Linux?
+
+            sendBufferSize *= bufferFactor;
+
+            s.connect(ss.getLocalSocketAddress());
+            Killer killer = new Killer(s);
+            killer.start();
+            try {
+                System.err.println("write...");
+                // Write too much so the buffer is full and we block,
+                // waiting for the server to read (which it never will).
+                // If the asynchronous close fails, we'll see a test timeout here.
+                byte[] buf = new byte[sendBufferSize];
+                s.getOutputStream().write(buf);
+                if (killer.wasDefinitelyKilled()) {
+                    fail("Socket close happened before write completed successfully");
+                } else {
+                    // Increase the bytes sent to try and cause write() to block for enough time.
+                    bufferFactor *= 2;
+                }
+            } catch (SocketException expected) {
+                // We throw "Connection reset by peer", which I don't _think_ is a problem.
+                // assertEquals("Socket closed", expected.getMessage());
+                break;
+            }
         }
         ss.close();
     }
@@ -242,6 +257,7 @@ public class ConcurrentCloseTest extends junit.framework.TestCase {
     // This thread calls the "close" method on the supplied T after 2s.
     static class Killer<T extends Closeable> extends Thread {
         private final T s;
+        private final AtomicLong killedTs = new AtomicLong(0);
 
         public Killer(T s) {
             this.s = s;
@@ -253,9 +269,17 @@ public class ConcurrentCloseTest extends junit.framework.TestCase {
                 Thread.sleep(2000);
                 System.err.println("close...");
                 s.close();
+                killedTs.set(System.nanoTime());
             } catch (Exception ex) {
                 ex.printStackTrace();
             }
         }
+
+        public boolean wasDefinitelyKilled() {
+            final long minThresholdNs = 500 * 1000 * 1000;
+            final long now = System.nanoTime();
+            final long killed = killedTs.get();
+            return (killed > 0 && now - killed > minThresholdNs);
+        }
     }
 }
diff --git a/luni/src/test/java/libcore/java/security/ProviderTest.java b/luni/src/test/java/libcore/java/security/ProviderTest.java
index e192dfb46b4..2b89296c891 100644
--- a/luni/src/test/java/libcore/java/security/ProviderTest.java
+++ b/luni/src/test/java/libcore/java/security/ProviderTest.java
@@ -30,7 +30,6 @@ import java.security.cert.CertStoreException;
 import java.security.cert.CertStoreParameters;
 import java.security.cert.CertStoreSpi;
 import java.security.cert.Certificate;
-import java.security.cert.CollectionCertStoreParameters;
 import java.security.interfaces.RSAPrivateKey;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -171,16 +170,6 @@ public class ProviderTest extends TestCaseWithRules {
                         missing.add(className);
                     }
                 }
-
-                // Try to create an instance. Some algorithms require a parameter,
-                // so we need to feed them something they'll be happy with.
-                Object param = null;
-                if (algorithm.equals("COLLECTION")) {
-                    param = new CollectionCertStoreParameters();
-                }
-                assertNotNull("Failed to instantiate " + providerName + " " + type + " " + algorithm
-                        + " " + className,
-                    service.newInstance(param));
             }
 
             // last chance: some algorithms might only be provided by their alias
diff --git a/luni/src/test/java/libcore/java/util/LegacyLocalesTest.java b/luni/src/test/java/libcore/java/util/LegacyLocalesTest.java
index 25fff2dc83b..115cf48bf9c 100644
--- a/luni/src/test/java/libcore/java/util/LegacyLocalesTest.java
+++ b/luni/src/test/java/libcore/java/util/LegacyLocalesTest.java
@@ -23,15 +23,16 @@ import static org.junit.Assume.assumeTrue;
 import dalvik.annotation.compat.VersionCodes;
 import dalvik.system.VMRuntime;
 
-import libcore.junit.util.compat.CoreCompatChangeRule;
-import libcore.junit.util.compat.CoreCompatChangeRule.DisableCompatChanges;
-import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
+import libcore.junit.util.SwitchTargetSdkVersionRule;
+import libcore.junit.util.SwitchTargetSdkVersionRule.TargetSdkVersion;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.text.BreakIterator;
 import java.text.Collator;
@@ -44,14 +45,15 @@ import java.util.Map;
 
 import sun.util.locale.BaseLocale;
 
+@RunWith(JUnit4.class)
 public class LegacyLocalesTest {
 
     @Rule
-    public final TestRule compatChangeRule = new CoreCompatChangeRule();
+    public TestRule switchTargetSdkVersionRule = SwitchTargetSdkVersionRule.getInstance();
 
     // http://b/3452611; Locale.getDisplayLanguage fails for the obsolete language codes.
     @Test
-    @DisableCompatChanges({BaseLocale.USE_NEW_ISO_LOCALE_CODES})
+    @TargetSdkVersion(VersionCodes.UPSIDE_DOWN_CAKE)
     public void test_getDisplayName_obsolete() {
         // he (new) -> iw (obsolete)
         assertObsolete("he", "iw", "");
@@ -60,7 +62,7 @@ public class LegacyLocalesTest {
     }
 
     @Test
-    @EnableCompatChanges({BaseLocale.USE_NEW_ISO_LOCALE_CODES})
+    @TargetSdkVersion(VersionCodes.VANILLA_ICE_CREAM)
     public void obsoleteLocales_withFlagEnabled() {
         var msg = "Test should run on V+ only, current SDK level=" + VMRuntime.getSdkVersion();
         assumeTrue(msg, VMRuntime.getSdkVersion() >= VersionCodes.VANILLA_ICE_CREAM);
diff --git a/luni/src/test/java/libcore/java/util/TimeZoneTest.java b/luni/src/test/java/libcore/java/util/TimeZoneTest.java
index f871da11f3f..a1a71a75df0 100644
--- a/luni/src/test/java/libcore/java/util/TimeZoneTest.java
+++ b/luni/src/test/java/libcore/java/util/TimeZoneTest.java
@@ -31,6 +31,7 @@ import libcore.junit.util.SwitchTargetSdkVersionRule.TargetSdkVersion;
 import org.junit.Rule;
 import org.junit.rules.TestRule;
 
+@SuppressWarnings("InvalidTimeZoneID") // We test behaviour around these invalid IDs.
 public class TimeZoneTest extends TestCaseWithRules {
 
     @Rule
@@ -212,6 +213,11 @@ public class TimeZoneTest extends TestCaseWithRules {
         assertEquals("GMT+05:00", TimeZone.getTimeZone("GMT+0500").getID());
         assertEquals("GMT+05:00", TimeZone.getTimeZone("GMT+500").getID());
         assertEquals("GMT+05:00", TimeZone.getTimeZone("GMT+5").getID());
+        assertEquals("GMT+05:00", TimeZone.getTimeZone("GMT+05:00:00").getID());
+        assertEquals("GMT+05:00", TimeZone.getTimeZone("GMT+5:00:00").getID());
+        assertEquals("GMT+05:00:45", TimeZone.getTimeZone("GMT+05:00:45").getID());
+        assertEquals("GMT+05:31:45", TimeZone.getTimeZone("GMT+05:31:45").getID());
+        assertEquals("GMT+15:00:45", TimeZone.getTimeZone("GMT+15:00:45").getID());
         // These aren't.
         assertEquals("GMT", TimeZone.getTimeZone("GMT+5.5").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+5:5").getID());
@@ -222,7 +228,6 @@ public class TimeZoneTest extends TestCaseWithRules {
         assertEquals("GMT", TimeZone.getTimeZone("GMT+05:99").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+28:00").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+05:00.00").getID());
-        assertEquals("GMT", TimeZone.getTimeZone("GMT+05:00:00").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+5:").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+junk").getID());
         assertEquals("GMT", TimeZone.getTimeZone("GMT+5junk").getID());
@@ -231,6 +236,37 @@ public class TimeZoneTest extends TestCaseWithRules {
         assertEquals("GMT", TimeZone.getTimeZone("junkGMT+5:00").getID());
         assertEquals("GMT", TimeZone.getTimeZone("junk").getID());
         assertEquals("GMT", TimeZone.getTimeZone("gmt+5:00").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+05:3030").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+0530:30").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+053030").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+05:00:60").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+05:00:90").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT+05:00:-10").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT05:00:-10").getID());
+        assertEquals("GMT", TimeZone.getTimeZone("GMT005:00:-10").getID());
+    }
+
+    public void testCustomZoneIds_offsets() {
+        Object[] data = {
+            "GMT+05:30:30",  5 * 60 * 60 + 30 * 60 + 30,
+            "GMT+525",       5 * 60 * 60 + 25 * 60,
+            "GMT-4",         -4 * 60 * 60,
+            "GMT-23",        -23 * 60 * 60,
+            "GMT-230",       -(2 * 60 * 60 + 30 * 60),
+            "GMT-23:59:59",  -(23 * 60 * 60 + 59 * 60 + 59),
+            "GMT+1234",      12 * 60 * 60 + 34 * 60,
+            "GMT+junk",      0,
+            "GMT+111111",    0,
+            "GMT+23:59:60",  0,
+        };
+
+        for (int i = 0; i < data.length; i = i + 2) {
+            TimeZone tz = TimeZone.getTimeZone((String) data[i]);
+            int offsetInSeconds = (int) data[i + 1];
+
+            String msg = "Unexpected offset at element " + (i / 2);
+            assertEquals(msg, offsetInSeconds * 1_000, tz.getRawOffset());
+        }
     }
 
     public void test_getDSTSavings() throws Exception {
diff --git a/luni/src/test/java/libcore/java/util/WeakHashMapTest.java b/luni/src/test/java/libcore/java/util/WeakHashMapTest.java
index 2cac89af101..3d43d42f030 100644
--- a/luni/src/test/java/libcore/java/util/WeakHashMapTest.java
+++ b/luni/src/test/java/libcore/java/util/WeakHashMapTest.java
@@ -16,20 +16,33 @@
 
 package libcore.java.util;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import junit.framework.TestCase;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 import java.lang.reflect.Field;
 import java.util.ConcurrentModificationException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.WeakHashMap;
 
-public class WeakHashMapTest extends TestCase {
+@RunWith(JUnit4.class)
+public class WeakHashMapTest {
 
     static Data[] data = new Data[100];
 
+    @Test
     public void test_replaceAll() {
         initializeData();
         WeakHashMap<Data, String> map = new WeakHashMap<>();
@@ -73,6 +86,7 @@ public class WeakHashMapTest extends TestCase {
         assertEquals(data.length, map.size());
     }
 
+    @Test
     public void testContainsNullValue() {
         var map = new WeakHashMap<String, String>();
 
@@ -87,6 +101,7 @@ public class WeakHashMapTest extends TestCase {
         assertTrue(map.containsValue(null));
     }
 
+    @Test
     public void testEntrySet_removeMapping() {
         var map = new WeakHashMap<String, String>();
         assertFalse(map.entrySet().remove(new Object()));
@@ -99,6 +114,7 @@ public class WeakHashMapTest extends TestCase {
         assertTrue(map.isEmpty());
     }
 
+    @Test
     public void testEntrySet_clear() {
         var map = new WeakHashMap<String, String>();
 
@@ -109,6 +125,7 @@ public class WeakHashMapTest extends TestCase {
         assertTrue(map.isEmpty());
     }
 
+    @Test
     public void testEntrySet_entrySetValue() {
         var map = new WeakHashMap<String, String>();
 
@@ -121,6 +138,7 @@ public class WeakHashMapTest extends TestCase {
         assertEquals("new value", map.get("key"));
     }
 
+    @Test
     public void testEntrySet_entryEquals() {
         var map = new WeakHashMap<String, String>();
 
@@ -132,6 +150,7 @@ public class WeakHashMapTest extends TestCase {
         assertNotEquals(entry, Map.entry("key", "another value"));
     }
 
+    @Test
     public void testKeySet_remove() {
         var map = new WeakHashMap<String, String>();
 
@@ -141,6 +160,7 @@ public class WeakHashMapTest extends TestCase {
         assertFalse(keys.remove(new Object()));
     }
 
+    @Test
     public void testKeySet_clear() {
         var map = new WeakHashMap<String, String>();
 
@@ -150,6 +170,7 @@ public class WeakHashMapTest extends TestCase {
         assertTrue(map.isEmpty());
     }
 
+    @Test
     public void testValues_clear() {
         var map = new WeakHashMap<String, String>();
 
@@ -159,6 +180,7 @@ public class WeakHashMapTest extends TestCase {
         assertTrue(map.isEmpty());
     }
 
+    @Test
     public void test_putAll() throws Throwable {
         var map = new WeakHashMap<String, String>();
 
@@ -175,6 +197,17 @@ public class WeakHashMapTest extends TestCase {
         assertEquals(anotherMap, map);
     }
 
+    @Test
+    public void factoryMethod() {
+        assertNotNull(WeakHashMap.newWeakHashMap(0));
+        assertNotNull(WeakHashMap.newWeakHashMap(10));
+    }
+
+    @Test
+    public void factoryMethod_invalidArgs() {
+        assertThrows(IllegalArgumentException.class, () -> WeakHashMap.newWeakHashMap(-10));
+    }
+
     private int threshold(WeakHashMap map) throws Exception {
         Field threshold = map.getClass().getDeclaredField("threshold");
         threshold.setAccessible(true);
diff --git a/luni/src/test/java/libcore/libcore/util/NativeAllocationRegistryTest.java b/luni/src/test/java/libcore/libcore/util/NativeAllocationRegistryTest.java
index 9190452de0e..4bc4139e27c 100644
--- a/luni/src/test/java/libcore/libcore/util/NativeAllocationRegistryTest.java
+++ b/luni/src/test/java/libcore/libcore/util/NativeAllocationRegistryTest.java
@@ -16,10 +16,15 @@
 
 package libcore.libcore.util;
 
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
+import java.util.Collection;
 import junit.framework.TestCase;
 
 import libcore.util.NativeAllocationRegistry;
 
+import org.junit.Ignore;
+
 public class NativeAllocationRegistryTest extends TestCase {
 
     static {
@@ -31,12 +36,18 @@ public class NativeAllocationRegistryTest extends TestCase {
     private static class TestConfig {
         public boolean treatAsMalloced;
         public boolean shareRegistry;
+        public boolean testMetrics;
 
-        public TestConfig(boolean treatAsMalloced, boolean shareRegistry) {
+        public TestConfig(boolean treatAsMalloced, boolean shareRegistry, boolean testMetrics) {
+            this.treatAsMalloced = treatAsMalloced;
             this.shareRegistry = shareRegistry;
+            this.testMetrics = testMetrics;
         }
     }
 
+    private static class TestClass {
+    }
+
     private static class Allocation {
         public byte[] javaAllocation;
         public long nativeAllocation;
@@ -77,10 +88,16 @@ public class NativeAllocationRegistryTest extends TestCase {
         for (int i = 0; i < numAllocationsToSimulate; i++) {
             if (!config.shareRegistry || registry == null) {
                 if (config.treatAsMalloced) {
-                    registry = NativeAllocationRegistry.createMalloced(
+                    registry = config.testMetrics
+                        ? NativeAllocationRegistry.createMalloced(
+                            TestClass.class, getNativeFinalizer(), nativeSize)
+                        : NativeAllocationRegistry.createMalloced(
                             classLoader, getNativeFinalizer(), nativeSize);
                 } else {
-                    registry = NativeAllocationRegistry.createNonmalloced(
+                    registry = config.testMetrics
+                        ? NativeAllocationRegistry.createNonmalloced(
+                            TestClass.class, getNativeFinalizer(), nativeSize)
+                        : NativeAllocationRegistry.createNonmalloced(
                             classLoader, getNativeFinalizer(), nativeSize);
                 }
             }
@@ -126,22 +143,70 @@ public class NativeAllocationRegistryTest extends TestCase {
         assertTrue("Too few native bytes still allocated (" + nativeBytes + "); "
                 + nativeReachableBytes + " bytes are reachable",
                 nativeBytes >= nativeReachableBytes);
+
+        if (config.testMetrics) {
+            Collection<NativeAllocationRegistry.Metrics> metrics =
+                NativeAllocationRegistry.getMetrics();
+
+            assertTrue("Expect at least 1 metrics, got "+ metrics.size() + "instead",
+                metrics.size() >= 1);
+
+            boolean hasTestClassMetrics = false;
+            for (NativeAllocationRegistry.Metrics m : metrics) {
+                if (m.getClassName().equals(TestClass.class.getName())) {
+                    final long count = config.treatAsMalloced ? m.getMallocedCount()
+                                                              : m.getNonmallocedCount();
+                    final long bytes = config.treatAsMalloced ? m.getMallocedBytes()
+                                                              : m.getNonmallocedBytes();
+
+                    assertTrue("Expect native allocations count to be at least " +
+                               numSavedAllocations + ", got " + count + " instead",
+                               count >= numSavedAllocations);
+                    assertTrue("Expect native allocations bytes to be at least " +
+                               nativeReachableBytes + ", got " + bytes + " instead",
+                               bytes >= nativeReachableBytes);
+
+                    hasTestClassMetrics = true;
+                }
+            }
+            assertTrue("No metrics for " + TestClass.class.getName(), hasTestClassMetrics);
+        }
     }
 
     public void testNativeAllocationNonmallocNoSharedRegistry() {
-        testNativeAllocation(new TestConfig(false, false));
+        testNativeAllocation(new TestConfig(false, false, false));
     }
 
     public void testNativeAllocationNonmallocSharedRegistry() {
-        testNativeAllocation(new TestConfig(false, true));
+        testNativeAllocation(new TestConfig(false, true, false));
     }
 
     public void testNativeAllocationMallocNoSharedRegistry() {
-        testNativeAllocation(new TestConfig(true, false));
+        testNativeAllocation(new TestConfig(true, false, false));
     }
 
     public void testNativeAllocationMallocSharedRegistry() {
-        testNativeAllocation(new TestConfig(true, true));
+        testNativeAllocation(new TestConfig(true, true, false));
+    }
+
+    @RequiresFlagsEnabled(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public void ignoreNativeAllocationNonmallocNoSharedRegistryWithMetrics() {
+        testNativeAllocation(new TestConfig(false, false, true));
+    }
+
+    @RequiresFlagsEnabled(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public void ignoreNativeAllocationNonmallocSharedRegistryWithMetrics() {
+        testNativeAllocation(new TestConfig(false, true, true));
+    }
+
+    @RequiresFlagsEnabled(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public void ignoreNativeAllocationMallocNoSharedRegistryWithMetrics() {
+        testNativeAllocation(new TestConfig(true, false, true));
+    }
+
+    @RequiresFlagsEnabled(com.android.libcore.Flags.FLAG_NATIVE_METRICS)
+    public void ignoreNativeAllocationMallocSharedRegistryWithMetrics() {
+        testNativeAllocation(new TestConfig(true, true, true));
     }
 
     public void testBadSize() {
diff --git a/luni/src/test/java/tests/com/android/org/bouncycastle/jce/provider/CertBlocklistTest.java b/luni/src/test/java/tests/com/android/org/bouncycastle/jce/provider/CertBlocklistTest.java
deleted file mode 100644
index 4aebdb15164..00000000000
--- a/luni/src/test/java/tests/com/android/org/bouncycastle/jce/provider/CertBlocklistTest.java
+++ /dev/null
@@ -1,438 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package tests.com.android.org.bouncycastle.jce.provider;
-
-import junit.framework.TestCase;
-
-import com.android.org.bouncycastle.jce.provider.CertBlocklist;
-import com.android.org.bouncycastle.util.encoders.Base64;
-import com.android.org.bouncycastle.util.encoders.Hex;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.PublicKey;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.HashSet;
-import java.util.Set;
-
-public class CertBlocklistTest extends TestCase {
-
-    private File tmpFile;
-
-    private Set<String> DEFAULT_PUBKEYS;
-    private Set<String> DEFAULT_SERIALS;
-
-    public static final String TEST_CERT = "" +
-                    "MIIDsjCCAxugAwIBAgIJAPLf2gS0zYGUMA0GCSqGSIb3DQEBBQUAMIGYMQswCQYDVQQGEwJVUzET" +
-                    "MBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEPMA0GA1UEChMGR29v" +
-                    "Z2xlMRAwDgYDVQQLEwd0ZXN0aW5nMRYwFAYDVQQDEw1HZXJlbXkgQ29uZHJhMSEwHwYJKoZIhvcN" +
-                    "AQkBFhJnY29uZHJhQGdvb2dsZS5jb20wHhcNMTIwNzE0MTc1MjIxWhcNMTIwODEzMTc1MjIxWjCB" +
-                    "mDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50YWluIFZp" +
-                    "ZXcxDzANBgNVBAoTBkdvb2dsZTEQMA4GA1UECxMHdGVzdGluZzEWMBQGA1UEAxMNR2VyZW15IENv" +
-                    "bmRyYTEhMB8GCSqGSIb3DQEJARYSZ2NvbmRyYUBnb29nbGUuY29tMIGfMA0GCSqGSIb3DQEBAQUA" +
-                    "A4GNADCBiQKBgQCjGGHATBYlmas+0sEECkno8LZ1KPglb/mfe6VpCT3GhSr+7br7NG/ZwGZnEhLq" +
-                    "E7YIH4fxltHmQC3Tz+jM1YN+kMaQgRRjo/LBCJdOKaMwUbkVynAH6OYsKevjrOPk8lfM5SFQzJMG" +
-                    "sA9+Tfopr5xg0BwZ1vA/+E3mE7Tr3M2UvwIDAQABo4IBADCB/TAdBgNVHQ4EFgQUhzkS9E6G+x8W" +
-                    "L4EsmRjDxu28tHUwgc0GA1UdIwSBxTCBwoAUhzkS9E6G+x8WL4EsmRjDxu28tHWhgZ6kgZswgZgx" +
-                    "CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3" +
-                    "MQ8wDQYDVQQKEwZHb29nbGUxEDAOBgNVBAsTB3Rlc3RpbmcxFjAUBgNVBAMTDUdlcmVteSBDb25k" +
-                    "cmExITAfBgkqhkiG9w0BCQEWEmdjb25kcmFAZ29vZ2xlLmNvbYIJAPLf2gS0zYGUMAwGA1UdEwQF" +
-                    "MAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAYiugFDmbDOQ2U/+mqNt7o8ftlEo9SJrns6O8uTtK6AvR" +
-                    "orDrR1AXTXkuxwLSbmVfedMGOZy7Awh7iZa8hw5x9XmUudfNxvmrKVEwGQY2DZ9PXbrnta/dwbhK" +
-                    "mWfoepESVbo7CKIhJp8gRW0h1Z55ETXD57aGJRvQS4pxkP8ANhM=";
-
-    public static final String TURKTRUST_1 = "" +
-                    "MIIFPTCCBCWgAwIBAgICCCcwDQYJKoZIhvcNAQEFBQAwgawxPTA7BgNVBAMMNFTDnFJLVFJVU1Qg" +
-                    "RWxla3Ryb25payBTdW51Y3UgU2VydGlmaWthc8SxIEhpem1ldGxlcmkxCzAJBgNVBAYTAlRSMV4w" +
-                    "XAYDVQQKDFVUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0gdmUgQmlsacWfaW0gR8O8dmVubGnE" +
-                    "n2kgSGl6bWV0bGVyaSBBLsWeLiAoYykgS2FzxLFtICAyMDA1MB4XDTExMDgwODA3MDc1MVoXDTIx" +
-                    "MDcwNjA3MDc1MVowbjELMAkGA1UEBhMCVFIxDzANBgNVBAgMBkFOS0FSQTEPMA0GA1UEBwwGQU5L" +
-                    "QVJBMQwwCgYDVQQKDANFR08xGDAWBgNVBAsMD0VHTyBCSUxHSSBJU0xFTTEVMBMGA1UEAwwMKi5F" +
-                    "R08uR09WLlRSMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv5zoj2Bpdl7R1M/zF6Qf" +
-                    "4su2F8vDqISKvuTuyJhNAHhFGHCsHjaixGMHspuz0l3V50kq/ECWbN8kKaeTrB112QOrWTU276iu" +
-                    "p1Gh+OlEOiR9vlQ4VAP00dWUjD6z9HQFCi8W3EsEtiiHiYOU9BcPpPkaUbECwP4nGVwR8aPwhB5P" +
-                    "GBJc98romdvciYkUpSOOwkuSRtooA7tRlLFu72QaNpXN1NueB36I3aajPk0YyiXy2w8XlgK7QI4P" +
-                    "SSBnSq+QblFocWVmLhF94je7py6lCnllrIFXpR3FWZLD5GcI6HKlBS78AQ+IMBLFHhsEVw5NQj90" +
-                    "chSZClfBWBZzIaV9RwIDAQABo4IBpDCCAaAwHwYDVR0jBBgwFoAUq042AzDS29UKaL6HpVBs/PZw" +
-                    "pSUwHQYDVR0OBBYEFGT7G4Y9uEryRIL5Vj3qJsD047M0MA4GA1UdDwEB/wQEAwIBBjBFBgNVHSAE" +
-                    "PjA8MDoGCWCGGAMAAwEBATAtMCsGCCsGAQUFBwIBFh9odHRwOi8vd3d3LnR1cmt0cnVzdC5jb20u" +
-                    "dHIvc3VlMA8GA1UdEwEB/wQFMAMBAf8wSQYDVR0fBEIwQDA+oDygOoY4aHR0cDovL3d3dy50dXJr" +
-                    "dHJ1c3QuY29tLnRyL3NpbC9UVVJLVFJVU1RfU1NMX1NJTF9zMi5jcmwwgaoGCCsGAQUFBwEBBIGd" +
-                    "MIGaMG4GCCsGAQUFBzAChmJodHRwOi8vd3d3LnR1cmt0cnVzdC5jb20udHIvc2VydGlmaWthbGFy" +
-                    "L1RVUktUUlVTVF9FbGVrdHJvbmlrX1N1bnVjdV9TZXJ0aWZpa2FzaV9IaXptZXRsZXJpX3MyLmNy" +
-                    "dDAoBggrBgEFBQcwAYYcaHR0cDovL29jc3AudHVya3RydXN0LmNvbS50cjANBgkqhkiG9w0BAQUF" +
-                    "AAOCAQEAj89QCCyoW0S20EcYDZAnvFLFmougK97Bt68iV1OM622+Cyeyf4Sz+1LBk1f9ni3fGT0Q" +
-                    "+RWZJYWq5YuSBiLVgk3NLcxnwe3wmnvErUgq1QDtAaNlBWMEMklOlWGfJ0eWaillUskJbDd4KwgZ" +
-                    "HDEj7g/jYEQqU1t0zoJdwM/zNsnLHkhwcWZ5PQnnbpff1Ct/1LH/8pdy2eRDmRmqniLUh8r2lZfJ" +
-                    "eudVZG6yIbxsqP3t2JCq5c2P1jDhAGF3g9DiskH0CzsRdbVpoWdr+PY1Xz/19G8XEpX9r+IBJhLd" +
-                    "bkpVo0Qh0A10mzFP/GUk5f/8nho2HvLaVMhWv1qKcF8IhQ==";
-
-    public static final String TURKTRUST_2 = "" +
-                    "MIID8DCCAtigAwIBAgICCGQwDQYJKoZIhvcNAQEFBQAwgawxPTA7BgNVBAMMNFTDnFJLVFJVU1Qg" +
-                    "RWxla3Ryb25payBTdW51Y3UgU2VydGlmaWthc8SxIEhpem1ldGxlcmkxCzAJBgNVBAYTAlRSMV4w" +
-                    "XAYDVQQKDFVUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0gdmUgQmlsacWfaW0gR8O8dmVubGnE" +
-                    "n2kgSGl6bWV0bGVyaSBBLsWeLiAoYykgS2FzxLFtICAyMDA1MB4XDTExMDgwODA3MDc1MVoXDTIx" +
-                    "MDgwNTA3MDc1MVowgaMxCzAJBgNVBAYTAlRSMRAwDgYDVQQIEwdMZWZrb3NhMRAwDgYDVQQHEwdM" +
-                    "ZWZrb3NhMRwwGgYDVQQKExNLS1RDIE1lcmtleiBCYW5rYXNpMSYwJAYDVQQDEx1lLWlzbGVtLmtr" +
-                    "dGNtZXJrZXpiYW5rYXNpLm9yZzEqMCgGCSqGSIb3DQEJARYbaWxldGlAa2t0Y21lcmtlemJhbmth" +
-                    "c2kub3JnMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw1hUpuRFY67NsZ6C9rzRAPCb" +
-                    "9RVpi4nZzJIA1TvIfr4hMPM0X5jseMf5GvgJQ+cBMZtooDd7BbZNy2z7O5A+8PYFaMDdokCENx2e" +
-                    "PIqAVuO6C5UAqM7J3n6RrhjOvqiw6dTQMbtXhjFao+YMuBVvRuuhGHBDK3Je64T/KLzcmAUlRJEu" +
-                    "y+ZMe7AatUaSDr/jy5DMA5xEYOdsnS5Zo30lRG+9vqbxb8CQi+E97sNjY+W4lEgJKQWMNh5rCxo4" +
-                    "Hinkm3CKyKX3PAS+DDVI3LQiCiIQUOMA2+1P5aTPTkpqlbjqhbWTWAPWOKCF9d83p3RMXOYt5Gah" +
-                    "S8rg5u6+toEC1QIDAQABoyMwITAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zANBgkq" +
-                    "hkiG9w0BAQUFAAOCAQEAwjWz5tsUvYORVW8KJSK/biHFrAnFotMtoTKEewRmnYaYjwXIr1IPaBqh" +
-                    "jkGGviLN2eOH/v97Uli6HC4lzhKHfMQUS9KF/f5nGcH8iQBy/gmFsfJQ1KDC6GNM4CfMGIzyxjYh" +
-                    "P0VzdUtKX3PAl5EqgMUcdqRDy6Ruz55+JkdvCL1nAC7xH+czJcZVwysTdGfLTCh6VtYPgIkeL6U8" +
-                    "3xQAyMuOHm72exJljYFqIsiNvGE0KufCqCuH1PD97IXMrLlwGmKKg5jP349lySBpJjm6RDqCTT+6" +
-                    "dUl2jkVbeNmco99Y7AOdtLsOdXBMCo5x8lK8zwQWFrzEms0joHXCpWfGWA==";
-
-    public static final String ANSSI = "" +
-                    "MIIDbDCCAlSgAwIBAgIDAx2nMA0GCSqGSIb3DQEBBQUAMEsxCzAJBgNVBAYTAkZSMQ4wDAYDVQQK" +
-                    "EwVER1RQRTEsMCoGA1UEAxMjQUMgREdUUEUgU2lnbmF0dXJlIEF1dGhlbnRpZmljYXRpb24wHhcN" +
-                    "MTMwNzE4MTAwNTI4WhcNMTQwNzE4MTAwNTI4WjA+MQswCQYDVQQGEwJGUjETMBEGA1UECgwKREcg" +
-                    "VHLDqXNvcjEaMBgGA1UEAwwRQUMgREcgVHLDqXNvciBTU0wwggEiMA0GCSqGSIb3DQEBAQUAA4IB" +
-                    "DwAwggEKAoIBAQDI0WFSUyY+MmtFkqFjTefoFyDgh9b1C/2YvSIvT8oCH62JWT5rpeTCZwaXbqWc" +
-                    "jaNfzggqaFsokqfhBif43HNHNtNJmvKE32VcuLB0SpsLR/1VeTd9F99C1JeHVa+nelumOHEfouX8" +
-                    "rRFrxNXNIYTVeiENT8Y2YqRb/XAril9g7i674uFzLiNR/t/N/F8Exujv9U8m8rmgud/+tG9WDRaD" +
-                    "Jwoj3ZFCOnL5qLnSUEcS6TzWpozLmC2JVO5GZKGGd7qC9FjdBkVilkbVIEGSrYvz2Uz2v5IGqMBI" +
-                    "QaFL/kSYWxGTaedTOk2drFEApp9AEPTfv1NwCWBfegsGQrHUROM3AgMBAAGjZjBkMBIGA1UdEwEB" +
-                    "/wQIMAYBAf8CAQQwHQYDVR0OBBYEFAAMW8lJqJW0DtAv5p3Mjogxvh9lMB8GA1UdIwQYMBaAFOnb" +
-                    "kI/9W5nkFTvwYlyn5A1Y6IeZMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOCAQEAtDfG" +
-                    "HkHOLW2d9fiMtwtkEwDauISJLJyCjoRmawzmQbIZXq7HaLliVfE0sdfKUm0iQ0im1/CpnJLPoTeK" +
-                    "yBHvNu1ubLc2m+9dabAYhF3pVdKC+gNaAzBXZ9Gt0p1CLk1lf8Hg+R10HN2IPCv7V/crz2Ga+c23" +
-                    "4P3pfwYW8+Nd7alGCuvqot6UYXOlheF7zWUkHn6z6tvY+9oMDHKSUAthhA/FB50JgJU89zyTv1eg" +
-                    "Y3ldKwvYBW3W3yNZdTHbPyNsPJdhqA55mDNsteE5YTp1PyySDb1MSVrbxDEruoH6ZE99Hob4Ih8A" +
-                    "mn7MHZatGClECgjXWFZ2Gxa7OUCaQpcH8g==";
-
-    public CertBlocklistTest() throws IOException {
-        tmpFile = File.createTempFile("test", "");
-        DEFAULT_PUBKEYS = getDefaultPubkeys();
-        DEFAULT_SERIALS = getDefaultSerials();
-        tmpFile.delete();
-    }
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        tmpFile = File.createTempFile("test", "");
-    }
-
-    @Override
-    public void tearDown() throws Exception {
-        try {
-            tmpFile.delete();
-        } finally {
-            super.tearDown();
-        }
-    }
-
-    private Set<String> getPubkeyBlocklist(String path) throws IOException {
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist(path, "");
-        // call readPubkeyBlocklist
-        Set<byte[]> arr = bl.pubkeyBlocklist;
-        // convert the results to a hashset of strings
-        Set<String> results = new HashSet<String>();
-        for (byte[] value: arr) {
-            results.add(new String(value));
-        }
-        return results;
-    }
-
-    private Set<String> getSerialBlocklist(String path) throws IOException {
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist("", path);
-        // call readPubkeyBlocklist
-        Set<BigInteger> arr = bl.serialBlocklist;
-        // convert the results to a hashset of strings
-        Set<String> results = new HashSet<String>();
-        for (BigInteger value: arr) {
-            results.add(value.toString(16));
-        }
-        return results;
-    }
-
-    private static String getHash(PublicKey publicKey) throws Exception {
-        byte[] encoded = publicKey.getEncoded();
-        MessageDigest digest = MessageDigest.getInstance("SHA1");
-        byte[] hexlifiedHash = Hex.encode(digest.digest(encoded));
-        return new String(hexlifiedHash);
-    }
-
-    private Set<String> getDefaultPubkeys() throws IOException {
-        return getPubkeyBlocklist("");
-    }
-
-    private Set<String> getDefaultSerials() throws IOException {
-        return getSerialBlocklist("");
-    }
-
-    private Set<String> getCurrentPubkeyBlocklist() throws IOException {
-        return getPubkeyBlocklist(tmpFile.getCanonicalPath());
-    }
-
-    private Set<String> getCurrentSerialBlocklist() throws IOException {
-        return getSerialBlocklist(tmpFile.getCanonicalPath());
-    }
-
-    private void blocklistToFile(String blocklist) throws IOException {
-        FileOutputStream out = new FileOutputStream(tmpFile);
-        out.write(blocklist.toString().getBytes());
-        out.close();
-    }
-
-    private void writeBlocklist(HashSet<String> values) throws IOException {
-        StringBuilder result = new StringBuilder();
-        // join the values into a string
-        for (String value : values) {
-            if (result.length() != 0) {
-                result.append(",");
-            }
-            result.append(value);
-        }
-        blocklistToFile(result.toString());
-    }
-
-    private static PublicKey createPublicKey(String cert) throws Exception {
-        byte[] derCert = Base64.decode(cert.getBytes());
-        InputStream istream = new ByteArrayInputStream(derCert);
-        CertificateFactory cf = CertificateFactory.getInstance("X.509");
-        return cf.generateCertificate(istream).getPublicKey();
-    }
-
-    private static BigInteger createSerialNumber(String cert) throws Exception {
-        byte[] derCert = Base64.decode(cert.getBytes());
-        InputStream istream = new ByteArrayInputStream(derCert);
-        CertificateFactory cf = CertificateFactory.getInstance("X.509");
-        X509Certificate xCert = (X509Certificate)cf.generateCertificate(istream);
-        return xCert.getSerialNumber();
-    }
-
-    public void testPubkeyBlocklistLegit() throws Exception {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091ccc");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default pubkeys into the bl
-        bl.addAll(DEFAULT_PUBKEYS);
-        // do the test
-        assertEquals(bl, getCurrentPubkeyBlocklist());
-    }
-
-    public void testLegitPubkeyIsntBlocklisted() throws Exception {
-        // build the public key
-        PublicKey pk = createPublicKey(TEST_CERT);
-        // write that to the test blocklist
-        writeBlocklist(new HashSet<String>());
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist(tmpFile.getCanonicalPath(), "");
-        // check to make sure it isn't blocklisted
-        assertEquals(bl.isPublicKeyBlockListed(pk), false);
-    }
-
-    public void testPubkeyIsBlocklisted() throws Exception {
-        // build the public key
-        PublicKey pk = createPublicKey(TEST_CERT);
-        // get its hash
-        String hash = getHash(pk);
-        // write that to the test blocklist
-        HashSet<String> testBlockList = new HashSet<String>();
-        testBlockList.add(hash);
-        writeBlocklist(testBlockList);
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist(tmpFile.getCanonicalPath(), "");
-        // check to make sure it isn't blocklited
-        assertTrue(bl.isPublicKeyBlockListed(pk));
-    }
-
-    public void testSerialBlocklistLegit() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("22e514121e61c643b1e9b06bd4b9f7d0");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default serials into the bl
-        bl.addAll(DEFAULT_SERIALS);
-        // do the test
-        assertEquals(bl, getCurrentSerialBlocklist());
-    }
-
-    public void testPubkeyBlocklistMultipleLegit() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091ccc");
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091ccd");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default pubkeys into the bl
-        bl.addAll(DEFAULT_PUBKEYS);
-        // do the test
-        assertEquals(bl, getCurrentPubkeyBlocklist());
-    }
-
-    public void testSerialBlocklistMultipleLegit() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("22e514121e61c643b1e9b06bd4b9f7d0");
-        bl.add("22e514121e61c643b1e9b06bd4b9f7d1");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default serials into the bl
-        bl.addAll(DEFAULT_SERIALS);
-        // do the test
-        assertEquals(bl, getCurrentSerialBlocklist());
-    }
-
-    public void testPubkeyBlocklistMultipleBad() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091ccc");
-        bl.add("");
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091ccd");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default pubkeys into the bl
-        bl.addAll(DEFAULT_PUBKEYS);
-        // remove the bad one
-        bl.remove("");
-        // do the test- results should be all but the bad one are handled
-        assertEquals(bl, getCurrentPubkeyBlocklist());
-    }
-
-    public void testSerialBlocklistMultipleBad() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("22e514121e61c643b1e9b06bd4b9f7d0");
-        bl.add("");
-        bl.add("22e514121e61c643b1e9b06bd4b9f7d1");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default serials into the bl
-        bl.addAll(DEFAULT_SERIALS);
-        // remove the bad one
-        bl.remove("");
-        // do the test- results should be all but the bad one are handled
-        assertEquals(bl, getCurrentSerialBlocklist());
-    }
-
-    public void testPubkeyBlocklistDoesntExist() throws IOException {
-        assertEquals(DEFAULT_PUBKEYS, getCurrentPubkeyBlocklist());
-    }
-
-    public void testSerialBlocklistDoesntExist() throws IOException {
-        assertEquals(DEFAULT_SERIALS, getCurrentSerialBlocklist());
-    }
-
-    public void testPubkeyBlocklistNotHexValues() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ");
-        // write the blocklist
-        writeBlocklist(bl);
-        // do the test
-        assertEquals(DEFAULT_PUBKEYS, getCurrentPubkeyBlocklist());
-    }
-
-    public void testSerialBlocklistNotHexValues() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ");
-        // write the blocklist
-        writeBlocklist(bl);
-        // do the test
-        assertEquals(DEFAULT_SERIALS, getCurrentSerialBlocklist());
-    }
-
-    public void testPubkeyBlocklistIncorrectLength() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("6ccabd7db47e94a5759901b6a7dfd45d1c091cc");
-        // write the blocklist
-        writeBlocklist(bl);
-        // do the test
-        assertEquals(DEFAULT_PUBKEYS, getCurrentPubkeyBlocklist());
-    }
-
-    public void testSerialBlocklistZero() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("0");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default serials
-        bl.addAll(DEFAULT_SERIALS);
-        // do the test
-        assertEquals(bl, getCurrentSerialBlocklist());
-    }
-
-    public void testSerialBlocklistNegative() throws IOException {
-        // build the blocklist
-        HashSet<String> bl = new HashSet<String>();
-        bl.add("-1");
-        // write the blocklist
-        writeBlocklist(bl);
-        // add the default serials
-        bl.addAll(DEFAULT_SERIALS);
-        // do the test
-        assertEquals(bl, getCurrentSerialBlocklist());
-    }
-
-    public void testTurkTrustIntermediate1PubkeyBlocklist() throws Exception {
-        // build the public key
-        PublicKey pk = createPublicKey(TURKTRUST_1);
-        // write that to the test blocklist
-        writeBlocklist(new HashSet<String>());
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist();
-        // check to make sure it isn't blocklisted
-        assertEquals(bl.isPublicKeyBlockListed(pk), true);
-    }
-
-    public void testTurkTrustIntermediate2PubkeyBlocklist() throws Exception {
-        // build the public key
-        PublicKey pk = createPublicKey(TURKTRUST_2);
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist();
-        // check to make sure it isn't blocklisted
-        assertEquals(bl.isPublicKeyBlockListed(pk), true);
-    }
-
-    public void testANSSIIntermediatePubkeyBlocklist() throws Exception {
-        // build the public key
-        PublicKey pk = createPublicKey(ANSSI);
-        // set our blocklist path
-        CertBlocklist bl = new CertBlocklist();
-        // check to make sure it isn't blocklisted
-        assertEquals(bl.isPublicKeyBlockListed(pk), true);
-    }
-
-    private static void printHash(String cert) throws Exception {
-        System.out.println("CERTIFICATE PUBLIC KEY HASH: " + getHash(createPublicKey(cert)));
-    }
-
-    private static void printSerial(String cert) throws Exception {
-        System.out.println("CERTIFICATE SERIAL NUMBER: " + createSerialNumber(cert).toString(16));
-    }
-}
diff --git a/luni/src/test/java17language/Android.bp b/luni/src/test/java17language/Android.bp
index bb5b25fc9eb..7da0c49979b 100644
--- a/luni/src/test/java17language/Android.bp
+++ b/luni/src/test/java17language/Android.bp
@@ -41,7 +41,7 @@ java_library {
 
 // Generate a clone of Java17LanguageFeaturesTest which uses a version of
 // Java17LanguageFeatures repackaged by jarjar. This ensures that jarjar is able
-// to handle a class file which must be at least v55 and includes bytecode
+// to handle a class file which must be at least v61 and includes bytecode
 // compiled from Java 17 language features.
 filegroup {
     name: "core-rewrite-java-17-test-for-jarjar-sed-script",
diff --git a/luni/src/test/java21language/Android.bp b/luni/src/test/java21language/Android.bp
new file mode 100644
index 00000000000..a1f0af2c5bf
--- /dev/null
+++ b/luni/src/test/java21language/Android.bp
@@ -0,0 +1,84 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Android tests related to Java 21 language features.
+
+// Use jarjar to repackage Java21LanguageFeatures, to be used in tests below.
+package {
+    default_team: "trendy_team_java_core_libraries",
+    // http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // the below license kinds from "libcore_luni_license":
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["libcore_luni_license"],
+}
+
+java_library {
+    name: "core-java-21-language-features-repackaged-for-test",
+    hostdex: true,
+
+    srcs: [":core-java-21-language-features-source"],
+    jarjar_rules: "jarjar_rules_java21_language_features.txt",
+    java_version: "21",
+
+    sdk_version: "none",
+    system_modules: "core-all-system-modules",
+    patch_module: "java.base",
+
+    visibility: ["//visibility:private"],
+}
+
+// Generate a clone of Java21LanguageFeaturesTest which uses a version of
+// Java21LanguageFeatures repackaged by jarjar. This ensures that jarjar is able
+// to handle a class file which must be at least v65 and includes bytecode
+// compiled from Java 21 language features.
+filegroup {
+    name: "core-rewrite-java-21-test-for-jarjar-sed-script",
+    srcs: ["rewrite-test-for-jarjar.sed"],
+    visibility: ["//visibility:private"],
+}
+
+filegroup {
+    name: "core-java-21-language-features-test-src",
+    srcs: ["java/libcore/libcore/internal/Java21LanguageFeaturesTest.java"],
+    visibility: ["//visibility:private"],
+}
+
+genrule {
+    name: "core-gen-test-repackaged-java-21-language-features",
+    srcs: [
+        ":core-rewrite-java-21-test-for-jarjar-sed-script",
+        ":core-java-21-language-features-test-src",
+    ],
+    out: ["libcore/libcore/internal/Java21LanguageFeaturesJarjarTest.java"],
+    cmd: "sed -r -f $(location :core-rewrite-java-21-test-for-jarjar-sed-script) $(location :core-java-21-language-features-test-src) > $(out)",
+    visibility: ["//visibility:private"],
+}
+
+java_library {
+    name: "core-java-21-language-tests",
+    hostdex: true,
+    srcs: [
+        "java/**/*.java",
+        ":core-gen-test-repackaged-java-21-language-features",
+    ],
+    sdk_version: "none",
+    system_modules: "core-all-system-modules",
+    static_libs: [
+        "core-java-21-language-features-repackaged-for-test",
+        "junit",
+    ],
+    visibility: ["//libcore"],
+    java_version: "21",
+}
diff --git a/luni/src/test/java21language/jarjar_rules_java21_language_features.txt b/luni/src/test/java21language/jarjar_rules_java21_language_features.txt
new file mode 100644
index 00000000000..dee72bc8dc2
--- /dev/null
+++ b/luni/src/test/java21language/jarjar_rules_java21_language_features.txt
@@ -0,0 +1 @@
+rule libcore.internal.** libcore.internal.repackaged.@1
diff --git a/luni/src/test/java21language/java/libcore/libcore/internal/Java21LanguageFeaturesTest.java b/luni/src/test/java21language/java/libcore/libcore/internal/Java21LanguageFeaturesTest.java
new file mode 100644
index 00000000000..5e591b60ce2
--- /dev/null
+++ b/luni/src/test/java21language/java/libcore/libcore/internal/Java21LanguageFeaturesTest.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package libcore.libcore.internal;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Arrays;
+import libcore.internal.Java21LanguageFeatures;
+
+import org.junit.Test;
+import org.junit.Ignore;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class Java21LanguageFeaturesTest {
+
+    @Test
+    public void testPatternMatchingSwitch() {
+        Java21LanguageFeatures.Shape s = new Java21LanguageFeatures.Triangle(6, 10);
+        assertEquals(30, Java21LanguageFeatures.calculateApproximateArea(s));
+
+        s = new Java21LanguageFeatures.Rectangle(4, 5);
+        assertEquals(20, Java21LanguageFeatures.calculateApproximateArea(s));
+
+        s = new Java21LanguageFeatures.Circle(5);
+        assertEquals(75, Java21LanguageFeatures.calculateApproximateArea(s));
+
+        s = new Blob();
+        assertEquals(0, Java21LanguageFeatures.calculateApproximateArea(s));
+    }
+
+    private static class Blob extends Java21LanguageFeatures.Shape {
+    }
+
+    @Test
+    public void testPatternMatchingSwitchWithNull() {
+        assertEquals("404", Java21LanguageFeatures.isDroid(null));
+        assertEquals("Yes", Java21LanguageFeatures.isDroid("Android"));
+        assertEquals("Yes", Java21LanguageFeatures.isDroid("Marvin"));
+        assertEquals("No", Java21LanguageFeatures.isDroid("Snoopy"));
+    }
+
+    @Test
+    public void testPatternMatchingSwitchCaseRefinement() {
+        assertEquals("404", Java21LanguageFeatures.isDroidIgnoreCase(null));
+        assertEquals("Yes", Java21LanguageFeatures.isDroidIgnoreCase("Android"));
+        assertEquals("Yes", Java21LanguageFeatures.isDroidIgnoreCase("MARVIN"));
+        assertEquals("No", Java21LanguageFeatures.isDroidIgnoreCase("Snoopy"));
+    }
+
+    @Test
+    public void testPatternMatchingSwitchWithEnum() {
+        assertFalse(Java21LanguageFeatures.hasManySides(
+                Java21LanguageFeatures.PointyShapeType.TRIANGLE));
+        assertTrue(Java21LanguageFeatures.hasManySides(
+                Java21LanguageFeatures.PointyShapeType.RECTANGLE));
+        assertFalse(Java21LanguageFeatures.hasManySides(
+                Java21LanguageFeatures.RoundedShapeType.CIRCLE));
+    }
+
+    @Test
+    public void testRecordPatterns() {
+        assertEquals(5, Java21LanguageFeatures.getX(new Java21LanguageFeatures.Point(5, 10)));
+        assertEquals(0, Java21LanguageFeatures.getX(Integer.valueOf(5)));
+    }
+
+    @Test
+    public void testRecordPatternsWithTypeInference() {
+        assertEquals(10, Java21LanguageFeatures.getY(new Java21LanguageFeatures.Point(5, 10)));
+        assertEquals(0, Java21LanguageFeatures.getY(Integer.valueOf(10)));
+    }
+
+    @Test
+    public void testNestedRecordPatterns() {
+        final var pointOne = new Java21LanguageFeatures.Point(5, 10);
+        final var pointTwo = new Java21LanguageFeatures.Point(5, 20);
+        final var pointThree = new Java21LanguageFeatures.Point(10, 20);
+
+        var line = new Java21LanguageFeatures.Line(pointOne, pointTwo);
+        assertTrue(Java21LanguageFeatures.isLineVertical(line));
+
+        line = new Java21LanguageFeatures.Line(pointOne, pointThree);
+        assertFalse(Java21LanguageFeatures.isLineVertical(line));
+
+        assertFalse(Java21LanguageFeatures.isLineVertical(Integer.valueOf(5)));
+    }
+
+    @Test
+    public void testSwitchRecordPatterns() {
+        final var five = new Java21LanguageFeatures.PairableInt(5);
+        final var ten = new Java21LanguageFeatures.PairableInt(10);
+        final var str = new Java21LanguageFeatures.PairableString("5");
+
+        var pair = new Java21LanguageFeatures.Pair(five, ten);
+        assertFalse(Java21LanguageFeatures.isFirstItemLarger(pair));
+
+        pair = new Java21LanguageFeatures.Pair(ten, five);
+        assertTrue(Java21LanguageFeatures.isFirstItemLarger(pair));
+
+        pair = new Java21LanguageFeatures.Pair(str, five);
+        assertFalse(Java21LanguageFeatures.isFirstItemLarger(pair));
+
+        pair = new Java21LanguageFeatures.Pair(five, str);
+        assertFalse(Java21LanguageFeatures.isFirstItemLarger(pair));
+    }
+
+    @Test
+    public void testSwitchRecordPatternsTypeInference() {
+        var pair = new Java21LanguageFeatures.AnyPair<Integer, Integer>(
+                Integer.valueOf(2), Integer.valueOf(3));
+        assertEquals(5, Java21LanguageFeatures.sumOfMembers(pair));
+    }
+
+    @Test
+    public void testComplexSwitchPatterns() {
+        Java21LanguageFeatures.Blob blob;
+        Object result;
+
+        blob = Java21LanguageFeatures.SquishyBlob.SMALL;
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Java21LanguageFeatures.SquishyBlob.SMALL, result);
+
+        blob = Java21LanguageFeatures.SquishyBlob.MEDIUM;
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Java21LanguageFeatures.SquishyBlob.MEDIUM, result);
+
+        blob = Java21LanguageFeatures.SquishyBlob.LARGE;
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Java21LanguageFeatures.SquishyBlob.LARGE, result);
+
+        blob = new Java21LanguageFeatures.MultiBlob(Java21LanguageFeatures.RoundedShapeType.CIRCLE,
+                Java21LanguageFeatures.Color.RED, Integer.valueOf(5));
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Java21LanguageFeatures.RoundedShapeType.CIRCLE, result);
+
+        blob = new Java21LanguageFeatures.MultiBlob(Java21LanguageFeatures.PointyShapeType.TRIANGLE,
+                Java21LanguageFeatures.Color.RED, Integer.valueOf(5));
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Java21LanguageFeatures.Color.RED, result);
+
+        blob = new Java21LanguageFeatures.MultiBlob(Java21LanguageFeatures.PointyShapeType.TRIANGLE,
+                Java21LanguageFeatures.Color.BLUE, Integer.valueOf(5));
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Integer.valueOf(5), result);
+
+        blob = new Java21LanguageFeatures.MultiBlob(Java21LanguageFeatures.PointyShapeType.TRIANGLE,
+                Java21LanguageFeatures.Color.BLUE, Integer.valueOf(10));
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Integer.valueOf(10), result);
+
+        blob = new Java21LanguageFeatures.GeometricBlob(20);
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Integer.valueOf(20), result);
+
+        blob = new Java21LanguageFeatures.GeometricBlob(2000);
+        result = Java21LanguageFeatures.getMainCharacteristic(blob);
+        assertEquals(Integer.valueOf(1000), result);
+    }
+}
diff --git a/luni/src/test/java21language/rewrite-test-for-jarjar.sed b/luni/src/test/java21language/rewrite-test-for-jarjar.sed
new file mode 100644
index 00000000000..a6f6b222203
--- /dev/null
+++ b/luni/src/test/java21language/rewrite-test-for-jarjar.sed
@@ -0,0 +1,21 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# This is a sed script that modifies Java source code in two ways.
+
+# Replace libcore.internal with libcore.internal.repackaged in imports:
+s/import libcore.internal/import libcore.internal.repackaged/
+
+# Replace Test with JarjarTest in class declarations.
+s/class ([A-Za-z0-9_]+)Test/class \1JarjarTest/
diff --git a/mmodules/intracoreapi/Android.bp b/mmodules/intracoreapi/Android.bp
index 09a9ff48f58..be0f388354e 100644
--- a/mmodules/intracoreapi/Android.bp
+++ b/mmodules/intracoreapi/Android.bp
@@ -82,6 +82,12 @@ java_sdk_library {
 
     // Don't copy any output files to the dist.
     no_dist: true,
+
+    // This module's output stubs contain apis defined in "art.module.public.api.stubs",
+    // but adding "art.module.public.api" as a dependency of this module leads to circular
+    // dependency and requires further bootstrapping. Thus, disable stubs generation from the
+    // api signature files and generate stubs from the source Java files instead.
+    build_from_text_stub: false,
 }
 
 // Bootstrap the art-module-intra-core-api-stubs-system-modules.
@@ -110,7 +116,7 @@ java_library {
         ":openjdk_lambda_stub_files",
     ],
     libs: [
-        "art.module.intra.core.api",
+        "art.module.intra.core.api.stubs",
     ],
     system_modules: "art-module-intra-core-api-stubs-bootstrap-system-modules",
     sdk_version: "none",
diff --git a/mmodules/intracoreapi/api/intra/current.txt b/mmodules/intracoreapi/api/intra/current.txt
index 02e11bda421..80ecce3ecfa 100644
--- a/mmodules/intracoreapi/api/intra/current.txt
+++ b/mmodules/intracoreapi/api/intra/current.txt
@@ -137,7 +137,7 @@ package libcore.net {
 package libcore.util {
 
   @libcore.api.IntraCoreApi public class NativeAllocationRegistry {
-    method @libcore.api.IntraCoreApi public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long);
+    method @NonNull @libcore.api.IntraCoreApi public static libcore.util.NativeAllocationRegistry createMalloced(@NonNull ClassLoader, long);
     method @NonNull @libcore.api.IntraCoreApi public Runnable registerNativeAllocation(@NonNull Object, long);
   }
 
diff --git a/non_openjdk_java_files.bp b/non_openjdk_java_files.bp
index bfe5ad8bad6..3f6bb4138d1 100644
--- a/non_openjdk_java_files.bp
+++ b/non_openjdk_java_files.bp
@@ -366,6 +366,7 @@ filegroup {
         "luni/src/main/java/libcore/icu/CollationKeyICU.java",
         "luni/src/main/java/libcore/internal/Java11LanguageFeatures.java",
         "luni/src/main/java/libcore/internal/Java17LanguageFeatures.java",
+        "luni/src/main/java/libcore/internal/Java21LanguageFeatures.java",
         "luni/src/main/java/libcore/internal/Java9LanguageFeatures.java",
         "luni/src/main/java/libcore/internal/StringPool.java",
         "luni/src/main/java/libcore/io/ClassPathURLStreamHandler.java",
diff --git a/ojluni/annotations/flagged_api/java/util/IdentityHashMap.annotated.java b/ojluni/annotations/flagged_api/java/util/IdentityHashMap.annotated.java
new file mode 100644
index 00000000000..e1bf6218ae2
--- /dev/null
+++ b/ojluni/annotations/flagged_api/java/util/IdentityHashMap.annotated.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2000, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package java.util;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public class IdentityHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable, java.util.Map<K,V>, java.io.Serializable {
+
+public IdentityHashMap() { throw new RuntimeException("Stub!"); }
+
+public IdentityHashMap(int expectedMaxSize) { throw new RuntimeException("Stub!"); }
+
+public IdentityHashMap(java.util.Map<? extends K,? extends V> m) { throw new RuntimeException("Stub!"); }
+
+public int size() { throw new RuntimeException("Stub!"); }
+
+public boolean isEmpty() { throw new RuntimeException("Stub!"); }
+
+public V get(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public boolean containsKey(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public boolean containsValue(java.lang.Object value) { throw new RuntimeException("Stub!"); }
+
+public V put(K key, V value) { throw new RuntimeException("Stub!"); }
+
+public void putAll(java.util.Map<? extends K,? extends V> m) { throw new RuntimeException("Stub!"); }
+
+public V remove(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public void clear() { throw new RuntimeException("Stub!"); }
+
+public boolean equals(java.lang.Object o) { throw new RuntimeException("Stub!"); }
+
+public int hashCode() { throw new RuntimeException("Stub!"); }
+
+public java.lang.Object clone() { throw new RuntimeException("Stub!"); }
+
+public java.util.Set<K> keySet() { throw new RuntimeException("Stub!"); }
+
+public java.util.Collection<V> values() { throw new RuntimeException("Stub!"); }
+
+public java.util.Set<java.util.Map.Entry<K,V>> entrySet() { throw new RuntimeException("Stub!"); }
+
+public void forEach(java.util.function.BiConsumer<? super K,? super V> action) { throw new RuntimeException("Stub!"); }
+
+public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V> function) { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V1_APIS)
+public boolean remove(java.lang.Object key, java.lang.Object value) { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V1_APIS)
+public boolean replace(K key, V oldValue, V newValue) { throw new RuntimeException("Stub!"); }
+}
+
diff --git a/ojluni/annotations/flagged_api/java/util/WeakHashMap.annotated.java b/ojluni/annotations/flagged_api/java/util/WeakHashMap.annotated.java
new file mode 100644
index 00000000000..16d95ff2171
--- /dev/null
+++ b/ojluni/annotations/flagged_api/java/util/WeakHashMap.annotated.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package java.util;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public class WeakHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {
+
+public WeakHashMap(int initialCapacity, float loadFactor) { throw new RuntimeException("Stub!"); }
+
+public WeakHashMap(int initialCapacity) { throw new RuntimeException("Stub!"); }
+
+public WeakHashMap() { throw new RuntimeException("Stub!"); }
+
+public WeakHashMap(java.util.Map<? extends K,? extends V> m) { throw new RuntimeException("Stub!"); }
+
+public int size() { throw new RuntimeException("Stub!"); }
+
+public boolean isEmpty() { throw new RuntimeException("Stub!"); }
+
+public V get(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public boolean containsKey(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public V put(K key, V value) { throw new RuntimeException("Stub!"); }
+
+public void putAll(java.util.Map<? extends K,? extends V> m) { throw new RuntimeException("Stub!"); }
+
+public V remove(java.lang.Object key) { throw new RuntimeException("Stub!"); }
+
+public void clear() { throw new RuntimeException("Stub!"); }
+
+public boolean containsValue(java.lang.Object value) { throw new RuntimeException("Stub!"); }
+
+public java.util.Set<K> keySet() { throw new RuntimeException("Stub!"); }
+
+public java.util.Collection<V> values() { throw new RuntimeException("Stub!"); }
+
+public java.util.Set<java.util.Map.Entry<K,V>> entrySet() { throw new RuntimeException("Stub!"); }
+
+public void forEach(java.util.function.BiConsumer<? super K,? super V> action) { throw new RuntimeException("Stub!"); }
+
+public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V> function) { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V1_APIS)
+public static <K, V> java.util.WeakHashMap<K,V> newWeakHashMap(int numMappings) { throw new RuntimeException("Stub!"); }
+}
+
diff --git a/ojluni/annotations/flagged_toolchainapi/java/lang/invoke/SerializedLambda.annotated.java b/ojluni/annotations/flagged_toolchainapi/java/lang/invoke/SerializedLambda.annotated.java
new file mode 100644
index 00000000000..55c1389f2ce
--- /dev/null
+++ b/ojluni/annotations/flagged_toolchainapi/java/lang/invoke/SerializedLambda.annotated.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang.invoke;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public final class SerializedLambda implements java.io.Serializable {
+
+    public SerializedLambda(java.lang.Class<?> capturingClass,
+            java.lang.String functionalInterfaceClass,
+            java.lang.String functionalInterfaceMethodName,
+            java.lang.String functionalInterfaceMethodSignature,
+            int implMethodKind,
+            java.lang.String implClass,
+            java.lang.String implMethodName,
+            java.lang.String implMethodSignature,
+            java.lang.String instantiatedMethodType,
+            java.lang.Object[] capturedArgs) { }
+
+    public java.lang.String getCapturingClass() { return null; }
+
+    public java.lang.String getFunctionalInterfaceClass() {
+        return null;
+    }
+
+    public java.lang.String getFunctionalInterfaceMethodName() {
+        return null;
+    }
+
+    public java.lang.String getFunctionalInterfaceMethodSignature() { return null; }
+
+    public java.lang.String getImplClass() {
+        return null;
+    }
+
+    public java.lang.String getImplMethodName() {
+        return null;
+    }
+
+    public java.lang.String getImplMethodSignature() {
+        return null;
+    }
+
+    public int getImplMethodKind() {
+        return 0;
+    }
+
+    public final java.lang.String getInstantiatedMethodType() {
+        return null;
+    }
+
+    public int getCapturedArgCount() {
+        return 0;
+    }
+
+    public java.lang.Object getCapturedArg(int i) {
+        return null;
+    }
+
+}
diff --git a/ojluni/annotations/sdk/nullability/java/util/WeakHashMap.annotated.java b/ojluni/annotations/sdk/nullability/java/util/WeakHashMap.annotated.java
index 83ae1cb64a1..ba9188266bb 100644
--- a/ojluni/annotations/sdk/nullability/java/util/WeakHashMap.annotated.java
+++ b/ojluni/annotations/sdk/nullability/java/util/WeakHashMap.annotated.java
@@ -67,4 +67,6 @@ public boolean containsValue(@libcore.util.Nullable java.lang.Object value) { th
 public void forEach(@libcore.util.NonNull java.util.function.BiConsumer<? super @libcore.util.NullFromTypeParam K,? super @libcore.util.NullFromTypeParam V> action) { throw new RuntimeException("Stub!"); }
 
 public void replaceAll(@libcore.util.NonNull java.util.function.BiFunction<? super @libcore.util.NullFromTypeParam K,? super @libcore.util.NullFromTypeParam V,? extends @libcore.util.NullFromTypeParam V> function) { throw new RuntimeException("Stub!"); }
+
+@libcore.util.NonNull public static <K, V> java.util.WeakHashMap<K,V> newWeakHashMap(int numMappings) { throw new RuntimeException("Stub!"); }
 }
diff --git a/ojluni/src/main/java/java/awt/font/TEST_MAPPING b/ojluni/src/main/java/java/awt/font/TEST_MAPPING
index 76ff4049ee8..af229c78431 100644
--- a/ojluni/src/main/java/java/awt/font/TEST_MAPPING
+++ b/ojluni/src/main/java/java/awt/font/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.awt.font"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_awt_font"
     },
     {
       "name": "CtsLibcoreOjTestCases_awt_font"
diff --git a/ojluni/src/main/java/java/beans/TEST_MAPPING b/ojluni/src/main/java/java/beans/TEST_MAPPING
index 0e669a8e6df..1bdcc54fccb 100644
--- a/ojluni/src/main/java/java/beans/TEST_MAPPING
+++ b/ojluni/src/main/java/java/beans/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.beans.tests.java.beans"
-        },
-        {
-          "include-filter": "libcore.java.util.beans"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_beans"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/io/TEST_MAPPING b/ojluni/src/main/java/java/io/TEST_MAPPING
index 6eb3bd74deb..eee1e49cda8 100644
--- a/ojluni/src/main/java/java/io/TEST_MAPPING
+++ b/ojluni/src/main/java/java/io/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.io"
-        },
-        {
-          "include-filter": "org.apache.harmony.luni.tests.java.io"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.io"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_java_io"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/lang/AbstractStringBuilder.java b/ojluni/src/main/java/java/lang/AbstractStringBuilder.java
index b00e6138c41..228831fd9e0 100644
--- a/ojluni/src/main/java/java/lang/AbstractStringBuilder.java
+++ b/ojluni/src/main/java/java/lang/AbstractStringBuilder.java
@@ -33,8 +33,8 @@ import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
 
 import static java.lang.String.COMPACT_STRINGS;
-import static java.lang.String.UTF16;
-import static java.lang.String.LATIN1;
+import static java.lang.String.CODER_UTF16;
+import static java.lang.String.CODER_LATIN1;
 import static java.lang.String.checkIndex;
 import static java.lang.String.checkOffset;
 
@@ -86,10 +86,10 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
     AbstractStringBuilder(int capacity) {
         if (COMPACT_STRINGS) {
             value = new byte[capacity];
-            coder = LATIN1;
+            coder = CODER_LATIN1;
         } else {
             value = StringUTF16.newBytesFor(capacity);
-            coder = UTF16;
+            coder = CODER_UTF16;
         }
     }
 
@@ -233,7 +233,7 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
         byte[] buf = StringUTF16.newBytesFor(value.length);
         StringLatin1.inflate(value, 0, buf, 0, count);
         this.value = buf;
-        this.coder = UTF16;
+        this.coder = CODER_UTF16;
     }
 
     /**
@@ -1512,7 +1512,7 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
         int count = this.count;
         int coder = this.coder;
         int n = count - 1;
-        if (COMPACT_STRINGS && coder == LATIN1) {
+        if (COMPACT_STRINGS && coder == CODER_LATIN1) {
             for (int j = (n-1) >> 1; j >= 0; j--) {
                 int k = n - j;
                 byte cj = val[j];
@@ -1554,7 +1554,7 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
                     byte[] val = this.value;
                     int count = this.count;
                     byte coder = this.coder;
-                    return coder == LATIN1
+                    return coder == CODER_LATIN1
                            ? new StringLatin1.CharsSpliterator(val, 0, count, 0)
                            : new StringUTF16.CharsSpliterator(val, 0, count, 0);
                 },
@@ -1578,7 +1578,7 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
                     byte[] val = this.value;
                     int count = this.count;
                     byte coder = this.coder;
-                    return coder == LATIN1
+                    return coder == CODER_LATIN1
                            ? new StringLatin1.CharsSpliterator(val, 0, count, 0)
                            : new StringUTF16.CodePointsSpliterator(val, 0, count, 0);
                 },
@@ -1613,20 +1613,24 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
         if (String.COMPACT_STRINGS) {
             this.value = StringUTF16.compress(value, off, len);
             if (this.value != null) {
-                this.coder = LATIN1;
+                this.coder = CODER_LATIN1;
                 return;
             }
         }
-        this.coder = UTF16;
+        this.coder = CODER_UTF16;
         this.value = StringUTF16.toBytes(value, off, len);
     }
 
+    /**
+     * Be careful the behavior difference from {@link String#coder()}. See
+     * {@link String#CODER_LATIN1} for details.
+     */
     final byte getCoder() {
-        return COMPACT_STRINGS ? coder : UTF16;
+        return COMPACT_STRINGS ? coder : CODER_UTF16;
     }
 
     final boolean isLatin1() {
-        return COMPACT_STRINGS && coder == LATIN1;
+        return COMPACT_STRINGS && coder == CODER_LATIN1;
     }
 
     private final void putCharsAt(int index, char[] s, int off, int end) {
@@ -1669,7 +1673,7 @@ abstract class AbstractStringBuilder implements Appendable, CharSequence {
         if (getCoder() != str.coder()) {
             inflate();
         }
-        str.getBytes(value, index, coder);
+        str.fillBytes(value, index, coder);
     }
 
     private final void appendChars(char[] s, int off, int end) {
diff --git a/ojluni/src/main/java/java/lang/BaseVirtualThread.java b/ojluni/src/main/java/java/lang/BaseVirtualThread.java
new file mode 100644
index 00000000000..897a0d11cbf
--- /dev/null
+++ b/ojluni/src/main/java/java/lang/BaseVirtualThread.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang;
+
+/**
+ * Base class for virtual thread implementations.
+ */
+// Android-changed: TODO(b/346542404): Import the permitted subclasses.
+/* sealed */ abstract class BaseVirtualThread extends Thread {
+        // permits VirtualThread, ThreadBuilders.BoundVirtualThread {
+
+    /**
+     * Initializes a virtual Thread.
+     *
+     * @param name thread name, can be null
+     * @param characteristics thread characteristics
+     * @param bound true when bound to an OS thread
+     */
+    BaseVirtualThread(String name, int characteristics, boolean bound) {
+        super(name, characteristics, bound);
+    }
+
+    /**
+     * Parks the current virtual thread until the parking permit is available or
+     * the thread is interrupted.
+     *
+     * The behavior of this method when the current thread is not this thread
+     * is not defined.
+     */
+    abstract void park();
+
+    /**
+     * Parks current virtual thread up to the given waiting time until the parking
+     * permit is available or the thread is interrupted.
+     *
+     * The behavior of this method when the current thread is not this thread
+     * is not defined.
+     */
+    abstract void parkNanos(long nanos);
+
+    /**
+     * Makes available the parking permit to the given this virtual thread.
+     */
+    abstract void unpark();
+}
+
diff --git a/ojluni/src/main/java/java/lang/ClassLoader.java b/ojluni/src/main/java/java/lang/ClassLoader.java
index 036af5332f2..685328925f4 100644
--- a/ojluni/src/main/java/java/lang/ClassLoader.java
+++ b/ojluni/src/main/java/java/lang/ClassLoader.java
@@ -2673,15 +2673,20 @@ public abstract class ClassLoader {
 
 class BootClassLoader extends ClassLoader {
 
-    private static BootClassLoader instance;
+    private static volatile BootClassLoader instance;
 
     @FindBugsSuppressWarnings("DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED")
-    public static synchronized BootClassLoader getInstance() {
-        if (instance == null) {
-            instance = new BootClassLoader();
+    public static BootClassLoader getInstance() {
+        BootClassLoader myInstance = instance;
+        if (myInstance == null) {
+            synchronized(BootClassLoader.class) {
+                if (instance == null) {
+                    instance = myInstance = new BootClassLoader();
+                }
+            }
         }
 
-        return instance;
+        return myInstance;
     }
 
     public BootClassLoader() {
diff --git a/ojluni/src/main/java/java/lang/MatchException.java b/ojluni/src/main/java/java/lang/MatchException.java
new file mode 100644
index 00000000000..14fcb1f6817
--- /dev/null
+++ b/ojluni/src/main/java/java/lang/MatchException.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang;
+
+/**
+ * Thrown to indicate an unexpected failure in pattern matching.
+ *
+ * <p>{@code MatchException} may be thrown when an exhaustive pattern matching
+ * language construct (such as a {@code switch} expression) encounters a value
+ * that does not match any of the specified patterns at run time, even though
+ * the construct has been deemed exhaustive. This is intentional and can arise
+ * from a number of cases:
+ *
+ * <ul>
+ *     <li>Separate compilation anomalies, where parts of the type hierarchy that
+ *         the patterns reference have been changed, but the pattern matching
+ *         construct has not been recompiled. For example, if a sealed interface
+ *         has a different set of permitted subtypes at run time than it had at
+ *         compile time, or if an enum class has a different set of enum constants
+ *         at runtime than it had at compile time, or if the type hierarchy has
+ *         been changed in some incompatible way between compile time and run time.</li>
+ *
+ *     <li>{@code null} values and nested patterns involving sealed classes. If,
+ *         for example, an interface {@code I} is {@code sealed} with two permitted
+ *         subclasses {@code A} and {@code B}, and a record class {@code R} has a
+ *         single component of type {@code I}, then the two record patterns {@code
+ *         R(A a)} and {@code R(B b)} together are considered to be exhaustive for
+ *         the type {@code R}, but neither of these patterns will match against the
+ *         result of {@code new R(null)}.</li>
+ *
+ *     <li>{@code null} values and nested record patterns. Given a record class
+ *         {@code S} with a single component of type {@code T}, where {@code T} is
+ *         another record class with a single component of type {@code String},
+ *         then the nested record pattern {@code R(S(var s))} is considered
+ *         exhaustive for the type {@code R} but it does not match against the
+ *         result of {@code new R(null)} (whereas it does match against the result
+ *         of {@code new R(new S(null))} does).</li>
+ * </ul>
+ *
+ * <p>{@code MatchException} may also be thrown by the process of pattern matching
+ * a value against a pattern. For example, pattern matching involving a record
+ * pattern may require accessor methods to be implicitly invoked in order to
+ * extract the component values. If any of these accessor methods throws an
+ * exception, pattern matching completes abruptly and throws {@code
+ * MatchException}. The original exception will be set as a {@link
+ * Throwable#getCause() cause} of the {@code MatchException}. No {@link
+ * Throwable#addSuppressed(java.lang.Throwable) suppressed} exceptions will be
+ * recorded.
+ *
+ * @jls 14.11.3 Execution of a {@code switch} Statement
+ * @jls 14.30.2 Pattern Matching
+ * @jls 15.28.2 Run-Time Evaluation of {@code switch} Expressions
+ *
+ * @since 21
+ *
+ * @hide
+ */
+public final class MatchException extends RuntimeException {
+    @java.io.Serial
+    private static final long serialVersionUID = 0L;
+
+    /**
+     * Constructs an {@code MatchException} with the specified detail message and
+     * cause.
+     *
+     * @param  message the detail message (which is saved for later retrieval
+     *         by the {@link #getMessage()} method).
+     * @param  cause the cause (which is saved for later retrieval by the
+     *         {@link #getCause()} method). (A {@code null} value is
+     *         permitted, and indicates that the cause is nonexistent or
+     *         unknown.)
+     *
+     * @hide
+     */
+    public MatchException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/ojluni/src/main/java/java/lang/StrictMath.java b/ojluni/src/main/java/java/lang/StrictMath.java
index 01659eb8443..431bc07599f 100644
--- a/ojluni/src/main/java/java/lang/StrictMath.java
+++ b/ojluni/src/main/java/java/lang/StrictMath.java
@@ -25,6 +25,8 @@
 
 package java.lang;
 
+import dalvik.annotation.optimization.CriticalNative;
+
 import java.util.Random;
 import jdk.internal.math.DoubleConsts;
 import jdk.internal.vm.annotation.IntrinsicCandidate;
@@ -164,6 +166,7 @@ public final class StrictMath {
     // public static double sin(double a) {
     //     return FdLibm.Sin.compute(a);
     // }
+    @CriticalNative
     public static native double sin(double a);
 
     /**
@@ -180,6 +183,7 @@ public final class StrictMath {
     // public static double cos(double a) {
     //     return FdLibm.Cos.compute(a);
     // }
+    @CriticalNative
     public static native double cos(double a);
 
     /**
@@ -196,6 +200,7 @@ public final class StrictMath {
     // public static double tan(double a) {
     //     return FdLibm.Tan.compute(a);
     // }
+    @CriticalNative
     public static native double tan(double a);
 
     /**
@@ -213,6 +218,7 @@ public final class StrictMath {
     // public static double asin(double a) {
     //     return FdLibm.Asin.compute(a);
     // }
+    @CriticalNative
     public static native double asin(double a);
 
     /**
@@ -230,6 +236,7 @@ public final class StrictMath {
     // public static double acos(double a) {
     //     return FdLibm.Acos.compute(a);
     // }
+    @CriticalNative
     public static native double acos(double a);
 
     /**
@@ -250,6 +257,7 @@ public final class StrictMath {
     // public static double atan(double a) {
     //     return FdLibm.Atan.compute(a);
     // }
+    @CriticalNative
     public static native double atan(double a);
 
     /**
@@ -306,6 +314,7 @@ public final class StrictMath {
     }
     */
     // END Android-changed: Reimplement in native
+    @CriticalNative
     public static native double exp(double a);
 
     /**
@@ -329,6 +338,7 @@ public final class StrictMath {
     // public static double log(double a) {
     //     return FdLibm.Log.compute(a);
     // }
+    @CriticalNative
     public static native double log(double a);
 
     /**
@@ -355,6 +365,7 @@ public final class StrictMath {
     // public static double log10(double a) {
     //     return FdLibm.Log10.compute(a);
     // }
+    @CriticalNative
     public static native double log10(double a);
 
     /**
@@ -378,6 +389,7 @@ public final class StrictMath {
     // public static double sqrt(double a) {
     //     return FdLibm.Sqrt.compute(a);
     // }
+    @CriticalNative
     public static native double sqrt(double a);
 
     /**
@@ -410,6 +422,7 @@ public final class StrictMath {
     }
     */
     // END Android-changed: Reimplement in native
+    @CriticalNative
     public static native double cbrt(double a);
 
     /**
@@ -438,6 +451,7 @@ public final class StrictMath {
     // public static double IEEEremainder(double f1, double f2) {
     //     return FdLibm.IEEEremainder.compute(f1, f2);
     // }
+    @CriticalNative
     public static native double IEEEremainder(double f1, double f2);
 
     /**
@@ -628,6 +642,7 @@ public final class StrictMath {
     // public static double atan2(double y, double x) {
     //     return FdLibm.Atan2.compute(y, x);
     // }
+    @CriticalNative
     public static native double atan2(double y, double x);
 
     /**
@@ -767,6 +782,7 @@ public final class StrictMath {
     }
     */
     // END Android-changed: Reimplement in native
+    @CriticalNative
     public static native double pow(double a, double b);
 
     /**
@@ -2171,6 +2187,7 @@ public final class StrictMath {
     // public static double sinh(double x) {
     //     return FdLibm.Sinh.compute(x);
     // }
+    @CriticalNative
     public static native double sinh(double x);
 
     /**
@@ -2199,6 +2216,7 @@ public final class StrictMath {
     // public static double cosh(double x) {
     //     return FdLibm.Cosh.compute(x);
     // }
+    @CriticalNative
     public static native double cosh(double x);
 
     /**
@@ -2234,6 +2252,7 @@ public final class StrictMath {
     // public static double tanh(double x) {
     //     return FdLibm.Tanh.compute(x);
     // }
+    @CriticalNative
     public static native double tanh(double x);
 
     /**
@@ -2265,6 +2284,7 @@ public final class StrictMath {
     }
     */
     // END Android-changed: Reimplement in native
+    @CriticalNative
     public static native double hypot(double x, double y);
 
     /**
@@ -2297,6 +2317,7 @@ public final class StrictMath {
     // public static double expm1(double x) {
     //     return FdLibm.Expm1.compute(x);
     // }
+    @CriticalNative
     public static native double expm1(double x);
 
     /**
@@ -2332,6 +2353,7 @@ public final class StrictMath {
     // public static double log1p(double x) {
     //     return FdLibm.Log1p.compute(x);
     // }
+    @CriticalNative
     public static native double log1p(double x);
 
     /**
diff --git a/ojluni/src/main/java/java/lang/String.java b/ojluni/src/main/java/java/lang/String.java
index 9e3b6c9d9f7..9d2201384dc 100644
--- a/ojluni/src/main/java/java/lang/String.java
+++ b/ojluni/src/main/java/java/lang/String.java
@@ -183,29 +183,8 @@ public final class String
      * For methods with several possible implementation paths, when String
      * compaction is disabled, only one code path is taken.
      *
-     * The instance field value is generally opaque to optimizing JIT
-     * compilers. Therefore, in performance-sensitive place, an explicit
-     * check of the static boolean {@code COMPACT_STRINGS} is done first
-     * before checking the {@code coder} field since the static boolean
-     * {@code COMPACT_STRINGS} would be constant folded away by an
-     * optimizing JIT compiler. The idioms for these cases are as follows.
+     * Android note: The value is always true since the introduction of this internal constant.
      *
-     * For code such as:
-     *
-     *    if (coder == LATIN1) { ... }
-     *
-     * can be written more optimally as
-     *
-     *    if (coder() == LATIN1) { ... }
-     *
-     * or:
-     *
-     *    if (COMPACT_STRINGS && coder == LATIN1) { ... }
-     *
-     * An optimizing JIT compiler can fold the above conditional as:
-     *
-     *    COMPACT_STRINGS == true  => if (coder == LATIN1) { ... }
-     *    COMPACT_STRINGS == false => if (false)           { ... }
      */
     // Android-changed: Inline the constant on ART.
     static final boolean COMPACT_STRINGS = true;
@@ -214,8 +193,35 @@ public final class String
     /** @hide */
     public static final String EMPTY = "";
 
-    @Native static final byte LATIN1 = 0;
-    @Native static final byte UTF16  = 1;
+    // BEGIN Android-changed: Rename the constants which has different definitions on Android.
+    // @Native static final byte LATIN1 = 0;
+    // @Native static final byte UTF16  = 1;
+    /**
+     * The constant id representing the internal encoding scheme Latin-1 used in {@link String} and
+     * {@link AbstractStringBuilder}.
+     *
+     * However, ART only uses this Latin-1 encoding to compress {@link String} when all characters
+     * are 0x01 - 0x7f, due to detection of ASCII string in Modified-UTF8 in ART. When it contains
+     * any characters of 0x00, 0x80 - 0xff, and \u0100 - \uffff, ART is assumed to use  UTF-16,
+     * or other Unicode-compatible encoding scheme internally. Note that
+     * {@link AbstractStringBuilder} avoids inflating to UTF-16 when it contains only 0x00 - 0xff.
+     *
+     * In contrast, {@link String} in the upstream uses Latin-1 encoding when all characters
+     * contains only 0x00 - 0xff, when {@link #COMPACT_STRINGS} is enabled.
+     *
+     * WARNING: Do not assume that a {@String} instance using {@link #CODER_UTF16} encoding
+     * must contain at least one character {@code \u0100} - {@code \uffff}. This isn't true on
+     * Android, and may cause bugs, e.g. http://b/356007654, when importing upstream codes.
+     * This constant is renamed from {@code LATIN1} to {@code CODER_LATIN1} to require a manual
+     * change and review of any usages of this constant.
+     */
+    @Native static final byte CODER_LATIN1 = 0;
+
+    /**
+     * @see #CODER_LATIN1
+     */
+    @Native static final byte CODER_UTF16 = 1;
+    // END Android-changed: Rename the constants which has different definitions on Android.
 
     /**
      * Class String is special cased within the Serialization Stream Protocol.
@@ -2241,15 +2247,17 @@ public final class String
             return -1;
         }
         if (srcCoder == tgtCoder) {
-            return srcCoder == LATIN1
+            return srcCoder == CODER_LATIN1
                 // Android-changed: libcore doesn't store String as Latin1 or UTF16 byte[] field.
                 // ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)
                 // : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);
                 ? StringLatin1.indexOf(src, srcCount, tgtStr, tgtCount, fromIndex)
                 : StringUTF16.indexOf(src, srcCount, tgtStr, tgtCount, fromIndex);
         }
-        if (srcCoder == LATIN1) {    //  && tgtCoder == UTF16
-            return -1;
+        if (srcCoder == CODER_LATIN1) {    //  && tgtCoder == UTF16
+            // Android-changed: Latin1 AbstractStringBuilder has a larger range than Latin1 String.
+            // return -1;
+            return StringLatin1.indexOfUTF16(src, srcCount, tgtStr, tgtCount, fromIndex);
         }
         // srcCoder == UTF16 && tgtCoder == LATIN1) {
         // return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);
@@ -2389,15 +2397,17 @@ public final class String
             return fromIndex;
         }
         if (srcCoder == tgtCoder) {
-            return srcCoder == LATIN1
+            return srcCoder == CODER_LATIN1
                 // Android-changed: libcore doesn't store String as Latin1 or UTF16 byte[] field.
                 // ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)
                 // : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);
                 ? StringLatin1.lastIndexOf(src, srcCount, tgtStr, tgtCount, fromIndex)
                 : StringUTF16.lastIndexOf(src, srcCount, tgtStr, tgtCount, fromIndex);
         }
-        if (srcCoder == LATIN1) {    // && tgtCoder == UTF16
-            return -1;
+        if (srcCoder == CODER_LATIN1) {    // && tgtCoder == UTF16
+            // Android-changed: Latin1 AbstractStringBuilder has a larger range than Latin1 String.
+            // return -1;
+            return StringLatin1.lastIndexOfUTF16(src, srcCount, tgtStr, tgtCount, fromIndex);
         }
         // srcCoder == UTF16 && tgtCoder == LATIN1
         // return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);
@@ -4357,33 +4367,40 @@ public final class String
      * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two
      * coders are different, and dst is big enough (range check)
      *
+     * Android-note: Please always inflate the byte buffer {@code dst} if
+     * {@code coder != str.coder()}, or the string contains only
+     * {@code \u0000} - (@code \u00ff} characters. The later check is a rather expensive
+     * operation because ART doesn't keep tracking it in a String instance.
+     *
+     * {@link #coder()} returns {@link #CODER_UTF16}
+     * if it contains any {@code \u0080} - {@code \u00ff} characters. See {@link #CODER_LATIN1}.
+     *
      * @param dstBegin  the char index, not offset of byte[]
      * @param coder     the coder of dst[]
      */
+    // BEGIN Android-changed: libcore doesn't store String as Latin1 or UTF16 byte[] field.
+    /*
     void getBytes(byte dst[], int dstBegin, byte coder) {
-        // Android-changed: libcore doesn't store String as Latin1 or UTF16 byte[] field.
-        /*
         if (coder() == coder) {
             System.arraycopy(value, 0, dst, dstBegin << coder, value.length);
         } else {    // this.coder == LATIN && coder == UTF16
             StringLatin1.inflate(value, 0, dst, dstBegin, value.length);
         }
-        */
+    }
+    */
+    void fillBytes(byte dst[], int dstBegin, byte coder) {
         // We do bound check here before the native calls, because the upstream implementation does
         // the bound check in System.arraycopy and StringLatin1.inflate or throws an exception.
-        if (coder == UTF16) {
+        if (coder == CODER_UTF16) {
             int fromIndex = dstBegin << 1;
             checkBoundsOffCount(fromIndex, length() << 1, dst.length);
             fillBytesUTF16(dst, fromIndex);
         } else {
-            if (coder() != LATIN1) {
-                // Do not concat String in the error message.
-                throw new StringIndexOutOfBoundsException("Expect Latin-1 coder.");
-            }
             checkBoundsOffCount(dstBegin, length(), dst.length);
             fillBytesLatin1(dst, dstBegin);
         }
     }
+    // END Android-changed: libcore doesn't store String as Latin1 or UTF16 byte[] field.
 
     // BEGIN Android-added: Implement fillBytes*() method natively.
 
@@ -4414,16 +4431,18 @@ public final class String
     }
 
     /**
-     * Android note: It returns UTF16 if the string has any 0x00 char.
+     * Android note: It returns UTF16 if the string has any 0x00 char and 0x80 - 0xff.
      * See the difference between {@link StringLatin1#canEncode(int)} and
      * art::mirror::String::IsASCII(uint16_t) in string.h.
+     *
+     * @see #CODER_LATIN1
      */
     byte coder() {
         // Android-changed: ART stores the flag in the count field.
         // return COMPACT_STRINGS ? coder : UTF16;
         // We assume that STRING_COMPRESSION_ENABLED is enabled here.
         // The flag has been true for 6+ years.
-        return COMPACT_STRINGS ? ((byte) (count & 1)) : UTF16;
+        return COMPACT_STRINGS ? ((byte) (count & 1)) : CODER_UTF16;
     }
 
     /*
@@ -4476,11 +4495,11 @@ public final class String
      */
     static String valueOfCodePoint(int codePoint) {
         if (COMPACT_STRINGS && StringLatin1.canEncode(codePoint)) {
-            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);
+            return new String(StringLatin1.toBytes((char)codePoint), CODER_LATIN1);
         } else if (Character.isBmpCodePoint(codePoint)) {
-            return new String(StringUTF16.toBytes((char)codePoint), UTF16);
+            return new String(StringUTF16.toBytes((char)codePoint), CODER_UTF16);
         } else if (Character.isSupplementaryCodePoint(codePoint)) {
-            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);
+            return new String(StringUTF16.toBytesSupplementary(codePoint), CODER_UTF16);
         }
 
         throw new IllegalArgumentException(
diff --git a/ojluni/src/main/java/java/lang/StringLatin1.java b/ojluni/src/main/java/java/lang/StringLatin1.java
index 91abce3b572..d4b005386df 100644
--- a/ojluni/src/main/java/java/lang/StringLatin1.java
+++ b/ojluni/src/main/java/java/lang/StringLatin1.java
@@ -36,8 +36,6 @@ import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import jdk.internal.HotSpotIntrinsicCandidate;
 
-import static java.lang.String.LATIN1;
-import static java.lang.String.UTF16;
 import static java.lang.String.checkOffset;
 
 final class StringLatin1 {
@@ -263,6 +261,38 @@ final class StringLatin1 {
         return -1;
     }
 
+    // BEGIN Android-added: Latin1 AbstractStringBuilder has a larger char range than Latin1 String.
+    public static int indexOfUTF16(byte[] value, int valueCount, String str, int strCount,
+            int fromIndex) {
+        char first = str.charAt(0);
+        int max = (valueCount - strCount);
+        for (int i = fromIndex; i <= max; i++) {
+            // Look for first character.
+            if (first != ((char) (value[i] & 0xff))) {
+                while (++i <= max && first != ((char) (value[i] & 0xff)));
+            }
+            // Found first character, now look at the rest of value
+            if (i <= max) {
+                int j = i + 1;
+                int end = j + strCount - 1;
+                for (int k = 1; j < end && ((char) (value[j] & 0xff)) == str.charAt(k); j++, k++);
+                if (j == end) {
+                    // Found whole string.
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public static int lastIndexOfUTF16(byte[] src, int srcCount,
+            String tgt, int tgtCount, int fromIndex) {
+        // Re-use the lastIndexOf implementation for Latin1 because our patched implementation
+        // casts Latin1 byte into char anyway. We can potentially do the same for indexOfUTF16.
+        return lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);
+    }
+    // END Android-added: Latin1 AbstractStringBuilder has a larger char range than Latin1 String.
+
     public static int lastIndexOf(byte[] src, int srcCount,
                                   // Android-changed: String has no byte[] field in libcore.
                                   // byte[] tgt, int tgtCount, int fromIndex) {
@@ -275,7 +305,9 @@ final class StringLatin1 {
 
   startSearchForLastChar:
         while (true) {
-            while (i >= min && (src[i] & 0xff) != strLastChar) {
+            // Android-changed: Latin1 AbstractStringBuilder has a larger char range than Latin1.
+            // while (i >= min && (src[i] & 0xff) != strLastChar) {
+            while (i >= min && ((char) (src[i] & 0xff)) != strLastChar) {
                 i--;
             }
             if (i < min) {
@@ -287,7 +319,7 @@ final class StringLatin1 {
             while (j > start) {
                 // Android-changed: Use charAt() because libcore doesn't store byte[] in java level.
                 // if ((src[j--] & 0xff) != (tgt[k--] & 0xff)) {
-                if ((src[j--] & 0xff) != (tgt.charAt(k--) & 0xff)) {
+                if (((char)(src[j--] & 0xff)) != tgt.charAt(k--)) {
                     i--;
                     continue startSearchForLastChar;
                 }
diff --git a/ojluni/src/main/java/java/lang/StringUTF16.java b/ojluni/src/main/java/java/lang/StringUTF16.java
index b0507e9f5ac..0bce7ae6991 100644
--- a/ojluni/src/main/java/java/lang/StringUTF16.java
+++ b/ojluni/src/main/java/java/lang/StringUTF16.java
@@ -34,8 +34,8 @@ import java.util.stream.StreamSupport;
 import jdk.internal.HotSpotIntrinsicCandidate;
 import jdk.internal.vm.annotation.IntrinsicCandidate;
 
-import static java.lang.String.UTF16;
-import static java.lang.String.LATIN1;
+import static java.lang.String.CODER_UTF16;
+import static java.lang.String.CODER_LATIN1;
 
 public final class StringUTF16 {
 
@@ -639,10 +639,10 @@ public final class StringUTF16 {
                StringLatin1.canEncode(newChar)) {
                byte[] val = compress(buf, 0, len);
                if (val != null) {
-                   return new String(val, LATIN1);
+                   return new String(val, CODER_LATIN1);
                }
            }
-           return new String(buf, UTF16);
+           return new String(buf, CODER_UTF16);
         }
         return null;
     }
diff --git a/ojluni/src/main/java/java/lang/Thread.java b/ojluni/src/main/java/java/lang/Thread.java
index b64324a2171..5127c98a1ca 100644
--- a/ojluni/src/main/java/java/lang/Thread.java
+++ b/ojluni/src/main/java/java/lang/Thread.java
@@ -38,6 +38,7 @@ import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.locks.LockSupport;
+import jdk.internal.misc.Unsafe;
 import sun.nio.ch.Interruptible;
 import sun.reflect.CallerSensitive;
 import dalvik.system.VMStack;
@@ -296,7 +297,7 @@ class Thread implements Runnable {
      */
     public static final int MIN_PRIORITY = 1;
 
-   /**
+    /**
      * The default priority that is assigned to a thread.
      */
     public static final int NORM_PRIORITY = 5;
@@ -584,6 +585,95 @@ class Thread implements Runnable {
         this.tid = nextThreadID();
     }
 
+    /**
+     * Characteristic value signifying that initial values for {@link
+     * InheritableThreadLocal inheritable-thread-locals} are not inherited from
+     * the constructing thread.
+     * See Thread initialization.
+     */
+    static final int NO_INHERIT_THREAD_LOCALS = 1 << 2;
+
+    /**
+     * Helper class to generate thread identifiers. The identifiers start at
+     * 2 as this class cannot be used during early startup to generate the
+     * identifier for the primordial thread. The counter is off-heap and
+     * shared with the VM to allow it assign thread identifiers to non-Java
+     * threads.
+     * See Thread initialization.
+     */
+    private static class ThreadIdentifiers {
+        private static final Unsafe U;
+        private static final long NEXT_TID_OFFSET;
+        static {
+            U = Unsafe.getUnsafe();
+            // Android-changed: TODO(b/346542404): Implement Thread.getNextThreadIdOffset()
+            // NEXT_TID_OFFSET = Thread.getNextThreadIdOffset();
+            NEXT_TID_OFFSET = 61234L;
+        }
+        static long next() {
+            return U.getAndAddLong(null, NEXT_TID_OFFSET, 1);
+        }
+    }
+
+    /**
+     * Returns the context class loader to inherit from the parent thread.
+     * See Thread initialization.
+     */
+    private static ClassLoader contextClassLoader(Thread parent) {
+        @SuppressWarnings("removal")
+        SecurityManager sm = System.getSecurityManager();
+        if (sm == null || isCCLOverridden(parent.getClass())) {
+            return parent.getContextClassLoader();
+        } else {
+            // skip call to getContextClassLoader
+            return parent.contextClassLoader;
+        }
+    }
+
+    /**
+     * Initializes a virtual Thread.
+     *
+     * @param name thread name, can be null
+     * @param characteristics thread characteristics
+     * @param bound true when bound to an OS thread
+     */
+    Thread(String name, int characteristics, boolean bound) {
+        this.tid = ThreadIdentifiers.next();
+        this.name = (name != null) ? name : "";
+        // Android-changed: Android has no SecurityManager.
+        // this.inheritedAccessControlContext = Constants.NO_PERMISSIONS_ACC;
+        this.inheritedAccessControlContext = AccessController.getContext();
+
+        // thread locals
+        if ((characteristics & NO_INHERIT_THREAD_LOCALS) == 0) {
+            Thread parent = currentThread();
+            ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
+            if (parentMap != null && parentMap.size() > 0) {
+                this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
+            }
+            this.contextClassLoader = contextClassLoader(parent);
+        } else {
+            // default CCL to the system class loader when not inheriting
+            this.contextClassLoader = ClassLoader.getSystemClassLoader();
+        }
+
+        // Android-changed: TODO(b/346542404): bound to an OS thread.
+        /*
+        // special value to indicate this is a newly-created Thread
+        this.scopedValueBindings = NEW_THREAD_BINDINGS;
+
+        // create a FieldHolder object, needed when bound to an OS thread
+        if (bound) {
+            ThreadGroup g = Constants.VTHREAD_GROUP;
+            int pri = NORM_PRIORITY;
+            this.holder = new FieldHolder(g, null, -1, pri, true);
+        } else {
+            this.holder = null;
+        }
+        */
+        this.stackSize = -1;
+    }
+
     /**
      * Throws CloneNotSupportedException as a Thread can not be meaningfully
      * cloned. Construct a new Thread instead.
@@ -928,6 +1018,21 @@ class Thread implements Runnable {
         this(group, target, name, stackSize, null, inheritThreadLocals);
     }
 
+    /**
+     * Returns {@code true} if this thread is a virtual thread. A virtual thread
+     * is scheduled by the Java virtual machine rather than the operating system.
+     *
+     * @return {@code true} if this thread is a virtual thread
+     *
+     * @since 21
+     * @hide
+     */
+    public final boolean isVirtual() {
+        // Android-changed: Virtual threads are not supported in Android.
+        // return (this instanceof BaseVirtualThread);
+        return false;
+    }
+
     /**
      * Causes this thread to begin execution; the Java Virtual Machine
      * calls the {@code run} method of this thread.
@@ -2000,6 +2105,19 @@ class Thread implements Runnable {
         return tid;
     }
 
+    /**
+     * Returns the identifier of this Thread.  The thread ID is a positive
+     * {@code long} number generated when this thread was created.
+     * The thread ID is unique and remains unchanged during its lifetime.
+     *
+     * @return this thread's ID
+     * @since 19
+     * @hide
+     */
+    public final long threadId() {
+        return tid;
+    }
+
     /**
      * A thread state.  A thread can be in one of the following states:
      * <ul>
diff --git a/ojluni/src/main/java/java/lang/ThreadLocal.java b/ojluni/src/main/java/java/lang/ThreadLocal.java
index 302a0a387a1..fa2a8aa32d1 100644
--- a/ojluni/src/main/java/java/lang/ThreadLocal.java
+++ b/ojluni/src/main/java/java/lang/ThreadLocal.java
@@ -420,6 +420,13 @@ public class ThreadLocal<T> {
             }
         }
 
+        /**
+         * Returns the number of elements in the map.
+         */
+        int size() {
+            return size;
+        }
+
         /**
          * Get the entry associated with key.  This method
          * itself handles only the fast path: a direct hit of existing
diff --git a/ojluni/src/main/java/java/lang/annotation/TEST_MAPPING b/ojluni/src/main/java/java/lang/annotation/TEST_MAPPING
index f5f636500f6..f75f9bb2812 100644
--- a/ojluni/src/main/java/java/lang/annotation/TEST_MAPPING
+++ b/ojluni/src/main/java/java/lang/annotation/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.lang.reflect.annotations"
-        },
-        {
-          "include-filter": "libcore.java.lang.annotation"
-        },
-        {
-          "include-filter": "org.apache.harmony.annotation.tests.java.lang.annotation"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_lang_annotation"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/lang/constant/ClassDesc.java b/ojluni/src/main/java/java/lang/constant/ClassDesc.java
index 435d992fa50..801cbceea1e 100644
--- a/ojluni/src/main/java/java/lang/constant/ClassDesc.java
+++ b/ojluni/src/main/java/java/lang/constant/ClassDesc.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,7 @@
  */
 package java.lang.constant;
 
+import java.lang.invoke.MethodHandles;
 import java.lang.invoke.TypeDescriptor;
 import java.util.stream.Stream;
 
@@ -72,12 +73,44 @@ public sealed interface ClassDesc
      * @throws NullPointerException if the argument is {@code null}
      * @throws IllegalArgumentException if the name string is not in the
      * correct format
+     * @see ClassDesc#ofDescriptor(String)
+     * @see ClassDesc#ofInternalName(String)
      */
     static ClassDesc of(String name) {
         ConstantUtils.validateBinaryClassName(requireNonNull(name));
         return ClassDesc.ofDescriptor("L" + binaryToInternal(name) + ";");
     }
 
+    // BEGIN Android-removed: Not used in Android.
+    /*
+    /**
+     * Returns a {@linkplain ClassDesc} for a class or interface type,
+     * given the name of the class or interface in internal form,
+     * such as {@code "java/lang/String"}.
+     *
+     * @apiNote
+     * To create a descriptor for an array type, either use {@link #ofDescriptor(String)}
+     * or {@link #arrayType()}; to create a descriptor for a primitive type, use
+     * {@link #ofDescriptor(String)} or use the predefined constants in
+     * {@link ConstantDescs}.
+     *
+     * @param name the fully qualified class name, in internal (slash-separated) form
+     * @return a {@linkplain ClassDesc} describing the desired class
+     * @throws NullPointerException if the argument is {@code null}
+     * @throws IllegalArgumentException if the name string is not in the
+     * correct format
+     * @jvms 4.2.1 Binary Class and Interface Names
+     * @see ClassDesc#of(String)
+     * @see ClassDesc#ofDescriptor(String)
+     * @since 20
+     * /
+    static ClassDesc ofInternalName(String name) {
+        ConstantUtils.validateInternalClassName(requireNonNull(name));
+        return ClassDesc.ofDescriptor("L" + name + ";");
+    }
+     */
+    // END Android-removed: Not used in Android.
+
     /**
      * Returns a {@linkplain ClassDesc} for a class or interface type,
      * given a package name and the unqualified (simple) name for the
@@ -99,7 +132,7 @@ public sealed interface ClassDesc
         }
         validateMemberName(requireNonNull(className), false);
         return ofDescriptor("L" + binaryToInternal(packageName) +
-                (packageName.length() > 0 ? "/" : "") + className + ";");
+                "/" + className + ";");
     }
 
     /**
@@ -116,15 +149,17 @@ public sealed interface ClassDesc
      * followed by the field descriptor for the component type.  Examples of
      * valid type descriptor strings include {@code "Ljava/lang/String;"}, {@code "I"},
      * {@code "[I"}, {@code "V"}, {@code "[Ljava/lang/String;"}, etc.
-     * See JVMS 4.3.2 ("Field Descriptors") for more detail.
+     * See JVMS {@jvms 4.3.2 }("Field Descriptors") for more detail.
      *
      * @param descriptor a field descriptor string
      * @return a {@linkplain ClassDesc} describing the desired class
      * @throws NullPointerException if the argument is {@code null}
-     * @throws IllegalArgumentException if the name string is not in the
+     * @throws IllegalArgumentException if the descriptor string is not in the
      * correct format
      * @jvms 4.3.2 Field Descriptors
      * @jvms 4.4.1 The CONSTANT_Class_info Structure
+     * @see ClassDesc#of(String)
+     * @see ClassDesc#ofInternalName(String)
      */
     static ClassDesc ofDescriptor(String descriptor) {
         requireNonNull(descriptor);
@@ -148,7 +183,8 @@ public sealed interface ClassDesc
      * is described by this {@linkplain ClassDesc}.
      *
      * @return a {@linkplain ClassDesc} describing the array type
-     * @throws IllegalStateException if the resulting {@linkplain ClassDesc} would have an array rank of greater than 255
+     * @throws IllegalStateException if the resulting {@linkplain
+     * ClassDesc} would have an array rank of greater than 255
      * @jvms 4.4.1 The CONSTANT_Class_info Structure
      */
     default ClassDesc arrayType() {
@@ -167,14 +203,27 @@ public sealed interface ClassDesc
      *
      * @param rank the rank of the array
      * @return a {@linkplain ClassDesc} describing the array type
-     * @throws IllegalArgumentException if the rank is less than or equal to zero or if the rank of the resulting array type is
+     * @throws IllegalArgumentException if the rank is less than or
+     * equal to zero or if the rank of the resulting array type is
      * greater than 255
      * @jvms 4.4.1 The CONSTANT_Class_info Structure
      */
     default ClassDesc arrayType(int rank) {
-        int currentDepth = ConstantUtils.arrayDepth(descriptorString());
-        if (rank <= 0 || currentDepth + rank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS)
-            throw new IllegalArgumentException("rank: " + currentDepth + rank);
+        int netRank;
+        if (rank <= 0) {
+            throw new IllegalArgumentException("rank " + rank + " is not a positive value");
+        }
+        try {
+            int currentDepth = ConstantUtils.arrayDepth(descriptorString());
+            netRank = Math.addExact(currentDepth, rank);
+            if (netRank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {
+                throw new IllegalArgumentException("rank: " + netRank +
+                                                   " exceeds maximum supported dimension of " +
+                                                   ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS);
+            }
+        } catch (ArithmeticException ae) {
+            throw new IllegalArgumentException("Integer overflow in rank computation");
+        }
         return ClassDesc.ofDescriptor("[".repeat(rank) + descriptorString());
     }
 
@@ -318,6 +367,9 @@ public sealed interface ClassDesc
      */
     String descriptorString();
 
+    @Override
+    Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;
+
     /**
      * Compare the specified object with this descriptor for equality.  Returns
      * {@code true} if and only if the specified object is also a
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java b/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
index a72b07b2227..ad09f3e6c24 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
@@ -37,10 +37,11 @@ import java.lang.reflect.Modifier;
  * @hide
  */
 public class MethodHandleImpl extends MethodHandle implements Cloneable {
-    private HandleInfo info;
+    private Object targetClassOrMethodHandleInfo;
 
     MethodHandleImpl(long artFieldOrMethod, int handleKind, MethodType type) {
         super(artFieldOrMethod, handleKind, type);
+        this.targetClassOrMethodHandleInfo = getMemberInternal().getDeclaringClass();
     }
 
     @Override
@@ -49,12 +50,13 @@ public class MethodHandleImpl extends MethodHandle implements Cloneable {
     }
 
     MethodHandleInfo reveal() {
-        if (info == null) {
-            final Member member = getMemberInternal();
-            info = new HandleInfo(member, this);
+        if (!(targetClassOrMethodHandleInfo instanceof HandleInfo handleInfo)) {
+            MethodHandleInfo info = new HandleInfo(getMemberInternal(), this);
+            targetClassOrMethodHandleInfo = info;
+            return info;
         }
 
-        return info;
+        return handleInfo;
     }
 
     /**
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodHandles.java b/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
index 305b3ebe020..47a74decff6 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
@@ -740,7 +740,10 @@ public class MethodHandles {
                             && !name.equals("java.lang.Daemons$FinalizerWatchdogDaemon")
                             && !name.equals("java.lang.runtime.ObjectMethods")
                             && !name.equals("java.lang.Thread")
-                            && !name.equals("java.util.HashMap")) ||
+                            && !name.equals("java.util.HashMap")
+                            && !name.equals("java.util.HashSet")
+                            && !name.equals("java.util.WeakHashMap")
+                            && !name.startsWith("java.util.stream.")) ||
                         (name.startsWith("sun.")
                                 && !name.startsWith("sun.invoke.")
                                 && !name.equals("sun.reflect.ReflectionFactory"))) {
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodType.java b/ojluni/src/main/java/java/lang/invoke/MethodType.java
index 1bf6e16e616..8340a9b1962 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodType.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodType.java
@@ -25,6 +25,8 @@
 
 package java.lang.invoke;
 
+import jdk.internal.util.ReferenceKey;
+import jdk.internal.util.ReferencedKeySet;
 import sun.invoke.util.Wrapper;
 import java.lang.ref.WeakReference;
 import java.lang.ref.Reference;
@@ -32,9 +34,12 @@ import java.lang.ref.ReferenceQueue;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
+
 import jdk.internal.vm.annotation.Stable;
 import sun.invoke.util.BytecodeDescriptor;
 import static java.lang.invoke.MethodHandleStatics.*;
@@ -106,22 +111,10 @@ class MethodType
     private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
 
     /**
-     * Check the given parameters for validity and store them into the final fields.
+     * Constructor that performs no copying or validation.
+     * Should only be called from the factory method makeImpl
      */
-    private MethodType(Class<?> rtype, Class<?>[] ptypes, boolean trusted) {
-        checkRtype(rtype);
-        checkPtypes(ptypes);
-        this.rtype = rtype;
-        // defensively copy the array passed in by the user
-        this.ptypes = trusted ? ptypes : Arrays.copyOf(ptypes, ptypes.length);
-    }
-
-    /**
-     * Construct a temporary unchecked instance of MethodType for use only as a key to the intern table.
-     * Does not check the given parameters for validity, and must be discarded after it is used as a searching key.
-     * The parameters are reversed for this constructor, so that is is not accidentally used.
-     */
-    private MethodType(Class<?>[] ptypes, Class<?> rtype) {
+    private MethodType(Class<?> rtype, Class<?>[] ptypes) {
         this.rtype = rtype;
         this.ptypes = ptypes;
     }
@@ -197,7 +190,16 @@ class MethodType
         return new IndexOutOfBoundsException(num.toString());
     }
 
-    static final ConcurrentWeakInternSet<MethodType> internTable = new ConcurrentWeakInternSet<>();
+    static final ReferencedKeySet<MethodType> internTable =
+            // Android-changed: use method with explicit name.
+            // ReferencedKeySet.create(false, true, new Supplier<>() {
+            ReferencedKeySet.createWithNativeQueue(false, new Supplier<>() {
+                @Override
+                public Map<ReferenceKey<MethodType>, ReferenceKey<MethodType>> get() {
+                    return new ConcurrentHashMap<>(512);
+                }
+            });
+
 
     static final Class<?>[] NO_PTYPES = {};
 
@@ -306,16 +308,27 @@ class MethodType
      */
     /*trusted*/ static
     MethodType makeImpl(Class<?> rtype, Class<?>[] ptypes, boolean trusted) {
-        MethodType mt = internTable.get(new MethodType(ptypes, rtype));
-        if (mt != null)
-            return mt;
         if (ptypes.length == 0) {
             ptypes = NO_PTYPES; trusted = true;
         }
-        mt = new MethodType(rtype, ptypes, trusted);
+        MethodType primordialMT = new MethodType(rtype, ptypes);
+        MethodType mt = internTable.get(primordialMT);
+        if (mt != null)
+            return mt;
+
         // promote the object to the Real Thing, and reprobe
+        Objects.requireNonNull(rtype);
+        if (trusted) {
+            MethodType.checkPtypes(ptypes);
+            mt = primordialMT;
+        } else {
+            // Make defensive copy then validate
+            ptypes = Arrays.copyOf(ptypes, ptypes.length);
+            MethodType.checkPtypes(ptypes);
+            mt = new MethodType(rtype, ptypes);
+        }
         mt.form = MethodTypeForm.findForm(mt);
-        return internTable.add(mt);
+        return internTable.intern(mt);
     }
     private static final MethodType[] objectOnlyTypes = new MethodType[20];
 
@@ -1300,106 +1313,4 @@ s.writeObject(this.parameterArray());
         // Verify all operands, and make sure ptypes is unshared:
         return methodType(rtype, ptypes);
     }
-
-    /**
-     * Simple implementation of weak concurrent intern set.
-     *
-     * @param <T> interned type
-     */
-    private static class ConcurrentWeakInternSet<T> {
-
-        private final ConcurrentMap<WeakEntry<T>, WeakEntry<T>> map;
-        private final ReferenceQueue<T> stale;
-
-        public ConcurrentWeakInternSet() {
-            this.map = new ConcurrentHashMap<>();
-            this.stale = new ReferenceQueue<>();
-        }
-
-        /**
-         * Get the existing interned element.
-         * This method returns null if no element is interned.
-         *
-         * @param elem element to look up
-         * @return the interned element
-         */
-        public T get(T elem) {
-            if (elem == null) throw new NullPointerException();
-            expungeStaleElements();
-
-            WeakEntry<T> value = map.get(new WeakEntry<>(elem));
-            if (value != null) {
-                T res = value.get();
-                if (res != null) {
-                    return res;
-                }
-            }
-            return null;
-        }
-
-        /**
-         * Interns the element.
-         * Always returns non-null element, matching the one in the intern set.
-         * Under the race against another add(), it can return <i>different</i>
-         * element, if another thread beats us to interning it.
-         *
-         * @param elem element to add
-         * @return element that was actually added
-         */
-        public T add(T elem) {
-            if (elem == null) throw new NullPointerException();
-
-            // Playing double race here, and so spinloop is required.
-            // First race is with two concurrent updaters.
-            // Second race is with GC purging weak ref under our feet.
-            // Hopefully, we almost always end up with a single pass.
-            T interned;
-            WeakEntry<T> e = new WeakEntry<>(elem, stale);
-            do {
-                expungeStaleElements();
-                WeakEntry<T> exist = map.putIfAbsent(e, e);
-                interned = (exist == null) ? elem : exist.get();
-            } while (interned == null);
-            return interned;
-        }
-
-        private void expungeStaleElements() {
-            Reference<? extends T> reference;
-            while ((reference = stale.poll()) != null) {
-                map.remove(reference);
-            }
-        }
-
-        private static class WeakEntry<T> extends WeakReference<T> {
-
-            public final int hashcode;
-
-            public WeakEntry(T key, ReferenceQueue<T> queue) {
-                super(key, queue);
-                hashcode = key.hashCode();
-            }
-
-            public WeakEntry(T key) {
-                super(key);
-                hashcode = key.hashCode();
-            }
-
-            @Override
-            public boolean equals(Object obj) {
-                if (obj instanceof WeakEntry) {
-                    Object that = ((WeakEntry) obj).get();
-                    Object mine = get();
-                    return (that == null || mine == null) ? (this == obj) : mine.equals(that);
-                }
-                return false;
-            }
-
-            @Override
-            public int hashCode() {
-                return hashcode;
-            }
-
-        }
-    }
-
 }
diff --git a/ojluni/src/main/java/java/lang/reflect/TEST_MAPPING b/ojluni/src/main/java/java/lang/reflect/TEST_MAPPING
index 2d13e0a2ee8..1cb5161a46c 100644
--- a/ojluni/src/main/java/java/lang/reflect/TEST_MAPPING
+++ b/ojluni/src/main/java/java/lang/reflect/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.lang.reflect"
-        },
-        {
-          "include-filter": "libcore.java.lang.reflect.annotations"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.lang.reflect"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_lang_reflect"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java b/ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java
new file mode 100644
index 00000000000..092c728e156
--- /dev/null
+++ b/ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java
@@ -0,0 +1,439 @@
+/*
+ * Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.runtime;
+
+import java.lang.Enum.EnumDesc;
+import java.lang.invoke.CallSite;
+import java.lang.invoke.ConstantCallSite;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.vm.annotation.Stable;
+
+import static java.util.Objects.requireNonNull;
+
+/**
+ * Bootstrap methods for linking {@code invokedynamic} call sites that implement
+ * the selection functionality of the {@code switch} statement.  The bootstraps
+ * take additional static arguments corresponding to the {@code case} labels
+ * of the {@code switch}, implicitly numbered sequentially from {@code [0..N)}.
+ *
+ * @since 21
+ *
+ * @hide
+ */
+public class SwitchBootstraps {
+
+    private SwitchBootstraps() {}
+
+    private static final Object SENTINEL = new Object();
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+
+    private static final MethodHandle INSTANCEOF_CHECK;
+    private static final MethodHandle INTEGER_EQ_CHECK;
+    private static final MethodHandle OBJECT_EQ_CHECK;
+    private static final MethodHandle ENUM_EQ_CHECK;
+    private static final MethodHandle NULL_CHECK;
+    private static final MethodHandle IS_ZERO;
+    private static final MethodHandle CHECK_INDEX;
+    private static final MethodHandle MAPPED_ENUM_LOOKUP;
+
+    static {
+        try {
+            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, "isInstance",
+                                                                                 MethodType.methodType(boolean.class, Object.class)),
+                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);
+            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, "integerEqCheck",
+                                           MethodType.methodType(boolean.class, Object.class, Integer.class));
+            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, "equals",
+                                           MethodType.methodType(boolean.class, Object.class, Object.class));
+            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, "enumEqCheck",
+                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));
+            NULL_CHECK = LOOKUP.findStatic(Objects.class, "isNull",
+                                           MethodType.methodType(boolean.class, Object.class));
+            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, "isZero",
+                                           MethodType.methodType(boolean.class, int.class));
+            CHECK_INDEX = LOOKUP.findStatic(Objects.class, "checkIndex",
+                                           MethodType.methodType(int.class, int.class, int.class));
+            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, "mappedEnumLookup",
+                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,
+                                                                         Class.class, EnumDesc[].class, EnumMap.class));
+        }
+        catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    /**
+     * Bootstrap method for linking an {@code invokedynamic} call site that
+     * implements a {@code switch} on a target of a reference type.  The static
+     * arguments are an array of case labels which must be non-null and of type
+     * {@code String} or {@code Integer} or {@code Class} or {@code EnumDesc}.
+     * <p>
+     * The type of the returned {@code CallSite}'s method handle will have
+     * a return type of {@code int}.   It has two parameters: the first argument
+     * will be an {@code Object} instance ({@code target}) and the second
+     * will be {@code int} ({@code restart}).
+     * <p>
+     * If the {@code target} is {@code null}, then the method of the call site
+     * returns {@literal -1}.
+     * <p>
+     * If the {@code target} is not {@code null}, then the method of the call site
+     * returns the index of the first element in the {@code labels} array starting from
+     * the {@code restart} index matching one of the following conditions:
+     * <ul>
+     *   <li>the element is of type {@code Class} that is assignable
+     *       from the target's class; or</li>
+     *   <li>the element is of type {@code String} or {@code Integer} and
+     *       equals to the target.</li>
+     *   <li>the element is of type {@code EnumDesc}, that describes a constant that is
+     *       equals to the target.</li>
+     * </ul>
+     * <p>
+     * If no element in the {@code labels} array matches the target, then
+     * the method of the call site return the length of the {@code labels} array.
+     * <p>
+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and
+     * the length of the {@code labels} array (inclusive),
+     * both  or an {@link IndexOutOfBoundsException} is thrown.
+     *
+     * @param lookup Represents a lookup context with the accessibility
+     *               privileges of the caller.  When used with {@code invokedynamic},
+     *               this is stacked automatically by the VM.
+     * @param invocationName unused
+     * @param invocationType The invocation type of the {@code CallSite} with two parameters,
+     *                       a reference type, an {@code int}, and {@code int} as a return type.
+     * @param labels case labels - {@code String} and {@code Integer} constants
+     *               and {@code Class} and {@code EnumDesc} instances, in any combination
+     * @return a {@code CallSite} returning the first matching element as described above
+     *
+     * @throws NullPointerException if any argument is {@code null}
+     * @throws IllegalArgumentException if any element in the labels array is null, if the
+     * invocation type is not not a method type of first parameter of a reference type,
+     * second parameter of type {@code int} and with {@code int} as its return type,
+     * or if {@code labels} contains an element that is not of type {@code String},
+     * {@code Integer}, {@code Class} or {@code EnumDesc}.
+     * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure
+     * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures
+     *
+     * @hide
+     */
+    public static CallSite typeSwitch(MethodHandles.Lookup lookup,
+                                      String invocationName,
+                                      MethodType invocationType,
+                                      Object... labels) {
+        if (invocationType.parameterCount() != 2
+            || (!invocationType.returnType().equals(int.class))
+            || invocationType.parameterType(0).isPrimitive()
+            || !invocationType.parameterType(1).equals(int.class))
+            throw new IllegalArgumentException("Illegal invocation type " + invocationType);
+        requireNonNull(labels);
+
+        labels = labels.clone();
+        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);
+
+        MethodHandle target = createMethodHandleSwitch(lookup, labels);
+
+        return new ConstantCallSite(target);
+    }
+
+    private static void verifyLabel(Object label) {
+        if (label == null) {
+            throw new IllegalArgumentException("null label found");
+        }
+        Class<?> labelClass = label.getClass();
+        if (labelClass != Class.class &&
+            labelClass != String.class &&
+            labelClass != Integer.class &&
+            labelClass != EnumDesc.class) {
+            throw new IllegalArgumentException("label with illegal type found: " + label.getClass());
+        }
+    }
+
+    /*
+     * Construct test chains for labels inside switch, to handle switch repeats:
+     * switch (idx) {
+     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...
+     *     case 1 -> if (selector matches label[1]) return 1; else ...
+     *     ...
+     * }
+     */
+    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {
+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);
+        MethodHandle[] testChains = new MethodHandle[labels.length];
+        List<Object> labelsList = List.of(labels).reversed();
+
+        for (int i = 0; i < labels.length; i++) {
+            MethodHandle test = def;
+            int idx = labels.length - 1;
+            List<Object> currentLabels = labelsList.subList(0, labels.length - i);
+
+            for (int j = 0; j < currentLabels.size(); j++, idx--) {
+                Object currentLabel = currentLabels.get(j);
+                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;
+                MethodHandle currentTest;
+                if (currentLabel instanceof Class<?>) {
+                    currentTest = INSTANCEOF_CHECK;
+                } else if (currentLabel instanceof Integer) {
+                    currentTest = INTEGER_EQ_CHECK;
+                } else if (currentLabel instanceof EnumDesc) {
+                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());
+                } else {
+                    currentTest = OBJECT_EQ_CHECK;
+                }
+                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),
+                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),
+                                                   test);
+            }
+            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);
+        }
+
+        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);
+    }
+
+    /*
+     * Construct code that maps the given selector and repeat index to a case label number:
+     * if (selector == null) return -1;
+     * else return "createRepeatIndexSwitch(labels)"
+     */
+    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {
+        MethodHandle mainTest;
+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);
+        if (labels.length > 0) {
+            mainTest = createRepeatIndexSwitch(lookup, labels);
+        } else {
+            mainTest = MethodHandles.dropArguments(def, 0, int.class);
+        }
+        MethodHandle body =
+                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),
+                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),
+                                            mainTest);
+        MethodHandle switchImpl =
+                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);
+        return withIndexCheck(switchImpl, labels.length);
+    }
+
+    private static boolean integerEqCheck(Object value, Integer constant) {
+        if (value instanceof Number input && constant.intValue() == input.intValue()) {
+            return true;
+        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {
+            return true;
+        }
+
+        return false;
+    }
+
+    private static boolean isZero(int value) {
+        return value == 0;
+    }
+
+    /**
+     * Bootstrap method for linking an {@code invokedynamic} call site that
+     * implements a {@code switch} on a target of an enum type. The static
+     * arguments are used to encode the case labels associated to the switch
+     * construct, where each label can be encoded in two ways:
+     * <ul>
+     *   <li>as a {@code String} value, which represents the name of
+     *       the enum constant associated with the label</li>
+     *   <li>as a {@code Class} value, which represents the enum type
+     *       associated with a type test pattern</li>
+     * </ul>
+     * <p>
+     * The returned {@code CallSite}'s method handle will have
+     * a return type of {@code int} and accepts two parameters: the first argument
+     * will be an {@code Enum} instance ({@code target}) and the second
+     * will be {@code int} ({@code restart}).
+     * <p>
+     * If the {@code target} is {@code null}, then the method of the call site
+     * returns {@literal -1}.
+     * <p>
+     * If the {@code target} is not {@code null}, then the method of the call site
+     * returns the index of the first element in the {@code labels} array starting from
+     * the {@code restart} index matching one of the following conditions:
+     * <ul>
+     *   <li>the element is of type {@code Class} that is assignable
+     *       from the target's class; or</li>
+     *   <li>the element is of type {@code String} and equals to the target
+     *       enum constant's {@link Enum#name()}.</li>
+     * </ul>
+     * <p>
+     * If no element in the {@code labels} array matches the target, then
+     * the method of the call site return the length of the {@code labels} array.
+     * <p>
+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and
+     * the length of the {@code labels} array (inclusive),
+     * both  or an {@link IndexOutOfBoundsException} is thrown.
+     *
+     * @param lookup Represents a lookup context with the accessibility
+     *               privileges of the caller. When used with {@code invokedynamic},
+     *               this is stacked automatically by the VM.
+     * @param invocationName unused
+     * @param invocationType The invocation type of the {@code CallSite} with two parameters,
+     *                       an enum type, an {@code int}, and {@code int} as a return type.
+     * @param labels case labels - {@code String} constants and {@code Class} instances,
+     *               in any combination
+     * @return a {@code CallSite} returning the first matching element as described above
+     *
+     * @throws NullPointerException if any argument is {@code null}
+     * @throws IllegalArgumentException if any element in the labels array is null, if the
+     * invocation type is not a method type whose first parameter type is an enum type,
+     * second parameter of type {@code int} and whose return type is {@code int},
+     * or if {@code labels} contains an element that is not of type {@code String} or
+     * {@code Class} of the target enum type.
+     * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure
+     * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures
+     *
+     * @hide
+     */
+    public static CallSite enumSwitch(MethodHandles.Lookup lookup,
+                                      String invocationName,
+                                      MethodType invocationType,
+                                      Object... labels) {
+        if (invocationType.parameterCount() != 2
+            || (!invocationType.returnType().equals(int.class))
+            || invocationType.parameterType(0).isPrimitive()
+            || !invocationType.parameterType(0).isEnum()
+            || !invocationType.parameterType(1).equals(int.class))
+            throw new IllegalArgumentException("Illegal invocation type " + invocationType);
+        requireNonNull(labels);
+
+        labels = labels.clone();
+
+        Class<?> enumClass = invocationType.parameterType(0);
+        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();
+
+        MethodHandle target;
+        boolean constantsOnly = Stream.of(labels).allMatch(l -> enumClass.isAssignableFrom(EnumDesc.class));
+
+        if (labels.length > 0 && constantsOnly) {
+            //If all labels are enum constants, construct an optimized handle for repeat index 0:
+            //if (selector == null) return -1
+            //else if (idx == 0) return mappingArray[selector.ordinal()]; //mapping array created lazily
+            //else return "createRepeatIndexSwitch(labels)"
+            MethodHandle body =
+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),
+                                                MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),
+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),
+                                                                            createRepeatIndexSwitch(lookup, labels),
+                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));
+            target = MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);
+        } else {
+            target = createMethodHandleSwitch(lookup, labels);
+        }
+
+        target = target.asType(invocationType);
+        target = withIndexCheck(target, labels.length);
+
+        return new ConstantCallSite(target);
+    }
+
+    private static <E extends Enum<E>> Object convertEnumConstants(MethodHandles.Lookup lookup, Class<?> enumClassTemplate, Object label) {
+        if (label == null) {
+            throw new IllegalArgumentException("null label found");
+        }
+        Class<?> labelClass = label.getClass();
+        if (labelClass == Class.class) {
+            if (label != enumClassTemplate) {
+                throw new IllegalArgumentException("the Class label: " + label +
+                                                   ", expected the provided enum class: " + enumClassTemplate);
+            }
+            return label;
+        } else if (labelClass == String.class) {
+            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);
+        } else {
+            throw new IllegalArgumentException("label with illegal type found: " + labelClass +
+                                               ", expected label of type either String or Class");
+        }
+    }
+
+    private static <T extends Enum<T>> int mappedEnumLookup(T value, MethodHandles.Lookup lookup, Class<T> enumClass, EnumDesc<?>[] labels, EnumMap enumMap) {
+        if (enumMap.map == null) {
+            T[] constants = SharedSecrets.getJavaLangAccess().getEnumConstantsShared(enumClass);
+            int[] map = new int[constants.length];
+            int ordinal = 0;
+
+            for (T constant : constants) {
+                map[ordinal] = labels.length;
+
+                for (int i = 0; i < labels.length; i++) {
+                    if (Objects.equals(labels[i].constantName(), constant.name())) {
+                        map[ordinal] = i;
+                        break;
+                    }
+                }
+
+                ordinal++;
+            }
+        }
+        return enumMap.map[value.ordinal()];
+    }
+
+    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {
+        if (resolvedEnum.resolvedEnum == null) {
+            Object resolved;
+
+            try {
+                if (!(value instanceof Enum<?> enumValue)) {
+                    return false;
+                }
+
+                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);
+
+                if (enumValue.getDeclaringClass() != clazz) {
+                    return false;
+                }
+
+                resolved = label.resolveConstantDesc(lookup);
+            } catch (IllegalArgumentException | ReflectiveOperationException ex) {
+                resolved = SENTINEL;
+            }
+
+            resolvedEnum.resolvedEnum = resolved;
+        }
+
+        return value == resolvedEnum.resolvedEnum;
+    }
+
+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {
+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);
+
+        return MethodHandles.filterArguments(target, 1, checkIndex);
+    }
+
+    private static final class ResolvedEnumLabel {
+        @Stable
+        public Object resolvedEnum;
+    }
+
+    private static final class EnumMap {
+        @Stable
+        public int[] map;
+    }
+}
diff --git a/ojluni/src/main/java/java/math/TEST_MAPPING b/ojluni/src/main/java/java/math/TEST_MAPPING
index 10388586916..657fca83022 100644
--- a/ojluni/src/main/java/java/math/TEST_MAPPING
+++ b/ojluni/src/main/java/java/math/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.java.math"
-        },
-        {
-          "include-filter": "libcore.java.math"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_math"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/nio/Bits.java b/ojluni/src/main/java/java/nio/Bits.java
index d579a2a44b2..734a0b96327 100644
--- a/ojluni/src/main/java/java/nio/Bits.java
+++ b/ojluni/src/main/java/java/nio/Bits.java
@@ -61,500 +61,6 @@ class Bits {                            // package-private
         return Long.reverseBytes(x);
     }
 
-    // BEGIN Android-added: Getter / Setters needed due to unsupported ScopedMemoryAccess.
-    // -- get/put char --
-
-    static private char makeChar(byte b1, byte b0) {
-        return (char)((b1 << 8) | (b0 & 0xff));
-    }
-
-    static char getCharL(ByteBuffer bb, int bi) {
-        return makeChar(bb._get(bi + 1),
-                        bb._get(bi    ));
-    }
-
-    static char getCharL(long a) {
-        return makeChar(_get(a + 1),
-                        _get(a    ));
-    }
-
-    static char getCharB(ByteBuffer bb, int bi) {
-        return makeChar(bb._get(bi    ),
-                        bb._get(bi + 1));
-    }
-
-    static char getCharB(long a) {
-        return makeChar(_get(a    ),
-                        _get(a + 1));
-    }
-
-    static char getChar(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getCharB(bb, bi) : getCharL(bb, bi);
-    }
-
-    static char getChar(long a, boolean bigEndian) {
-        return bigEndian ? getCharB(a) : getCharL(a);
-    }
-
-    private static byte char1(char x) { return (byte)(x >> 8); }
-    private static byte char0(char x) { return (byte)(x     ); }
-
-    static void putCharL(ByteBuffer bb, int bi, char x) {
-        bb._put(bi    , char0(x));
-        bb._put(bi + 1, char1(x));
-    }
-
-    static void putCharL(long a, char x) {
-        _put(a    , char0(x));
-        _put(a + 1, char1(x));
-    }
-
-    static void putCharB(ByteBuffer bb, int bi, char x) {
-        bb._put(bi    , char1(x));
-        bb._put(bi + 1, char0(x));
-    }
-
-    static void putCharB(long a, char x) {
-        _put(a    , char1(x));
-        _put(a + 1, char0(x));
-    }
-
-    static void putChar(ByteBuffer bb, int bi, char x, boolean bigEndian) {
-        if (bigEndian)
-            putCharB(bb, bi, x);
-        else
-            putCharL(bb, bi, x);
-    }
-
-    static void putChar(long a, char x, boolean bigEndian) {
-        if (bigEndian)
-            putCharB(a, x);
-        else
-            putCharL(a, x);
-    }
-
-
-    // -- get/put short --
-
-    static private short makeShort(byte b1, byte b0) {
-        return (short)((b1 << 8) | (b0 & 0xff));
-    }
-
-    static short getShortL(ByteBuffer bb, int bi) {
-        return makeShort(bb._get(bi + 1),
-                         bb._get(bi    ));
-    }
-
-    static short getShortL(long a) {
-        return makeShort(_get(a + 1),
-                         _get(a    ));
-    }
-
-    static short getShortB(ByteBuffer bb, int bi) {
-        return makeShort(bb._get(bi    ),
-                         bb._get(bi + 1));
-    }
-
-    static short getShortB(long a) {
-        return makeShort(_get(a    ),
-                         _get(a + 1));
-    }
-
-    static short getShort(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getShortB(bb, bi) : getShortL(bb, bi);
-    }
-
-    static short getShort(long a, boolean bigEndian) {
-        return bigEndian ? getShortB(a) : getShortL(a);
-    }
-
-    private static byte short1(short x) { return (byte)(x >> 8); }
-    private static byte short0(short x) { return (byte)(x     ); }
-
-    static void putShortL(ByteBuffer bb, int bi, short x) {
-        bb._put(bi    , short0(x));
-        bb._put(bi + 1, short1(x));
-    }
-
-    static void putShortL(long a, short x) {
-        _put(a    , short0(x));
-        _put(a + 1, short1(x));
-    }
-
-    static void putShortB(ByteBuffer bb, int bi, short x) {
-        bb._put(bi    , short1(x));
-        bb._put(bi + 1, short0(x));
-    }
-
-    static void putShortB(long a, short x) {
-        _put(a    , short1(x));
-        _put(a + 1, short0(x));
-    }
-
-    static void putShort(ByteBuffer bb, int bi, short x, boolean bigEndian) {
-        if (bigEndian)
-            putShortB(bb, bi, x);
-        else
-            putShortL(bb, bi, x);
-    }
-
-    static void putShort(long a, short x, boolean bigEndian) {
-        if (bigEndian)
-            putShortB(a, x);
-        else
-            putShortL(a, x);
-    }
-
-
-    // -- get/put int --
-
-    static private int makeInt(byte b3, byte b2, byte b1, byte b0) {
-        return (((b3       ) << 24) |
-                ((b2 & 0xff) << 16) |
-                ((b1 & 0xff) <<  8) |
-                ((b0 & 0xff)      ));
-    }
-
-    static int getIntL(ByteBuffer bb, int bi) {
-        return makeInt(bb._get(bi + 3),
-                       bb._get(bi + 2),
-                       bb._get(bi + 1),
-                       bb._get(bi    ));
-    }
-
-    static int getIntL(long a) {
-        return makeInt(_get(a + 3),
-                       _get(a + 2),
-                       _get(a + 1),
-                       _get(a    ));
-    }
-
-    static int getIntB(ByteBuffer bb, int bi) {
-        return makeInt(bb._get(bi    ),
-                       bb._get(bi + 1),
-                       bb._get(bi + 2),
-                       bb._get(bi + 3));
-    }
-
-    static int getIntB(long a) {
-        return makeInt(_get(a    ),
-                       _get(a + 1),
-                       _get(a + 2),
-                       _get(a + 3));
-    }
-
-    static int getInt(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getIntB(bb, bi) : getIntL(bb, bi) ;
-    }
-
-    static int getInt(long a, boolean bigEndian) {
-        return bigEndian ? getIntB(a) : getIntL(a) ;
-    }
-
-    private static byte int3(int x) { return (byte)(x >> 24); }
-    private static byte int2(int x) { return (byte)(x >> 16); }
-    private static byte int1(int x) { return (byte)(x >>  8); }
-    private static byte int0(int x) { return (byte)(x      ); }
-
-    static void putIntL(ByteBuffer bb, int bi, int x) {
-        bb._put(bi + 3, int3(x));
-        bb._put(bi + 2, int2(x));
-        bb._put(bi + 1, int1(x));
-        bb._put(bi    , int0(x));
-    }
-
-    static void putIntL(long a, int x) {
-        _put(a + 3, int3(x));
-        _put(a + 2, int2(x));
-        _put(a + 1, int1(x));
-        _put(a    , int0(x));
-    }
-
-    static void putIntB(ByteBuffer bb, int bi, int x) {
-        bb._put(bi    , int3(x));
-        bb._put(bi + 1, int2(x));
-        bb._put(bi + 2, int1(x));
-        bb._put(bi + 3, int0(x));
-    }
-
-    static void putIntB(long a, int x) {
-        _put(a    , int3(x));
-        _put(a + 1, int2(x));
-        _put(a + 2, int1(x));
-        _put(a + 3, int0(x));
-    }
-
-    static void putInt(ByteBuffer bb, int bi, int x, boolean bigEndian) {
-        if (bigEndian)
-            putIntB(bb, bi, x);
-        else
-            putIntL(bb, bi, x);
-    }
-
-    static void putInt(long a, int x, boolean bigEndian) {
-        if (bigEndian)
-            putIntB(a, x);
-        else
-            putIntL(a, x);
-    }
-
-
-    // -- get/put long --
-
-    static private long makeLong(byte b7, byte b6, byte b5, byte b4,
-                                 byte b3, byte b2, byte b1, byte b0)
-    {
-        return ((((long)b7       ) << 56) |
-                (((long)b6 & 0xff) << 48) |
-                (((long)b5 & 0xff) << 40) |
-                (((long)b4 & 0xff) << 32) |
-                (((long)b3 & 0xff) << 24) |
-                (((long)b2 & 0xff) << 16) |
-                (((long)b1 & 0xff) <<  8) |
-                (((long)b0 & 0xff)      ));
-    }
-
-    static long getLongL(ByteBuffer bb, int bi) {
-        return makeLong(bb._get(bi + 7),
-                        bb._get(bi + 6),
-                        bb._get(bi + 5),
-                        bb._get(bi + 4),
-                        bb._get(bi + 3),
-                        bb._get(bi + 2),
-                        bb._get(bi + 1),
-                        bb._get(bi    ));
-    }
-
-    static long getLongL(long a) {
-        return makeLong(_get(a + 7),
-                        _get(a + 6),
-                        _get(a + 5),
-                        _get(a + 4),
-                        _get(a + 3),
-                        _get(a + 2),
-                        _get(a + 1),
-                        _get(a    ));
-    }
-
-    static long getLongB(ByteBuffer bb, int bi) {
-        return makeLong(bb._get(bi    ),
-                        bb._get(bi + 1),
-                        bb._get(bi + 2),
-                        bb._get(bi + 3),
-                        bb._get(bi + 4),
-                        bb._get(bi + 5),
-                        bb._get(bi + 6),
-                        bb._get(bi + 7));
-    }
-
-    static long getLongB(long a) {
-        return makeLong(_get(a    ),
-                        _get(a + 1),
-                        _get(a + 2),
-                        _get(a + 3),
-                        _get(a + 4),
-                        _get(a + 5),
-                        _get(a + 6),
-                        _get(a + 7));
-    }
-
-    static long getLong(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getLongB(bb, bi) : getLongL(bb, bi);
-    }
-
-    static long getLong(long a, boolean bigEndian) {
-        return bigEndian ? getLongB(a) : getLongL(a);
-    }
-
-    private static byte long7(long x) { return (byte)(x >> 56); }
-    private static byte long6(long x) { return (byte)(x >> 48); }
-    private static byte long5(long x) { return (byte)(x >> 40); }
-    private static byte long4(long x) { return (byte)(x >> 32); }
-    private static byte long3(long x) { return (byte)(x >> 24); }
-    private static byte long2(long x) { return (byte)(x >> 16); }
-    private static byte long1(long x) { return (byte)(x >>  8); }
-    private static byte long0(long x) { return (byte)(x      ); }
-
-    static void putLongL(ByteBuffer bb, int bi, long x) {
-        bb._put(bi + 7, long7(x));
-        bb._put(bi + 6, long6(x));
-        bb._put(bi + 5, long5(x));
-        bb._put(bi + 4, long4(x));
-        bb._put(bi + 3, long3(x));
-        bb._put(bi + 2, long2(x));
-        bb._put(bi + 1, long1(x));
-        bb._put(bi    , long0(x));
-    }
-
-    static void putLongL(long a, long x) {
-        _put(a + 7, long7(x));
-        _put(a + 6, long6(x));
-        _put(a + 5, long5(x));
-        _put(a + 4, long4(x));
-        _put(a + 3, long3(x));
-        _put(a + 2, long2(x));
-        _put(a + 1, long1(x));
-        _put(a    , long0(x));
-    }
-
-    static void putLongB(ByteBuffer bb, int bi, long x) {
-        bb._put(bi    , long7(x));
-        bb._put(bi + 1, long6(x));
-        bb._put(bi + 2, long5(x));
-        bb._put(bi + 3, long4(x));
-        bb._put(bi + 4, long3(x));
-        bb._put(bi + 5, long2(x));
-        bb._put(bi + 6, long1(x));
-        bb._put(bi + 7, long0(x));
-    }
-
-    static void putLongB(long a, long x) {
-        _put(a    , long7(x));
-        _put(a + 1, long6(x));
-        _put(a + 2, long5(x));
-        _put(a + 3, long4(x));
-        _put(a + 4, long3(x));
-        _put(a + 5, long2(x));
-        _put(a + 6, long1(x));
-        _put(a + 7, long0(x));
-    }
-
-    static void putLong(ByteBuffer bb, int bi, long x, boolean bigEndian) {
-        if (bigEndian)
-            putLongB(bb, bi, x);
-        else
-            putLongL(bb, bi, x);
-    }
-
-    static void putLong(long a, long x, boolean bigEndian) {
-        if (bigEndian)
-            putLongB(a, x);
-        else
-            putLongL(a, x);
-    }
-
-
-    // -- get/put float --
-
-    static float getFloatL(ByteBuffer bb, int bi) {
-        return Float.intBitsToFloat(getIntL(bb, bi));
-    }
-
-    static float getFloatL(long a) {
-        return Float.intBitsToFloat(getIntL(a));
-    }
-
-    static float getFloatB(ByteBuffer bb, int bi) {
-        return Float.intBitsToFloat(getIntB(bb, bi));
-    }
-
-    static float getFloatB(long a) {
-        return Float.intBitsToFloat(getIntB(a));
-    }
-
-    static float getFloat(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getFloatB(bb, bi) : getFloatL(bb, bi);
-    }
-
-    static float getFloat(long a, boolean bigEndian) {
-        return bigEndian ? getFloatB(a) : getFloatL(a);
-    }
-
-    static void putFloatL(ByteBuffer bb, int bi, float x) {
-        putIntL(bb, bi, Float.floatToRawIntBits(x));
-    }
-
-    static void putFloatL(long a, float x) {
-        putIntL(a, Float.floatToRawIntBits(x));
-    }
-
-    static void putFloatB(ByteBuffer bb, int bi, float x) {
-        putIntB(bb, bi, Float.floatToRawIntBits(x));
-    }
-
-    static void putFloatB(long a, float x) {
-        putIntB(a, Float.floatToRawIntBits(x));
-    }
-
-    static void putFloat(ByteBuffer bb, int bi, float x, boolean bigEndian) {
-        if (bigEndian)
-            putFloatB(bb, bi, x);
-        else
-            putFloatL(bb, bi, x);
-    }
-
-    static void putFloat(long a, float x, boolean bigEndian) {
-        if (bigEndian)
-            putFloatB(a, x);
-        else
-            putFloatL(a, x);
-    }
-
-
-    // -- get/put double --
-
-    static double getDoubleL(ByteBuffer bb, int bi) {
-        return Double.longBitsToDouble(getLongL(bb, bi));
-    }
-
-    static double getDoubleL(long a) {
-        return Double.longBitsToDouble(getLongL(a));
-    }
-
-    static double getDoubleB(ByteBuffer bb, int bi) {
-        return Double.longBitsToDouble(getLongB(bb, bi));
-    }
-
-    static double getDoubleB(long a) {
-        return Double.longBitsToDouble(getLongB(a));
-    }
-
-    static double getDouble(ByteBuffer bb, int bi, boolean bigEndian) {
-        return bigEndian ? getDoubleB(bb, bi) : getDoubleL(bb, bi);
-    }
-
-    static double getDouble(long a, boolean bigEndian) {
-        return bigEndian ? getDoubleB(a) : getDoubleL(a);
-    }
-
-    static void putDoubleL(ByteBuffer bb, int bi, double x) {
-        putLongL(bb, bi, Double.doubleToRawLongBits(x));
-    }
-
-    static void putDoubleL(long a, double x) {
-        putLongL(a, Double.doubleToRawLongBits(x));
-    }
-
-    static void putDoubleB(ByteBuffer bb, int bi, double x) {
-        putLongB(bb, bi, Double.doubleToRawLongBits(x));
-    }
-
-    static void putDoubleB(long a, double x) {
-        putLongB(a, Double.doubleToRawLongBits(x));
-    }
-
-    static void putDouble(ByteBuffer bb, int bi, double x, boolean bigEndian) {
-        if (bigEndian)
-            putDoubleB(bb, bi, x);
-        else
-            putDoubleL(bb, bi, x);
-    }
-
-    static void putDouble(long a, double x, boolean bigEndian) {
-        if (bigEndian)
-            putDoubleB(a, x);
-        else
-            putDoubleL(a, x);
-    }
-
-    private static byte _get(long a) {
-        return UNSAFE.getByte(a);
-    }
-
-    private static void _put(long a, byte b) {
-        UNSAFE.putByte(a, b);
-    }
-    // END Android-added: Getter / Setters needed due to unsupported ScopedMemoryAccess.
 
     // -- Unsafe access --
 
diff --git a/ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template b/ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template
index f6de926c812..735849712bc 100644
--- a/ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template
+++ b/ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template
@@ -443,16 +443,16 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public char getChar() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);
-        return Bits.getChar(this, ix(nextGetIndex(2)), bigEndian);
+        return getCharUnchecked(nextGetIndex(2));
     }
 
     @Override
     public char getChar(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);
-        return Bits.getChar(this, ix(checkIndex(i, 2)), bigEndian);
+        return getCharUnchecked(checkIndex(i, 2));
     }
 
 #end[rw]
@@ -462,9 +462,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);
-        Bits.putChar(this, ix(nextPutIndex(2)), x, bigEndian);
+        putCharUnchecked(nextPutIndex(2), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -474,7 +474,13 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     char getCharUnchecked(int i) {
-        return Bits.getChar(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+        if (bigEndian) {
+            return (char) ((src[ix] << 8) | (src[ix + 1] & 0xff));
+        } else {
+            return (char) ((src[ix + 1] << 8) | (src[ix] & 0xff));
+        }
     }
 
     @Override
@@ -488,9 +494,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SSCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
-        Bits.putChar(this, ix(checkIndex(i, 2)), x, bigEndian);
+        putCharUnchecked(checkIndex(i, 2), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -500,7 +506,16 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putCharUnchecked(int i, char x) {
-        Bits.putChar(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 8) & 0xff);
+            dst[ix  ] = (byte) ((x >> 0) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x >> 0) & 0xff);
+            dst[ix  ] = (byte) ((x >> 8) & 0xff);
+        }
     }
 
     @Override
@@ -547,16 +562,16 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public short getShort() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);
-        return Bits.getShort(this, ix(nextGetIndex(2)), bigEndian);
+        return getShortUnchecked(nextGetIndex(2));
     }
 
     @Override
     public short getShort(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);
-        return Bits.getShort(this, ix(checkIndex(i, 2)), bigEndian);
+        return getShortUnchecked(checkIndex(i, 2));
     }
 
 #end[rw]
@@ -564,7 +579,13 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     short getShortUnchecked(int i) {
-        return Bits.getShort(this, ix(i), bigEndian);
+        byte[] src = hb;
+        int ix = ix(i);
+        if (bigEndian) {
+            return (short) ((src[ix] << 8) | (src[ix + 1] & 0xff));
+        } else {
+            return (short) ((src[ix + 1] << 8) | (src[ix] & 0xff));
+        }
     }
 
     @Override
@@ -578,9 +599,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);
-        Bits.putShort(this, ix(nextPutIndex(2)), x, bigEndian);
+        putShortUnchecked(nextPutIndex(2), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -590,9 +611,11 @@ final class Heap$Type$Buffer$RW$
     @Override
     public $Type$Buffer putShort(int i, short x) {
 #if[rw]
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
+        throwIfReadOnly();
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
-        Bits.putShort(this, ix(checkIndex(i, 2)), x, bigEndian);
+        putShortUnchecked(checkIndex(i, 2), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -602,7 +625,15 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putShortUnchecked(int i, short x) {
-        Bits.putShort(this, ix(i), x, bigEndian);
+        byte[] dst = hb;
+        int ix = ix(i);
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 8) & 0xff);
+            dst[ix  ] = (byte) ((x >> 0) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x >> 0) & 0xff);
+            dst[ix  ] = (byte) ((x >> 8) & 0xff);
+        }
     }
 
     @Override
@@ -649,16 +680,16 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public int getInt() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);
-        return Bits.getInt(this, ix(nextGetIndex(4)), bigEndian);
+        return getIntUnchecked(nextGetIndex(4));
     }
 
     @Override
     public int getInt(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);
-        return Bits.getInt(this, ix(checkIndex(i, 4)), bigEndian);
+        return getIntUnchecked(checkIndex(i, 4));
     }
 
 #end[rw]
@@ -666,7 +697,19 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     int getIntUnchecked(int i) {
-        return Bits.getInt(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+        if (bigEndian) {
+            return (((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix  ] & 0xff)      ));
+        } else {
+            return (((src[ix++] & 0xff)      ) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix  ] & 0xff) << 24));
+        }
     }
 
     @Override
@@ -680,9 +723,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);
-        Bits.putInt(this, ix(nextPutIndex(4)), x, bigEndian);
+        putIntUnchecked(nextPutIndex(4), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -694,9 +737,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);
-        Bits.putInt(this, ix(checkIndex(i, 4)), x, bigEndian);
+        putIntUnchecked(checkIndex(i, 4), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -706,7 +749,20 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putIntUnchecked(int i, int x) {
-        Bits.putInt(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 24) & 0xff);
+            dst[ix++] = (byte) ((x >> 16) & 0xff);
+            dst[ix++] = (byte) ((x >>  8) & 0xff);
+            dst[ix  ] = (byte) ((x      ) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x      ) & 0xff);
+            dst[ix++] = (byte) ((x >>  8) & 0xff);
+            dst[ix++] = (byte) ((x >> 16) & 0xff);
+            dst[ix  ] = (byte) ((x >> 24) & 0xff);
+        }
     }
 
     @Override
@@ -752,16 +808,16 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public long getLong() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);
-        return Bits.getLong(this, ix(nextGetIndex(8)), bigEndian);
+        return getLongUnchecked(nextGetIndex(8));
     }
 
     @Override
     public long getLong(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);
-        return Bits.getLong(this, ix(checkIndex(i, 8)), bigEndian);
+        return getLongUnchecked(checkIndex(i, 8));
     }
 
 #end[rw]
@@ -769,7 +825,30 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     long getLongUnchecked(int i) {
-        return Bits.getLong(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+
+        if (bigEndian) {
+            int h = ((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) <<  0);
+            int l = ((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix  ] & 0xff) <<  0);
+            return (((long) h) << 32L) | (((long) l) & 0xffffffffL);
+        } else {
+            int l = ((src[ix++] & 0xff) <<  0) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) << 24);
+            int h = ((src[ix++] & 0xff) <<  0) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix  ] & 0xff) << 24);
+            return (((long) h) << 32L) | (((long) l) & 0xffffffffL);
+        }
     }
 
     @Override
@@ -783,9 +862,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);
-        Bits.putLong(this, ix(nextPutIndex(8)), x, bigEndian);
+        putLongUnchecked(nextPutIndex(8), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -797,9 +876,9 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);
-        Bits.putLong(this, ix(checkIndex(i, 8)), x, bigEndian);
+        putLongUnchecked(checkIndex(i, 8), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -809,7 +888,31 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putLongUnchecked(int i, long x) {
-        Bits.putLong(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+        if (bigEndian) {
+            int t = (int) (x >> 32);
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            t = (int) x;
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix  ] = (byte) ((t >>  0) & 0xff);
+        } else {
+            int t = (int) x;
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            t = (int) (x >> 32);
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix  ] = (byte) ((t >> 24) & 0xff);
+        }
     }
 
     @Override
@@ -856,18 +959,18 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public float getFloat() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);
         // return Float.intBitsToFloat(x);
-        return Bits.getFloat(this, ix(nextGetIndex(4)), bigEndian);
+        return getFloatUnchecked(nextGetIndex(4));
     }
 
     @Override
     public float getFloat(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);
         // return Float.intBitsToFloat(x);
-        return Bits.getFloat(this, ix(checkIndex(i, 4)), bigEndian);
+        return getFloatUnchecked(checkIndex(i, 4));
     }
 
 #end[rw]
@@ -875,7 +978,7 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     float getFloatUnchecked(int i) {
-        return Bits.getFloat(this, ix(i), bigEndian);
+        return Float.intBitsToFloat(getIntUnchecked(i));
     }
 
     @Override
@@ -889,10 +992,10 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int y = Float.floatToRawIntBits(x);
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);
-        Bits.putFloat(this, ix(nextPutIndex(4)), x, bigEndian);
+        putFloatUnchecked(nextPutIndex(4), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -904,10 +1007,10 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int y = Float.floatToRawIntBits(x);
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);
-        Bits.putFloat(this, ix(checkIndex(i, 4)), x, bigEndian);
+        putFloatUnchecked(checkIndex(i, 4), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -917,7 +1020,7 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putFloatUnchecked(int i, float x) {
-        Bits.putFloat(this, ix(i), x, bigEndian);
+        putIntUnchecked(i, Float.floatToRawIntBits(x));
     }
 
     @Override
@@ -964,18 +1067,18 @@ final class Heap$Type$Buffer$RW$
 
     @Override
     public double getDouble() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);
         // return Double.longBitsToDouble(x);
-        return Bits.getDouble(this, ix(nextGetIndex(8)), bigEndian);
+        return getDoubleUnchecked(nextGetIndex(8));
     }
 
     @Override
     public double getDouble(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);
         // return Double.longBitsToDouble(x);
-        return Bits.getDouble(this, ix(checkIndex(i, 8)), bigEndian);
+        return getDoubleUnchecked(checkIndex(i, 8));
     }
 
 #end[rw]
@@ -983,7 +1086,7 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     double getDoubleUnchecked(int i) {
-        return Bits.getDouble(this, ix(i), bigEndian);
+        return Double.longBitsToDouble(getLongUnchecked(i));
     }
 
     @Override
@@ -997,10 +1100,10 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long y = Double.doubleToRawLongBits(x);
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);
-        Bits.putDouble(this, ix(nextPutIndex(8)), x, bigEndian);
+        putDoubleUnchecked(nextPutIndex(8), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -1012,10 +1115,10 @@ final class Heap$Type$Buffer$RW$
 #if[rw]
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long y = Double.doubleToRawLongBits(x);
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);
-        Bits.putDouble(this, ix(checkIndex(i, 8)), x, bigEndian);
+        putDoubleUnchecked(checkIndex(i, 8), x);
         return this;
 #else[rw]
         throw new ReadOnlyBufferException();
@@ -1025,7 +1128,7 @@ final class Heap$Type$Buffer$RW$
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putDoubleUnchecked(int i, double x) {
-        Bits.putDouble(this, ix(i), x, bigEndian);
+        putLongUnchecked(i, Double.doubleToRawLongBits(x));
     }
 
     @Override
diff --git a/ojluni/src/main/java/java/nio/HeapByteBuffer.java b/ojluni/src/main/java/java/nio/HeapByteBuffer.java
index f3d35c70a43..8f9c776139d 100644
--- a/ojluni/src/main/java/java/nio/HeapByteBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapByteBuffer.java
@@ -443,16 +443,16 @@ final class HeapByteBuffer
 
     @Override
     public char getChar() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);
-        return Bits.getChar(this, ix(nextGetIndex(2)), bigEndian);
+        return getCharUnchecked(nextGetIndex(2));
     }
 
     @Override
     public char getChar(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);
-        return Bits.getChar(this, ix(checkIndex(i, 2)), bigEndian);
+        return getCharUnchecked(checkIndex(i, 2));
     }
 
 
@@ -462,9 +462,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);
-        Bits.putChar(this, ix(nextPutIndex(2)), x, bigEndian);
+        putCharUnchecked(nextPutIndex(2), x);
         return this;
 
 
@@ -474,7 +474,13 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     char getCharUnchecked(int i) {
-        return Bits.getChar(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+        if (bigEndian) {
+            return (char) ((src[ix] << 8) | (src[ix + 1] & 0xff));
+        } else {
+            return (char) ((src[ix + 1] << 8) | (src[ix] & 0xff));
+        }
     }
 
     @Override
@@ -488,9 +494,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SSCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
-        Bits.putChar(this, ix(checkIndex(i, 2)), x, bigEndian);
+        putCharUnchecked(checkIndex(i, 2), x);
         return this;
 
 
@@ -500,7 +506,16 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putCharUnchecked(int i, char x) {
-        Bits.putChar(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 8) & 0xff);
+            dst[ix  ] = (byte) ((x >> 0) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x >> 0) & 0xff);
+            dst[ix  ] = (byte) ((x >> 8) & 0xff);
+        }
     }
 
     @Override
@@ -547,16 +562,16 @@ final class HeapByteBuffer
 
     @Override
     public short getShort() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);
-        return Bits.getShort(this, ix(nextGetIndex(2)), bigEndian);
+        return getShortUnchecked(nextGetIndex(2));
     }
 
     @Override
     public short getShort(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);
-        return Bits.getShort(this, ix(checkIndex(i, 2)), bigEndian);
+        return getShortUnchecked(checkIndex(i, 2));
     }
 
 
@@ -564,7 +579,13 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     short getShortUnchecked(int i) {
-        return Bits.getShort(this, ix(i), bigEndian);
+        byte[] src = hb;
+        int ix = ix(i);
+        if (bigEndian) {
+            return (short) ((src[ix] << 8) | (src[ix + 1] & 0xff));
+        } else {
+            return (short) ((src[ix + 1] << 8) | (src[ix] & 0xff));
+        }
     }
 
     @Override
@@ -578,9 +599,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);
-        Bits.putShort(this, ix(nextPutIndex(2)), x, bigEndian);
+        putShortUnchecked(nextPutIndex(2), x);
         return this;
 
 
@@ -590,9 +611,11 @@ final class HeapByteBuffer
     @Override
     public ByteBuffer putShort(int i, short x) {
 
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
+        throwIfReadOnly();
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
-        Bits.putShort(this, ix(checkIndex(i, 2)), x, bigEndian);
+        putShortUnchecked(checkIndex(i, 2), x);
         return this;
 
 
@@ -602,7 +625,15 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putShortUnchecked(int i, short x) {
-        Bits.putShort(this, ix(i), x, bigEndian);
+        byte[] dst = hb;
+        int ix = ix(i);
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 8) & 0xff);
+            dst[ix  ] = (byte) ((x >> 0) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x >> 0) & 0xff);
+            dst[ix  ] = (byte) ((x >> 8) & 0xff);
+        }
     }
 
     @Override
@@ -649,16 +680,16 @@ final class HeapByteBuffer
 
     @Override
     public int getInt() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);
-        return Bits.getInt(this, ix(nextGetIndex(4)), bigEndian);
+        return getIntUnchecked(nextGetIndex(4));
     }
 
     @Override
     public int getInt(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);
-        return Bits.getInt(this, ix(checkIndex(i, 4)), bigEndian);
+        return getIntUnchecked(checkIndex(i, 4));
     }
 
 
@@ -666,7 +697,19 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     int getIntUnchecked(int i) {
-        return Bits.getInt(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+        if (bigEndian) {
+            return (((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix  ] & 0xff)      ));
+        } else {
+            return (((src[ix++] & 0xff)      ) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix  ] & 0xff) << 24));
+        }
     }
 
     @Override
@@ -680,9 +723,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);
-        Bits.putInt(this, ix(nextPutIndex(4)), x, bigEndian);
+        putIntUnchecked(nextPutIndex(4), x);
         return this;
 
 
@@ -694,9 +737,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);
-        Bits.putInt(this, ix(checkIndex(i, 4)), x, bigEndian);
+        putIntUnchecked(checkIndex(i, 4), x);
         return this;
 
 
@@ -706,7 +749,20 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putIntUnchecked(int i, int x) {
-        Bits.putInt(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+
+        if (bigEndian) {
+            dst[ix++] = (byte) ((x >> 24) & 0xff);
+            dst[ix++] = (byte) ((x >> 16) & 0xff);
+            dst[ix++] = (byte) ((x >>  8) & 0xff);
+            dst[ix  ] = (byte) ((x      ) & 0xff);
+        } else {
+            dst[ix++] = (byte) ((x      ) & 0xff);
+            dst[ix++] = (byte) ((x >>  8) & 0xff);
+            dst[ix++] = (byte) ((x >> 16) & 0xff);
+            dst[ix  ] = (byte) ((x >> 24) & 0xff);
+        }
     }
 
     @Override
@@ -752,16 +808,16 @@ final class HeapByteBuffer
 
     @Override
     public long getLong() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);
-        return Bits.getLong(this, ix(nextGetIndex(8)), bigEndian);
+        return getLongUnchecked(nextGetIndex(8));
     }
 
     @Override
     public long getLong(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);
-        return Bits.getLong(this, ix(checkIndex(i, 8)), bigEndian);
+        return getLongUnchecked(checkIndex(i, 8));
     }
 
 
@@ -769,7 +825,30 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     long getLongUnchecked(int i) {
-        return Bits.getLong(this, ix(i), bigEndian);
+        int ix = ix(i);
+        byte[] src = hb;
+
+        if (bigEndian) {
+            int h = ((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) <<  0);
+            int l = ((src[ix++] & 0xff) << 24) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix  ] & 0xff) <<  0);
+            return (((long) h) << 32L) | (((long) l) & 0xffffffffL);
+        } else {
+            int l = ((src[ix++] & 0xff) <<  0) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix++] & 0xff) << 24);
+            int h = ((src[ix++] & 0xff) <<  0) |
+                    ((src[ix++] & 0xff) <<  8) |
+                    ((src[ix++] & 0xff) << 16) |
+                    ((src[ix  ] & 0xff) << 24);
+            return (((long) h) << 32L) | (((long) l) & 0xffffffffL);
+        }
     }
 
     @Override
@@ -783,9 +862,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);
-        Bits.putLong(this, ix(nextPutIndex(8)), x, bigEndian);
+        putLongUnchecked(nextPutIndex(8), x);
         return this;
 
 
@@ -797,9 +876,9 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);
-        Bits.putLong(this, ix(checkIndex(i, 8)), x, bigEndian);
+        putLongUnchecked(checkIndex(i, 8), x);
         return this;
 
 
@@ -809,7 +888,31 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putLongUnchecked(int i, long x) {
-        Bits.putLong(this, ix(i), x, bigEndian);
+        int ix = ix(i);
+        byte[] dst = hb;
+        if (bigEndian) {
+            int t = (int) (x >> 32);
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            t = (int) x;
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix  ] = (byte) ((t >>  0) & 0xff);
+        } else {
+            int t = (int) x;
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix++] = (byte) ((t >> 24) & 0xff);
+            t = (int) (x >> 32);
+            dst[ix++] = (byte) ((t >>  0) & 0xff);
+            dst[ix++] = (byte) ((t >>  8) & 0xff);
+            dst[ix++] = (byte) ((t >> 16) & 0xff);
+            dst[ix  ] = (byte) ((t >> 24) & 0xff);
+        }
     }
 
     @Override
@@ -856,18 +959,18 @@ final class HeapByteBuffer
 
     @Override
     public float getFloat() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);
         // return Float.intBitsToFloat(x);
-        return Bits.getFloat(this, ix(nextGetIndex(4)), bigEndian);
+        return getFloatUnchecked(nextGetIndex(4));
     }
 
     @Override
     public float getFloat(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);
         // return Float.intBitsToFloat(x);
-        return Bits.getFloat(this, ix(checkIndex(i, 4)), bigEndian);
+        return getFloatUnchecked(checkIndex(i, 4));
     }
 
 
@@ -875,7 +978,7 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     float getFloatUnchecked(int i) {
-        return Bits.getFloat(this, ix(i), bigEndian);
+        return Float.intBitsToFloat(getIntUnchecked(i));
     }
 
     @Override
@@ -889,10 +992,10 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int y = Float.floatToRawIntBits(x);
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);
-        Bits.putFloat(this, ix(nextPutIndex(4)), x, bigEndian);
+        putFloatUnchecked(nextPutIndex(4), x);
         return this;
 
 
@@ -904,10 +1007,10 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // int y = Float.floatToRawIntBits(x);
         // SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);
-        Bits.putFloat(this, ix(checkIndex(i, 4)), x, bigEndian);
+        putFloatUnchecked(checkIndex(i, 4), x);
         return this;
 
 
@@ -917,7 +1020,7 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putFloatUnchecked(int i, float x) {
-        Bits.putFloat(this, ix(i), x, bigEndian);
+        putIntUnchecked(i, Float.floatToRawIntBits(x));
     }
 
     @Override
@@ -964,18 +1067,18 @@ final class HeapByteBuffer
 
     @Override
     public double getDouble() {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);
         // return Double.longBitsToDouble(x);
-        return Bits.getDouble(this, ix(nextGetIndex(8)), bigEndian);
+        return getDoubleUnchecked(nextGetIndex(8));
     }
 
     @Override
     public double getDouble(int i) {
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);
         // return Double.longBitsToDouble(x);
-        return Bits.getDouble(this, ix(checkIndex(i, 8)), bigEndian);
+        return getDoubleUnchecked(checkIndex(i, 8));
     }
 
 
@@ -983,7 +1086,7 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     double getDoubleUnchecked(int i) {
-        return Bits.getDouble(this, ix(i), bigEndian);
+        return Double.longBitsToDouble(getLongUnchecked(i));
     }
 
     @Override
@@ -997,10 +1100,10 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long y = Double.doubleToRawLongBits(x);
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);
-        Bits.putDouble(this, ix(nextPutIndex(8)), x, bigEndian);
+        putDoubleUnchecked(nextPutIndex(8), x);
         return this;
 
 
@@ -1012,10 +1115,10 @@ final class HeapByteBuffer
 
         // Android-added: Merge the Read-only buffer class with this Read-Write buffer class.
         throwIfReadOnly();
-        // Android-changed: Use Bits instead of ScopedMemoryAccess to be supported yet.
+        // Android-changed: Avoid unsupported ScopedMemoryAccess.
         // long y = Double.doubleToRawLongBits(x);
         // SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);
-        Bits.putDouble(this, ix(checkIndex(i, 8)), x, bigEndian);
+        putDoubleUnchecked(checkIndex(i, 8), x);
         return this;
 
 
@@ -1025,7 +1128,7 @@ final class HeapByteBuffer
     // BEGIN Android-added: {get,put}*Unchecked() accessors.
     @Override
     void putDoubleUnchecked(int i, double x) {
-        Bits.putDouble(this, ix(i), x, bigEndian);
+        putLongUnchecked(i, Double.doubleToRawLongBits(x));
     }
 
     @Override
diff --git a/ojluni/src/main/java/java/nio/HeapCharBuffer.java b/ojluni/src/main/java/java/nio/HeapCharBuffer.java
index 64c676821ce..d7c8d677dde 100644
--- a/ojluni/src/main/java/java/nio/HeapCharBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapCharBuffer.java
@@ -1050,6 +1050,109 @@ final class HeapCharBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/HeapDoubleBuffer.java b/ojluni/src/main/java/java/nio/HeapDoubleBuffer.java
index 477d7230c6e..b71acb418a7 100644
--- a/ojluni/src/main/java/java/nio/HeapDoubleBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapDoubleBuffer.java
@@ -1080,6 +1080,109 @@ final class HeapDoubleBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/HeapFloatBuffer.java b/ojluni/src/main/java/java/nio/HeapFloatBuffer.java
index b7b8941fb62..e21de0ccbcc 100644
--- a/ojluni/src/main/java/java/nio/HeapFloatBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapFloatBuffer.java
@@ -1080,6 +1080,109 @@ final class HeapFloatBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/HeapIntBuffer.java b/ojluni/src/main/java/java/nio/HeapIntBuffer.java
index 31354a08dee..df894a7ab54 100644
--- a/ojluni/src/main/java/java/nio/HeapIntBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapIntBuffer.java
@@ -1080,6 +1080,109 @@ final class HeapIntBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/HeapLongBuffer.java b/ojluni/src/main/java/java/nio/HeapLongBuffer.java
index 4d05e39474c..621d7382506 100644
--- a/ojluni/src/main/java/java/nio/HeapLongBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapLongBuffer.java
@@ -1080,6 +1080,109 @@ final class HeapLongBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/HeapShortBuffer.java b/ojluni/src/main/java/java/nio/HeapShortBuffer.java
index f48ea610c7d..42f5053e0cd 100644
--- a/ojluni/src/main/java/java/nio/HeapShortBuffer.java
+++ b/ojluni/src/main/java/java/nio/HeapShortBuffer.java
@@ -1080,6 +1080,109 @@ final class HeapShortBuffer
 
 
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 
 
diff --git a/ojluni/src/main/java/java/nio/channels/TEST_MAPPING b/ojluni/src/main/java/java/nio/channels/TEST_MAPPING
deleted file mode 100644
index dfb741cebd8..00000000000
--- a/ojluni/src/main/java/java/nio/channels/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.nio.channels"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.nio.channels"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/nio/channels/spi/TEST_MAPPING b/ojluni/src/main/java/java/nio/channels/spi/TEST_MAPPING
index 7974b9ae4b9..8951eb8a9bd 100644
--- a/ojluni/src/main/java/java/nio/channels/spi/TEST_MAPPING
+++ b/ojluni/src/main/java/java/nio/channels/spi/TEST_MAPPING
@@ -3,16 +3,10 @@
     {
       "name": "CtsLibcoreTestCases",
       "options": [
-        {
-          "include-filter": "libcore.java.nio.channels.spi"
-        },
         {
           "include-filter": "org.apache.harmony.nio.tests.java.nio.channels.spi"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.nio.channels.spi"
         }
       ]
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/main/java/java/nio/charset/TEST_MAPPING b/ojluni/src/main/java/java/nio/charset/TEST_MAPPING
deleted file mode 100644
index 5fa13f1b0ae..00000000000
--- a/ojluni/src/main/java/java/nio/charset/TEST_MAPPING
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-  "imports": [
-    {
-      "path": "libcore/luni/src/main/java/java/nio/charset"
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/nio/file/TEST_MAPPING b/ojluni/src/main/java/java/nio/file/TEST_MAPPING
deleted file mode 100644
index 24bd29ae0ca..00000000000
--- a/ojluni/src/main/java/java/nio/file/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.nio.file"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/nio/file/attribute/TEST_MAPPING b/ojluni/src/main/java/java/nio/file/attribute/TEST_MAPPING
index 6c130c4f350..5d25a3b9349 100644
--- a/ojluni/src/main/java/java/nio/file/attribute/TEST_MAPPING
+++ b/ojluni/src/main/java/java/nio/file/attribute/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.nio.file.attribute"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_nio_file_attribute"
     }
diff --git a/ojluni/src/main/java/java/nio/file/spi/TEST_MAPPING b/ojluni/src/main/java/java/nio/file/spi/TEST_MAPPING
deleted file mode 100644
index 632f30c3e98..00000000000
--- a/ojluni/src/main/java/java/nio/file/spi/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.nio.file.spi"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/security/TEST_MAPPING b/ojluni/src/main/java/java/security/TEST_MAPPING
index 53b281876f2..02385df5780 100644
--- a/ojluni/src/main/java/java/security/TEST_MAPPING
+++ b/ojluni/src/main/java/java/security/TEST_MAPPING
@@ -1,30 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security"
-        },
-        {
-          "include-filter": "org.apache.harmony.security.tests.java.security"
-        },
-        {
-          "include-filter": "tests.targets.security"
-        },
-        {
-          "include-filter": "com.android.org.conscrypt.java.security"
-        },
-        {
-          "include-filter": "tests.java.security"
-        },
-        {
-          "include-filter": "tests.security"
-        },
-        {
-          "include-filter": "libcore.java.security"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_security"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/security/acl/TEST_MAPPING b/ojluni/src/main/java/java/security/acl/TEST_MAPPING
deleted file mode 100644
index 864ca2885c8..00000000000
--- a/ojluni/src/main/java/java/security/acl/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "tests.security.acl"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/security/cert/TEST_MAPPING b/ojluni/src/main/java/java/security/cert/TEST_MAPPING
index 0c96cc48208..f84f7042354 100644
--- a/ojluni/src/main/java/java/security/cert/TEST_MAPPING
+++ b/ojluni/src/main/java/java/security/cert/TEST_MAPPING
@@ -1,22 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "tests.security.cert"
-        },
-        {
-          "include-filter": "tests.targets.security.cert"
-        },
-        {
-          "include-filter": "com.android.org.conscrypt.java.security.cert"
-        },
-        {
-          "include-filter": "libcore.java.security.cert"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_security_cert"
     }
diff --git a/ojluni/src/main/java/java/security/interfaces/TEST_MAPPING b/ojluni/src/main/java/java/security/interfaces/TEST_MAPPING
deleted file mode 100644
index 3c28d5162bc..00000000000
--- a/ojluni/src/main/java/java/security/interfaces/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "tests.security.interfaces"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/security/spec/TEST_MAPPING b/ojluni/src/main/java/java/security/spec/TEST_MAPPING
deleted file mode 100644
index f54aac609a8..00000000000
--- a/ojluni/src/main/java/java/security/spec/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.security.spec"
-        },
-        {
-          "include-filter": "tests.security.spec"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/sql/TEST_MAPPING b/ojluni/src/main/java/java/sql/TEST_MAPPING
index 28cf3b3befd..bab9fc1847b 100644
--- a/ojluni/src/main/java/java/sql/TEST_MAPPING
+++ b/ojluni/src/main/java/java/sql/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.sql.tests.java.sql"
-        },
-        {
-          "include-filter": "tests.java.sql"
-        },
-        {
-          "include-filter": "libcore.java.sql"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_java_sql"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/text/TEST_MAPPING b/ojluni/src/main/java/java/text/TEST_MAPPING
index 30747b2d1f6..a92181fca2c 100644
--- a/ojluni/src/main/java/java/text/TEST_MAPPING
+++ b/ojluni/src/main/java/java/text/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.java.text"
-        },
-        {
-          "include-filter": "libcore.java.text"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_text"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/time/TEST_MAPPING b/ojluni/src/main/java/java/time/TEST_MAPPING
index 6956e2fd933..28b328b5d5e 100644
--- a/ojluni/src/main/java/java/time/TEST_MAPPING
+++ b/ojluni/src/main/java/java/time/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.time"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_time"
     }
   ],
   "presubmit-large": [
diff --git a/ojluni/src/main/java/java/time/chrono/TEST_MAPPING b/ojluni/src/main/java/java/time/chrono/TEST_MAPPING
index 0e310657f59..0f5005237cc 100644
--- a/ojluni/src/main/java/java/time/chrono/TEST_MAPPING
+++ b/ojluni/src/main/java/java/time/chrono/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.time.chrono"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_time_chrono"
     }
diff --git a/ojluni/src/main/java/java/time/format/TEST_MAPPING b/ojluni/src/main/java/java/time/format/TEST_MAPPING
index 9de70982a0f..026c1c61f10 100644
--- a/ojluni/src/main/java/java/time/format/TEST_MAPPING
+++ b/ojluni/src/main/java/java/time/format/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.time.format"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_time_format"
     }
diff --git a/ojluni/src/main/java/java/time/temporal/TEST_MAPPING b/ojluni/src/main/java/java/time/temporal/TEST_MAPPING
index f40206fdefd..0d74cbb3399 100644
--- a/ojluni/src/main/java/java/time/temporal/TEST_MAPPING
+++ b/ojluni/src/main/java/java/time/temporal/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.time.temporal"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_time_temporal"
     }
diff --git a/ojluni/src/main/java/java/time/zone/TEST_MAPPING b/ojluni/src/main/java/java/time/zone/TEST_MAPPING
index 00aefafbf02..5576c0943a6 100644
--- a/ojluni/src/main/java/java/time/zone/TEST_MAPPING
+++ b/ojluni/src/main/java/java/time/zone/TEST_MAPPING
@@ -1,13 +1,5 @@
 {
   "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.time.zone"
-        }
-      ]
-    },
     {
       "name": "CtsLibcoreOjTestCases_time_zone"
     }
diff --git a/ojluni/src/main/java/java/util/Arrays.java b/ojluni/src/main/java/java/util/Arrays.java
index 995dec87c01..3ed26f73d0b 100644
--- a/ojluni/src/main/java/java/util/Arrays.java
+++ b/ojluni/src/main/java/java/util/Arrays.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,6 +34,7 @@ import dalvik.annotation.compat.VersionCodes;
 import dalvik.system.VMRuntime;
 
 import jdk.internal.util.ArraysSupport;
+import jdk.internal.vm.annotation.ForceInline;
 import jdk.internal.vm.annotation.IntrinsicCandidate;
 
 import java.io.Serializable;
@@ -80,7 +81,7 @@ import java.util.stream.StreamSupport;
  * @author John Rose
  * @since  1.2
  */
-public class Arrays {
+public final class Arrays {
 
     // Suppresses default constructor, ensuring non-instantiability.
     private Arrays() {}
@@ -2420,7 +2421,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2465,9 +2477,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2492,7 +2517,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2537,9 +2573,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2554,7 +2603,7 @@ public class Arrays {
      * @param a2 the other array to be tested for equality
      * @return {@code true} if the two arrays are equal
      */
-    public static boolean equals(short[] a, short a2[]) {
+    public static boolean equals(short[] a, short[] a2) {
         if (a==a2)
             return true;
         if (a==null || a2==null)
@@ -2564,7 +2613,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2609,9 +2669,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2637,7 +2710,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2682,9 +2766,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2710,7 +2807,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2755,9 +2863,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2782,7 +2903,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (a[idx] != a2[idx]) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2827,9 +2959,23 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex,
                                       aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (a[aFromIndex++] != b[bFromIndex++]) {
+                return false;
+            }
+        }
+
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2841,7 +2987,7 @@ public class Arrays {
      * two array references are considered equal if both are {@code null}.
      *
      * Two doubles {@code d1} and {@code d2} are considered equal if:
-     * <pre>    {@code new Double(d1).equals(new Double(d2))}</pre>
+     * <pre>    {@code Double.valueOf(d1).equals(Double.valueOf(d2))}</pre>
      * (Unlike the {@code ==} operator, this method considers
      * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)
      *
@@ -2860,7 +3006,18 @@ public class Arrays {
         if (a2.length != length)
             return false;
 
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (Double.doubleToLongBits(a[idx]) != Double.doubleToLongBits(a2[idx])) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2874,7 +3031,7 @@ public class Arrays {
      * in the same order.
      *
      * <p>Two doubles {@code d1} and {@code d2} are considered equal if:
-     * <pre>    {@code new Double(d1).equals(new Double(d2))}</pre>
+     * <pre>    {@code Double.valueOf(d1).equals(Double.valueOf(d2))}</pre>
      * (Unlike the {@code ==} operator, this method considers
      * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)
      *
@@ -2911,8 +3068,22 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex, aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (Double.doubleToLongBits(a[aFromIndex++]) !=
+                    Double.doubleToLongBits(b[bFromIndex++])) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2924,7 +3095,7 @@ public class Arrays {
      * two array references are considered equal if both are {@code null}.
      *
      * Two floats {@code f1} and {@code f2} are considered equal if:
-     * <pre>    {@code new Float(f1).equals(new Float(f2))}</pre>
+     * <pre>    {@code Float.valueOf(f1).equals(Float.valueOf(f2))}</pre>
      * (Unlike the {@code ==} operator, this method considers
      * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)
      *
@@ -2942,8 +3113,18 @@ public class Arrays {
         int length = a.length;
         if (a2.length != length)
             return false;
-
-        return ArraysSupport.mismatch(a, a2, length) < 0;
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        // return ArraysSupport.mismatch(a, a2, length) < 0;
+        for (int idx = 0; idx < length; ++idx) {
+            if (Float.floatToIntBits(a[idx]) != Float.floatToIntBits(a2[idx])) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -2957,7 +3138,7 @@ public class Arrays {
      * in the same order.
      *
      * <p>Two floats {@code f1} and {@code f2} are considered equal if:
-     * <pre>    {@code new Float(f1).equals(new Float(f2))}</pre>
+     * <pre>    {@code Float.valueOf(f1).equals(Float.valueOf(f2))}</pre>
      * (Unlike the {@code ==} operator, this method considers
      * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)
      *
@@ -2994,8 +3175,21 @@ public class Arrays {
         if (aLength != bLength)
             return false;
 
+        // BEGIN Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
+        // TODO(b/362153334) Assess whether it's worth writing intrinsics or not.
+        /*
         return ArraysSupport.mismatch(a, aFromIndex,
                                       b, bFromIndex, aLength) < 0;
+        */
+        for (int idx = 0; idx < aLength; ++idx) {
+            if (Float.floatToIntBits(a[aFromIndex++]) != Float.floatToIntBits(b[bFromIndex++])) {
+                return false;
+            }
+        }
+        return true;
+        // END Android-changed: keep for-loop implementation due to the absence of ArraySupport
+        // intrinsics.
     }
 
     /**
@@ -3582,6 +3776,12 @@ public class Arrays {
      * @since 1.6
      */
     public static byte[] copyOf(byte[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         byte[] copy = new byte[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3606,6 +3806,12 @@ public class Arrays {
      * @since 1.6
      */
     public static short[] copyOf(short[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         short[] copy = new short[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3630,12 +3836,19 @@ public class Arrays {
      * @since 1.6
      */
     public static int[] copyOf(int[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         int[] copy = new int[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
         return copy;
     }
 
+
     /**
      * Copies the specified array, truncating or padding with zeros (if necessary)
      * so the copy has the specified length.  For all indices that are
@@ -3654,6 +3867,12 @@ public class Arrays {
      * @since 1.6
      */
     public static long[] copyOf(long[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         long[] copy = new long[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3678,6 +3897,12 @@ public class Arrays {
      * @since 1.6
      */
     public static char[] copyOf(char[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         char[] copy = new char[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3702,6 +3927,12 @@ public class Arrays {
      * @since 1.6
      */
     public static float[] copyOf(float[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         float[] copy = new float[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3726,6 +3957,12 @@ public class Arrays {
      * @since 1.6
      */
     public static double[] copyOf(double[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         double[] copy = new double[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3750,6 +3987,12 @@ public class Arrays {
      * @since 1.6
      */
     public static boolean[] copyOf(boolean[] original, int newLength) {
+        // Android-removed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (newLength == original.length) {
+            return original.clone();
+        }
+        */
         boolean[] copy = new boolean[newLength];
         System.arraycopy(original, 0, copy, 0,
                          Math.min(original.length, newLength));
@@ -3837,6 +4080,13 @@ public class Arrays {
         return copy;
     }
 
+    @ForceInline
+    private static void checkLength(int from, int to) {
+        if (to < from) {
+            throw new IllegalArgumentException(from + " > " + to);
+        }
+    }
+
     /**
      * Copies the specified range of the specified array into a new array.
      * The initial index of the range ({@code from}) must lie between zero
@@ -3864,9 +4114,21 @@ public class Arrays {
      * @since 1.6
      */
     public static byte[] copyOfRange(byte[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeByte(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeByte(original, from, to);
+    }
+
+    @ForceInline
+    private static byte[] copyOfRangeByte(byte[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         byte[] copy = new byte[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -3900,9 +4162,21 @@ public class Arrays {
      * @since 1.6
      */
     public static short[] copyOfRange(short[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeShort(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeShort(original, from, to);
+    }
+
+    @ForceInline
+    private static short[] copyOfRangeShort(short[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         short[] copy = new short[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -3936,9 +4210,21 @@ public class Arrays {
      * @since 1.6
      */
     public static int[] copyOfRange(int[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeInt(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeInt(original, from, to);
+    }
+
+    @ForceInline
+    private static int[] copyOfRangeInt(int[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         int[] copy = new int[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -3972,9 +4258,21 @@ public class Arrays {
      * @since 1.6
      */
     public static long[] copyOfRange(long[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeLong(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeLong(original, from, to);
+    }
+
+    @ForceInline
+    private static long[] copyOfRangeLong(long[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         long[] copy = new long[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -4008,9 +4306,22 @@ public class Arrays {
      * @since 1.6
      */
     public static char[] copyOfRange(char[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeChar(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeChar(original, from, to);
+    }
+
+
+    @ForceInline
+    private static char[] copyOfRangeChar(char[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         char[] copy = new char[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -4044,9 +4355,22 @@ public class Arrays {
      * @since 1.6
      */
     public static float[] copyOfRange(float[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeFloat(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeFloat(original, from, to);
+    }
+
+
+    @ForceInline
+    private static float[] copyOfRangeFloat(float[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         float[] copy = new float[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -4080,9 +4404,22 @@ public class Arrays {
      * @since 1.6
      */
     public static double[] copyOfRange(double[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeDouble(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeDouble(original, from, to);
+    }
+
+
+    @ForceInline
+    private static double[] copyOfRangeDouble(double[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         double[] copy = new double[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -4116,9 +4453,22 @@ public class Arrays {
      * @since 1.6
      */
     public static boolean[] copyOfRange(boolean[] original, int from, int to) {
+        // Tickle the JIT to fold special cases optimally
+        // Android-changed: TODO(b/359517996) .clone() is slower than System.arraycopy.
+        /*
+        if (from != 0 || to != original.length)
+            return copyOfRangeBoolean(original, from, to);
+        else // from == 0 && to == original.length
+            return original.clone();
+        */
+        return copyOfRangeBoolean(original, from, to);
+    }
+
+
+    @ForceInline
+    private static boolean[] copyOfRangeBoolean(boolean[] original, int from, int to) {
+        checkLength(from, to);
         int newLength = to - from;
-        if (newLength < 0)
-            throw new IllegalArgumentException(from + " > " + to);
         boolean[] copy = new boolean[newLength];
         System.arraycopy(original, from, copy, 0,
                          Math.min(original.length - from, newLength));
@@ -4137,6 +4487,10 @@ public class Arrays {
      * those that would change the size of the returned list. Those methods leave
      * the list unchanged and throw {@link UnsupportedOperationException}.
      *
+     * <p>If the specified array's actual component type differs from the type
+     * parameter T, this can result in operations on the returned list throwing an
+     * {@code ArrayStoreException}.
+     *
      * @apiNote
      * This method acts as bridge between array-based and collection-based
      * APIs, in combination with {@link Collection#toArray}.
@@ -4345,16 +4699,15 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(long a[]) {
-        if (a == null)
+    public static int hashCode(long[] a) {
+        if (a == null) {
             return 0;
-
+        }
         int result = 1;
         for (long element : a) {
             int elementHash = (int)(element ^ (element >>> 32));
             result = 31 * result + elementHash;
         }
-
         return result;
     }
 
@@ -4374,15 +4727,15 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(int a[]) {
-        if (a == null)
+    public static int hashCode(int[] a) {
+        if (a == null) {
             return 0;
-
-        int result = 1;
-        for (int element : a)
-            result = 31 * result + element;
-
-        return result;
+        }
+        return switch (a.length) {
+            case 0 -> 1;
+            case 1 -> 31 + a[0];
+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_INT);
+        };
     }
 
     /**
@@ -4401,15 +4754,15 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(short a[]) {
-        if (a == null)
+    public static int hashCode(short[] a) {
+        if (a == null) {
             return 0;
-
-        int result = 1;
-        for (short element : a)
-            result = 31 * result + element;
-
-        return result;
+        }
+        return switch (a.length) {
+            case 0 -> 1;
+            case 1 -> 31 + (int)a[0];
+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_SHORT);
+        };
     }
 
     /**
@@ -4428,15 +4781,15 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(char a[]) {
-        if (a == null)
+    public static int hashCode(char[] a) {
+        if (a == null) {
             return 0;
-
-        int result = 1;
-        for (char element : a)
-            result = 31 * result + element;
-
-        return result;
+        }
+        return switch (a.length) {
+            case 0 -> 1;
+            case 1 -> 31 + (int)a[0];
+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_CHAR);
+        };
     }
 
     /**
@@ -4455,15 +4808,15 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(byte a[]) {
-        if (a == null)
+    public static int hashCode(byte[] a) {
+        if (a == null) {
             return 0;
-
-        int result = 1;
-        for (byte element : a)
-            result = 31 * result + element;
-
-        return result;
+        }
+        return switch (a.length) {
+            case 0 -> 1;
+            case 1 -> 31 + (int)a[0];
+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_BYTE);
+        };
     }
 
     /**
@@ -4482,7 +4835,7 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(boolean a[]) {
+    public static int hashCode(boolean[] a) {
         if (a == null)
             return 0;
 
@@ -4509,7 +4862,7 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(float a[]) {
+    public static int hashCode(float[] a) {
         if (a == null)
             return 0;
 
@@ -4536,7 +4889,7 @@ public class Arrays {
      * @return a content-based hash code for {@code a}
      * @since 1.5
      */
-    public static int hashCode(double a[]) {
+    public static int hashCode(double[] a) {
         if (a == null)
             return 0;
 
@@ -4569,7 +4922,7 @@ public class Arrays {
      * @see #deepHashCode(Object[])
      * @since 1.5
      */
-    public static int hashCode(Object a[]) {
+    public static int hashCode(Object[] a) {
         if (a == null)
             return 0;
 
@@ -4610,7 +4963,7 @@ public class Arrays {
      * @see #hashCode(Object[])
      * @since 1.5
      */
-    public static int deepHashCode(Object a[]) {
+    public static int deepHashCode(Object[] a) {
         if (a == null)
             return 0;
 
@@ -5695,8 +6048,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -5830,8 +6183,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(byte[], int, int, byte[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -6085,8 +6438,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(short[], int, int, short[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -6339,8 +6692,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(char[], int, int, char[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -6474,8 +6827,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(int[], int, int, int[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -6728,8 +7081,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(long[], int, int, long[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -6982,8 +7335,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(float[], int, int, float[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -7117,8 +7470,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(double[], int, int, double[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -7276,8 +7629,8 @@ public class Arrays {
      * <p>The comparison is consistent with
      * {@link #equals(Object[], int, int, Object[], int, int) equals}, more
      * specifically the following holds for arrays {@code a} and {@code b} with
-     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively:
+     * specified ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively:
      * <pre>{@code
      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
@@ -7559,8 +7912,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -7572,8 +7925,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -7686,8 +8039,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -7699,8 +8052,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -7813,8 +8166,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -7826,8 +8179,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -7940,8 +8293,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -7953,8 +8306,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8067,8 +8420,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8080,8 +8433,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8194,8 +8547,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8207,8 +8560,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8321,8 +8674,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8334,8 +8687,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8448,8 +8801,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8461,8 +8814,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8579,8 +8932,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8592,8 +8945,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
@@ -8725,8 +9078,8 @@ public class Arrays {
      * Otherwise, there is no mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a common
      * prefix of length {@code pl} if the following expression is true:
      * <pre>{@code
      *     pl >= 0 &&
@@ -8738,8 +9091,8 @@ public class Arrays {
      * elements from each array mismatch.
      *
      * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
-     * ranges [{@code aFromIndex}, {@code atoIndex}) and
-     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
+     * ranges [{@code aFromIndex}, {@code aToIndex}) and
+     * [{@code bFromIndex}, {@code bToIndex}) respectively, share a proper
      * prefix if the following expression is true:
      * <pre>{@code
      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
diff --git a/ojluni/src/main/java/java/util/Collection.java b/ojluni/src/main/java/java/util/Collection.java
index b647526f29b..ab1526a5335 100644
--- a/ojluni/src/main/java/java/util/Collection.java
+++ b/ojluni/src/main/java/java/util/Collection.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,8 +33,11 @@ import java.util.stream.StreamSupport;
 /**
  * The root interface in the <i>collection hierarchy</i>.  A collection
  * represents a group of objects, known as its <i>elements</i>.  Some
- * collections allow duplicate elements and others do not.  Some are ordered
- * and others unordered.  The JDK does not provide any <i>direct</i>
+ * collections allow duplicate elements and others do not.  Some are ordered,
+ * and others are unordered. Collections that have a defined
+ * <a href="SequencedCollection.html#encounter">encounter order</a>
+ * are generally subtypes of the {@link SequencedCollection} interface.
+ * The JDK does not provide any <i>direct</i>
  * implementations of this interface: it provides implementations of more
  * specific subinterfaces like {@code Set} and {@code List}.  This interface
  * is typically used to pass collections around and manipulate them where
@@ -121,8 +124,9 @@ import java.util.stream.StreamSupport;
  * Other examples of view collections include collections that provide a
  * different representation of the same elements, for example, as
  * provided by {@link List#subList List.subList},
- * {@link NavigableSet#subSet NavigableSet.subSet}, or
- * {@link Map#entrySet Map.entrySet}.
+ * {@link NavigableSet#subSet NavigableSet.subSet},
+ * {@link Map#entrySet Map.entrySet}, or
+ * {@link SequencedCollection#reversed SequencedCollection.reversed}.
  * Any changes made to the backing collection are visible in the view collection.
  * Correspondingly, any changes made to the view collection &mdash; if changes
  * are permitted &mdash; are written through to the backing collection.
@@ -202,7 +206,8 @@ import java.util.stream.StreamSupport;
  * serializability of such collections is described in the specification of the method
  * that creates them, or in some other suitable place. In cases where the serializability
  * of a collection is not specified, there is no guarantee about the serializability of such
- * collections. In particular, many <a href="#view">view collections</a> are not serializable.
+ * collections. In particular, many <a href="#view">view collections</a> are not serializable,
+ * even if the original collection is serializable.
  *
  * <p>A collection implementation that implements the {@code Serializable} interface cannot
  * be guaranteed to be serializable. The reason is that in general, collections
@@ -280,10 +285,10 @@ public interface Collection<E> extends Iterable<E> {
      *         element
      * @throws ClassCastException if the type of the specified element
      *         is incompatible with this collection
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified element is null and this
      *         collection does not permit null elements
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      */
     boolean contains(Object o);
 
@@ -463,11 +468,11 @@ public interface Collection<E> extends Iterable<E> {
      * @return {@code true} if an element was removed as a result of this call
      * @throws ClassCastException if the type of the specified element
      *         is incompatible with this collection
-     *         (<a href="#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified element is null and this
      *         collection does not permit null elements
-     *         (<a href="#optional-restrictions">optional</a>)
-     * @throws UnsupportedOperationException if the <tt>remove</tt> operation
+     *         ({@linkplain Collection##optional-restrictions optional})
+     * @throws UnsupportedOperationException if the {@code remove} operation
      *         is not supported by this collection
      */
     boolean remove(Object o);
@@ -485,11 +490,11 @@ public interface Collection<E> extends Iterable<E> {
      * @throws ClassCastException if the types of one or more elements
      *         in the specified collection are incompatible with this
      *         collection
-     *         (<a href="#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified collection contains one
      *         or more null elements and this collection does not permit null
      *         elements
-     *         (<a href="#optional-restrictions">optional</a>),
+     *         ({@linkplain Collection##optional-restrictions optional})
      *         or if the specified collection is null.
      * @see    #contains(Object)
      */
@@ -501,7 +506,9 @@ public interface Collection<E> extends Iterable<E> {
      * the specified collection is modified while the operation is in progress.
      * (This implies that the behavior of this call is undefined if the
      * specified collection is this collection, and this collection is
-     * nonempty.)
+     * nonempty.) If the specified collection has a defined
+     * <a href="SequencedCollection.html#encounter">encounter order</a>,
+     * processing of its elements generally occurs in that order.
      *
      * @param c collection containing elements to be added to this collection
      * @return {@code true} if this collection changed as a result of the call
@@ -535,11 +542,11 @@ public interface Collection<E> extends Iterable<E> {
      * @throws ClassCastException if the types of one or more elements
      *         in this collection are incompatible with the specified
      *         collection
-     *         (<a href="#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if this collection contains one or more
      *         null elements and the specified collection does not support
      *         null elements
-     *         (<a href="#optional-restrictions">optional</a>),
+     *         ({@linkplain Collection##optional-restrictions optional})
      *         or if the specified collection is null
      * @see #remove(Object)
      * @see #contains(Object)
@@ -594,11 +601,11 @@ public interface Collection<E> extends Iterable<E> {
      * @throws ClassCastException if the types of one or more elements
      *         in this collection are incompatible with the specified
      *         collection
-     *         (<a href="#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if this collection contains one or more
      *         null elements and the specified collection does not permit null
      *         elements
-     *         (<a href="#optional-restrictions">optional</a>),
+     *         ({@linkplain Collection##optional-restrictions optional})
      *         or if the specified collection is null
      * @see #remove(Object)
      * @see #contains(Object)
diff --git a/ojluni/src/main/java/java/util/Currency.java b/ojluni/src/main/java/java/util/Currency.java
index b2daecdb99c..c184d582560 100644
--- a/ojluni/src/main/java/java/util/Currency.java
+++ b/ojluni/src/main/java/java/util/Currency.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,6 +60,7 @@ import libcore.icu.ICU;
  * with {@code Currency} or monetary values as it provides better handling of floating
  * point numbers and their operations.
  *
+ * @spec http://www.iso.org/iso/home/standards/currency_codes.htm ISO - ISO 4217 - Currency codes
  * @see java.math.BigDecimal
  * @since 1.4
  */
@@ -173,6 +174,11 @@ public final class Currency implements Serializable {
     private static final int VALID_FORMAT_VERSION = 3;
 
     static {
+        initStatic();
+    }
+
+    @SuppressWarnings("removal")
+    private static void initStatic() {
         AccessController.doPrivileged(new PrivilegedAction<>() {
             @Override
             public Void run() {
@@ -240,7 +246,7 @@ public final class Currency implements Serializable {
 
     /**
      * Constructs a {@code Currency} instance. The constructor is private
-     * so that we can insure that there's never more than one instance for a
+     * so that we can ensure that there's never more than one instance for a
      * given currency.
      */
     // BEGIN Android-changed: Use ICU.
@@ -334,7 +340,7 @@ public final class Currency implements Serializable {
      * of the respective countries.
      * <p>
      * If the specified {@code locale} contains "cu"
-     * <a href="./Locale.html#def_locale_extension">Unicode extensions</a>,
+     * {@linkplain Locale##def_locale_extension Unicode extensions},
      * the instance returned from this method reflects
      * the values specified with those extensions.
      * <p>
diff --git a/ojluni/src/main/java/java/util/Date.java b/ojluni/src/main/java/java/util/Date.java
index 494bb4d5633..7229ed0d40c 100644
--- a/ojluni/src/main/java/java/util/Date.java
+++ b/ojluni/src/main/java/java/util/Date.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,14 +27,11 @@
 package java.util;
 
 import java.text.DateFormat;
-import java.time.LocalDate;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.ObjectInputStream;
-import java.lang.ref.SoftReference;
 import java.time.Instant;
 import sun.util.calendar.BaseCalendar;
-import sun.util.calendar.CalendarDate;
 import sun.util.calendar.CalendarSystem;
 import sun.util.calendar.CalendarUtils;
 import sun.util.calendar.Era;
@@ -265,6 +262,8 @@ public class Date
      * {@link Date#parse} method.
      *
      * @param   s   a string representation of the date.
+     * @throws IllegalArgumentException if {@code s} cannot be interpreted as a
+     * representation of a date and time.
      * @see     java.text.DateFormat
      * @see     java.util.Date#parse(java.lang.String)
      * @deprecated As of JDK version 1.1,
@@ -446,6 +445,8 @@ public class Date
      * @param   s   a string to be parsed as a date.
      * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
      *          represented by the string argument.
+     * @throws IllegalArgumentException if {@code s} cannot be interpreted as a
+     * representation of a date and time.
      * @see     java.text.DateFormat
      * @deprecated As of JDK version 1.1,
      * replaced by {@code DateFormat.parse(String s)}.
@@ -996,10 +997,9 @@ public class Date
      * @since   1.2
      * @throws    NullPointerException if {@code anotherDate} is null.
      */
+    @Override
     public int compareTo(Date anotherDate) {
-        long thisTime = getMillisOf(this);
-        long anotherTime = getMillisOf(anotherDate);
-        return (thisTime<anotherTime ? -1 : (thisTime==anotherTime ? 0 : 1));
+        return Long.compare(getMillisOf(this), getMillisOf(anotherDate));
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/DualPivotQuicksort.java b/ojluni/src/main/java/java/util/DualPivotQuicksort.java
index ac96b34c5fb..3dcc7fee1f5 100644
--- a/ojluni/src/main/java/java/util/DualPivotQuicksort.java
+++ b/ojluni/src/main/java/java/util/DualPivotQuicksort.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -3997,6 +3997,7 @@ final class DualPivotQuicksort {
      */
     private static final class Sorter extends CountedCompleter<Void> {
         private static final long serialVersionUID = 20180818L;
+        @SuppressWarnings("serial")
         private final Object a, b;
         private final int low, size, offset, depth;
 
@@ -4066,6 +4067,7 @@ final class DualPivotQuicksort {
      */
     private static final class Merger extends CountedCompleter<Void> {
         private static final long serialVersionUID = 20180818L;
+        @SuppressWarnings("serial")
         private final Object dst, a1, a2;
         private final int k, lo1, hi1, lo2, hi2;
 
@@ -4115,6 +4117,7 @@ final class DualPivotQuicksort {
      */
     private static final class RunMerger extends RecursiveTask<Object> {
         private static final long serialVersionUID = 20180818L;
+        @SuppressWarnings("serial")
         private final Object a, b;
         private final int[] run;
         private final int offset, aim, lo, hi;
diff --git a/ojluni/src/main/java/java/util/EnumMap.java b/ojluni/src/main/java/java/util/EnumMap.java
index 640d248ca8e..67b11da79a6 100644
--- a/ojluni/src/main/java/java/util/EnumMap.java
+++ b/ojluni/src/main/java/java/util/EnumMap.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -72,6 +72,9 @@ import jdk.internal.access.SharedSecrets;
  * <a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework">
  * Java Collections Framework</a>.
  *
+ * @param <K> the enum type of keys maintained by this map
+ * @param <V> the type of mapped values
+ *
  * @author Josh Bloch
  * @see EnumSet
  * @since 1.5
diff --git a/ojluni/src/main/java/java/util/EnumSet.java b/ojluni/src/main/java/java/util/EnumSet.java
index 75d21a0c66b..042b2ac99ee 100644
--- a/ojluni/src/main/java/java/util/EnumSet.java
+++ b/ojluni/src/main/java/java/util/EnumSet.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,12 +73,15 @@ import jdk.internal.access.SharedSecrets;
  * <a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework">
  * Java Collections Framework</a>.
  *
+ * @param <E> the enum type of elements maintained by this set
+ *
  * @author Josh Bloch
  * @since 1.5
  * @see EnumMap
  */
-public abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E>
-    implements Cloneable, java.io.Serializable
+// Android-changed: remove sealed marker (there is no metalava support b/355648520).
+public abstract /*sealed*/ class EnumSet<E extends Enum<E>> extends AbstractSet<E>
+    implements Cloneable, java.io.Serializable // permits JumboEnumSet, RegularEnumSet
 {
     // declare EnumSet.class serialization compatibility with JDK 8
     @java.io.Serial
diff --git a/ojluni/src/main/java/java/util/Enumeration.java b/ojluni/src/main/java/java/util/Enumeration.java
index 8d920c82f22..23b4648d90d 100644
--- a/ojluni/src/main/java/java/util/Enumeration.java
+++ b/ojluni/src/main/java/java/util/Enumeration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,6 +49,8 @@ package java.util;
  * adapt an {@code Enumeration} to an {@code Iterator} by using the
  * {@link #asIterator} method.
  *
+ * @param <E> the type of elements returned by this enumeration
+ *
  * @see     java.util.Iterator
  * @see     java.io.SequenceInputStream
  * @see     java.util.Enumeration#nextElement()
diff --git a/ojluni/src/main/java/java/util/Hashtable.java b/ojluni/src/main/java/java/util/Hashtable.java
index 2fcdc46fbdd..035cb83b608 100644
--- a/ojluni/src/main/java/java/util/Hashtable.java
+++ b/ojluni/src/main/java/java/util/Hashtable.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -832,9 +832,7 @@ public class Hashtable<K,V>
                         return false;
                 }
             }
-        } catch (ClassCastException unused)   {
-            return false;
-        } catch (NullPointerException unused) {
+        } catch (ClassCastException | NullPointerException unused) {
             return false;
         }
 
@@ -1273,7 +1271,7 @@ public class Hashtable<K,V>
         float lf = fields.get("loadFactor", 0.75f);
         if (lf <= 0 || Float.isNaN(lf))
             throw new StreamCorruptedException("Illegal load factor: " + lf);
-        lf = Math.min(Math.max(0.25f, lf), 4.0f);
+        lf = Math.clamp(lf, 0.25f, 4.0f);
 
         // Read the original length of the array and number of elements
         int origlength = s.readInt();
@@ -1291,7 +1289,7 @@ public class Hashtable<K,V>
         // no larger than the clamped original length.  Make the length
         // odd if it's large enough, this helps distribute the entries.
         // Guard against the length ending up zero, that's not valid.
-        int length = (int)((elements + elements / 20) / lf) + 3;
+        int length = (int)(elements * 1.05f / lf) + 3;
         if (length > elements && (length & 1) == 0)
             length--;
         length = Math.min(length, origlength);
diff --git a/ojluni/src/main/java/java/util/IdentityHashMap.java b/ojluni/src/main/java/java/util/IdentityHashMap.java
index 4795c30b3d5..77f06fb9410 100644
--- a/ojluni/src/main/java/java/util/IdentityHashMap.java
+++ b/ojluni/src/main/java/java/util/IdentityHashMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,6 +49,10 @@ import jdk.internal.access.SharedSecrets;
  * designed for use only in the rare cases wherein reference-equality
  * semantics are required.</b>
  *
+ * <p>The view collections of this map also have reference-equality semantics
+ * for their elements. See the {@link keySet() keySet}, {@link values() values},
+ * and {@link entrySet() entrySet} methods for further information.
+ *
  * <p>A typical use of this class is <i>topology-preserving object graph
  * transformations</i>, such as serialization or deep-copying.  To perform such
  * a transformation, a program must maintain a "node table" that keeps track
@@ -130,6 +134,9 @@ import jdk.internal.access.SharedSecrets;
  * and operation mixes, this class will yield better performance than
  * {@link HashMap}, which uses <i>chaining</i> rather than linear-probing.
  *
+ * @param <K> the type of keys maintained by this map
+ * @param <V> the type of mapped values
+ *
  * @see     System#identityHashCode(Object)
  * @see     Object#hashCode()
  * @see     Collection
@@ -343,7 +350,8 @@ public class IdentityHashMap<K,V>
 
     /**
      * Tests whether the specified object reference is a key in this identity
-     * hash map.
+     * hash map. Returns {@code true} if and only if this map contains a mapping
+     * with key {@code k} such that {@code (key == k)}.
      *
      * @param   key   possible key
      * @return  {@code true} if the specified object reference is a key
@@ -367,7 +375,8 @@ public class IdentityHashMap<K,V>
 
     /**
      * Tests whether the specified object reference is a value in this identity
-     * hash map.
+     * hash map. Returns {@code true} if and only if this map contains a mapping
+     * with value {@code v} such that {@code (value == v)}.
      *
      * @param value value whose presence in this map is to be tested
      * @return {@code true} if this map maps one or more keys to the
@@ -408,8 +417,9 @@ public class IdentityHashMap<K,V>
 
     /**
      * Associates the specified value with the specified key in this identity
-     * hash map.  If the map previously contained a mapping for the key, the
-     * old value is replaced.
+     * hash map. If this map already {@link containsKey(Object) contains}
+     * a mapping for the key, the old value is replaced, otherwise, a new mapping
+     * is inserted into this map.
      *
      * @param key the key with which the specified value is to be associated
      * @param value the value to be associated with the specified key
@@ -494,8 +504,10 @@ public class IdentityHashMap<K,V>
 
     /**
      * Copies all of the mappings from the specified map to this map.
-     * These mappings will replace any mappings that this map had for
-     * any of the keys currently in the specified map.
+     * For each mapping in the specified map, if this map already
+     * {@link containsKey(Object) contains} a mapping for the key,
+     * its value is replaced with the value from the specified map;
+     * otherwise, a new mapping is inserted into this map.
      *
      * @param m mappings to be stored in this map
      * @throws NullPointerException if the specified map is null
@@ -513,6 +525,8 @@ public class IdentityHashMap<K,V>
 
     /**
      * Removes the mapping for this key from this map if present.
+     * The mapping is removed if and only if the mapping has a key
+     * {@code k} such that (key == k).
      *
      * @param key key whose mapping is to be removed from the map
      * @return the previous value associated with {@code key}, or
@@ -629,7 +643,9 @@ public class IdentityHashMap<K,V>
      * {@code true} if the given object is also a map and the two maps
      * represent identical object-reference mappings.  More formally, this
      * map is equal to another map {@code m} if and only if
-     * {@code this.entrySet().equals(m.entrySet())}.
+     * {@code this.entrySet().equals(m.entrySet())}. See the
+     * {@link entrySet() entrySet} method for the specification of equality
+     * of this map's entries.
      *
      * <p><b>Owing to the reference-equality-based semantics of this map it is
      * possible that the symmetry and transitivity requirements of the
@@ -664,8 +680,11 @@ public class IdentityHashMap<K,V>
 
     /**
      * Returns the hash code value for this map.  The hash code of a map is
-     * defined to be the sum of the hash codes of each entry in the map's
-     * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}
+     * defined to be the sum of the hash codes of each entry of this map.
+     * See the {@link entrySet() entrySet} method for a specification of the
+     * hash code of this map's entries.
+     *
+     * <p>This specification ensures that {@code m1.equals(m2)}
      * implies that {@code m1.hashCode()==m2.hashCode()} for any two
      * {@code IdentityHashMap} instances {@code m1} and {@code m2}, as
      * required by the general contract of {@link Object#hashCode}.
@@ -1159,7 +1178,9 @@ public class IdentityHashMap<K,V>
      * e.getValue()==o.getValue()}.  To accommodate these equals
      * semantics, the {@code hashCode} method returns
      * {@code System.identityHashCode(e.getKey()) ^
-     * System.identityHashCode(e.getValue())}.
+     * System.identityHashCode(e.getValue())}. (While the keys and values
+     * are compared using reference equality, the {@code Map.Entry}
+     * objects themselves are not.)
      *
      * <p><b>Owing to the reference-equality-based semantics of the
      * {@code Map.Entry} instances in the set returned by this method,
@@ -1379,6 +1400,50 @@ public class IdentityHashMap<K,V>
         }
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * <p>More formally, if this map contains a mapping from a key
+     * {@code k} to a value {@code v} such that {@code (key == k)}
+     * and {@code (value == v)}, then this method removes the mapping
+     * for this key and returns {@code true}; otherwise it returns
+     * {@code false}.
+     */
+    @Override
+    public boolean remove(Object key, Object value) {
+        return removeMapping(key, value);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>More formally, if this map contains a mapping from a key
+     * {@code k} to a value {@code v} such that {@code (key == k)}
+     * and {@code (oldValue == v)}, then this method associates
+     * {@code k} with {@code newValue} and returns {@code true};
+     * otherwise it returns {@code false}.
+     */
+    @Override
+    public boolean replace(K key, V oldValue, V newValue) {
+        Object k = maskNull(key);
+        Object[] tab = table;
+        int len = tab.length;
+        int i = hash(k, len);
+
+        while (true) {
+            Object item = tab[i];
+            if (item == k) {
+                if (tab[i + 1] != oldValue)
+                    return false;
+                tab[i + 1] = newValue;
+                return true;
+            }
+            if (item == null)
+                return false;
+            i = nextKeyIndex(i, len);
+        }
+    }
+
     /**
      * Similar form as array-based Spliterators, but skips blank elements,
      * and guestimates size as decreasing by half per split.
diff --git a/ojluni/src/main/java/java/util/ImmutableCollections.java b/ojluni/src/main/java/java/util/ImmutableCollections.java
index d3bfb33348c..93bdda42702 100644
--- a/ojluni/src/main/java/java/util/ImmutableCollections.java
+++ b/ojluni/src/main/java/java/util/ImmutableCollections.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -149,7 +149,7 @@ class ImmutableCollections {
     static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }
 
     @jdk.internal.ValueBased
-    static abstract class AbstractImmutableCollection<E> extends AbstractCollection<E> {
+    abstract static class AbstractImmutableCollection<E> extends AbstractCollection<E> {
         // all mutating methods throw UnsupportedOperationException
         @Override public boolean add(E e) { throw uoe(); }
         @Override public boolean addAll(Collection<? extends E> c) { throw uoe(); }
@@ -173,10 +173,12 @@ class ImmutableCollections {
      */
     @SuppressWarnings("unchecked")
     static <E> List<E> listCopy(Collection<? extends E> coll) {
-        if (coll instanceof List12 || (coll instanceof ListN && ! ((ListN<?>)coll).allowNulls)) {
+        if (coll instanceof List12 || (coll instanceof ListN<?> c && !c.allowNulls)) {
             return (List<E>)coll;
+        } else if (coll.isEmpty()) { // implicit nullcheck of coll
+            return List.of();
         } else {
-            return (List<E>)List.of(coll.toArray()); // implicit nullcheck of coll
+            return (List<E>)List.of(coll.toArray());
         }
     }
 
@@ -256,7 +258,7 @@ class ImmutableCollections {
     // ---------- List Implementations ----------
 
     @jdk.internal.ValueBased
-    static abstract class AbstractImmutableList<E> extends AbstractImmutableCollection<E>
+    abstract static class AbstractImmutableList<E> extends AbstractImmutableCollection<E>
             implements List<E>, RandomAccess {
 
         // all mutating methods throw UnsupportedOperationException
@@ -336,6 +338,11 @@ class ImmutableCollections {
             return indexOf(o) >= 0;
         }
 
+        @Override
+        public List<E> reversed() {
+            return ReverseOrderListView.of(this, false);
+        }
+
         IndexOutOfBoundsException outOfBounds(int index) {
             return new IndexOutOfBoundsException("Index: " + index + " Size: " + size());
         }
@@ -749,7 +756,7 @@ class ImmutableCollections {
     // ---------- Set Implementations ----------
 
     @jdk.internal.ValueBased
-    static abstract class AbstractImmutableSet<E> extends AbstractImmutableCollection<E>
+    abstract static class AbstractImmutableSet<E> extends AbstractImmutableCollection<E>
             implements Set<E> {
 
         @Override
@@ -1069,7 +1076,7 @@ class ImmutableCollections {
 
     // ---------- Map Implementations ----------
 
-    @jdk.internal.ValueBased
+    // Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap
     abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {
         @Override public void clear() { throw uoe(); }
         @Override public V compute(K key, BiFunction<? super K,? super V,? extends V> rf) { throw uoe(); }
@@ -1100,7 +1107,7 @@ class ImmutableCollections {
         }
     }
 
-    @jdk.internal.ValueBased
+    // Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap
     static final class Map1<K,V> extends AbstractImmutableMap<K,V> {
         @Stable
         private final K k0;
@@ -1167,7 +1174,7 @@ class ImmutableCollections {
      * @param <K> the key type
      * @param <V> the value type
      */
-    @jdk.internal.ValueBased
+    // Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap
     static final class MapN<K,V> extends AbstractImmutableMap<K,V> {
 
         @Stable
diff --git a/ojluni/src/main/java/java/util/JumboEnumSet.java b/ojluni/src/main/java/java/util/JumboEnumSet.java
index f80e5056803..126fc077b6c 100644
--- a/ojluni/src/main/java/java/util/JumboEnumSet.java
+++ b/ojluni/src/main/java/java/util/JumboEnumSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,7 @@ package java.util;
  * @since 1.5
  * @serial exclude
  */
-class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {
+final class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {
     @java.io.Serial
     private static final long serialVersionUID = 334349849919042784L;
 
diff --git a/ojluni/src/main/java/java/util/ListIterator.java b/ojluni/src/main/java/java/util/ListIterator.java
index 365daf0cb3b..2cebebf685f 100644
--- a/ojluni/src/main/java/java/util/ListIterator.java
+++ b/ojluni/src/main/java/java/util/ListIterator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,6 +49,8 @@ package java.util;
  * <a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework">
  * Java Collections Framework</a>.
  *
+ * @param <E> the type of elements returned by this list iterator
+ *
  * @author  Josh Bloch
  * @see Collection
  * @see List
diff --git a/ojluni/src/main/java/java/util/LongSummaryStatistics.java b/ojluni/src/main/java/java/util/LongSummaryStatistics.java
index ec8d9441c79..e84d70acf86 100644
--- a/ojluni/src/main/java/java/util/LongSummaryStatistics.java
+++ b/ojluni/src/main/java/java/util/LongSummaryStatistics.java
@@ -63,6 +63,7 @@ import java.util.stream.Collector;
  * <p>This implementation does not check for overflow of the count or the sum.
  * @since 1.8
  */
+@SuppressWarnings("overloads")
 public class LongSummaryStatistics implements LongConsumer, IntConsumer {
     private long count;
     private long sum;
diff --git a/ojluni/src/main/java/java/util/Map.java b/ojluni/src/main/java/java/util/Map.java
index c44b51a2dfe..a36b8187106 100644
--- a/ojluni/src/main/java/java/util/Map.java
+++ b/ojluni/src/main/java/java/util/Map.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,8 +42,10 @@ import java.io.Serializable;
  * or set of key-value mappings.  The <i>order</i> of a map is defined as
  * the order in which the iterators on the map's collection views return their
  * elements.  Some map implementations, like the {@code TreeMap} class, make
- * specific guarantees as to their order; others, like the {@code HashMap}
- * class, do not.
+ * specific guarantees as to their encounter order; others, like the
+ * {@code HashMap} class, do not. Maps with a defined
+ * <a href="SequencedCollection.html#encounter">encounter order</a>
+ * are generally subtypes of the {@link SequencedMap} interface.
  *
  * <p>Note: great care must be exercised if mutable objects are used as map
  * keys.  The behavior of a map is not specified if the value of an object is
@@ -188,11 +190,9 @@ public interface Map<K, V> {
      * @return {@code true} if this map contains a mapping for the specified
      *         key
      * @throws ClassCastException if the key is of an inappropriate type for
-     *         this map
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key is null and this map
-     *         does not permit null keys
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         does not permit null keys ({@linkplain Collection##optional-restrictions optional})
      */
     boolean containsKey(Object key);
 
@@ -208,11 +208,9 @@ public interface Map<K, V> {
      * @return {@code true} if this map maps one or more keys to the
      *         specified value
      * @throws ClassCastException if the value is of an inappropriate type for
-     *         this map
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified value is null and this
-     *         map does not permit null values
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         map does not permit null values ({@linkplain Collection##optional-restrictions optional})
      */
     boolean containsValue(Object value);
 
@@ -236,11 +234,9 @@ public interface Map<K, V> {
      * @return the value to which the specified key is mapped, or
      *         {@code null} if this map contains no mapping for the key
      * @throws ClassCastException if the key is of an inappropriate type for
-     *         this map
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key is null and this map
-     *         does not permit null keys
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         does not permit null keys ({@linkplain Collection##optional-restrictions optional})
      */
     V get(Object key);
 
@@ -296,11 +292,9 @@ public interface Map<K, V> {
      * @throws UnsupportedOperationException if the {@code remove} operation
      *         is not supported by this map
      * @throws ClassCastException if the key is of an inappropriate type for
-     *         this map
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key is null and this
-     *         map does not permit null keys
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         map does not permit null keys ({@linkplain Collection##optional-restrictions optional})
      */
     V remove(Object key);
 
@@ -312,8 +306,10 @@ public interface Map<K, V> {
      * (optional operation).  The effect of this call is equivalent to that
      * of calling {@link #put(Object,Object) put(k, v)} on this map once
      * for each mapping from key {@code k} to value {@code v} in the
-     * specified map.  The behavior of this operation is undefined if the
-     * specified map is modified while the operation is in progress.
+     * specified map.  The behavior of this operation is undefined if the specified map
+     * is modified while the operation is in progress. If the specified map has a defined
+     * <a href="SequencedCollection.html#encounter">encounter order</a>,
+     * processing of its mappings generally occurs in that order.
      *
      * @param m mappings to be stored in this map
      * @throws UnsupportedOperationException if the {@code putAll} operation
@@ -398,29 +394,55 @@ public interface Map<K, V> {
      * implemented. The Entry may be independent of any map, or it may represent
      * an entry of the entry-set view of a map.
      * <p>
-     * Instances of the {@code Map.Entry} interface may be obtained by iterating
-     * the entry-set view of a map. These instances maintain a connection to the
-     * original, backing map. This connection to the backing map is valid
-     * <i>only</i> for the duration of iteration over the entry-set view.
-     * During iteration of the entry-set view, if supported by the backing map,
-     * a change to a {@code Map.Entry}'s value via the
-     * {@link Map.Entry#setValue setValue} method will be visible in the backing map.
-     * The behavior of such a {@code Map.Entry} instance is undefined outside of
-     * iteration of the map's entry-set view. It is also undefined if the backing
-     * map has been modified after the {@code Map.Entry} was returned by the
-     * iterator, except through the {@code Map.Entry.setValue} method. In particular,
+     * An Entry maintains a connection to its underlying map if the Entry was obtained by
+     * iterating the {@link Map#entrySet} view of a map, either explicitly by using an
+     * {@link Iterator} or implicitly via the enhanced {@code for} statement. This connection
+     * to the backing map is valid <i>only</i> during iteration of the entry-set view. During
+     * the iteration, if supported by the backing map, a change to an Entry's value via
+     * the {@link Map.Entry#setValue setValue} method will be visible in the backing map.
+     * The behavior of such an Entry is undefined outside of iteration of the map's entry-set
+     * view. It is also undefined if the backing map has been modified after the Entry was
+     * returned by the iterator, except through the {@code setValue} method. In addition,
      * a change to the value of a mapping in the backing map might or might not be
-     * visible in the corresponding {@code Map.Entry} element of the entry-set view.
+     * visible in the corresponding Entry of the entry-set view.
+     * <p>
+     * An Entry may also be obtained from a map's entry-set view by other means, for
+     * example, using the
+     * {@link Set#parallelStream parallelStream},
+     * {@link Set#stream stream},
+     * {@link Set#spliterator spliterator} methods,
+     * any of the
+     * {@link Set#toArray toArray} overloads,
+     * or by copying the entry-set view into another collection. It is unspecified whether
+     * the obtained Entry instances are connected to the underlying map, whether changes
+     * to such an Entry will affect the underlying the map and vice-versa, and whether
+     * such an Entry supports the optional {@link Map.Entry#setValue setValue} method.
+     * <p>
+     * In addition, an Entry may be obtained directly from a map, for example via calls
+     * to methods directly on the {@link NavigableMap} interface. An entry thus obtained
+     * is generally not connected to the map and is an unmodifiable snapshot of the mapping
+     * as of the time of the call. Such an Entry also does not generally support the
+     * {@code setValue} method.
+     * <p>
+     * An Entry obtained by direct construction of the {@link AbstractMap.SimpleEntry}
+     * or {@link AbstractMap.SimpleImmutableEntry} classes or from a call to the
+     * {@link Map#entry Map.entry} or {@link Map.Entry#copyOf Map.Entry.copyOf} methods
+     * is not connected to any map.
      *
      * @apiNote
-     * It is possible to create a {@code Map.Entry} instance that is disconnected
-     * from a backing map by using the {@link Map.Entry#copyOf copyOf} method. For example,
-     * the following creates a snapshot of a map's entries that is guaranteed not to
-     * change even if the original map is modified:
+     * The exact behavior of Entry instances obtained from a map's entry-set view other than
+     * via iteration varies across different map implementations; some are connected to the
+     * backing map, and some are not. To guarantee that an Entry is disconnected from its
+     * backing map, use the {@link Map.Entry#copyOf copyOf} method. For example, the following
+     * creates a snapshot of a map's entries that is guaranteed not to change even if the
+     * original map is modified:
      * <pre> {@code
      * var entries = map.entrySet().stream().map(Map.Entry::copyOf).toList()
      * }</pre>
      *
+     * @param <K> the type of the key
+     * @param <V> the type of the value
+     *
      * @see Map#entrySet()
      * @since 1.2
      */
@@ -586,7 +608,7 @@ public interface Map<K, V> {
          *
          * @apiNote
          * An instance obtained from a map's entry-set view has a connection to that map.
-         * The {@code copyOf}  method may be used to create a {@code Map.Entry} instance,
+         * The {@code copyOf} method may be used to create a {@code Map.Entry} instance,
          * containing the same key and value, that is independent of any map.
          *
          * @implNote
@@ -659,11 +681,9 @@ public interface Map<K, V> {
      * @return the value to which the specified key is mapped, or
      * {@code defaultValue} if this map contains no mapping for the key
      * @throws ClassCastException if the key is of an inappropriate type for
-     * this map
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     * this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key is null and this map
-     * does not permit null keys
-     * (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     * does not permit null keys ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default V getOrDefault(Object key, V defaultValue) {
@@ -734,23 +754,18 @@ public interface Map<K, V> {
      *
      * @param function the function to apply to each entry
      * @throws UnsupportedOperationException if the {@code set} operation
-     * is not supported by this map's entry set iterator.
+     *         is not supported by this map's entry set iterator.
      * @throws ClassCastException if the class of a replacement value
-     * prevents it from being stored in this map
-     * @throws NullPointerException if the specified function is null, or the
-     * specified replacement value is null, and this map does not permit null
-     * values
-     * @throws ClassCastException if a replacement value is of an inappropriate
-     *         type for this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
-     * @throws NullPointerException if function or a replacement value is null,
-     *         and this map does not permit null keys or values
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         prevents it from being stored in this map
+     *         ({@linkplain Collection##optional-restrictions optional})
+     * @throws NullPointerException if the specified function is null, or if a
+     *         replacement value is null and this map does not permit null values
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of a replacement value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ConcurrentModificationException if an entry is found to be
-     * removed during iteration
+     *         removed during iteration
      * @since 1.8
      */
     default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
@@ -808,16 +823,15 @@ public interface Map<K, V> {
      *         if the implementation supports null values.)
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the key or value is of an inappropriate
-     *         type for this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         type for this map ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key or value is null,
      *         and this map does not permit null keys or values
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of the specified key
      *         or value prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default V putIfAbsent(K key, V value) {
@@ -854,13 +868,13 @@ public interface Map<K, V> {
      * @return {@code true} if the value was removed
      * @throws UnsupportedOperationException if the {@code remove} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the key or value is of an inappropriate
      *         type for this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key or value is null,
      *         and this map does not permit null keys or values
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default boolean remove(Object key, Object value) {
@@ -902,15 +916,13 @@ public interface Map<K, V> {
      * @param newValue value to be associated with the specified key
      * @return {@code true} if the value was replaced
      * @throws UnsupportedOperationException if the {@code put} operation
-     *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         is not supported by this map ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of a specified key or value
      *         prevents it from being stored in this map
      * @throws NullPointerException if a specified key or newValue is null,
      *         and this map does not permit null keys or values
      * @throws NullPointerException if oldValue is null and this map does not
-     *         permit null values
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         permit null values ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of a specified key
      *         or value prevents it from being stored in this map
      * @since 1.8
@@ -953,10 +965,10 @@ public interface Map<K, V> {
      *         if the implementation supports null values.)
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of the specified key or value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key or value is null,
      *         and this map does not permit null keys or values
      * @throws IllegalArgumentException if some property of the specified key
@@ -1036,13 +1048,13 @@ public interface Map<K, V> {
      *         is null
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of the specified key or value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of the specified key
      *         or value prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default V computeIfAbsent(K key,
@@ -1113,13 +1125,13 @@ public interface Map<K, V> {
      *         remappingFunction is null
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of the specified key or value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of the specified key
      *         or value prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default V computeIfPresent(K key,
@@ -1199,13 +1211,13 @@ public interface Map<K, V> {
      *         remappingFunction is null
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+               ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of the specified key or value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of the specified key
      *         or value prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @since 1.8
      */
     default V compute(K key,
@@ -1294,13 +1306,13 @@ public interface Map<K, V> {
      *         value is associated with the key
      * @throws UnsupportedOperationException if the {@code put} operation
      *         is not supported by this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws ClassCastException if the class of the specified key or value
      *         prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws IllegalArgumentException if some property of the specified key
      *         or value prevents it from being stored in this map
-     *         (<a href="{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
+     *         ({@linkplain Collection##optional-restrictions optional})
      * @throws NullPointerException if the specified key is null and this map
      *         does not support null keys or the value or remappingFunction is
      *         null
@@ -1730,6 +1742,8 @@ public interface Map<K, V> {
     static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
         if (map instanceof ImmutableCollections.AbstractImmutableMap) {
             return (Map<K,V>)map;
+        } else if (map.isEmpty()) { // Implicit nullcheck of map
+            return Map.of();
         } else {
             return (Map<K,V>)Map.ofEntries(map.entrySet().toArray(new Entry[0]));
         }
diff --git a/ojluni/src/main/java/java/util/Objects.java b/ojluni/src/main/java/java/util/Objects.java
index 236011f7409..c32a67441da 100644
--- a/ojluni/src/main/java/java/util/Objects.java
+++ b/ojluni/src/main/java/java/util/Objects.java
@@ -26,6 +26,7 @@
 package java.util;
 
 import jdk.internal.util.Preconditions;
+import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.function.Supplier;
 
@@ -352,8 +353,7 @@ public final class Objects {
      * @throws IndexOutOfBoundsException if the {@code index} is out of bounds
      * @since 9
      */
-    // Android-removed: @ForceInline is an unsupported attribute.
-    //@ForceInline
+    @ForceInline
     public static
     int checkIndex(int index, int length) {
         return Preconditions.checkIndex(index, length, null);
@@ -429,8 +429,7 @@ public final class Objects {
      * @throws IndexOutOfBoundsException if the {@code index} is out of bounds
      * @since 16
      */
-    // Android-removed: @ForceInline is an unsupported attribute.
-    //@ForceInline
+    @ForceInline
     public static
     long checkIndex(long index, long length) {
         return Preconditions.checkIndex(index, length, null);
diff --git a/ojluni/src/main/java/java/util/Optional.java b/ojluni/src/main/java/java/util/Optional.java
index d9f54c9d61c..479e6592e46 100644
--- a/ojluni/src/main/java/java/util/Optional.java
+++ b/ojluni/src/main/java/java/util/Optional.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -212,7 +212,7 @@ public final class Optional<T> {
      */
     public Optional<T> filter(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
-        if (!isPresent()) {
+        if (isEmpty()) {
             return this;
         } else {
             return predicate.test(value) ? this : empty();
@@ -254,7 +254,7 @@ public final class Optional<T> {
      */
     public <U> Optional<U> map(Function<? super T, ? extends U> mapper) {
         Objects.requireNonNull(mapper);
-        if (!isPresent()) {
+        if (isEmpty()) {
             return empty();
         } else {
             return Optional.ofNullable(mapper.apply(value));
@@ -282,7 +282,7 @@ public final class Optional<T> {
      */
     public <U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>> mapper) {
         Objects.requireNonNull(mapper);
-        if (!isPresent()) {
+        if (isEmpty()) {
             return empty();
         } else {
             @SuppressWarnings("unchecked")
@@ -331,7 +331,7 @@ public final class Optional<T> {
      * @since 9
      */
     public Stream<T> stream() {
-        if (!isPresent()) {
+        if (isEmpty()) {
             return Stream.empty();
         } else {
             return Stream.of(value);
diff --git a/ojluni/src/main/java/java/util/PrimitiveIterator.java b/ojluni/src/main/java/java/util/PrimitiveIterator.java
index e6fd3a57dbc..b0e07ef6e5a 100644
--- a/ojluni/src/main/java/java/util/PrimitiveIterator.java
+++ b/ojluni/src/main/java/java/util/PrimitiveIterator.java
@@ -91,6 +91,7 @@ public interface PrimitiveIterator<T, T_CONS> extends Iterator<T> {
      * An Iterator specialized for {@code int} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public static interface OfInt extends PrimitiveIterator<Integer, IntConsumer> {
 
         /**
@@ -158,6 +159,7 @@ public interface PrimitiveIterator<T, T_CONS> extends Iterator<T> {
      * An Iterator specialized for {@code long} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public static interface OfLong extends PrimitiveIterator<Long, LongConsumer> {
 
         /**
@@ -224,6 +226,7 @@ public interface PrimitiveIterator<T, T_CONS> extends Iterator<T> {
      * An Iterator specialized for {@code double} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public static interface OfDouble extends PrimitiveIterator<Double, DoubleConsumer> {
 
         /**
diff --git a/ojluni/src/main/java/java/util/RegularEnumSet.java b/ojluni/src/main/java/java/util/RegularEnumSet.java
index 1deda8a2935..f06adcbf692 100644
--- a/ojluni/src/main/java/java/util/RegularEnumSet.java
+++ b/ojluni/src/main/java/java/util/RegularEnumSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,7 @@ package java.util;
  * @since 1.5
  * @serial exclude
  */
-class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {
+final class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {
     @java.io.Serial
     private static final long serialVersionUID = 3411599620347842686L;
     /**
diff --git a/ojluni/src/main/java/java/util/Set.java b/ojluni/src/main/java/java/util/Set.java
index 4c703008a87..5ce3bf04c7c 100644
--- a/ojluni/src/main/java/java/util/Set.java
+++ b/ojluni/src/main/java/java/util/Set.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -728,6 +728,8 @@ public interface Set<E> extends Collection<E> {
     static <E> Set<E> copyOf(Collection<? extends E> coll) {
         if (coll instanceof ImmutableCollections.AbstractImmutableSet) {
             return (Set<E>)coll;
+        } else if (coll.isEmpty()) { // Implicit nullcheck of coll
+            return Set.of();
         } else {
             return (Set<E>)Set.of(new HashSet<>(coll).toArray());
         }
diff --git a/ojluni/src/main/java/java/util/SimpleTimeZone.java b/ojluni/src/main/java/java/util/SimpleTimeZone.java
index 72ce744e579..5fd63db2049 100644
--- a/ojluni/src/main/java/java/util/SimpleTimeZone.java
+++ b/ojluni/src/main/java/java/util/SimpleTimeZone.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -839,8 +839,12 @@ public class SimpleTimeZone extends TimeZone {
 
     /**
      * Queries if the given date is in daylight saving time.
+     * @implSpec The default implementation throws a
+     * {@code NullPointerException} if {@code date} is {@code null}
      * @return true if daylight saving time is in effective at the
      * given date; false otherwise.
+     * @throws NullPointerException This method may throw a
+     * {@code NullPointerException} if {@code date} is {@code null}
      */
     public boolean inDaylightTime(Date date)
     {
diff --git a/ojluni/src/main/java/java/util/Spliterator.java b/ojluni/src/main/java/java/util/Spliterator.java
index 0f49a183f12..517d71c191b 100644
--- a/ojluni/src/main/java/java/util/Spliterator.java
+++ b/ojluni/src/main/java/java/util/Spliterator.java
@@ -295,7 +295,7 @@ import java.util.function.LongConsumer;
  */
 public interface Spliterator<T> {
     /**
-     * If a remaining element exists, performs the given action on it,
+     * If a remaining element exists: performs the given action on it,
      * returning {@code true}; else returns {@code false}.  If this
      * Spliterator is {@link #ORDERED} the action is performed on the
      * next element in encounter order.  Exceptions thrown by the
@@ -304,7 +304,7 @@ public interface Spliterator<T> {
      * Subsequent behavior of a spliterator is unspecified if the action throws
      * an exception.
      *
-     * @param action The action
+     * @param action The action whose operation is performed at-most once
      * @return {@code false} if no remaining elements existed
      * upon entry to this method, else {@code true}.
      * @throws NullPointerException if the specified action is null
@@ -659,6 +659,7 @@ public interface Spliterator<T> {
      * A Spliterator specialized for {@code int} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public interface OfInt extends OfPrimitive<Integer, IntConsumer, OfInt> {
 
         @Override
@@ -723,6 +724,7 @@ public interface Spliterator<T> {
      * A Spliterator specialized for {@code long} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public interface OfLong extends OfPrimitive<Long, LongConsumer, OfLong> {
 
         @Override
@@ -787,6 +789,7 @@ public interface Spliterator<T> {
      * A Spliterator specialized for {@code double} values.
      * @since 1.8
      */
+    @SuppressWarnings("overloads")
     public interface OfDouble extends OfPrimitive<Double, DoubleConsumer, OfDouble> {
 
         @Override
diff --git a/ojluni/src/main/java/java/util/Spliterators.java b/ojluni/src/main/java/java/util/Spliterators.java
index c5d9bd7c85d..c047d96ab49 100644
--- a/ojluni/src/main/java/java/util/Spliterators.java
+++ b/ojluni/src/main/java/java/util/Spliterators.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -399,8 +399,8 @@ public final class Spliterators {
 
     /**
      * Creates a {@code Spliterator} using the given collection's
-     * {@link java.util.Collection#iterator()} as the source of elements, and
-     * reporting its {@link java.util.Collection#size()} as its initial size.
+     * {@link java.util.Collection#iterator() iterator} as the source of elements, and
+     * reporting its {@link java.util.Collection#size() size} as its initial size.
      *
      * <p>The spliterator is
      * <em><a href="Spliterator.html#binding">late-binding</a></em>, inherits
@@ -908,18 +908,21 @@ public final class Spliterators {
             OfRef() { }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfInt
                 extends EmptySpliterator<Integer, Spliterator.OfInt, IntConsumer>
                 implements Spliterator.OfInt {
             OfInt() { }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfLong
                 extends EmptySpliterator<Long, Spliterator.OfLong, LongConsumer>
                 implements Spliterator.OfLong {
             OfLong() { }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfDouble
                 extends EmptySpliterator<Double, Spliterator.OfDouble, DoubleConsumer>
                 implements Spliterator.OfDouble {
@@ -945,9 +948,12 @@ public final class Spliterators {
         private int index;        // current index, modified on advance/split
         private final int fence;  // one past last index
         private final int characteristics;
+        private long estimatedSize; // if >= 0, the estimated size, to help to split evenly
+                                    // if -1, exact size is known to be fence - index
 
         /**
          * Creates a spliterator covering all of the given array.
+         * Its size is known exactly and it is SIZED and SUBSIZED.
          * @param array the array, assumed to be unmodified during use
          * @param additionalCharacteristics Additional spliterator characteristics
          * of this spliterator's source or elements beyond {@code SIZED} and
@@ -958,7 +964,8 @@ public final class Spliterators {
         }
 
         /**
-         * Creates a spliterator covering the given array and range
+         * Creates a spliterator covering the given array and range.
+         * Its size is known exactly and it is SIZED and SUBSIZED.
          * @param array the array, assumed to be unmodified during use
          * @param origin the least index (inclusive) to cover
          * @param fence one past the greatest index to cover
@@ -971,14 +978,39 @@ public final class Spliterators {
             this.index = origin;
             this.fence = fence;
             this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;
+            this.estimatedSize = -1;
+        }
+
+        /**
+         * Creates a spliterator covering the given array and range but that is
+         * not SIZED or SUBSIZED. This case occurs as a result of splitting another
+         * spliterator that is not sized, so it's inappropriate for one of its
+         * sub-spliterators to be sized.
+         * @param array the array, assumed to be unmodified during use
+         * @param origin the least index (inclusive) to cover
+         * @param fence one past the greatest index to cover
+         * @param characteristics characteristics of this spliterator's source; {@code SIZED} and
+         *        {@code SUBSIZED} are removed if present
+         * @param estimatedSize the size estimate; should always be nonnegative
+         */
+        private ArraySpliterator(Object[] array, int origin, int fence, int characteristics, long estimatedSize) {
+            this.array = array;
+            this.index = origin;
+            this.fence = fence;
+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);
+            this.estimatedSize = estimatedSize;
         }
 
         @Override
         public Spliterator<T> trySplit() {
             int lo = index, mid = (lo + fence) >>> 1;
-            return (lo >= mid)
-                   ? null
-                   : new ArraySpliterator<>(array, lo, index = mid, characteristics);
+            if (lo >= mid) return null;
+            if (estimatedSize == -1) {
+                return new ArraySpliterator<>(array, lo, index = mid, characteristics);
+            }
+            long prefixEstimatedSize = estimatedSize >>> 1;
+            estimatedSize -= prefixEstimatedSize;
+            return new ArraySpliterator<>(array, lo, index = mid, characteristics, prefixEstimatedSize);
         }
 
         @SuppressWarnings("unchecked")
@@ -1006,7 +1038,9 @@ public final class Spliterators {
         }
 
         @Override
-        public long estimateSize() { return (long)(fence - index); }
+        public long estimateSize() {
+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);
+        }
 
         @Override
         public int characteristics() {
@@ -1030,6 +1064,7 @@ public final class Spliterators {
         private int index;        // current index, modified on advance/split
         private final int fence;  // one past last index
         private final int characteristics;
+        private long estimatedSize; // estimated size, to help to split evenly
 
         /**
          * Creates a spliterator covering all of the given array.
@@ -1056,14 +1091,27 @@ public final class Spliterators {
             this.index = origin;
             this.fence = fence;
             this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;
+            this.estimatedSize = -1;
+        }
+
+        private IntArraySpliterator(int[] array, int origin, int fence, int characteristics, long estimatedSize) {
+            this.array = array;
+            this.index = origin;
+            this.fence = fence;
+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);
+            this.estimatedSize = estimatedSize;
         }
 
         @Override
         public OfInt trySplit() {
             int lo = index, mid = (lo + fence) >>> 1;
-            return (lo >= mid)
-                   ? null
-                   : new IntArraySpliterator(array, lo, index = mid, characteristics);
+            if (lo >= mid) return null;
+            if (estimatedSize == -1) {
+                return new IntArraySpliterator(array, lo, index = mid, characteristics);
+            }
+            long prefixEstimatedSize = estimatedSize >>> 1;
+            estimatedSize -= prefixEstimatedSize;
+            return new IntArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);
         }
 
         @Override
@@ -1089,7 +1137,9 @@ public final class Spliterators {
         }
 
         @Override
-        public long estimateSize() { return (long)(fence - index); }
+        public long estimateSize() {
+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);
+        }
 
         @Override
         public int characteristics() {
@@ -1113,6 +1163,7 @@ public final class Spliterators {
         private int index;        // current index, modified on advance/split
         private final int fence;  // one past last index
         private final int characteristics;
+        private long estimatedSize; // estimated size, to help to split evenly
 
         /**
          * Creates a spliterator covering all of the given array.
@@ -1139,14 +1190,27 @@ public final class Spliterators {
             this.index = origin;
             this.fence = fence;
             this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;
+            this.estimatedSize = -1;
+        }
+
+        private LongArraySpliterator(long[] array, int origin, int fence, int characteristics, long estimatedSize) {
+            this.array = array;
+            this.index = origin;
+            this.fence = fence;
+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);
+            this.estimatedSize = estimatedSize;
         }
 
         @Override
         public OfLong trySplit() {
             int lo = index, mid = (lo + fence) >>> 1;
-            return (lo >= mid)
-                   ? null
-                   : new LongArraySpliterator(array, lo, index = mid, characteristics);
+            if (lo >= mid) return null;
+            if (estimatedSize == -1) {
+                return new LongArraySpliterator(array, lo, index = mid, characteristics);
+            }
+            long prefixEstimatedSize = estimatedSize >>> 1;
+            estimatedSize -= prefixEstimatedSize;
+            return new LongArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);
         }
 
         @Override
@@ -1172,7 +1236,9 @@ public final class Spliterators {
         }
 
         @Override
-        public long estimateSize() { return (long)(fence - index); }
+        public long estimateSize() {
+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);
+        }
 
         @Override
         public int characteristics() {
@@ -1196,6 +1262,7 @@ public final class Spliterators {
         private int index;        // current index, modified on advance/split
         private final int fence;  // one past last index
         private final int characteristics;
+        private long estimatedSize; // estimated size, to help to split evenly
 
         /**
          * Creates a spliterator covering all of the given array.
@@ -1222,14 +1289,27 @@ public final class Spliterators {
             this.index = origin;
             this.fence = fence;
             this.characteristics = additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;
+            this.estimatedSize = -1;
+        }
+
+        private DoubleArraySpliterator(double[] array, int origin, int fence, int characteristics, long estimatedSize) {
+            this.array = array;
+            this.index = origin;
+            this.fence = fence;
+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);
+            this.estimatedSize = estimatedSize;
         }
 
         @Override
         public OfDouble trySplit() {
             int lo = index, mid = (lo + fence) >>> 1;
-            return (lo >= mid)
-                   ? null
-                   : new DoubleArraySpliterator(array, lo, index = mid, characteristics);
+            if (lo >= mid) return null;
+            if (estimatedSize == -1) {
+                return new DoubleArraySpliterator(array, lo, index = mid, characteristics);
+            }
+            long prefixEstimatedSize = estimatedSize >>> 1;
+            estimatedSize -= prefixEstimatedSize;
+            return new DoubleArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);
         }
 
         @Override
@@ -1255,7 +1335,9 @@ public final class Spliterators {
         }
 
         @Override
-        public long estimateSize() { return (long)(fence - index); }
+        public long estimateSize() {
+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);
+        }
 
         @Override
         public int characteristics() {
@@ -1294,6 +1376,8 @@ public final class Spliterators {
      * extending this class, such as when there is already an iterator
      * available to use.
      *
+     * @param <T> the type of elements returned by this Spliterator
+     *
      * @see #spliterator(Iterator, long, int)
      * @since 1.8
      */
@@ -1362,9 +1446,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = holder.value; } while (++j < n && tryAdvance(holder));
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new ArraySpliterator<>(a, 0, j, characteristics());
+                    return new ArraySpliterator<>(a, 0, j, characteristics);
+                }
+                return new ArraySpliterator<>(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -1472,9 +1558,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = holder.value; } while (++j < n && tryAdvance(holder));
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new IntArraySpliterator(a, 0, j, characteristics());
+                    return new IntArraySpliterator(a, 0, j, characteristics);
+                }
+                return new IntArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -1582,9 +1670,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = holder.value; } while (++j < n && tryAdvance(holder));
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new LongArraySpliterator(a, 0, j, characteristics());
+                    return new LongArraySpliterator(a, 0, j, characteristics);
+                }
+                return new LongArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -1692,9 +1782,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = holder.value; } while (++j < n && tryAdvance(holder));
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new DoubleArraySpliterator(a, 0, j, characteristics());
+                    return new DoubleArraySpliterator(a, 0, j, characteristics);
+                }
+                return new DoubleArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -1743,11 +1835,11 @@ public final class Spliterators {
 
         /**
          * Creates a spliterator using the given
-         * collection's {@link java.util.Collection#iterator()) for traversal,
-         * and reporting its {@link java.util.Collection#size()) as its initial
+         * collection's {@link java.util.Collection#iterator() iterator} for traversal,
+         * and reporting its {@link java.util.Collection#size() size} as its initial
          * size.
          *
-         * @param c the collection
+         * @param collection the collection
          * @param characteristics properties of this spliterator's
          *        source or elements.
          */
@@ -1827,9 +1919,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = i.next(); } while (++j < n && i.hasNext());
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new ArraySpliterator<>(a, 0, j, characteristics);
+                    return new ArraySpliterator<>(a, 0, j, characteristics);
+                }
+                return new ArraySpliterator<>(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -1939,9 +2033,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = i.nextInt(); } while (++j < n && i.hasNext());
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new IntArraySpliterator(a, 0, j, characteristics);
+                    return new IntArraySpliterator(a, 0, j, characteristics);
+                }
+                return new IntArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -2033,9 +2129,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = i.nextLong(); } while (++j < n && i.hasNext());
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new LongArraySpliterator(a, 0, j, characteristics);
+                    return new LongArraySpliterator(a, 0, j, characteristics);
+                }
+                return new LongArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
@@ -2127,9 +2225,11 @@ public final class Spliterators {
                 int j = 0;
                 do { a[j] = i.nextDouble(); } while (++j < n && i.hasNext());
                 batch = j;
-                if (est != Long.MAX_VALUE)
+                if (est != Long.MAX_VALUE) {
                     est -= j;
-                return new DoubleArraySpliterator(a, 0, j, characteristics);
+                    return new DoubleArraySpliterator(a, 0, j, characteristics);
+                }
+                return new DoubleArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE / 2);
             }
             return null;
         }
diff --git a/ojluni/src/main/java/java/util/Stack.java b/ojluni/src/main/java/java/util/Stack.java
index b807d73d0b8..0d2a16de62a 100644
--- a/ojluni/src/main/java/java/util/Stack.java
+++ b/ojluni/src/main/java/java/util/Stack.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,8 @@ package java.util;
  * <pre>   {@code
  *   Deque<Integer> stack = new ArrayDeque<Integer>();}</pre>
  *
+ * @param <E> Type of component elements
+ *
  * @author  Jonathan Payne
  * @since   1.0
  */
diff --git a/ojluni/src/main/java/java/util/TEST_MAPPING b/ojluni/src/main/java/java/util/TEST_MAPPING
index a8ec92da24d..16206998e26 100644
--- a/ojluni/src/main/java/java/util/TEST_MAPPING
+++ b/ojluni/src/main/java/java/util/TEST_MAPPING
@@ -1,28 +1,12 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.util"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.util"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_java_util"
     }
   ],
   "presubmit-large": [
     {
-      "name": "CtsLibcoreOjTestCases",
-      "options": [
-        {
-          "include-filter": "test.java.util"
-        },
-        {
-          "include-filter": "org.openjdk.tests.java.util"
-        }
-      ]
+      "name": "CtsLibcoreOjTestCases_util"
     }
   ]
 }
diff --git a/ojluni/src/main/java/java/util/TimeZone.java b/ojluni/src/main/java/java/util/TimeZone.java
index a1ee972332a..64e3b298115 100644
--- a/ojluni/src/main/java/java/util/TimeZone.java
+++ b/ojluni/src/main/java/java/util/TimeZone.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1996, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -52,6 +52,7 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import libcore.io.IoUtils;
 import libcore.util.ZoneInfo;
+import java.time.ZoneOffset;
 
 import dalvik.system.RuntimeHooks;
 
@@ -70,9 +71,11 @@ import dalvik.system.RuntimeHooks;
  * along with a time zone ID. For instance, the time zone ID for the
  * U.S. Pacific Time zone is "America/Los_Angeles". So, you can get a
  * U.S. Pacific Time {@code TimeZone} object with:
- * <blockquote><pre>
+ * <blockquote>
+ * {@snippet lang=java :
  * TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");
- * </pre></blockquote>
+ * }
+ * </blockquote>
  * You can use the {@code getAvailableIDs} method to iterate through
  * all the supported time zone IDs. You can then choose a
  * supported ID to get a {@code TimeZone}.
@@ -82,6 +85,7 @@ import dalvik.system.RuntimeHooks;
  *
  * <blockquote><pre>
  * <a id="CustomID"><i>CustomID:</i></a>
+ *         {@code GMT} <i>Sign</i> <i>Hours</i> {@code :} <i>Minutes</i> {@code :} <i>Seconds</i>
  *         {@code GMT} <i>Sign</i> <i>Hours</i> {@code :} <i>Minutes</i>
  *         {@code GMT} <i>Sign</i> <i>Hours</i> <i>Minutes</i>
  *         {@code GMT} <i>Sign</i> <i>Hours</i>
@@ -92,11 +96,13 @@ import dalvik.system.RuntimeHooks;
  *         <i>Digit</i> <i>Digit</i>
  * <i>Minutes:</i>
  *         <i>Digit</i> <i>Digit</i>
+ * <i>Seconds:</i>
+ *         <i>Digit</i> <i>Digit</i>
  * <i>Digit:</i> one of
  *         {@code 0 1 2 3 4 5 6 7 8 9}
  * </pre></blockquote>
  *
- * <i>Hours</i> must be between 0 to 23 and <i>Minutes</i> must be
+ * <i>Hours</i> must be between 0 to 23 and <i>Minutes</i>/<i>Seconds</i> must be
  * between 00 to 59.  For example, "GMT+10" and "GMT+0010" mean ten
  * hours and ten minutes ahead of GMT, respectively.
  * <p>
@@ -110,17 +116,20 @@ import dalvik.system.RuntimeHooks;
  * zone ID is normalized in the following syntax:
  * <blockquote><pre>
  * <a id="NormalizedCustomID"><i>NormalizedCustomID:</i></a>
- *         {@code GMT} <i>Sign</i> <i>TwoDigitHours</i> {@code :} <i>Minutes</i>
+ *         {@code GMT} <i>Sign</i> <i>TwoDigitHours</i> {@code :} <i>Minutes</i> [<i>ColonSeconds</i>]
  * <i>Sign:</i> one of
  *         {@code + -}
  * <i>TwoDigitHours:</i>
  *         <i>Digit</i> <i>Digit</i>
  * <i>Minutes:</i>
  *         <i>Digit</i> <i>Digit</i>
+ * <i>ColonSeconds:</i>
+ *         {@code :} <i>Digit</i> <i>Digit</i>
  * <i>Digit:</i> one of
  *         {@code 0 1 2 3 4 5 6 7 8 9}
  * </pre></blockquote>
  * For example, TimeZone.getTimeZone("GMT-8").getID() returns "GMT-08:00".
+ * <i>ColonSeconds</i> part only appears if the seconds value is non-zero.
  *
  * <h2>Three-letter time zone IDs</h2>
  *
@@ -165,7 +174,18 @@ public abstract class TimeZone implements Serializable, Cloneable {
     // Android-changed: Use a preload holder to allow compile-time initialization of TimeZone and
     // dependents.
     private static class NoImagePreloadHolder {
-        public static final Pattern CUSTOM_ZONE_ID_PATTERN = Pattern.compile("^GMT[-+](\\d{1,2})(:?(\\d\\d))?$");
+        // Custom time zone ID can only have one of the following forms:
+        // 1. GMT Sign Hours
+        // 2. GMT Sign Hours Minutes
+        // 3. GMT Sign Hours : Minutes
+        // 4. GMT Sign Hours : Minutes : Seconds
+        // The second capturing group is either:
+        // * Absent (then input matches the 1st form).
+        // * Consists of only 2 digits (matches the 2nd form).
+        // * Consists of colon and 2 digits (matches the 3rd form).
+        // * Or has the 4th form: colon followed by 2 digits, followed by colon and 2 digits.
+        public static final Pattern CUSTOM_ZONE_ID_PATTERN =
+                Pattern.compile("^GMT[-+](\\d{1,2})((\\d\\d)|:((\\d\\d)(:(\\d\\d))?))?");
     }
 
     // Proclaim serialization compatibility with JDK 1.1
@@ -299,7 +319,11 @@ public abstract class TimeZone implements Serializable, Cloneable {
     /**
      * Sets the time zone ID. This does not change any other data in
      * the time zone object.
+     * @implSpec The default implementation throws a
+     * {@code NullPointerException} if {@code ID} is {@code null}
      * @param ID the new time zone ID.
+     * @throws NullPointerException This method may throw a
+     * {@code NullPointerException} if {@code ID} is {@code null}
      */
     public void setID(String ID)
     {
@@ -314,10 +338,14 @@ public abstract class TimeZone implements Serializable, Cloneable {
      * presentation to the user in the default locale.
      *
      * <p>This method is equivalent to:
-     * <blockquote><pre>
-     * getDisplayName(false, {@link #LONG},
-     *                Locale.getDefault({@link Locale.Category#DISPLAY}))
-     * </pre></blockquote>
+     * <blockquote>
+     * {@snippet lang=java :
+     * // @link substring="LONG" target="#LONG" :
+     * getDisplayName(false, LONG,
+     *                // @link substring="Locale.Category.DISPLAY" target="Locale.Category#DISPLAY" :
+     *                Locale.getDefault(Locale.Category.DISPLAY));
+     * }
+     * </blockquote>
      *
      * @return the human-readable name of this time zone in the default locale.
      * @since 1.2
@@ -335,9 +363,12 @@ public abstract class TimeZone implements Serializable, Cloneable {
      * presentation to the user in the specified {@code locale}.
      *
      * <p>This method is equivalent to:
-     * <blockquote><pre>
-     * getDisplayName(false, {@link #LONG}, locale)
-     * </pre></blockquote>
+     * <blockquote>
+     * {@snippet lang=java :
+     * // @link substring="LONG" target="#LONG" :
+     * getDisplayName(false, LONG, locale);
+     * }
+     * </blockquote>
      *
      * @param locale the locale in which to supply the display name.
      * @return the human-readable name of this time zone in the given locale.
@@ -357,10 +388,13 @@ public abstract class TimeZone implements Serializable, Cloneable {
      * Time). Otherwise, a Standard Time name is returned.
      *
      * <p>This method is equivalent to:
-     * <blockquote><pre>
+     * <blockquote>
+     * {@snippet lang=java :
      * getDisplayName(daylight, style,
-     *                Locale.getDefault({@link Locale.Category#DISPLAY}))
-     * </pre></blockquote>
+     *                // @link substring="Locale.Category.DISPLAY" target="Locale.Category#DISPLAY" :
+     *                Locale.getDefault(Locale.Category.DISPLAY));
+     * }
+     * </blockquote>
      *
      * @param daylight {@code true} specifying a Daylight Saving Time name, or
      *                 {@code false} specifying a Standard Time name
@@ -378,16 +412,29 @@ public abstract class TimeZone implements Serializable, Cloneable {
                               Locale.getDefault(Locale.Category.DISPLAY));
     }
 
+    // Android-changed: ResourceBundle section removed.
     /**
      * Returns the {@link #SHORT short} or {@link #LONG long} name of this time
      * zone with either standard or daylight time, as written in {@code locale}.
      * If the name is not available, the result is in the format
      * {@code GMT[+-]hh:mm}.
      *
-     * @param daylightTime true for daylight time, false for standard time.
-     * @param style either {@link TimeZone#LONG} or {@link TimeZone#SHORT}.
-     * @param locale the display locale.
+     * @implSpec The default implementation throws an
+     * {@code IllegalArgumentException} if {@code style} is invalid or a
+     * {@code NullPointerException} if {@code ID} is {@code null}.
+     * @param daylightTime {@code true} specifying a Daylight Saving Time name, or
+     *                 {@code false} specifying a Standard Time name
+     * @param style either {@link #LONG} or {@link #SHORT}
+     * @param locale   the locale in which to supply the display name.
+     * @return the human-readable name of this time zone in the given locale.
+     * @throws IllegalArgumentException This method may throw an
+     * {@code IllegalArgumentException} if {@code style} is invalid.
+     * @throws NullPointerException This method may throw a
+     * {@code NullPointerException} if {@code ID} is {@code null}
+     * @since 1.2
+     * @see java.text.DateFormatSymbols#getZoneStrings()
      */
+    // Android-changed: daylight -> daylightTime.
     public String getDisplayName(boolean daylightTime, int style, Locale locale) {
         // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames
         TimeZoneNames.NameType nameType;
@@ -548,6 +595,8 @@ public abstract class TimeZone implements Serializable, Cloneable {
      * @param date the given Date.
      * @return {@code true} if the given date is in Daylight Saving Time,
      *         {@code false}, otherwise.
+     * @throws NullPointerException This method may throw a
+     * {@code NullPointerException} if {@code date} is {@code null}
      */
     public abstract boolean inDaylightTime(Date date);
 
@@ -561,6 +610,7 @@ public abstract class TimeZone implements Serializable, Cloneable {
      *
      * @return the specified {@code TimeZone}, or the GMT zone if the given ID
      * cannot be understood.
+     * @throws NullPointerException if {@code ID} is {@code null}
      */
     // Android-changed: param s/ID/id; use ZoneInfoDb instead of ZoneInfo class.
     public static synchronized TimeZone getTimeZone(String id) {
@@ -603,6 +653,16 @@ public abstract class TimeZone implements Serializable, Cloneable {
      */
     public static TimeZone getTimeZone(ZoneId zoneId) {
         String tzid = zoneId.getId(); // throws an NPE if null
+        // BEGIN Android-removed: sun.util.calendar.ZoneInfo is not available.
+        /*
+        if (zoneId instanceof ZoneOffset zo) {
+            var totalMillis = zo.getTotalSeconds() * 1_000;
+            return new ZoneInfo(totalMillis == 0 ? "UTC" : GMT_ID + tzid, totalMillis);
+        } else if (tzid.startsWith("UT") && !tzid.equals("UTC")) {
+            tzid = tzid.replaceFirst("(UTC|UT)(.*)", "GMT$2");
+        }
+        */
+        // END Android-removed: sun.util.calendar.ZoneInfo is not available.
         char c = tzid.charAt(0);
         if (c == '+' || c == '-') {
             tzid = "GMT" + tzid;
@@ -625,7 +685,8 @@ public abstract class TimeZone implements Serializable, Cloneable {
     }
 
     /**
-     * Returns a new SimpleTimeZone for an ID of the form "GMT[+|-]hh[[:]mm]", or null.
+     * Returns a new SimpleTimeZone for an ID of the form either "GMT[+|-]hh[[:]mm]" or
+     * GMT[+|-]hh:mm:SS, or null.
      */
     private static TimeZone getCustomTimeZone(String id) {
         Matcher m = NoImagePreloadHolder.CUSTOM_ZONE_ID_PATTERN.matcher(id);
@@ -635,26 +696,38 @@ public abstract class TimeZone implements Serializable, Cloneable {
 
         int hour;
         int minute = 0;
+        int second = 0;
         try {
             hour = Integer.parseInt(m.group(1));
             if (m.group(3) != null) {
                 minute = Integer.parseInt(m.group(3));
             }
+            if (m.group(5) != null) {
+                minute = Integer.parseInt(m.group(5));
+            }
+            if (m.group(7) != null) {
+                second = Integer.parseInt(m.group(7));
+            }
         } catch (NumberFormatException impossible) {
             throw new AssertionError(impossible);
         }
 
-        if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
+        if (hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
             return null;
         }
 
         char sign = id.charAt(3);
-        int raw = (hour * 3600000) + (minute * 60000);
+        int raw = (hour * 3600000) + (minute * 60000) + second * 1000;
         if (sign == '-') {
             raw = -raw;
         }
 
-        String cleanId = String.format(Locale.ROOT, "GMT%c%02d:%02d", sign, hour, minute);
+        String cleanId;
+        if (second == 0) {
+            cleanId = String.format(Locale.ROOT, "GMT%c%02d:%02d", sign, hour, minute);
+        } else {
+            cleanId = String.format(Locale.ROOT, "GMT%c%02d:%02d:%02d", sign, hour, minute, second);
+        }
 
         return new SimpleTimeZone(raw, cleanId);
     }
@@ -692,12 +765,13 @@ public abstract class TimeZone implements Serializable, Cloneable {
      */
     private static native String getSystemGMTOffsetID();
 
+    // Android-changed: removed section about the way default time zone ID is stored / fetched.
     /**
      * Gets the default <code>TimeZone</code> for this host.
      * The source of the default <code>TimeZone</code>
      * may vary with implementation.
      * @return a default <code>TimeZone</code>.
-     * @see #setDefault
+     * @see #setDefault(TimeZone)
      */
     public static TimeZone getDefault() {
         return (TimeZone) getDefaultRef().clone();
@@ -721,7 +795,7 @@ public abstract class TimeZone implements Serializable, Cloneable {
                 } catch (IOException ex) {
                     // "vogar --mode device" can end up here.
                     // TODO: give libcore access to Android system properties and read "persist.sys.timezone".
-                    zoneName = "GMT";
+                    zoneName = GMT_ID;
                 }
             }
             defaultTimeZone = TimeZone.getTimeZone(zoneName);
@@ -729,9 +803,65 @@ public abstract class TimeZone implements Serializable, Cloneable {
         return defaultTimeZone;
     }
 
+    // BEGIN Android-removed: different getDefault / setDefault implementation.
+    /*
+     * Returns the reference to the default TimeZone object. This
+     * method doesn't create a clone.
+     *
+    static TimeZone getDefaultRef() {
+        TimeZone defaultZone = defaultTimeZone;
+        if (defaultZone == null) {
+            // Need to initialize the default time zone.
+            defaultZone = setDefaultZone();
+            assert defaultZone != null;
+        }
+        // Don't clone here.
+        return defaultZone;
+    }
+
+    private static synchronized TimeZone setDefaultZone() {
+        TimeZone tz;
+        // get the time zone ID from the system properties
+        Properties props = GetPropertyAction.privilegedGetProperties();
+        String zoneID = props.getProperty("user.timezone");
+
+        // if the time zone ID is not set (yet), perform the
+        // platform to Java time zone ID mapping.
+        if (zoneID == null || zoneID.isEmpty()) {
+            zoneID = getSystemTimeZoneID(StaticProperty.javaHome());
+            if (zoneID == null) {
+                zoneID = GMT_ID;
+            }
+        }
+
+        // Get the time zone for zoneID. But not fall back to
+        // "GMT" here.
+        tz = getTimeZone(zoneID, false);
+
+        if (tz == null) {
+            // If the given zone ID is unknown in Java, try to
+            // get the GMT-offset-based time zone ID,
+            // a.k.a. custom time zone ID (e.g., "GMT-08:00").
+            String gmtOffsetID = getSystemGMTOffsetID();
+            if (gmtOffsetID != null) {
+                zoneID = gmtOffsetID;
+            }
+            tz = getTimeZone(zoneID, true);
+        }
+        assert tz != null;
+
+        final String id = zoneID;
+        props.setProperty("user.timezone", id);
+
+        defaultTimeZone = tz;
+        return tz;
+    }
+    */
+    // END Android-removed: different getDefault / setDefault implementation.
+
     /**
      * Sets the {@code TimeZone} that is returned by the {@code getDefault}
-     * method. {@code timeZone} is cached. If {@code timeZone} is null, the cached
+     * method. {@code zone} is cached. If {@code zone} is null, the cached
      * default {@code TimeZone} is cleared. This method doesn't change the value
      * of the {@code user.timezone} property.
      *
@@ -747,7 +877,12 @@ public abstract class TimeZone implements Serializable, Cloneable {
             sm.checkPermission(new PropertyPermission
                     ("user.timezone", "write"));
         }
-        defaultTimeZone = timeZone != null ? (TimeZone) timeZone.clone() : null;
+        // by saving a defensive clone and returning a clone in getDefault() too,
+        // the defaultTimeZone instance is isolated from user code which makes it
+        // effectively immutable. This is important to avoid races when the
+        // following is evaluated in ZoneId.systemDefault():
+        // TimeZone.getDefault().toZoneId().
+        defaultTimeZone = (timeZone == null) ? null : (TimeZone) timeZone.clone();
         // Android-changed: notify ICU4J of changed default TimeZone.
         ExtendedTimeZone.clearDefaultTimeZone();
     }
@@ -797,4 +932,122 @@ public abstract class TimeZone implements Serializable, Cloneable {
      */
     private String           ID;
     private static volatile TimeZone defaultTimeZone;
+
+    static final String         GMT_ID        = "GMT";
+    // Android-removed: different setDefault / getDefault implementation.
+    /*
+    private static final int    GMT_ID_LENGTH = 3;
+
+     *
+     * Parses a custom time zone identifier and returns a corresponding zone.
+     * This method doesn't support the RFC 822 time zone format. (e.g., +hhmm)
+     *
+     * @param id a string of the <a href="#CustomID">custom ID form</a>.
+     * @return a newly created TimeZone with the given offset and
+     * no daylight saving time, or null if the id cannot be parsed.
+     *
+    private static final TimeZone parseCustomTimeZone(String id) {
+        int length;
+
+        // Error if the length of id isn't long enough or id doesn't
+        // start with "GMT".
+        if ((length = id.length()) < (GMT_ID_LENGTH + 2) ||
+            id.indexOf(GMT_ID) != 0) {
+            return null;
+        }
+
+        ZoneInfo zi;
+
+        // First, we try to find it in the cache with the given
+        // id. Even the id is not normalized, the returned ZoneInfo
+        // should have its normalized id.
+        zi = ZoneInfoFile.getZoneInfo(id);
+        if (zi != null) {
+            return zi;
+        }
+
+        int index = GMT_ID_LENGTH;
+        boolean negative = false;
+        char c = id.charAt(index++);
+        if (c == '-') {
+            negative = true;
+        } else if (c != '+') {
+            return null;
+        }
+
+        int hours = 0;
+        int minutes = 0;
+        int num = 0;
+        int countDelim = 0;
+        int len = 0;
+        while (index < length) {
+            c = id.charAt(index++);
+            if (c == ':') {
+                if (countDelim > 1) {
+                    return null;
+                }
+                if (len == 0 || len > 2) {
+                    return null;
+                }
+                if (countDelim == 0) {
+                    hours = num;
+                } else if (countDelim == 1){
+                    minutes = num;
+                }
+                countDelim++;
+                num = 0;
+                len = 0;
+                continue;
+            }
+            if (c < '0' || c > '9') {
+                return null;
+            }
+            num = num * 10 + (c - '0');
+            len++;
+        }
+        if (index != length) {
+            return null;
+        }
+        if (countDelim == 0) {
+            if (len <= 2) {
+                hours = num;
+                minutes = 0;
+                num = 0;
+            } else if (len <= 4) {
+                hours = num / 100;
+                minutes = num % 100;
+                num = 0;
+            } else {
+                return null;
+            }
+        } else if (countDelim == 1){
+            if (len == 2) {
+                minutes = num;
+                num = 0;
+            } else {
+                return null;
+            }
+        } else {
+            if (len != 2) {
+                return null;
+            }
+        }
+        if (hours > 23 || minutes > 59 || num > 59) {
+            return null;
+        }
+        int gmtOffset =  (hours * 3_600 + minutes * 60 + num) * 1_000;
+
+        if (gmtOffset == 0) {
+            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
+            if (negative) {
+                zi.setID("GMT-00:00");
+            } else {
+                zi.setID("GMT+00:00");
+            }
+        } else {
+            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
+        }
+        return zi;
+    }
+    */
 }
diff --git a/ojluni/src/main/java/java/util/Timer.java b/ojluni/src/main/java/java/util/Timer.java
index 6b8b7084143..1a4089d5698 100644
--- a/ojluni/src/main/java/java/util/Timer.java
+++ b/ojluni/src/main/java/java/util/Timer.java
@@ -30,6 +30,12 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.lang.ref.Cleaner.Cleanable;
 import jdk.internal.ref.CleanerFactory;
 
+import android.compat.annotation.ChangeId;
+import android.compat.annotation.EnabledAfter;
+import android.compat.Compatibility;
+
+import dalvik.annotation.compat.VersionCodes;
+
 /**
  * A facility for threads to schedule tasks for future execution in a
  * background thread.  Tasks may be scheduled for one-time execution, or for
@@ -90,6 +96,27 @@ import jdk.internal.ref.CleanerFactory;
  */
 
 public class Timer {
+    /**
+     * For fixed rate tasks, prevent multiple tasks from running back-to-back to
+     * account for missed periods.
+     * On Android, it's often the case that app processes will miss multiple
+     * scheduled periods because the CPU often enters suspended states, or
+     * because app processes may be moved to the Cached Apps Freezer.
+     * This flag prevents apps from thrashing upon exiting suspend or frozen
+     * states to needlessly "catch up" to lost time.
+     *
+     * @hide
+     */
+    @ChangeId
+    @EnabledAfter(targetSdkVersion = VersionCodes.VANILLA_ICE_CREAM)
+    public static final long SKIP_MULTIPLE_MISSED_PERIODIC_TASKS = 351566728L;
+
+    /** @hide */
+    public static boolean skipMultipleMissedPeriodicTasks() {
+        return Compatibility.isChangeEnabled(
+            SKIP_MULTIPLE_MISSED_PERIODIC_TASKS);
+    }
+
     /**
      * The timer task queue.  This data structure is shared with the timer
      * thread.  The timer produces tasks, via its various schedule calls,
@@ -338,6 +365,16 @@ public class Timer {
      * @throws IllegalStateException if task was already scheduled or
      *         cancelled, timer was cancelled, or timer thread terminated.
      * @throws NullPointerException if {@code task} is null
+     *
+     * <p>Since API level 31: If the app is frozen by the Android cached apps
+     * freezer before the fixed rate task is done or canceled, the task may run
+     * many times immediately when the app unfreezes, just as if a single
+     * execution of the command had taken the duration of the frozen period to
+     * execute.
+     *
+     * <p>Since API level 36: If any execution of this task takes longer than
+     * its period, then the subsequent execution will be scheduled for the most
+     * recent missed period.
      */
     public void scheduleAtFixedRate(TimerTask task, long delay, long period) {
         if (delay < 0)
@@ -533,6 +570,7 @@ class TimerThread extends Thread {
     /**
      * The main timer loop.  (See class comment.)
      */
+    // Android-changed: b/351566728 relax scheduling on missed repeating tasks.
     private void mainLoop() {
         while (true) {
             try {
@@ -546,28 +584,34 @@ class TimerThread extends Thread {
                         break; // Queue is empty and will forever remain; die
 
                     // Queue nonempty; look at first evt and do the right thing
-                    long currentTime, executionTime;
+                    long now, execTime;
                     task = queue.getMin();
                     synchronized(task.lock) {
                         if (task.state == TimerTask.CANCELLED) {
                             queue.removeMin();
                             continue;  // No action required, poll queue again
                         }
-                        currentTime = System.currentTimeMillis();
-                        executionTime = task.nextExecutionTime;
-                        if (taskFired = (executionTime<=currentTime)) {
-                            if (task.period == 0) { // Non-repeating, remove
+                        now = System.currentTimeMillis();
+                        execTime = task.nextExecutionTime;
+                        if (taskFired = (execTime<=now)) {
+                            final long p = task.period;
+                            if (p == 0) { // Non-repeating, remove
                                 queue.removeMin();
                                 task.state = TimerTask.EXECUTED;
-                            } else { // Repeating task, reschedule
-                                queue.rescheduleMin(
-                                  task.period<0 ? currentTime   - task.period
-                                                : executionTime + task.period);
+                            } else if (p < 0) { // Fixed delay
+                                queue.rescheduleMin(now - p);
+                            } else { // Fixed rate
+                                long newTime = execTime + p;
+                                if (Timer.skipMultipleMissedPeriodicTasks()
+                                        && (newTime < now - p)) {
+                                    newTime = now - ((now - execTime + p) % p);
+                                }
+                                queue.rescheduleMin(newTime);
                             }
                         }
                     }
                     if (!taskFired) // Task hasn't yet fired; wait
-                        queue.wait(executionTime - currentTime);
+                        queue.wait(execTime - now);
                 }
                 if (taskFired)  // Task fired; run it, holding no locks
                     task.run();
diff --git a/ojluni/src/main/java/java/util/WeakHashMap.java b/ojluni/src/main/java/java/util/WeakHashMap.java
index 03aee09e992..93406750666 100644
--- a/ojluni/src/main/java/java/util/WeakHashMap.java
+++ b/ojluni/src/main/java/java/util/WeakHashMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -198,6 +198,10 @@ public class WeakHashMap<K,V>
      * Constructs a new, empty {@code WeakHashMap} with the given initial
      * capacity and the given load factor.
      *
+     * @apiNote
+     * To create a {@code WeakHashMap} with an initial capacity that accommodates
+     * an expected number of mappings, use {@link #newWeakHashMap(int) newWeakHashMap}.
+     *
      * @param  initialCapacity The initial capacity of the {@code WeakHashMap}
      * @param  loadFactor      The load factor of the {@code WeakHashMap}
      * @throws IllegalArgumentException if the initial capacity is negative,
@@ -213,9 +217,7 @@ public class WeakHashMap<K,V>
         if (loadFactor <= 0 || Float.isNaN(loadFactor))
             throw new IllegalArgumentException("Illegal Load factor: "+
                                                loadFactor);
-        int capacity = 1;
-        while (capacity < initialCapacity)
-            capacity <<= 1;
+        int capacity = HashMap.tableSizeFor(initialCapacity);
         table = newTable(capacity);
         this.loadFactor = loadFactor;
         threshold = (int)(capacity * loadFactor);
@@ -225,6 +227,10 @@ public class WeakHashMap<K,V>
      * Constructs a new, empty {@code WeakHashMap} with the given initial
      * capacity and the default load factor (0.75).
      *
+     * @apiNote
+     * To create a {@code WeakHashMap} with an initial capacity that accommodates
+     * an expected number of mappings, use {@link #newWeakHashMap(int) newWeakHashMap}.
+     *
      * @param  initialCapacity The initial capacity of the {@code WeakHashMap}
      * @throws IllegalArgumentException if the initial capacity is negative
      */
@@ -251,7 +257,7 @@ public class WeakHashMap<K,V>
      * @since   1.3
      */
     public WeakHashMap(Map<? extends K, ? extends V> m) {
-        this(Math.max((int) ((float)m.size() / DEFAULT_LOAD_FACTOR + 1.0F),
+        this(Math.max((int) Math.ceil(m.size() / (double)DEFAULT_LOAD_FACTOR),
                 DEFAULT_INITIAL_CAPACITY),
              DEFAULT_LOAD_FACTOR);
         putAll(m);
@@ -468,7 +474,7 @@ public class WeakHashMap<K,V>
         modCount++;
         Entry<K,V> e = tab[i];
         tab[i] = new Entry<>(k, value, queue, h, e);
-        if (++size >= threshold)
+        if (++size > threshold)
             resize(tab.length * 2);
         return null;
     }
@@ -557,7 +563,7 @@ public class WeakHashMap<K,V>
          * to at most one extra resize.
          */
         if (numKeysToBeAdded > threshold) {
-            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
+            int targetCapacity = (int)Math.ceil(numKeysToBeAdded / (double)loadFactor);
             if (targetCapacity > MAXIMUM_CAPACITY)
                 targetCapacity = MAXIMUM_CAPACITY;
             int newCapacity = table.length;
@@ -1040,7 +1046,7 @@ public class WeakHashMap<K,V>
         Objects.requireNonNull(function);
         int expectedModCount = modCount;
 
-        Entry<K, V>[] tab = getTable();;
+        Entry<K, V>[] tab = getTable();
         for (Entry<K, V> entry : tab) {
             while (entry != null) {
                 Object key = entry.get();
@@ -1337,4 +1343,24 @@ public class WeakHashMap<K,V>
         }
     }
 
+    /**
+     * Creates a new, empty WeakHashMap suitable for the expected number of mappings.
+     * The returned map uses the default load factor of 0.75, and its initial capacity is
+     * generally large enough so that the expected number of mappings can be added
+     * without resizing the map.
+     *
+     * @param numMappings the expected number of mappings
+     * @param <K>         the type of keys maintained by the new map
+     * @param <V>         the type of mapped values
+     * @return the newly created map
+     * @throws IllegalArgumentException if numMappings is negative
+     * @since 19
+     */
+    public static <K, V> WeakHashMap<K, V> newWeakHashMap(int numMappings) {
+        if (numMappings < 0) {
+            throw new IllegalArgumentException("Negative number of mappings: " + numMappings);
+        }
+        return new WeakHashMap<>(HashMap.calculateHashMapCapacity(numMappings));
+    }
+
 }
diff --git a/ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java b/ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java
index 192df252f20..34cceeb1bc5 100644
--- a/ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java
+++ b/ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java
@@ -38,6 +38,12 @@ package java.util.concurrent;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
+import android.compat.annotation.ChangeId;
+import android.compat.annotation.EnabledAfter;
+import android.compat.Compatibility;
+
+import dalvik.annotation.compat.VersionCodes;
+
 import java.util.AbstractQueue;
 import java.util.Arrays;
 import java.util.Collection;
@@ -137,6 +143,27 @@ public class ScheduledThreadPoolExecutor
         extends ThreadPoolExecutor
         implements ScheduledExecutorService {
 
+    /**
+     * For fixed rate tasks, prevent multiple tasks from running back-to-back to
+     * account for missed periods.
+     * On Android, it's often the case that app processes will miss multiple
+     * scheduled periods because the CPU often enters suspended states, or
+     * because app processes may be moved to the Cached Apps Freezer.
+     * This flag prevents apps from thrashing upon exiting suspend or frozen
+     * states to needlessly "catch up" to lost time.
+     *
+     * @hide
+     */
+    @ChangeId
+    @EnabledAfter(targetSdkVersion = VersionCodes.VANILLA_ICE_CREAM)
+    public static final long STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS = 288912692L;
+
+    /** @hide */
+    public static boolean skipMultipleMissedPeriodicTasks() {
+        return Compatibility.isChangeEnabled(
+            STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS);
+    }
+
     /*
      * This class specializes ThreadPoolExecutor implementation by
      *
@@ -279,12 +306,25 @@ public class ScheduledThreadPoolExecutor
         /**
          * Sets the next time to run for a periodic task.
          */
+        // Android-changed: b/288912692 relax scheduling on missed fixed rate
+        // tasks.
         private void setNextRunTime() {
             long p = period;
-            if (p > 0)
+            if (p > 0) {
+                // Schedule for one period past the last start
                 time += p;
-            else
+                if (skipMultipleMissedPeriodicTasks()) {
+                    final long now = System.nanoTime();
+                    // If next schedule is in the past
+                    if (time < now - period) {
+                        // Schedule for last missed period, so we don't attempt
+                        // to catch up the rate to multiple missed tasks.
+                        time = now - ((now - time + p) % p);
+                    }
+                }
+            } else {
                 time = triggerTime(-p);
+            }
         }
 
         public boolean cancel(boolean mayInterruptIfRunning) {
@@ -612,10 +652,16 @@ public class ScheduledThreadPoolExecutor
      * {@link Future#isDone isDone()} on the returned future will
      * return {@code true}.
      *
-     * <p>If any execution of this task takes longer than its period, then
-     * subsequent executions may start late, but will not concurrently
+     * <p>Since API level 31: If the app is frozen by the Android cached apps
+     * freezer before the fixed rate task is done or canceled, the task may run
+     * many times immediately when the app unfreezes, just as if a single
+     * execution of the command had taken the duration of the frozen period to
      * execute.
      *
+     * <p>Since API level 36: If any execution of this task takes longer than
+     * its period, then the subsequent execution will be scheduled for the most
+     * recent missed period.
+     *
      * @throws RejectedExecutionException {@inheritDoc}
      * @throws NullPointerException       {@inheritDoc}
      * @throws IllegalArgumentException   {@inheritDoc}
diff --git a/ojluni/src/main/java/java/util/concurrent/TEST_MAPPING b/ojluni/src/main/java/java/util/concurrent/TEST_MAPPING
index 5730a289f90..08216278107 100644
--- a/ojluni/src/main/java/java/util/concurrent/TEST_MAPPING
+++ b/ojluni/src/main/java/java/util/concurrent/TEST_MAPPING
@@ -7,14 +7,6 @@
           "include-filter": "jsr166"
         }
       ]
-    },
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.util.concurrent"
-        }
-      ]
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java
index 1555c22caa4..d8cb9869afe 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java
@@ -260,7 +260,7 @@ public class AtomicBoolean implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -278,7 +278,7 @@ public class AtomicBoolean implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -296,7 +296,7 @@ public class AtomicBoolean implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java
index b77e08e66cf..ffde955735f 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java
@@ -510,7 +510,7 @@ public class AtomicInteger extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -528,7 +528,7 @@ public class AtomicInteger extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -546,7 +546,7 @@ public class AtomicInteger extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java
index f59327da98a..676788e4204 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java
@@ -470,7 +470,7 @@ public class AtomicIntegerArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -488,7 +488,7 @@ public class AtomicIntegerArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -506,7 +506,7 @@ public class AtomicIntegerArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java
index 323a5135d15..def3e7ade8a 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java
@@ -525,7 +525,7 @@ public class AtomicLong extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -543,7 +543,7 @@ public class AtomicLong extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -561,7 +561,7 @@ public class AtomicLong extends Number implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java
index 24e42a1ea81..af2ff6729fd 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java
@@ -470,7 +470,7 @@ public class AtomicLongArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -488,7 +488,7 @@ public class AtomicLongArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -506,7 +506,7 @@ public class AtomicLongArray implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java
index 03dd039ce45..b2c692df5e7 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java
@@ -353,7 +353,7 @@ public class AtomicReference<V> implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -369,7 +369,7 @@ public class AtomicReference<V> implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -385,7 +385,7 @@ public class AtomicReference<V> implements java.io.Serializable {
      *
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java
index b1ad0a91524..f85fb9376ad 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java
@@ -434,7 +434,7 @@ public class AtomicReferenceArray<E> implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -452,7 +452,7 @@ public class AtomicReferenceArray<E> implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
@@ -470,7 +470,7 @@ public class AtomicReferenceArray<E> implements java.io.Serializable {
      * @param i the index
      * @param expectedValue the expected value
      * @param newValue the new value
-     * @return the witness value, which will be the same as the
+     * @return the <em>witness value</em>, which will be the same as the
      * expected value if successful
      * @since 9
      */
diff --git a/ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java b/ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java
index 3b9925afaec..e87520d9937 100644
--- a/ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java
+++ b/ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java
@@ -47,7 +47,7 @@ import java.util.function.LongBinaryOperator;
  * for classes supporting dynamic striping on 64bit values. The class
  * extends Number so that concrete subclasses must publicly do so.
  */
-@SuppressWarnings({"removal","serial"})
+@SuppressWarnings("serial")
 abstract class Striped64 extends Number {
     /*
      * This class maintains a lazily-initialized table of atomically
@@ -383,12 +383,13 @@ abstract class Striped64 extends Number {
     private static final VarHandle THREAD_PROBE;
     static {
         try {
-            MethodHandles.Lookup l = MethodHandles.lookup();
-            BASE = l.findVarHandle(Striped64.class,
+            MethodHandles.Lookup l1 = MethodHandles.lookup();
+            BASE = l1.findVarHandle(Striped64.class,
                     "base", long.class);
-            CELLSBUSY = l.findVarHandle(Striped64.class,
+            CELLSBUSY = l1.findVarHandle(Striped64.class,
                     "cellsBusy", int.class);
-            l = java.security.AccessController.doPrivileged(
+            @SuppressWarnings("removal")
+            MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(
                     new java.security.PrivilegedAction<>() {
                         public MethodHandles.Lookup run() {
                             try {
@@ -397,7 +398,7 @@ abstract class Striped64 extends Number {
                                 throw new ExceptionInInitializerError(e);
                             }
                         }});
-            THREAD_PROBE = l.findVarHandle(Thread.class,
+            THREAD_PROBE = l2.findVarHandle(Thread.class,
                     "threadLocalRandomProbe", int.class);
         } catch (ReflectiveOperationException e) {
             throw new ExceptionInInitializerError(e);
diff --git a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
index 829058bb521..55d4ea37af4 100644
--- a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
+++ b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
@@ -197,31 +197,53 @@ public abstract class AbstractQueuedLongSynchronizer
         return U.compareAndSetReference(this, TAIL, c, v);
     }
 
-    /** tries once to CAS a new dummy node for head */
-    private void tryInitializeHead() {
-        Node h = new ExclusiveNode();
-        if (U.compareAndSetReference(this, HEAD, null, h))
-            tail = h;
+    /**
+     * Tries to CAS a new dummy node for head.
+     * Returns new tail, or null if OutOfMemory
+     */
+    private Node tryInitializeHead() {
+        for (Node h = null, t;;) {
+            if ((t = tail) != null)
+                return t;
+            else if (head != null)
+                Thread.onSpinWait();
+            else {
+                if (h == null) {
+                    try {
+                        h = new ExclusiveNode();
+                    } catch (OutOfMemoryError oome) {
+                        return null;
+                    }
+                }
+                if (U.compareAndSetReference(this, HEAD, null, h))
+                    return tail = h;
+            }
+        }
     }
 
+
     /**
      * Enqueues the node unless null. (Currently used only for
      * ConditionNodes; other cases are interleaved with acquires.)
      */
-    final void enqueue(Node node) {
+    final void enqueue(ConditionNode node) {
         if (node != null) {
-            for (;;) {
-                Node t = tail;
+            boolean unpark = false;
+            for (Node t;;) {
+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {
+                    unpark = true;             // wake up to spin on OOME
+                    break;
+                }
                 node.setPrevRelaxed(t);        // avoid unnecessary fence
-                if (t == null)                 // initialize
-                    tryInitializeHead();
-                else if (casTail(t, node)) {
+                if (casTail(t, node)) {
                     t.next = node;
                     if (t.status < 0)          // wake up to clean link
-                        LockSupport.unpark(node.waiter);
+                        unpark = true;
                     break;
                 }
             }
+            if (unpark)
+                LockSupport.unpark(node.waiter);
         }
     }
 
@@ -280,7 +302,10 @@ public abstract class AbstractQueuedLongSynchronizer
          *  Check if node now first
          *    if so, ensure head stable, else ensure valid predecessor
          *  if node is first or not yet enqueued, try acquiring
+         *  else if queue is not initialized, do so by attaching new header node
+         *     resort to spinwait on OOME trying to create node
          *  else if node not yet created, create it
+         *     resort to spinwait on OOME trying to create node
          *  else if not yet enqueued, try once to enqueue
          *  else if woken from park, retry (up to postSpins times)
          *  else if WAITING status not set, set and retry
@@ -323,18 +348,20 @@ public abstract class AbstractQueuedLongSynchronizer
                     return 1;
                 }
             }
-            if (node == null) {                 // allocate; retry before enqueue
-                if (shared)
-                    node = new SharedNode();
-                else
-                    node = new ExclusiveNode();
+            Node t;
+            if ((t = tail) == null) {           // initialize queue
+                if (tryInitializeHead() == null)
+                    return acquireOnOOME(shared, arg);
+            } else if (node == null) {          // allocate; retry before enqueue
+                try {
+                    node = (shared) ? new SharedNode() : new ExclusiveNode();
+                } catch (OutOfMemoryError oome) {
+                    return acquireOnOOME(shared, arg);
+                }
             } else if (pred == null) {          // try to enqueue
                 node.waiter = current;
-                Node t = tail;
                 node.setPrevRelaxed(t);         // avoid unnecessary fence
-                if (t == null)
-                    tryInitializeHead();
-                else if (!casTail(t, node))
+                if (!casTail(t, node))
                     node.setPrevRelaxed(null);  // back out
                 else
                     t.next = node;
@@ -360,9 +387,23 @@ public abstract class AbstractQueuedLongSynchronizer
         return cancelAcquire(node, interrupted, interruptible);
     }
 
+    /**
+     * Spin-waits with backoff; used only upon OOME failures during acquire.
+     */
+    private int acquireOnOOME(boolean shared, long arg) {
+        for (long nanos = 1L;;) {
+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))
+                return 1;
+            U.park(false, nanos);               // must use Unsafe park to sleep
+            if (nanos < 1L << 30)               // max about 1 second
+                nanos <<= 1;
+        }
+    }
+
     /**
      * Possibly repeatedly traverses from tail, unsplicing cancelled
-     * nodes until none are found.
+     * nodes until none are found. Unparks nodes that may have been
+     * relinked to be next eligible acquirer.
      */
     private void cleanQueue() {
         for (;;) {                               // restart point
@@ -1069,6 +1110,12 @@ public abstract class AbstractQueuedLongSynchronizer
         /** Last node of condition queue. */
         private transient ConditionNode lastWaiter;
 
+        /**
+         * Fixed delay in nanoseconds between releasing and reacquiring
+         * lock during Condition waits that encounter OutOfMemoryErrors
+         */
+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; // 10 ms
+
         /**
          * Creates a new {@code ConditionObject} instance.
          */
@@ -1105,7 +1152,7 @@ public abstract class AbstractQueuedLongSynchronizer
             ConditionNode first = firstWaiter;
             if (!isHeldExclusively())
                 throw new IllegalMonitorStateException();
-            if (first != null)
+            else if (first != null)
                 doSignal(first, false);
         }
 
@@ -1120,7 +1167,7 @@ public abstract class AbstractQueuedLongSynchronizer
             ConditionNode first = firstWaiter;
             if (!isHeldExclusively())
                 throw new IllegalMonitorStateException();
-            if (first != null)
+            else if (first != null)
                 doSignal(first, true);
         }
 
@@ -1158,7 +1205,9 @@ public abstract class AbstractQueuedLongSynchronizer
          */
         private boolean canReacquire(ConditionNode node) {
             // check links, not status to avoid enqueue race
-            return node != null && node.prev != null && isEnqueued(node);
+            Node p; // traverse unless known to be bidirectionally linked
+            return node != null && (p = node.prev) != null &&
+                (p.next == node || isEnqueued(node));
         }
 
         /**
@@ -1185,6 +1234,26 @@ public abstract class AbstractQueuedLongSynchronizer
             }
         }
 
+        /**
+         * Constructs objects needed for condition wait. On OOME,
+         * releases lock, sleeps, reacquires, and returns null.
+         */
+        private ConditionNode newConditionNode() {
+            long savedState;
+            if (tryInitializeHead() != null) {
+                try {
+                    return new ConditionNode();
+                } catch (OutOfMemoryError oome) {
+                }
+            }
+            // fall through if encountered OutOfMemoryError
+            if (!isHeldExclusively() || !release(savedState = getState()))
+                throw new IllegalMonitorStateException();
+            U.park(false, OOME_COND_WAIT_DELAY);
+            acquireOnOOME(false, savedState);
+            return null;
+        }
+
         /**
          * Implements uninterruptible condition wait.
          * <ol>
@@ -1197,7 +1266,9 @@ public abstract class AbstractQueuedLongSynchronizer
          * </ol>
          */
         public final void awaitUninterruptibly() {
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return;
             long savedState = enableWait(node);
             LockSupport.setCurrentBlocker(this); // for back-compatibility
             boolean interrupted = false, rejected = false;
@@ -1241,7 +1312,9 @@ public abstract class AbstractQueuedLongSynchronizer
         public final void await() throws InterruptedException {
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return;
             long savedState = enableWait(node);
             LockSupport.setCurrentBlocker(this); // for back-compatibility
             boolean interrupted = false, cancelled = false, rejected = false;
@@ -1292,7 +1365,9 @@ public abstract class AbstractQueuedLongSynchronizer
                 throws InterruptedException {
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return nanosTimeout - OOME_COND_WAIT_DELAY;
             long savedState = enableWait(node);
             long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
             long deadline = System.nanoTime() + nanos;
@@ -1336,7 +1411,9 @@ public abstract class AbstractQueuedLongSynchronizer
             long abstime = deadline.getTime();
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return false;
             long savedState = enableWait(node);
             boolean cancelled = false, interrupted = false;
             while (!canReacquire(node)) {
@@ -1377,7 +1454,9 @@ public abstract class AbstractQueuedLongSynchronizer
             long nanosTimeout = unit.toNanos(time);
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return false;
             long savedState = enableWait(node);
             long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
             long deadline = System.nanoTime() + nanos;
diff --git a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
index 921150f58ca..36d21d3fcfc 100644
--- a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
+++ b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
@@ -432,6 +432,19 @@ public abstract class AbstractQueuedSynchronizer
      * methods.  (It is usually easy for compilers to optimize
      * call-site specializations when heavily used.)
      *
+     * Most AQS methods may be called by JDK components that cannot be
+     * allowed to fail when encountering OutOfMemoryErrors. The main
+     * acquire method resorts to spin-waits with backoff if nodes
+     * cannot be allocated. Condition waits release and reacquire
+     * locks upon OOME at a slow fixed rate (OOME_COND_WAIT_DELAY)
+     * designed with the hope that eventually enough memory will be
+     * recovered; if not performance can be very slow. Effectiveness
+     * is also limited by the possibility of class loading triggered
+     * by first-time usages, that may encounter unrecoverable
+     * OOMEs. Also, it is possible for OutOfMemoryErrors to be thrown
+     * when attempting to create and throw
+     * IllegalMonitorStateExceptions and InterruptedExceptions.
+     *
      * There are several arbitrary decisions about when and how to
      * check interrupts in both acquire and await before and/or after
      * blocking. The decisions are less arbitrary in implementation
@@ -562,31 +575,52 @@ public abstract class AbstractQueuedSynchronizer
         return U.compareAndSetReference(this, TAIL, c, v);
     }
 
-    /** tries once to CAS a new dummy node for head */
-    private void tryInitializeHead() {
-        Node h = new ExclusiveNode();
-        if (U.compareAndSetReference(this, HEAD, null, h))
-            tail = h;
+    /**
+     * Tries to CAS a new dummy node for head.
+     * Returns new tail, or null if OutOfMemory
+     */
+    private Node tryInitializeHead() {
+        for (Node h = null, t;;) {
+            if ((t = tail) != null)
+                return t;
+            else if (head != null)
+                Thread.onSpinWait();
+            else {
+                if (h == null) {
+                    try {
+                        h = new ExclusiveNode();
+                    } catch (OutOfMemoryError oome) {
+                        return null;
+                    }
+                }
+                if (U.compareAndSetReference(this, HEAD, null, h))
+                    return tail = h;
+            }
+        }
     }
 
     /**
      * Enqueues the node unless null. (Currently used only for
      * ConditionNodes; other cases are interleaved with acquires.)
      */
-    final void enqueue(Node node) {
+    final void enqueue(ConditionNode node) {
         if (node != null) {
-            for (;;) {
-                Node t = tail;
+            boolean unpark = false;
+            for (Node t;;) {
+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {
+                    unpark = true;             // wake up to spin on OOME
+                    break;
+                }
                 node.setPrevRelaxed(t);        // avoid unnecessary fence
-                if (t == null)                 // initialize
-                    tryInitializeHead();
-                else if (casTail(t, node)) {
+                if (casTail(t, node)) {
                     t.next = node;
                     if (t.status < 0)          // wake up to clean link
-                        LockSupport.unpark(node.waiter);
+                        unpark = true;
                     break;
                 }
             }
+            if (unpark)
+                LockSupport.unpark(node.waiter);
         }
     }
 
@@ -638,14 +672,17 @@ public abstract class AbstractQueuedSynchronizer
         Thread current = Thread.currentThread();
         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
         boolean interrupted = false, first = false;
-        Node pred = null;                // predecessor of node when enqueued
+        Node pred = null;               // predecessor of node when enqueued
 
         /*
          * Repeatedly:
          *  Check if node now first
          *    if so, ensure head stable, else ensure valid predecessor
          *  if node is first or not yet enqueued, try acquiring
+         *  else if queue is not initialized, do so by attaching new header node
+         *     resort to spinwait on OOME trying to create node
          *  else if node not yet created, create it
+         *     resort to spinwait on OOME trying to create node
          *  else if not yet enqueued, try once to enqueue
          *  else if woken from park, retry (up to postSpins times)
          *  else if WAITING status not set, set and retry
@@ -688,18 +725,20 @@ public abstract class AbstractQueuedSynchronizer
                     return 1;
                 }
             }
-            if (node == null) {                 // allocate; retry before enqueue
-                if (shared)
-                    node = new SharedNode();
-                else
-                    node = new ExclusiveNode();
+            Node t;
+            if ((t = tail) == null) {           // initialize queue
+                if (tryInitializeHead() == null)
+                    return acquireOnOOME(shared, arg);
+            } else if (node == null) {          // allocate; retry before enqueue
+                try {
+                    node = (shared) ? new SharedNode() : new ExclusiveNode();
+                } catch (OutOfMemoryError oome) {
+                    return acquireOnOOME(shared, arg);
+                }
             } else if (pred == null) {          // try to enqueue
                 node.waiter = current;
-                Node t = tail;
                 node.setPrevRelaxed(t);         // avoid unnecessary fence
-                if (t == null)
-                    tryInitializeHead();
-                else if (!casTail(t, node))
+                if (!casTail(t, node))
                     node.setPrevRelaxed(null);  // back out
                 else
                     t.next = node;
@@ -725,6 +764,19 @@ public abstract class AbstractQueuedSynchronizer
         return cancelAcquire(node, interrupted, interruptible);
     }
 
+    /**
+     * Spin-waits with backoff; used only upon OOME failures during acquire.
+     */
+    private int acquireOnOOME(boolean shared, int arg) {
+        for (long nanos = 1L;;) {
+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))
+                return 1;
+            U.park(false, nanos);               // must use Unsafe park to sleep
+            if (nanos < 1L << 30)               // max about 1 second
+                nanos <<= 1;
+        }
+    }
+
     /**
      * Possibly repeatedly traverses from tail, unsplicing cancelled
      * nodes until none are found. Unparks nodes that may have been
@@ -1435,6 +1487,12 @@ public abstract class AbstractQueuedSynchronizer
         /** Last node of condition queue. */
         private transient ConditionNode lastWaiter;
 
+        /**
+         * Fixed delay in nanoseconds between releasing and reacquiring
+         * lock during Condition waits that encounter OutOfMemoryErrors
+         */
+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; // 10 ms
+
         /**
          * Creates a new {@code ConditionObject} instance.
          */
@@ -1471,7 +1529,7 @@ public abstract class AbstractQueuedSynchronizer
             ConditionNode first = firstWaiter;
             if (!isHeldExclusively())
                 throw new IllegalMonitorStateException();
-            if (first != null)
+            else if (first != null)
                 doSignal(first, false);
         }
 
@@ -1486,7 +1544,7 @@ public abstract class AbstractQueuedSynchronizer
             ConditionNode first = firstWaiter;
             if (!isHeldExclusively())
                 throw new IllegalMonitorStateException();
-            if (first != null)
+            else if (first != null)
                 doSignal(first, true);
         }
 
@@ -1524,7 +1582,9 @@ public abstract class AbstractQueuedSynchronizer
          */
         private boolean canReacquire(ConditionNode node) {
             // check links, not status to avoid enqueue race
-            return node != null && node.prev != null && isEnqueued(node);
+            Node p; // traverse unless known to be bidirectionally linked
+            return node != null && (p = node.prev) != null &&
+                (p.next == node || isEnqueued(node));
         }
 
         /**
@@ -1551,6 +1611,26 @@ public abstract class AbstractQueuedSynchronizer
             }
         }
 
+        /**
+         * Constructs objects needed for condition wait. On OOME,
+         * releases lock, sleeps, reacquires, and returns null.
+         */
+        private ConditionNode newConditionNode() {
+            int savedState;
+            if (tryInitializeHead() != null) {
+                try {
+                    return new ConditionNode();
+                } catch (OutOfMemoryError oome) {
+                }
+            }
+            // fall through if encountered OutOfMemoryError
+            if (!isHeldExclusively() || !release(savedState = getState()))
+                throw new IllegalMonitorStateException();
+            U.park(false, OOME_COND_WAIT_DELAY);
+            acquireOnOOME(false, savedState);
+            return null;
+        }
+
         /**
          * Implements uninterruptible condition wait.
          * <ol>
@@ -1563,7 +1643,9 @@ public abstract class AbstractQueuedSynchronizer
          * </ol>
          */
         public final void awaitUninterruptibly() {
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return;
             int savedState = enableWait(node);
             LockSupport.setCurrentBlocker(this); // for back-compatibility
             boolean interrupted = false, rejected = false;
@@ -1607,7 +1689,9 @@ public abstract class AbstractQueuedSynchronizer
         public final void await() throws InterruptedException {
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return;
             int savedState = enableWait(node);
             LockSupport.setCurrentBlocker(this); // for back-compatibility
             boolean interrupted = false, cancelled = false, rejected = false;
@@ -1658,7 +1742,9 @@ public abstract class AbstractQueuedSynchronizer
                 throws InterruptedException {
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return nanosTimeout - OOME_COND_WAIT_DELAY;
             int savedState = enableWait(node);
             long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
             long deadline = System.nanoTime() + nanos;
@@ -1702,7 +1788,9 @@ public abstract class AbstractQueuedSynchronizer
             long abstime = deadline.getTime();
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return false;
             int savedState = enableWait(node);
             boolean cancelled = false, interrupted = false;
             while (!canReacquire(node)) {
@@ -1743,7 +1831,9 @@ public abstract class AbstractQueuedSynchronizer
             long nanosTimeout = unit.toNanos(time);
             if (Thread.interrupted())
                 throw new InterruptedException();
-            ConditionNode node = new ConditionNode();
+            ConditionNode node = newConditionNode();
+            if (node == null)
+                return false;
             int savedState = enableWait(node);
             long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
             long deadline = System.nanoTime() + nanos;
@@ -1849,7 +1939,6 @@ public abstract class AbstractQueuedSynchronizer
         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, "head");
     private static final long TAIL
         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, "tail");
-
     static {
         Class<?> ensureLoaded = LockSupport.class;
     }
diff --git a/ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java b/ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java
index 33767c7c57e..28fe0d4dca3 100644
--- a/ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java
+++ b/ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java
@@ -35,6 +35,7 @@
 
 package java.util.concurrent.locks;
 
+import jdk.internal.misc.VirtualThreads;
 import jdk.internal.misc.Unsafe;
 
 /**
@@ -173,8 +174,13 @@ public class LockSupport {
      *        this operation has no effect
      */
     public static void unpark(Thread thread) {
-        if (thread != null)
-            U.unpark(thread);
+        if (thread != null) {
+            if (thread.isVirtual()) {
+                VirtualThreads.unpark(thread);
+            } else {
+                U.unpark(thread);
+            }
+        }
     }
 
     /**
@@ -208,8 +214,15 @@ public class LockSupport {
     public static void park(Object blocker) {
         Thread t = Thread.currentThread();
         setBlocker(t, blocker);
-        U.park(false, 0L);
-        setBlocker(t, null);
+        try {
+            if (t.isVirtual()) {
+                VirtualThreads.park();
+            } else {
+                U.park(false, 0L);
+            }
+        } finally {
+            setBlocker(t, null);
+        }
     }
 
     /**
@@ -249,8 +262,15 @@ public class LockSupport {
         if (nanos > 0) {
             Thread t = Thread.currentThread();
             setBlocker(t, blocker);
-            U.park(false, nanos);
-            setBlocker(t, null);
+            try {
+                if (t.isVirtual()) {
+                    VirtualThreads.park(nanos);
+                } else {
+                    U.park(false, nanos);
+                }
+            } finally {
+                setBlocker(t, null);
+            }
         }
     }
 
@@ -290,8 +310,15 @@ public class LockSupport {
     public static void parkUntil(Object blocker, long deadline) {
         Thread t = Thread.currentThread();
         setBlocker(t, blocker);
-        U.park(true, deadline);
-        setBlocker(t, null);
+        try {
+            if (t.isVirtual()) {
+                VirtualThreads.parkUntil(deadline);
+            } else {
+                U.park(true, deadline);
+            }
+        } finally {
+            setBlocker(t, null);
+        }
     }
 
     /**
@@ -338,7 +365,11 @@ public class LockSupport {
      * for example, the interrupt status of the thread upon return.
      */
     public static void park() {
-        U.park(false, 0L);
+        if (Thread.currentThread().isVirtual()) {
+            VirtualThreads.park();
+        } else {
+            U.park(false, 0L);
+        }
     }
 
     /**
@@ -372,8 +403,13 @@ public class LockSupport {
      * @param nanos the maximum number of nanoseconds to wait
      */
     public static void parkNanos(long nanos) {
-        if (nanos > 0)
-            U.park(false, nanos);
+        if (nanos > 0) {
+            if (Thread.currentThread().isVirtual()) {
+                VirtualThreads.park(nanos);
+            } else {
+                U.park(false, nanos);
+            }
+        }
     }
 
     /**
@@ -407,24 +443,23 @@ public class LockSupport {
      *        to wait until
      */
     public static void parkUntil(long deadline) {
-        U.park(true, deadline);
+        if (Thread.currentThread().isVirtual()) {
+            VirtualThreads.parkUntil(deadline);
+        } else {
+            U.park(true, deadline);
+        }
     }
 
     /**
-     * Returns the thread id for the given thread.  We must access
-     * this directly rather than via method Thread.getId() because
-     * getId() has been known to be overridden in ways that do not
-     * preserve unique mappings.
+     * Returns the thread id for the given thread.
      */
     static final long getThreadId(Thread thread) {
-        return U.getLong(thread, TID);
+        return thread.threadId();
     }
 
     // Hotspot implementation via intrinsics API
     private static final Unsafe U = Unsafe.getUnsafe();
     private static final long PARKBLOCKER
         = U.objectFieldOffset(Thread.class, "parkBlocker");
-    private static final long TID
-        = U.objectFieldOffset(Thread.class, "tid");
 
 }
diff --git a/ojluni/src/main/java/java/util/function/TEST_MAPPING b/ojluni/src/main/java/java/util/function/TEST_MAPPING
deleted file mode 100644
index 5840cf90c30..00000000000
--- a/ojluni/src/main/java/java/util/function/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.util.function"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/jar/TEST_MAPPING b/ojluni/src/main/java/java/util/jar/TEST_MAPPING
deleted file mode 100644
index 5b26443ffff..00000000000
--- a/ojluni/src/main/java/java/util/jar/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.util.jar"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.util.jar"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/logging/TEST_MAPPING b/ojluni/src/main/java/java/util/logging/TEST_MAPPING
index 85f4d2bdf48..46c806fe909 100644
--- a/ojluni/src/main/java/java/util/logging/TEST_MAPPING
+++ b/ojluni/src/main/java/java/util/logging/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.logging.tests.java.util.logging"
-        },
-        {
-          "include-filter": "libcore.java.util.logging"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_java_util_logging"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/prefs/TEST_MAPPING b/ojluni/src/main/java/java/util/prefs/TEST_MAPPING
deleted file mode 100644
index 3a3445b65ba..00000000000
--- a/ojluni/src/main/java/java/util/prefs/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.java.util.prefs"
-        },
-        {
-          "include-filter": "libcore.java.util.prefs"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/regex/TEST_MAPPING b/ojluni/src/main/java/java/util/regex/TEST_MAPPING
index 1bd44e21772..3cb2319a54c 100644
--- a/ojluni/src/main/java/java/util/regex/TEST_MAPPING
+++ b/ojluni/src/main/java/java/util/regex/TEST_MAPPING
@@ -1,18 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.regex.tests.java.util.regex"
-        },
-        {
-          "include-filter": "libcore.java.util.regex"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.util.regex"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_util_regex"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/stream/AbstractPipeline.java b/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
index 8040fc1f2d3..7d03ae34f79 100644
--- a/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
+++ b/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
@@ -588,8 +588,8 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
 
     /**
      * Get the output shape of the pipeline.  If the pipeline is the head,
-     * then it's output shape corresponds to the shape of the source.
-     * Otherwise, it's output shape corresponds to the output shape of the
+     * then its output shape corresponds to the shape of the source.
+     * Otherwise, its output shape corresponds to the output shape of the
      * associated operation.
      *
      * @return the output shape
diff --git a/ojluni/src/main/java/java/util/stream/AbstractTask.java b/ojluni/src/main/java/java/util/stream/AbstractTask.java
index 44c2656157b..9a61729f68d 100644
--- a/ojluni/src/main/java/java/util/stream/AbstractTask.java
+++ b/ojluni/src/main/java/java/util/stream/AbstractTask.java
@@ -180,7 +180,7 @@ abstract class AbstractTask<P_IN, P_OUT, R,
 
     /**
      * Computes the result associated with a leaf node.  Will be called by
-     * {@code compute()} and the result passed to @{code setLocalResult()}
+     * {@code compute()} and the result passed to {@code setLocalResult()}
      *
      * @return the computed result of a leaf node
      */
diff --git a/ojluni/src/main/java/java/util/stream/BaseStream.java b/ojluni/src/main/java/java/util/stream/BaseStream.java
index 0328b25cafd..28e0541efdb 100644
--- a/ojluni/src/main/java/java/util/stream/BaseStream.java
+++ b/ojluni/src/main/java/java/util/stream/BaseStream.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -69,6 +69,11 @@ public interface BaseStream<T, S extends BaseStream<T, S>>
      * <p>This is a <a href="package-summary.html#StreamOps">terminal
      * operation</a>.
      *
+     * @apiNote
+     * This operation is provided as an "escape hatch" to enable
+     * arbitrary client-controlled pipeline traversals in the event that the
+     * existing operations are not sufficient to the task.
+     *
      * @return the element iterator for this stream
      */
     Iterator<T> iterator();
@@ -79,6 +84,11 @@ public interface BaseStream<T, S extends BaseStream<T, S>>
      * <p>This is a <a href="package-summary.html#StreamOps">terminal
      * operation</a>.
      *
+     * @apiNote
+     * This operation is provided as an "escape hatch" to enable
+     * arbitrary client-controlled pipeline traversals in the event that the
+     * existing operations are not sufficient to the task.
+     *
      * <p>
      * The returned spliterator should report the set of characteristics derived
      * from the stream pipeline (namely the characteristics derived from the
diff --git a/ojluni/src/main/java/java/util/stream/Collectors.java b/ojluni/src/main/java/java/util/stream/Collectors.java
index 8956823d0c5..bbb0982fac3 100644
--- a/ojluni/src/main/java/java/util/stream/Collectors.java
+++ b/ojluni/src/main/java/java/util/stream/Collectors.java
@@ -194,6 +194,24 @@ public final class Collectors {
      * @param <T> the type of elements to be collected
      * @param <R> the type of the result
      */
+    // BEGIN Android-changed: intracore api is built as java 1.8. Using record class causes
+    // gpaste/4626855330316288
+    /*
+    record CollectorImpl<T, A, R>(Supplier<A> supplier,
+                                  BiConsumer<A, T> accumulator,
+                                  BinaryOperator<A> combiner,
+                                  Function<A, R> finisher,
+                                  Set<Characteristics> characteristics
+            ) implements Collector<T, A, R> {
+
+        CollectorImpl(Supplier<A> supplier,
+                      BiConsumer<A, T> accumulator,
+                      BinaryOperator<A> combiner,
+                      Set<Characteristics> characteristics) {
+            this(supplier, accumulator, combiner, castingIdentity(), characteristics);
+        }
+    }
+    */
     static class CollectorImpl<T, A, R> implements Collector<T, A, R> {
         private final Supplier<A> supplier;
         private final BiConsumer<A, T> accumulator;
@@ -245,6 +263,8 @@ public final class Collectors {
             return characteristics;
         }
     }
+    // END Android-changed: intracore api is built as java 1.8. Using record class causes
+    // gpaste/4626855330316288
 
     /**
      * Returns a {@code Collector} that accumulates the input elements into a
@@ -667,7 +687,7 @@ public final class Collectors {
     }
 
     /**
-     * Returns a {@code Collector} that produces the sum of a integer-valued
+     * Returns a {@code Collector} that produces the sum of an integer-valued
      * function applied to the input elements.  If no elements are present,
      * the result is 0.
      *
@@ -2010,6 +2030,35 @@ public final class Collectors {
             this.forFalse = forFalse;
         }
 
+        @Override
+        public int size() {
+            return 2;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        public T get(Object key) {
+            if (key instanceof Boolean b) {
+                return b ? forTrue : forFalse;
+            } else {
+                return null;
+            }
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            return key instanceof Boolean;
+        }
+
+        @Override
+        public boolean containsValue(Object value) {
+            return Objects.equals(value, forTrue) || Objects.equals(value, forFalse);
+        }
+
         @Override
         public Set<Map.Entry<Boolean, T>> entrySet() {
             return new AbstractSet<>() {
diff --git a/ojluni/src/main/java/java/util/stream/FindOps.java b/ojluni/src/main/java/java/util/stream/FindOps.java
index 299cebec571..131eec06236 100644
--- a/ojluni/src/main/java/java/util/stream/FindOps.java
+++ b/ojluni/src/main/java/java/util/stream/FindOps.java
@@ -162,7 +162,7 @@ final class FindOps {
     }
 
     /**
-     * Implementation of @{code TerminalSink} that implements the find
+     * Implementation of {@code TerminalSink} that implements the find
      * functionality, requesting cancellation when something has been found
      *
      * @param <T> The type of input element
diff --git a/ojluni/src/main/java/java/util/stream/ForEachOps.java b/ojluni/src/main/java/java/util/stream/ForEachOps.java
index 69714ca3f85..0c6b8aa665a 100644
--- a/ojluni/src/main/java/java/util/stream/ForEachOps.java
+++ b/ojluni/src/main/java/java/util/stream/ForEachOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,13 +26,14 @@ package java.util.stream;
 
 import java.util.Objects;
 import java.util.Spliterator;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountedCompleter;
 import java.util.function.Consumer;
 import java.util.function.DoubleConsumer;
 import java.util.function.IntConsumer;
 import java.util.function.IntFunction;
 import java.util.function.LongConsumer;
+import java.lang.invoke.VarHandle;
+import java.lang.invoke.MethodHandles;
 
 /**
  * Factory for creating instances of {@code TerminalOp} that perform an
@@ -364,11 +365,21 @@ final class ForEachOps {
         private final PipelineHelper<T> helper;
         private Spliterator<S> spliterator;
         private final long targetSize;
-        private final ConcurrentHashMap<ForEachOrderedTask<S, T>, ForEachOrderedTask<S, T>> completionMap;
         private final Sink<T> action;
         private final ForEachOrderedTask<S, T> leftPredecessor;
         private Node<T> node;
 
+        private ForEachOrderedTask<S, T> next;
+        private static final VarHandle NEXT;
+        static {
+            try {
+                MethodHandles.Lookup l = MethodHandles.lookup();
+                NEXT = l.findVarHandle(ForEachOrderedTask.class, "next", ForEachOrderedTask.class);
+            } catch (Exception e) {
+                throw new InternalError(e);
+            }
+        }
+
         protected ForEachOrderedTask(PipelineHelper<T> helper,
                                      Spliterator<S> spliterator,
                                      Sink<T> action) {
@@ -376,8 +387,6 @@ final class ForEachOps {
             this.helper = helper;
             this.spliterator = spliterator;
             this.targetSize = AbstractTask.suggestTargetSize(spliterator.estimateSize());
-            // Size map to avoid concurrent re-sizes
-            this.completionMap = new ConcurrentHashMap<>(Math.max(16, AbstractTask.getLeafTarget() << 1));
             this.action = action;
             this.leftPredecessor = null;
         }
@@ -389,7 +398,6 @@ final class ForEachOps {
             this.helper = parent.helper;
             this.spliterator = spliterator;
             this.targetSize = parent.targetSize;
-            this.completionMap = parent.completionMap;
             this.action = parent.action;
             this.leftPredecessor = leftPredecessor;
         }
@@ -410,6 +418,10 @@ final class ForEachOps {
                 ForEachOrderedTask<S, T> rightChild =
                     new ForEachOrderedTask<>(task, rightSplit, leftChild);
 
+                // leftChild and rightChild were just created and not fork():ed
+                // yet so no need for a volatile write
+                leftChild.next = rightChild;
+
                 // Fork the parent task
                 // Completion of the left and right children "happens-before"
                 // completion of the parent
@@ -417,7 +429,6 @@ final class ForEachOps {
                 // Completion of the left child "happens-before" completion of
                 // the right child
                 rightChild.addToPendingCount(1);
-                task.completionMap.put(leftChild, rightChild);
 
                 // If task is not on the left spine
                 if (task.leftPredecessor != null) {
@@ -433,7 +444,7 @@ final class ForEachOps {
                     leftChild.addToPendingCount(1);
                     // Update association of left-predecessor to left-most
                     // leaf node of right subtree
-                    if (task.completionMap.replace(task.leftPredecessor, task, leftChild)) {
+                    if (NEXT.compareAndSet(task.leftPredecessor, task, leftChild)) {
                         // If replaced, adjust the pending count of the parent
                         // to complete when its children complete
                         task.addToPendingCount(-1);
@@ -499,7 +510,7 @@ final class ForEachOps {
             // "happens-before" completion of the associated left-most leaf task
             // of right subtree (if any, which can be this task's right sibling)
             //
-            ForEachOrderedTask<S, T> leftDescendant = completionMap.remove(this);
+            var leftDescendant = (ForEachOrderedTask<S, T>)NEXT.getAndSet(this, null);
             if (leftDescendant != null)
                 leftDescendant.tryComplete();
         }
diff --git a/ojluni/src/main/java/java/util/stream/Node.java b/ojluni/src/main/java/java/util/stream/Node.java
index 17cb67924b9..006cf36aca7 100644
--- a/ojluni/src/main/java/java/util/stream/Node.java
+++ b/ojluni/src/main/java/java/util/stream/Node.java
@@ -202,7 +202,7 @@ public interface Node<T> {
         Node<T> build();
 
         /**
-         * Specialized @{code Node.Builder} for int elements
+         * Specialized {@code Node.Builder} for int elements
          */
         interface OfInt extends Node.Builder<Integer>, Sink.OfInt {
             @Override
@@ -210,7 +210,7 @@ public interface Node<T> {
         }
 
         /**
-         * Specialized @{code Node.Builder} for long elements
+         * Specialized {@code Node.Builder} for long elements
          */
         interface OfLong extends Node.Builder<Long>, Sink.OfLong {
             @Override
@@ -218,7 +218,7 @@ public interface Node<T> {
         }
 
         /**
-         * Specialized @{code Node.Builder} for double elements
+         * Specialized {@code Node.Builder} for double elements
          */
         interface OfDouble extends Node.Builder<Double>, Sink.OfDouble {
             @Override
@@ -316,6 +316,7 @@ public interface Node<T> {
     /**
      * Specialized {@code Node} for int elements
      */
+    @SuppressWarnings("overloads")
     interface OfInt extends OfPrimitive<Integer, IntConsumer, int[], Spliterator.OfInt, OfInt> {
 
         /**
@@ -393,6 +394,7 @@ public interface Node<T> {
     /**
      * Specialized {@code Node} for long elements
      */
+    @SuppressWarnings("overloads")
     interface OfLong extends OfPrimitive<Long, LongConsumer, long[], Spliterator.OfLong, OfLong> {
 
         /**
@@ -470,6 +472,7 @@ public interface Node<T> {
     /**
      * Specialized {@code Node} for double elements
      */
+    @SuppressWarnings("overloads")
     interface OfDouble extends OfPrimitive<Double, DoubleConsumer, double[], Spliterator.OfDouble, OfDouble> {
 
         /**
diff --git a/ojluni/src/main/java/java/util/stream/Nodes.java b/ojluni/src/main/java/java/util/stream/Nodes.java
index 7922624476e..ed8e9e7775f 100644
--- a/ojluni/src/main/java/java/util/stream/Nodes.java
+++ b/ojluni/src/main/java/java/util/stream/Nodes.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -178,7 +178,7 @@ final class Nodes {
     }
 
     /**
-     * Produces a variable size @{link Node.Builder}.
+     * Produces a variable size {@link Node.Builder}.
      *
      * @param <T> the type of elements of the node builder
      * @return a {@code Node.Builder}
@@ -216,7 +216,7 @@ final class Nodes {
     }
 
     /**
-     * Produces a variable size @{link Node.Builder.OfInt}.
+     * Produces a variable size {@link Node.Builder.OfInt}.
      *
      * @return a {@code Node.Builder.OfInt}
      */
@@ -253,7 +253,7 @@ final class Nodes {
     }
 
     /**
-     * Produces a variable size @{link Node.Builder.OfLong}.
+     * Produces a variable size {@link Node.Builder.OfLong}.
      *
      * @return a {@code Node.Builder.OfLong}
      */
@@ -290,7 +290,7 @@ final class Nodes {
     }
 
     /**
-     * Produces a variable size @{link Node.Builder.OfDouble}.
+     * Produces a variable size {@link Node.Builder.OfDouble}.
      *
      * @return a {@code Node.Builder.OfDouble}
      */
@@ -590,6 +590,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfInt
                 extends EmptyNode<Integer, int[], IntConsumer>
                 implements Node.OfInt {
@@ -607,6 +608,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfLong
                 extends EmptyNode<Long, long[], LongConsumer>
                 implements Node.OfLong {
@@ -624,6 +626,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfDouble
                 extends EmptyNode<Double, double[], DoubleConsumer>
                 implements Node.OfDouble {
@@ -888,6 +891,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfInt
                 extends ConcNode.OfPrimitive<Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt>
                 implements Node.OfInt {
@@ -902,6 +906,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfLong
                 extends ConcNode.OfPrimitive<Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong>
                 implements Node.OfLong {
@@ -916,6 +921,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfDouble
                 extends ConcNode.OfPrimitive<Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble>
                 implements Node.OfDouble {
@@ -1168,6 +1174,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfInt
                 extends OfPrimitive<Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt>
                 implements Spliterator.OfInt {
@@ -1177,6 +1184,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfLong
                 extends OfPrimitive<Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong>
                 implements Spliterator.OfLong {
@@ -1186,6 +1194,7 @@ final class Nodes {
             }
         }
 
+        @SuppressWarnings("overloads")
         private static final class OfDouble
                 extends OfPrimitive<Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble>
                 implements Spliterator.OfDouble {
@@ -2063,14 +2072,14 @@ final class Nodes {
                 else {
                     task.setPendingCount(task.node.getChildCount() - 1);
 
-                    int size = 0;
+                    long size = 0;
                     int i = 0;
                     for (;i < task.node.getChildCount() - 1; i++) {
-                        K leftTask = task.makeChild(i, task.offset + size);
+                        K leftTask = task.makeChild(i, (int) (task.offset + size));
                         size += leftTask.node.count();
                         leftTask.fork();
                     }
-                    task = task.makeChild(i, task.offset + size);
+                    task = task.makeChild(i, (int) (task.offset + size));
                 }
             }
         }
diff --git a/ojluni/src/main/java/java/util/stream/PipelineHelper.java b/ojluni/src/main/java/java/util/stream/PipelineHelper.java
index 05358b80650..5a4dc2c583d 100644
--- a/ojluni/src/main/java/java/util/stream/PipelineHelper.java
+++ b/ojluni/src/main/java/java/util/stream/PipelineHelper.java
@@ -167,7 +167,7 @@ public abstract class PipelineHelper<P_OUT> {
     abstract<P_IN> Spliterator<P_OUT> wrapSpliterator(Spliterator<P_IN> spliterator);
 
     /**
-     * Constructs a @{link Node.Builder} compatible with the output shape of
+     * Constructs a {@link Node.Builder} compatible with the output shape of
      * this {@code PipelineHelper}.
      *
      * @param exactSizeIfKnown if >=0 then a builder will be created that has a
diff --git a/ojluni/src/main/java/java/util/stream/ReferencePipeline.java b/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
index 07bd046c56e..20449433be3 100644
--- a/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
+++ b/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -635,10 +635,9 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
         // Runtime checking will be performed when an element is stored in A[], thus if A is not a
         // super type of U an ArrayStoreException will be thrown.
         @SuppressWarnings("rawtypes")
-        IntFunction rawGenerator = (IntFunction) generator;
-        // Android-changed: Eclipse compiler requires explicit (Node<A[]>) cast (b/29399275).
-        return (A[]) Nodes.flatten((Node<A[]>) evaluateToArrayNode(rawGenerator), rawGenerator)
-                .asArray(rawGenerator);
+        IntFunction rawGenerator = generator;
+        return (A[]) Nodes.flatten(evaluateToArrayNode(rawGenerator), rawGenerator)
+                              .asArray(rawGenerator);
     }
 
     @Override
diff --git a/ojluni/src/main/java/java/util/stream/Sink.java b/ojluni/src/main/java/java/util/stream/Sink.java
index 491701b743c..7355d9355dd 100644
--- a/ojluni/src/main/java/java/util/stream/Sink.java
+++ b/ojluni/src/main/java/java/util/stream/Sink.java
@@ -188,6 +188,7 @@ public interface Sink<T> extends Consumer<T> {
      * {@code accept(int)}, and wires {@code accept(Integer)} to bridge to
      * {@code accept(int)}.
      */
+    @SuppressWarnings("overloads")
     interface OfInt extends Sink<Integer>, IntConsumer {
         @Override
         void accept(int value);
@@ -205,6 +206,7 @@ public interface Sink<T> extends Consumer<T> {
      * {@code accept(long)}, and wires {@code accept(Long)} to bridge to
      * {@code accept(long)}.
      */
+    @SuppressWarnings("overloads")
     interface OfLong extends Sink<Long>, LongConsumer {
         @Override
         void accept(long value);
@@ -222,6 +224,7 @@ public interface Sink<T> extends Consumer<T> {
      * {@code accept(double)}, and wires {@code accept(Double)} to bridge to
      * {@code accept(double)}.
      */
+    @SuppressWarnings("overloads")
     interface OfDouble extends Sink<Double>, DoubleConsumer {
         @Override
         void accept(double value);
diff --git a/ojluni/src/main/java/java/util/stream/SliceOps.java b/ojluni/src/main/java/java/util/stream/SliceOps.java
index 2a1e31e76a6..6152a27366a 100644
--- a/ojluni/src/main/java/java/util/stream/SliceOps.java
+++ b/ojluni/src/main/java/java/util/stream/SliceOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -50,7 +50,7 @@ final class SliceOps {
      * @return the sliced size
      */
     private static long calcSize(long size, long skip, long limit) {
-        return size >= 0 ? Math.max(0, Math.min(size - skip, limit)) : -1;
+        return size >= 0 ? Math.clamp(size - skip, 0, limit) : -1;
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/stream/SpinedBuffer.java b/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
index d21518abf6f..25a4a06daf9 100644
--- a/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
+++ b/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
@@ -725,6 +725,7 @@ public class SpinedBuffer<E>
      * An ordered collection of {@code int} values.
      * @hide Visible for CTS testing only (OpenJDK8 tests).
      */
+    @SuppressWarnings("overloads")
     // Android-changed: Made public for CTS tests only.
     public static class OfInt extends SpinedBuffer.OfPrimitive<Integer, int[], IntConsumer>
             implements IntConsumer {
@@ -793,6 +794,7 @@ public class SpinedBuffer<E>
         }
 
         public Spliterator.OfInt spliterator() {
+            @SuppressWarnings("overloads")
             class Splitr extends BaseSpliterator<Spliterator.OfInt>
                     implements Spliterator.OfInt {
                 Splitr(int firstSpineIndex, int lastSpineIndex,
@@ -842,6 +844,7 @@ public class SpinedBuffer<E>
      * An ordered collection of {@code long} values.
      * @hide Visible for CTS testing only (OpenJDK8 tests).
      */
+    @SuppressWarnings("overloads")
     // Android-changed: Made public for CTS tests only.
     public static class OfLong extends SpinedBuffer.OfPrimitive<Long, long[], LongConsumer>
             implements LongConsumer {
@@ -911,6 +914,7 @@ public class SpinedBuffer<E>
 
 
         public Spliterator.OfLong spliterator() {
+            @SuppressWarnings("overloads")
             class Splitr extends BaseSpliterator<Spliterator.OfLong>
                     implements Spliterator.OfLong {
                 Splitr(int firstSpineIndex, int lastSpineIndex,
@@ -960,6 +964,7 @@ public class SpinedBuffer<E>
      * An ordered collection of {@code double} values.
      * @hide Visible for CTS testing only (OpenJDK8 tests).
      */
+    @SuppressWarnings("overloads")
     // Android-changed: Made public for CTS tests only.
     public static class OfDouble
             extends SpinedBuffer.OfPrimitive<Double, double[], DoubleConsumer>
@@ -1029,6 +1034,7 @@ public class SpinedBuffer<E>
         }
 
         public Spliterator.OfDouble spliterator() {
+            @SuppressWarnings("overloads")
             class Splitr extends BaseSpliterator<Spliterator.OfDouble>
                     implements Spliterator.OfDouble {
                 Splitr(int firstSpineIndex, int lastSpineIndex,
diff --git a/ojluni/src/main/java/java/util/stream/StreamSpliterators.java b/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
index 01ba72d1950..d2f558c2821 100644
--- a/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
+++ b/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
@@ -572,6 +572,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfInt
                 extends OfPrimitive<Integer, IntConsumer, Spliterator.OfInt>
                 implements Spliterator.OfInt {
@@ -581,6 +582,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfLong
                 extends OfPrimitive<Long, LongConsumer, Spliterator.OfLong>
                 implements Spliterator.OfLong {
@@ -590,6 +592,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfDouble
                 extends OfPrimitive<Double, DoubleConsumer, Spliterator.OfDouble>
                 implements Spliterator.OfDouble {
@@ -815,6 +818,7 @@ class StreamSpliterators {
             protected abstract T_CONS emptyConsumer();
         }
 
+        @SuppressWarnings("overloads")
         static final class OfInt extends OfPrimitive<Integer, Spliterator.OfInt, IntConsumer>
                 implements Spliterator.OfInt {
             OfInt(Spliterator.OfInt s, long sliceOrigin, long sliceFence) {
@@ -839,6 +843,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfLong extends OfPrimitive<Long, Spliterator.OfLong, LongConsumer>
                 implements Spliterator.OfLong {
             OfLong(Spliterator.OfLong s, long sliceOrigin, long sliceFence) {
@@ -863,6 +868,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfDouble extends OfPrimitive<Double, Spliterator.OfDouble, DoubleConsumer>
                 implements Spliterator.OfDouble {
             OfDouble(Spliterator.OfDouble s, long sliceOrigin, long sliceFence) {
@@ -1128,6 +1134,7 @@ class StreamSpliterators {
             protected abstract T_BUFF bufferCreate(int initialCapacity);
         }
 
+        @SuppressWarnings("overloads")
         static final class OfInt
                 extends OfPrimitive<Integer, IntConsumer, ArrayBuffer.OfInt, Spliterator.OfInt>
                 implements Spliterator.OfInt, IntConsumer {
@@ -1163,6 +1170,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfLong
                 extends OfPrimitive<Long, LongConsumer, ArrayBuffer.OfLong, Spliterator.OfLong>
                 implements Spliterator.OfLong, LongConsumer {
@@ -1198,6 +1206,7 @@ class StreamSpliterators {
             }
         }
 
+        @SuppressWarnings("overloads")
         static final class OfDouble
                 extends OfPrimitive<Double, DoubleConsumer, ArrayBuffer.OfDouble, Spliterator.OfDouble>
                 implements Spliterator.OfDouble, DoubleConsumer {
diff --git a/ojluni/src/main/java/java/util/stream/Streams.java b/ojluni/src/main/java/java/util/stream/Streams.java
index aa696c5ddb5..1b2d7e5c98c 100644
--- a/ojluni/src/main/java/java/util/stream/Streams.java
+++ b/ojluni/src/main/java/java/util/stream/Streams.java
@@ -804,6 +804,7 @@ final class Streams {
             }
         }
 
+        @SuppressWarnings("overloads")
         static class OfInt
                 extends ConcatSpliterator.OfPrimitive<Integer, IntConsumer, Spliterator.OfInt>
                 implements Spliterator.OfInt {
@@ -812,6 +813,7 @@ final class Streams {
             }
         }
 
+        @SuppressWarnings("overloads")
         static class OfLong
                 extends ConcatSpliterator.OfPrimitive<Long, LongConsumer, Spliterator.OfLong>
                 implements Spliterator.OfLong {
@@ -820,6 +822,7 @@ final class Streams {
             }
         }
 
+        @SuppressWarnings("overloads")
         static class OfDouble
                 extends ConcatSpliterator.OfPrimitive<Double, DoubleConsumer, Spliterator.OfDouble>
                 implements Spliterator.OfDouble {
diff --git a/ojluni/src/main/java/java/util/zip/TEST_MAPPING b/ojluni/src/main/java/java/util/zip/TEST_MAPPING
deleted file mode 100644
index 52ac9327cea..00000000000
--- a/ojluni/src/main/java/java/util/zip/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.java.util.zip"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.java.util.zip"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/zip/ZipFile.java b/ojluni/src/main/java/java/util/zip/ZipFile.java
index ee23e551b6b..9991b31bd50 100644
--- a/ojluni/src/main/java/java/util/zip/ZipFile.java
+++ b/ojluni/src/main/java/java/util/zip/ZipFile.java
@@ -107,9 +107,6 @@ public class ZipFile implements ZipConstants, Closeable {
     // c) the "native" source of this zip file.
     private final @Stable CleanableResource res;
 
-    // Android-added: CloseGuard support.
-    private final CloseGuard guard = CloseGuard.get();
-
     private static final int STORED = ZipEntry.STORED;
     private static final int DEFLATED = ZipEntry.DEFLATED;
 
@@ -754,6 +751,9 @@ public class ZipFile implements ZipConstants, Closeable {
 
         final Cleanable cleanable;
 
+        // Android-added: CloseGuard support.
+        final CloseGuard guard = CloseGuard.get();
+
         Source zsrc;
 
         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {
@@ -767,6 +767,8 @@ public class ZipFile implements ZipConstants, Closeable {
             this.istreams = Collections.newSetFromMap(new WeakHashMap<>());
             this.inflaterCache = new ArrayDeque<>();
             this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc, enableZipPathValidator);
+            // Android-added: CloseGuard support.
+            this.guard.open("ZipFile.close");
         }
 
         void clean() {
@@ -808,6 +810,8 @@ public class ZipFile implements ZipConstants, Closeable {
 
         public void run() {
             IOException ioe = null;
+            // Android-added: CloseGuard support.
+            guard.warnIfOpen();
 
             // Release cached inflaters and close the cache first
             Deque<Inflater> inflaters = this.inflaterCache;
@@ -873,16 +877,14 @@ public class ZipFile implements ZipConstants, Closeable {
         if (closeRequested) {
             return;
         }
-        // Android-added: CloseGuard support.
-        if (guard != null) {
-            guard.close();
-        }
         closeRequested = true;
 
         synchronized (this) {
             // Close streams, release their inflaters, release cached inflaters
             // and release zip source
             try {
+                // Android-added: CloseGuard support.
+                res.guard.close();
                 res.clean();
             } catch (UncheckedIOException ioe) {
                 throw ioe.getCause();
diff --git a/ojluni/src/main/java/javax/crypto/TEST_MAPPING b/ojluni/src/main/java/javax/crypto/TEST_MAPPING
index 6860a5c5176..e2f8f60fdff 100644
--- a/ojluni/src/main/java/javax/crypto/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/crypto/TEST_MAPPING
@@ -1,24 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.crypto.tests.javax.crypto"
-        },
-        {
-          "include-filter": "org.apache.harmony.crypto.tests.javax.crypto.func"
-        },
-        {
-          "include-filter": "libcore.javax.crypto"
-        },
-        {
-          "include-filter": "com.android.org.conscrypt.javax.crypto"
-        },
-        {
-          "include-filter": "org.apache.harmony.crypto.tests.javax.crypto.serialization"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_crypto"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/crypto/interfaces/TEST_MAPPING b/ojluni/src/main/java/javax/crypto/interfaces/TEST_MAPPING
deleted file mode 100644
index 427bf7924a9..00000000000
--- a/ojluni/src/main/java/javax/crypto/interfaces/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.crypto.tests.javax.crypto.interfaces"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/crypto/spec/TEST_MAPPING b/ojluni/src/main/java/javax/crypto/spec/TEST_MAPPING
deleted file mode 100644
index d1e9d5a1a68..00000000000
--- a/ojluni/src/main/java/javax/crypto/spec/TEST_MAPPING
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.crypto.tests.javax.crypto.spec"
-        },
-        {
-          "include-filter": "libcore.javax.crypto.spec"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/net/TEST_MAPPING b/ojluni/src/main/java/javax/net/TEST_MAPPING
index aeabde81438..9f6f1d218d0 100644
--- a/ojluni/src/main/java/javax/net/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/net/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.net"
-        },
-        {
-          "include-filter": "libcore.javax.net"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_net"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/net/ssl/TEST_MAPPING b/ojluni/src/main/java/javax/net/ssl/TEST_MAPPING
index d3ae570f0ef..13cac41cdae 100644
--- a/ojluni/src/main/java/javax/net/ssl/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/net/ssl/TEST_MAPPING
@@ -1,21 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.javax.net.ssl"
-        },
-        {
-          "include-filter": "com.android.org.conscrypt.javax.net.ssl"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.javax.net.ssl"
-        },
-        {
-          "include-filter": "org.apache.harmony.luni.tests.internal.net.www.protocol.https"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_net_ssl"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/security/auth/TEST_MAPPING b/ojluni/src/main/java/javax/security/auth/TEST_MAPPING
index 45bd9c79ccb..d860b68de7a 100644
--- a/ojluni/src/main/java/javax/security/auth/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/security/auth/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security.auth"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_security_auth"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/security/auth/callback/TEST_MAPPING b/ojluni/src/main/java/javax/security/auth/callback/TEST_MAPPING
deleted file mode 100644
index e742b171239..00000000000
--- a/ojluni/src/main/java/javax/security/auth/callback/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security.auth.callback"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/security/auth/login/TEST_MAPPING b/ojluni/src/main/java/javax/security/auth/login/TEST_MAPPING
deleted file mode 100644
index a22e2b315ac..00000000000
--- a/ojluni/src/main/java/javax/security/auth/login/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security.auth.login"
-        }
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/security/auth/x500/TEST_MAPPING b/ojluni/src/main/java/javax/security/auth/x500/TEST_MAPPING
index 3ba13dadfc0..a3b4d4d51af 100644
--- a/ojluni/src/main/java/javax/security/auth/x500/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/security/auth/x500/TEST_MAPPING
@@ -5,11 +5,8 @@
       "options": [
         {
           "include-filter": "libcore.javax.security.auth.x500"
-        },
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security.auth.x500"
         }
       ]
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/main/java/javax/security/cert/TEST_MAPPING b/ojluni/src/main/java/javax/security/cert/TEST_MAPPING
index 4603638c435..cb318d0af23 100644
--- a/ojluni/src/main/java/javax/security/cert/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/security/cert/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.javax.security.cert"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_security_cert"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/javax/sql/TEST_MAPPING b/ojluni/src/main/java/javax/sql/TEST_MAPPING
index bbbb56c71ca..a131b9d7885 100644
--- a/ojluni/src/main/java/javax/sql/TEST_MAPPING
+++ b/ojluni/src/main/java/javax/sql/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.javax.sql"
-        },
-        {
-          "include-filter": "org.apache.harmony.sql.tests.javax.sql"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_sql"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/jdk/internal/access/JavaLangAccess.java b/ojluni/src/main/java/jdk/internal/access/JavaLangAccess.java
new file mode 100644
index 00000000000..23f33014b28
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/access/JavaLangAccess.java
@@ -0,0 +1,567 @@
+/*
+ * Copyright (c) 2003, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.access;
+
+public interface JavaLangAccess {
+
+    // BEGIN Android-removed: Not used in Android.
+    /*
+    /**
+     * Returns the list of {@code Method} objects for the declared public
+     * methods of this class or interface that have the specified method name
+     * and parameter types.
+     * /
+    List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes);
+
+    /**
+     * Return the constant pool for a class.
+     * /
+    ConstantPool getConstantPool(Class<?> klass);
+
+    /**
+     * Compare-And-Set the AnnotationType instance corresponding to this class.
+     * (This method only applies to annotation types.)
+     * /
+    boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType);
+
+    /**
+     * Get the AnnotationType instance corresponding to this class.
+     * (This method only applies to annotation types.)
+     * /
+    AnnotationType getAnnotationType(Class<?> klass);
+
+    /**
+     * Get the declared annotations for a given class, indexed by their types.
+     * /
+    Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap(Class<?> klass);
+
+    /**
+     * Get the array of bytes that is the class-file representation
+     * of this Class' annotations.
+     * /
+    byte[] getRawClassAnnotations(Class<?> klass);
+
+    /**
+     * Get the array of bytes that is the class-file representation
+     * of this Class' type annotations.
+     * /
+    byte[] getRawClassTypeAnnotations(Class<?> klass);
+
+    /**
+     * Get the array of bytes that is the class-file representation
+     * of this Executable's type annotations.
+     * /
+    byte[] getRawExecutableTypeAnnotations(Executable executable);
+     */
+    // END Android-removed: Not used in Android.
+
+    /**
+     * Returns the elements of an enum class or null if the
+     * Class object does not represent an enum type;
+     * the result is uncloned, cached, and shared by all callers.
+     */
+    <E extends Enum<E>> E[] getEnumConstantsShared(Class<E> klass);
+
+    // BEGIN Android-removed: Not used in Android.
+    /*
+    /**
+     * Set current thread's blocker field.
+     * /
+    void blockedOn(Interruptible b);
+
+    /**
+     * Registers a shutdown hook.
+     *
+     * It is expected that this method with registerShutdownInProgress=true
+     * is only used to register DeleteOnExitHook since the first file
+     * may be added to the delete on exit list by the application shutdown
+     * hooks.
+     *
+     * @param slot  the slot in the shutdown hook array, whose element
+     *              will be invoked in order during shutdown
+     * @param registerShutdownInProgress true to allow the hook
+     *        to be registered even if the shutdown is in progress.
+     * @param hook  the hook to be registered
+     *
+     * @throws IllegalStateException if shutdown is in progress and
+     *         the slot is not valid to register.
+     * /
+    void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook);
+
+    /**
+     * Returns a new Thread with the given Runnable and an
+     * inherited AccessControlContext.
+     * /
+    Thread newThreadWithAcc(Runnable target, @SuppressWarnings("removal") AccessControlContext acc);
+
+    /**
+     * Invokes the finalize method of the given object.
+     * /
+    void invokeFinalize(Object o) throws Throwable;
+
+    /**
+     * Returns the ConcurrentHashMap used as a storage for ClassLoaderValue(s)
+     * associated with the given class loader, creating it if it doesn't already exist.
+     * /
+    ConcurrentHashMap<?, ?> createOrGetClassLoaderValueMap(ClassLoader cl);
+
+    /**
+     * Defines a class with the given name to a class loader.
+     * /
+    Class<?> defineClass(ClassLoader cl, String name, byte[] b, ProtectionDomain pd, String source);
+
+    /**
+     * Defines a class with the given name to a class loader with
+     * the given flags and class data.
+     *
+     * @see java.lang.invoke.MethodHandles.Lookup#defineClass
+     * /
+    Class<?> defineClass(ClassLoader cl, Class<?> lookup, String name, byte[] b, ProtectionDomain pd, boolean initialize, int flags, Object classData);
+
+    /**
+     * Returns a class loaded by the bootstrap class loader.
+     * /
+    Class<?> findBootstrapClassOrNull(String name);
+
+    /**
+     * Define a Package of the given name and module by the given class loader.
+     * /
+    Package definePackage(ClassLoader cl, String name, Module module);
+
+    /**
+     * Invokes Long.fastUUID
+     * /
+    String fastUUID(long lsb, long msb);
+
+    /**
+     * Record the non-exported packages of the modules in the given layer
+     * /
+    void addNonExportedPackages(ModuleLayer layer);
+
+    /**
+     * Invalidate package access cache
+     * /
+    void invalidatePackageAccessCache();
+
+    /**
+     * Defines a new module to the Java virtual machine. The module
+     * is defined to the given class loader.
+     *
+     * The URI is for information purposes only, it can be {@code null}.
+     * /
+    Module defineModule(ClassLoader loader, ModuleDescriptor descriptor, URI uri);
+
+    /**
+     * Defines the unnamed module for the given class loader.
+     * /
+    Module defineUnnamedModule(ClassLoader loader);
+
+    /**
+     * Updates the readability so that module m1 reads m2. The new read edge
+     * does not result in a strong reference to m2 (m2 can be GC'ed).
+     *
+     * This method is the same as m1.addReads(m2) but without a permission check.
+     * /
+    void addReads(Module m1, Module m2);
+
+    /**
+     * Updates module m to read all unnamed modules.
+     * /
+    void addReadsAllUnnamed(Module m);
+
+    /**
+     * Updates module m1 to export a package unconditionally.
+     * /
+    void addExports(Module m1, String pkg);
+
+    /**
+     * Updates module m1 to export a package to module m2. The export does
+     * not result in a strong reference to m2 (m2 can be GC'ed).
+     * /
+    void addExports(Module m1, String pkg, Module m2);
+
+    /**
+     * Updates a module m to export a package to all unnamed modules.
+     * /
+    void addExportsToAllUnnamed(Module m, String pkg);
+
+    /**
+     * Updates module m1 to open a package to module m2. Opening the
+     * package does not result in a strong reference to m2 (m2 can be GC'ed).
+     * /
+    void addOpens(Module m1, String pkg, Module m2);
+
+    /**
+     * Updates module m to open a package to all unnamed modules.
+     * /
+    void addOpensToAllUnnamed(Module m, String pkg);
+
+    /**
+     * Updates module m to open all packages in the given sets.
+     * /
+    void addOpensToAllUnnamed(Module m, Set<String> concealedPkgs, Set<String> exportedPkgs);
+
+    /**
+     * Updates module m to use a service.
+     * /
+    void addUses(Module m, Class<?> service);
+
+    /**
+     * Returns true if module m reflectively exports a package to other
+     * /
+    boolean isReflectivelyExported(Module module, String pn, Module other);
+
+    /**
+     * Returns true if module m reflectively opens a package to other
+     * /
+    boolean isReflectivelyOpened(Module module, String pn, Module other);
+
+    /**
+     * Updates module m to allow access to restricted methods.
+     * /
+    Module addEnableNativeAccess(Module m);
+
+    /**
+     * Updates all unnamed modules to allow access to restricted methods.
+     * /
+    void addEnableNativeAccessToAllUnnamed();
+
+    /**
+     * Ensure that the given module has native access. If not, warn or
+     * throw exception depending on the configuration.
+     * /
+    void ensureNativeAccess(Module m, Class<?> owner, String methodName);
+
+    /**
+     * Returns the ServicesCatalog for the given Layer.
+     * /
+    ServicesCatalog getServicesCatalog(ModuleLayer layer);
+
+    /**
+     * Record that this layer has at least one module defined to the given
+     * class loader.
+     * /
+    void bindToLoader(ModuleLayer layer, ClassLoader loader);
+
+    /**
+     * Returns an ordered stream of layers. The first element is the
+     * given layer, the remaining elements are its parents, in DFS order.
+     * /
+    Stream<ModuleLayer> layers(ModuleLayer layer);
+
+    /**
+     * Returns a stream of the layers that have modules defined to the
+     * given class loader.
+     * /
+    Stream<ModuleLayer> layers(ClassLoader loader);
+
+    /**
+     * Count the number of leading positive bytes in the range.
+     * /
+    int countPositives(byte[] ba, int off, int len);
+
+    /**
+     * Constructs a new {@code String} by decoding the specified subarray of
+     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.
+     *
+     * The caller of this method shall relinquish and transfer the ownership of
+     * the byte array to the callee since the later will not make a copy.
+     *
+     * @param bytes the byte array source
+     * @param cs the Charset
+     * @return the newly created string
+     * @throws CharacterCodingException for malformed or unmappable bytes
+     * /
+    String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;
+
+    /**
+     * Encode the given string into a sequence of bytes using the specified Charset.
+     *
+     * This method avoids copying the String's internal representation if the input
+     * is ASCII.
+     *
+     * This method throws CharacterCodingException instead of replacing when
+     * malformed input or unmappable characters are encountered.
+     *
+     * @param s the string to encode
+     * @param cs the charset
+     * @return the encoded bytes
+     * @throws CharacterCodingException for malformed input or unmappable characters
+     * /
+    byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException;
+
+    /**
+     * Returns a new string by decoding from the given utf8 bytes array.
+     *
+     * @param off the index of the first byte to decode
+     * @param len the number of bytes to decode
+     * @return the newly created string
+     * @throws IllegalArgumentException for malformed or unmappable bytes.
+     * /
+    String newStringUTF8NoRepl(byte[] bytes, int off, int len);
+
+    /**
+     * Get the char at index in a byte[] in internal UTF-16 representation,
+     * with no bounds checks.
+     *
+     * @param bytes the UTF-16 encoded bytes
+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)
+     * @return the char value
+     * /
+    char getUTF16Char(byte[] bytes, int index);
+
+    /**
+     * Encode the given string into a sequence of bytes using utf8.
+     *
+     * @param s the string to encode
+     * @return the encoded bytes in utf8
+     * @throws IllegalArgumentException for malformed surrogates
+     * /
+    byte[] getBytesUTF8NoRepl(String s);
+
+    /**
+     * Inflated copy from byte[] to char[], as defined by StringLatin1.inflate
+     * /
+    void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);
+
+    /**
+     * Decodes ASCII from the source byte array into the destination
+     * char array.
+     *
+     * @return the number of bytes successfully decoded, at most len
+     * /
+    int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);
+
+    /**
+     * Returns the initial `System.in` to determine if it is replaced
+     * with `System.setIn(newIn)` method
+     * /
+    InputStream initialSystemIn();
+
+    /**
+     * Encodes ASCII codepoints as possible from the source array into
+     * the destination byte array, assuming that the encoding is ASCII
+     * compatible
+     *
+     * @return the number of bytes successfully encoded, or 0 if none
+     * /
+    int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);
+
+    /**
+     * Set the cause of Throwable
+     * @param cause set t's cause to new value
+     * /
+    void setCause(Throwable t, Throwable cause);
+
+    /**
+     * Get protection domain of the given Class
+     * /
+    ProtectionDomain protectionDomain(Class<?> c);
+
+    /**
+     * Get a method handle of string concat helper method
+     * /
+    MethodHandle stringConcatHelper(String name, MethodType methodType);
+
+    /**
+     * Get the string concat initial coder
+     * /
+    long stringConcatInitialCoder();
+
+    /**
+     * Update lengthCoder for constant
+     * /
+    long stringConcatMix(long lengthCoder, String constant);
+     */
+    // END Android-removed: Not used in Android.
+
+   // BEGIN Android-removed: Preview features not supported.
+   /*
+   /**
+    * Get the coder for the supplied character.
+    * /
+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)
+   long stringConcatCoder(char value);
+
+   /**
+    * Update lengthCoder for StringBuilder.
+    * /
+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)
+   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);
+
+    /**
+     * Prepend StringBuilder content.
+     * /
+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)
+   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);
+     */
+   // END Android-removed: Preview features not supported.
+
+    // BEGIN Android-removed: Not used in Android.
+    /*
+    /**
+     * Join strings
+     * /
+    String join(String prefix, String suffix, String delimiter, String[] elements, int size);
+
+    /*
+     * Get the class data associated with the given class.
+     * @param c the class
+     * @see java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+     * /
+    Object classData(Class<?> c);
+
+    long findNative(ClassLoader loader, String entry);
+
+    /**
+     * Direct access to Shutdown.exit to avoid security manager checks
+     * @param statusCode the status code
+     * /
+    void exit(int statusCode);
+
+    /**
+     * Returns an array of all platform threads.
+     * /
+    Thread[] getAllThreads();
+
+    /**
+     * Returns the ThreadContainer for a thread, may be null.
+     * /
+    ThreadContainer threadContainer(Thread thread);
+
+    /**
+     * Starts a thread in the given ThreadContainer.
+     * /
+    void start(Thread thread, ThreadContainer container);
+
+    /**
+     * Returns the top of the given thread's stackable scope stack.
+     * /
+    StackableScope headStackableScope(Thread thread);
+
+    /**
+     * Sets the top of the current thread's stackable scope stack.
+     * /
+    void setHeadStackableScope(StackableScope scope);
+
+    /**
+     * Returns the Thread object for the current platform thread. If the
+     * current thread is a virtual thread then this method returns the carrier.
+     * /
+    Thread currentCarrierThread();
+
+    /**
+     * Executes the given value returning task on the current carrier thread.
+     * /
+    <V> V executeOnCarrierThread(Callable<V> task) throws Exception;
+
+    /**
+     * Returns the value of the current carrier thread's copy of a thread-local.
+     * /
+    <T> T getCarrierThreadLocal(CarrierThreadLocal<T> local);
+
+    /**
+     * Sets the value of the current carrier thread's copy of a thread-local.
+     * /
+    <T> void setCarrierThreadLocal(CarrierThreadLocal<T> local, T value);
+
+    /**
+     * Removes the value of the current carrier thread's copy of a thread-local.
+     * /
+    void removeCarrierThreadLocal(CarrierThreadLocal<?> local);
+
+    /**
+     * Returns {@code true} if there is a value in the current carrier thread's copy of
+     * thread-local, even if that values is {@code null}.
+     * /
+    boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local);
+
+    /**
+     * Returns the current thread's scoped values cache
+     * /
+    Object[] scopedValueCache();
+
+    /**
+     * Sets the current thread's scoped values cache
+     * /
+    void setScopedValueCache(Object[] cache);
+
+    /**
+     * Return the current thread's scoped value bindings.
+     * /
+    Object scopedValueBindings();
+
+    /**
+     * Returns the innermost mounted continuation
+     * /
+    Continuation getContinuation(Thread thread);
+
+    /**
+     * Sets the innermost mounted continuation
+     * /
+    void setContinuation(Thread thread, Continuation continuation);
+
+    /**
+     * The ContinuationScope of virtual thread continuations
+     * /
+    ContinuationScope virtualThreadContinuationScope();
+
+    /**
+     * Parks the current virtual thread.
+     * @throws WrongThreadException if the current thread is not a virtual thread
+     * /
+    void parkVirtualThread();
+
+    /**
+     * Parks the current virtual thread for up to the given waiting time.
+     * @param nanos the maximum number of nanoseconds to wait
+     * @throws WrongThreadException if the current thread is not a virtual thread
+     * /
+    void parkVirtualThread(long nanos);
+
+    /**
+     * Re-enables a virtual thread for scheduling. If the thread was parked then
+     * it will be unblocked, otherwise its next attempt to park will not block
+     * @param thread the virtual thread to unpark
+     * @throws IllegalArgumentException if the thread is not a virtual thread
+     * @throws RejectedExecutionException if the scheduler cannot accept a task
+     * /
+    void unparkVirtualThread(Thread thread);
+
+    /**
+     * Creates a new StackWalker
+     * /
+    StackWalker newStackWalkerInstance(Set<StackWalker.Option> options,
+                                       ContinuationScope contScope,
+                                       Continuation continuation);
+    /**
+     * Returns '<loader-name>' @<id> if classloader has a name
+     * explicitly set otherwise <qualified-class-name> @<id>
+     * /
+    String getLoaderNameID(ClassLoader loader);
+     */
+    // END Android-removed: Not used in Android.
+}
diff --git a/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java b/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
index 42da788f4ea..22c5aa85be3 100644
--- a/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
+++ b/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
@@ -43,7 +43,11 @@ public class SharedSecrets {
     private static JavaAWTAccess javaAWTAccess;
     private static JavaAWTFontAccess javaAWTFontAccess;
     private static JavaBeansAccess javaBeansAccess;
+    */
+    // END Android-removed: Pruned unused access interfaces.
     private static JavaLangAccess javaLangAccess;
+    // BEGIN Android-removed: Pruned unused access interfaces.
+    /*
     private static JavaLangInvokeAccess javaLangInvokeAccess;
     private static JavaLangModuleAccess javaLangModuleAccess;
     private static JavaLangRefAccess javaLangRefAccess;
@@ -111,12 +115,16 @@ public class SharedSecrets {
     public static void setJavaUtilJarAccess(JavaUtilJarAccess access) {
         javaUtilJarAccess = access;
     }
+    */
+    // END Android-removed: Pruned unused access interfaces.
     public static void setJavaLangAccess(JavaLangAccess jla) {
         javaLangAccess = jla;
     }
     public static JavaLangAccess getJavaLangAccess() {
         return javaLangAccess;
     }
+    // BEGIN Android-removed: Pruned unused access interfaces.
+    /*
     public static void setJavaLangInvokeAccess(JavaLangInvokeAccess jlia) {
         javaLangInvokeAccess = jlia;
     }
diff --git a/ojluni/src/main/java/jdk/internal/event/Event.java b/ojluni/src/main/java/jdk/internal/event/Event.java
new file mode 100644
index 00000000000..b01bb289a92
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/Event.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.event;
+
+/**
+ * Base class for events, to be subclassed in order to define events and their
+ * fields.
+ *
+ * @hidden
+ */
+public abstract class Event {
+    /**
+     * Sole constructor, for invocation by subclass constructors, typically
+     * implicit.
+     */
+    protected Event() {
+    }
+
+    /**
+     * Starts the timing of this event.
+     */
+    public void begin() {
+    }
+
+    /**
+     * Ends the timing of this event.
+     *
+     * The {@code end} method must be invoked after the {@code begin} method.
+     */
+    public void end() {
+    }
+
+    /**
+     * Writes the field values, time stamp, and event duration.
+     * <p>
+     * If the event starts with an invocation of the {@code begin} method, but does
+     * not end with an explicit invocation of the {@code end} method, then the event
+     * ends when the {@code commit} method is invoked.
+     */
+    public void commit() {
+    }
+
+    /**
+     * Returns {@code true} if the event is enabled, {@code false} otherwise
+     *
+     * @return {@code true} if event is enabled, {@code false} otherwise
+     */
+    public boolean isEnabled() {
+        return false;
+    }
+
+    /**
+     * Returns {@code true} if the event is enabled and if the duration is within
+     * the threshold for the event, {@code false} otherwise.
+     *
+     * @return {@code true} if the event can be written, {@code false} otherwise
+     */
+    public boolean shouldCommit() {
+        return false;
+    }
+
+    /**
+     * Sets a field value.
+     *
+     * @param index the index of the field to set
+     * @param value value to set, can be {@code null}
+     * @throws UnsupportedOperationException if functionality is not supported
+     * @throws IndexOutOfBoundsException if {@code index} is less than {@code 0} or
+     *         greater than or equal to the number of fields specified for the event
+     */
+    public void set(int index, Object value) {
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java b/ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java
new file mode 100644
index 00000000000..84536009e29
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.event;
+
+/**
+ * Event recording that a virtual thread has terminated.
+ */
+public class VirtualThreadEndEvent extends Event {
+    private final static VirtualThreadEndEvent EVENT = new VirtualThreadEndEvent();
+
+    /**
+     * Returns {@code true} if event is enabled, {@code false} otherwise.
+     */
+    public static boolean isTurnedOn() {
+        return EVENT.isEnabled();
+    }
+
+    public long javaThreadId;
+}
diff --git a/ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java b/ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java
new file mode 100644
index 00000000000..73746dc4abc
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.event;
+
+/**
+ * Event recording that a virtual thread has parked on its carrier thread.
+ */
+public class VirtualThreadPinnedEvent extends Event {
+}
diff --git a/ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java b/ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java
new file mode 100644
index 00000000000..e5a6f6179dd
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.event;
+
+/**
+ * Event recording that a virtual thread has been started.
+ */
+public class VirtualThreadStartEvent extends Event {
+    private final static VirtualThreadStartEvent EVENT = new VirtualThreadStartEvent();
+
+    /**
+     * Returns {@code true} if event is enabled, {@code false} otherwise.
+     */
+    public static boolean isTurnedOn() {
+        return EVENT.isEnabled();
+    }
+
+    public long javaThreadId;
+}
diff --git a/ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java b/ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java
new file mode 100644
index 00000000000..e12e4008e4a
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.event;
+
+/**
+ * Event recording when an attempt to submit the task for a virtual thread failed.
+ */
+public class VirtualThreadSubmitFailedEvent extends Event {
+    public long javaThreadId;
+    public String exceptionMessage;
+}
diff --git a/ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java b/ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java
new file mode 100644
index 00000000000..f80e387cc9c
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.misc;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Defines static methods to support execution in the context of a virtual thread.
+ *
+ * @hide
+ */
+public final class VirtualThreads {
+    // Android-removed: Not used in Android.
+    // private static final JavaLangAccess JLA;
+    // static {
+    //     JLA = SharedSecrets.getJavaLangAccess();
+    //     if (JLA == null) {
+    //         throw new InternalError("JavaLangAccess not setup");
+    //     }
+    // }
+    private VirtualThreads() { }
+
+    /**
+     * Parks the current virtual thread until it is unparked or interrupted.
+     * If already unparked then the parking permit is consumed and this method
+     * completes immediately (meaning it doesn't yield). It also completes
+     * immediately if the interrupt status is set.
+     * @throws WrongThreadException if the current thread is not a virtual thread
+     */
+    public static void park() {
+        // Android-removed: Not used in Android.
+        // JLA.parkVirtualThread();
+    }
+
+    /**
+     * Parks the current virtual thread up to the given waiting time or until it
+     * is unparked or interrupted. If already unparked then the parking permit is
+     * consumed and this method completes immediately (meaning it doesn't yield).
+     * It also completes immediately if the interrupt status is set or the waiting
+     * time is {@code <= 0}.
+     * @param nanos the maximum number of nanoseconds to wait
+     * @throws WrongThreadException if the current thread is not a virtual thread
+     */
+    public static void park(long nanos) {
+        // Android-removed: Not used in Android.
+        // JLA.parkVirtualThread(nanos);
+    }
+
+    /**
+     * Parks the current virtual thread until the given deadline or until is is
+     * unparked or interrupted. If already unparked then the parking permit is
+     * consumed and this method completes immediately (meaning it doesn't yield).
+     * It also completes immediately if the interrupt status is set or the
+     * deadline has past.
+     * @param deadline absolute time, in milliseconds, from the epoch
+     * @throws WrongThreadException if the current thread is not a virtual thread
+     */
+    public static void parkUntil(long deadline) {
+        // Android-removed: Not used in Android.
+        // long millis = deadline - System.currentTimeMillis();
+        // long nanos = TimeUnit.NANOSECONDS.convert(millis, TimeUnit.MILLISECONDS);
+        // park(nanos);
+    }
+
+    /**
+     * Re-enables a virtual thread for scheduling. If the thread was parked then
+     * it will be unblocked, otherwise its next attempt to park will not block
+     * @param thread the virtual thread to unpark
+     * @throws IllegalArgumentException if the thread is not a virtual thread
+     * @throws RejectedExecutionException if the scheduler cannot accept a task
+     */
+    public static void unpark(Thread thread) {
+        // Android-removed: Not used in Android.
+        // JLA.unparkVirtualThread(thread);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/ReferenceKey.java b/ojluni/src/main/java/jdk/internal/util/ReferenceKey.java
new file mode 100644
index 00000000000..a193794fe70
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/ReferenceKey.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.lang.ref.Reference;
+
+/**
+ * View/wrapper of keys used by the backing {@link ReferencedKeyMap}.
+ * There are two style of keys; one for entries in the backing map and
+ * one for queries to the backing map. This second style avoids the
+ * overhead of a {@link Reference} object.
+ *
+ * @param <T> key type
+ *
+ * @since 21
+ */
+public sealed interface ReferenceKey<T> permits StrongReferenceKey, WeakReferenceKey, SoftReferenceKey {
+    /**
+     * {@return the value of the unwrapped key}
+     */
+    T get();
+
+    /**
+     * Cleanup unused key.
+     */
+    void unused();
+
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java b/ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java
new file mode 100644
index 00000000000..c002b3da7cf
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java
@@ -0,0 +1,487 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Objects;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import jdk.internal.access.SharedSecrets;
+
+/**
+ * This class provides management of {@link Map maps} where it is desirable to
+ * remove entries automatically when the key is garbage collected. This is
+ * accomplished by using a backing map where the keys are either a
+ * {@link WeakReference} or a {@link SoftReference}.
+ * <p>
+ * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}
+ * of the backing map and whether {@link WeakReference} or
+ * {@link SoftReference} is to be used.
+ *
+ * {@snippet :
+ * // Use HashMap and WeakReference
+ * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);
+ * map.put(10_000_000L, "a");
+ * map.put(10_000_001L, "b");
+ * map.put(10_000_002L, "c");
+ * map.put(10_000_003L, "d");
+ * map.put(10_000_004L, "e");
+ *
+ * // Use ConcurrentHashMap and SoftReference
+ * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);
+ * map.put(20_000_000L, "v");
+ * map.put(20_000_001L, "w");
+ * map.put(20_000_002L, "x");
+ * map.put(20_000_003L, "y");
+ * map.put(20_000_004L, "z");
+ * }
+ *
+ * @implNote Care must be given that the backing map does replacement by
+ * replacing the value in the map entry instead of deleting the old entry and
+ * adding a new entry, otherwise replaced entries may end up with a strongly
+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known
+ * to be safe.
+ *
+ * @param <K> the type of keys maintained by this map
+ * @param <V> the type of mapped values
+ *
+ * @since 21
+ */
+public final class ReferencedKeyMap<K, V> implements Map<K, V> {
+    /**
+     * true if {@link SoftReference} keys are to be used,
+     * {@link WeakReference} otherwise.
+     */
+    private final boolean isSoft;
+
+    /**
+     * Backing {@link Map}.
+     */
+    private final Map<ReferenceKey<K>, V> map;
+
+    /**
+     * {@link ReferenceQueue} for cleaning up entries.
+     */
+    private final ReferenceQueue<K> stale;
+
+    /**
+     * Private constructor.
+     *
+     * @param isSoft          true if {@link SoftReference} keys are to
+     *                        be used, {@link WeakReference} otherwise.
+     * @param map             backing map
+     * @param stale           {@link ReferenceQueue} for cleaning up entries
+     */
+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map, ReferenceQueue<K> stale) {
+        this.isSoft = isSoft;
+        this.map = map;
+        this.stale = stale;
+    }
+
+    /**
+     * Create a new {@link ReferencedKeyMap} map.
+     *
+     * @param isSoft          true if {@link SoftReference} keys are to
+     *                        be used, {@link WeakReference} otherwise.
+     * @param supplier        {@link Supplier} of the backing map
+     *
+     * @return a new map with {@link Reference} keys
+     *
+     * @param <K> the type of keys maintained by the new map
+     * @param <V> the type of mapped values
+     */
+    // Android-changed: made private so no one tries to create a map with a non-native queue.
+    // public static <K, V> ReferencedKeyMap<K, V>
+    private static <K, V> ReferencedKeyMap<K, V>
+    create(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {
+        // Android-changed: only native monitors based queues are available.
+        // return create(isSoft, false, supplier);
+        return create(isSoft, true, supplier);
+    }
+
+    /**
+     * Create a new {@link ReferencedKeyMap} map.
+     *
+     * @param isSoft          true if {@link SoftReference} keys are to
+     *                        be used, {@link WeakReference} otherwise.
+     * @param useNativeQueue  true if uses NativeReferenceQueue
+     *                        otherwise use {@link ReferenceQueue}.
+     * @param supplier        {@link Supplier} of the backing map
+     *
+     * @return a new map with {@link Reference} keys
+     *
+     * @param <K> the type of keys maintained by the new map
+     * @param <V> the type of mapped values
+     */
+    // Android-changed: made package-private so no one tries to create a map with a non-native queue
+    // public static <K, V> ReferencedKeyMap<K, V>
+    static <K, V> ReferencedKeyMap<K, V>
+    create(boolean isSoft, boolean useNativeQueue, Supplier<Map<ReferenceKey<K>, V>> supplier) {
+        // Android-added: non-native queue is not available.
+        if (!useNativeQueue) {
+            throw new IllegalArgumentException("Only native queue is supported");
+        }
+        return new ReferencedKeyMap<K, V>(isSoft, supplier.get(),
+                // Android-changed: non-native queue is not available and ReferenceQueue is
+                // native monitors based.
+                // useNativeQueue ? SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue()
+                //                : new ReferenceQueue<>()
+                new ReferenceQueue<>()
+                );
+    }
+
+    // Android-added: add a separate method with explicit name instead of passing boolean arg.
+    public static <K, V> ReferencedKeyMap<K, V>
+    createWithNativeQueue(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {
+        return create(isSoft, /* useNativeQueue= */ true, supplier);
+    }
+
+    /**
+     * {@return a key suitable for a map entry}
+     *
+     * @param key unwrapped key
+     */
+    @SuppressWarnings("unchecked")
+    private ReferenceKey<K> entryKey(Object key) {
+        if (isSoft) {
+            return new SoftReferenceKey<>((K)key, stale);
+        } else {
+            return new WeakReferenceKey<>((K)key, stale);
+        }
+    }
+
+    /**
+     * {@return a key suitable for lookup}
+     *
+     * @param key unwrapped key
+     */
+    @SuppressWarnings("unchecked")
+    private ReferenceKey<K> lookupKey(Object key) {
+        return new StrongReferenceKey<>((K)key);
+    }
+
+    @Override
+    public int size() {
+        removeStaleReferences();
+        return map.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        removeStaleReferences();
+        return map.isEmpty();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        Objects.requireNonNull(key, "key must not be null");
+        removeStaleReferences();
+        return map.containsKey(lookupKey(key));
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        Objects.requireNonNull(value, "value must not be null");
+        removeStaleReferences();
+        return map.containsValue(value);
+    }
+
+    @Override
+    public V get(Object key) {
+        Objects.requireNonNull(key, "key must not be null");
+        removeStaleReferences();
+        return map.get(lookupKey(key));
+    }
+
+    @Override
+    public V put(K key, V newValue) {
+        Objects.requireNonNull(key, "key must not be null");
+        Objects.requireNonNull(newValue, "value must not be null");
+        removeStaleReferences();
+        ReferenceKey<K> entryKey = entryKey(key);
+        // If {@code put} returns non-null then was actually a {@code replace}
+        // and older key was used. In that case the new key was not used and the
+        // reference marked stale.
+        V oldValue = map.put(entryKey, newValue);
+        if (oldValue != null) {
+            entryKey.unused();
+        }
+        return oldValue;
+    }
+
+    @Override
+    public V remove(Object key) {
+        // Rely on gc to clean up old key.
+        return map.remove(lookupKey(key));
+    }
+
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        removeStaleReferences();
+        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {
+            K key = entry.getKey();
+            V value = entry.getValue();
+            put(key, value);
+        }
+    }
+
+    @Override
+    public void clear() {
+        removeStaleReferences();
+        // Rely on gc to clean up old keys.
+        map.clear();
+    }
+
+    /**
+     * Common routine for collecting the current set of keys.
+     *
+     * @return {@link Stream} of valid keys (unwrapped)
+     */
+    private Stream<K> filterKeySet() {
+        return map.keySet()
+                .stream()
+                .map(ReferenceKey::get)
+                .filter(Objects::nonNull);
+    }
+
+    @Override
+    public Set<K> keySet() {
+        removeStaleReferences();
+        return filterKeySet().collect(Collectors.toSet());
+    }
+
+    @Override
+    public Collection<V> values() {
+        removeStaleReferences();
+        return map.values();
+    }
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        removeStaleReferences();
+        return filterKeySet()
+                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))
+                .collect(Collectors.toSet());
+    }
+
+    @Override
+    public V putIfAbsent(K key, V newValue) {
+        removeStaleReferences();
+        ReferenceKey<K> entryKey = entryKey(key);
+        // If {@code putIfAbsent} returns non-null then was actually a
+        // {@code replace}  and older key was used. In that case the new key was
+        // not used and the reference marked stale.
+        V oldValue = map.putIfAbsent(entryKey, newValue);
+        if (oldValue != null) {
+            entryKey.unused();
+        }
+        return oldValue;
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        // Rely on gc to clean up old key.
+        return map.remove(lookupKey(key), value);
+    }
+
+    @Override
+    public boolean replace(K key, V oldValue, V newValue) {
+        removeStaleReferences();
+        // If replace is successful then the older key will be used and the
+        // lookup key will suffice.
+        return map.replace(lookupKey(key), oldValue, newValue);
+    }
+
+    @Override
+    public V replace(K key, V value) {
+        removeStaleReferences();
+        // If replace is successful then the older key will be used and the
+        // lookup key will suffice.
+        return map.replace(lookupKey(key), value);
+    }
+
+    @Override
+    public String toString() {
+        removeStaleReferences();
+        return filterKeySet()
+                .map(k -> k + "=" + get(k))
+                .collect(Collectors.joining(", ", "{", "}"));
+    }
+
+    /**
+     * Removes enqueued weak references from map.
+     */
+    public void removeStaleReferences() {
+        while (true) {
+            Object key = stale.poll();
+            if (key == null) {
+                break;
+            }
+            map.remove(key);
+        }
+    }
+
+    /**
+     * Puts an entry where the key and the value are the same. Used for
+     * interning values in a set.
+     *
+     * @implNote Requires a {@link ReferencedKeyMap} whose {@code V} type
+     * is a {@code ReferenceKey<K>}. Otherwise, a {@link ClassCastException} will
+     * be thrown.
+     *
+     * @param setMap    {@link ReferencedKeyMap} where interning takes place
+     * @param key       key to add
+     *
+     * @param <T> type of key
+     *
+     * @return the old key instance if found otherwise the new key instance
+     *
+     * @throws ClassCastException if {@code V} is not {@code EntryKey<T>}
+     */
+    static <T> T intern(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {
+        T value = existingKey(setMap, key);
+        if (value != null) {
+            return value;
+        }
+        return internKey(setMap, key);
+    }
+
+    /**
+     * Puts an entry where the key and the value are the same. Used for
+     * interning values in a set.
+     *
+     * @implNote Requires a {@link ReferencedKeyMap} whose {@code V} type
+     * is a {@code ReferenceKey<K>}. Otherwise, a {@link ClassCastException} will
+     * be thrown.
+     *
+     * @param setMap    {@link ReferencedKeyMap} where interning takes place
+     * @param key       key to add
+     * @param interner  operation to apply to key before adding to map
+     *
+     * @param <T> type of key
+     *
+     * @return the old key instance if found otherwise the new key instance
+     *
+     * @throws ClassCastException if {@code V} is not {@code EntryKey<T>}
+     *
+     * @implNote This version of intern should not be called during phase1
+     * using a lambda. Use an UnaryOperator instance instead.
+     */
+    static <T> T intern(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key, UnaryOperator<T> interner) {
+        T value = existingKey(setMap, key);
+        if (value != null) {
+            return value;
+        }
+        key = interner.apply(key);
+        return internKey(setMap, key);
+    }
+
+    /**
+     * Check if the key already exists in the map.
+     *
+     * @param setMap    {@link ReferencedKeyMap} where interning takes place
+     * @param key       key to test
+     *
+     * @param <T> type of key
+     *
+     * @return key if found otherwise null
+     */
+    private static <T> T existingKey(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {
+        setMap.removeStaleReferences();
+        ReferenceKey<T> entryKey = setMap.get(setMap.lookupKey(key));
+        return entryKey != null ? entryKey.get() : null;
+    }
+
+    /**
+     * Attempt to add key to map.
+     *
+     * @param setMap    {@link ReferencedKeyMap} where interning takes place
+     * @param key       key to add
+     *
+     * @param <T> type of key
+     *
+     * @return the old key instance if found otherwise the new key instance
+     */
+    private static <T> T internKey(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {
+        ReferenceKey<T> entryKey = setMap.entryKey(key);
+        T interned;
+        do {
+            setMap.removeStaleReferences();
+            ReferenceKey<T> existing = setMap.map.putIfAbsent(entryKey, entryKey);
+            if (existing == null) {
+                return key;
+            } else {
+                // If {@code putIfAbsent} returns non-null then was actually a
+                // {@code replace} and older key was used. In that case the new
+                // key was not used and the reference marked stale.
+                interned = existing.get();
+                if (interned != null) {
+                    entryKey.unused();
+                }
+            }
+        } while (interned == null);
+        return interned;
+    }
+
+
+    /**
+     * Attempt to add key to map if absent.
+     *
+     * @param setMap    {@link ReferencedKeyMap} where interning takes place
+     * @param key       key to add
+     *
+     * @param <T> type of key
+     *
+     * @return true if the key was added
+     */
+    static <T> boolean internAddKey(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {
+        ReferenceKey<T> entryKey = setMap.entryKey(key);
+        setMap.removeStaleReferences();
+        ReferenceKey<T> existing = setMap.map.putIfAbsent(entryKey, entryKey);
+        if (existing == null) {
+            return true;
+        } else {
+            // If {@code putIfAbsent} returns non-null then was actually a
+            // {@code replace} and older key was used. In that case the new
+            // key was not used and the reference marked stale.
+            entryKey.unused();
+            return false;
+        }
+     }
+
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java b/ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java
new file mode 100644
index 00000000000..dac67794700
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
+
+/**
+ * This class provides management of {@link Set set} where it is desirable to
+ * remove elements automatically when the element is garbage collected. This is
+ * accomplished by using a backing map where the keys and values are either a
+ * {@link WeakReference} or a {@link SoftReference}.
+ * <p>
+ * To create a {@link ReferencedKeySet} the user must provide a {@link Supplier}
+ * of the backing map and whether {@link WeakReference} or
+ * {@link SoftReference} is to be used.
+ * {@snippet :
+ * Set<Long> set;
+ *
+ * set = ReferencedKeySet.create(false, HashMap::new);
+ * set.add(30_000_000L);
+ * set.add(30_000_001L);
+ * set.add(30_000_002L);
+ * set.add(30_000_003L);
+ * set.add(30_000_004L);
+ *
+ * set = ReferencedKeySet.create(true, ConcurrentHashMap::new);
+ * set.add(40_000_000L);
+ * set.add(40_000_001L);
+ * set.add(40_000_002L);
+ * set.add(40_000_003L);
+ * set.add(40_000_004L);
+ * }
+ *
+ * @implNote Care must be given that the backing map does replacement by
+ * replacing the value in the map entry instead of deleting the old entry and
+ * adding a new entry, otherwise replaced entries may end up with a strongly
+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known
+ * to be safe.
+ *
+ * @param <T> the type of elements maintained by this set
+ */
+public final class ReferencedKeySet<T> extends AbstractSet<T> {
+    /**
+     * Backing {@link ReferencedKeySet} map.
+     */
+    final ReferencedKeyMap<T, ReferenceKey<T>> map;
+
+    /**
+     * Private constructor.
+     *
+     * @param map     backing map
+     */
+    private ReferencedKeySet(ReferencedKeyMap<T, ReferenceKey<T>> map) {
+        this.map = map;
+    }
+
+    /**
+     * Create a new {@link ReferencedKeySet} elements.
+     *
+     * @param isSoft          true if {@link SoftReference} elements are to
+     *                        be used, {@link WeakReference} otherwise.
+     * @param supplier        {@link Supplier} of the backing map
+     *
+     * @return a new set with {@link Reference} elements
+     *
+     * @param <E> the type of elements maintained by this set
+     */
+    // Android-changed: made private so no one tries to create a map with a non-native queue.
+    // public static <E> ReferencedKeySet<E>
+    private static <E> ReferencedKeySet<E>
+    create(boolean isSoft, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {
+        return create(isSoft, false, supplier);
+    }
+
+    /**
+     * Create a new {@link ReferencedKeySet} elements.
+     *
+     * @param isSoft          true if {@link SoftReference} elements are to
+     *                        be used, {@link WeakReference} otherwise.
+     * @param useNativeQueue  true if uses NativeReferenceQueue
+     *                        otherwise use {@link ReferenceQueue}.
+     * @param supplier        {@link Supplier} of the backing map
+     *
+     * @return a new set with {@link Reference} elements
+     *
+     * @param <E> the type of elements maintained by this set
+     */
+    // Android-changed: made private so no one tries to create a map with a non-native queue.
+    // public static <E> ReferencedKeySet<E>
+    private static <E> ReferencedKeySet<E>
+    create(boolean isSoft, boolean useNativeQueue, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {
+         return new ReferencedKeySet<>(ReferencedKeyMap.create(isSoft, useNativeQueue, supplier));
+    }
+
+    // Android-added: add a separate method with explicit name instead of passing boolean arg.
+    public static <E> ReferencedKeySet<E>
+    createWithNativeQueue(boolean isSoft, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {
+        return new ReferencedKeySet<>(ReferencedKeyMap.createWithNativeQueue(isSoft, supplier));
+    }
+
+    /**
+     * Removes enqueued weak references from set.
+     */
+    public void removeStaleReferences() {
+        map.removeStaleReferences();
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return map.keySet().iterator();
+    }
+
+    @Override
+    public int size() {
+        return map.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public boolean contains(Object o) {
+        return map.containsKey((T)o);
+    }
+
+    @Override
+    public boolean add(T e) {
+        return ReferencedKeyMap.internAddKey(map, e);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return map.remove(o) != null;
+    }
+
+    @Override
+    public void clear() {
+        map.clear();
+    }
+
+    /**
+     * Gets an existing element from the set, returning null if not present or
+     * the old element if previously added.
+     *
+     * @param e  element to get
+     *
+     * @return the old element if present, otherwise, null
+     */
+    public T get(T e) {
+        ReferenceKey<T> key = map.get(e);
+
+        return key == null ? null : key.get();
+    }
+
+    /**
+     * Intern an element to the set, returning the element if newly added or the
+     * old element if previously added.
+     *
+     * @param e  element to add
+     *
+     * @return the old element if present, otherwise, the new element
+     */
+    public T intern(T e) {
+        return ReferencedKeyMap.intern(map, e);
+    }
+
+    /**
+     * Intern an element to the set, returning the element if newly added or the
+     * old element if previously added.
+     *
+     * @param e         element to add
+     * @param interner  operation to apply to key before adding to set
+     *
+     * @return the old element if present, otherwise, the new element
+     *
+     * @implNote This version of intern should not be called during phase1
+     * using a lambda. Use an UnaryOperator instance instead.
+     */
+    public T intern(T e, UnaryOperator<T> interner) {
+        return ReferencedKeyMap.intern(map, e, interner);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java b/ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java
new file mode 100644
index 00000000000..f7e94e79f0b
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.util.Objects;
+
+/**
+ * {@link SoftReference} wrapper key for entries in the backing map.
+ *
+ * @param <T> key type
+ *
+ * @since 21
+ */
+final class SoftReferenceKey<T> extends SoftReference<T> implements ReferenceKey<T> {
+    /**
+     * Saved hashcode of the key. Used when {@link SoftReference} is
+     * null.
+     */
+    private final int hashcode;
+
+    /**
+     * Package-Protected constructor.
+     *
+     * @param key   unwrapped key value
+     * @param queue reference queue
+     */
+    SoftReferenceKey(T key, ReferenceQueue<T> queue) {
+        super(key, queue);
+        this.hashcode = Objects.hashCode(key);
+    }
+
+    /**
+     * Cleanup unused key. No need to enqueue since the key did not make it
+     * into the map.
+     */
+    @Override
+    public void unused() {
+        clear();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        // Necessary when removing a null reference
+        if (obj == this) {
+            return true;
+        }
+        // Necessary when comparing an unwrapped key
+        if (obj instanceof ReferenceKey<?> key) {
+            obj = key.get();
+        }
+        // Note: refersTo is insufficient since keys require equivalence.
+        // refersTo would also require a cast to type T.
+        return Objects.equals(get(), obj);
+    }
+
+    @Override
+    public int hashCode() {
+        // Use saved hashcode
+        return hashcode;
+    }
+
+    @Override
+    public String toString() {
+        return this.getClass().getCanonicalName() + "#" + System.identityHashCode(this);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java b/ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java
new file mode 100644
index 00000000000..2da0ed97be1
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.util.Objects;
+
+/**
+ * Wrapper for querying the backing map. Avoids the overhead of an
+ * {@link java.lang.ref.Reference} object.
+ *
+ * @param <T> key type
+ *
+ * @since 21
+ */
+final class StrongReferenceKey<T> implements ReferenceKey<T> {
+    T key;
+
+    /**
+     * Package-Protected constructor.
+     *
+     * @param key unwrapped key value
+     */
+    StrongReferenceKey(T key) {
+        // Android-changed: Some ReferencedKeyMap methods check key for nullness (get, put,
+        // containsKey), but others (putIfAbsent) don't. Adding null check here with assumption
+        // that absence of null checks in ReferencedKeyMap was just overlooked.
+        // this.key = key;
+        this.key = Objects.requireNonNull(key);
+    }
+
+    /**
+     * {@return the unwrapped key}
+     */
+    @Override
+    public T get() {
+        return key;
+    }
+
+    @Override
+    public void unused() {
+        key = null;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        // Necessary when comparing an unwrapped key
+        if (obj instanceof ReferenceKey<?> key) {
+            obj = key.get();
+        }
+        return Objects.equals(get(), obj);
+    }
+
+    @Override
+    public int hashCode() {
+        // Use unwrapped key hash code
+        // Android-changed: throw NPE explicitly. After unused() call this object should not be used
+        // return get().hashCode();
+        T nonNullKey = Objects.requireNonNull(get());
+        return nonNullKey.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return this.getClass().getCanonicalName() + "#" + System.identityHashCode(this);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java b/ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java
new file mode 100644
index 00000000000..3fe6d6026d7
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.util;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.Objects;
+
+/**
+ * {@link WeakReference} wrapper key for entries in the backing map.
+ *
+ * @param <T> key type
+ *
+ * @since 21
+ */
+final class WeakReferenceKey<T> extends WeakReference<T> implements ReferenceKey<T> {
+    /**
+     * Saved hashcode of the key. Used when {@link WeakReference} is
+     * null.
+     */
+    private final int hashcode;
+
+    /**
+     * Package-Protected constructor.
+     *
+     * @param key   unwrapped key value
+     * @param queue reference queue
+     */
+    WeakReferenceKey(T key, ReferenceQueue<T> queue) {
+        super(key, queue);
+        this.hashcode = Objects.hashCode(key);
+    }
+
+    /**
+     * Cleanup unused key. No need to enqueue since the key did not make it
+     * into the map.
+     */
+    @Override
+    public void unused() {
+        clear();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        // Necessary when removing a null reference
+        if (obj == this) {
+            return true;
+        }
+        // Necessary when comparing an unwrapped key
+        if (obj instanceof ReferenceKey<?> key) {
+            obj = key.get();
+        }
+        // Note: refersTo is insufficient since keys require equivalence.
+        // refersTo would also require a cast to type T.
+        return Objects.equals(get(), obj);
+    }
+
+    @Override
+    public int hashCode() {
+        // Use saved hashcode
+        return hashcode;
+    }
+
+    @Override
+    public String toString() {
+        return this.getClass().getCanonicalName() + "#" + System.identityHashCode(this);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/StackChunk.java b/ojluni/src/main/java/jdk/internal/vm/StackChunk.java
new file mode 100644
index 00000000000..0c48ce67934
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/StackChunk.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2019, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.vm;
+
+public final class StackChunk {
+    public static void init() {}
+
+    private StackChunk parent;
+    private int size;    // in words
+    private int sp;      // in words
+    private int argsize; // bottom stack-passed arguments, in words
+
+    // The stack itself is appended here by the VM, as well as some injected fields
+
+    public StackChunk parent() { return parent; }
+    public boolean isEmpty()   { return sp >= (size - argsize); }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java b/ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java
new file mode 100644
index 00000000000..b5fdd0c0082
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.vm.annotation;
+
+import java.lang.annotation.*;
+
+/**
+ * A method or constructor may be annotated as "force inline" if the standard
+ * inlining metrics are to be ignored when the HotSpot VM inlines the method
+ * or constructor.
+ * <p>
+ * This annotation must be used sparingly.  It is useful when the only
+ * reasonable alternative is to bind the name of a specific method or
+ * constructor into the HotSpot VM for special handling by the inlining policy.
+ * This annotation must not be relied on as an alternative to avoid tuning the
+ * VM's inlining policy.  In a few cases, it may act as a temporary workaround
+ * until the profiling and inlining performed by the HotSpot VM is sufficiently
+ * improved.
+ *
+ * @implNote
+ * This annotation only takes effect for methods or constructors of classes
+ * loaded by the boot loader.  Annotations on methods or constructors of classes
+ * loaded outside of the boot loader are ignored.
+ */
+@Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
+// Android-changed: not used at runtime.
+// @Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.SOURCE)
+public @interface ForceInline {
+}
diff --git a/ojluni/src/main/java/sun/invoke/util/TEST_MAPPING b/ojluni/src/main/java/sun/invoke/util/TEST_MAPPING
index 48ae161c6c8..c3944ab9516 100644
--- a/ojluni/src/main/java/sun/invoke/util/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/invoke/util/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.invoke.util"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_invoke_util"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/misc/TEST_MAPPING b/ojluni/src/main/java/sun/misc/TEST_MAPPING
index f0d2cec4429..8988d02d5a6 100644
--- a/ojluni/src/main/java/sun/misc/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/misc/TEST_MAPPING
@@ -1,15 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "org.apache.harmony.tests.org.apache.harmony.kernel.dalvik"
-        },
-        {
-          "include-filter": "libcore.sun.misc"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_misc"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/net/util/TEST_MAPPING b/ojluni/src/main/java/sun/net/util/TEST_MAPPING
index 068b5da6b0a..18c681168f4 100644
--- a/ojluni/src/main/java/sun/net/util/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/net/util/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.net.util"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_net_util"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/security/jca/TEST_MAPPING b/ojluni/src/main/java/sun/security/jca/TEST_MAPPING
index 02e5a749825..3560857dddd 100644
--- a/ojluni/src/main/java/sun/security/jca/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/security/jca/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.security.jca"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_security_jca"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/security/pkcs/TEST_MAPPING b/ojluni/src/main/java/sun/security/pkcs/TEST_MAPPING
index 3f37df7409a..c115a75c0d8 100644
--- a/ojluni/src/main/java/sun/security/pkcs/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/security/pkcs/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.security.pkcs"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_security_pkcs"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/security/x509/TEST_MAPPING b/ojluni/src/main/java/sun/security/x509/TEST_MAPPING
index 92012a6e6f8..894088daef9 100644
--- a/ojluni/src/main/java/sun/security/x509/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/security/x509/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.security.x509"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_security_x509"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/java/sun/util/locale/BaseLocale.java b/ojluni/src/main/java/sun/util/locale/BaseLocale.java
index 4da0a08647d..08cd7887469 100644
--- a/ojluni/src/main/java/sun/util/locale/BaseLocale.java
+++ b/ojluni/src/main/java/sun/util/locale/BaseLocale.java
@@ -118,7 +118,7 @@ public final class BaseLocale {
 
     private static boolean useOldIsoCodes() {
         return !(VMRuntime.getSdkVersion() >= VersionCodes.VANILLA_ICE_CREAM &&
-                Compatibility.isChangeEnabled(USE_NEW_ISO_LOCALE_CODES));
+                VMRuntime.getRuntime().getTargetSdkVersion() >= VersionCodes.VANILLA_ICE_CREAM);
     }
     // END Android-added: flag to control Locale behaviour with legacy locales.
 
diff --git a/ojluni/src/main/java/sun/util/logging/TEST_MAPPING b/ojluni/src/main/java/sun/util/logging/TEST_MAPPING
index e3bb92a2395..244da052926 100644
--- a/ojluni/src/main/java/sun/util/logging/TEST_MAPPING
+++ b/ojluni/src/main/java/sun/util/logging/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.sun.util.logging"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_sun_util_logging"
     }
   ]
 }
\ No newline at end of file
diff --git a/ojluni/src/main/native/Android.bp b/ojluni/src/main/native/Android.bp
index ea47f190746..1196f285139 100644
--- a/ojluni/src/main/native/Android.bp
+++ b/ojluni/src/main/native/Android.bp
@@ -25,12 +25,10 @@ filegroup {
         "//libcore",
     ],
     srcs: [
-        "ZipFile.c",
         "Inflater.c",
         "Deflater.c",
         "CRC32.c",
         "Adler32.c",
-        "zip_util.c",
         "jni_util.c",
         "jni_util_md.c",
         "io_util.c",
diff --git a/ojluni/src/main/native/OnLoad.cpp b/ojluni/src/main/native/OnLoad.cpp
index dd60a74a1a5..a1e95fd7b0f 100644
--- a/ojluni/src/main/native/OnLoad.cpp
+++ b/ojluni/src/main/native/OnLoad.cpp
@@ -22,7 +22,6 @@
 #include <jni.h>
 #include <android-base/logging.h>
 
-extern "C" void register_java_util_zip_ZipFile(JNIEnv* env);
 extern "C" void register_java_util_zip_Inflater(JNIEnv* env);
 extern "C" void register_java_util_zip_Deflater(JNIEnv* env);
 extern "C" void register_java_io_FileDescriptor(JNIEnv* env);
@@ -93,7 +92,6 @@ extern "C" JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void*) {
   register_java_lang_System(env);
 
   // Initialize the rest in the order in which they appear in Android.bp .
-  register_java_util_zip_ZipFile(env);
   register_java_util_zip_Inflater(env);
   register_java_util_zip_Deflater(env);
   register_java_io_FileDescriptor(env);
diff --git a/ojluni/src/main/native/StrictMath.c b/ojluni/src/main/native/StrictMath.c
index 7f9bbebcdf7..eb68a9e50ba 100644
--- a/ojluni/src/main/native/StrictMath.c
+++ b/ojluni/src/main/native/StrictMath.c
@@ -33,111 +33,109 @@
 
 
 JNIEXPORT jdouble JNICALL
-StrictMath_cos(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_cos(jdouble d)
 {
     return (jdouble) ieee_cos((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_sin(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_sin(jdouble d)
 {
     return (jdouble) ieee_sin((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_tan(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_tan(jdouble d)
 {
     return (jdouble) ieee_tan((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_asin(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_asin(jdouble d)
 {
     return (jdouble) ieee_asin((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_acos(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_acos(jdouble d)
 {
     return (jdouble) ieee_acos((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_atan(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_atan(jdouble d)
 {
     return (jdouble) ieee_atan((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_exp(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_exp(jdouble d)
 {
     return (jdouble) ieee_exp((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_log(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_log(jdouble d)
 {
     return (jdouble) ieee_log((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_log10(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_log10(jdouble d)
 {
     return (jdouble) ieee_log10((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_sqrt(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_sqrt(jdouble d)
 {
     return (jdouble) ieee_sqrt((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_cbrt(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_cbrt(jdouble d)
 {
     return (jdouble) ieee_cbrt((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_atan2(JNIEnv *env, jclass unused, jdouble d1, jdouble d2)
+StrictMath_atan2(jdouble d1, jdouble d2)
 {
     return (jdouble) ieee_atan2((double)d1, (double)d2);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_pow(JNIEnv *env, jclass unused, jdouble d1, jdouble d2)
+StrictMath_pow(jdouble d1, jdouble d2)
 {
     return (jdouble) ieee_pow((double)d1, (double)d2);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_IEEEremainder(JNIEnv *env, jclass unused,
-                                  jdouble dividend,
-                                  jdouble divisor)
+StrictMath_IEEEremainder(jdouble dividend, jdouble divisor)
 {
     return (jdouble) ieee_remainder(dividend, divisor);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_cosh(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_cosh(jdouble d)
 {
     return (jdouble) ieee_cosh((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_sinh(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_sinh(jdouble d)
 {
     return (jdouble) ieee_sinh((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_tanh(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_tanh(jdouble d)
 {
     return (jdouble) ieee_tanh((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_hypot(JNIEnv *env, jclass unused, jdouble x, jdouble y)
+StrictMath_hypot(jdouble x, jdouble y)
 {
     return (jdouble) ieee_hypot((double)x, (double)y);
 }
@@ -145,13 +143,13 @@ StrictMath_hypot(JNIEnv *env, jclass unused, jdouble x, jdouble y)
 
 
 JNIEXPORT jdouble JNICALL
-StrictMath_log1p(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_log1p(jdouble d)
 {
     return (jdouble) ieee_log1p((double)d);
 }
 
 JNIEXPORT jdouble JNICALL
-StrictMath_expm1(JNIEnv *env, jclass unused, jdouble d)
+StrictMath_expm1(jdouble d)
 {
     return (jdouble) ieee_expm1((double)d);
 }
diff --git a/ojluni/src/main/native/ZipFile.c b/ojluni/src/main/native/ZipFile.c
deleted file mode 100644
index fcdd41c7c65..00000000000
--- a/ojluni/src/main/native/ZipFile.c
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
- * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Native method support for java.util.zip.ZipFile
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <ctype.h>
-#include <assert.h>
-#include <nativehelper/JNIHelp.h>
-#include "jlong.h"
-#include "jvm.h"
-#include "jni.h"
-#include "jni_util.h"
-#include "zip_util.h"
-#ifdef WIN32
-#include "io_util_md.h"
-#else
-#include "io_util.h"
-#endif
-
-#include "java_util_zip_ZipFile.h"
-
-#define NATIVE_METHOD(className, functionName, signature) \
-{ #functionName, signature, (void*)(className ## _ ## functionName) }
-
-#define DEFLATED 8
-#define STORED 0
-
-static jfieldID jzfileID;
-jmethodID jzOnZipEntryAccessID;
-
-static int OPEN_READ = java_util_zip_ZipFile_OPEN_READ;
-static int OPEN_DELETE = java_util_zip_ZipFile_OPEN_DELETE;
-
-static void
-ThrowZipException(JNIEnv *env, const char *msg)
-{
-    jstring s = NULL;
-    jobject x;
-
-    if (msg != NULL) {
-        s = JNU_NewStringPlatform(env, msg);
-    }
-    x = JNU_NewObjectByName(env,
-                            "java/util/zip/ZipException",
-                            "(Ljava/lang/String;)V", s);
-    if (x != NULL) {
-        (*env)->Throw(env, x);
-    }
-}
-
-JNIEXPORT jlong JNICALL
-// Android changed: Changed to non-static java method.
-ZipFile_open(JNIEnv *env, jobject thiz, jstring name,
-                                        jint mode, jlong lastModified,
-                                        jboolean usemmap)
-{
-    const char *path = JNU_GetStringPlatformChars(env, name, 0);
-    char *msg = 0;
-    jlong result = 0;
-    int flag = 0;
-    jzfile *zip = 0;
-
-    if (mode & OPEN_READ) flag |= O_RDONLY;
-    // Android changed, JVM_O_DELETE/unlink is problematic, see b/28901232.
-    //if (mode & OPEN_DELETE) flag |= JVM_O_DELETE;
-
-    if (path != 0) {
-        zip = ZIP_Get_From_Cache(path, &msg, lastModified);
-        if (zip == 0 && msg == 0) {
-            ZFILE zfd = 0;
-#ifdef WIN32
-            zfd = winFileHandleOpen(env, name, flag);
-            if (zfd == -1) {
-                /* Exception already pending. */
-                goto finally;
-            }
-#else
-            zfd = JVM_Open(path, flag, 0);
-            if (zfd < 0) {
-                throwFileNotFoundException(env, name);
-                goto finally;
-            }
-#endif
-            // Android changed: Pass jni env and thiz object into the method.
-            zip = ZIP_Put_In_Cache0(env, thiz, path, zfd, &msg, lastModified, usemmap);
-        }
-
-        if (zip != 0) {
-            result = ptr_to_jlong(zip);
-        } else if (msg != 0) {
-            ThrowZipException(env, msg);
-            free(msg);
-        } else if (errno == ENOMEM) {
-            JNU_ThrowOutOfMemoryError(env, 0);
-        } else {
-            ThrowZipException(env, "error in opening zip file");
-        }
-finally:
-        JNU_ReleaseStringPlatformChars(env, name, path);
-    }
-    return result;
-}
-
-JNIEXPORT jint JNICALL
-ZipFile_getTotal(JNIEnv *env, jclass cls, jlong zfile)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-
-    return zip->total;
-}
-
-JNIEXPORT jboolean JNICALL
-ZipFile_startsWithLOC(JNIEnv *env, jclass cls, jlong zfile)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-
-    return zip->locsig;
-}
-
-JNIEXPORT void JNICALL
-ZipFile_close(JNIEnv *env, jclass cls, jlong zfile)
-{
-    ZIP_Close(jlong_to_ptr(zfile));
-}
-
-JNIEXPORT jint JNICALL
-ZipFile_getFileDescriptor(JNIEnv *env, jclass cls, jlong zfile) {
-    jzfile *zip = jlong_to_ptr(zfile);
-    return zip->zfd;
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getEntry(JNIEnv *env, jclass cls, jlong zfile,
-                 jbyteArray name, jboolean addSlash)
-{
-#define MAXNAME 1024
-    jzfile *zip = jlong_to_ptr(zfile);
-    jsize ulen = (*env)->GetArrayLength(env, name);
-    char buf[MAXNAME+2], *path;
-    jzentry *ze;
-
-    if (ulen > MAXNAME) {
-        path = malloc(ulen + 2);
-        if (path == 0) {
-            JNU_ThrowOutOfMemoryError(env, 0);
-            return 0;
-        }
-    } else {
-        path = buf;
-    }
-    (*env)->GetByteArrayRegion(env, name, 0, ulen, (jbyte *)path);
-    path[ulen] = '\0';
-    ze = ZIP_GetEntry2(zip, path, (jint)ulen, addSlash);
-    if (path != buf) {
-        free(path);
-    }
-    return ptr_to_jlong(ze);
-}
-
-JNIEXPORT void JNICALL
-ZipFile_freeEntry(JNIEnv *env, jclass cls, jlong zfile,
-                                    jlong zentry)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-    jzentry *ze = jlong_to_ptr(zentry);
-    ZIP_FreeEntry(zip, ze);
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getNextEntry(JNIEnv *env, jclass cls, jlong zfile,
-                                        jint n)
-{
-    jzentry *ze = ZIP_GetNextEntry(jlong_to_ptr(zfile), n);
-    return ptr_to_jlong(ze);
-}
-
-JNIEXPORT jint JNICALL
-ZipFile_getEntryMethod(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return ze->csize != 0 ? DEFLATED : STORED;
-}
-
-JNIEXPORT jint JNICALL
-ZipFile_getEntryFlag(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return ze->flag;
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getEntryCSize(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return ze->csize != 0 ? ze->csize : ze->size;
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getEntrySize(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return ze->size;
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getEntryTime(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return (jlong)ze->time & 0xffffffffUL;
-}
-
-JNIEXPORT jlong JNICALL
-ZipFile_getEntryCrc(JNIEnv *env, jclass cls, jlong zentry)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    return (jlong)ze->crc & 0xffffffffUL;
-}
-
-JNIEXPORT jbyteArray JNICALL
-ZipFile_getCommentBytes(JNIEnv *env, jclass cls, jlong zfile)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-    jbyteArray jba = NULL;
-
-    if (zip->comment != NULL) {
-        if ((jba = (*env)->NewByteArray(env, zip->clen)) == NULL)
-            return NULL;
-        (*env)->SetByteArrayRegion(env, jba, 0, zip->clen, (jbyte*)zip->comment);
-    }
-    return jba;
-}
-
-JNIEXPORT jbyteArray JNICALL
-ZipFile_getEntryBytes(JNIEnv *env, jclass cls, jlong zentry, jint type)
-{
-    jzentry *ze = jlong_to_ptr(zentry);
-    int len = 0;
-    jbyteArray jba = NULL;
-    switch (type) {
-    case java_util_zip_ZipFile_JZENTRY_NAME:
-        if (ze->name != 0) {
-            len = (int)ze->nlen;
-            if (len == 0 || (jba = (*env)->NewByteArray(env, len)) == NULL)
-                break;
-            (*env)->SetByteArrayRegion(env, jba, 0, len, (jbyte *)ze->name);
-        }
-        break;
-    case java_util_zip_ZipFile_JZENTRY_EXTRA:
-        if (ze->extra != 0) {
-            unsigned char *bp = (unsigned char *)&ze->extra[0];
-            len = (bp[0] | (bp[1] << 8));
-            if (len <= 0 || (jba = (*env)->NewByteArray(env, len)) == NULL)
-                break;
-            (*env)->SetByteArrayRegion(env, jba, 0, len, &ze->extra[2]);
-        }
-        break;
-    case java_util_zip_ZipFile_JZENTRY_COMMENT:
-        if (ze->comment != 0) {
-            len = (int)strlen(ze->comment);
-            if (len == 0 || (jba = (*env)->NewByteArray(env, len)) == NULL)
-                break;
-            (*env)->SetByteArrayRegion(env, jba, 0, len, (jbyte*)ze->comment);
-        }
-        break;
-    }
-    return jba;
-}
-
-JNIEXPORT jint JNICALL
-ZipFile_read(JNIEnv *env, jclass cls, jlong zfile,
-             jlong zentry, jlong pos, jbyteArray bytes,
-             jint off, jint len)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-    char *msg;
-
-    // BEGIN Android-changed: Removed tmp stack buffer.
-    long long length = (long long)(*env)->GetArrayLength(env, bytes);
-    if (off < 0 || len < 0 || off + len > length) {
-        char errmsg[128];
-        snprintf(errmsg, sizeof(errmsg), "len: %d, off: %d are not valid for array sized %lld\n",
-                 len, off, length);
-        JNU_ThrowArrayIndexOutOfBoundsException(env, errmsg);
-        return -1;
-    }
-
-    jbyte *buf = (*env)->GetByteArrayElements(env, bytes, NULL);
-    ZIP_Lock(zip);
-    len = ZIP_Read(zip, jlong_to_ptr(zentry), pos, buf + off, len);
-    msg = zip->msg;
-    ZIP_Unlock(zip);
-    (*env)->ReleaseByteArrayElements(env, bytes, buf, 0);
-
-    if (len == -1) {
-        if (msg != 0) {
-            ThrowZipException(env, msg);
-        } else {
-            char errmsg[128];
-            snprintf(errmsg, sizeof(errmsg), "errno: %d, error: %s\n", errno,
-                     "Error reading ZIP file");
-            JNU_ThrowIOExceptionWithLastError(env, errmsg);
-        }
-    }
-    // END Android-changed: Removed tmp stack buffer.
-
-    return len;
-}
-
-JNIEXPORT jstring JNICALL
-ZipFile_getZipMessage(JNIEnv *env, jclass cls, jlong zfile)
-{
-    jzfile *zip = jlong_to_ptr(zfile);
-    char *msg = zip->msg;
-    if (msg == NULL) {
-        return NULL;
-    }
-    return JNU_NewStringPlatform(env, msg);
-}
-
-JNIEXPORT jobjectArray JNICALL
-JarFile_getMetaInfEntryNames(JNIEnv *env, jobject obj)
-{
-    jlong zfile = (*env)->GetLongField(env, obj, jzfileID);
-    jzfile *zip;
-    int i, count;
-    jobjectArray result = 0;
-
-    if (zfile == 0) {
-        JNU_ThrowByName(env,
-                        "java/lang/IllegalStateException", "zip file closed");
-        return NULL;
-    }
-    zip = jlong_to_ptr(zfile);
-
-    /* count the number of valid ZIP metanames */
-    count = 0;
-    if (zip->metanames != 0) {
-        for (i = 0; i < zip->metacount; i++) {
-            if (zip->metanames[i] != 0) {
-                count++;
-            }
-        }
-    }
-
-    /* If some names were found then build array of java strings */
-    if (count > 0) {
-        jclass cls = (*env)->FindClass(env, "java/lang/String");
-        result = (*env)->NewObjectArray(env, count, cls, 0);
-        if (result != 0) {
-            for (i = 0; i < count; i++) {
-                jstring str = (*env)->NewStringUTF(env, zip->metanames[i]);
-                if (str == 0) {
-                    break;
-                }
-                (*env)->SetObjectArrayElement(env, result, i, str);
-                (*env)->DeleteLocalRef(env, str);
-            }
-        }
-    }
-    return result;
-}
-
-static JNINativeMethod gMethods[] = {
-  NATIVE_METHOD(ZipFile, getFileDescriptor, "(J)I"),
-  NATIVE_METHOD(ZipFile, getEntry, "(J[BZ)J"),
-  NATIVE_METHOD(ZipFile, freeEntry, "(JJ)V"),
-  NATIVE_METHOD(ZipFile, getNextEntry, "(JI)J"),
-  NATIVE_METHOD(ZipFile, close, "(J)V"),
-  NATIVE_METHOD(ZipFile, open, "(Ljava/lang/String;IJZ)J"),
-  NATIVE_METHOD(ZipFile, getTotal, "(J)I"),
-  NATIVE_METHOD(ZipFile, startsWithLOC, "(J)Z"),
-  NATIVE_METHOD(ZipFile, read, "(JJJ[BII)I"),
-  NATIVE_METHOD(ZipFile, getEntryTime, "(J)J"),
-  NATIVE_METHOD(ZipFile, getEntryCrc, "(J)J"),
-  NATIVE_METHOD(ZipFile, getEntryCSize, "(J)J"),
-  NATIVE_METHOD(ZipFile, getEntrySize, "(J)J"),
-  NATIVE_METHOD(ZipFile, getEntryMethod, "(J)I"),
-  NATIVE_METHOD(ZipFile, getEntryFlag, "(J)I"),
-  NATIVE_METHOD(ZipFile, getCommentBytes, "(J)[B"),
-  NATIVE_METHOD(ZipFile, getEntryBytes, "(JI)[B"),
-  NATIVE_METHOD(ZipFile, getZipMessage, "(J)Ljava/lang/String;"),
-};
-
-static JNINativeMethod gJarFileMethods[] = {
-  NATIVE_METHOD(JarFile, getMetaInfEntryNames, "()[Ljava/lang/String;"),
-};
-
-void register_java_util_zip_ZipFile(JNIEnv* env) {}
diff --git a/ojluni/src/main/native/zip_util.c b/ojluni/src/main/native/zip_util.c
deleted file mode 100644
index 2b63d6bfd9a..00000000000
--- a/ojluni/src/main/native/zip_util.c
+++ /dev/null
@@ -1,1818 +0,0 @@
-/*
- * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Support for reading ZIP/JAR files.
- */
-
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <string.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <time.h>
-#include <ctype.h>
-#include <assert.h>
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jlong.h"
-#include "jvm.h"
-#include "io_util.h"
-#include "io_util_md.h"
-#include "zip_util.h"
-#include <zlib.h>
-
-extern jmethodID jzOnZipEntryAccessID;
-
-// Android-changed: Fuchsia: Alias *64 on Fuchsia builds. http://b/119496969
-// #ifdef _ALLBSD_SOURCE
-#if defined(_ALLBSD_SOURCE) || defined(__Fuchsia__)
-#define off64_t off_t
-#define mmap64 mmap
-#endif
-
-/* USE_MMAP means mmap the CEN & ENDHDR part of the zip file. */
-#ifdef USE_MMAP
-#include <sys/mman.h>
-#endif
-
-#define MAXREFS 0xFFFF  /* max number of open zip file references */
-
-#define MCREATE()      JVM_RawMonitorCreate()
-#define MLOCK(lock)    JVM_RawMonitorEnter(lock)
-#define MUNLOCK(lock)  JVM_RawMonitorExit(lock)
-#define MDESTROY(lock) JVM_RawMonitorDestroy(lock)
-
-#define CENSIZE(cen) (CENHDR + CENNAM(cen) + CENEXT(cen) + CENCOM(cen))
-
-static jzfile *zfiles = 0;      /* currently open zip files */
-static void *zfiles_lock = 0;
-
-static void freeCEN(jzfile *);
-
-#ifndef PATH_MAX
-#define PATH_MAX 1024
-#endif
-
-static jint INITIAL_META_COUNT = 2;   /* initial number of entries in meta name array */
-
-/*
- * Declare library specific JNI_Onload entry if static build
- */
-#ifdef STATIC_BUILD
-DEF_STATIC_JNI_OnLoad
-#endif
-
-/*
- * The ZFILE_* functions exist to provide some platform-independence with
- * respect to file access needs.
- */
-
-/*
- * Opens the named file for reading, returning a ZFILE.
- *
- * Compare this with winFileHandleOpen in windows/native/java/io/io_util_md.c.
- * This function does not take JNIEnv* and uses CreateFile (instead of
- * CreateFileW).  The expectation is that this function will be called only
- * from ZIP_Open_Generic, which in turn is used by the JVM, where we do not
- * need to concern ourselves with wide chars.
- */
-static ZFILE
-ZFILE_Open(const char *fname, int flags) {
-#ifdef WIN32
-    WCHAR *wfname, *wprefixed_fname;
-    size_t fname_length;
-    jlong fhandle;
-    const DWORD access =
-        (flags & O_RDWR)   ? (GENERIC_WRITE | GENERIC_READ) :
-        (flags & O_WRONLY) ?  GENERIC_WRITE :
-        GENERIC_READ;
-    const DWORD sharing =
-        FILE_SHARE_READ | FILE_SHARE_WRITE;
-    const DWORD disposition =
-        /* Note: O_TRUNC overrides O_CREAT */
-        (flags & O_TRUNC) ? CREATE_ALWAYS :
-        (flags & O_CREAT) ? OPEN_ALWAYS   :
-        OPEN_EXISTING;
-    const DWORD  maybeWriteThrough =
-        (flags & (O_SYNC | O_DSYNC)) ?
-        FILE_FLAG_WRITE_THROUGH :
-        FILE_ATTRIBUTE_NORMAL;
-    const DWORD maybeDeleteOnClose =
-        (flags & O_TEMPORARY) ?
-        FILE_FLAG_DELETE_ON_CLOSE :
-        FILE_ATTRIBUTE_NORMAL;
-    const DWORD flagsAndAttributes = maybeWriteThrough | maybeDeleteOnClose;
-
-    fname_length = strlen(fname);
-    if (fname_length < MAX_PATH) {
-        return (jlong)CreateFile(
-            fname,              /* path name in multibyte char */
-            access,             /* Read and/or write permission */
-            sharing,            /* File sharing flags */
-            NULL,               /* Security attributes */
-            disposition,        /* creation disposition */
-            flagsAndAttributes, /* flags and attributes */
-            NULL);
-    } else {
-        /* Get required buffer size to convert to Unicode */
-        int wfname_len = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
-                                             fname, -1, NULL, 0);
-        if (wfname_len == 0) {
-            return (jlong)INVALID_HANDLE_VALUE;
-        }
-        if ((wfname = (WCHAR*)malloc(wfname_len * sizeof(WCHAR))) == NULL) {
-            return (jlong)INVALID_HANDLE_VALUE;
-        }
-        if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
-                                fname, -1, wfname, wfname_len) == 0) {
-            free(wfname);
-            return (jlong)INVALID_HANDLE_VALUE;
-        }
-        wprefixed_fname = getPrefixed(wfname, (int)fname_length);
-        fhandle = (jlong)CreateFileW(
-            wprefixed_fname,    /* Wide char path name */
-            access,             /* Read and/or write permission */
-            sharing,            /* File sharing flags */
-            NULL,               /* Security attributes */
-            disposition,        /* creation disposition */
-            flagsAndAttributes, /* flags and attributes */
-            NULL);
-        free(wfname);
-        free(wprefixed_fname);
-        return fhandle;
-    }
-#else
-    return open(fname, flags, 0);
-#endif
-}
-
-/*
- * The io_util_md.h files do not provide IO_CLOSE, hence we use platform
- * specifics.
- */
-static void
-ZFILE_Close(ZFILE zfd) {
-#ifdef WIN32
-    CloseHandle((HANDLE) zfd);
-#else
-    close(zfd);
-#endif
-}
-
-// Android-changed: also pass offset and use pread instead of read
-// syscall. The former does not change file offset. See b/30407219.
-static int
-ZFILE_read(ZFILE zfd, char *buf, jint nbytes, jlong offset) {
-#ifdef WIN32
-    return (int) IO_Read(zfd, buf, nbytes);
-#else
-    // return read(zfd, buf, nbytes);
-    return pread64(zfd, buf, nbytes, offset);
-#endif
-}
-
-/*
- * Initialize zip file support. Return 0 if successful otherwise -1
- * if could not be initialized.
- */
-static jint
-InitializeZip()
-{
-    static jboolean inited = JNI_FALSE;
-
-    // Initialize errno to 0.  It may be set later (e.g. during memory
-    // allocation) but we can disregard previous values.
-    errno = 0;
-
-    if (inited)
-        return 0;
-    zfiles_lock = MCREATE();
-    if (zfiles_lock == 0) {
-        return -1;
-    }
-    inited = JNI_TRUE;
-
-    return 0;
-}
-
-/*
- * Reads len bytes of data from the specified offset into buf.
- * Returns 0 if all bytes could be read, otherwise returns -1.
- */
-static int
-readFullyAt(ZFILE zfd, void *buf, jlong len, jlong offset) {
-  char *bp = (char *) buf;
-
-  while (len > 0) {
-        jlong limit = ((((jlong) 1) << 31) - 1);
-        jint count = (len < limit) ?
-            (jint) len :
-            (jint) limit;
-        jint n = ZFILE_read(zfd, bp, count, offset);
-        if (n > 0) {
-            bp += n;
-            offset += n;
-            len -= n;
-        } else if (n == -1 && errno == EINTR) {
-          /* Retry after EINTR (interrupted by signal). */
-            continue;
-        } else { /* EOF or IO error */
-            return -1;
-        }
-    }
-    return 0;
-}
-
-
-/*
- * Allocates a new zip file object for the specified file name.
- * Returns the zip file object or NULL if not enough memory.
- */
-static jzfile *
-allocZip(const char *name)
-{
-    jzfile *zip;
-    if (((zip = calloc(1, sizeof(jzfile))) != NULL) &&
-        ((zip->name = strdup(name))        != NULL) &&
-        ((zip->lock = MCREATE())           != NULL)) {
-        zip->zfd = -1;
-        return zip;
-    }
-
-    if (zip != NULL) {
-        free(zip->name);
-        free(zip);
-    }
-    return NULL;
-}
-
-/*
- * Frees all native resources owned by the specified zip file object.
- */
-static void
-freeZip(jzfile *zip)
-{
-    /* First free any cached jzentry */
-    ZIP_FreeEntry(zip,0);
-    if (zip->lock != NULL) MDESTROY(zip->lock);
-    free(zip->name);
-    freeCEN(zip);
-
-#ifdef USE_MMAP
-    if (zip->usemmap) {
-        if (zip->maddr != NULL)
-            munmap((char *)zip->maddr, zip->mlen);
-    } else
-#endif
-    {
-        free(zip->cencache.data);
-    }
-    if (zip->comment != NULL)
-        free(zip->comment);
-    if (zip->zfd != -1) ZFILE_Close(zip->zfd);
-    free(zip);
-}
-
-/* The END header is followed by a variable length comment of size < 64k. */
-static const jlong END_MAXLEN = 0xFFFF + ENDHDR;
-
-#define READBLOCKSZ 128
-
-static jboolean verifyEND(jzfile *zip, jlong endpos, char *endbuf) {
-    /* ENDSIG matched, however the size of file comment in it does not
-       match the real size. One "common" cause for this problem is some
-       "extra" bytes are padded at the end of the zipfile.
-       Let's do some extra verification, we don't care about the performance
-       in this situation.
-     */
-    jlong cenpos = endpos - ENDSIZ(endbuf);
-    jlong locpos = cenpos - ENDOFF(endbuf);
-    char buf[4];
-    return (cenpos >= 0 &&
-            locpos >= 0 &&
-            readFullyAt(zip->zfd, buf, sizeof(buf), cenpos) != -1 &&
-            CENSIG_AT(buf) &&
-            readFullyAt(zip->zfd, buf, sizeof(buf), locpos) != -1 &&
-            LOCSIG_AT(buf));
-}
-
-/*
- * Searches for end of central directory (END) header. The contents of
- * the END header will be read and placed in endbuf. Returns the file
- * position of the END header, otherwise returns -1 if the END header
- * was not found or an error occurred.
- */
-static jlong
-findEND(jzfile *zip, void *endbuf)
-{
-    char buf[READBLOCKSZ];
-    jlong pos;
-    const jlong len = zip->len;
-    const ZFILE zfd = zip->zfd;
-    const jlong minHDR = len - END_MAXLEN > 0 ? len - END_MAXLEN : 0;
-    // Android-changed: explicitly cast sizeof result to prevent sanitizer error.
-    const jlong minPos = minHDR - ((jlong)sizeof(buf)-ENDHDR);
-    jint clen;
-
-    for (pos = len - sizeof(buf); pos >= minPos; pos -= (sizeof(buf)-ENDHDR)) {
-
-        int i;
-        jlong off = 0;
-        if (pos < 0) {
-            /* Pretend there are some NUL bytes before start of file */
-            off = -pos;
-            memset(buf, '\0', (size_t)off);
-        }
-
-        if (readFullyAt(zfd, buf + off, sizeof(buf) - off,
-                        pos + off) == -1) {
-            return -1;  /* System error */
-        }
-
-        /* Now scan the block backwards for END header signature */
-        for (i = sizeof(buf) - ENDHDR; i >= 0; i--) {
-            if (buf[i+0] == 'P'    &&
-                buf[i+1] == 'K'    &&
-                buf[i+2] == '\005' &&
-                buf[i+3] == '\006' &&
-                ((pos + i + ENDHDR + ENDCOM(buf + i) == len)
-                 || verifyEND(zip, pos + i, buf + i))) {
-                /* Found END header */
-                memcpy(endbuf, buf + i, ENDHDR);
-
-                clen = ENDCOM(endbuf);
-                if (clen != 0) {
-                    zip->comment = malloc(clen + 1);
-                    if (zip->comment == NULL) {
-                        return -1;
-                    }
-                    if (readFullyAt(zfd, zip->comment, clen, pos + i + ENDHDR)
-                        == -1) {
-                        free(zip->comment);
-                        zip->comment = NULL;
-                        return -1;
-                    }
-                    zip->comment[clen] = '\0';
-                    zip->clen = clen;
-                }
-                return pos + i;
-            }
-        }
-    }
-
-    return -1; /* END header not found */
-}
-
-/*
- * Searches for the ZIP64 end of central directory (END) header. The
- * contents of the ZIP64 END header will be read and placed in end64buf.
- * Returns the file position of the ZIP64 END header, otherwise returns
- * -1 if the END header was not found or an error occurred.
- *
- * The ZIP format specifies the "position" of each related record as
- *   ...
- *   [central directory]
- *   [zip64 end of central directory record]
- *   [zip64 end of central directory locator]
- *   [end of central directory record]
- *
- * The offset of zip64 end locator can be calculated from endpos as
- * "endpos - ZIP64_LOCHDR".
- * The "offset" of zip64 end record is stored in zip64 end locator.
- */
-static jlong
-findEND64(jzfile *zip, void *end64buf, jlong endpos)
-{
-    char loc64[ZIP64_LOCHDR];
-    jlong end64pos;
-    if (readFullyAt(zip->zfd, loc64, ZIP64_LOCHDR, endpos - ZIP64_LOCHDR) == -1) {
-        return -1;    // end64 locator not found
-    }
-    end64pos = ZIP64_LOCOFF(loc64);
-    if (readFullyAt(zip->zfd, end64buf, ZIP64_ENDHDR, end64pos) == -1) {
-        return -1;    // end64 record not found
-    }
-    return end64pos;
-}
-
-// Android-changed: Commented-out an unused function
-/*
- * Returns a hash code value for a C-style NUL-terminated string.
- */
-// static unsigned int
-// hash(const char *s)
-// {
-//     int h = 0;
-//     while (*s != '\0')
-//         h = 31*h + *s++;
-//     return h;
-// }
-
-/*
- * Returns a hash code value for a string of a specified length.
- */
-static unsigned int
-hashN(const char *s, int length)
-{
-    int h = 0;
-    while (length-- > 0)
-        h = 31*h + *s++;
-    return h;
-}
-
-/*
- * Returns true if |s| is a valid zip entry name.
- */
-static bool isValidEntryName(const char *s, int length)
-{
-    while (length-- > 0) {
-       if (*s++ == 0) {
-           return false;
-       }
-    }
-
-    return true;
-}
-
-static unsigned int
-hash_append(unsigned int hash, char c)
-{
-    return ((int)hash)*31 + c;
-}
-
-/*
- * Returns true if the specified entry's name begins with the string
- * "META-INF/".
- */
-static int
-isMetaName(const char *name, int length)
-{
-    static const char kMetaInf[] = "META-INF/";
-    static const int kMetaInfLength = sizeof(kMetaInf) - 1;
-    const char *s;
-    if (length < kMetaInfLength) {
-        return 0;
-    }
-
-    return (strncmp(kMetaInf, name, kMetaInfLength) == 0) ? 1 : 0;
-}
-
-/*
- * Increases the capacity of zip->metanames.
- * Returns non-zero in case of allocation error.
- */
-static int
-growMetaNames(jzfile *zip)
-{
-    jint i;
-    /* double the meta names array */
-    const jint new_metacount = zip->metacount << 1;
-    zip->metanames =
-        realloc(zip->metanames, new_metacount * sizeof(zip->metanames[0]));
-    if (zip->metanames == NULL) return -1;
-    for (i = zip->metacount; i < new_metacount; i++)
-        zip->metanames[i] = NULL;
-    zip->metacurrent = zip->metacount;
-    zip->metacount = new_metacount;
-    return 0;
-}
-
-/*
- * Adds name to zip->metanames.
- * Returns non-zero in case of allocation error.
- */
-static int
-addMetaName(jzfile *zip, const char *name, int length)
-{
-    jint i;
-    if (zip->metanames == NULL) {
-      zip->metacount = INITIAL_META_COUNT;
-      zip->metanames = calloc(zip->metacount, sizeof(zip->metanames[0]));
-      if (zip->metanames == NULL) return -1;
-      zip->metacurrent = 0;
-    }
-
-    i = zip->metacurrent;
-
-    /* current meta name array isn't full yet. */
-    if (i < zip->metacount) {
-      zip->metanames[i] = (char *) malloc(length+1);
-      if (zip->metanames[i] == NULL) return -1;
-      memcpy(zip->metanames[i], name, length);
-      zip->metanames[i][length] = '\0';
-      zip->metacurrent++;
-      return 0;
-    }
-
-    /* No free entries in zip->metanames? */
-    if (growMetaNames(zip) != 0) return -1;
-    return addMetaName(zip, name, length);
-}
-
-static void
-freeMetaNames(jzfile *zip)
-{
-    if (zip->metanames) {
-        jint i;
-        for (i = 0; i < zip->metacount; i++)
-            free(zip->metanames[i]);
-        free(zip->metanames);
-        zip->metanames = NULL;
-    }
-}
-
-/* Free Zip data allocated by readCEN() */
-static void
-freeCEN(jzfile *zip)
-{
-    free(zip->entries); zip->entries = NULL;
-    free(zip->table);   zip->table   = NULL;
-    freeMetaNames(zip);
-}
-
-/*
- * Counts the number of CEN headers in a central directory extending
- * from BEG to END.  Might return a bogus answer if the zip file is
- * corrupt, but will not crash.
- */
-static jint
-countCENHeaders(unsigned char *beg, unsigned char *end)
-{
-    jint count = 0;
-    ptrdiff_t i;
-    for (i = 0; i + CENHDR <= end - beg; i += CENSIZE(beg + i))
-        count++;
-    return count;
-}
-
-#define ZIP_FORMAT_ERROR(message) \
-if (1) { zip->msg = message; goto Catch; } else ((void)0)
-
-// Android-added: Retrieve ZipFile's variable that determines if zip path validation is enabled.
-static jboolean isZipPathValidatorEnabled(JNIEnv *env, jobject thiz) {
-    jclass cls = (*env)->FindClass(env, "java/util/zip/ZipFile");
-    jfieldID fid = (*env)->GetFieldID(env, cls, "isZipPathValidatorEnabled", "Z");
-    return (*env)->GetBooleanField(env, thiz, fid);
-}
-
-/*
- * Reads zip file central directory. Returns the file position of first
- * CEN header, otherwise returns -1 if an error occurred. If zip->msg != NULL
- * then the error was a zip format error and zip->msg has the error text.
- * Always pass in -1 for knownTotal; it's used for a recursive call.
- */
-static jlong
-// Android changed: Pass jni env and thiz object into the method.
-readCEN(JNIEnv *env, jobject thiz, jzfile *zip, jint knownTotal)
-{
-    /* Following are unsigned 32-bit */
-    jlong endpos, end64pos, cenpos, cenlen, cenoff;
-    /* Following are unsigned 16-bit */
-    jint total, tablelen, i, j;
-    unsigned char *cenbuf = NULL;
-    unsigned char *cenend;
-    unsigned char *cp;
-#ifdef USE_MMAP
-    static jlong pagesize;
-    jlong offset;
-#endif
-    unsigned char endbuf[ENDHDR];
-    jint endhdrlen = ENDHDR;
-    jzcell *entries;
-    jint *table;
-
-    /* Clear previous zip error */
-    zip->msg = NULL;
-    /* Get position of END header */
-    if ((endpos = findEND(zip, endbuf)) == -1)
-        return -1; /* no END header or system error */
-
-    if (endpos == 0) return 0;  /* only END header present */
-
-    freeCEN(zip);
-   /* Get position and length of central directory */
-    cenlen = ENDSIZ(endbuf);
-    cenoff = ENDOFF(endbuf);
-    total  = ENDTOT(endbuf);
-    if (cenlen == ZIP64_MAGICVAL || cenoff == ZIP64_MAGICVAL ||
-        total == ZIP64_MAGICCOUNT) {
-        unsigned char end64buf[ZIP64_ENDHDR];
-        if ((end64pos = findEND64(zip, end64buf, endpos)) != -1) {
-            cenlen = ZIP64_ENDSIZ(end64buf);
-            cenoff = ZIP64_ENDOFF(end64buf);
-            total = (jint)ZIP64_ENDTOT(end64buf);
-            endpos = end64pos;
-            endhdrlen = ZIP64_ENDHDR;
-        }
-    }
-
-    if (cenlen > endpos) {
-        ZIP_FORMAT_ERROR("invalid END header (bad central directory size)");
-    }
-    cenpos = endpos - cenlen;
-
-    /* Get position of first local file (LOC) header, taking into
-     * account that there may be a stub prefixed to the zip file. */
-    zip->locpos = cenpos - cenoff;
-    if (zip->locpos < 0) {
-        ZIP_FORMAT_ERROR("invalid END header (bad central directory offset)");
-    }
-#ifdef USE_MMAP
-    if (zip->usemmap) {
-      /* On Solaris & Linux prior to JDK 6, we used to mmap the whole jar file to
-       * read the jar file contents. However, this greatly increased the perceived
-       * footprint numbers because the mmap'ed pages were adding into the totals shown
-       * by 'ps' and 'top'. We switched to mmaping only the central directory of jar
-       * file while calling 'read' to read the rest of jar file. Here are a list of
-       * reasons apart from above of why we are doing so:
-       * 1. Greatly reduces mmap overhead after startup complete;
-       * 2. Avoids dual path code maintainance;
-       * 3. Greatly reduces risk of address space (not virtual memory) exhaustion.
-       */
-        if (pagesize == 0) {
-            pagesize = (jlong)sysconf(_SC_PAGESIZE);
-            if (pagesize == 0) goto Catch;
-        }
-        if (cenpos > pagesize) {
-            offset = cenpos & ~(pagesize - 1);
-        } else {
-            offset = 0;
-        }
-        /* When we are not calling recursively, knownTotal is -1. */
-        if (knownTotal == -1) {
-            void* mappedAddr;
-            /* Mmap the CEN and END part only. We have to figure
-               out the page size in order to make offset to be multiples of
-               page size.
-            */
-            zip->mlen = cenpos - offset + cenlen + endhdrlen;
-            zip->offset = offset;
-            mappedAddr = mmap64(0, zip->mlen, PROT_READ, MAP_SHARED, zip->zfd, (off64_t) offset);
-            zip->maddr = (mappedAddr == (void*) MAP_FAILED) ? NULL :
-                (unsigned char*)mappedAddr;
-
-            if (zip->maddr == NULL) {
-                jio_fprintf(stderr, "mmap failed for CEN and END part of zip file\n");
-                goto Catch;
-            }
-        }
-        cenbuf = zip->maddr + cenpos - offset;
-    } else
-#endif
-    {
-        if ((cenbuf = malloc((size_t) cenlen)) == NULL ||
-            (readFullyAt(zip->zfd, cenbuf, cenlen, cenpos) == -1))
-        goto Catch;
-    }
-
-    cenend = cenbuf + cenlen;
-
-    /* Initialize zip file data structures based on the total number
-     * of central directory entries as stored in ENDTOT.  Since this
-     * is a 2-byte field, but we (and other zip implementations)
-     * support approx. 2**31 entries, we do not trust ENDTOT, but
-     * treat it only as a strong hint.  When we call ourselves
-     * recursively, knownTotal will have the "true" value.
-     *
-     * Keep this path alive even with the Zip64 END support added, just
-     * for zip files that have more than 0xffff entries but don't have
-     * the Zip64 enabled.
-     */
-    total = (knownTotal != -1) ? knownTotal : total;
-    entries  = zip->entries  = calloc(total, sizeof(entries[0]));
-    tablelen = zip->tablelen = ((total/2) | 1); // Odd -> fewer collisions
-    table    = zip->table    = malloc(tablelen * sizeof(table[0]));
-    /* According to ISO C it is perfectly legal for malloc to return zero
-     * if called with a zero argument. We check this for 'entries' but not
-     * for 'table' because 'tablelen' can't be zero (see computation above). */
-    if ((entries == NULL && total != 0) || table == NULL) goto Catch;
-    for (j = 0; j < tablelen; j++)
-        table[j] = ZIP_ENDCHAIN;
-    // Android-added: Retrieve ZipFile's variable that determines if zip path validation is enabled.
-    jboolean isZipFilePathValidatorEnabled = isZipPathValidatorEnabled(env, thiz);
-    /* Iterate through the entries in the central directory */
-    for (i = 0, cp = cenbuf; cp <= cenend - CENHDR; i++, cp += CENSIZE(cp)) {
-        /* Following are unsigned 16-bit */
-        // Android-changed: A new variable flag because its value is used more than once.
-        jint method, nlen, flag;
-        unsigned int hsh;
-
-        if (i >= total) {
-            /* This will only happen if the zip file has an incorrect
-             * ENDTOT field, which usually means it contains more than
-             * 65535 entries. */
-            // Android changed: Pass jni env and thiz object into the method.
-            cenpos = readCEN(env, thiz, zip, countCENHeaders(cenbuf, cenend));
-            goto Finally;
-        }
-
-        method = CENHOW(cp);
-        nlen   = CENNAM(cp);
-        // Android-added: A new variable flag because its value is used more than once.
-        flag   = CENFLG(cp);
-
-        if (!CENSIG_AT(cp)) {
-            ZIP_FORMAT_ERROR("invalid CEN header (bad signature)");
-        }
-        // Android-changed: Use of the flag variable instead of the direct call to CENFLG.
-        if (flag & 1) {
-            ZIP_FORMAT_ERROR("invalid CEN header (encrypted entry)");
-        }
-        if (method != STORED && method != DEFLATED) {
-            ZIP_FORMAT_ERROR("invalid CEN header (bad compression method)");
-        }
-        if (cp + CENHDR + nlen > cenend) {
-            ZIP_FORMAT_ERROR("invalid CEN header (bad header size)");
-        }
-
-        // BEGIN Android-changed: Use strict mode to validate zip entry name,
-        // and throw exception if policy throws exception.
-        const char* entryName = (const char *)cp + CENHDR;
-        if (!isValidEntryName(entryName, nlen)) {
-            ZIP_FORMAT_ERROR("invalid CEN header (invalid entry name)");
-        }
-        if (isZipFilePathValidatorEnabled &&
-            ZIP_OnZipEntryAccess(env, thiz, entryName, nlen, flag)) {
-            ZIP_FORMAT_ERROR("restricted zip entry name");
-        }
-        // END Android-changed: Use strict mode to validate zip entry name,
-        // and throw exception if policy throws exception.
-
-        /* if the entry is metadata add it to our metadata names */
-        if (isMetaName(entryName, nlen)) {
-            if (addMetaName(zip, (char *)cp+CENHDR, nlen) != 0) {
-                goto Catch;
-            }
-        }
-
-        /* Record the CEN offset and the name hash in our hash cell. */
-        entries[i].cenpos = cenpos + (cp - cenbuf);
-        entries[i].hash = hashN(entryName, nlen);
-        entries[i].next = ZIP_ENDCHAIN;
-
-        /* Add the entry to the hash table */
-        hsh = entries[i].hash % tablelen;
-
-        /* First check that there are no other entries that have the same name. */
-        int chain = table[hsh];
-        while (chain != ZIP_ENDCHAIN) {
-            const jzcell* cell = &entries[chain];
-            if (cell->hash == entries[i].hash) {
-                const char* cenStart = (const char *) cenbuf + cell->cenpos - cenpos;
-                if (CENNAM(cenStart) == nlen) {
-                    const char* chainName = cenStart + CENHDR;
-                    if (strncmp(entryName, chainName, nlen) == 0) {
-                        ZIP_FORMAT_ERROR("invalid CEN header (duplicate entry)");
-                    }
-                }
-            }
-
-            chain = cell->next;
-        }
-
-
-        entries[i].next = table[hsh];
-        table[hsh] = i;
-    }
-    if (cp != cenend) {
-        ZIP_FORMAT_ERROR("invalid CEN header (bad header size)");
-    }
-    zip->total = i;
-    goto Finally;
-
- Catch:
-    freeCEN(zip);
-    cenpos = -1;
-
- Finally:
-#ifdef USE_MMAP
-    if (!zip->usemmap)
-#endif
-        free(cenbuf);
-
-    return cenpos;
-}
-
-/*
- * Opens a zip file with the specified mode. Returns the jzfile object
- * or NULL if an error occurred. If a zip error occurred then *pmsg will
- * be set to the error message text if pmsg != 0. Otherwise, *pmsg will be
- * set to NULL. Caller is responsible to free the error message.
- */
-jzfile *
-// Android changed: Pass jni env and thiz object into the method.
-ZIP_Open_Generic(JNIEnv *env, jobject thiz, const char *name, char **pmsg, int mode, jlong lastModified)
-{
-    jzfile *zip = NULL;
-
-    /* Clear zip error message */
-    // BEGIN Android-changed: Don't crash crash if `pmsg` is NULL and getting from the cache fails.
-    /*
-    if (pmsg != NULL) {
-        *pmsg = NULL;
-    }
-
-    zip = ZIP_Get_From_Cache(name, pmsg, lastModified);
-
-    if (zip == NULL && pmsg != NULL && *pmsg == NULL) {
-        ZFILE zfd = ZFILE_Open(name, mode);
-        zip = ZIP_Put_In_Cache(name, zfd, pmsg, lastModified);
-    }
-    */
-    /*
-     * We want to know if ZIP_Get_From_Cache fails, which isn't possible to
-     * distinguish without passing a non-null message value. Hence, if the user
-     * didn't supply a `pmsg`, we make and manage our own.
-     */
-    char *localPmsg = NULL;
-    zip = ZIP_Get_From_Cache(name, &localPmsg, lastModified);
-
-    if (zip == NULL && localPmsg == NULL) {
-        ZFILE zfd = ZFILE_Open(name, mode);
-        // Android changed: Pass jni env and thiz object into the method.
-        zip = ZIP_Put_In_Cache(env, thiz, name, zfd, &localPmsg, lastModified);
-    }
-
-    if (pmsg == NULL) {
-      free(localPmsg);
-    } else {
-      *pmsg = localPmsg;
-    }
-    // END Android-changed: Don't crash crash if `pmsg` is NULL and getting from the cache fails.
-    return zip;
-}
-
-/*
- * Returns the jzfile corresponding to the given file name from the cache of
- * zip files, or NULL if the file is not in the cache.  If the name is longer
- * than PATH_MAX or a zip error occurred then *pmsg will be set to the error
- * message text if pmsg != 0. Otherwise, *pmsg will be set to NULL. Caller
- * is responsible to free the error message.
- */
-jzfile *
-ZIP_Get_From_Cache(const char *name, char **pmsg, jlong lastModified)
-{
-    char buf[PATH_MAX];
-    jzfile *zip;
-
-    if (InitializeZip()) {
-        return NULL;
-    }
-
-    /* Clear zip error message */
-    if (pmsg != 0) {
-        *pmsg = NULL;
-    }
-
-    if (strlen(name) >= PATH_MAX) {
-        if (pmsg) {
-            *pmsg = strdup("zip file name too long");
-        }
-        return NULL;
-    }
-    strcpy(buf, name);
-    JVM_NativePath(buf);
-    name = buf;
-
-    MLOCK(zfiles_lock);
-    for (zip = zfiles; zip != NULL; zip = zip->next) {
-        if (strcmp(name, zip->name) == 0
-            && (zip->lastModified == lastModified || zip->lastModified == 0)
-            && zip->refs < MAXREFS) {
-            zip->refs++;
-            break;
-        }
-    }
-    MUNLOCK(zfiles_lock);
-    return zip;
-}
-
-/*
- * Reads data from the given file descriptor to create a jzfile, puts the
- * jzfile in a cache, and returns that jzfile.  Returns NULL in case of error.
- * If a zip error occurs, then *pmsg will be set to the error message text if
- * pmsg != 0. Otherwise, *pmsg will be set to NULL. Caller is responsible to
- * free the error message.
- */
-
-jzfile *
-// Android changed: Pass jni env and thiz object into the method.
-ZIP_Put_In_Cache(JNIEnv *env, jobject thiz, const char *name, ZFILE zfd, char **pmsg, jlong lastModified)
-{
-    // Android changed: Pass jni env and thiz object into the method.
-    return ZIP_Put_In_Cache0(env, thiz, name, zfd, pmsg, lastModified, JNI_TRUE);
-}
-
-jzfile *
-// Android changed: Pass jni env and thiz object into the method.
-ZIP_Put_In_Cache0(JNIEnv *env, jobject thiz, const char *name, ZFILE zfd, char **pmsg, jlong lastModified,
-                 jboolean usemmap)
-{
-    char errbuf[256];
-    jlong len;
-    jzfile *zip;
-
-    if ((zip = allocZip(name)) == NULL) {
-        return NULL;
-    }
-
-#ifdef USE_MMAP
-    zip->usemmap = usemmap;
-#endif
-    zip->refs = 1;
-    zip->lastModified = lastModified;
-
-    if (zfd == -1) {
-        if (pmsg && getLastErrorString(errbuf, sizeof(errbuf)) > 0)
-            *pmsg = strdup(errbuf);
-        freeZip(zip);
-        return NULL;
-    }
-
-    // Assumption, zfd refers to start of file. Trivially, reuse errbuf.
-    if (readFullyAt(zfd, errbuf, 4, 0 /* offset */) != -1) {  // errors will be handled later
-        zip->locsig = LOCSIG_AT(errbuf) ? JNI_TRUE : JNI_FALSE;
-    }
-
-    // This lseek is safe because it happens during construction of the ZipFile
-    // object. We must take care not to perform any operations that change the
-    // offset after (see b/30407219).
-    len = zip->len = IO_Lseek(zfd, 0, SEEK_END);
-    if (len <= 0) {
-        if (len == 0) { /* zip file is empty */
-            if (pmsg) {
-                *pmsg = strdup("zip file is empty");
-            }
-        } else { /* error */
-            if (pmsg && getLastErrorString(errbuf, sizeof(errbuf)) > 0)
-                *pmsg = strdup(errbuf);
-        }
-        ZFILE_Close(zfd);
-        freeZip(zip);
-        return NULL;
-    }
-
-    zip->zfd = zfd;
-    // Android changed: Pass jni env and thiz object into the method.
-    if (readCEN(env, thiz, zip, -1) < 0) {
-        /* An error occurred while trying to read the zip file */
-        if (pmsg != 0) {
-            /* Set the zip error message */
-            if (zip->msg != NULL)
-                *pmsg = strdup(zip->msg);
-        }
-        freeZip(zip);
-        return NULL;
-    }
-    MLOCK(zfiles_lock);
-    zip->next = zfiles;
-    zfiles = zip;
-    MUNLOCK(zfiles_lock);
-
-    return zip;
-}
-
-/*
- * Opens a zip file for reading. Returns the jzfile object or NULL
- * if an error occurred. If a zip error occurred then *msg will be
- * set to the error message text if msg != 0. Otherwise, *msg will be
- * set to NULL. Caller doesn't need to free the error message.
- */
-JNIEXPORT jzfile *
-// Android changed: Pass jni env and thiz object into the method.
-ZIP_Open(JNIEnv *env, jobject thiz, const char *name, char **pmsg)
-{
-    // Android changed: Pass jni env and thiz object into the method.
-    jzfile *file = ZIP_Open_Generic(env, thiz, name, pmsg, O_RDONLY, 0);
-    if (file == NULL && pmsg != NULL && *pmsg != NULL) {
-        free(*pmsg);
-        *pmsg = "Zip file open error";
-    }
-    return file;
-}
-
-/*
- * Closes the specified zip file object.
- */
-JNIEXPORT void
-ZIP_Close(jzfile *zip)
-{
-    MLOCK(zfiles_lock);
-    if (--zip->refs > 0) {
-        /* Still more references so just return */
-        MUNLOCK(zfiles_lock);
-        return;
-    }
-    /* No other references so close the file and remove from list */
-    if (zfiles == zip) {
-        zfiles = zfiles->next;
-    } else {
-        jzfile *zp;
-        for (zp = zfiles; zp->next != 0; zp = zp->next) {
-            if (zp->next == zip) {
-                zp->next = zip->next;
-                break;
-            }
-        }
-    }
-    MUNLOCK(zfiles_lock);
-    freeZip(zip);
-    return;
-}
-
-/* Empirically, most CEN headers are smaller than this. */
-#define AMPLE_CEN_HEADER_SIZE 160
-
-/* A good buffer size when we want to read CEN headers sequentially. */
-#define CENCACHE_PAGESIZE 8192
-
-static char *
-readCENHeader(jzfile *zip, jlong cenpos, jint bufsize)
-{
-    jint censize;
-    ZFILE zfd = zip->zfd;
-    char *cen;
-    if (bufsize > zip->len - cenpos)
-        bufsize = (jint)(zip->len - cenpos);
-    if ((cen = malloc(bufsize)) == NULL)       goto Catch;
-    if (readFullyAt(zfd, cen, bufsize, cenpos) == -1)     goto Catch;
-    censize = CENSIZE(cen);
-    if (censize <= bufsize) return cen;
-    if ((cen = realloc(cen, censize)) == NULL)              goto Catch;
-    if (readFullyAt(zfd, cen+bufsize, censize-bufsize, cenpos + bufsize) == -1) goto Catch;
-    return cen;
-
- Catch:
-    free(cen);
-    return NULL;
-}
-
-static char *
-sequentialAccessReadCENHeader(jzfile *zip, jlong cenpos)
-{
-    cencache *cache = &zip->cencache;
-    char *cen;
-    if (cache->data != NULL
-        && (cenpos >= cache->pos)
-        && (cenpos + CENHDR <= cache->pos + CENCACHE_PAGESIZE))
-    {
-        cen = cache->data + cenpos - cache->pos;
-        if (cenpos + CENSIZE(cen) <= cache->pos + CENCACHE_PAGESIZE)
-            /* A cache hit */
-            return cen;
-    }
-
-    if ((cen = readCENHeader(zip, cenpos, CENCACHE_PAGESIZE)) == NULL)
-        return NULL;
-    free(cache->data);
-    cache->data = cen;
-    cache->pos  = cenpos;
-    return cen;
-}
-
-typedef enum { ACCESS_RANDOM, ACCESS_SEQUENTIAL } AccessHint;
-
-/*
- * Return a new initialized jzentry corresponding to a given hash cell.
- * In case of error, returns NULL.
- * We already sanity-checked all the CEN headers for ZIP format errors
- * in readCEN(), so we don't check them again here.
- * The ZIP lock should be held here.
- */
-static jzentry *
-newEntry(jzfile *zip, jzcell *zc, AccessHint accessHint)
-{
-    jlong locoff;
-    jint nlen, elen, clen;
-    jzentry *ze;
-    char *cen;
-
-    if ((ze = (jzentry *) malloc(sizeof(jzentry))) == NULL) return NULL;
-    ze->name    = NULL;
-    ze->extra   = NULL;
-    ze->comment = NULL;
-
-#ifdef USE_MMAP
-    if (zip->usemmap) {
-        cen = (char*) zip->maddr + zc->cenpos - zip->offset;
-    } else
-#endif
-    {
-        if (accessHint == ACCESS_RANDOM)
-            cen = readCENHeader(zip, zc->cenpos, AMPLE_CEN_HEADER_SIZE);
-        else
-            cen = sequentialAccessReadCENHeader(zip, zc->cenpos);
-        if (cen == NULL) goto Catch;
-    }
-
-    nlen      = CENNAM(cen);
-    elen      = CENEXT(cen);
-    clen      = CENCOM(cen);
-    ze->time  = CENTIM(cen);
-    ze->size  = CENLEN(cen);
-    ze->csize = (CENHOW(cen) == STORED) ? 0 : CENSIZ(cen);
-    ze->crc   = CENCRC(cen);
-    locoff    = CENOFF(cen);
-    ze->pos   = -(zip->locpos + locoff);
-    ze->flag  = CENFLG(cen);
-
-    if ((ze->name = malloc(nlen + 1)) == NULL) goto Catch;
-    memcpy(ze->name, cen + CENHDR, nlen);
-    ze->name[nlen] = '\0';
-    ze->nlen = nlen;
-    if (elen > 0) {
-        char *extra = cen + CENHDR + nlen;
-
-        /* This entry has "extra" data */
-        if ((ze->extra = malloc(elen + 2)) == NULL) goto Catch;
-        ze->extra[0] = (unsigned char) elen;
-        ze->extra[1] = (unsigned char) (elen >> 8);
-        memcpy(ze->extra+2, extra, elen);
-        if (ze->csize == ZIP64_MAGICVAL || ze->size == ZIP64_MAGICVAL ||
-            locoff == ZIP64_MAGICVAL) {
-            jint off = 0;
-            while ((off + 4) < elen) {    // spec: HeaderID+DataSize+Data
-                jint sz = SH(extra, off + 2);
-                if (SH(extra, off) == ZIP64_EXTID) {
-                    off += 4;
-                    if (ze->size == ZIP64_MAGICVAL) {
-                        // if invalid zip64 extra fields, just skip
-                        if (sz < 8 || (off + 8) > elen)
-                            break;
-                        ze->size = LL(extra, off);
-                        sz -= 8;
-                        off += 8;
-                    }
-                    if (ze->csize == ZIP64_MAGICVAL) {
-                        if (sz < 8 || (off + 8) > elen)
-                            break;
-                        ze->csize = LL(extra, off);
-                        sz -= 8;
-                        off += 8;
-                    }
-                    if (locoff == ZIP64_MAGICVAL) {
-                        if (sz < 8 || (off + 8) > elen)
-                            break;
-                        ze->pos = -(zip->locpos +  LL(extra, off));
-                        sz -= 8;
-                        off += 8;
-                    }
-                    break;
-                }
-                off += (sz + 4);
-            }
-        }
-    }
-
-    if (clen > 0) {
-        /* This entry has a comment */
-        if ((ze->comment = malloc(clen + 1)) == NULL) goto Catch;
-        memcpy(ze->comment, cen + CENHDR + nlen + elen, clen);
-        ze->comment[clen] = '\0';
-    }
-    goto Finally;
-
- Catch:
-    free(ze->name);
-    free(ze->extra);
-    free(ze->comment);
-    free(ze);
-    ze = NULL;
-
- Finally:
-#ifdef USE_MMAP
-    if (!zip->usemmap)
-#endif
-        if (cen != NULL && accessHint == ACCESS_RANDOM) free(cen);
-    return ze;
-}
-
-/*
- * Free the given jzentry.
- * In fact we maintain a one-entry cache of the most recently used
- * jzentry for each zip.  This optimizes a common access pattern.
- */
-
-void
-ZIP_FreeEntry(jzfile *jz, jzentry *ze)
-{
-    jzentry *last;
-    ZIP_Lock(jz);
-    last = jz->cache;
-    jz->cache = ze;
-    ZIP_Unlock(jz);
-    if (last != NULL) {
-        /* Free the previously cached jzentry */
-        free(last->name);
-        if (last->extra)   free(last->extra);
-        if (last->comment) free(last->comment);
-        free(last);
-    }
-}
-
-/*
- * Returns the zip entry corresponding to the specified name, or
- * NULL if not found.
- */
-jzentry *
-ZIP_GetEntry(jzfile *zip, char *name, jint ulen)
-{
-    if (ulen == 0) {
-        return ZIP_GetEntry2(zip, name, (jint)strlen(name), JNI_FALSE);
-    }
-    return ZIP_GetEntry2(zip, name, ulen, JNI_TRUE);
-}
-
-jboolean equals(char* name1, int len1, char* name2, int len2) {
-    if (len1 != len2) {
-        return JNI_FALSE;
-    }
-    while (len1-- > 0) {
-        if (*name1++ != *name2++) {
-            return JNI_FALSE;
-        }
-    }
-    return JNI_TRUE;
-}
-
-/*
- * Returns the zip entry corresponding to the specified name, or
- * NULL if not found.
- * This method supports embedded null character in "name", use ulen
- * for the length of "name".
- */
-jzentry *
-ZIP_GetEntry2(jzfile *zip, char *name, jint ulen, jboolean addSlash)
-{
-    unsigned int hsh = hashN(name, ulen);
-    jint idx;
-    jzentry *ze = 0;
-
-    ZIP_Lock(zip);
-    if (zip->total == 0) {
-        goto Finally;
-    }
-
-    idx = zip->table[hsh % zip->tablelen];
-
-    /*
-     * This while loop is an optimization where a double lookup
-     * for name and name+/ is being performed. The name char
-     * array has enough room at the end to try again with a
-     * slash appended if the first table lookup does not succeed.
-     */
-    while(1) {
-
-        /* Check the cached entry first */
-        ze = zip->cache;
-        if (ze && equals(ze->name, ze->nlen, name, ulen)) {
-            /* Cache hit!  Remove and return the cached entry. */
-            zip->cache = 0;
-            ZIP_Unlock(zip);
-            return ze;
-        }
-        ze = 0;
-
-        /*
-         * Search down the target hash chain for a cell whose
-         * 32 bit hash matches the hashed name.
-         */
-        while (idx != ZIP_ENDCHAIN) {
-            jzcell *zc = &zip->entries[idx];
-
-            if (zc->hash == hsh) {
-                /*
-                 * OK, we've found a ZIP entry whose 32 bit hashcode
-                 * matches the name we're looking for.  Try to read
-                 * its entry information from the CEN.  If the CEN
-                 * name matches the name we're looking for, we're
-                 * done.
-                 * If the names don't match (which should be very rare)
-                 * we keep searching.
-                 */
-                ze = newEntry(zip, zc, ACCESS_RANDOM);
-                if (ze && equals(ze->name, ze->nlen, name, ulen)) {
-                    break;
-                }
-                if (ze != 0) {
-                    /* We need to release the lock across the free call */
-                    ZIP_Unlock(zip);
-                    ZIP_FreeEntry(zip, ze);
-                    ZIP_Lock(zip);
-                }
-                ze = 0;
-            }
-            idx = zc->next;
-        }
-
-        /* Entry found, return it */
-        if (ze != 0) {
-            break;
-        }
-
-        /* If no need to try appending slash, we are done */
-        if (!addSlash) {
-            break;
-        }
-
-        /* Slash is already there? */
-        if (ulen > 0 && name[ulen - 1] == '/') {
-            break;
-        }
-
-        /* Add slash and try once more */
-        name[ulen++] = '/';
-        name[ulen] = '\0';
-        hsh = hash_append(hsh, '/');
-        idx = zip->table[hsh % zip->tablelen];
-        addSlash = JNI_FALSE;
-    }
-
-Finally:
-    ZIP_Unlock(zip);
-    return ze;
-}
-
-/*
- * Returns the n'th (starting at zero) zip file entry, or NULL if the
- * specified index was out of range.
- */
-JNIEXPORT jzentry *
-ZIP_GetNextEntry(jzfile *zip, jint n)
-{
-    jzentry *result;
-    if (n < 0 || n >= zip->total) {
-        return 0;
-    }
-    ZIP_Lock(zip);
-    result = newEntry(zip, &zip->entries[n], ACCESS_SEQUENTIAL);
-    ZIP_Unlock(zip);
-    return result;
-}
-
-/*
- * Locks the specified zip file for reading.
- */
-void
-ZIP_Lock(jzfile *zip)
-{
-    MLOCK(zip->lock);
-}
-
-/*
- * Unlocks the specified zip file.
- */
-void
-ZIP_Unlock(jzfile *zip)
-{
-    MUNLOCK(zip->lock);
-}
-
-/*
- * Returns the offset of the entry data within the zip file.
- * Returns -1 if an error occurred, in which case zip->msg will
- * contain the error text.
- */
-jlong
-ZIP_GetEntryDataOffset(jzfile *zip, jzentry *entry)
-{
-    /* The Zip file spec explicitly allows the LOC extra data size to
-     * be different from the CEN extra data size, although the JDK
-     * never creates such zip files.  Since we cannot trust the CEN
-     * extra data size, we need to read the LOC to determine the entry
-     * data offset.  We do this lazily to avoid touching the virtual
-     * memory page containing the LOC when initializing jzentry
-     * objects.  (This speeds up javac by a factor of 10 when the JDK
-     * is installed on a very slow filesystem.)
-     */
-    if (entry->pos <= 0) {
-        unsigned char loc[LOCHDR];
-        if (readFullyAt(zip->zfd, loc, LOCHDR, -(entry->pos)) == -1) {
-            zip->msg = "error reading zip file";
-            return -1;
-        }
-        if (!LOCSIG_AT(loc)) {
-            zip->msg = "invalid LOC header (bad signature)";
-            return -1;
-        }
-        entry->pos = (- entry->pos) + LOCHDR + LOCNAM(loc) + LOCEXT(loc);
-    }
-    return entry->pos;
-}
-
-/*
- * Reads bytes from the specified zip entry. Assumes that the zip
- * file had been previously locked with ZIP_Lock(). Returns the
- * number of bytes read, or -1 if an error occurred. If zip->msg != 0
- * then a zip error occurred and zip->msg contains the error text.
- *
- * The current implementation does not support reading an entry that
- * has the size bigger than 2**32 bytes in ONE invocation.
- */
-jint
-ZIP_Read(jzfile *zip, jzentry *entry, jlong pos, void *buf, jint len)
-{
-    jlong entry_size;
-    jlong start;
-
-    if (zip == 0) {
-        return -1;
-    }
-
-    /* Clear previous zip error */
-    zip->msg = NULL;
-
-    if (entry == 0) {
-        zip->msg = "ZIP_Read: jzentry is NULL";
-        return -1;
-    }
-
-    entry_size = (entry->csize != 0) ? entry->csize : entry->size;
-
-    /* Check specified position */
-    if (pos < 0 || pos > entry_size - 1) {
-        zip->msg = "ZIP_Read: specified offset out of range";
-        return -1;
-    }
-
-    /* Check specified length */
-    if (len <= 0)
-        return 0;
-    if (len > entry_size - pos)
-        len = (jint)(entry_size - pos);
-
-    /* Get file offset to start reading data */
-    start = ZIP_GetEntryDataOffset(zip, entry);
-    if (start < 0)
-        return -1;
-    start += pos;
-
-    if (start + len > zip->len) {
-        zip->msg = "ZIP_Read: corrupt zip file: invalid entry size";
-        return -1;
-    }
-
-    if (readFullyAt(zip->zfd, buf, len, start) == -1) {
-        zip->msg = "ZIP_Read: error reading zip file";
-        return -1;
-    }
-    return len;
-}
-
-
-/* The maximum size of a stack-allocated buffer.
- */
-#define BUF_SIZE 4096
-
-/*
- * This function is used by the runtime system to load compressed entries
- * from ZIP/JAR files specified in the class path. It is defined here
- * so that it can be dynamically loaded by the runtime if the zip library
- * is found.
- *
- * The current implementation does not support reading an entry that
- * has the size bigger than 2**32 bytes in ONE invocation.
- */
-jboolean
-InflateFully(jzfile *zip, jzentry *entry, void *buf, char **msg)
-{
-    z_stream strm;
-    char tmp[BUF_SIZE];
-    jlong pos = 0;
-    jlong count = entry->csize;
-
-    *msg = 0; /* Reset error message */
-
-    if (count == 0) {
-        *msg = "inflateFully: entry not compressed";
-        return JNI_FALSE;
-    }
-
-    memset(&strm, 0, sizeof(z_stream));
-    if (inflateInit2(&strm, -MAX_WBITS) != Z_OK) {
-        *msg = strm.msg;
-        return JNI_FALSE;
-    }
-
-    strm.next_out = buf;
-    strm.avail_out = (uInt)entry->size;
-
-    while (count > 0) {
-        jint n = count > (jlong)sizeof(tmp) ? (jint)sizeof(tmp) : (jint)count;
-        ZIP_Lock(zip);
-        n = ZIP_Read(zip, entry, pos, tmp, n);
-        ZIP_Unlock(zip);
-        if (n <= 0) {
-            if (n == 0) {
-                *msg = "inflateFully: Unexpected end of file";
-            }
-            inflateEnd(&strm);
-            return JNI_FALSE;
-        }
-        pos += n;
-        count -= n;
-        strm.next_in = (Bytef *)tmp;
-        strm.avail_in = n;
-        do {
-            switch (inflate(&strm, Z_PARTIAL_FLUSH)) {
-            case Z_OK:
-                break;
-            case Z_STREAM_END:
-                // Android-changed: added entry->size < 0 check.
-                // if (count != 0 || strm.total_out != (uInt)entry->size) {
-                if (count != 0 || entry->size < 0 || strm.total_out != (uint64_t)entry->size) {
-                    *msg = "inflateFully: Unexpected end of stream";
-                    inflateEnd(&strm);
-                    return JNI_FALSE;
-                }
-                break;
-            default:
-                break;
-            }
-        } while (strm.avail_in > 0);
-    }
-
-    inflateEnd(&strm);
-    return JNI_TRUE;
-}
-
-/*
- * The current implementation does not support reading an entry that
- * has the size bigger than 2**32 bytes in ONE invocation.
- */
-JNIEXPORT jzentry *
-ZIP_FindEntry(jzfile *zip, char *name, jint *sizeP, jint *nameLenP)
-{
-    jzentry *entry = ZIP_GetEntry(zip, name, 0);
-    if (entry) {
-        *sizeP = (jint)entry->size;
-        *nameLenP = (jint)strlen(entry->name);
-    }
-    return entry;
-}
-
-/*
- * Reads a zip file entry into the specified byte array
- * When the method completes, it releases the jzentry.
- * Note: this is called from the separately delivered VM (hotspot/classic)
- * so we have to be careful to maintain the expected behaviour.
- */
-JNIEXPORT jboolean
-ZIP_ReadEntry(jzfile *zip, jzentry *entry, unsigned char *buf, char *entryname)
-{
-    char *msg;
-    char tmpbuf[1024];
-
-    if (entry == 0) {
-        jio_fprintf(stderr, "jzentry was invalid");
-        return JNI_FALSE;
-    }
-
-    strcpy(entryname, entry->name);
-    if (entry->csize == 0) {
-        /* Entry is stored */
-        jlong pos = 0;
-        jlong size = entry->size;
-        while (pos < size) {
-            jint n;
-            jlong limit = ((((jlong) 1) << 31) - 1);
-            jint count = (size - pos < limit) ?
-                /* These casts suppress a VC++ Internal Compiler Error */
-                (jint) (size - pos) :
-                (jint) limit;
-            ZIP_Lock(zip);
-            n = ZIP_Read(zip, entry, pos, buf, count);
-            msg = zip->msg;
-            ZIP_Unlock(zip);
-            if (n == -1) {
-                if (msg == 0) {
-                    getErrorString(errno, tmpbuf, sizeof(tmpbuf));
-                    msg = tmpbuf;
-                }
-                jio_fprintf(stderr, "%s: %s\n", zip->name, msg);
-                return JNI_FALSE;
-            }
-            buf += n;
-            pos += n;
-        }
-    } else {
-        /* Entry is compressed */
-        int ok = InflateFully(zip, entry, buf, &msg);
-        if (!ok) {
-            if ((msg == NULL) || (*msg == 0)) {
-                msg = zip->msg;
-            }
-            if (msg == 0) {
-                getErrorString(errno, tmpbuf, sizeof(tmpbuf));
-                msg = tmpbuf;
-            }
-            jio_fprintf(stderr, "%s: %s\n", zip->name, msg);
-            return JNI_FALSE;
-        }
-    }
-
-    ZIP_FreeEntry(zip, entry);
-
-    return JNI_TRUE;
-}
-
-// BEGIN Android-added: Use strict mode to validate zip entry name.
-jboolean
-ZIP_OnZipEntryAccess(JNIEnv *env, jobject thiz, const char* entryName, int len, jint flag) {
-    jbyteArray array = (*env)->NewByteArray(env, len);
-    (*env)->SetByteArrayRegion(env, array, 0, len, (jbyte*) entryName);
-    (*env)->CallVoidMethod(env, thiz, jzOnZipEntryAccessID, array, flag);
-    if ((*env)->ExceptionCheck(env)) {
-        (*env)->ExceptionClear(env);
-        return true;
-    }
-    return false;
-}
-// END Android-added:  Use strict mode to validate zip entry name.
-
-// BEGIN Android-removed: following methods are used outside of java.util.zip and
-// that code is absent from Android.
-/*
-JNIEXPORT jboolean
-ZIP_InflateFully(void *inBuf, jlong inLen, void *outBuf, jlong outLen, char **pmsg)
-{
-    z_stream strm;
-    int i = 0;
-    memset(&strm, 0, sizeof(z_stream));
-
-    *pmsg = 0; * Reset error message *
-
-    if (inflateInit2(&strm, MAX_WBITS) != Z_OK) {
-        *pmsg = strm.msg;
-        return JNI_FALSE;
-    }
-
-    strm.next_out = (Bytef *) outBuf;
-    strm.avail_out = (uInt)outLen;
-    strm.next_in = (Bytef *) inBuf;
-    strm.avail_in = (uInt)inLen;
-
-    do {
-        switch (inflate(&strm, Z_PARTIAL_FLUSH)) {
-            case Z_OK:
-                break;
-            case Z_STREAM_END:
-                if (strm.total_out != (uInt)outLen) {
-                    *pmsg = "INFLATER_inflateFully: Unexpected end of stream";
-                    inflateEnd(&strm);
-                    return JNI_FALSE;
-                }
-                break;
-            case Z_DATA_ERROR:
-                *pmsg = "INFLATER_inflateFully: Compressed data corrupted";
-                inflateEnd(&strm);
-                return JNI_FALSE;
-            case Z_MEM_ERROR:
-                *pmsg = "INFLATER_inflateFully: out of memory";
-                inflateEnd(&strm);
-                return JNI_FALSE;
-            default:
-                *pmsg = "INFLATER_inflateFully: internal error";
-                inflateEnd(&strm);
-                return JNI_FALSE;
-        }
-    } while (strm.avail_in > 0);
-
-    inflateEnd(&strm);
-    return JNI_TRUE;
-}
-
-static voidpf tracking_zlib_alloc(voidpf opaque, uInt items, uInt size) {
-  size_t* needed = (size_t*) opaque;
-  *needed += (size_t) items * (size_t) size;
-  return (voidpf) calloc((size_t) items, (size_t) size);
-}
-
-static void tracking_zlib_free(voidpf opaque, voidpf address) {
-  free((void*) address);
-}
-
-static voidpf zlib_block_alloc(voidpf opaque, uInt items, uInt size) {
-  char** range = (char**) opaque;
-  voidpf result = NULL;
-  size_t needed = (size_t) items * (size_t) size;
-
-  if (range[1] - range[0] >= (ptrdiff_t) needed) {
-    result = (voidpf) range[0];
-    range[0] += needed;
-  }
-
-  return result;
-}
-
-static void zlib_block_free(voidpf opaque, voidpf address) {
-  * Nothing to do. *
-}
-
-static char const* deflateInit2Wrapper(z_stream* strm, int level) {
-  int err = deflateInit2(strm, level >= 0 && level <= 9 ? level : Z_DEFAULT_COMPRESSION,
-                         Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
-  if (err == Z_MEM_ERROR) {
-    return "Out of memory in deflateInit2";
-  }
-
-  if (err != Z_OK) {
-    return "Internal error in deflateInit2";
-  }
-
-  return NULL;
-}
-
-JNIEXPORT char const*
-ZIP_GZip_InitParams(size_t inLen, size_t* outLen, size_t* tmpLen, int level) {
-  z_stream strm;
-  *tmpLen = 0;
-  char const* errorMsg;
-
-  memset(&strm, 0, sizeof(z_stream));
-  strm.zalloc = tracking_zlib_alloc;
-  strm.zfree = tracking_zlib_free;
-  strm.opaque = (voidpf) tmpLen;
-
-  errorMsg = deflateInit2Wrapper(&strm, level);
-
-  if (errorMsg == NULL) {
-    *outLen = (size_t) deflateBound(&strm, (uLong) inLen);
-    deflateEnd(&strm);
-  }
-
-  return errorMsg;
-}
-
-JNIEXPORT size_t
-ZIP_GZip_Fully(char* inBuf, size_t inLen, char* outBuf, size_t outLen, char* tmp, size_t tmpLen,
-               int level, char* comment, char const** pmsg) {
-  z_stream strm;
-  gz_header hdr;
-  int err;
-  char* block[] = {tmp, tmpLen + tmp};
-  size_t result = 0;
-
-  memset(&strm, 0, sizeof(z_stream));
-  strm.zalloc = zlib_block_alloc;
-  strm.zfree = zlib_block_free;
-  strm.opaque = (voidpf) block;
-
-  *pmsg = deflateInit2Wrapper(&strm, level);
-
-  if (*pmsg == NULL) {
-    strm.next_out = (Bytef *) outBuf;
-    strm.avail_out = (uInt) outLen;
-    strm.next_in = (Bytef *) inBuf;
-    strm.avail_in = (uInt) inLen;
-
-    if (comment != NULL) {
-      memset(&hdr, 0, sizeof(hdr));
-      hdr.comment = (Bytef*) comment;
-      deflateSetHeader(&strm, &hdr);
-    }
-
-    err = deflate(&strm, Z_FINISH);
-
-    if (err == Z_OK || err == Z_BUF_ERROR) {
-      *pmsg = "Buffer too small";
-    } else if (err != Z_STREAM_END) {
-      *pmsg = "Intern deflate error";
-    } else {
-      result = (size_t) strm.total_out;
-    }
-
-    deflateEnd(&strm);
-  }
-
-  return result;
-}
-*/
-// END Android-removed: following methods are used outside of java.util.zip and
-// that code is absent from Android.
diff --git a/ojluni/src/main/native/zip_util.h b/ojluni/src/main/native/zip_util.h
deleted file mode 100644
index 542f0f4eb3a..00000000000
--- a/ojluni/src/main/native/zip_util.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Prototypes for zip file support
- */
-
-#ifndef _ZIP_H_
-#define _ZIP_H_
-
-/*
- * Header signatures
- */
-#define PKZIP_SIGNATURE_AT(p, b2, b3) \
-  (((p)[0] == 'P') & ((p)[1] == 'K') & ((p)[2] == b2) & ((p)[3] == b3))
-#define CENSIG_AT(p)       PKZIP_SIGNATURE_AT(p, 1, 2)
-#define LOCSIG_AT(p)       PKZIP_SIGNATURE_AT(p, 3, 4)
-#define ENDSIG_AT(p)       PKZIP_SIGNATURE_AT(p, 5, 6)
-#define EXTSIG_AT(p)       PKZIP_SIGNATURE_AT(p, 7, 8)
-#define ZIP64_ENDSIG_AT(p) PKZIP_SIGNATURE_AT(p, 6, 6)
-#define ZIP64_LOCSIG_AT(p) PKZIP_SIGNATURE_AT(p, 6, 7)
-
-/*
- * Header sizes including signatures
- */
-
-#define LOCHDR 30
-#define EXTHDR 16
-#define CENHDR 46
-#define ENDHDR 22
-
-#define ZIP64_ENDHDR 56       // ZIP64 end header size
-#define ZIP64_LOCHDR 20       // ZIP64 end loc header size
-#define ZIP64_EXTHDR 24       // EXT header size
-#define ZIP64_EXTID   1       // Extra field Zip64 header ID
-
-#define ZIP64_MAGICVAL 0xffffffffLL
-#define ZIP64_MAGICCOUNT 0xffff
-
-
-/*
- * Header field access macros
- */
-#define CH(b, n) (((unsigned char *)(b))[n])
-#define SH(b, n) (CH(b, n) | (CH(b, n+1) << 8))
-#define LG(b, n) ((SH(b, n) | (SH(b, n+2) << 16)) &0xffffffffUL)
-#define LL(b, n) (((jlong)LG(b, n)) | (((jlong)LG(b, n+4)) << 32))
-#define GETSIG(b) LG(b, 0)
-
-/*
- * Macros for getting local file (LOC) header fields
- */
-#define LOCVER(b) SH(b, 4)          /* version needed to extract */
-#define LOCFLG(b) SH(b, 6)          /* general purpose bit flags */
-#define LOCHOW(b) SH(b, 8)          /* compression method */
-#define LOCTIM(b) LG(b, 10)         /* modification time */
-#define LOCCRC(b) LG(b, 14)         /* crc of uncompressed data */
-#define LOCSIZ(b) LG(b, 18)         /* compressed data size */
-#define LOCLEN(b) LG(b, 22)         /* uncompressed data size */
-#define LOCNAM(b) SH(b, 26)         /* filename length */
-#define LOCEXT(b) SH(b, 28)         /* extra field length */
-
-/*
- * Macros for getting extra local (EXT) header fields
- */
-#define EXTCRC(b) LG(b, 4)          /* crc of uncompressed data */
-#define EXTSIZ(b) LG(b, 8)          /* compressed size */
-#define EXTLEN(b) LG(b, 12)         /* uncompressed size */
-
-/*
- * Macros for getting central directory header (CEN) fields
- */
-#define CENVEM(b) SH(b, 4)          /* version made by */
-#define CENVER(b) SH(b, 6)          /* version needed to extract */
-#define CENFLG(b) SH(b, 8)          /* general purpose bit flags */
-#define CENHOW(b) SH(b, 10)         /* compression method */
-#define CENTIM(b) LG(b, 12)         /* modification time */
-#define CENCRC(b) LG(b, 16)         /* crc of uncompressed data */
-#define CENSIZ(b) LG(b, 20)         /* compressed size */
-#define CENLEN(b) LG(b, 24)         /* uncompressed size */
-#define CENNAM(b) SH(b, 28)         /* length of filename */
-#define CENEXT(b) SH(b, 30)         /* length of extra field */
-#define CENCOM(b) SH(b, 32)         /* file comment length */
-#define CENDSK(b) SH(b, 34)         /* disk number start */
-#define CENATT(b) SH(b, 36)         /* internal file attributes */
-#define CENATX(b) LG(b, 38)         /* external file attributes */
-#define CENOFF(b) LG(b, 42)         /* offset of local header */
-
-/*
- * Macros for getting end of central directory header (END) fields
- */
-#define ENDSUB(b) SH(b, 8)          /* number of entries on this disk */
-#define ENDTOT(b) SH(b, 10)         /* total number of entries */
-#define ENDSIZ(b) LG(b, 12)         /* central directory size */
-#define ENDOFF(b) LG(b, 16)         /* central directory offset */
-#define ENDCOM(b) SH(b, 20)         /* size of zip file comment */
-
-/*
- * Macros for getting Zip64 end of central directory header fields
- */
-#define ZIP64_ENDLEN(b) LL(b, 4)      /* size of zip64 end of central dir */
-#define ZIP64_ENDVEM(b) SH(b, 12)     /* version made by */
-#define ZIP64_ENDVER(b) SH(b, 14)     /* version needed to extract */
-#define ZIP64_ENDNMD(b) LG(b, 16)     /* number of this disk */
-#define ZIP64_ENDDSK(b) LG(b, 20)     /* disk number of start */
-#define ZIP64_ENDTOD(b) LL(b, 24)     /* total number of entries on this disk */
-#define ZIP64_ENDTOT(b) LL(b, 32)     /* total number of entries */
-#define ZIP64_ENDSIZ(b) LL(b, 40)     /* central directory size in bytes */
-#define ZIP64_ENDOFF(b) LL(b, 48)     /* offset of first CEN header */
-
-/*
- * Macros for getting Zip64 end of central directory locator fields
- */
-#define ZIP64_LOCDSK(b) LG(b, 4)      /* disk number start */
-#define ZIP64_LOCOFF(b) LL(b, 8)      /* offset of zip64 end */
-#define ZIP64_LOCTOT(b) LG(b, 16)     /* total number of disks */
-
-/*
- * Supported compression methods
- */
-#define STORED      0
-#define DEFLATED    8
-
-/*
- * Support for reading ZIP/JAR files. Some things worth noting:
- *
- * - Zip file entries larger than 2**32 bytes are not supported.
- * - jzentry time and crc fields are signed even though they really
- *   represent unsigned quantities.
- * - If csize is zero then the entry is uncompressed.
- * - If extra != 0 then the first two bytes are the length of the extra
- *   data in intel byte order.
- * - If pos <= 0 then it is the position of entry LOC header.
- *   If pos > 0 then it is the position of entry data.
- *   pos should not be accessed directly, but only by ZIP_GetEntryDataOffset.
- * - entry name may include embedded null character, use nlen for length
- */
-
-typedef struct jzentry {  /* Zip file entry */
-    char *name;           /* entry name */
-    jlong time;           /* modification time */
-    jlong size;           /* size of uncompressed data */
-    jlong csize;          /* size of compressed data (zero if uncompressed) */
-    jint crc;             /* crc of uncompressed data */
-    char *comment;        /* optional zip file comment */
-    jbyte *extra;         /* optional extra data */
-    jlong pos;            /* position of LOC header or entry data */
-    jint flag;            /* general purpose flag */
-    jint nlen;            /* length of the entry name */
-} jzentry;
-
-/*
- * In-memory hash table cell.
- * In a typical system we have a *lot* of these, as we have one for
- * every entry in every active JAR.
- * Note that in order to save space we don't keep the name in memory,
- * but merely remember a 32 bit hash.
- */
-typedef struct jzcell {
-    unsigned int hash;    /* 32 bit hashcode on name */
-    unsigned int next;    /* hash chain: index into jzfile->entries */
-    jlong cenpos;         /* Offset of central directory file header */
-} jzcell;
-
-typedef struct cencache {
-    char *data;           /* A cached page of CEN headers */
-    jlong pos;            /* file offset of data */
-} cencache;
-
-/*
- * Use ZFILE to represent access to a file in a platform-indepenent
- * fashion.
- */
-#ifdef WIN32
-#define ZFILE jlong
-#else
-#define ZFILE int
-#endif
-
-/*
- * Use mmap for CEN & ENDHDR sections
- */
-#define USE_MMAP 1
-
-/*
- * Descriptor for a ZIP file.
- */
-typedef struct jzfile {   /* Zip file */
-    char *name;           /* zip file name */
-    jint refs;            /* number of active references */
-    jlong len;            /* length (in bytes) of zip file */
-#ifdef USE_MMAP
-    unsigned char *maddr; /* beginning address of the CEN & ENDHDR */
-    jlong mlen;           /* length (in bytes) mmaped */
-    jlong offset;         /* offset of the mmapped region from the
-                             start of the file. */
-    jboolean usemmap;     /* if mmap is used. */
-#endif
-    jboolean locsig;      /* if zip file starts with LOCSIG */
-    cencache cencache;    /* CEN header cache */
-    ZFILE zfd;            /* open file descriptor */
-    void *lock;           /* read lock */
-    char *comment;        /* zip file comment */
-    jint clen;            /* length of the zip file comment */
-    char *msg;            /* zip error message */
-    jzcell *entries;      /* array of hash cells */
-    jint total;           /* total number of entries */
-    jint *table;          /* Hash chain heads: indexes into entries */
-    jint tablelen;        /* number of hash heads */
-    struct jzfile *next;  /* next zip file in search list */
-    jzentry *cache;       /* we cache the most recently freed jzentry */
-    /* Information on metadata names in META-INF directory */
-    char **metanames;     /* array of meta names (may have null names) */
-    jint metacurrent;     /* the next empty slot in metanames array */
-    jint metacount;       /* number of slots in metanames array */
-    jlong lastModified;   /* last modified time */
-    jlong locpos;         /* position of first LOC header (usually 0) */
-} jzfile;
-
-/*
- * Index representing end of hash chain
- */
-#define ZIP_ENDCHAIN ((jint)-1)
-
-JNIEXPORT jzentry *
-ZIP_FindEntry(jzfile *zip, char *name, jint *sizeP, jint *nameLenP);
-
-JNIEXPORT jboolean
-ZIP_ReadEntry(jzfile *zip, jzentry *entry, unsigned char *buf, char *entrynm);
-
-JNIEXPORT jzentry *
-ZIP_GetNextEntry(jzfile *zip, jint n);
-
-JNIEXPORT jzfile *
-ZIP_Open(JNIEnv *env, jobject thiz, const char *name, char **pmsg);
-
-jzfile *
-ZIP_Open_Generic(JNIEnv *env, jobject thiz, const char *name, char **pmsg, int mode, jlong lastModified);
-
-jzfile *
-ZIP_Get_From_Cache(const char *name, char **pmsg, jlong lastModified);
-
-jzfile *
-ZIP_Put_In_Cache(JNIEnv *env, jobject thiz, const char *name, ZFILE zfd, char **pmsg, jlong lastModified);
-
-jzfile *
-ZIP_Put_In_Cache0(JNIEnv *env, jobject thiz, const char *name, ZFILE zfd, char **pmsg, jlong lastModified, jboolean usemmap);
-
-JNIEXPORT void
-ZIP_Close(jzfile *zip);
-
-jzentry *
-ZIP_GetEntry(jzfile *zip, char *name, jint ulen);
-void
-ZIP_Lock(jzfile *zip);
-void
-ZIP_Unlock(jzfile *zip);
-jint
-ZIP_Read(jzfile *zip, jzentry *entry, jlong pos, void *buf, jint len);
-void
-ZIP_FreeEntry(jzfile *zip, jzentry *ze);
-jlong ZIP_GetEntryDataOffset(jzfile *zip, jzentry *entry);
-jzentry * ZIP_GetEntry2(jzfile *zip, char *name, jint ulen, jboolean addSlash);
-
-// Android-removed; this method is used outside of java.util.zip and
-// that code is absent from Android.
-/*
-JNIEXPORT jboolean
-ZIP_InflateFully(void *inBuf, jlong inLen, void *outBuf, jlong outLen, char **pmsg);
-*/
-
-jboolean ZIP_OnZipEntryAccess(JNIEnv *env, jobject thiz, const char* entryName, int len, jint flag);
-#endif /* !_ZIP_H_ */
diff --git a/ojluni/src/test/Android.bp b/ojluni/src/test/Android.bp
index be294cce800..d5daecdb9d9 100644
--- a/ojluni/src/test/Android.bp
+++ b/ojluni/src/test/Android.bp
@@ -59,6 +59,7 @@ java_test {
     static_libs: [
         "core-test-rules",
         "junit",
+        "core-compat-test-rules",
         "mockwebserver",
         "testng",
     ],
@@ -152,7 +153,10 @@ java_test {
         "testng",
     ],
 
-    static_libs: ["mockwebserver"],
+    static_libs: [
+        "core-compat-test-rules",
+        "mockwebserver",
+    ],
 
     errorprone: {
         javacflags: [
diff --git a/ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java b/ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java
new file mode 100644
index 00000000000..1ea70eaba9a
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7121314
+ * @summary AbstractCollection.toArray(T[]) doesn't return the given array
+ *           in concurrent modification.
+ * @author Ulf Zibis, David Holmes
+ */
+
+package test.java.util.AbstractCollection;
+
+import java.util.AbstractCollection;
+import java.util.Arrays;
+import java.util.Iterator;
+
+public class ToArrayTest {
+
+    static class TestCollection<E> extends AbstractCollection<E> {
+        private final E[] elements;
+        private int[] sizes;
+        private int nextSize;
+
+        public TestCollection(E[] elements) {
+            this.elements = elements;
+            setSizeSequence(new int[] { elements.length });
+        }
+
+        /*
+         * Sets the values that size() will return on each use. The next
+         * call to size will return sizes[0], then sizes[1] etc. This allows us
+         * to emulate a concurrent change to the contents of the collection
+         * without having to perform concurrent changes. If sizes[n+1] contains
+         * a larger value, the collection will appear to have shrunk when
+         * iterated; if a smaller value then the collection will appear to have
+         * grown when iterated.
+         */
+        void setSizeSequence(int... sizes) {
+            this.sizes = sizes;
+            nextSize = 0;
+        }
+
+        /* can change collection's size after each invocation */
+        @Override
+        public int size() {
+            return sizes[nextSize == sizes.length - 1 ? nextSize : nextSize++];
+        }
+
+        @Override
+        public Iterator<E> iterator() {
+            return new Iterator<E>() {
+                int pos = 0;
+
+                public boolean hasNext() {
+                    return pos < sizes[nextSize];
+                }
+                public E next() {
+                    return elements[pos++];
+                }
+                public void remove() {
+                    throw new UnsupportedOperationException(
+                            "Not supported yet.");
+                }
+            };
+        }
+    }
+
+    static final Object[] OBJECTS = { new Object(), new Object(), new Object() };
+    static final TestCollection<?> CANDIDATE = new TestCollection<Object>(OBJECTS);
+    static final int CAP = OBJECTS.length; // capacity of the CANDIDATE
+    static final int LAST = CAP - 1; // last possible array index
+    Object[] a;
+    Object[] res;
+
+    int last() {
+        return a.length - 1;
+    }
+
+    protected void test() throws Throwable {
+        // Check array type conversion
+        res = new TestCollection<>(new Object[] { "1", "2" }).toArray(new String[0]);
+        check(res instanceof String[]);
+        check(res.length == 2);
+        check(res[1] == "2");
+
+        // Check incompatible type of target array
+        try {
+            res = CANDIDATE.toArray(new String[CAP]);
+            check(false);
+        } catch (Throwable t) {
+            check(t instanceof ArrayStoreException);
+        }
+
+        // Check more elements than a.length
+        a = new Object[CAP - 1]; // appears too small
+        res = CANDIDATE.toArray(a);
+        check(res != a);
+        check(res[LAST] != null);
+
+        // Check equal elements as a.length
+        a = new Object[CAP]; // appears to match
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] != null);
+
+        // Check equal elements as a.length
+        a = new Object[CAP + 1]; // appears too big
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] == null);
+
+        // Check less elements than expected, but more than a.length
+        a = new Object[CAP - 2]; // appears too small
+        CANDIDATE.setSizeSequence(CAP, CAP - 1);
+        res = CANDIDATE.toArray(a);
+        check(res != a);
+        check(res.length == CAP - 1);
+        check(res[LAST - 1] != null);
+
+        // Check less elements than expected, but equal as a.length
+        a = Arrays.copyOf(OBJECTS, CAP); // appears to match
+        CANDIDATE.setSizeSequence(CAP, CAP - 1);
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] == null);
+
+        // Check more elements than expected and more than a.length
+        a = new Object[CAP - 1]; // appears to match
+        CANDIDATE.setSizeSequence(CAP - 1, CAP);
+        res = CANDIDATE.toArray(a);
+        check(res != a);
+        check(res[LAST] != null);
+
+        // Check more elements than expected, but equal as a.length
+        a = new Object[CAP - 1]; // appears to match
+        CANDIDATE.setSizeSequence(CAP - 2, CAP - 1);
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] != null);
+
+        // Check more elements than expected, but less than a.length
+        a = Arrays.copyOf(OBJECTS, CAP); // appears to match
+        CANDIDATE.setSizeSequence(CAP - 2, CAP - 1);
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] == null);
+
+        test_7121314();
+    }
+
+    /*
+     * Major target of this testcase, bug 7121314.
+     */
+    protected void test_7121314() throws Throwable {
+        // Check equal elements as a.length, but less than expected
+        a = new Object[CAP - 1]; // appears too small
+        CANDIDATE.setSizeSequence(CAP, CAP - 1);
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] != null);
+
+        // Check less elements than a.length and less than expected
+        a = Arrays.copyOf(OBJECTS, CAP - 1); // appears too small
+        CANDIDATE.setSizeSequence(CAP, CAP - 2);
+        res = CANDIDATE.toArray(a);
+        check(res == a);
+        check(res[last()] == null);
+
+    }
+
+    public static void main(String[] args) throws Throwable {
+        ToArrayTest testcase = new ToArrayTest();
+        try {
+            testcase.test();
+        } catch (Throwable t) {
+            unexpected(t);
+        }
+
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new Exception("Some tests failed");
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    static volatile int passed = 0, failed = 0;
+    static void pass() { passed++; }
+    static void fail() { failed++; Thread.dumpStack(); }
+    static void fail(String msg) { System.out.println(msg); fail(); }
+    static void unexpected(Throwable t) { failed++; t.printStackTrace(); }
+    static void check(boolean cond) { if (cond) pass(); else fail(); }
+    static void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else {System.out.println(x + " not equal to " + y); fail(); }
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractCollection/ToString.java b/ojluni/src/test/java/util/AbstractCollection/ToString.java
new file mode 100644
index 00000000000..0370f4ac5d8
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractCollection/ToString.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4486049 6282555 6318622
+ * @summary toString method fails if size changes in between a call to size
+ *           and an attempt to iterate.
+ * @author Josh Bloch, Martin Buchholz
+ */
+
+package test.java.util.AbstractCollection;
+
+import java.util.AbstractCollection;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.Vector;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+public class ToString {
+    private static void realMain(String[] args) {
+        testCollection(new LinkedHashSet<Object>() {
+                public int size() {
+                    return super.size() + 1; // Lies, lies, all lies!
+                }});
+        testCollection(new ArrayList<Object>());
+        testCollection(new Vector<Object>());
+        testCollection(new CopyOnWriteArrayList<Object>());
+        testCollection(new CopyOnWriteArraySet<Object>());
+    }
+
+    private static void testCollection(Collection<Object> c) {
+        System.out.println(c.getClass());
+        equal(c.toString(), "[]");
+        check(c.add("x"));
+        equal(c.toString(), "[x]");
+        check(c.add("y"));
+        equal(c.toString(), "[x, y]");
+        check(c.add(null));
+        equal(c.toString(), "[x, y, null]");
+        if (c instanceof AbstractCollection) {
+            check(c.add(c));
+            equal(c.toString(), "[x, y, null, (this Collection)]");
+        }
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    static volatile int passed = 0, failed = 0;
+    static void pass() { passed++; }
+    static void fail() { failed++; Thread.dumpStack(); }
+    static void fail(String msg) { System.out.println(msg); fail(); }
+    static void unexpected(Throwable t) { failed++; t.printStackTrace(); }
+    static void check(boolean cond) { if (cond) pass(); else fail(); }
+    static void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else {System.out.println(x + " not equal to " + y); fail(); }}
+
+    public static void main(String[] args) throws Throwable {
+        try { realMain(args); } catch (Throwable t) { unexpected(t); }
+
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new Exception("Some tests failed");
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractList/CheckForComodification.java b/ojluni/src/test/java/util/AbstractList/CheckForComodification.java
new file mode 100644
index 00000000000..582d00e3742
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractList/CheckForComodification.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     4902078
+ * @summary concurrent modification not detected on 2nd to last iteration
+ * @author  Josh Bloch
+ *
+ * @ignore Bug fix temporarily removed as it uncovered other bugs (4992226)
+ */
+
+package test.java.util.AbstractList;
+
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.List;
+
+public class CheckForComodification {
+    private static final int LENGTH = 10;
+    public static void main(String[] args) throws Exception {
+        List<Integer> list = new ArrayList<>();
+        for (int i = 0; i < LENGTH; i++)
+            list.add(i);
+        try {
+            for (int i : list)
+                if (i == LENGTH - 2)
+                    list.remove(i);
+        } catch (ConcurrentModificationException e) {
+            return;
+        }
+        throw new RuntimeException("No ConcurrentModificationException");
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java b/ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java
new file mode 100644
index 00000000000..24464c67c21
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     8161558
+ * @summary ListIterator should not discard cause on exception
+ * @run testng CheckForIndexOutOfBoundsException
+ */
+
+package test.java.util.AbstractList;
+
+import java.util.List;
+import java.util.AbstractList;
+import java.util.Iterator;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+// Fixed size list containing two elements
+
+class MyList extends AbstractList<String> {
+
+    private static final int SIZE = 2;
+
+    public String get(int i) {
+        if (i >= 0 && i < SIZE) {
+            return "x";
+        } else {
+            throw new IndexOutOfBoundsException(i);
+        }
+    }
+
+    public int size() {
+        return SIZE;
+    }
+}
+
+@Test
+public class CheckForIndexOutOfBoundsException {
+
+    List<String> list = new MyList();
+
+
+    @Test
+    public void checkIteratorNext() {
+        var iterator = list.iterator(); // position at start
+        try {
+            for (int i = 0; i <= list.size(); i++) {
+                iterator.next();
+            }
+            fail("Failing checkIteratorNext() - NoSuchElementException should have been thrown");
+        } catch (NoSuchElementException e) {
+            checkAssertOnException(e);
+        }
+    }
+
+    @Test
+    public void checkListIteratorNext() {
+        var iterator = list.listIterator(list.size()); // position at end
+        try {
+            iterator.next();
+            fail("Failing checkListIteratorNext() - NoSuchElementException should have been thrown");
+        } catch (NoSuchElementException e) {
+            checkAssertOnException(e);
+        }
+    }
+
+    @Test
+    public void checkListIteratorPrevious() {
+        var iterator = list.listIterator(0); // position at start
+        try {
+            iterator.previous();
+            fail("Failing checkListIteratorPrevious() - NoSuchElementException should have been thrown");
+        } catch (NoSuchElementException e) {
+            checkAssertOnException(e);
+        }
+    }
+
+    private void checkAssertOnException(NoSuchElementException e) {
+        var cause = e.getCause();
+        assertNotNull(cause, "Exception.getCause()");
+        assertTrue(cause instanceof IndexOutOfBoundsException, "Exception.getCause() should be an " +
+                "IndexOutOfBoundsException");
+        var msg = e.getMessage();
+        assertNotNull(msg, "Exception.getMessage()");
+        assertTrue(msg.contains("IndexOutOfBoundsException"), "Exception.getMessage() should " +
+                "contain the string 'IndexOutOfBoundsException'");
+    }
+}
+
diff --git a/ojluni/src/test/java/util/AbstractList/FailFastIterator.java b/ojluni/src/test/java/util/AbstractList/FailFastIterator.java
new file mode 100644
index 00000000000..c2d27bf8363
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractList/FailFastIterator.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4189896
+ * @summary AbstractList iterators previously checked for co-modification
+ *          *after* the set/add/remove operations were performed.
+ */
+
+package test.java.util.AbstractList;
+
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.List;
+import java.util.ListIterator;
+
+public class FailFastIterator {
+    public static void main(String[] args) throws Exception {
+        List orig = new ArrayList(100);
+        for (int i=0; i<100; i++)
+            orig.add(new Integer(i));
+
+        List copy = new ArrayList(orig);
+        try {
+            ListIterator i = copy.listIterator();
+            i.next();
+            copy.remove(99);
+            copy.add(new Integer(99));
+            i.remove();
+            throw new Exception("remove: iterator didn't fail fast");
+        } catch (ConcurrentModificationException e) {
+        }
+        if (!copy.equals(orig))
+            throw new Exception("remove: iterator didn't fail fast enough");
+
+        try {
+            ListIterator i = copy.listIterator();
+            i.next();
+            copy.remove(99);
+            copy.add(new Integer(99));
+            i.set(new Integer(666));
+            throw new Exception("set: iterator didn't fail fast");
+        } catch (ConcurrentModificationException e) {
+        }
+        if (!copy.equals(orig))
+            throw new Exception("set: iterator didn't fail fast enough");
+
+        try {
+            ListIterator i = copy.listIterator();
+            copy.remove(99);
+            copy.add(new Integer(99));
+            i.add(new Integer(666));
+            throw new Exception("add: iterator didn't fail fast");
+        } catch (ConcurrentModificationException e) {
+        }
+        if (!copy.equals(orig))
+            throw new Exception("add: iterator didn't fail fast enough");
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractList/HasNextAfterException.java b/ojluni/src/test/java/util/AbstractList/HasNextAfterException.java
new file mode 100644
index 00000000000..66a0dd827f1
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractList/HasNextAfterException.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2000, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4375048
+ * @summary AbstractList's ListIterator.hasNext() returns
+ *          true, after ListIterator.previous() causes
+ *          an exception for an empty list.
+ * @author Konstantin Kladko
+ */
+
+package test.java.util.AbstractList;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+public class HasNextAfterException {
+    public static void main(String[] args) {
+        List list = new ArrayList();
+        ListIterator i = list.listIterator();
+        try {
+        i.previous();
+        }
+        catch (NoSuchElementException e) {
+        }
+        if (i.hasNext()) {
+            throw new RuntimeException(
+               "ListIterator.hasNext() returns true for an empty "
+                + "List after ListIterator.previous().");
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java b/ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java
new file mode 100644
index 00000000000..8586fd82eb4
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2000, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4328748
+ * @summary AbstractMap's clone() method is implemented to
+ *  reset AbstractMap's private fields after super.clone()
+ *
+ * @author Konstantin Kladko
+ */
+
+package test.java.util.AbstractMap;
+
+import java.util.AbstractMap;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class AbstractMapClone extends AbstractMap implements Cloneable {
+
+    private Map map = new HashMap();
+
+    public Set entrySet() {
+        return map.entrySet();
+    }
+
+    public Object put(Object key, Object value) {
+        return map.put(key, value);
+    }
+
+    public Object clone() {
+        final AbstractMapClone clone;
+        try {
+            clone = (AbstractMapClone)super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError(e);
+        }
+        clone.map = (Map)((HashMap)map).clone();
+        return clone;
+    }
+
+    public static void main(String[] args) {
+        AbstractMapClone m1 = new AbstractMapClone();
+        m1.put("1", "1");
+        Set k1 = m1.keySet();
+        AbstractMapClone m2 = (AbstractMapClone)m1.clone();
+        Set k2 = m2.keySet();
+        m2.put("2","2");
+        if (k1.equals(k2)) {
+            throw new RuntimeException("AbstractMap.clone() failed.");
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractMap/Equals.java b/ojluni/src/test/java/util/AbstractMap/Equals.java
new file mode 100644
index 00000000000..87493c0589f
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractMap/Equals.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package test.java.util.AbstractMap;
+
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+/**
+ * @test
+ * @bug     4503672
+ * @summary AbstractMap.equals and AbstractSet.equals are fragile: they
+ *          throw exceptions when they should return false.
+ * @author  Josh Bloch
+ */
+public class Equals {
+    public static void main(String[] args) {
+        Map m = new HashMap();
+        m.put(null, "");
+        Map h = new Hashtable();
+        h.put("", "");
+        if (m.equals(h))
+            throw new RuntimeException("1");
+
+        Map m1 = new TreeMap();
+        m1.put(new Integer(42), "The Answer");
+        Map m2 = new TreeMap();
+        m2.put("The Answer", new Integer(42));
+        if (m1.equals(m2))
+            throw new RuntimeException("3");
+
+        Set s1 = new TreeSet();
+        s1.add(new Integer(666));
+        Set s2 = new TreeSet();
+        s2.add("Great googly moogly!");
+        if (s1.equals(s2))
+            throw new RuntimeException("2");
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractMap/SimpleEntries.java b/ojluni/src/test/java/util/AbstractMap/SimpleEntries.java
new file mode 100644
index 00000000000..ac060ab0e3d
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractMap/SimpleEntries.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4904074 6328220 6330389 8308167
+ * @modules java.base/jdk.internal.util
+ * @summary Basic tests for several Map.Entry implementations
+ * @author Martin Buchholz
+ */
+
+package test.java.util.AbstractMap;
+
+import java.util.Map;
+import jdk.internal.util.NullableKeyValueHolder;
+
+import static java.util.AbstractMap.SimpleEntry;
+import static java.util.AbstractMap.SimpleImmutableEntry;
+
+public class SimpleEntries {
+    private static String k = "foo";
+    private static Long v = 1L;
+    private static Long v2 = 2L;
+    private static void realMain(String[] args) throws Throwable {
+        testEntry(new SimpleEntry<String,Long>(k,v));
+        testEntry(new SimpleImmutableEntry<String,Long>(k,v));
+        testEntry(Map.entry(k,v));
+        testEntry(Map.Entry.copyOf(Map.entry(k,v)));
+        testEntry(new NullableKeyValueHolder(k,v));
+        testNullEntry(new SimpleEntry<String,Long>(null,null));
+        testNullEntry(new SimpleImmutableEntry<String,Long>(null,null));
+        testNullEntry(new NullableKeyValueHolder(null,null));
+    }
+
+    private static void testEntry(Map.Entry<String,Long> e) {
+        equal(e.getKey(), k);
+        equal(e.getValue(), v);
+        equal(e, new SimpleEntry<String,Long>(k,v));
+        check(! e.equals(new SimpleEntry<String,Long>(k,v2)));
+        check(! e.equals(null));
+        equal(e, new SimpleImmutableEntry<String,Long>(k,v));
+        equal(e.toString(), k+"="+v);
+        check(e.hashCode() == 101575); // hash("foo") ^ hash(1L)
+        if (e instanceof SimpleEntry) {
+            equal(e.setValue(v2), v);
+            equal(e.getValue(), v2);
+            equal(e.setValue(null), v2);
+            equal(e.getValue(), null);
+        } else {
+            try { e.setValue(v2); fail(); }
+            catch (UnsupportedOperationException t) {}
+            catch (Throwable t) { unexpected(t); }
+        }
+    }
+
+    private static void testNullEntry(Map.Entry<String,Long> e) {
+        equal(e.getKey(), null);
+        equal(e.getValue(), null);
+        equal(e, new SimpleEntry<String,Long>(null, null));
+        equal(e, new SimpleImmutableEntry<String,Long>(null, null));
+        equal(e.toString(), "null=null");
+        check(e.hashCode() == 0);
+        if (e instanceof SimpleEntry) {
+            equal(e.setValue(v), null);
+            equal(e.getValue(), v);
+        } else {
+            try { e.setValue(null); fail(); }
+            catch (UnsupportedOperationException t) {}
+            catch (Throwable t) { unexpected(t); }
+        }
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    static volatile int passed = 0, failed = 0;
+    static void pass() {passed++;}
+    static void fail() {failed++; Thread.dumpStack();}
+    static void fail(String msg) {System.out.println(msg); fail();}
+    static void unexpected(Throwable t) {failed++; t.printStackTrace();}
+    static void check(boolean cond) {if (cond) pass(); else fail();}
+    static void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else fail(x + " not equal to " + y);}
+    public static void main(String[] args) throws Throwable {
+        try {realMain(args);} catch (Throwable t) {unexpected(t);}
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new AssertionError("Some tests failed");}
+}
diff --git a/ojluni/src/test/java/util/AbstractMap/ToString.java b/ojluni/src/test/java/util/AbstractMap/ToString.java
new file mode 100644
index 00000000000..0beec9ee24a
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractMap/ToString.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4486049
+ * @summary toString method fails if size changes in between a call to size
+ *           and an attempt to iterate.
+ * @author Josh Bloch
+ */
+
+package test.java.util.AbstractMap;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class ToString {
+    public static void main(String[] args) {
+        Map m = new LyingMap();
+        if (!m.toString().equals("{}"))
+            throw new RuntimeException(m.toString() + "!= {}");
+
+        m.put("x", "1");
+        if (!m.toString().equals("{x=1}"))
+            throw new RuntimeException(m.toString() + "!= {x=1}");
+
+        m.put("y", "2");
+        if (!m.toString().equals("{x=1, y=2}"))
+            throw new RuntimeException(m.toString() + "!= {x=1, y=2}");
+    }
+}
+
+class LyingMap extends LinkedHashMap {
+    public int size() {
+        return super.size() + 1; // Lies, lies, all lies!
+    }
+}
diff --git a/ojluni/src/test/java/util/AbstractSequentialList/AddAll.java b/ojluni/src/test/java/util/AbstractSequentialList/AddAll.java
new file mode 100644
index 00000000000..ff125e0a2fb
--- /dev/null
+++ b/ojluni/src/test/java/util/AbstractSequentialList/AddAll.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4295163
+ * @summary AddAll(int, Collection) intersperses the Collection with this List.
+ */
+
+package test.java.util.AbstractSequentialList;
+
+import java.util.AbstractSequentialList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.ListIterator;
+
+public class AddAll {
+    public static void main(String[] args) throws Exception {
+        List t = new FooList();
+        t.add("b"); t.add("a"); t.add("r");
+        t.addAll(0, Arrays.asList(new String[] {"f","o","o"}));
+        if (!t.equals(Arrays.asList(new String[] {"f","o","o","b","a","r"})))
+            throw new Exception("addAll is broken");
+    }
+}
+
+class FooList extends AbstractSequentialList {
+    List a = new ArrayList();
+
+    public int size() {
+        return a.size();
+    }
+
+    public ListIterator listIterator(int index) {
+        return a.listIterator(index);
+    }
+}
diff --git a/ojluni/src/test/java/util/Arrays/HashCode.java b/ojluni/src/test/java/util/Arrays/HashCode.java
new file mode 100644
index 00000000000..5e7ee3d84a0
--- /dev/null
+++ b/ojluni/src/test/java/util/Arrays/HashCode.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2022, 2023, Oracle, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @summary Basic array hashCode functionality
+ * @run main/othervm --add-exports java.base/jdk.internal.util=ALL-UNNAMED -Xcomp -Xbatch HashCode
+ */
+
+package test.java.util.Arrays;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+public class HashCode {
+    private static String[] tests = { "", " ", "a", "abcdefg",
+            "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities",
+            "C'tait le meilleur des temps, c'tait le pire des temps, c'tait l'ge de la sagesse, c'tait l'ge de la folie, c'tait l'poque de la croyance, c'tait l'poque de l'incrdulit, c'tait la saison de la Lumire, c'tait C'tait la saison des Tnbres, c'tait le printemps de l'espoir, c'tait l'hiver du dsespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la priode ressemblait tellement  la priode actuelle, que certaines de ses autorits les plus bruyantes ont insist pour qu'elle soit reue, pour le bien ou pour le mal, au degr superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)",
+            ""
+    };
+
+    byte[][] zeroes = new byte[64][];
+    private static byte[][] testBytes = new byte[tests.length][];
+    private static short[][] testShorts = new short[tests.length][];
+    private static char[][] testChars = new char[tests.length][];
+    private static int[][] testInts = new int[tests.length][];
+
+    private static int[] expected = { 1, 63, 128, 536518979, -1174896354, -1357593156, 428276276};
+    private static int[] expectedUnsigned = { 1, 63, 128, 536518979, -1174896354, 584369596, -2025326028};
+
+    public static void main(String[] args) throws Exception {
+
+        // Deep introspection into range-based hash functions
+        Class<?> arraysSupport = Class.forName("jdk.internal.util.ArraysSupport");
+        Method vectorizedHashCode = arraysSupport.getDeclaredMethod("vectorizedHashCode", Object.class, int.class, int.class, int.class, int.class);
+        vectorizedHashCode.setAccessible(true);
+
+        for (int i = 0; i < tests.length; i++) {
+            testBytes[i] = tests[i].getBytes("UTF-8");
+            int len = testBytes[i].length;
+            testChars[i] = new char[len];
+            testShorts[i] = new short[len];
+            testInts[i] = new int[len];
+            for (int j = 0; j < len; j++) {
+                testChars[i][j] = (char) testBytes[i][j];
+                testShorts[i][j] = testBytes[i][j];
+                testInts[i][j] = testBytes[i][j];
+            }
+        }
+
+        boolean failed = false;
+        try {
+            int zeroResult = 1;
+            for (int i = 0; i < 64; i++) {
+                byte[] zeroes = new byte[i];
+                byte[] extraZeroes = new byte[i + 47];
+                for (int j = 0; j < 10_000; j++) {
+                    int hashCode = Arrays.hashCode(zeroes);
+                    if (hashCode != zeroResult) {
+                        throw new RuntimeException("byte[] \"" + Arrays.toString(zeroes) + "\": "
+                                + " e = " + zeroResult
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                    hashCode = (int) vectorizedHashCode.invoke(null, extraZeroes, 17, i, 1, /* ArraysSupport.T_BYTE */ 8);
+                    if (hashCode != zeroResult) {
+                        throw new RuntimeException("byte[] subrange \"" + Arrays.toString(extraZeroes)
+                                + "\" at offset 17, limit " + i + ": "
+                                + " e = " + zeroResult
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                }
+                zeroResult *= 31;
+            }
+            for (int i = 0; i < tests.length; i++) {
+                for (int j = 0; j < 64; j++) {
+                    int e = expected[i];
+                    int hashCode = Arrays.hashCode(testBytes[i]);
+                    if (hashCode != e) {
+                        throw new RuntimeException("byte[] \"" + Arrays.toString(testBytes[i]) + "\": "
+                                + " e = " + e
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                }
+            }
+            System.out.println("byte[] tests passed");
+        } catch (RuntimeException e) {
+            System.out.println(e.getMessage());
+            failed = true;
+        }
+
+        try {
+            for (int i = 0; i < tests.length; i++) {
+                for (int j = 0; j < 64; j++) {
+                    int e = expected[i];
+                    int hashCode = Arrays.hashCode(testShorts[i]);
+                    if (hashCode != e) {
+                        throw new RuntimeException("short[] \"" + Arrays.toString(testShorts[i]) + "\": "
+                                + " e = " + e
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                }
+            }
+            System.out.println("short[] tests passed");
+        } catch (RuntimeException e) {
+            System.out.println(e.getMessage());
+            failed = true;
+        }
+
+        try {
+            for (int i = 0; i < tests.length; i++) {
+                for (int j = 0; j < 64; j++) {
+                    int e = expected[i];
+                    int hashCode = Arrays.hashCode(testInts[i]);
+                    if (hashCode != e) {
+                        throw new RuntimeException("int[] \"" + Arrays.toString(testInts[i]) + "\": "
+                                + " e = " + e
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                }
+            }
+            System.out.println("int[] tests passed");
+        } catch (RuntimeException e) {
+            System.out.println(e.getMessage());
+            failed = true;
+        }
+
+        try {
+            for (int i = 0; i < tests.length; i++) {
+                for (int j = 0; j < 64; j++) {
+                    int e = expectedUnsigned[i];
+                    int hashCode = Arrays.hashCode(testChars[i]);
+                    if (hashCode != e) {
+                        throw new RuntimeException("char[] \"" + Arrays.toString(testChars[i]) + "\": "
+                                + " e = " + e
+                                + ", hashCode = " + hashCode
+                                + ", repetition = " + j);
+                    }
+                }
+            }
+            System.out.println("char[] tests passed");
+        } catch (RuntimeException e) {
+            System.out.println(e.getMessage());
+            failed = true;
+        }
+
+        if (failed) {
+            throw new RuntimeException("Some tests failed");
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/Arrays/TimSortStackSize2.java b/ojluni/src/test/java/util/Arrays/TimSortStackSize2.java
new file mode 100644
index 00000000000..3806d9ecaf5
--- /dev/null
+++ b/ojluni/src/test/java/util/Arrays/TimSortStackSize2.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8072909
+ * @summary Test TimSort stack size on big arrays
+ * @library /test/lib
+ * @modules java.management
+ * @requires (vm.debug == false)
+ * @build TimSortStackSize2
+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox
+ * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *     -XX:+WhiteBoxAPI TimSortStackSize2
+ */
+package test.java.util.Arrays;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Consumer;
+
+// import jdk.test.lib.process.OutputAnalyzer;
+// import jdk.test.lib.process.ProcessTools;
+// import jdk.test.whitebox.WhiteBox;
+
+// Android-changed: test relies on jdk.test.lib.process.
+public class TimSortStackSize2 {
+/*
+    public static void main(String[] args) {
+        if ( args == null || args.length == 0 ){
+            startMeWithArgs();
+        } else {
+            doTestOfTwoTimSorts(Integer.parseInt(args[0]));
+        }
+    }
+
+    private static void startMeWithArgs(){
+        /*
+         * big tests not for regular execution on all platforms:
+         * run main/othervm -Xmx8g TimSortStackSize2 1073741824
+         * run main/othervm -Xmx16g TimSortStackSize2 2147483644
+         *
+        try {
+            Boolean compressedOops = WhiteBox.getWhiteBox()
+                                             .getBooleanVMFlag("UseCompressedOops");
+            long memory = (compressedOops == null || compressedOops) ? 385 : 770;
+            final String xmsValue = "-Xms" +     memory + "m";
+            final String xmxValue = "-Xmx" + 2 * memory + "m";
+
+            System.out.printf("compressedOops: %s; Test will be started with \"%s %s\"%n",
+                              compressedOops, xmsValue, xmxValue);
+            OutputAnalyzer output = ProcessTools.executeTestJava(xmsValue,
+                                                                 xmxValue,
+                                                                 "TimSortStackSize2",
+                                                                 "67108864");
+            System.out.println(output.getOutput());
+            output.shouldHaveExitValue(0);
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static void doTestOfTwoTimSorts(final int lengthOfTest){
+        boolean passed = doTest("TimSort", lengthOfTest,
+            (Integer [] a) -> Arrays.sort(a));
+        passed = doTest("ComparableTimSort", lengthOfTest, (Integer [] a) ->
+            Arrays.sort(a, (Object first, Object second) -> {
+                return ((Comparable<Object>)first).compareTo(second);
+            }))
+            && passed;
+        if ( !passed ){
+            throw new RuntimeException();
+        }
+    }
+
+    private static boolean doTest(final String msg, final int lengthOfTest,
+                                  final  Consumer<Integer[]> c){
+        Integer [] a = null;
+        try {
+            a = new TimSortStackSize2(lengthOfTest).createArray();
+            long begin = System.nanoTime();
+            c.accept(a);
+            long end = System.nanoTime();
+            System.out.println(msg + " OK. Time: " + (end - begin) + "ns");
+        } catch (ArrayIndexOutOfBoundsException e){
+            System.out.println(msg + " broken:");
+            e.printStackTrace();
+            return false;
+        } finally {
+            a = null;
+        }
+        return true;
+    }
+
+    private static final int MIN_MERGE = 32;
+    private final int minRun;
+    private final int length;
+    private final List<Long> runs = new ArrayList<Long>();
+
+    public TimSortStackSize2(final int len) {
+        this.length = len;
+        minRun = minRunLength(len);
+        fillRunsJDKWorstCase();
+    }
+
+    private static int minRunLength(int n) {
+        assert n >= 0;
+        int r = 0;      // Becomes 1 if any 1 bits are shifted off
+        while (n >= MIN_MERGE) {
+            r |= (n & 1);
+            n >>= 1;
+        }
+        return n + r;
+    }
+
+    /**
+     * Adds a sequence x_1, ..., x_n of run lengths to <code>runs</code> such that:<br>
+     * 1. X = x_1 + ... + x_n <br>
+     * 2. x_j >= minRun for all j <br>
+     * 3. x_1 + ... + x_{j-2}  <  x_j  <  x_1 + ... + x_{j-1} for all j <br>
+     * These conditions guarantee that TimSort merges all x_j's one by one
+     * (resulting in X) using only merges on the second-to-last element.
+     * @param X  The sum of the sequence that should be added to runs.
+     *
+    private void generateJDKWrongElem(long X) {
+        for(long newTotal; X >= 2 * minRun + 1; X = newTotal) {
+            //Default strategy
+            newTotal = X / 2 + 1;
+            //Specialized strategies
+            if(3 * minRun + 3 <= X && X <= 4*minRun+1) {
+                // add x_1=MIN+1, x_2=MIN, x_3=X-newTotal  to runs
+                newTotal = 2 * minRun + 1;
+            } else if (5 * minRun + 5 <= X && X <= 6 * minRun + 5) {
+                // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=X-newTotal  to runs
+                newTotal = 3 * minRun + 3;
+            } else if (8 * minRun + 9 <= X && X <= 10 * minRun + 9) {
+                // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=X-newTotal  to runs
+                newTotal = 5 * minRun + 5;
+            } else if (13 * minRun + 15 <= X && X <= 16 * minRun + 17) {
+                // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=3MIN+4, x_6=X-newTotal  to runs
+                newTotal = 8 * minRun + 9;
+            }
+            runs.add(0, X - newTotal);
+        }
+        runs.add(0, X);
+    }
+
+    /**
+     * Fills <code>runs</code> with a sequence of run lengths of the form<br>
+     * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>
+     * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>
+     * ... <br>
+     * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>
+     * The Y_i's are chosen to satisfy the invariant throughout execution,
+     * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)
+     * into an X_i that violates the invariant.
+     * X is the sum of all run lengths that will be added to <code>runs</code>.
+     *
+    private void fillRunsJDKWorstCase() {
+        long runningTotal = 0;
+        long Y = minRun + 4;
+        long X = minRun;
+
+        while (runningTotal + Y + X <= length) {
+            runningTotal += X + Y;
+            generateJDKWrongElem(X);
+            runs.add(0, Y);
+
+            // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}
+            X = Y + runs.get(1) + 1;
+
+            // Y_{i+1} = X_{i+1} + Y_i + 1
+            Y += X + 1;
+        }
+
+        if (runningTotal + X <= length) {
+            runningTotal += X;
+            generateJDKWrongElem(X);
+        }
+
+        runs.add(length - runningTotal);
+    }
+
+    private Integer [] createArray() {
+        Integer [] a = new Integer[length];
+        Arrays.fill(a, 0);
+        int endRun = -1;
+        for (long len : runs) {
+            a[endRun += len] = 1;
+        }
+        a[length - 1] = 0;
+        return a;
+    }
+*/
+}
diff --git a/ojluni/src/test/java/util/Collection/MOAT.java b/ojluni/src/test/java/util/Collection/MOAT.java
index 6f2e1365d40..60734b496e6 100644
--- a/ojluni/src/test/java/util/Collection/MOAT.java
+++ b/ojluni/src/test/java/util/Collection/MOAT.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -138,9 +138,13 @@ public class MOAT {
         testMap(Collections.synchronizedNavigableMap(new TreeMap<Integer,Integer>()));
 
         // Unmodifiable wrappers
-        testImmutableSet(unmodifiableSet(new HashSet<>(Arrays.asList(1,2,3))));
+        testImmutableSet(unmodifiableSet(new HashSet<>(Arrays.asList(1,2,3))), 99);
         testImmutableList(unmodifiableList(Arrays.asList(1,2,3)));
         testImmutableMap(unmodifiableMap(Collections.singletonMap(1,2)));
+        testImmutableSeqColl(unmodifiableSequencedCollection(Arrays.asList(1,2,3)), 99);
+        testImmutableSeqColl(unmodifiableSequencedSet(new LinkedHashSet<>(Arrays.asList(1,2,3))), 99);
+        var lhm = new LinkedHashMap<Integer,Integer>(); lhm.put(1,2); lhm.put(3, 4);
+        testImmutableSeqMap(unmodifiableSequencedMap(lhm));
         testCollMutatorsAlwaysThrow(unmodifiableSet(new HashSet<>(Arrays.asList(1,2,3))));
         testCollMutatorsAlwaysThrow(unmodifiableSet(Collections.emptySet()));
         testEmptyCollMutatorsAlwaysThrow(unmodifiableSet(Collections.emptySet()));
@@ -170,7 +174,7 @@ public class MOAT {
         testEmptySet(Collections.emptySet());
         testEmptySet(Collections.emptySortedSet());
         testEmptySet(Collections.emptyNavigableSet());
-        testImmutableSet(emptySet);
+        testImmutableSet(emptySet, 99);
 
         List<Integer> emptyList = emptyList();
         testCollection(emptyList);
@@ -195,7 +199,7 @@ public class MOAT {
         Set<Integer> singletonSet = singleton(1);
         equal(singletonSet.size(), 1);
         testCollection(singletonSet);
-        testImmutableSet(singletonSet);
+        testImmutableSet(singletonSet, 99);
 
         List<Integer> singletonList = singletonList(1);
         equal(singletonList.size(), 1);
@@ -323,20 +327,20 @@ public class MOAT {
                 Set.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                 Set.of(integerArray))) {
             testCollection(set);
-            testImmutableSet(set);
+            testImmutableSet(set, 99);
             testCollMutatorsAlwaysThrow(set);
         }
 
         Set<Integer> setCopy = Set.copyOf(Arrays.asList(1, 2, 3));
         testCollection(setCopy);
-        testImmutableSet(setCopy);
+        testImmutableSet(setCopy, 99);
         testCollMutatorsAlwaysThrow(setCopy);
 
         Set<Integer> setCollected = Stream.of(1, 1, 2, 3, 2, 3)
                                           .collect(Collectors.toUnmodifiableSet());
         equal(setCollected, Set.of(1, 2, 3));
         testCollection(setCollected);
-        testImmutableSet(setCollected);
+        testImmutableSet(setCollected, 99);
         testCollMutatorsAlwaysThrow(setCollected);
 
         // Immutable Map
@@ -463,12 +467,12 @@ public class MOAT {
             testEmptyIterator(((NavigableSet<T>)c).descendingIterator());
     }
 
-    private static void testImmutableCollection(final Collection<Integer> c) {
+    private static <T> void testImmutableCollection(final Collection<T> c, T t) {
         THROWS(UnsupportedOperationException.class,
-               () -> c.add(99),
-               () -> c.addAll(singleton(99)));
+               () -> c.add(t),
+               () -> c.addAll(singleton(t)));
         if (! c.isEmpty()) {
-            final Integer first = c.iterator().next();
+            final T first = c.iterator().next();
             THROWS(UnsupportedOperationException.class,
                    () -> c.clear(),
                    () -> c.remove(first),
@@ -477,13 +481,36 @@ public class MOAT {
         }
     }
 
-    private static void testImmutableSet(final Set<Integer> c) {
-        testImmutableCollection(c);
+    private static <T> void testImmutableSeqColl(final SequencedCollection<T> c, T t) {
+        SequencedCollection<T> r = c.reversed();
+        testImmutableCollection(c, t);
+        testImmutableCollection(r, t);
+        THROWS(UnsupportedOperationException.class,
+               () -> c.addFirst(t),
+               () -> c.addLast(t),
+               () -> r.addFirst(t),
+               () -> r.addLast(t));
+        if (! c.isEmpty()) {
+            THROWS(UnsupportedOperationException.class,
+                   () -> c.removeFirst(),
+                   () -> c.removeLast(),
+                   () -> r.removeFirst(),
+                   () -> r.removeLast());
+        }
+    }
+
+    private static <T> void testImmutableSet(final Set<T> c, T t) {
+        testImmutableCollection(c, t);
+    }
+
+    private static <T> void testImmutableSeqSet(final SequencedSet<T> c, T t) {
+        testImmutableSeqColl(c, t);
     }
 
     private static void testImmutableList(final List<Integer> c) {
         testList(c);
-        testImmutableCollection(c);
+        testImmutableCollection(c, 42);
+        testImmutableSeqColl(c, 42);
         THROWS(UnsupportedOperationException.class,
                () -> c.set(0,42),
                () -> c.add(0,42),
@@ -607,6 +634,15 @@ public class MOAT {
         check(! m.containsKey(1));
     }
 
+    private static void testImmutableMapEntry(final Map.Entry<Integer,Integer> me) {
+        Integer key = me.getKey();
+        Integer val = me.getValue();
+        THROWS(UnsupportedOperationException.class,
+               () -> me.setValue(3));
+        equal(key, me.getKey());
+        equal(val, me.getValue());
+    }
+
     private static void testImmutableMap(final Map<Integer,Integer> m) {
         THROWS(UnsupportedOperationException.class,
                () -> m.put(1,1),
@@ -616,18 +652,39 @@ public class MOAT {
             THROWS(UnsupportedOperationException.class,
                    () -> m.remove(first),
                    () -> m.clear());
-            final Map.Entry<Integer,Integer> me
-                = m.entrySet().iterator().next();
-            Integer key = me.getKey();
-            Integer val = me.getValue();
+            testImmutableMapEntry(m.entrySet().iterator().next());
+        }
+        testImmutableSet(m.keySet(), 99);
+        testImmutableCollection(m.values(), 99);
+        testImmutableSet(m.entrySet(), Map.entry(42, 43));
+    }
+
+    private static void testImmutableSeqMap(final SequencedMap<Integer,Integer> m) {
+        SequencedMap<Integer,Integer> r = m.reversed();
+        testImmutableMap(m);
+        testImmutableMap(r);
+        THROWS(UnsupportedOperationException.class,
+               () -> m.putFirst(0, 0),
+               () -> m.putLast(0, 0),
+               () -> r.putFirst(0, 0),
+               () -> r.putLast(0, 0));
+        if (! m.isEmpty()) {
             THROWS(UnsupportedOperationException.class,
-                   () -> me.setValue(3));
-            equal(key, me.getKey());
-            equal(val, me.getValue());
+                   () -> m.pollFirstEntry(),
+                   () -> m.pollLastEntry(),
+                   () -> r.pollFirstEntry(),
+                   () -> r.pollLastEntry());
+            testImmutableMapEntry(m.sequencedEntrySet().getFirst());
+            testImmutableMapEntry(r.sequencedEntrySet().getFirst());
+            testImmutableMapEntry(m.sequencedEntrySet().reversed().getFirst());
+            testImmutableMapEntry(r.sequencedEntrySet().reversed().getFirst());
         }
-        testImmutableSet(m.keySet());
-        testImmutableCollection(m.values());
-        //testImmutableSet(m.entrySet());
+        testImmutableSeqSet(m.sequencedKeySet(), 99);
+        testImmutableSeqColl(m.sequencedValues(), 99);
+        testImmutableSeqSet(m.sequencedEntrySet(), Map.entry(42, 43));
+        testImmutableSeqSet(r.sequencedKeySet(), 99);
+        testImmutableSeqColl(r.sequencedValues(), 99);
+        testImmutableSeqSet(r.sequencedEntrySet(), Map.entry(42, 43));
     }
 
     private static void clear(Map<?,?> m) {
diff --git a/ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java b/ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java
index bf055b66d32..421c9cade52 100644
--- a/ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java
+++ b/ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018 Google Inc. All rights reserved.
+ * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -197,4 +198,29 @@ public class DelegatingIteratorForEachRemaining {
         Class clazz = entrySet.iterator().next().getClass();
         assertThrowingIterator(Collections.checkedSet(entrySet, clazz).iterator());
     }
+
+    /**
+     * Calls Collections.unmodifiableMap().entrySet().iterator().forEachRemaining() by passing
+     * that method a {@code null} action and expects that call to fail with a
+     * {@code NullPointerException}.
+     */
+    @Test
+    public void testUnmodifiableForEachRemainingNPE() {
+        final Iterator<?> it = Collections.unmodifiableMap(Map.of()).entrySet().iterator();
+        // pass null action and expect a NPE
+        Assert.assertThrows(NullPointerException.class, () -> it.forEachRemaining(null));
+    }
+
+    /**
+     * Calls Collections.checkedMap().entrySet().iterator().forEachRemaining() by passing
+     * that method a {@code null} action and expects that call to fail with a
+     * {@code NullPointerException}.
+     */
+    @Test
+    public void testCheckedMapForEachRemainingNPE() {
+        final Iterator<?> it = Collections.checkedMap(Map.of(), String.class,
+                String.class).entrySet().iterator();
+        // pass null "action" and expect it to fail with NPE
+        Assert.assertThrows(NullPointerException.class, () -> it.forEachRemaining(null));
+    }
 }
diff --git a/ojluni/src/test/java/util/Collections/RacingCollections.java b/ojluni/src/test/java/util/Collections/RacingCollections.java
index 81c4a513595..3cef487ed76 100644
--- a/ojluni/src/test/java/util/Collections/RacingCollections.java
+++ b/ojluni/src/test/java/util/Collections/RacingCollections.java
@@ -362,7 +362,20 @@ public class RacingCollections {
 
     //--------------------- Infrastructure ---------------------------
     static volatile int passed = 0, failed = 0;
-    static void pass() {passed++;}
+    // Android-changed: Add more logs for http://b/349042322
+    // static void pass() {passed++;}
+    static volatile long lastLogTimeMs = Long.MIN_VALUE;
+    static void pass() {
+        passed++;
+        long currentTimeMs = System.currentTimeMillis();
+        long lastMs = lastLogTimeMs;
+        // For simplicity, it's okay that we log more than once in 10 seconds due to race.
+        // For reference, on cuttlefish x86_64, the test finishes in 3 seconds.
+        if (currentTimeMs - lastMs >= 10000 /* 10 seconds */) {
+            lastLogTimeMs = currentTimeMs;
+            System.logI("RacingCollections counter pass: " + passed + " failures: " + failed);
+        }
+    }
     static void fail() {failed++; Thread.dumpStack();}
     static void fail(String msg) {System.out.println(msg); fail();}
     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
diff --git a/ojluni/src/test/java/util/Collections/Wrappers.java b/ojluni/src/test/java/util/Collections/Wrappers.java
index 5b8aff4d3f7..875dce45144 100644
--- a/ojluni/src/test/java/util/Collections/Wrappers.java
+++ b/ojluni/src/test/java/util/Collections/Wrappers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,14 +35,13 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Objects;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 import org.testng.annotations.Test;
 import org.testng.annotations.DataProvider;
 
-import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
 
 @Test(groups = "unit")
 public class Wrappers {
@@ -68,9 +67,11 @@ public class Wrappers {
         }
 
         cases.add(new Object[] { Collections.unmodifiableCollection(seedList) });
+        cases.add(new Object[] { Collections.unmodifiableSequencedCollection(seedList) });
         cases.add(new Object[] { Collections.unmodifiableList(seedList) });
         cases.add(new Object[] { Collections.unmodifiableList(seedRandomAccess) });
         cases.add(new Object[] { Collections.unmodifiableSet(seedSet) });
+        cases.add(new Object[] { Collections.unmodifiableSequencedSet(seedSet) });
         cases.add(new Object[] { Collections.unmodifiableSortedSet(seedSet) });
         cases.add(new Object[] { Collections.unmodifiableNavigableSet(seedSet) });
 
@@ -79,6 +80,24 @@ public class Wrappers {
         cases.add(new Object[] { Collections.unmodifiableMap(seedMap).entrySet() });
         cases.add(new Object[] { Collections.unmodifiableMap(seedMap).keySet() });
         cases.add(new Object[] { Collections.unmodifiableMap(seedMap).values() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).entrySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).keySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).values() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().entrySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().keySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().values() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet().reversed() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet().reversed() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues().reversed() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet().reversed() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet().reversed() });
+        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues().reversed() });
         cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).entrySet() });
         cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).keySet() });
         cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).values() });
@@ -138,11 +157,14 @@ public class Wrappers {
     @Test(dataProvider = "collections")
     public static void testAllDefaultMethodsOverridden(Collection c) throws NoSuchMethodException {
         Class cls = c.getClass();
+        var notOverridden = new ArrayList<Method>();
         for (Method m: defaultMethods) {
             Method m2 = cls.getMethod(m.getName(), m.getParameterTypes());
-            // default had been override
-            assertFalse(m2.isDefault(), cls.getCanonicalName());
+            if (m2.isDefault()) {
+                notOverridden.add(m);
+            }
         }
+        assertTrue(notOverridden.isEmpty(), cls.getName() + " does not override " + notOverridden);
     }
 }
 
diff --git a/ojluni/src/test/java/util/Comparator/BasicTest.java b/ojluni/src/test/java/util/Comparator/BasicTest.java
new file mode 100644
index 00000000000..7eab4da6e67
--- /dev/null
+++ b/ojluni/src/test/java/util/Comparator/BasicTest.java
@@ -0,0 +1,395 @@
+/*
+ * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8171826
+ * @summary Comparator default method tests
+ * @run testng BasicTest
+ */
+
+package test.java.util.Comparator;
+
+import org.testng.annotations.Test;
+
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.function.Function;
+import java.util.function.ToDoubleFunction;
+import java.util.function.ToIntFunction;
+import java.util.function.ToLongFunction;
+
+import static org.testng.Assert.*;
+
+@Test(groups = "unit")
+public class BasicTest {
+    private static class Thing {
+        public final int intField;
+        public final long longField;
+        public final double doubleField;
+        public final String stringField;
+
+        private Thing(int intField, long longField, double doubleField, String stringField) {
+            this.intField = intField;
+            this.longField = longField;
+            this.doubleField = doubleField;
+            this.stringField = stringField;
+        }
+
+        public int getIntField() {
+            return intField;
+        }
+
+        public long getLongField() {
+            return longField;
+        }
+
+        public double getDoubleField() {
+            return doubleField;
+        }
+
+        public String getStringField() {
+            return stringField;
+        }
+    }
+
+    private final int[] intValues = { -2, -2, -1, -1, 0, 0, 1, 1, 2, 2 };
+    private final long[] longValues = { -2, -2, -1, -1, 0, 0, 1, 1, 2, 2 };
+    private final double[] doubleValues = { -2, -2, -1, -1, 0, 0, 1, 1, 2, 2 };
+    private final String[] stringValues = { "a", "a", "b", "b", "c", "c", "d", "d", "e", "e" };
+    private final int[] comparisons = { 0, -1, 0, -1, 0, -1, 0, -1, 0 };
+
+    private<T> void assertComparisons(T[] things, Comparator<T> comp, int[] comparisons) {
+        for (int i=0; i<comparisons.length; i++) {
+            assertEquals(comparisons.length + 1, things.length);
+            assertEquals(comparisons[i], comp.compare(things[i], things[i+1]));
+            assertEquals(-comparisons[i], comp.compare(things[i+1], things[i]));
+        }
+    }
+
+    public void testIntComparator() {
+        Thing[] things = new Thing[intValues.length];
+        for (int i=0; i<intValues.length; i++)
+            things[i] = new Thing(intValues[i], 0L, 0.0, null);
+        Comparator<Thing> comp = Comparator.comparingInt(new ToIntFunction<Thing>() {
+            @Override
+            public int applyAsInt(Thing thing) {
+                return thing.getIntField();
+            }
+        });
+
+        assertComparisons(things, comp, comparisons);
+    }
+
+    public void testLongComparator() {
+        Thing[] things = new Thing[longValues.length];
+        for (int i=0; i<longValues.length; i++)
+            things[i] = new Thing(0, longValues[i], 0.0, null);
+        Comparator<Thing> comp = Comparator.comparingLong(new ToLongFunction<Thing>() {
+            @Override
+            public long applyAsLong(Thing thing) {
+                return thing.getLongField();
+            }
+        });
+
+        assertComparisons(things, comp, comparisons);
+    }
+
+    public void testDoubleComparator() {
+        Thing[] things = new Thing[doubleValues.length];
+        for (int i=0; i<doubleValues.length; i++)
+            things[i] = new Thing(0, 0L, doubleValues[i], null);
+        Comparator<Thing> comp = Comparator.comparingDouble(new ToDoubleFunction<Thing>() {
+            @Override
+            public double applyAsDouble(Thing thing) {
+                return thing.getDoubleField();
+            }
+        });
+
+        assertComparisons(things, comp, comparisons);
+    }
+
+    public void testComparing() {
+        Thing[] things = new Thing[doubleValues.length];
+        for (int i=0; i<doubleValues.length; i++)
+            things[i] = new Thing(0, 0L, 0.0, stringValues[i]);
+        Comparator<Thing> comp = Comparator.comparing(new Function<Thing, String>() {
+            @Override
+            public String apply(Thing thing) {
+                return thing.getStringField();
+            }
+        });
+
+        assertComparisons(things, comp, comparisons);
+    }
+
+    public void testNaturalOrderComparator() {
+        Comparator<String> comp = Comparator.naturalOrder();
+
+        assertComparisons(stringValues, comp, comparisons);
+    }
+
+    public void testReverseComparator() {
+        Comparator<String> cmpr = Comparator.reverseOrder();
+        Comparator<String> cmp = cmpr.reversed();
+
+        assertEquals(cmp.reversed(), cmpr);
+        assertEquals(0, cmp.compare("a", "a"));
+        assertEquals(0, cmpr.compare("a", "a"));
+        assertTrue(cmp.compare("a", "b") < 0);
+        assertTrue(cmpr.compare("a", "b") > 0);
+        assertTrue(cmp.compare("b", "a") > 0);
+        assertTrue(cmpr.compare("b", "a") < 0);
+    }
+
+    public void testReverseComparator2() {
+        Comparator<String> cmp = (s1, s2) -> s1.length() - s2.length();
+        Comparator<String> cmpr = cmp.reversed();
+
+        assertEquals(cmpr.reversed(), cmp);
+        assertEquals(0, cmp.compare("abc", "def"));
+        assertEquals(0, cmpr.compare("abc", "def"));
+        assertTrue(cmp.compare("abcd", "def") > 0);
+        assertTrue(cmpr.compare("abcd", "def") < 0);
+        assertTrue(cmp.compare("abc", "defg") < 0);
+        assertTrue(cmpr.compare("abc", "defg") > 0);
+    }
+
+    private <T> void assertComparison(Comparator<T> cmp, T less, T greater) {
+        assertTrue(cmp.compare(less, greater) < 0, "less");
+        assertTrue(cmp.compare(less, less) == 0, "equal");
+        assertTrue(cmp.compare(greater, greater) == 0, "equal");
+        assertTrue(cmp.compare(greater, less) > 0, "greater");
+    }
+
+    private static class People {
+        final String firstName;
+        final String lastName;
+        final int age;
+
+        People(String first, String last, int age) {
+            firstName = first;
+            lastName = last;
+            this.age = age;
+        }
+
+        String getFirstName() { return firstName; }
+        String getLastName() { return lastName; }
+        int getAge() { return age; }
+        long getAgeAsLong() { return (long) age; };
+        double getAgeAsDouble() { return (double) age; };
+    }
+
+    private final People people[] = {
+        new People("John", "Doe", 34),
+        new People("Mary", "Doe", 30),
+        new People("Maria", "Doe", 14),
+        new People("Jonah", "Doe", 10),
+        new People("John", "Cook", 54),
+        new People("Mary", "Cook", 50),
+        new People("Mary", null, 25),
+        new People("John", null, 27)
+    };
+
+    public void testComparatorDefaultMethods() {
+        Comparator<People> cmp = Comparator.comparing(People::getFirstName);
+        Comparator<People> cmp2 = Comparator.comparing(People::getLastName);
+        // reverseOrder
+        assertComparison(cmp.reversed(), people[1], people[0]);
+        // thenComparing(Comparator)
+        assertComparison(cmp.thenComparing(cmp2), people[0], people[1]);
+        assertComparison(cmp.thenComparing(cmp2), people[4], people[0]);
+        // thenComparing(Function)
+        assertComparison(cmp.thenComparing(People::getLastName), people[0], people[1]);
+        assertComparison(cmp.thenComparing(People::getLastName), people[4], people[0]);
+        // thenComparing(ToIntFunction)
+        assertComparison(cmp.thenComparingInt(People::getAge), people[0], people[1]);
+        assertComparison(cmp.thenComparingInt(People::getAge), people[1], people[5]);
+        // thenComparing(ToLongFunction)
+        assertComparison(cmp.thenComparingLong(People::getAgeAsLong), people[0], people[1]);
+        assertComparison(cmp.thenComparingLong(People::getAgeAsLong), people[1], people[5]);
+        // thenComparing(ToDoubleFunction)
+        assertComparison(cmp.thenComparingDouble(People::getAgeAsDouble), people[0], people[1]);
+        assertComparison(cmp.thenComparingDouble(People::getAgeAsDouble), people[1], people[5]);
+    }
+
+
+    public void testNullsFirst() {
+        Comparator<String> strcmp = Comparator.nullsFirst(Comparator.naturalOrder());
+        Comparator<People> cmp = Comparator.comparing(People::getLastName, strcmp)
+                                           .thenComparing(People::getFirstName, strcmp);
+        // Mary.null vs Mary.Cook - solve by last name
+        assertComparison(cmp, people[6], people[5]);
+        // John.null vs Mary.null - solve by first name
+        assertComparison(cmp, people[7], people[6]);
+
+        // More than one thenComparing
+        strcmp = Comparator.nullsFirst(Comparator.comparingInt(String::length)
+                                                 .thenComparing(String.CASE_INSENSITIVE_ORDER));
+        assertComparison(strcmp, null, "abc");
+        assertComparison(strcmp, "ab", "abc");
+        assertComparison(strcmp, "abc", "def");
+        assertEquals(0, strcmp.compare("abc", "ABC"));
+
+        // Ensure reverse still handle null properly
+        Comparator<String> strcmp2 = strcmp.reversed().thenComparing(Comparator.naturalOrder());
+        assertComparison(strcmp2, "abc", null);
+        assertComparison(strcmp2, "abc", "ab");
+        assertComparison(strcmp2, "def", "abc");
+        assertComparison(strcmp2, "ABC", "abc");
+
+        // Considering non-null values to be equal
+        Comparator<String> blind = Comparator.nullsFirst(null);
+        assertComparison(blind, null, "abc");
+        assertEquals(0, blind.compare("abc", "def"));
+        // reverse still consider non-null values to be equal
+        strcmp = blind.reversed();
+        assertComparison(strcmp, "abc", null);
+        assertEquals(0, strcmp.compare("abc", "def"));
+        // chain with another comparator to compare non-nulls
+        strcmp = blind.thenComparing(Comparator.naturalOrder());
+        assertComparison(strcmp, null, "abc");
+        assertComparison(strcmp, "abc", "def");
+    }
+
+    public void testNullsLast() {
+        Comparator<String> strcmp = Comparator.nullsLast(Comparator.naturalOrder());
+        Comparator<People> cmp = Comparator.comparing(People::getLastName, strcmp)
+                                           .thenComparing(People::getFirstName, strcmp);
+        // Mary.null vs Mary.Cook - solve by last name
+        assertComparison(cmp, people[5], people[6]);
+        // John.null vs Mary.null - solve by first name
+        assertComparison(cmp, people[7], people[6]);
+
+        // More than one thenComparing
+        strcmp = Comparator.nullsLast(Comparator.comparingInt(String::length)
+                                                .thenComparing(String.CASE_INSENSITIVE_ORDER));
+        assertComparison(strcmp, "abc", null);
+        assertComparison(strcmp, "ab", "abc");
+        assertComparison(strcmp, "abc", "def");
+
+        // Ensure reverse still handle null properly
+        Comparator<String> strcmp2 = strcmp.reversed().thenComparing(Comparator.naturalOrder());
+        assertComparison(strcmp2, null, "abc");
+        assertComparison(strcmp2, "abc", "ab");
+        assertComparison(strcmp2, "def", "abc");
+        assertComparison(strcmp2, "ABC", "abc");
+
+        // Considering non-null values to be equal
+        Comparator<String> blind = Comparator.nullsLast(null);
+        assertComparison(blind, "abc", null);
+        assertEquals(0, blind.compare("abc", "def"));
+        // reverse still consider non-null values to be equal
+        strcmp = blind.reversed();
+        assertComparison(strcmp, null, "abc");
+        assertEquals(0, strcmp.compare("abc", "def"));
+        // chain with another comparator to compare non-nulls
+        strcmp = blind.thenComparing(Comparator.naturalOrder());
+        assertComparison(strcmp, "abc", null);
+        assertComparison(strcmp, "abc", "def");
+    }
+
+    public void testComposeComparator() {
+        // Longer string in front
+        Comparator<String> first = (s1, s2) -> s2.length() - s1.length();
+        Comparator<String> second = Comparator.naturalOrder();
+        Comparator<String> composed = first.thenComparing(second);
+
+        assertTrue(composed.compare("abcdefg", "abcdef") < 0);
+        assertTrue(composed.compare("abcdef", "abcdefg") > 0);
+        assertTrue(composed.compare("abcdef", "abcdef") == 0);
+        assertTrue(composed.compare("abcdef", "ghijkl") < 0);
+        assertTrue(composed.compare("ghijkl", "abcdefg") > 0);
+    }
+
+    public void testNulls() {
+        try {
+            Comparator.<String>naturalOrder().compare("abc", (String) null);
+            fail("expected NPE with naturalOrder");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator.<String>naturalOrder().compare((String) null, "abc");
+            fail("expected NPE with naturalOrder");
+        } catch (NullPointerException npe) {}
+
+        try {
+            Comparator.<String>reverseOrder().compare("abc", (String) null);
+            fail("expected NPE with naturalOrder");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator.<String>reverseOrder().compare((String) null, "abc");
+            fail("expected NPE with naturalOrder");
+        } catch (NullPointerException npe) {}
+
+        try {
+            Comparator<People> cmp = Comparator.comparing(null, Comparator.<String>naturalOrder());
+            fail("comparing(null, cmp) should throw NPE");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator<People> cmp = Comparator.comparing(People::getFirstName, null);
+            fail("comparing(f, null) should throw NPE");
+        } catch (NullPointerException npe) {}
+
+        try {
+            Comparator<People> cmp = Comparator.comparing(null);
+            fail("comparing(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator<People> cmp = Comparator.comparingInt(null);
+            fail("comparing(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator<People> cmp = Comparator.comparingLong(null);
+            fail("comparing(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+        try {
+            Comparator<People> cmp = Comparator.comparingDouble(null);
+            fail("comparing(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+    }
+
+    public void testNaturalAndReverseIdentity() {
+        var naturalOrder = Comparator.<String>naturalOrder();
+        var reverseOrder = Comparator.<String>reverseOrder();
+
+        assertEquals(
+                naturalOrder,
+                Collections.reverseOrder(reverseOrder),
+                "Comparator.naturalOrder() and Collections.reverseOrder(Comparator.reverseOrder()) not equal");
+
+        assertEquals(
+                reverseOrder,
+                Collections.reverseOrder(naturalOrder),
+                "Comparator.reverseOrder() and Collections.reverseOrder(Comparator.naturalOrder()) not equal");
+
+        assertEquals(
+                naturalOrder.reversed(),
+                reverseOrder,
+                "Comparator.naturalOrder().reversed() amd Comparator.reverseOrder() not equal");
+
+        assertEquals(
+                reverseOrder.reversed(),
+                naturalOrder,
+                "Comparator.reverseOrder().reversed() and Comparator.naturalOrder() not equal");
+    }
+}
diff --git a/ojluni/src/test/java/util/Comparator/TypeTest.java b/ojluni/src/test/java/util/Comparator/TypeTest.java
new file mode 100644
index 00000000000..3ecccf8c8b3
--- /dev/null
+++ b/ojluni/src/test/java/util/Comparator/TypeTest.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @summary Comparator API narrowing type test
+ * @bug 8009736 8033590
+ * @run testng TypeTest
+ */
+
+package test.java.util.Comparator;
+
+import java.util.function.Function;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.Comparator;
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertTrue;
+
+@Test(groups = "unit")
+public class TypeTest {
+    static class Person {
+        String name;
+        static Comparator<Person> C = (p1, p2) -> p1.name.compareTo(p2.name);
+
+        Person(String name) {
+            this.name = name;
+        }
+
+        String getName() { return name; }
+    }
+
+    static class Employee extends Person {
+        int id;
+        static Comparator<Employee> C = (e1, e2) -> e1.id - e2.id;
+
+        Employee(int id, String name) {
+            super(name);
+            this.id = id;
+        }
+    }
+
+    static class Manager extends Employee {
+        long reports;
+        static Comparator<Manager> C = (e1, e2) -> (int) (e1.reports - e2.reports);
+
+        Manager(String name, int id, long reports) {
+            super(id, name);
+            this.reports = reports;
+        }
+    }
+
+    static class Department {
+        Manager mgr;
+        String hr_code;
+
+        Department(Manager mgr, String hr) {
+            this.mgr = mgr;
+            this.hr_code = hr;
+        }
+
+        Manager getManager() {
+            return mgr;
+        }
+
+        String getHR() {
+            return hr_code;
+        }
+    }
+
+    static <T> void assertOrder(T o1, T o2, Comparator<? super T> cmp) {
+        if (cmp.compare(o1, o2) > 0) {
+            System.out.println("Fail!!");
+        }
+        if (cmp.compare(o1, o2) == 0) {
+            System.out.println("Equal!!");
+        }
+    }
+
+    // Type tests just to make sure the code can compile and build
+    // Not necessarily need a meaningful result
+    public void testOrder() {
+        Manager m1 = new Manager("Manager", 2, 2000);
+        Manager m2 = new Manager("Manager", 4, 1300);
+
+        // Comparator<Employee> tmp = Person.C;
+
+        // Comparator<Manager> cmp = Employee.C.thenComparing(Person.C);
+        Comparator<Employee> cmp = Employee.C.thenComparing(Person.C);
+        assertOrder(m1, m2, Employee.C.thenComparing(Person.C));
+        assertOrder(m1, m2, cmp);
+        assertOrder(m1, new Employee(1, "Z"), Person.C);
+        assertOrder(new Employee(1, "Z"), m2, Employee.C);
+
+        assertOrder(m1, m2, Comparator.comparing(Employee::getName, String.CASE_INSENSITIVE_ORDER));
+
+        Map<String, Integer> map = new TreeMap<>();
+        map.entrySet().stream().sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER));
+    }
+
+    public void testJDK8033590() {
+        Manager a = new Manager("John Doe", 1234, 16);
+        Manager b = new Manager("Jane Roe", 2468, 16);
+        Department da = new Department(a, "X");
+        Department db = new Department(b, "X");
+
+        Comparator<Department> cmp = Comparator.comparing(Department::getHR)
+                .thenComparing(Department::getManager, Employee.C);
+        assertTrue(cmp.compare(da, db) < 0);
+
+        cmp = Comparator.comparing(Department::getHR)
+                .thenComparing(Department::getManager, Manager.C);
+        assertTrue(cmp.compare(da, db) == 0);
+
+        cmp = Comparator.comparing(Department::getHR)
+                .thenComparing(Department::getManager, Person.C);
+        assertTrue(cmp.compare(da, db) > 0);
+    }
+}
diff --git a/ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java b/ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java
index 3bf5b387c52..e0fe0080e1e 100644
--- a/ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java
+++ b/ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java
@@ -98,8 +98,14 @@ public class CompensatedSums {
         }
 
         Assert.assertTrue(jdkParallelStreamError <= goodParallelStreamError);
-        // Android-removed: due to limited number of iterations this check might
+        // Android-added: due to limited number of iterations this check might
         // occasionally fail (b/284693092).
+        /*
+         * Due to floating-point addition being inherently non-associative,
+         * and due to the unpredictable scheduling of the threads used
+         * in parallel streams, this assertion can fail intermittently,
+         * hence is suppressed for now.
+         */
         // Assert.assertTrue(badParallelStreamError >= jdkParallelStreamError);
 
         Assert.assertTrue(goodSequentialStreamError >= jdkSequentialStreamError);
@@ -153,4 +159,4 @@ public class CompensatedSums {
                 ll[2] += rr[2];
             };
 
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java b/ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java
index 6c310d1659f..52f82dc8ffa 100644
--- a/ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java
+++ b/ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java
@@ -38,14 +38,10 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class DistinctEntrySetElements {
     static enum TestEnum { e00, e01, e02 }
 
-    @Test
-    public void testDistinctElements() {
+    public static void main(String[] args) throws Exception {
         final EnumMap<TestEnum, String> enumMap = new EnumMap<>(TestEnum.class);
 
         for (TestEnum e : TestEnum.values()) {
@@ -55,7 +51,11 @@ public class DistinctEntrySetElements {
         Set<Map.Entry<TestEnum, String>> entrySet = enumMap.entrySet();
         HashSet<Map.Entry<TestEnum, String>> hashSet = new HashSet<>(entrySet);
 
-        Assert.assertTrue(hashSet.equals(entrySet));
-        Assert.assertEquals(hashSet.hashCode(), entrySet.hashCode());
+        if (false == hashSet.equals(entrySet)) {
+            throw new RuntimeException("Test FAILED: Sets are not equal.");
+        }
+        if (hashSet.hashCode() != entrySet.hashCode()) {
+            throw new RuntimeException("Test FAILED: Set's hashcodes are not equal.");
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java b/ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
index dddf9a4bade..03e1963c76b 100644
--- a/ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
+++ b/ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
@@ -37,14 +37,10 @@ import java.util.EnumMap;
 import java.util.Iterator;
 import java.util.Map;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class EntrySetIteratorRemoveInvalidatesEntry {
     static enum TestEnum { e00, e01, e02 }
 
-    @Test
-    public void testInvalidatesEntry() throws Exception {
+    public static void main(String[] args) throws Exception {
         final EnumMap<TestEnum, String> enumMap = new EnumMap<>(TestEnum.class);
 
         for (TestEnum e : TestEnum.values()) {
@@ -52,14 +48,14 @@ public class EntrySetIteratorRemoveInvalidatesEntry {
         }
 
         Iterator<Map.Entry<TestEnum, String>> entrySetIterator =
-                enumMap.entrySet().iterator();
+            enumMap.entrySet().iterator();
         Map.Entry<TestEnum, String> entry = entrySetIterator.next();
 
         entrySetIterator.remove();
 
         try {
             entry.getKey();
-            Assert.fail();
+            throw new RuntimeException("Test FAILED: Entry not invalidated by removal.");
         } catch (Exception e) { }
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/EnumMapBash.java b/ojluni/src/test/java/util/EnumMap/EnumMapBash.java
index 5d60d63ecef..8656ff0abc6 100644
--- a/ojluni/src/test/java/util/EnumMap/EnumMapBash.java
+++ b/ojluni/src/test/java/util/EnumMap/EnumMapBash.java
@@ -33,14 +33,10 @@ package test.java.util.EnumMap;
 import java.util.*;
 import java.io.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class EnumMapBash {
     static Random rnd = new Random();
 
-    @Test
-    public void testMapBash() {
+    public static void main(String[] args) {
         bash(Silly31.class);
         bash(Silly32.class);
         bash(Silly33.class);
@@ -204,7 +200,7 @@ public class EnumMapBash {
             oos.writeObject(oldObj);
             oos.flush();
             ByteArrayInputStream bin = new ByteArrayInputStream(
-                    bos.toByteArray());
+                bos.toByteArray());
             ObjectInputStream ois = new ObjectInputStream(bin);
             return (T) ois.readObject();
         } catch(Exception e) {
@@ -335,4 +331,4 @@ public class EnumMapBash {
         e490, e491, e492, e493, e494, e495, e496, e497, e498, e499
     }
 
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java b/ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java
new file mode 100644
index 00000000000..cdb008be51c
--- /dev/null
+++ b/ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     7164256
+ * @summary EnumMap.entrySet() returns an entrySet referencing to the cloned instance
+ * @author  Diego Belfer
+ */
+
+package test.java.util.EnumMap;
+
+import java.util.EnumMap;
+
+public class ProperEntrySetOnClone {
+    public enum Test {
+        ONE, TWO
+    }
+
+    public static void main(String[] args) {
+        EnumMap<Test, String> map1 = new EnumMap<Test, String>(Test.class);
+        map1.put(Test.ONE, "1");
+        map1.put(Test.TWO, "2");
+
+        // We need to force creation of the map1.entrySet
+        int size = map1.entrySet().size();
+        if (size != 2) {
+            throw new RuntimeException(
+                    "Invalid size in original map. Expected: 2 was: " + size);
+        }
+
+        EnumMap<Test, String> map2 = map1.clone();
+        map2.remove(Test.ONE);
+        size = map2.entrySet().size();
+        if (size != 1) {
+            throw new RuntimeException(
+                    "Invalid size in cloned instance. Expected: 1 was: " + size);
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/EnumMap/SimpleSerialization.java b/ojluni/src/test/java/util/EnumMap/SimpleSerialization.java
index 6a10ad827d5..5069d726771 100644
--- a/ojluni/src/test/java/util/EnumMap/SimpleSerialization.java
+++ b/ojluni/src/test/java/util/EnumMap/SimpleSerialization.java
@@ -25,28 +25,27 @@
  * Portions Copyright (c) 2011 IBM Corporation
  */
 
+package test.java.util.EnumMap;
+
 /*
  * @test
  * @bug 6312706
  * @summary A serialized EnumMap can be successfully de-serialized.
  * @author Neil Richards <neil.richards@ngmr.net>, <neil_richards@uk.ibm.com>
  */
-package test.java.util.EnumMap;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import java.util.EnumMap;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class SimpleSerialization {
     private enum TestEnum { e00, e01, e02, e03, e04, e05, e06, e07 }
-
-    @Test
-    public void testSimpleSerialization() throws Exception {
+    public static void main(final String[] args) throws Exception {
         final EnumMap<TestEnum, String> enumMap = new EnumMap<>(TestEnum.class);
 
         enumMap.put(TestEnum.e01, TestEnum.e01.name());
@@ -66,6 +65,27 @@ public class SimpleSerialization {
         final Object deserializedObject = ois.readObject();
         ois.close();
 
-        Assert.assertTrue(enumMap.equals(deserializedObject));
+        if (false == enumMap.equals(deserializedObject)) {
+            throw new RuntimeException(getFailureText(enumMap, deserializedObject));
+        }
+    }
+
+    private static String getFailureText(final Object orig, final Object copy) {
+        final StringWriter sw = new StringWriter();
+        final PrintWriter pw = new PrintWriter(sw);
+
+        pw.println("Test FAILED: Deserialized object is not equal to the original object");
+        pw.print("\tOriginal: ");
+        printObject(pw, orig).println();
+        pw.print("\tCopy:     ");
+        printObject(pw, copy).println();
+
+        pw.close();
+        return sw.toString();
+    }
+
+    private static PrintWriter printObject(final PrintWriter pw, final Object o) {
+        pw.printf("%s@%08x", o.getClass().getName(), System.identityHashCode(o));
+        return pw;
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/ToArray.java b/ojluni/src/test/java/util/EnumMap/ToArray.java
index 7b2ea5edd5f..bd64bf37e57 100644
--- a/ojluni/src/test/java/util/EnumMap/ToArray.java
+++ b/ojluni/src/test/java/util/EnumMap/ToArray.java
@@ -21,45 +21,49 @@
  * questions.
  */
 
+package test.java.util.EnumMap;
+
 /*
  * @test
  * @bug     6310858
  * @summary Tests for toArray
  * @author  Martin Buchholz
  */
-package test.java.util.EnumMap;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class ToArray {
     enum Country { FRENCH, POLISH }
-
-    @Test
-    public void testToArray() throws Throwable {
+    public static void main(String[] args) throws Throwable {
         Map<Country, String> m = new EnumMap<Country, String>(Country.class);
         m.put(Country.FRENCH, "connection");
         m.put(Country.POLISH, "sausage");
 
         Object[] z = m.entrySet().toArray();
-        Assert.assertEquals(z.getClass(), Object[].class);
-        Assert.assertEquals(z.length, 2);
+        System.out.println(Arrays.toString(z));
+        if (! (z.getClass() == Object[].class &&
+               z.length == 2 &&
+               ((Map.Entry)z[0]).getKey() == Country.FRENCH &&
+               ((Map.Entry)z[1]).getKey() == Country.POLISH))
+            throw new AssertionError();
 
         Map.Entry[] x1 = new Map.Entry[3];
         x1[2] = m.entrySet().iterator().next();
         Map.Entry[] x2 = m.entrySet().toArray(x1);
-        Assert.assertEquals(x1, x2);
-        Assert.assertEquals(x2[0].getKey(), Country.FRENCH);
-        Assert.assertEquals(x2[1].getKey(), Country.POLISH);
-        Assert.assertEquals(x2[2], null);
+        System.out.println(Arrays.toString(x2));
+        if (! (x1 == x2 &&
+               x2[0].getKey() == Country.FRENCH &&
+               x2[1].getKey() == Country.POLISH &&
+               x2[2] == null))
+            throw new AssertionError();
 
         Map.Entry[] y1 = new Map.Entry[1];
         Map.Entry[] y2 = m.entrySet().toArray(y1);
-        Assert.assertTrue(y1 != y2);
-        Assert.assertEquals(y2.length, 2);
-        Assert.assertEquals(y2[0].getKey(), Country.FRENCH);
-        Assert.assertEquals(y2[1].getKey(), Country.POLISH);
+        System.out.println(Arrays.toString(y2));
+        if (! (y1 != y2 &&
+               y2.length == 2 &&
+               y2[0].getKey() == Country.FRENCH &&
+               y2[1].getKey() == Country.POLISH))
+            throw new AssertionError();
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumMap/UniqueNullValue.java b/ojluni/src/test/java/util/EnumMap/UniqueNullValue.java
index 3e416c924b2..382f722a431 100644
--- a/ojluni/src/test/java/util/EnumMap/UniqueNullValue.java
+++ b/ojluni/src/test/java/util/EnumMap/UniqueNullValue.java
@@ -36,22 +36,26 @@ package test.java.util.EnumMap;
 import java.util.EnumMap;
 import java.util.Map;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class UniqueNullValue {
     static enum TestEnum { e00, e01 }
 
-    @Test
-    public void testUniqueNull() {
+    public static void main(String[] args) {
         Map<TestEnum, Integer> map = new EnumMap<>(TestEnum.class);
 
         map.put(TestEnum.e00, 0);
-        Assert.assertTrue(map.containsValue(0));
-        Assert.assertFalse(map.containsValue(null));
+        if (false == map.containsValue(0)) {
+            throw new RuntimeException("EnumMap unexpectedly missing 0 value");
+        }
+        if (map.containsValue(null)) {
+            throw new RuntimeException("EnumMap unexpectedly holds null value");
+        }
 
         map.put(TestEnum.e00, null);
-        Assert.assertFalse(map.containsValue(0));
-        Assert.assertTrue(map.containsValue(null));
+        if (map.containsValue(0)) {
+            throw new RuntimeException("EnumMap unexpectedly holds 0 value");
+        }
+        if (false == map.containsValue(null)) {
+            throw new RuntimeException("EnumMap unexpectedly missing null value");
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/AllOf.java b/ojluni/src/test/java/util/EnumSet/AllOf.java
index 604d0ab565c..0959d8a239d 100644
--- a/ojluni/src/test/java/util/EnumSet/AllOf.java
+++ b/ojluni/src/test/java/util/EnumSet/AllOf.java
@@ -21,23 +21,19 @@
  * questions.
  */
 
+package test.java.util.EnumSet;
+
 /*
  * @test
  * @bug     4946090
  * @summary AllOf static factory is broken in Regular and Jumbo enum set
  * @author  Josh Bloch
  */
-package test.java.util.EnumSet;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class AllOf {
-
-    @Test
-    public void testAllOf() throws Exception {
+    public static void main(String[] args) throws Exception {
         test(Test0.class, 0);
         test(Test33.class, 33);
         test(Test127.class, 127);
@@ -45,9 +41,11 @@ public class AllOf {
     }
 
     static <T extends Enum<T>> void test(Class<T> enumClass,
-            int expected) {
+                                                int expected) {
         EnumSet<T> set = EnumSet.allOf(enumClass);
-        Assert.assertEquals(set.size(), expected);
+        if (set.size() != expected)
+            throw new RuntimeException(set.size() +" != " + expected);
+        set.toString();
     }
 
     public enum Test0 {}
@@ -83,4 +81,4 @@ public class AllOf {
         T112, T113, T114, T115, T116, T117, T118, T119, T120, T121, T122, T123,
         T124, T125, T126, T127
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/BogusEnumSet.java b/ojluni/src/test/java/util/EnumSet/BogusEnumSet.java
new file mode 100644
index 00000000000..ed4a61ebd2a
--- /dev/null
+++ b/ojluni/src/test/java/util/EnumSet/BogusEnumSet.java
@@ -0,0 +1,100 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     6739302
+ * @summary Check that deserialization preserves EnumSet integrity
+ * @author  Josh Bloch
+ */
+
+package test.java.util.EnumSet;
+
+import java.util.*;
+import java.io.*;
+
+public class BogusEnumSet {
+    public static void main(String[] args) throws Throwable {
+        // This test tries to deserialize a bogus stream produced with
+        // hypothetical EnumSet without a writeReplace() method - i.e.
+        // not using serialization proxy pattern. It tests that such
+        // stream is not accepted as valid stream - the EnumSet class
+        // declares a readObject() method which throws exception.
+        byte[] serializedForm  = {
+            (byte)0xac, (byte)0xed, 0x0, 0x5, 0x73, 0x72, 0x0, 0x18,
+            0x6a,  0x61,  0x76,  0x61, 0x2e,  0x75,  0x74,  0x69,
+            0x6c,  0x2e, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x45,
+            0x6e, 0x75, 0x6d, 0x53, 0x65, 0x74, 0x2f, 0x58, 0x6f, (byte)0xc7,
+            0x7e, (byte)0xb0, (byte)0xd0, 0x7e, 0x2, 0x0, 0x1, 0x4a, 0x0, 0x8,
+            0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x78, 0x72, 0x0,
+            0x11, 0x6a,  0x61,  0x76,  0x61, 0x2e,  0x75,  0x74,  0x69,
+            0x6c,  0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x65, 0x74, 0xe,
+            0x3, 0x21, 0x6a, (byte)0xcd, (byte)0x8c, 0x29, (byte)0xdd, 0x2,
+            0x0, 0x2, 0x4c, 0x0, 0xb, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
+            0x54, 0x79, 0x70, 0x65, 0x74, 0x0, 0x11, 0x4c, 0x6a, 0x61, 0x76,
+            0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x43, 0x6c, 0x61, 0x73,
+            0x73, 0x3b, 0x5b, 0x0, 0x8, 0x75, 0x6e, 0x69, 0x76, 0x65, 0x72,
+            0x73, 0x65, 0x74, 0x0, 0x11, 0x5b, 0x4c, 0x6a, 0x61, 0x76, 0x61,
+            0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x45, 0x6e, 0x75, 0x6d, 0x3b,
+            0x78, 0x70, 0x76, 0x72, 0x0, 0x16, 0x6a, 0x61, 0x76, 0x61, 0x2e,
+            0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61,
+            0x64, 0x24, 0x53, 0x74, 0x61, 0x74, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0,
+            0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0x78, 0x72, 0x0, 0xe, 0x6a, 0x61,
+            0x76, 0x61, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x45, 0x6e, 0x75,
+            0x6d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0x78,
+            0x70, 0x75, 0x72, 0x0, 0x19, 0x5b, 0x4c, 0x6a, 0x61, 0x76, 0x61,
+            0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61,
+            0x64, 0x24, 0x53, 0x74, 0x61, 0x74, 0x65, 0x3b, 0x68, (byte)0xa3,
+            (byte)0xb5, (byte)0xd5, 0x11, 0x7d, 0x1b, (byte)0xb3, 0x2, 0x0,
+            0x0, 0x78, 0x70, 0x0, 0x0, 0x0, 0x6, 0x7e, 0x71, 0x0, 0x7e, 0x0,
+            0x5, 0x74, 0x0, 0x3, 0x4e, 0x45, 0x57, 0x7e, 0x71, 0x0, 0x7e, 0x0,
+            0x5, 0x74, 0x0, 0x8, 0x52, 0x55, 0x4e, 0x4e, 0x41, 0x42, 0x4c, 0x45,
+            0x7e, 0x71, 0x0, 0x7e, 0x0, 0x5, 0x74, 0x0, 0x7, 0x42, 0x4c, 0x4f,
+            0x43, 0x4b, 0x45, 0x44, 0x7e, 0x71, 0x0, 0x7e, 0x0, 0x5, 0x74, 0x0,
+            0x7, 0x57, 0x41, 0x49, 0x54, 0x49, 0x4e, 0x47, 0x7e, 0x71, 0x0,
+            0x7e, 0x0, 0x5, 0x74, 0x0, 0xd, 0x54, 0x49, 0x4d, 0x45, 0x44,
+            0x5f, 0x57, 0x41, 0x49, 0x54, 0x49, 0x4e, 0x47, 0x7e, 0x71, 0x0,
+            0x7e, 0x0, 0x5, 0x74, 0x0, 0xa, 0x54, 0x45, 0x52, 0x4d, 0x49,
+            0x4e, 0x41, 0x54, 0x45, 0x44, (byte)0xff, (byte)0xff, (byte)0xff,
+            (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff
+        };
+
+        try {
+          // Should fail, but instead creates corrupt EnumSet
+          @SuppressWarnings("unchecked")
+          EnumSet<Thread.State> es = (EnumSet<Thread.State>)
+              deserialize(serializedForm);
+
+          // Demonstrates corruption
+          System.out.println("Enum size: " + Thread.State.values().length); // 6
+          System.out.println("Set size: " + es.size()); // 64
+          System.out.println("Set: " + es); // Throws IndexOutOfBoundsException
+          throw new AssertionError("Expected exception InvalidObjectException not thrown");
+        } catch (java.io.InvalidObjectException expected) { /* OK */ }
+    }
+
+    private static Object deserialize(byte[] sf) throws Throwable {
+      return new ObjectInputStream(
+          new ByteArrayInputStream(sf))
+          .readObject();
+    }
+}
diff --git a/ojluni/src/test/java/util/EnumSet/ComplementOf.java b/ojluni/src/test/java/util/EnumSet/ComplementOf.java
index 0493864b234..766406b181c 100644
--- a/ojluni/src/test/java/util/EnumSet/ComplementOf.java
+++ b/ojluni/src/test/java/util/EnumSet/ComplementOf.java
@@ -21,23 +21,19 @@
  * questions.
  */
 
+package test.java.util.EnumSet;
+
 /*
  * @test
  * @bug     4946096
  * @summary ComplementOf static factory is broken in Regular and Jumbo enum set
  * @author  Josh Bloch
  */
-package test.java.util.EnumSet;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class ComplementOf {
-
-    @Test
-    public void testComplementOf() {
+    public static void main(String[] args) throws Exception {
         test(Test0.class);
         test(MonthTest10.class);
         test(Test127.class);
@@ -47,7 +43,9 @@ public class ComplementOf {
     static <T extends Enum<T>> void test(Class<T> enumClass) {
         EnumSet<T> set = EnumSet.allOf(enumClass);
         EnumSet<T> setComplement = EnumSet.complementOf(set);
-        Assert.assertEquals(setComplement.size(), 0);
+        if (setComplement.size() != 0)
+            throw new RuntimeException(setComplement.size() + " != 0");
+        setComplement.toString();
     }
 
     public enum Test0 { }
@@ -79,4 +77,4 @@ public class ComplementOf {
         T112, T113, T114, T115, T116, T117, T118, T119, T120, T121, T122, T123,
         T124, T125, T126, T127
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/EnumSetBash.java b/ojluni/src/test/java/util/EnumSet/EnumSetBash.java
index 291e9d52d01..994f8dd291c 100644
--- a/ojluni/src/test/java/util/EnumSet/EnumSetBash.java
+++ b/ojluni/src/test/java/util/EnumSet/EnumSetBash.java
@@ -35,14 +35,15 @@ package test.java.util.EnumSet;
 import java.util.*;
 import java.io.*;
 
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 public class EnumSetBash {
     static Random rnd = new Random();
 
+    // Android-changed: shard this test.
+    // public static void main(String[] args) {
     @Test
-    public void testEnumSetBash() {
+    public void testSmallSizesShard() {
         bash(Silly0.class);
         bash(Silly1.class);
         bash(Silly31.class);
@@ -95,34 +96,48 @@ public class EnumSetBash {
             EnumSet<T> diff2 = clone(s2, enumClass); diff2.removeAll(s1);
             EnumSet<T> union = clone(s1, enumClass); union.addAll(s2);
 
-            Assert.assertFalse(diff1.removeAll(diff2));
-            Assert.assertFalse(diff1.removeAll(intersection));
-            Assert.assertFalse(diff2.removeAll(diff1));
-            Assert.assertFalse(diff2.removeAll(intersection));
-            Assert.assertFalse(intersection.removeAll(diff1));
-            Assert.assertFalse(intersection.removeAll(diff1));
+            if (diff1.removeAll(diff2))
+                fail("Set algebra identity 2 failed");
+            if (diff1.removeAll(intersection))
+                fail("Set algebra identity 3 failed");
+            if (diff2.removeAll(diff1))
+                fail("Set algebra identity 4 failed");
+            if (diff2.removeAll(intersection))
+                fail("Set algebra identity 5 failed");
+            if (intersection.removeAll(diff1))
+                fail("Set algebra identity 6 failed");
+            if (intersection.removeAll(diff1))
+                fail("Set algebra identity 7 failed");
 
             intersection.addAll(diff1); intersection.addAll(diff2);
-            Assert.assertTrue(intersection.equals(union));
+            if (!intersection.equals(union))
+                fail("Set algebra identity 1 failed");
 
-            Assert.assertEquals(new HashSet<T>(union).hashCode(), union.hashCode());
+            if (new HashSet<T>(union).hashCode() != union.hashCode())
+                fail("Incorrect hashCode computation.");
 
             Iterator e = union.iterator();
             while (e.hasNext())
-                Assert.assertTrue(intersection.remove(e.next()));
-            Assert.assertTrue(intersection.isEmpty());
+                if (!intersection.remove(e.next()))
+                    fail("Couldn't remove element from copy.");
+            if (!intersection.isEmpty())
+                fail("Copy nonempty after deleting all elements.");
 
             e = union.iterator();
             while (e.hasNext()) {
                 Object o = e.next();
-                Assert.assertTrue(union.contains(o));
+                if (!union.contains(o))
+                    fail("Set doesn't contain one of its elements.");
                 e.remove();
-                Assert.assertFalse(union.contains(o));
+                if (union.contains(o))
+                    fail("Set contains element after deletion.");
             }
-            Assert.assertTrue(union.isEmpty());
+            if (!union.isEmpty())
+                fail("Set nonempty after deleting all elements.");
 
             s1.clear();
-            Assert.assertTrue(s1.isEmpty());
+            if (!s1.isEmpty())
+                fail("Set nonempty after clear.");
         }
     }
 
@@ -150,14 +165,17 @@ public class EnumSetBash {
                     clone = EnumSet.copyOf((Collection<E>)s);
                 else
                     clone = EnumSet.copyOf((Collection<E>)(Collection)
-                            Arrays.asList(s.toArray()));
+                                           Arrays.asList(s.toArray()));
                 break;
             case 5:
                 clone = (EnumSet<E>) deepCopy(s);
         }
-        Assert.assertTrue(s.equals(clone));
-        Assert.assertTrue(s.containsAll(clone));
-        Assert.assertTrue(clone.containsAll(s));
+        if (!s.equals(clone))
+            fail("Set not equal to copy. " + method);
+        if (!s.containsAll(clone))
+            fail("Set does not contain copy. " + method);
+        if (!clone.containsAll(s))
+            fail("Copy does not contain set. " + method);
         return clone;
     }
 
@@ -170,7 +188,7 @@ public class EnumSetBash {
             oos.writeObject(oldObj);
             oos.flush();
             ByteArrayInputStream bin = new ByteArrayInputStream(
-                    bos.toByteArray());
+                bos.toByteArray());
             ObjectInputStream ois = new ObjectInputStream(bin);
             return (T) ois.readObject();
         } catch(Exception e) {
@@ -185,14 +203,22 @@ public class EnumSetBash {
             boolean prePresent = s.contains(e);
             int preSize = s.size();
             boolean added = s.add(e);
-            Assert.assertTrue(s.contains(e));
-            Assert.assertFalse(added == prePresent);
+            if (!s.contains(e))
+                fail ("Element not present after addition.");
+            if (added == prePresent)
+                fail ("added == alreadyPresent");
             int postSize = s.size();
-            Assert.assertFalse(added && preSize == postSize);
-            Assert.assertFalse(!added && preSize != postSize);
+            if (added && preSize == postSize)
+                fail ("Add returned true, but size didn't change.");
+            if (!added && preSize != postSize)
+                fail ("Add returned false, but size changed.");
         }
     }
 
+    static void fail(String s) {
+        throw new RuntimeException(s);
+    }
+
     public enum Silly0 { };
 
     public enum Silly1 { e1 }
@@ -316,4 +342,4 @@ public class EnumSetBash {
         e490, e491, e492, e493, e494, e495, e496, e497, e498, e499
     }
 
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java b/ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java
new file mode 100644
index 00000000000..7d9253c9f0c
--- /dev/null
+++ b/ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     8227368
+ * @summary Test deserialization of a stream containing EnumSet.class object
+ */
+
+package test.java.util.EnumSet;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.EnumSet;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+public class EnumSetClassSerialization {
+
+    public static void main(String[] args) throws Exception {
+        // EnumSet.class object serialized with JDK 8
+        int[] bytes = {
+            0xac, 0xed, 0x00, 0x05, 0x76, 0x72, 0x00, 0x11, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75, 0x74, 0x69,
+            0x6c, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x65, 0x74, 0x0e, 0x03, 0x21, 0x6a, 0xcd, 0x8c, 0x29,
+            0xdd, 0x02, 0x00, 0x02, 0x4c, 0x00, 0x0b, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79,
+            0x70, 0x65, 0x74, 0x00, 0x11, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f,
+            0x43, 0x6c, 0x61, 0x73, 0x73, 0x3b, 0x5b, 0x00, 0x08, 0x75, 0x6e, 0x69, 0x76, 0x65, 0x72, 0x73,
+            0x65, 0x74, 0x00, 0x11, 0x5b, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f,
+            0x45, 0x6e, 0x75, 0x6d, 0x3b, 0x78, 0x70
+        };
+
+        InputStream in = new InputStream() {
+            int i = 0;
+
+            @Override
+            public int read() {
+                return i < bytes.length ? bytes[i++] & 0xFF : -1;
+            }
+        };
+        ObjectInputStream ois = new ObjectInputStream(in);
+
+        Object res = ois.readObject();
+
+        if (res != EnumSet.class) {
+            throw new AssertionError(
+                "Expected: " + EnumSet.class + ", got: " + res);
+        }
+    }
+
+    /**
+     * This class can be used to print out lines that constitute
+     * the 'bytes' variable initializer in the test.
+     */
+    public static class Serializer {
+        public static void main(String[] args) throws IOException {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            ObjectOutputStream oos = new ObjectOutputStream(baos);
+            oos.writeObject(EnumSet.class);
+            oos.close();
+            byte[] bytes = baos.toByteArray();
+            int bpl = 16;
+            System.out.print(
+                IntStream
+                    .range(0, (bytes.length + bpl - 1) / bpl)
+                    .mapToObj(i -> IntStream
+                        .range(
+                            i * bpl,
+                            Math.min(i * bpl + bpl, bytes.length)
+                        )
+                        .mapToObj(ii -> {
+                            String s = Integer.toHexString(bytes[ii] & 0xFF);
+                            return s.length() == 1 ? "0x0" + s : "0x" + s;
+                        })
+                        .collect(Collectors.joining(", "))
+                    )
+                    .collect(Collectors.joining(",\n  ", "int[] bytes = {\n  ", "\n};"))
+            );
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/EnumSet/InsertWrongType.java b/ojluni/src/test/java/util/EnumSet/InsertWrongType.java
index 5a47ff4f8fb..d1bceb51f86 100644
--- a/ojluni/src/test/java/util/EnumSet/InsertWrongType.java
+++ b/ojluni/src/test/java/util/EnumSet/InsertWrongType.java
@@ -21,23 +21,19 @@
  * questions.
  */
 
+package test.java.util.EnumSet;
+
 /*
  * @test
  * @bug     5050285
  * @summary Inserting enum of wrong type does horrible things to EnumSet/Map
  * @author  Josh Bloch
  */
-package test.java.util.EnumSet;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class InsertWrongType {
-
-    @Test
-    public void testInsertWrongType() {
+    public static void main(String[] args) throws Exception {
         // Ordinal in range
         addIllTypedElt(Test32.class,  Test33.T1);  // Regular
         addIllTypedElt(Test127.class, Test128.T1); // Jumbo
@@ -92,16 +88,20 @@ public class InsertWrongType {
         EnumSet set = EnumSet.noneOf(enumClass);
         try {
             set.add(elt);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("Incorrectly typed add succeeded");
     }
 
     static void addAllIllTypedElt(Class enumClass, Enum elt) {
         EnumSet set = EnumSet.noneOf(enumClass);
         try {
             set.addAll(Collections.singleton(elt));
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("Incorrectly typed addAll succeeded");
     }
 
     static void addAllEmptyMistypedEnumSet(Class destClass, Class srcClass) {
@@ -116,51 +116,65 @@ public class InsertWrongType {
         list.add(e2);
         try {
             EnumSet.copyOf(list);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous copyOf succeeded");
     }
 
     static void heterogeneousOf2(Enum e1, Enum e2) {
         try {
             EnumSet.of(e1, e2);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous of (2 args) succeeded");
     }
 
     static void heterogeneousOf3(Enum e1, Enum e2) {
         try {
             EnumSet.of(e1, e1, e2);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous of (3 args) succeeded");
     }
 
     static void heterogeneousOf4(Enum e1, Enum e2) {
         try {
             EnumSet.of(e1, e1, e1, e2);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous of (4 args) succeeded");
     }
 
     static void heterogeneousOf5(Enum e1, Enum e2) {
         try {
             EnumSet.of(e1, e1, e1, e1, e2);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous of (5 args) succeeded");
     }
 
     static void heterogeneousOfVar(Enum e1, Enum e2) {
         try {
             EnumSet.of(e1, e1, e1, e1, e1, e2);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("heterogeneous of (Var args) succeeded");
     }
 
     static void putIllTypedKey(Class enumClass, Enum elt) {
         EnumMap map = new EnumMap(enumClass);
         try {
             map.put(elt, "foofy");
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("Incorrectly typed put succeeded");
     }
 
     static void putAllIllTypedKey(Class enumClass, Enum elt) {
@@ -169,8 +183,10 @@ public class InsertWrongType {
         src.put(elt, "goofy");
         try {
             dest.putAll(src);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("Incorrectly typed putAll succeeded");
     }
 
     static void putAllIllTypedKeyEnumMap(Class enumClass, Enum elt) {
@@ -179,8 +195,10 @@ public class InsertWrongType {
         src.put(elt, "goofy");
         try {
             dest.putAll(src);
-            Assert.fail();
-        } catch(ClassCastException e) {}
+        } catch(ClassCastException e) {
+            return;
+        }
+        throw new RuntimeException("Incorrectly typed enum put All succeeded");
     }
 
     static void putAllEmptyMistypedEnumMap(Class destClass, Class srcClass) {
@@ -226,4 +244,4 @@ public class InsertWrongType {
         T112, T113, T114, T115, T116, T117, T118, T119, T120, T121, T122, T123,
         T124, T125, T126, T127, T128
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/JumboRange.java b/ojluni/src/test/java/util/EnumSet/JumboRange.java
index 57852bbc6cf..fa040a1eb06 100644
--- a/ojluni/src/test/java/util/EnumSet/JumboRange.java
+++ b/ojluni/src/test/java/util/EnumSet/JumboRange.java
@@ -31,13 +31,8 @@ package test.java.util.EnumSet;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class JumboRange {
-
-    @Test
-    public void testJumboRange() {
+    public static void main(String[] args) {
         test(Test127.class, Test127.T2, Test127.T6);
         test(Test127.class, Test127.T126, Test127.T126);
         test(Test127.class, Test127.T0, Test127.T126);
@@ -45,7 +40,9 @@ public class JumboRange {
 
     static <T extends Enum<T>> void test(Class<T> enumClass, T e0,T e1) {
         EnumSet<T> range = EnumSet.range(e0, e1);
-        Assert.assertEquals(range.size(), e1.ordinal() - e0.ordinal() + 1);
+        if (range.size() != e1.ordinal() - e0.ordinal() + 1)
+            throw new RuntimeException(range.size() + " != " +
+                                       (e1.ordinal() - e0.ordinal() + 1));
     }
 
     public enum Test127 {
@@ -60,4 +57,4 @@ public class JumboRange {
         T112, T113, T114, T115, T116, T117, T118, T119, T120, T121, T122, T123,
         T124, T125, T126
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java b/ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
index 79071f60abb..0b9d4cbd3c0 100644
--- a/ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
+++ b/ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
@@ -38,12 +38,9 @@ import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Set;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class LargeEnumIteratorRemoveResilience {
     // enum with more than 64 values
-    private enum LargeEnum {
+    private static enum LargeEnum {
         e00, e01, e02, e03, e04, e05, e06, e07,
         e08, e09, e0A, e0B, e0C, e0D, e0E, e0F,
         e10, e11, e12, e13, e14, e15, e16, e17,
@@ -56,8 +53,7 @@ public class LargeEnumIteratorRemoveResilience {
         e48, e49, e4A, e4B, e4C, e4D, e4E, e4F,
     }
 
-    @Test
-    public void testLargeEnumIterator() throws Exception {
+    public static void main(final String[] args) throws Exception {
         final Set<LargeEnum> set = EnumSet.noneOf(LargeEnum.class);
 
         set.add(LargeEnum.e2D);
@@ -90,8 +86,13 @@ public class LargeEnumIteratorRemoveResilience {
     }
 
     private static void checkSetAfterRemoval(final Set<LargeEnum> set,
-            final int origSize, final LargeEnum removedElement) {
-        Assert.assertEquals(set.size(), (origSize - 1));
-        Assert.assertFalse(set.contains(removedElement));
+            final int origSize, final LargeEnum removedElement)
+            throws Exception {
+        if (set.size() != (origSize - 1)) {
+            throw new Exception("Test FAILED: Unexpected set size after removal; expected '" + (origSize - 1) + "' but found '" + set.size() + "'");
+        }
+        if (set.contains(removedElement)) {
+            throw new Exception("Test FAILED: Element returned from iterator unexpectedly still in set after removal.");
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/OneUniverse.java b/ojluni/src/test/java/util/EnumSet/OneUniverse.java
new file mode 100644
index 00000000000..124b7f6ceac
--- /dev/null
+++ b/ojluni/src/test/java/util/EnumSet/OneUniverse.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     6276988
+ * @summary All enum constants in a class should share a single "universe".
+ * @modules java.base/java.util:open
+ */
+
+package test.java.util.EnumSet;
+
+import java.lang.reflect.Field;
+import java.math.RoundingMode;
+import java.util.EnumSet;
+
+public class OneUniverse {
+
+    private static final Field universeField;
+
+    static {
+        try {
+            universeField = EnumSet.class.getDeclaredField("universe");
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError(e);
+        }
+        universeField.setAccessible(true);
+    }
+
+    public static void main(String... args) {
+
+        EnumSet<RoundingMode> noneSet = EnumSet.noneOf(RoundingMode.class);
+        EnumSet<RoundingMode> allSet  = EnumSet.allOf(RoundingMode.class);
+
+        if (getUniverse(noneSet) != getUniverse(allSet)) {
+            throw new AssertionError(
+                    "Multiple universes detected.  Inform the bridge!");
+        }
+    }
+
+    private static <E extends Enum<E>> Enum<E>[] getUniverse(EnumSet<E> set) {
+        try {
+            return (Enum<E>[]) universeField.get(set);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+    }
+}
diff --git a/ojluni/src/test/java/util/EnumSet/Range.java b/ojluni/src/test/java/util/EnumSet/Range.java
index 6c5e759e99c..5a036709df6 100644
--- a/ojluni/src/test/java/util/EnumSet/Range.java
+++ b/ojluni/src/test/java/util/EnumSet/Range.java
@@ -31,13 +31,8 @@ package test.java.util.EnumSet;
 
 import java.util.*;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class Range {
-
-    @Test
-    public void testRange() {
+    public static void main(String[] args) {
         test(Test33.class, Test33.T6, Test33.T2);
         test(Test127.class, Test127.T6, Test127.T2);
     }
@@ -45,7 +40,6 @@ public class Range {
     static <T extends Enum<T>> void test(Class<T> enumClass, T e0,T e1) {
         try {
             EnumSet<T> range = EnumSet.range(e0, e1);
-            Assert.fail();
         } catch(IllegalArgumentException e) {
             return;
         }
@@ -70,4 +64,4 @@ public class Range {
         T112, T113, T114, T115, T116, T117, T118, T119, T120, T121, T122, T123,
         T124, T125, T126
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/EnumSet/RetainAll.java b/ojluni/src/test/java/util/EnumSet/RetainAll.java
new file mode 100644
index 00000000000..cef03610c36
--- /dev/null
+++ b/ojluni/src/test/java/util/EnumSet/RetainAll.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 6377356
+ * @summary Test EnumSet.retainAll
+ * @author Josh Bloch, Martin Buchholz
+ */
+
+package test.java.util.EnumSet;
+
+import java.util.*;
+
+// Android-added: call with incompatible type is made on purpose.
+@SuppressWarnings("CollectionIncompatibleType")
+public class RetainAll {
+    enum RegularA { A0, A2 }
+    enum RegularB { B0, B1 }
+    enum JumboA {
+        A00, A01, A02, A03, A04, A05, A06, A07, A08, A09,
+        A10, A11, A12, A13, A14, A15, A16, A17, A18, A19,
+        A20, A21, A22, A23, A24, A25, A26, A27, A28, A29,
+        A30, A31, A32, A33, A34, A35, A36, A37, A38, A39,
+        A40, A41, A42, A43, A44, A45, A46, A47, A48, A49,
+        A50, A51, A52, A53, A54, A55, A56, A57, A58, A59,
+        A60, A61, A62, A63, A64, A65, A66, A67, A68, A69,
+    }
+    enum JumboB {
+        B00, B01, B02, B03, B04, B05, B06, B07, B08, B09,
+        B10, B11, B12, B13, B14, B15, B16, B17, B18, B19,
+        B20, B21, B22, B23, B24, B25, B26, B27, B28, B29,
+        B30, B31, B32, B33, B34, B35, B36, B37, B38, B39,
+        B40, B41, B42, B43, B44, B45, B46, B47, B48, B49,
+        B50, B51, B52, B53, B54, B55, B56, B57, B58, B59,
+        B60, B61, B62, B63, B64, B65, B66, B67, B68, B69,
+    }
+
+    private static void realMain(String[] args) throws Throwable {
+        Set<RegularA> ras = EnumSet.noneOf(RegularA.class);
+        Set<RegularB> rbs = EnumSet.noneOf(RegularB.class);
+        Set<JumboA>   jas = EnumSet.noneOf(JumboA.class);
+        Set<JumboB>   jbs = EnumSet.noneOf(JumboB.class);
+        check(ras.getClass().getName().matches(".*Regular.*"));
+        check(jas.getClass().getName().matches(".*Jumbo.*"));
+        check(! ras.retainAll(ras));
+        check(! ras.retainAll(rbs));
+        check(! jas.retainAll(jas));
+        check(! jas.retainAll(jbs));
+        check(! ras.retainAll(jas));
+        check(! jas.retainAll(ras));
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    static volatile int passed = 0, failed = 0;
+    static void pass() {passed++;}
+    static void fail() {failed++; Thread.dumpStack();}
+    static void fail(String msg) {System.out.println(msg); fail();}
+    static void unexpected(Throwable t) {failed++; t.printStackTrace();}
+    static void check(boolean cond) {if (cond) pass(); else fail();}
+    static void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else fail(x + " not equal to " + y);}
+    public static void main(String[] args) throws Throwable {
+        try {realMain(args);} catch (Throwable t) {unexpected(t);}
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new AssertionError("Some tests failed");}
+}
diff --git a/ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java b/ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
index fc944d0cca7..8280516212c 100644
--- a/ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
+++ b/ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
@@ -37,15 +37,11 @@ import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Set;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
 public class SmallEnumIteratorRemoveResilience {
     // enum with less than 64 values
-    private enum SmallEnum { e0, e1, e2 }
+    private static enum SmallEnum { e0, e1, e2 }
 
-    @Test
-    public void testSmallEnumRemoveResilience() {
+    public static void main(final String[] args) throws Exception {
         final Set<SmallEnum> set = EnumSet.noneOf(SmallEnum.class);
 
         set.add(SmallEnum.e0);
@@ -78,8 +74,13 @@ public class SmallEnumIteratorRemoveResilience {
     }
 
     private static void checkSetAfterRemoval(final Set<SmallEnum> set,
-            final int origSize, final SmallEnum removedElement) {
-        Assert.assertEquals(set.size(), (origSize - 1));
-        Assert.assertFalse(set.contains(removedElement));
+            final int origSize, final SmallEnum removedElement)
+            throws Exception {
+        if (set.size() != (origSize - 1)) {
+            throw new Exception("Test FAILED: Unexpected set size after removal; expected '" + (origSize - 1) + "' but found '" + set.size() + "'");
+        }
+        if (set.contains(removedElement)) {
+            throw new Exception("Test FAILED: Element returned from iterator unexpectedly still in set after removal.");
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java b/ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java
index 58d5f4993b8..33fb7ae22d9 100644
--- a/ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java
+++ b/ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,113 +24,434 @@
 
 package test.java.util.HashMap;
 
+import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
+import java.util.AbstractMap;
+import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.ThreadLocalRandom;
+import java.util.Set;
+import java.util.WeakHashMap;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
 import java.util.function.Supplier;
-import java.util.stream.IntStream;
 
-import static java.util.stream.Collectors.toMap;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertThrows;
 
 /*
  * @test
- * @bug 8210280
+ * @bug 8186958 8210280 8281631 8285386 8284780
  * @modules java.base/java.util:open
- * @summary White box tests for HashMap internals around table resize
- * @run testng WhiteBoxResizeTest
- * @key randomness
+ * @summary White box tests for HashMap-related internals around table sizing
+ * @run testng/othervm -Xmx2g WhiteBoxResizeTest
  */
 public class WhiteBoxResizeTest {
-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();
+
     final MethodHandle TABLE_SIZE_FOR;
-    final VarHandle THRESHOLD;
-    final VarHandle TABLE;
+    final VarHandle HM_TABLE;
+    final VarHandle WHM_TABLE;
+    final VarHandle HS_MAP;
 
     public WhiteBoxResizeTest() throws ReflectiveOperationException {
-        Class<?> mClass = HashMap.class;
-        String nodeClassName = mClass.getName() + "$Node";
-        Class<?> nodeArrayClass = Class.forName("[L" + nodeClassName + ";");
-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(mClass, MethodHandles.lookup());
-        TABLE = lookup.findVarHandle(mClass, "table", nodeArrayClass);
-        this.TABLE_SIZE_FOR = lookup.findStatic(
-                mClass, "tableSizeFor",
-                MethodType.methodType(int.class, int.class));
-        this.THRESHOLD = lookup.findVarHandle(mClass, "threshold", int.class);
+        MethodHandles.Lookup hmlookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());
+        TABLE_SIZE_FOR = hmlookup.findStatic(
+                HashMap.class, "tableSizeFor", MethodType.methodType(int.class, int.class));
+        HM_TABLE = hmlookup.unreflectVarHandle(HashMap.class.getDeclaredField("table"));
+
+        MethodHandles.Lookup whmlookup = MethodHandles.privateLookupIn(WeakHashMap.class, MethodHandles.lookup());
+        WHM_TABLE = whmlookup.unreflectVarHandle(WeakHashMap.class.getDeclaredField("table"));
+
+        MethodHandles.Lookup hslookup = MethodHandles.privateLookupIn(HashSet.class, MethodHandles.lookup());
+        HS_MAP = hslookup.unreflectVarHandle(HashSet.class.getDeclaredField("map"));
     }
 
+    /*
+     * utility methods
+     */
+
     int tableSizeFor(int n) {
         try {
             return (int) TABLE_SIZE_FOR.invoke(n);
-        } catch (Throwable t) { throw new AssertionError(t); }
+        } catch (Throwable t) {
+            throw new AssertionError(t);
+        }
     }
 
-    Object[] table(HashMap map) {
+    Object[] table(Map<?, ?> map) {
         try {
-            return (Object[]) TABLE.get(map);
-        } catch (Throwable t) { throw new AssertionError(t); }
+            VarHandle vh = map instanceof WeakHashMap ? WHM_TABLE : HM_TABLE;
+            return (Object[]) vh.get(map);
+        } catch (Throwable t) {
+            throw new AssertionError(t);
+        }
     }
 
-    int capacity(HashMap map) {
+    int capacity(Map<?, ?> map) {
         return table(map).length;
     }
 
-    @Test
-    public void testTableSizeFor() {
-        assertEquals(tableSizeFor(0), 1);
-        assertEquals(tableSizeFor(1), 1);
-        assertEquals(tableSizeFor(2), 2);
-        assertEquals(tableSizeFor(3), 4);
-        assertEquals(tableSizeFor(15), 16);
-        assertEquals(tableSizeFor(16), 16);
-        assertEquals(tableSizeFor(17), 32);
-        int maxSize = 1 << 30;
-        assertEquals(tableSizeFor(maxSize - 1), maxSize);
-        assertEquals(tableSizeFor(maxSize), maxSize);
-        assertEquals(tableSizeFor(maxSize + 1), maxSize);
-        assertEquals(tableSizeFor(Integer.MAX_VALUE), maxSize);
+    // creates a map with size mappings
+    Map<String, String> makeMap(int size) {
+        Map<String, String> map = new HashMap<>();
+        putN(map, size);
+        return map;
+    }
+
+    // creates a "fake" map: size() returns the given size, but
+    // the entrySet iterator returns only one entry
+    Map<String, String> fakeMap(int size) {
+        return new AbstractMap<>() {
+            public Set<Map.Entry<String, String>> entrySet() {
+                return new AbstractSet<Map.Entry<String, String>>() {
+                    public int size() {
+                        return size;
+                    }
+
+                    public Iterator<Map.Entry<String, String>> iterator() {
+                        return Set.of(Map.entry("1", "1")).iterator();
+                    }
+                };
+            }
+        };
+    }
+
+    void putN(Map<String, String> map, int n) {
+        for (int i = 0; i < n; i++) {
+            String string = Integer.toString(i);
+            map.put(string, string);
+        }
+    }
+
+    /*
+     * tests of tableSizeFor
+     */
+
+    @DataProvider(name = "tableSizeFor")
+    public Object[][] tableSizeForCases() {
+        final int MAX = 1 << 30;
+        return new Object[][] {
+                // tableSizeFor(arg), expected
+                { 0,                   1 },
+                { 1,                   1 },
+                { 2,                   2 },
+                { 3,                   4 },
+                { 4,                   4 },
+                { 5,                   8 },
+                { 15,                 16 },
+                { 16,                 16 },
+                { 17,                 32 },
+                { MAX-1,             MAX },
+                { MAX,               MAX },
+                { MAX+1,             MAX },
+                { Integer.MAX_VALUE, MAX }
+        };
+    }
+
+    @Test(dataProvider = "tableSizeFor")
+    public void tableSizeFor(int arg, int expected) {
+        assertEquals(tableSizeFor(arg), expected);
     }
 
-    @Test
-    public void capacityTestDefaultConstructor() {
-        capacityTestDefaultConstructor(new HashMap<>());
-        capacityTestDefaultConstructor(new LinkedHashMap<>());
+    /*
+     * tests for lazy table allocation
+     */
+
+    @DataProvider(name = "lazy")
+    public Object[][] lazyTableAllocationCases() {
+        return new Object[][]{
+                {new HashMap<>()},
+                // { new WeakHashMap<>() }, // WHM doesn't allocate lazily
+                {new LinkedHashMap<>()}
+        };
     }
 
-    void capacityTestDefaultConstructor(HashMap<Integer, Integer> map) {
+    @Test(dataProvider = "lazy")
+    public void lazyTableAllocation(Map<?, ?> map) {
         assertNull(table(map));
+    }
+
+    /*
+     * tests for default capacity (no-arg constructor)
+     */
+
+    @DataProvider(name = "defaultCapacity")
+    public Object[][] defaultCapacityCases() {
+        return new Supplier<?>[][]{
+                {() -> new HashMap<>()},
+                {() -> new LinkedHashMap<>()},
+                {() -> new WeakHashMap<>()}
+        };
+    }
+
+    @Test(dataProvider = "defaultCapacity")
+    public void defaultCapacity(Supplier<Map<String, String>> s) {
+        Map<String, String> map = s.get();
+        map.put("", "");
+        assertEquals(capacity(map), 16);
+    }
+
+    /*
+     * tests for requested capacity (int and int+float constructors)
+     */
+
+    @DataProvider(name = "requestedCapacity")
+    public Iterator<Object[]> requestedCapacityCases() {
+        ArrayList<Object[]> cases = new ArrayList<>();
+        for (int i = 2; i < 64; i++) {
+            int cap = i;
+            cases.add(new Object[]{"rhm1", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap)});
+            cases.add(new Object[]{"rhm2", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap, 0.75f)});
+            cases.add(new Object[]{"rlm1", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap)});
+            cases.add(new Object[]{"rlm2", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap, 0.75f)});
+            cases.add(new Object[]{"rwm1", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap)});
+            cases.add(new Object[]{"rwm2", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap, 0.75f)});
+        }
+        return cases.iterator();
+    }
+
+    @Test(dataProvider = "requestedCapacity")
+    public void requestedCapacity(String label, int cap, Supplier<Map<String, String>> s) {
+        Map<String, String> map = s.get();
+        map.put("", "");
+        assertEquals(capacity(map), tableSizeFor(cap));
+    }
+
+    /*
+     * Tests for capacity after map is populated with a given number N of mappings.
+     * Maps are populated using a copy constructor on a map with N mappings,
+     * other constructors followed by N put() calls, and other constructors followed
+     * by putAll() on a map with N mappings.
+     *
+     * String labels encode the test case for ease of diagnosis if one of the test cases fails.
+     * For example, "plm2pn" is "populated LinkedHashMap, 2-arg constructor, followed by putN".
+     */
+
+    // helper method for one populated capacity case, to provide target types for lambdas
+    Object[] pcc(String label,
+                 int size,
+                 int expectedCapacity,
+                 Supplier<Map<String, String>> supplier,
+                 Consumer<Map<String, String>> consumer) {
+        return new Object[]{label, size, expectedCapacity, supplier, consumer};
+    }
+
+    List<Object[]> genPopulatedCapacityCases(int size, int cap) {
+        return Arrays.asList(
+                pcc("phmcpy", size, cap, () -> new HashMap<>(makeMap(size)),       map -> { }),
+                pcc("phm0pn", size, cap, () -> new HashMap<>(),                    map -> { putN(map, size); }),
+                pcc("phm1pn", size, cap, () -> new HashMap<>(cap),                 map -> { putN(map, size); }),
+                pcc("phm2pn", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { putN(map, size); }),
+                pcc("phm0pa", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(makeMap(size)); }),
+                pcc("phm1pa", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(makeMap(size)); }),
+                pcc("phm2pa", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(makeMap(size)); }),
+
+                pcc("plmcpy", size, cap, () -> new LinkedHashMap<>(makeMap(size)), map -> { }),
+                pcc("plm0pn", size, cap, () -> new LinkedHashMap<>(),              map -> { putN(map, size); }),
+                pcc("plm1pn", size, cap, () -> new LinkedHashMap<>(cap),           map -> { putN(map, size); }),
+                pcc("plm2pn", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { putN(map, size); }),
+                pcc("plm0pa", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(makeMap(size)); }),
+                pcc("plm1pa", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(makeMap(size)); }),
+                pcc("plm2pa", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(makeMap(size)); }),
+
+                pcc("pwmcpy", size, cap, () -> new WeakHashMap<>(makeMap(size)),   map -> { }),
+                pcc("pwm0pn", size, cap, () -> new WeakHashMap<>(),                map -> { putN(map, size); }),
+                pcc("pwm1pn", size, cap, () -> new WeakHashMap<>(cap),             map -> { putN(map, size); }),
+                pcc("pwm2pn", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { putN(map, size); }),
+                pcc("pwm0pa", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(makeMap(size)); }),
+                pcc("pwm1pa", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(makeMap(size)); }),
+                pcc("pwm2pa", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(makeMap(size)); })
+        );
+    }
+
+    List<Object[]> genFakePopulatedCapacityCases(int size, int cap) {
+        return Arrays.asList(
+                pcc("fhmcpy", size, cap, () -> new HashMap<>(fakeMap(size)),       map -> { }),
+                pcc("fhm0pa", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(fakeMap(size)); }),
+                pcc("fhm1pa", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(fakeMap(size)); }),
+                pcc("fhm2pa", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(fakeMap(size)); }),
+
+                pcc("flmcpy", size, cap, () -> new LinkedHashMap<>(fakeMap(size)), map -> { }),
+                pcc("flm0pa", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(fakeMap(size)); }),
+                pcc("flm1pa", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(fakeMap(size)); }),
+                pcc("flm2pa", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(fakeMap(size)); }),
 
-        map.put(1, 1);
-        assertEquals(capacity(map), 16); // default initial capacity
+                pcc("fwmcpy", size, cap, () -> new WeakHashMap<>(fakeMap(size)),   map -> { }),
+             // pcc("fwm0pa", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), // see note
+                pcc("fwm1pa", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(fakeMap(size)); }),
+                pcc("fwm2pa", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(fakeMap(size)); })
+        );
 
-        map.putAll(IntStream.range(0, 64).boxed().collect(toMap(i -> i, i -> i)));
-        assertEquals(capacity(map), 128);
+        // Test case "fwm0pa" is commented out because WeakHashMap uses a different allocation
+        // policy from the other map implementations: it deliberately under-allocates in this case.
     }
 
-    @Test
-    public void capacityTestInitialCapacity() {
-        int initialCapacity = rnd.nextInt(2, 128);
-        List<Supplier<HashMap<Integer, Integer>>> suppliers = List.of(
-            () -> new HashMap<>(initialCapacity),
-            () -> new HashMap<>(initialCapacity, 0.75f),
-            () -> new LinkedHashMap<>(initialCapacity),
-            () -> new LinkedHashMap<>(initialCapacity, 0.75f));
+    @DataProvider(name = "populatedCapacity")
+    public Iterator<Object[]> populatedCapacityCases() {
+        ArrayList<Object[]> cases = new ArrayList<>();
+        cases.addAll(genPopulatedCapacityCases(12,  16));
+        cases.addAll(genPopulatedCapacityCases(13,  32));
+        cases.addAll(genPopulatedCapacityCases(24,  32));
+        cases.addAll(genPopulatedCapacityCases(25,  64));
+        cases.addAll(genPopulatedCapacityCases(48,  64));
+        cases.addAll(genPopulatedCapacityCases(49, 128));
 
-        for (Supplier<HashMap<Integer, Integer>> supplier : suppliers) {
-            HashMap<Integer, Integer> map = supplier.get();
-            assertNull(table(map));
+        // numbers in this range are truncated by a float computation with 0.75f
+        // but can get an exact result with a double computation with 0.75d
+        // Android-removed: cause OOM.
+        // cases.addAll(genFakePopulatedCapacityCases(25165824,  33554432));
+        // cases.addAll(genFakePopulatedCapacityCases(25165825,  67108864));
+        // cases.addAll(genFakePopulatedCapacityCases(50331648,  67108864));
+        // cases.addAll(genFakePopulatedCapacityCases(50331649, 134217728));
 
-            map.put(1, 1);
-            assertEquals(capacity(map), tableSizeFor(initialCapacity));
+        return cases.iterator();
+    }
+
+    @Test(dataProvider = "populatedCapacity")
+    public void populatedCapacity(String label, // unused, included for diagnostics
+                                  int size,     // unused, included for diagnostics
+                                  int expectedCapacity,
+                                  Supplier<Map<String, String>> s,
+                                  Consumer<Map<String, String>> c) {
+        Map<String, String> map = s.get();
+        c.accept(map);
+        assertEquals(capacity(map), expectedCapacity);
+    }
+
+    /*
+     * tests for requested size (static factory methods)
+     */
+
+    // helper method for one requested size case, to provide target types for lambda
+    Object[] rsc(String label,
+                 int size,
+                 int expectedCapacity,
+                 Supplier<Capacitiable> supplier) {
+        return new Object[]{label, size, expectedCapacity, supplier};
+    }
+
+    List<Object[]> genRequestedSizeCases(int size, int cap) {
+        return Arrays.asList(
+                rsc("rshm", size, cap, () -> new MapCapacitiable(HashMap.newHashMap(size))),
+                rsc("rslm", size, cap, () -> new MapCapacitiable(LinkedHashMap.newLinkedHashMap(size))),
+                rsc("rswm", size, cap, () -> new MapCapacitiable(WeakHashMap.newWeakHashMap(size))),
+                rsc("rshs", size, cap, () -> new SetCapacitiable(HashSet.newHashSet(size))),
+                rsc("rsls", size, cap, () -> new SetCapacitiable(LinkedHashSet.newLinkedHashSet(size)))
+        );
+    }
+
+    @DataProvider(name = "requestedSize")
+    public Iterator<Object[]> requestedSizeCases() {
+        ArrayList<Object[]> cases = new ArrayList<>();
+        cases.addAll(genRequestedSizeCases(12,  16));
+        cases.addAll(genRequestedSizeCases(13,  32));
+        cases.addAll(genRequestedSizeCases(24,  32));
+        cases.addAll(genRequestedSizeCases(25,  64));
+        cases.addAll(genRequestedSizeCases(48,  64));
+        cases.addAll(genRequestedSizeCases(49, 128));
+
+        // numbers in this range are truncated by a float computation with 0.75f
+        // but can get an exact result with a double computation with 0.75d
+        // Android-removed: cause OOM.
+        // cases.addAll(genRequestedSizeCases(25165824,  33554432));
+        // cases.addAll(genRequestedSizeCases(25165825,  67108864));
+        // cases.addAll(genRequestedSizeCases(50331648,  67108864));
+        // cases.addAll(genRequestedSizeCases(50331649, 134217728));
+
+        return cases.iterator();
+    }
+
+    @Test(dataProvider = "requestedSize")
+    public void requestedSize(String label,  // unused, included for diagnostics
+                              int size,      // unused, included for diagnostics
+                              int expectedCapacity,
+                              Supplier<Capacitiable> s) {
+        Capacitiable capacitiable = s.get();
+        capacitiable.init();
+        assertEquals(capacitiable.capacity(), expectedCapacity);
+    }
+
+    interface Capacitiable {
+
+        void init();
+
+        int capacity();
+
+    }
+
+    class MapCapacitiable implements Capacitiable {
+
+        private final Map<String, String> content;
+
+        public MapCapacitiable(Map<String, String> content) {
+            this.content = content;
+        }
+
+        @Override
+        public void init() {
+            content.put("", "");
+        }
+
+        @Override
+        public int capacity() {
+            return table(content).length;
         }
     }
+
+    class SetCapacitiable implements Capacitiable {
+
+        private final Set<String> content;
+
+        public SetCapacitiable(Set<String> content) {
+            this.content = content;
+        }
+
+        @Override
+        public void init() {
+            content.add("");
+        }
+
+        @Override
+        public int capacity() {
+            HashMap<?, ?> hashMap = (HashMap<?, ?>) HS_MAP.get(content);
+            return table(hashMap).length;
+        }
+    }
+
+    @DataProvider(name = "negativeNumMappings")
+    public Iterator<Object[]> negativeNumMappings() {
+        final List<Object[]> methods = new ArrayList<>();
+        methods.add(new Object[] {(IntFunction<?>) HashMap::newHashMap, "HashMap::newHashMap"});
+        methods.add(new Object[] {(IntFunction<?>) LinkedHashMap::newLinkedHashMap,
+                "LinkedHashMap::newLinkedHashMap"});
+        methods.add(new Object[] {(IntFunction<?>) WeakHashMap::newWeakHashMap,
+                "WeakHashMap::newWeakHashMap"});
+        methods.add(new Object[] {(IntFunction<?>) HashSet::newHashSet, "HashSet::newHashSet"});
+        methods.add(new Object[] {(IntFunction<?>) LinkedHashSet::newLinkedHashSet,
+                "LinkedHashSet::newLinkedHashSet"});
+        return methods.iterator();
+    }
+
+    /**
+     * Tests that the APIs that take {@code numMappings} or {@code numElements} as a parameter for
+     * creating the collection instance (for example: {@link HashMap#newHashMap(int)}), throw
+     * an {@code IllegalArgumentException} when a negative value is passed to them
+     */
+    @Test(dataProvider = "negativeNumMappings")
+    public void testNegativeNumMappings(final IntFunction<?> method, final String methodName) {
+        assertThrows(IllegalArgumentException.class, () -> method.apply(-1));
+    }
 }
diff --git a/ojluni/src/test/java/util/IdentityHashMap/Basic.java b/ojluni/src/test/java/util/IdentityHashMap/Basic.java
new file mode 100644
index 00000000000..659ca7d1bf1
--- /dev/null
+++ b/ojluni/src/test/java/util/IdentityHashMap/Basic.java
@@ -0,0 +1,769 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package test.java.util.IdentityHashMap;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.IdentityHashMap;
+import java.util.Set;
+import java.util.function.BiPredicate;
+import java.util.stream.IntStream;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import static java.util.Map.entry;
+import static org.testng.Assert.*;
+
+/*
+ * @test
+ * @bug 8285295 8178355
+ * @summary Basic tests for IdentityHashMap
+ * @run testng Basic
+ */
+
+// NOTE: avoid using TestNG's assertEquals/assertNotEquals directly on two IDHM instances,
+// as its logic for testing collections equality is suspect. Use checkEntries() to assert
+// that a map's entrySet contains exactly the expected mappings. There are no guarantees about
+// the identities of Map.Entry instances obtained from the entrySet; however, the keys and
+// values they contain are guaranteed to have the right identity.
+
+// TODO add tests using null keys and values
+// TODO deeper testing of view collections including iterators, equals, contains, etc.
+// TODO Map.Entry::setValue
+
+public class Basic {
+    /*
+     * Helpers
+     */
+
+    record Box(int i) {
+        Box(Box other) {
+            this(other.i());
+        }
+    }
+
+    // Checks that a collection contains exactly the given elements and no others, using the
+    // provided predicate for equivalence. Checking is performed both using contains() on the
+    // collection and by simple array searching. The latter is O(N^2) so is suitable only for
+    // small arrays. No two of the given elements can be equivalent according to the predicate.
+
+    // TODO: read out the elements using iterator and stream and check them too
+
+    @SafeVarargs
+    private <E> void checkContents(Collection<E> c, BiPredicate<E,E> p, E... given) {
+        @SuppressWarnings("unchecked")
+        E[] contents = (E[]) c.toArray();
+
+        assertEquals(c.size(), given.length);
+        assertEquals(contents.length, given.length);
+        final int LEN = given.length;
+
+        for (E e : given) {
+            assertTrue(c.contains(e));
+        }
+
+        // Fill indexes array with position of a given element in the contents array,
+        // or -1 if the given element cannot be found.
+
+        int[] indexes = new int[LEN];
+
+        outer:
+        for (int i = 0; i < LEN; i++) {
+            for (int j = 0; j < LEN; j++) {
+                if (p.test(given[i], contents[j])) {
+                    indexes[i] = j;
+                    continue outer;
+                }
+            }
+            indexes[i] = -1;
+        }
+
+        // If every given element matches a distinct element in the contents array,
+        // the sorted indexes array will be the sequence [0..LEN-1].
+
+        Arrays.sort(indexes);
+        assertEquals(indexes, IntStream.range(0, LEN).toArray());
+    }
+
+    // Checks that the collection contains the given boxes, by identity.
+    private void checkElements(Collection<Box> c, Box... given) {
+        checkContents(c, (b1, b2) -> b1 == b2, given);
+    }
+
+    // Checks that the collection contains entries that have identical keys and values.
+    // The entries themselves are not checked for identity.
+    @SafeVarargs
+    private void checkEntries(Collection<Map.Entry<Box, Box>> c, Map.Entry<Box, Box>... given) {
+        checkContents(c, (e1, e2) -> e1.getKey() == e2.getKey() && e1.getValue() == e2.getValue(), given);
+    }
+
+    /*
+     * Setup
+     */
+
+    final Box k1a = new Box(17);
+    final Box k1b = new Box(17); // equals but != k1a
+    final Box k2  = new Box(42);
+
+    final Box v1a = new Box(30);
+    final Box v1b = new Box(30); // equals but != v1a
+    final Box v2  = new Box(99);
+
+    IdentityHashMap<Box, Box> map;
+    IdentityHashMap<Box, Box> map2;
+
+    @BeforeMethod
+    public void setup() {
+        map = new IdentityHashMap<>();
+        map.put(k1a, v1a);
+        map.put(k1b, v1b);
+        map.put(k2,  v2);
+
+        map2 = new IdentityHashMap<>();
+        map2.put(k1a, v1a);
+        map2.put(k1b, v1b);
+        map2.put(k2,  v2);
+    }
+
+    /*
+     * Tests
+     */
+
+    // containsKey
+    // containsValue
+    // size
+    @Test
+    public void testSizeContainsKeyValue() {
+        assertEquals(map.size(), 3);
+
+        assertTrue(map.containsKey(k1a));
+        assertTrue(map.containsKey(k1b));
+        assertTrue(map.containsKey(k2));
+        assertFalse(map.containsKey(new Box(k1a)));
+
+        assertTrue(map.containsValue(v1a));
+        assertTrue(map.containsValue(v1b));
+        assertFalse(map.containsValue(new Box(v1a)));
+        assertTrue(map.containsValue(v2));
+    }
+
+    // get
+    @Test
+    public void testGet() {
+        assertSame(map.get(k1a), v1a);
+        assertSame(map.get(k1b), v1b);
+        assertSame(map.get(k2), v2);
+        assertNull(map.get(new Box(k1a)));
+    }
+
+    // getOrDefault
+    @Test
+    public void testGetOrDefault() {
+        Box other = new Box(22);
+
+        assertSame(map.getOrDefault(k1a, other), v1a);
+        assertSame(map.getOrDefault(k1b, other), v1b);
+        assertSame(map.getOrDefault(new Box(k1a), other), other);
+        assertSame(map.getOrDefault(k2, other), v2);
+    }
+
+    // clear
+    // isEmpty
+    @Test
+    public void testClearEmpty() {
+        assertFalse(map.isEmpty());
+        map.clear();
+        assertTrue(map.isEmpty());
+    }
+
+    // hashCode
+    @Test
+    public void testHashCode() {
+        int expected = (System.identityHashCode(k1a) ^ System.identityHashCode(v1a)) +
+                       (System.identityHashCode(k1b) ^ System.identityHashCode(v1b)) +
+                       (System.identityHashCode(k2)  ^ System.identityHashCode(v2));
+        assertEquals(map.hashCode(), expected);
+        assertEquals(map.entrySet().hashCode(), expected);
+    }
+
+    // equals
+    @Test
+    public void testEquals() {
+        assertTrue(map.equals(map));
+        assertTrue(map.equals(map2));
+        assertTrue(map2.equals(map));
+
+        assertTrue(map.keySet().equals(map.keySet()));
+        assertTrue(map.keySet().equals(map2.keySet()));
+        assertTrue(map2.keySet().equals(map.keySet()));
+
+        assertTrue(map.entrySet().equals(map.entrySet()));
+        assertTrue(map.entrySet().equals(map2.entrySet()));
+        assertTrue(map2.entrySet().equals(map.entrySet()));
+    }
+
+    // equals
+    @Test
+    public void testEqualsDifferentKey() {
+        map2.remove(k1a);
+        map2.put(new Box(k1a), v1a);
+
+        assertFalse(map.equals(map2));
+        assertFalse(map2.equals(map));
+
+        assertFalse(map.keySet().equals(map2.keySet()));
+        assertFalse(map2.keySet().equals(map.keySet()));
+
+        assertFalse(map.entrySet().equals(map2.entrySet()));
+        assertFalse(map2.entrySet().equals(map.entrySet()));
+    }
+
+    // equals
+    @Test
+    public void testEqualsDifferentValue() {
+        map2.put(k1a, new Box(v1a));
+
+        assertFalse(map.equals(map2));
+        assertFalse(map2.equals(map));
+
+        assertTrue(map.keySet().equals(map2.keySet()));
+        assertTrue(map2.keySet().equals(map.keySet()));
+
+        assertFalse(map.entrySet().equals(map2.entrySet()));
+        assertFalse(map2.entrySet().equals(map.entrySet()));
+    }
+
+    // equals
+    @Test
+    public void testEqualsNewMapping() {
+        map.put(new Box(k1a), new Box(v1a));
+
+        assertFalse(map.equals(map2));
+        assertFalse(map2.equals(map));
+
+        assertFalse(map.keySet().equals(map2.keySet()));
+        assertFalse(map2.keySet().equals(map.keySet()));
+
+        assertFalse(map.entrySet().equals(map2.entrySet()));
+        assertFalse(map2.entrySet().equals(map.entrySet()));
+    }
+
+    // equals
+    @Test
+    public void testEqualsMissingMapping() {
+        var tmp = new IdentityHashMap<Box, Box>();
+        tmp.put(k1a, v1a);
+        tmp.put(k1b, v1b);
+
+        assertFalse(map.equals(tmp));
+        assertFalse(tmp.equals(map));
+
+        assertFalse(map.keySet().equals(tmp.keySet()));
+        assertFalse(tmp.keySet().equals(map.keySet()));
+
+        assertFalse(map.entrySet().equals(tmp.entrySet()));
+        assertFalse(tmp.entrySet().equals(map.entrySet()));
+    }
+
+    // keySet equals, contains
+    @Test
+    public void testKeySet() {
+        Set<Box> keySet = map.keySet();
+
+        checkElements(keySet, k1a, k1b, k2);
+        assertFalse(keySet.contains(new Box(k1a)));
+        assertTrue(map.keySet().equals(map2.keySet()));
+        assertTrue(map2.keySet().equals(map.keySet()));
+    }
+
+    // keySet remove
+    @Test
+    public void testKeySetNoRemove() {
+        Set<Box> keySet = map.keySet();
+        boolean r = keySet.remove(new Box(k1a));
+
+        assertFalse(r);
+        checkElements(keySet, k1a, k1b, k2);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+        assertTrue(map.keySet().equals(map2.keySet()));
+        assertTrue(map2.keySet().equals(map.keySet()));
+    }
+
+    // keySet remove
+    @Test
+    public void testKeySetRemove() {
+        Set<Box> keySet = map.keySet();
+        boolean r = keySet.remove(k1a);
+
+        assertTrue(r);
+        checkElements(keySet, k1b, k2);
+        checkEntries(map.entrySet(), entry(k1b, v1b),
+                                     entry(k2, v2));
+        assertFalse(map.keySet().equals(map2.keySet()));
+        assertFalse(map2.keySet().equals(map.keySet()));
+    }
+
+    // values
+    @Test
+    public void testValues() {
+        Collection<Box> values = map.values();
+        checkElements(values, v1a, v1b, v2);
+        assertFalse(values.contains(new Box(v1a)));
+    }
+
+    // values remove
+    @Test
+    public void testValuesNoRemove() {
+        Collection<Box> values = map.values();
+        boolean r = values.remove(new Box(v1a));
+
+        assertFalse(r);
+        checkElements(values, v1a, v1b, v2);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // values remove
+    @Test
+    public void testValuesRemove() {
+        Collection<Box> values = map.values();
+        boolean r = values.remove(v1a);
+
+        assertTrue(r);
+        checkElements(values, v1b, v2);
+        checkEntries(map.entrySet(), entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // entrySet equals, contains
+    @Test
+    public void testEntrySet() {
+        Set<Map.Entry<Box,Box>> entrySet = map.entrySet();
+
+        assertFalse(entrySet.contains(entry(new Box(k1a), v1a)));
+        assertFalse(entrySet.contains(entry(k1b, new Box(v1b))));
+        assertFalse(entrySet.contains(entry(new Box(k2), new Box(v2))));
+        assertTrue(map.entrySet().equals(map2.entrySet()));
+        checkEntries(entrySet, entry(k1a, v1a),
+                               entry(k1b, v1b),
+                               entry(k2, v2));
+    }
+
+    // entrySet remove
+    @Test
+    public void testEntrySetNoRemove() {
+        Set<Map.Entry<Box, Box>> entrySet = map.entrySet();
+        boolean r1 = entrySet.remove(entry(new Box(k1a), v1a));
+        boolean r2 = entrySet.remove(entry(k1a, new Box(v1a)));
+
+        assertFalse(r1);
+        assertFalse(r2);
+        assertTrue(entrySet.equals(map2.entrySet()));
+        checkEntries(entrySet, entry(k1a, v1a),
+                               entry(k1b, v1b),
+                               entry(k2, v2));
+    }
+
+    // entrySet remove
+    @Test
+    public void testEntrySetRemove() {
+        Set<Map.Entry<Box, Box>> entrySet = map.entrySet();
+        boolean r = entrySet.remove(Map.entry(k1a, v1a));
+
+        assertTrue(r);
+        assertFalse(entrySet.equals(map2.entrySet()));
+        assertFalse(map.entrySet().equals(map2.entrySet()));
+        checkEntries(entrySet, entry(k1b, v1b),
+                               entry(k2, v2));
+        checkEntries(map.entrySet(), entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // put
+    @Test
+    public void testPutNew() {
+        Box newKey = new Box(k1a);
+        Box newVal = new Box(v1a);
+        Box r = map.put(newKey, newVal);
+
+        assertNull(r);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // put
+    @Test
+    public void testPutOverwrite() {
+        Box newVal = new Box(v1a);
+        Box r = map.put(k1a, newVal);
+
+        assertSame(r, v1a);
+        checkEntries(map.entrySet(), entry(k1a, newVal),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // putAll
+    @Test
+    public void testPutAll() {
+        Box newKey  = new Box(k1a);
+        Box newVal  = new Box(v1a);
+        Box newValB = new Box(v1b);
+        var argMap = new IdentityHashMap<Box, Box>();
+        argMap.put(newKey, newVal); // new entry
+        argMap.put(k1b, newValB);   // will overwrite value
+        map.putAll(argMap);
+
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, newValB),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // putIfAbsent
+    @Test
+    public void testPutIfAbsentNoop() {
+        Box r = map.putIfAbsent(k1a, new Box(v1a)); // no-op
+
+        assertSame(r, v1a);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // putIfAbsent
+    @Test
+    public void testPutIfAbsentAddsNew() {
+        Box newKey = new Box(k1a);
+        Box newVal = new Box(v1a);
+        Box r = map.putIfAbsent(newKey, newVal); // adds new entry
+
+        assertNull(r);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // remove(Object)
+    @Test
+    public void testRemoveKey() {
+        Box r = map.remove(k1b);
+
+        assertSame(r, v1b);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k2, v2));
+    }
+
+    // remove(Object, Object) absent key, absent value
+    @Test
+    public void testRemoveAA() {
+        Box k1c = new Box(k1a);
+        Box v1c = new Box(v1a);
+        assertFalse(map.remove(k1c, v1c));
+        checkEntries(map.entrySet(),
+                entry(k1a, v1a),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // remove(Object, Object) absent key, present value
+    @Test
+    public void testRemoveAV() {
+        Box k1c = new Box(k1a);
+        assertFalse(map.remove(k1c, v1a));
+        checkEntries(map.entrySet(),
+                     entry(k1a, v1a),
+                     entry(k1b, v1b),
+                     entry(k2, v2));
+    }
+
+    // remove(Object, Object) present key, absent value
+    @Test
+    public void testRemoveKA() {
+        Box v1c = new Box(v1a);
+        assertFalse(map.remove(k1a, v1c));
+        checkEntries(map.entrySet(),
+                entry(k1a, v1a),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // remove(Object, Object) present key, present value
+    @Test
+    public void testRemoveKV() {
+        assertTrue(map.remove(k1a, v1a));
+        checkEntries(map.entrySet(),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // replace(K, V, V) absent key, absent oldValue
+    @Test
+    public void testReplaceAA() {
+        Box k1c = new Box(k1a);
+        Box v1c = new Box(v1a);
+        Box newVal = new Box(v2);
+        assertFalse(map.replace(k1c, v1c, newVal));
+        checkEntries(map.entrySet(),
+                entry(k1a, v1a),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // replace(K, V, V) absent key, present oldValue
+    @Test
+    public void testReplaceAV() {
+        Box k1c = new Box(k1a);
+        Box newVal = new Box(v2);
+        assertFalse(map.replace(k1c, v1a, newVal));
+        checkEntries(map.entrySet(),
+                entry(k1a, v1a),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // replace(K, V, V) present key, absent oldValue
+    @Test
+    public void testReplaceKA() {
+        Box v1c = new Box(v1a);
+        Box newVal = new Box(v2);
+        assertFalse(map.replace(k1a, v1c, newVal));
+        checkEntries(map.entrySet(),
+                entry(k1a, v1a),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // replace(K, V, V) present key, present oldValue
+    @Test
+    public void testReplaceKV() {
+        Box newVal = new Box(v2);
+        assertTrue(map.replace(k1a, v1a, newVal));
+        checkEntries(map.entrySet(),
+                entry(k1a, newVal),
+                entry(k1b, v1b),
+                entry(k2, v2));
+    }
+
+    // AN: key absent, remappingFunction returns null
+    @Test
+    public void testComputeAN() {
+        Box newKey = new Box(k1a);
+        Box r = map.compute(newKey, (k, v) -> null);
+
+        assertNull(r);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // AV: key absent, remappingFunction returns non-null value
+    @Test
+    public void testComputeAV() {
+        Box newKey = new Box(k1a);
+        Box newVal = new Box(v1a);
+        Box r = map.compute(newKey, (k, v) -> newVal);
+
+        assertSame(r, newVal);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // PN: key present, remappingFunction returns null
+    @Test
+    public void testComputePN() {
+        Box r = map.compute(k1a, (k, v) -> null);
+
+        assertNull(r);
+        checkEntries(map.entrySet(), entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // PV: key present, remappingFunction returns non-null value
+    @Test
+    public void testComputePV() {
+        Box newVal = new Box(v1a);
+        Box r = map.compute(k1a, (k, v) -> newVal);
+
+        assertSame(r, newVal);
+        checkEntries(map.entrySet(), entry(k1a, newVal),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // computeIfAbsent
+    @Test
+    public void testComputeIfAbsentIsCalled() {
+        boolean[] called = new boolean[1];
+        Box newKey = new Box(k1a);
+        Box newVal = new Box(v1a);
+        Box r = map.computeIfAbsent(newKey, k -> { called[0] = true; return newVal; });
+
+        assertSame(r, newVal);
+        assertTrue(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // computeIfAbsent
+    @Test
+    public void testComputeIfAbsentNotCalled() {
+        boolean[] called = new boolean[1];
+        Box r = map.computeIfAbsent(k1a, k -> { called[0] = true; return null; });
+
+        assertSame(r, v1a);
+        assertFalse(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // computeIfAbsent
+    @Test
+    public void testComputeIfAbsentNullReturn() {
+        boolean[] called = new boolean[1];
+        Box newKey = new Box(k1a);
+        Box r = map.computeIfAbsent(newKey, k -> { called[0] = true; return null; });
+
+        assertNull(r);
+        assertTrue(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // computeIfPresent
+    @Test
+    public void testComputeIfPresentIsCalled() {
+        boolean[] called = new boolean[1];
+        Box newVal = new Box(v1a);
+        Box r = map.computeIfPresent(k1a, (k, v) -> { called[0] = true; return newVal; });
+
+        assertSame(r, newVal);
+        assertTrue(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, newVal),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // computeIfPresent
+    @Test
+    public void testComputeIfPresentNotCalled() {
+        boolean[] called = new boolean[1];
+        Box r = map.computeIfPresent(new Box(k1a), (k, v) -> { called[0] = true; return null; });
+
+        assertNull(r);
+        assertFalse(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // computeIfPresent
+    @Test
+    public void testComputeIfPresentNullReturn() {
+        boolean[] called = new boolean[1];
+        Box r = map.computeIfPresent(k1a, (k, v) -> { called[0] = true; return null; });
+
+        assertNull(r);
+        assertTrue(called[0]);
+        checkEntries(map.entrySet(), entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // merge
+    @Test
+    public void testMergeAbsent() {
+        boolean[] called = new boolean[1];
+        Box newKey = new Box(k1a);
+        Box newVal = new Box(v1a);
+        Box r = map.merge(newKey, newVal, (v1, v2) -> { called[0] = true; return newVal; });
+
+        assertSame(r, newVal);
+        assertFalse(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, v1a),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2),
+                                     entry(newKey, newVal));
+    }
+
+    // merge
+    @Test
+    public void testMergePresent() {
+        boolean[] called = new boolean[1];
+        Box val2 = new Box(47);
+        Box[] mergedVal = new Box[1];
+        Box r = map.merge(k1a, val2, (v1, v2) -> {
+            called[0] = true;
+            mergedVal[0] = new Box(v1.i + v2.i);
+            return mergedVal[0];
+        });
+
+        assertSame(r, mergedVal[0]);
+        assertTrue(called[0]);
+        checkEntries(map.entrySet(), entry(k1a, mergedVal[0]),
+                                     entry(k1b, v1b),
+                                     entry(k2, v2));
+    }
+
+    // forEach
+    @Test
+    public void testForEach() {
+        @SuppressWarnings("unchecked")
+        List<Map.Entry<Box, Box>> entries = new ArrayList<>();
+        map.forEach((k, v) -> entries.add(entry(k, v)));
+        checkEntries(entries, entry(k1a, v1a),
+                              entry(k1b, v1b),
+                              entry(k2, v2));
+    }
+
+    // replaceAll
+    @Test
+    public void testReplaceAll() {
+        List<Map.Entry<Box, Box>> replacements = new ArrayList<>();
+
+        map.replaceAll((k, v) -> {
+            Box v1 = new Box(v);
+            replacements.add(entry(k, v1));
+            return v1;
+        });
+
+        @SuppressWarnings("unchecked")
+        var replacementArray = (Map.Entry<Box, Box>[]) replacements.toArray(Map.Entry[]::new);
+        checkEntries(map.entrySet(), replacementArray);
+    }
+}
diff --git a/ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java b/ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java
index 1b22ac0f74e..3e298e0fdc6 100644
--- a/ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java
+++ b/ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java
@@ -44,6 +44,7 @@ import java.util.function.BiConsumer;
 import java.util.function.Supplier;
 
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
 
 import android.compat.Compatibility;
@@ -83,7 +84,7 @@ public class AddNonComparable {
         test(new PriorityQueue<>(), AComparable::new,
              (q, e) -> {
                  assertEquals(q.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
 
         test(new PriorityBlockingQueue<>(), NonComparable::new,
@@ -94,7 +95,7 @@ public class AddNonComparable {
         test(new PriorityBlockingQueue<>(), AComparable::new,
              (q, e) -> {
                  assertEquals(q.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
     }
 
@@ -117,7 +118,7 @@ public class AddNonComparable {
         test(new TreeSet<>(), AComparable::new,
              (s, e) -> {
                  assertEquals(s.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
 
         test(new ConcurrentSkipListSet<>(), NonComparable::new,
@@ -128,7 +129,7 @@ public class AddNonComparable {
         test(new ConcurrentSkipListSet<>(), AComparable::new,
              (s, e) -> {
                  assertEquals(s.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
     }
 
@@ -150,7 +151,7 @@ public class AddNonComparable {
         test(new TreeMap<>(), AComparable::new,
              (m, e) -> {
                  assertEquals(m.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
 
         test(new ConcurrentSkipListMap<>(), NonComparable::new,
@@ -161,7 +162,7 @@ public class AddNonComparable {
         test(new ConcurrentSkipListMap<>(), AComparable::new,
              (s, e) -> {
                  assertEquals(s.size(), 1);
-                 assertTrue(e == null);
+                 assertNull(e);
              });
     }
 
diff --git a/ojluni/src/test/java/util/concurrent/tck/AbstractExecutorServiceTest.java b/ojluni/src/test/java/util/concurrent/tck/AbstractExecutorServiceTest.java
index 70745097441..42f2c7afd7f 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AbstractExecutorServiceTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AbstractExecutorServiceTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.security.PrivilegedAction;
 import java.security.PrivilegedExceptionAction;
@@ -54,16 +62,22 @@ import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AbstractExecutorServiceTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AbstractExecutorServiceTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AbstractExecutorServiceTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AbstractExecutorServiceTest.class);
+    // }
 
     /**
      * A no-frills implementation of AbstractExecutorService, designed
@@ -87,6 +101,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * execute(runnable) runs it to completion
      */
+    @Test
     public void testExecuteRunnable() throws Exception {
         ExecutorService e = new DirectExecutorService();
         final AtomicBoolean done = new AtomicBoolean(false);
@@ -104,6 +119,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * Completed submit(callable) returns result
      */
+    @Test
     public void testSubmitCallable() throws Exception {
         ExecutorService e = new DirectExecutorService();
         Future<String> future = e.submit(new StringTask());
@@ -114,6 +130,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * Completed submit(runnable) returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Exception {
         ExecutorService e = new DirectExecutorService();
         Future<?> future = e.submit(new NoOpRunnable());
@@ -124,6 +141,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * Completed submit(runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Exception {
         ExecutorService e = new DirectExecutorService();
         Future<String> future = e.submit(new NoOpRunnable(), TEST_STRING);
@@ -134,6 +152,8 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * A submitted privileged action runs to completion
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitPrivilegedAction() throws Exception {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -155,6 +175,8 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * A submitted privileged exception action runs to completion
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitPrivilegedExceptionAction() throws Exception {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -173,6 +195,8 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * A submitted failed privileged exception action reports exception
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitFailedPrivilegedExceptionAction() throws Exception {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -195,6 +219,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * execute(null runnable) throws NPE
      */
+    @Test
     public void testExecuteNullRunnable() {
         ExecutorService e = new DirectExecutorService();
         try {
@@ -206,6 +231,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * submit(null callable) throws NPE
      */
+    @Test
     public void testSubmitNullCallable() {
         ExecutorService e = new DirectExecutorService();
         try {
@@ -217,6 +243,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * submit(callable).get() throws InterruptedException if interrupted
      */
+    @Test
     public void testInterruptedSubmit() throws InterruptedException {
         final CountDownLatch submitted    = new CountDownLatch(1);
         final CountDownLatch quittingTime = new CountDownLatch(1);
@@ -246,6 +273,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
      * get of submit(callable) throws ExecutionException if callable
      * throws exception
      */
+    @Test
     public void testSubmitEE() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -266,6 +294,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NPE
      */
+    @Test
     public void testInvokeAny1() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -279,6 +308,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testInvokeAny2() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -292,6 +322,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAny3() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -309,6 +340,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task in c completes
      */
+    @Test
     public void testInvokeAny4() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -326,6 +358,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task in c if at least one completes
      */
+    @Test
     public void testInvokeAny5() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -340,6 +373,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NPE
      */
+    @Test
     public void testInvokeAll1() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -353,6 +387,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -364,6 +399,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -380,6 +416,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * get of returned element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testInvokeAll4() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -399,6 +436,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks in c
      */
+    @Test
     public void testInvokeAll5() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -415,6 +453,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAny1() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -428,6 +467,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(null time unit) throws NPE
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -443,6 +483,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testTimedInvokeAny2() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -457,6 +498,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -474,6 +516,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -493,6 +536,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task in c
      */
+    @Test
     public void testTimedInvokeAny5() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -509,6 +553,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAll1() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -522,6 +567,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll(null time unit) throws NPE
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -537,6 +583,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -548,6 +595,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws InterruptedException {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -564,6 +612,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * get of returned element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -584,6 +633,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks in c
      */
+    @Test
     public void testTimedInvokeAll5() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -601,6 +651,7 @@ public class AbstractExecutorServiceTest extends JSR166TestCase {
     /**
      * timed invokeAll cancels tasks not completed by timeout
      */
+    @Test
     public void testTimedInvokeAll6() throws Exception {
         final ExecutorService e = new DirectExecutorService();
         try (PoolCleaner cleaner = cleaner(e)) {
diff --git a/ojluni/src/test/java/util/concurrent/tck/AbstractQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/AbstractQueueTest.java
index c7bb03ca5db..7231bc4594b 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AbstractQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AbstractQueueTest.java
@@ -34,21 +34,29 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.AbstractQueue;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AbstractQueueTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AbstractQueueTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AbstractQueueTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AbstractQueueTest.class);
+    // }
 
     static class Succeed extends AbstractQueue<Integer> {
         public boolean offer(Integer x) {
@@ -75,6 +83,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * add returns true if offer succeeds
      */
+    @Test
     public void testAddS() {
         Succeed q = new Succeed();
         assertTrue(q.add(two));
@@ -83,6 +92,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * add throws ISE true if offer fails
      */
+    @Test
     public void testAddF() {
         Fail q = new Fail();
         try {
@@ -94,6 +104,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * add throws NPE if offer does
      */
+    @Test
     public void testAddNPE() {
         Succeed q = new Succeed();
         try {
@@ -105,6 +116,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * remove returns normally if poll succeeds
      */
+    @Test
     public void testRemoveS() {
         Succeed q = new Succeed();
         q.remove();
@@ -113,6 +125,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * remove throws NSEE if poll returns null
      */
+    @Test
     public void testRemoveF() {
         Fail q = new Fail();
         try {
@@ -124,6 +137,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * element returns normally if peek succeeds
      */
+    @Test
     public void testElementS() {
         Succeed q = new Succeed();
         q.element();
@@ -132,6 +146,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * element throws NSEE if peek returns null
      */
+    @Test
     public void testElementF() {
         Fail q = new Fail();
         try {
@@ -143,6 +158,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         Succeed q = new Succeed();
         try {
@@ -154,6 +170,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         Succeed q = new Succeed();
         try {
@@ -165,6 +182,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         Succeed q = new Succeed();
         Integer[] ints = new Integer[SIZE];
@@ -178,6 +196,7 @@ public class AbstractQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         Succeed q = new Succeed();
         Integer[] ints = new Integer[SIZE];
@@ -192,6 +211,7 @@ public class AbstractQueueTest extends JSR166TestCase {
     /**
      * addAll throws ISE if an add fails
      */
+    @Test
     public void testAddAll4() {
         Fail q = new Fail();
         Integer[] ints = new Integer[SIZE];
diff --git a/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java b/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java
index 438ea56c1f4..3817bc5f249 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedLongSynchronizerTest.java
@@ -36,6 +36,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -43,17 +51,21 @@ import java.util.HashSet;
 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AbstractQueuedLongSynchronizerTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AbstractQueuedLongSynchronizerTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AbstractQueuedLongSynchronizerTest.class);
+    // }
 
     /**
      * A simple mutex class, adapted from the class javadoc.  Exclusive
@@ -162,7 +174,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!sync.isQueued(t)) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
         assertTrue(t.isAlive());
@@ -301,6 +313,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * isHeldExclusively is false upon construction
      */
+    @Test
     public void testIsHeldExclusively() {
         Mutex sync = new Mutex();
         assertFalse(sync.isHeldExclusively());
@@ -309,6 +322,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * acquiring released sync succeeds
      */
+    @Test
     public void testAcquire() {
         Mutex sync = new Mutex();
         sync.acquire();
@@ -320,6 +334,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquire on a released sync succeeds
      */
+    @Test
     public void testTryAcquire() {
         Mutex sync = new Mutex();
         assertTrue(sync.tryAcquire());
@@ -331,6 +346,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasQueuedThreads reports whether there are waiting threads
      */
+    @Test
     public void testHasQueuedThreads() {
         final Mutex sync = new Mutex();
         assertFalse(sync.hasQueuedThreads());
@@ -352,6 +368,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * isQueued(null) throws NullPointerException
      */
+    @Test
     public void testIsQueuedNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -363,6 +380,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * isQueued reports whether a thread is queued
      */
+    @Test
     public void testIsQueued() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -391,6 +409,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getFirstQueuedThread returns first waiting thread or null if none
      */
+    @Test
     public void testGetFirstQueuedThread() {
         final Mutex sync = new Mutex();
         assertNull(sync.getFirstQueuedThread());
@@ -412,6 +431,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasContended reports false if no thread has ever blocked, else true
      */
+    @Test
     public void testHasContended() {
         final Mutex sync = new Mutex();
         assertFalse(sync.hasContended());
@@ -434,6 +454,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getQueuedThreads returns all waiting threads
      */
+    @Test
     public void testGetQueuedThreads() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -462,6 +483,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getExclusiveQueuedThreads returns all exclusive waiting threads
      */
+    @Test
     public void testGetExclusiveQueuedThreads() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -490,6 +512,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getSharedQueuedThreads does not include exclusively waiting threads
      */
+    @Test
     public void testGetSharedQueuedThreads_Exclusive() {
         final Mutex sync = new Mutex();
         assertTrue(sync.getSharedQueuedThreads().isEmpty());
@@ -512,6 +535,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getSharedQueuedThreads returns all shared waiting threads
      */
+    @Test
     public void testGetSharedQueuedThreads_Shared() {
         final BooleanLatch l = new BooleanLatch();
         assertHasSharedQueuedThreads(l, NO_THREADS);
@@ -538,6 +562,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireNanos is interruptible
      */
+    @Test
     public void testTryAcquireNanos_Interruptible() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -554,6 +579,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquire on exclusively held sync fails
      */
+    @Test
     public void testTryAcquireWhenSynced() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -569,6 +595,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireNanos on an exclusively held sync times out
      */
+    @Test
     public void testAcquireNanos_Timeout() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -587,6 +614,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getState is true when acquired and false when not
      */
+    @Test
     public void testGetState() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -614,6 +642,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * acquireInterruptibly succeeds when released, else is interruptible
      */
+    @Test
     public void testAcquireInterruptibly() throws InterruptedException {
         final Mutex sync = new Mutex();
         final BooleanLatch threadStarted = new BooleanLatch();
@@ -634,6 +663,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * owns is true for a condition created by sync else false
      */
+    @Test
     public void testOwns() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -645,6 +675,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * Calling await without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testAwait_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -662,6 +693,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * Calling signal without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testSignal_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -675,6 +707,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * Calling signalAll without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testSignalAll_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -687,10 +720,13 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil without a signal times out
      */
+    @Test
     public void testAwaitTimed_Timeout() { testAwait_Timeout(AwaitMethod.awaitTimed); }
+    @Test
     public void testAwaitNanos_Timeout() { testAwait_Timeout(AwaitMethod.awaitNanos); }
+    @Test
     public void testAwaitUntil_Timeout() { testAwait_Timeout(AwaitMethod.awaitUntil); }
-    public void testAwait_Timeout(AwaitMethod awaitMethod) {
+    private void testAwait_Timeout(AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         sync.acquire();
@@ -701,11 +737,15 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil returns when signalled
      */
+    @Test
     public void testSignal_await()      { testSignal(AwaitMethod.await); }
+    @Test
     public void testSignal_awaitTimed() { testSignal(AwaitMethod.awaitTimed); }
+    @Test
     public void testSignal_awaitNanos() { testSignal(AwaitMethod.awaitNanos); }
+    @Test
     public void testSignal_awaitUntil() { testSignal(AwaitMethod.awaitUntil); }
-    public void testSignal(final AwaitMethod awaitMethod) {
+    private void testSignal(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch acquired = new BooleanLatch();
@@ -731,6 +771,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters(null) throws NullPointerException
      */
+    @Test
     public void testHasWaitersNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -742,6 +783,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength(null) throws NullPointerException
      */
+    @Test
     public void testGetWaitQueueLengthNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -753,6 +795,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws NPE if null
      */
+    @Test
     public void testGetWaitingThreadsNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -764,6 +807,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalArgumentException if not owned
      */
+    @Test
     public void testHasWaitersIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -778,6 +822,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testHasWaitersIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -791,6 +836,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitQueueLengthIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -805,6 +851,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testGetWaitQueueLengthIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -818,6 +865,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitingThreadsIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -832,6 +880,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testGetWaitingThreadsIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -845,6 +894,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters returns true when a thread is waiting, else false
      */
+    @Test
     public void testHasWaiters() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -877,6 +927,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength returns number of waiting threads
      */
+    @Test
     public void testGetWaitQueueLength() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -925,6 +976,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads returns only and all waiting threads
      */
+    @Test
     public void testGetWaitingThreads() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -996,6 +1048,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * awaitUninterruptibly is uninterruptible
      */
+    @Test
     public void testAwaitUninterruptibly() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -1030,11 +1083,15 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil is interruptible
      */
+    @Test
     public void testInterruptible_await()      { testInterruptible(AwaitMethod.await); }
+    @Test
     public void testInterruptible_awaitTimed() { testInterruptible(AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitNanos() { testInterruptible(AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitUntil() { testInterruptible(AwaitMethod.awaitUntil); }
-    public void testInterruptible(final AwaitMethod awaitMethod) {
+    private void testInterruptible(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch pleaseInterrupt = new BooleanLatch();
@@ -1053,11 +1110,15 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * signalAll wakes up all threads
      */
+    @Test
     public void testSignalAll_await()      { testSignalAll(AwaitMethod.await); }
+    @Test
     public void testSignalAll_awaitTimed() { testSignalAll(AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitNanos() { testSignalAll(AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitUntil() { testSignalAll(AwaitMethod.awaitUntil); }
-    public void testSignalAll(final AwaitMethod awaitMethod) {
+    private void testSignalAll(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch acquired1 = new BooleanLatch();
@@ -1094,6 +1155,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * toString indicates current state
      */
+    @Test
     public void testToString() {
         Mutex sync = new Mutex();
         assertTrue(sync.toString().contains("State = " + Mutex.UNLOCKED));
@@ -1104,6 +1166,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * A serialized AQS deserializes with current state, but no queued threads
      */
+    @Test
     public void testSerialization() {
         Mutex sync = new Mutex();
         assertFalse(serialClone(sync).isHeldExclusively());
@@ -1128,6 +1191,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryReleaseShared setting state changes getState
      */
+    @Test
     public void testGetStateWithReleaseShared() {
         final BooleanLatch l = new BooleanLatch();
         assertFalse(l.isSignalled());
@@ -1138,6 +1202,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * releaseShared has no effect when already signalled
      */
+    @Test
     public void testReleaseShared() {
         final BooleanLatch l = new BooleanLatch();
         assertFalse(l.isSignalled());
@@ -1150,6 +1215,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * acquireSharedInterruptibly returns after release, but not before
      */
+    @Test
     public void testAcquireSharedInterruptibly() {
         final BooleanLatch l = new BooleanLatch();
 
@@ -1174,6 +1240,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos returns after release, but not before
      */
+    @Test
     public void testTryAcquireSharedNanos() {
         final BooleanLatch l = new BooleanLatch();
 
@@ -1198,6 +1265,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * acquireSharedInterruptibly is interruptible
      */
+    @Test
     public void testAcquireSharedInterruptibly_Interruptible() {
         final BooleanLatch l = new BooleanLatch();
         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
@@ -1216,6 +1284,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos is interruptible
      */
+    @Test
     public void testTryAcquireSharedNanos_Interruptible() {
         final BooleanLatch l = new BooleanLatch();
         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
@@ -1235,6 +1304,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos times out if not released before timeout
      */
+    @Test
     public void testTryAcquireSharedNanos_Timeout() {
         final BooleanLatch l = new BooleanLatch();
         final BooleanLatch observedQueued = new BooleanLatch();
@@ -1262,6 +1332,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * awaitNanos/timed await with 0 wait times out immediately
      */
+    @Test
     public void testAwait_Zero() throws InterruptedException {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -1274,6 +1345,7 @@ public class AbstractQueuedLongSynchronizerTest extends JSR166TestCase {
     /**
      * awaitNanos/timed await with maximum negative wait times does not underflow
      */
+    @Test
     public void testAwait_NegativeInfinity() throws InterruptedException {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
diff --git a/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java b/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java
index a1f36baa49b..e1f0a0ce42e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AbstractQueuedSynchronizerTest.java
@@ -36,6 +36,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -43,17 +51,21 @@ import java.util.HashSet;
 import java.util.concurrent.locks.AbstractQueuedSynchronizer;
 import java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AbstractQueuedSynchronizerTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AbstractQueuedSynchronizerTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AbstractQueuedSynchronizerTest.class);
+    // }
 
     /**
      * A simple mutex class, adapted from the class javadoc.  Exclusive
@@ -165,7 +177,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!sync.isQueued(t)) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
         assertTrue(t.isAlive());
@@ -304,6 +316,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * isHeldExclusively is false upon construction
      */
+    @Test
     public void testIsHeldExclusively() {
         Mutex sync = new Mutex();
         assertFalse(sync.isHeldExclusively());
@@ -312,6 +325,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * acquiring released sync succeeds
      */
+    @Test
     public void testAcquire() {
         Mutex sync = new Mutex();
         sync.acquire();
@@ -323,6 +337,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquire on a released sync succeeds
      */
+    @Test
     public void testTryAcquire() {
         Mutex sync = new Mutex();
         assertTrue(sync.tryAcquire());
@@ -334,6 +349,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasQueuedThreads reports whether there are waiting threads
      */
+    @Test
     public void testHasQueuedThreads() {
         final Mutex sync = new Mutex();
         assertFalse(sync.hasQueuedThreads());
@@ -355,6 +371,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * isQueued(null) throws NullPointerException
      */
+    @Test
     public void testIsQueuedNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -366,6 +383,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * isQueued reports whether a thread is queued
      */
+    @Test
     public void testIsQueued() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -394,6 +412,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getFirstQueuedThread returns first waiting thread or null if none
      */
+    @Test
     public void testGetFirstQueuedThread() {
         final Mutex sync = new Mutex();
         assertNull(sync.getFirstQueuedThread());
@@ -415,6 +434,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasContended reports false if no thread has ever blocked, else true
      */
+    @Test
     public void testHasContended() {
         final Mutex sync = new Mutex();
         assertFalse(sync.hasContended());
@@ -437,6 +457,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getQueuedThreads returns all waiting threads
      */
+    @Test
     public void testGetQueuedThreads() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -465,6 +486,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getExclusiveQueuedThreads returns all exclusive waiting threads
      */
+    @Test
     public void testGetExclusiveQueuedThreads() {
         final Mutex sync = new Mutex();
         Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
@@ -493,6 +515,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getSharedQueuedThreads does not include exclusively waiting threads
      */
+    @Test
     public void testGetSharedQueuedThreads_Exclusive() {
         final Mutex sync = new Mutex();
         assertTrue(sync.getSharedQueuedThreads().isEmpty());
@@ -515,6 +538,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getSharedQueuedThreads returns all shared waiting threads
      */
+    @Test
     public void testGetSharedQueuedThreads_Shared() {
         final BooleanLatch l = new BooleanLatch();
         assertHasSharedQueuedThreads(l, NO_THREADS);
@@ -541,6 +565,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireNanos is interruptible
      */
+    @Test
     public void testTryAcquireNanos_Interruptible() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -557,6 +582,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquire on exclusively held sync fails
      */
+    @Test
     public void testTryAcquireWhenSynced() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -572,6 +598,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireNanos on an exclusively held sync times out
      */
+    @Test
     public void testAcquireNanos_Timeout() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -590,6 +617,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getState is true when acquired and false when not
      */
+    @Test
     public void testGetState() {
         final Mutex sync = new Mutex();
         sync.acquire();
@@ -617,6 +645,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * acquireInterruptibly succeeds when released, else is interruptible
      */
+    @Test
     public void testAcquireInterruptibly() throws InterruptedException {
         final Mutex sync = new Mutex();
         final BooleanLatch threadStarted = new BooleanLatch();
@@ -637,6 +666,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * owns is true for a condition created by sync else false
      */
+    @Test
     public void testOwns() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -648,6 +678,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * Calling await without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testAwait_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -665,6 +696,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * Calling signal without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testSignal_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -678,6 +710,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * Calling signalAll without holding sync throws IllegalMonitorStateException
      */
+    @Test
     public void testSignalAll_IMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -690,10 +723,13 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil without a signal times out
      */
+    @Test
     public void testAwaitTimed_Timeout() { testAwait_Timeout(AwaitMethod.awaitTimed); }
+    @Test
     public void testAwaitNanos_Timeout() { testAwait_Timeout(AwaitMethod.awaitNanos); }
+    @Test
     public void testAwaitUntil_Timeout() { testAwait_Timeout(AwaitMethod.awaitUntil); }
-    public void testAwait_Timeout(AwaitMethod awaitMethod) {
+    private void testAwait_Timeout(AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         sync.acquire();
@@ -704,11 +740,15 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil returns when signalled
      */
+    @Test
     public void testSignal_await()      { testSignal(AwaitMethod.await); }
+    @Test
     public void testSignal_awaitTimed() { testSignal(AwaitMethod.awaitTimed); }
+    @Test
     public void testSignal_awaitNanos() { testSignal(AwaitMethod.awaitNanos); }
+    @Test
     public void testSignal_awaitUntil() { testSignal(AwaitMethod.awaitUntil); }
-    public void testSignal(final AwaitMethod awaitMethod) {
+    private void testSignal(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch acquired = new BooleanLatch();
@@ -734,6 +774,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters(null) throws NullPointerException
      */
+    @Test
     public void testHasWaitersNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -745,6 +786,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength(null) throws NullPointerException
      */
+    @Test
     public void testGetWaitQueueLengthNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -756,6 +798,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads(null) throws NullPointerException
      */
+    @Test
     public void testGetWaitingThreadsNPE() {
         final Mutex sync = new Mutex();
         try {
@@ -767,6 +810,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalArgumentException if not owned
      */
+    @Test
     public void testHasWaitersIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -781,6 +825,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testHasWaitersIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -794,6 +839,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitQueueLengthIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -808,6 +854,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testGetWaitQueueLengthIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -821,6 +868,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitingThreadsIAE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -835,6 +883,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalMonitorStateException if not synced
      */
+    @Test
     public void testGetWaitingThreadsIMSE() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -848,6 +897,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * hasWaiters returns true when a thread is waiting, else false
      */
+    @Test
     public void testHasWaiters() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -880,6 +930,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitQueueLength returns number of waiting threads
      */
+    @Test
     public void testGetWaitQueueLength() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -928,6 +979,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * getWaitingThreads returns only and all waiting threads
      */
+    @Test
     public void testGetWaitingThreads() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -999,6 +1051,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * awaitUninterruptibly is uninterruptible
      */
+    @Test
     public void testAwaitUninterruptibly() {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -1033,11 +1086,15 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil is interruptible
      */
+    @Test
     public void testInterruptible_await()      { testInterruptible(AwaitMethod.await); }
+    @Test
     public void testInterruptible_awaitTimed() { testInterruptible(AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitNanos() { testInterruptible(AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitUntil() { testInterruptible(AwaitMethod.awaitUntil); }
-    public void testInterruptible(final AwaitMethod awaitMethod) {
+    private void testInterruptible(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch pleaseInterrupt = new BooleanLatch();
@@ -1056,11 +1113,15 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * signalAll wakes up all threads
      */
+    @Test
     public void testSignalAll_await()      { testSignalAll(AwaitMethod.await); }
+    @Test
     public void testSignalAll_awaitTimed() { testSignalAll(AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitNanos() { testSignalAll(AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitUntil() { testSignalAll(AwaitMethod.awaitUntil); }
-    public void testSignalAll(final AwaitMethod awaitMethod) {
+    private void testSignalAll(final AwaitMethod awaitMethod) {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
         final BooleanLatch acquired1 = new BooleanLatch();
@@ -1097,6 +1158,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * toString indicates current state
      */
+    @Test
     public void testToString() {
         Mutex sync = new Mutex();
         assertTrue(sync.toString().contains("State = " + Mutex.UNLOCKED));
@@ -1107,6 +1169,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * A serialized AQS deserializes with current state, but no queued threads
      */
+    @Test
     public void testSerialization() {
         Mutex sync = new Mutex();
         assertFalse(serialClone(sync).isHeldExclusively());
@@ -1131,6 +1194,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryReleaseShared setting state changes getState
      */
+    @Test
     public void testGetStateWithReleaseShared() {
         final BooleanLatch l = new BooleanLatch();
         assertFalse(l.isSignalled());
@@ -1141,6 +1205,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * releaseShared has no effect when already signalled
      */
+    @Test
     public void testReleaseShared() {
         final BooleanLatch l = new BooleanLatch();
         assertFalse(l.isSignalled());
@@ -1153,6 +1218,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * acquireSharedInterruptibly returns after release, but not before
      */
+    @Test
     public void testAcquireSharedInterruptibly() {
         final BooleanLatch l = new BooleanLatch();
 
@@ -1177,6 +1243,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos returns after release, but not before
      */
+    @Test
     public void testTryAcquireSharedNanos() {
         final BooleanLatch l = new BooleanLatch();
 
@@ -1201,6 +1268,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * acquireSharedInterruptibly is interruptible
      */
+    @Test
     public void testAcquireSharedInterruptibly_Interruptible() {
         final BooleanLatch l = new BooleanLatch();
         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
@@ -1219,6 +1287,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos is interruptible
      */
+    @Test
     public void testTryAcquireSharedNanos_Interruptible() {
         final BooleanLatch l = new BooleanLatch();
         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
@@ -1238,6 +1307,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * tryAcquireSharedNanos times out if not released before timeout
      */
+    @Test
     public void testTryAcquireSharedNanos_Timeout() {
         final BooleanLatch l = new BooleanLatch();
         final BooleanLatch observedQueued = new BooleanLatch();
@@ -1265,6 +1335,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * awaitNanos/timed await with 0 wait times out immediately
      */
+    @Test
     public void testAwait_Zero() throws InterruptedException {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
@@ -1277,6 +1348,7 @@ public class AbstractQueuedSynchronizerTest extends JSR166TestCase {
     /**
      * awaitNanos/timed await with maximum negative wait times does not underflow
      */
+    @Test
     public void testAwait_NegativeInfinity() throws InterruptedException {
         final Mutex sync = new Mutex();
         final ConditionObject c = sync.newCondition();
diff --git a/ojluni/src/test/java/util/concurrent/tck/ArrayBlockingQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/ArrayBlockingQueueTest.java
index 23b11d721fe..18477201fbe 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ArrayBlockingQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ArrayBlockingQueueTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -50,39 +58,50 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ThreadLocalRandom;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ArrayBlockingQueueTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return ArrayBlockingQueue.class; }
-            public Collection emptyCollection() {
-                boolean fair = ThreadLocalRandom.current().nextBoolean();
-                return populatedQueue(0, SIZE, 2 * SIZE, fair);
-            }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-
-        return newTestSuite(
-            ArrayBlockingQueueTest.class,
-            new Fair().testSuite(),
-            new NonFair().testSuite(),
-            CollectionTest.testSuite(new Implementation()));
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ArrayBlockingQueueTest");
     }
 
+    // Android-removed: No usage of suite().
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return ArrayBlockingQueue.class; }
+    //         public Collection emptyCollection() {
+    //             boolean fair = ThreadLocalRandom.current().nextBoolean();
+    //             return populatedQueue(0, SIZE, 2 * SIZE, fair);
+    //         }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+
+    //     return newTestSuite(
+    //         ArrayBlockingQueueTest.class,
+    //         new Fair().testSuite(),
+    //         new NonFair().testSuite(),
+    //         CollectionTest.testSuite(new Implementation()));
+    // }
+
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Fair extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return populatedQueue(0, SIZE, 2 * SIZE, true);
         }
     }
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class NonFair extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return populatedQueue(0, SIZE, 2 * SIZE, false);
@@ -126,6 +145,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * A new queue has the indicated capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(SIZE, new ArrayBlockingQueue(SIZE).remainingCapacity());
     }
@@ -133,6 +153,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Constructor throws IAE if capacity argument nonpositive
      */
+    @Test
     public void testConstructor_nonPositiveCapacity() {
         for (int i : new int[] { 0, -1, Integer.MIN_VALUE }) {
             try {
@@ -151,6 +172,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor_nullCollection() {
         try {
             new ArrayBlockingQueue(1, true, null);
@@ -161,6 +183,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
         try {
@@ -172,6 +195,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -186,6 +210,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from too large collection throws IAE
      */
+    @Test
     public void testConstructor_collectionTooLarge() {
         // just barely fits - succeeds
         new ArrayBlockingQueue(SIZE, false,
@@ -200,6 +225,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor7() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -213,6 +239,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue transitions from empty to full when elements added
      */
+    @Test
     public void testEmptyFull() {
         BlockingQueue q = populatedQueue(0, 2, 2, false);
         assertTrue(q.isEmpty());
@@ -228,6 +255,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * remainingCapacity decreases on add, increases on remove
      */
+    @Test
     public void testRemainingCapacity() {
         int size = ThreadLocalRandom.current().nextInt(1, SIZE);
         BlockingQueue q = populatedQueue(size, size, 2 * size, false);
@@ -248,6 +276,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Offer succeeds if not full; fails if full
      */
+    @Test
     public void testOffer() {
         ArrayBlockingQueue q = new ArrayBlockingQueue(1);
         assertTrue(q.offer(zero));
@@ -257,6 +286,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * add succeeds if not full; throws ISE if full
      */
+    @Test
     public void testAdd() {
         ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; i++) assertTrue(q.add((Integer) i));
@@ -270,6 +300,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -282,6 +313,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -296,6 +328,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * addAll throws ISE if not enough room
      */
+    @Test
     public void testAddAll_insufficientSpace() {
         int size = ThreadLocalRandom.current().nextInt(1, SIZE);
         ArrayBlockingQueue q = populatedQueue(0, size, size, false);
@@ -314,6 +347,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -329,6 +363,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() throws InterruptedException {
         ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -342,6 +377,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly if full
      */
+    @Test
     public void testBlockingPut() throws InterruptedException {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -378,6 +414,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly waiting for take when full
      */
+    @Test
     public void testPutWithTake() throws InterruptedException {
         final int capacity = 2;
         final ArrayBlockingQueue q = new ArrayBlockingQueue(capacity);
@@ -412,6 +449,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * timed offer times out if full and elements not taken
      */
+    @Test
     public void testTimedOffer() throws InterruptedException {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(2);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -438,6 +476,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * take retrieves elements in FIFO order
      */
+    @Test
     public void testTake() throws InterruptedException {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -448,6 +487,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final ArrayBlockingQueue q = populatedQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -481,6 +521,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -492,6 +533,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -504,6 +546,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -521,6 +564,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedQueue(SIZE);
         final CountDownLatch aboutToWait = new CountDownLatch(1);
@@ -549,6 +593,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -563,6 +608,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -578,6 +624,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -592,6 +639,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         int size = ThreadLocalRandom.current().nextInt(1, SIZE);
         ArrayBlockingQueue q = populatedQueue(size, size, 2 * size, false);
@@ -606,6 +654,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         int size = ThreadLocalRandom.current().nextInt(1, 5);
         ArrayBlockingQueue q = populatedQueue(size, size, 2 * size, false);
@@ -624,6 +673,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         ArrayBlockingQueue p = new ArrayBlockingQueue(SIZE);
@@ -638,6 +688,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         ArrayBlockingQueue p = populatedQueue(SIZE);
@@ -657,6 +708,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             ArrayBlockingQueue q = populatedQueue(SIZE);
@@ -704,6 +756,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray() and toArray(a) contain all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
         final int size = rnd.nextInt(6);
@@ -729,6 +782,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray_incompatibleArrayType() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -744,6 +798,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() throws InterruptedException {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -763,6 +818,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new ArrayBlockingQueue(SIZE).iterator());
     }
@@ -770,6 +826,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(3);
         q.add(two);
@@ -789,6 +846,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(3);
         q.add(one);
@@ -807,6 +865,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(3);
         q.add(one);
@@ -822,6 +881,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -833,6 +893,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * offer transfers elements across Executor tasks
      */
+    @Test
     public void testOfferInExecutor() {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(2);
         q.add(one);
@@ -860,6 +921,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll retrieves elements across Executor threads
      */
+    @Test
     public void testPollInExecutor() {
         final ArrayBlockingQueue q = new ArrayBlockingQueue(2);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -884,6 +946,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
@@ -902,6 +965,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties queue into another collection c
      */
+    @Test
     public void testDrainTo() {
         ArrayBlockingQueue q = populatedQueue(SIZE);
         ArrayList l = new ArrayList();
@@ -926,6 +990,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo empties full queue, unblocking a waiting put.
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final ArrayBlockingQueue q = populatedQueue(SIZE);
         Thread t = new Thread(new CheckedRunnable() {
@@ -946,6 +1011,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE * 2);
         for (int i = 0; i < SIZE + 2; ++i) {
@@ -965,6 +1031,7 @@ public class ArrayBlockingQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?>[] qs = {
             populatedQueue(0, 1, 10, false),
diff --git a/ojluni/src/test/java/util/concurrent/tck/ArrayDeque8Test.java b/ojluni/src/test/java/util/concurrent/tck/ArrayDeque8Test.java
index a25d036a774..b6a0c6e3b41 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ArrayDeque8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ArrayDeque8Test.java
@@ -33,25 +33,40 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.Spliterator;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ArrayDeque8Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ArrayDeque8Test");
     }
 
-    public static Test suite() {
-        return newTestSuite(ArrayDeque8Test.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(ArrayDeque8Test.class);
+    // }
 
     /**
      * Spliterator.getComparator always throws IllegalStateException
      */
+    @Test
     public void testSpliterator_getComparator() {
         assertThrows(IllegalStateException.class,
                      () -> new ArrayDeque().spliterator().getComparator());
@@ -60,6 +75,7 @@ public class ArrayDeque8Test extends JSR166TestCase {
     /**
      * Spliterator characteristics are as advertised
      */
+    @Test
     public void testSpliterator_characteristics() {
         ArrayDeque q = new ArrayDeque();
         Spliterator s = q.spliterator();
@@ -81,6 +97,7 @@ public class ArrayDeque8Test extends JSR166TestCase {
      * Handle capacities near Integer.MAX_VALUE.
      * ant -Dvmoptions='-Xms28g -Xmx28g' -Djsr166.expensiveTests=true -Djsr166.tckTestClass=ArrayDeque8Test -Djsr166.methodFilter=testHugeCapacity tck
      */
+    @Test
     public void testHugeCapacity() {
         if (! (testImplementationDetails
                && expensiveTests
diff --git a/ojluni/src/test/java/util/concurrent/tck/ArrayDequeTest.java b/ojluni/src/test/java/util/concurrent/tck/ArrayDequeTest.java
index 2b926be74c7..6b8e1752aeb 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ArrayDequeTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ArrayDequeTest.java
@@ -33,6 +33,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -44,25 +53,30 @@ import java.util.Queue;
 import java.util.Random;
 import java.util.concurrent.ThreadLocalRandom;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ArrayDequeTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return ArrayDeque.class; }
-            public Collection emptyCollection() { return populatedDeque(0); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return false; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(ArrayDequeTest.class,
-                            CollectionTest.testSuite(new Implementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ArrayDequeTest");
+    }
+
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return ArrayDeque.class; }
+    //         public Collection emptyCollection() { return populatedDeque(0); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return false; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(ArrayDequeTest.class,
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Returns a new deque of given size containing consecutive
@@ -113,6 +127,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * new deque is empty
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new ArrayDeque().size());
     }
@@ -120,6 +135,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new ArrayDeque((Collection)null);
@@ -130,6 +146,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new ArrayDeque(Arrays.asList(new Integer[SIZE]));
@@ -140,6 +157,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -153,6 +171,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -165,6 +184,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         ArrayDeque q = new ArrayDeque();
         assertTrue(q.isEmpty());
@@ -179,6 +199,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -194,6 +215,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * push(null) throws NPE
      */
+    @Test
     public void testPushNull() {
         ArrayDeque q = new ArrayDeque(1);
         try {
@@ -205,6 +227,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * peekFirst() returns element inserted with push
      */
+    @Test
     public void testPush() {
         ArrayDeque q = populatedDeque(3);
         q.pollLast();
@@ -215,6 +238,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * pop() removes next element, or throws NSEE if empty
      */
+    @Test
     public void testPop() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -229,6 +253,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offer(null) throws NPE
      */
+    @Test
     public void testOfferNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -240,6 +265,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offerFirst(null) throws NPE
      */
+    @Test
     public void testOfferFirstNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -251,6 +277,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offerLast(null) throws NPE
      */
+    @Test
     public void testOfferLastNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -262,6 +289,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offer(x) succeeds
      */
+    @Test
     public void testOffer() {
         ArrayDeque q = new ArrayDeque();
         assertTrue(q.offer(zero));
@@ -273,6 +301,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offerFirst(x) succeeds
      */
+    @Test
     public void testOfferFirst() {
         ArrayDeque q = new ArrayDeque();
         assertTrue(q.offerFirst(zero));
@@ -284,6 +313,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * offerLast(x) succeeds
      */
+    @Test
     public void testOfferLast() {
         ArrayDeque q = new ArrayDeque();
         assertTrue(q.offerLast(zero));
@@ -295,6 +325,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -306,6 +337,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addFirst(null) throws NPE
      */
+    @Test
     public void testAddFirstNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -317,6 +349,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addLast(null) throws NPE
      */
+    @Test
     public void testAddLastNull() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -328,6 +361,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * add(x) succeeds
      */
+    @Test
     public void testAdd() {
         ArrayDeque q = new ArrayDeque();
         assertTrue(q.add(zero));
@@ -339,6 +373,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addFirst(x) succeeds
      */
+    @Test
     public void testAddFirst() {
         ArrayDeque q = new ArrayDeque();
         q.addFirst(zero);
@@ -350,6 +385,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addLast(x) succeeds
      */
+    @Test
     public void testAddLast() {
         ArrayDeque q = new ArrayDeque();
         q.addLast(zero);
@@ -361,6 +397,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -372,6 +409,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         ArrayDeque q = new ArrayDeque();
         try {
@@ -384,6 +422,7 @@ public class ArrayDequeTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         ArrayDeque q = new ArrayDeque();
         Integer[] ints = new Integer[SIZE];
@@ -398,6 +437,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -413,6 +453,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * pollFirst() succeeds unless empty
      */
+    @Test
     public void testPollFirst() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -424,6 +465,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * pollLast() succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -435,6 +477,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * poll() succeeds unless empty
      */
+    @Test
     public void testPoll() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -446,6 +489,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * remove() removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -460,6 +504,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -481,6 +526,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * peekFirst() returns next element, or null if empty
      */
+    @Test
     public void testPeekFirst() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -495,6 +541,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * peek() returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -509,6 +556,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * peekLast() returns next element, or null if empty
      */
+    @Test
     public void testPeekLast() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -523,6 +571,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * element() returns first element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -538,6 +587,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * getFirst() returns first element, or throws NSEE if empty
      */
+    @Test
     public void testFirstElement() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -553,6 +603,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * getLast() returns last element, or throws NSEE if empty
      */
+    @Test
     public void testLastElement() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -569,6 +620,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * removeFirst() removes first element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveFirst() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -584,6 +636,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * removeLast() removes last element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveLast() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -599,6 +652,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * removeFirstOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveFirstOccurrence() {
         Deque<Integer> q = populatedDeque(SIZE);
         assertFalse(q.removeFirstOccurrence(null));
@@ -623,6 +677,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * removeLastOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveLastOccurrence() {
         Deque<Integer> q = populatedDeque(SIZE);
         assertFalse(q.removeLastOccurrence(null));
@@ -647,6 +702,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         ArrayDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -659,6 +715,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         ArrayDeque q = populatedDeque(SIZE);
         q.clear();
@@ -673,6 +730,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         ArrayDeque q = populatedDeque(SIZE);
         ArrayDeque p = new ArrayDeque();
@@ -687,6 +745,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         ArrayDeque q = populatedDeque(SIZE);
         ArrayDeque p = populatedDeque(SIZE);
@@ -702,6 +761,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             ArrayDeque q = populatedDeque(SIZE);
@@ -748,6 +808,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * toArray() and toArray(a) contain all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         final int size = ThreadLocalRandom.current().nextInt(10);
         ArrayDeque<Integer> q = new ArrayDeque<>(size);
@@ -771,6 +832,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * toArray(null) throws NullPointerException
      */
+    @Test
     public void testToArray_NullArg() {
         ArrayDeque l = new ArrayDeque();
         l.add(new Object());
@@ -783,6 +845,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray_incompatibleArrayType() {
         ArrayDeque l = new ArrayDeque();
         l.add(new Integer(5));
@@ -799,6 +862,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         ArrayDeque q = populatedDeque(SIZE);
         Iterator it = q.iterator();
@@ -812,6 +876,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         Deque c = new ArrayDeque();
         assertIteratorExhausted(c.iterator());
@@ -821,6 +886,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final ArrayDeque q = new ArrayDeque();
         q.add(one);
@@ -837,6 +903,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * iterator.remove() removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final ArrayDeque q = new ArrayDeque();
         final Random rng = new Random();
@@ -865,6 +932,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Descending iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         ArrayDeque q = populatedDeque(SIZE);
         int i = 0;
@@ -884,6 +952,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * Descending iterator ordering is reverse FIFO
      */
+    @Test
     public void testDescendingIteratorOrdering() {
         final ArrayDeque q = new ArrayDeque();
         for (int iters = 0; iters < 100; ++iters) {
@@ -905,6 +974,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * descendingIterator.remove() removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final ArrayDeque q = new ArrayDeque();
         final Random rng = new Random();
@@ -933,6 +1003,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * toString() contains toStrings of elements
      */
+    @Test
     public void testToString() {
         ArrayDeque q = populatedDeque(SIZE);
         String s = q.toString();
@@ -944,6 +1015,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * A deserialized serialized deque has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedDeque(SIZE);
         Queue y = serialClone(x);
@@ -963,6 +1035,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * A cloned deque has same elements in same order
      */
+    @Test
     public void testClone() throws Exception {
         ArrayDeque<Integer> x = populatedDeque(SIZE);
         ArrayDeque<Integer> y = x.clone();
@@ -981,6 +1054,7 @@ public class ArrayDequeTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Deque<?>[] qs = {
             new ArrayDeque<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/ArrayListTest.java b/ojluni/src/test/java/util/concurrent/tck/ArrayListTest.java
index b168d50b6a5..75a2112d01e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ArrayListTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ArrayListTest.java
@@ -37,31 +37,29 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
-
 public class ArrayListTest extends JSR166TestCase {
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return ArrayList.class; }
-            public List emptyCollection() { return new ArrayList(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return false; }
-            public boolean permitsNulls() { return true; }
-        }
-        class SubListImplementation extends Implementation {
-            public List emptyCollection() {
-                return super.emptyCollection().subList(0, 0);
-            }
-        }
-        return newTestSuite(
-                // ArrayListTest.class,
-                CollectionTest.testSuite(new Implementation()),
-                CollectionTest.testSuite(new SubListImplementation()));
-    }
+    // Android-removed: Usage of the suite() function.
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return ArrayList.class; }
+    //         public List emptyCollection() { return new ArrayList(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return false; }
+    //         public boolean permitsNulls() { return true; }
+    //     }
+    //     class SubListImplementation extends Implementation {
+    //         public List emptyCollection() {
+    //             return super.emptyCollection().subList(0, 0);
+    //         }
+    //     }
+    //     return newTestSuite(
+    //             // ArrayListTest.class,
+    //             CollectionTest.testSuite(new Implementation()),
+    //             CollectionTest.testSuite(new SubListImplementation()));
+    // }
 
 }
diff --git a/ojluni/src/test/java/util/concurrent/tck/Atomic8Test.java b/ojluni/src/test/java/util/concurrent/tck/Atomic8Test.java
index dc3af4c088a..0d568988346 100644
--- a/ojluni/src/test/java/util/concurrent/tck/Atomic8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/Atomic8Test.java
@@ -33,6 +33,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerArray;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -43,20 +52,24 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 /**
  * Tests of atomic class methods accepting lambdas introduced in JDK8.
  */
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class Atomic8Test extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(Atomic8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.Atomic8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(Atomic8Test.class);
+    // }
 
     static long addLong17(long x) { return x + 17; }
     static int addInt17(int x) { return x + 17; }
@@ -90,6 +103,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLong getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testLongGetAndUpdate() {
         AtomicLong a = new AtomicLong(1L);
         assertEquals(1L, a.getAndUpdate(Atomic8Test::addLong17));
@@ -101,6 +115,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLong updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testLongUpdateAndGet() {
         AtomicLong a = new AtomicLong(1L);
         assertEquals(18L, a.updateAndGet(Atomic8Test::addLong17));
@@ -111,6 +126,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLong getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testLongGetAndAccumulate() {
         AtomicLong a = new AtomicLong(1L);
         assertEquals(1L, a.getAndAccumulate(2L, Long::sum));
@@ -122,6 +138,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLong accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testLongAccumulateAndGet() {
         AtomicLong a = new AtomicLong(1L);
         assertEquals(7L, a.accumulateAndGet(6L, Long::sum));
@@ -133,6 +150,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicInteger getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testIntGetAndUpdate() {
         AtomicInteger a = new AtomicInteger(1);
         assertEquals(1, a.getAndUpdate(Atomic8Test::addInt17));
@@ -144,6 +162,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicInteger updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testIntUpdateAndGet() {
         AtomicInteger a = new AtomicInteger(1);
         assertEquals(18, a.updateAndGet(Atomic8Test::addInt17));
@@ -155,6 +174,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicInteger getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testIntGetAndAccumulate() {
         AtomicInteger a = new AtomicInteger(1);
         assertEquals(1, a.getAndAccumulate(2, Integer::sum));
@@ -166,6 +186,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicInteger accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testIntAccumulateAndGet() {
         AtomicInteger a = new AtomicInteger(1);
         assertEquals(7, a.accumulateAndGet(6, Integer::sum));
@@ -177,6 +198,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReference getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testReferenceGetAndUpdate() {
         AtomicReference<Integer> a = new AtomicReference<>(one);
         assertEquals((Integer) 1, a.getAndUpdate(Atomic8Test::addInteger17));
@@ -188,6 +210,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReference updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testReferenceUpdateAndGet() {
         AtomicReference<Integer> a = new AtomicReference<>(one);
         assertEquals((Integer) 18, a.updateAndGet(Atomic8Test::addInteger17));
@@ -199,6 +222,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReference getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testReferenceGetAndAccumulate() {
         AtomicReference<Integer> a = new AtomicReference<>(one);
         assertEquals((Integer) 1, a.getAndAccumulate(2, Atomic8Test::sumInteger));
@@ -210,6 +234,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReference accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testReferenceAccumulateAndGet() {
         AtomicReference<Integer> a = new AtomicReference<>(one);
         assertEquals((Integer) 7, a.accumulateAndGet(6, Atomic8Test::sumInteger));
@@ -221,6 +246,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongArray getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testLongArrayGetAndUpdate() {
         AtomicLongArray a = new AtomicLongArray(1);
         a.set(0, 1);
@@ -233,6 +259,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongArray updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testLongArrayUpdateAndGet() {
         AtomicLongArray a = new AtomicLongArray(1);
         a.set(0, 1);
@@ -245,6 +272,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongArray getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testLongArrayGetAndAccumulate() {
         AtomicLongArray a = new AtomicLongArray(1);
         a.set(0, 1);
@@ -257,6 +285,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongArray accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testLongArrayAccumulateAndGet() {
         AtomicLongArray a = new AtomicLongArray(1);
         a.set(0, 1);
@@ -269,6 +298,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerArray getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testIntArrayGetAndUpdate() {
         AtomicIntegerArray a = new AtomicIntegerArray(1);
         a.set(0, 1);
@@ -281,6 +311,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerArray updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testIntArrayUpdateAndGet() {
         AtomicIntegerArray a = new AtomicIntegerArray(1);
         a.set(0, 1);
@@ -293,6 +324,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerArray getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testIntArrayGetAndAccumulate() {
         AtomicIntegerArray a = new AtomicIntegerArray(1);
         a.set(0, 1);
@@ -305,6 +337,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerArray accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testIntArrayAccumulateAndGet() {
         AtomicIntegerArray a = new AtomicIntegerArray(1);
         a.set(0, 1);
@@ -316,6 +349,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceArray getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testReferenceArrayGetAndUpdate() {
         AtomicReferenceArray<Integer> a = new AtomicReferenceArray<>(1);
         a.set(0, one);
@@ -328,6 +362,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceArray updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testReferenceArrayUpdateAndGet() {
         AtomicReferenceArray<Integer> a = new AtomicReferenceArray<>(1);
         a.set(0, one);
@@ -339,6 +374,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceArray getAndAccumulate returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testReferenceArrayGetAndAccumulate() {
         AtomicReferenceArray<Integer> a = new AtomicReferenceArray<>(1);
         a.set(0, one);
@@ -351,6 +387,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceArray accumulateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testReferenceArrayAccumulateAndGet() {
         AtomicReferenceArray<Integer> a = new AtomicReferenceArray<>(1);
         a.set(0, one);
@@ -362,6 +399,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongFieldUpdater getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testLongFieldUpdaterGetAndUpdate() {
         AtomicLongFieldUpdater a = aLongFieldUpdater();
         a.set(this, 1);
@@ -375,6 +413,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongFieldUpdater updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testLongFieldUpdaterUpdateAndGet() {
         AtomicLongFieldUpdater a = aLongFieldUpdater();
         a.set(this, 1);
@@ -388,6 +427,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongFieldUpdater getAndAccumulate returns previous value
      * and updates with supplied function.
      */
+    @Test
     public void testLongFieldUpdaterGetAndAccumulate() {
         AtomicLongFieldUpdater a = aLongFieldUpdater();
         a.set(this, 1);
@@ -401,6 +441,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicLongFieldUpdater accumulateAndGet updates with supplied
      * function and returns result.
      */
+    @Test
     public void testLongFieldUpdaterAccumulateAndGet() {
         AtomicLongFieldUpdater a = aLongFieldUpdater();
         a.set(this, 1);
@@ -414,6 +455,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerFieldUpdater getAndUpdate returns previous value and updates
      * result of supplied function
      */
+    @Test
     public void testIntegerFieldUpdaterGetAndUpdate() {
         AtomicIntegerFieldUpdater a = anIntFieldUpdater();
         a.set(this, 1);
@@ -427,6 +469,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerFieldUpdater updateAndGet updates with supplied function and
      * returns result.
      */
+    @Test
     public void testIntegerFieldUpdaterUpdateAndGet() {
         AtomicIntegerFieldUpdater a = anIntFieldUpdater();
         a.set(this, 1);
@@ -440,6 +483,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerFieldUpdater getAndAccumulate returns previous value
      * and updates with supplied function.
      */
+    @Test
     public void testIntegerFieldUpdaterGetAndAccumulate() {
         AtomicIntegerFieldUpdater a = anIntFieldUpdater();
         a.set(this, 1);
@@ -453,6 +497,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicIntegerFieldUpdater accumulateAndGet updates with supplied
      * function and returns result.
      */
+    @Test
     public void testIntegerFieldUpdaterAccumulateAndGet() {
         AtomicIntegerFieldUpdater a = anIntFieldUpdater();
         a.set(this, 1);
@@ -466,6 +511,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceFieldUpdater getAndUpdate returns previous value
      * and updates result of supplied function
      */
+    @Test
     public void testReferenceFieldUpdaterGetAndUpdate() {
         AtomicReferenceFieldUpdater<Atomic8Test,Integer> a = anIntegerFieldUpdater();
         a.set(this, one);
@@ -479,6 +525,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceFieldUpdater updateAndGet updates with supplied
      * function and returns result.
      */
+    @Test
     public void testReferenceFieldUpdaterUpdateAndGet() {
         AtomicReferenceFieldUpdater<Atomic8Test,Integer> a = anIntegerFieldUpdater();
         a.set(this, one);
@@ -492,6 +539,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceFieldUpdater returns previous value and updates
      * with supplied function.
      */
+    @Test
     public void testReferenceFieldUpdaterGetAndAccumulate() {
         AtomicReferenceFieldUpdater<Atomic8Test,Integer> a = anIntegerFieldUpdater();
         a.set(this, one);
@@ -505,6 +553,7 @@ public class Atomic8Test extends JSR166TestCase {
      * AtomicReferenceFieldUpdater accumulateAndGet updates with
      * supplied function and returns result.
      */
+    @Test
     public void testReferenceFieldUpdaterAccumulateAndGet() {
         AtomicReferenceFieldUpdater<Atomic8Test,Integer> a = anIntegerFieldUpdater();
         a.set(this, one);
@@ -518,6 +567,7 @@ public class Atomic8Test extends JSR166TestCase {
      * All Atomic getAndUpdate methods throw NullPointerException on
      * null function argument
      */
+    @Test
     public void testGetAndUpdateNPE() {
         Runnable[] throwingActions = {
             () -> new AtomicLong().getAndUpdate(null),
@@ -536,6 +586,7 @@ public class Atomic8Test extends JSR166TestCase {
     /**
      * All Atomic updateAndGet methods throw NullPointerException on null function argument
      */
+    @Test
     public void testUpdateAndGetNPE() {
         Runnable[] throwingActions = {
             () -> new AtomicLong().updateAndGet(null),
@@ -555,6 +606,7 @@ public class Atomic8Test extends JSR166TestCase {
      * All Atomic getAndAccumulate methods throw NullPointerException
      * on null function argument
      */
+    @Test
     public void testGetAndAccumulateNPE() {
         Runnable[] throwingActions = {
             () -> new AtomicLong().getAndAccumulate(1L, null),
@@ -574,6 +626,7 @@ public class Atomic8Test extends JSR166TestCase {
      * All Atomic accumulateAndGet methods throw NullPointerException
      * on null function argument
      */
+    @Test
     public void testAccumulateAndGetNPE() {
         Runnable[] throwingActions = {
             () -> new AtomicLong().accumulateAndGet(1L, null),
@@ -594,6 +647,7 @@ public class Atomic8Test extends JSR166TestCase {
      * instances of the class passed to the newUpdater call will
      * result in a ClassCastException being thrown.
      */
+    @Test
     public void testFieldUpdaters_ClassCastException() {
         // Use raw types to allow passing wrong object type, provoking CCE
         final AtomicLongFieldUpdater longUpdater = aLongFieldUpdater();
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicBooleanTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicBooleanTest.java
index 4d666da8a6b..0ca4b703c9e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicBooleanTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicBooleanTest.java
@@ -34,22 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicBooleanTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicBooleanTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicBooleanTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicBooleanTest.class);
+    // }
 
     /**
      * constructor initializes to given value
      */
+    @Test
     public void testConstructor() {
         assertTrue(new AtomicBoolean(true).get());
         assertFalse(new AtomicBoolean(false).get());
@@ -58,6 +73,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * default constructed initializes to false
      */
+    @Test
     public void testConstructor2() {
         AtomicBoolean ai = new AtomicBoolean();
         assertFalse(ai.get());
@@ -66,6 +82,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * get returns the last value set
      */
+    @Test
     public void testGetSet() {
         AtomicBoolean ai = new AtomicBoolean(true);
         assertTrue(ai.get());
@@ -78,6 +95,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet in same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicBoolean ai = new AtomicBoolean(true);
         assertTrue(ai.get());
@@ -90,6 +108,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicBoolean ai = new AtomicBoolean(true);
         assertTrue(ai.compareAndSet(true, false));
@@ -106,6 +125,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicBoolean ai = new AtomicBoolean(true);
         Thread t = new Thread(new CheckedRunnable() {
@@ -123,6 +143,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicBoolean ai = new AtomicBoolean(true);
         do {} while (!ai.weakCompareAndSet(true, false));
@@ -136,6 +157,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicBoolean ai = new AtomicBoolean();
         boolean[] booleans = { false, true };
@@ -150,6 +172,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * a deserialized serialized atomic holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicBoolean x = new AtomicBoolean();
         AtomicBoolean y = serialClone(x);
@@ -163,6 +186,7 @@ public class AtomicBooleanTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         AtomicBoolean ai = new AtomicBoolean();
         assertEquals(Boolean.toString(false), ai.toString());
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerArrayTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerArrayTest.java
index e24d0ea3f77..ee5757f342b 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerArrayTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerArrayTest.java
@@ -34,24 +34,38 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicIntegerArray;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicIntegerArrayTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicIntegerArrayTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicIntegerArrayTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicIntegerArrayTest.class);
+    // }
 
     /**
      * constructor creates array of given size with all elements zero
      */
+    @Test
     public void testConstructor() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++)
@@ -61,6 +75,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * constructor with null array throws NPE
      */
+    @Test
     public void testConstructor2NPE() {
         try {
             int[] a = null;
@@ -72,6 +87,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * constructor with array is of same size and has all elements
      */
+    @Test
     public void testConstructor2() {
         int[] a = { 17, 3, -42, 99, -7 };
         AtomicIntegerArray aa = new AtomicIntegerArray(a);
@@ -83,6 +99,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * get and set for out of bound indices throw IndexOutOfBoundsException
      */
+    @Test
     public void testIndexing() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int index : new int[] { -1, SIZE }) {
@@ -120,6 +137,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * get returns the last value set at index
      */
+    @Test
     public void testGetSet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -135,6 +153,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet at index by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -150,6 +169,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -168,6 +188,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicIntegerArray a = new AtomicIntegerArray(1);
         a.set(0, 1);
@@ -188,6 +209,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -203,6 +225,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value at given index
      */
+    @Test
     public void testGetAndSet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -216,6 +239,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -230,6 +254,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -243,6 +268,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -260,6 +286,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -274,6 +301,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -288,6 +316,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -328,6 +357,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
      * Multiple threads using same array of counters successfully
      * update a number of times equal to total count
      */
+    @Test
     public void testCountingInMultipleThreads() throws InterruptedException {
         final AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);
         int countdown = 10000;
@@ -345,6 +375,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * a deserialized serialized array holds same values
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicIntegerArray x = new AtomicIntegerArray(SIZE);
         for (int i = 0; i < SIZE; i++)
@@ -360,6 +391,7 @@ public class AtomicIntegerArrayTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         int[] a = { 17, 3, -42, 99, -7 };
         AtomicIntegerArray aa = new AtomicIntegerArray(a);
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerFieldUpdaterTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerFieldUpdaterTest.java
index 0d6f79a94cd..b46bdf594a7 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerFieldUpdaterTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerFieldUpdaterTest.java
@@ -34,23 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     volatile int x = 0;
     protected volatile int protectedField;
     private volatile int privateField;
     int w;
     float z;
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicIntegerFieldUpdaterTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicIntegerFieldUpdaterTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicIntegerFieldUpdaterTest.class);
+    // }
 
     // for testing subclass access
     static class AtomicIntegerFieldUpdaterTestSubclass extends AtomicIntegerFieldUpdaterTest {
@@ -111,6 +125,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * Construction with non-existent field throws RuntimeException
      */
+    @Test
     public void testConstructor() {
         try {
             updaterFor("y");
@@ -123,6 +138,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction with field not of given type throws IllegalArgumentException
      */
+    @Test
     public void testConstructor2() {
         try {
             updaterFor("z");
@@ -133,6 +149,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction with non-volatile field throws IllegalArgumentException
      */
+    @Test
     public void testConstructor3() {
         try {
             updaterFor("w");
@@ -143,6 +160,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction using private field from subclass throws RuntimeException
      */
+    @Test
     public void testPrivateFieldInSubclass() {
         AtomicIntegerFieldUpdaterTestSubclass s =
             new AtomicIntegerFieldUpdaterTestSubclass();
@@ -153,6 +171,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
      * construction from unrelated class; package access is allowed,
      * private access is not
      */
+    @Test
     public void testUnrelatedClassAccess() {
         new UnrelatedClass().checkPackageAccess(this);
         new UnrelatedClass().checkPrivateAccess(this);
@@ -161,6 +180,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value set or assigned
      */
+    @Test
     public void testGetSet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -175,6 +195,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -189,6 +210,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -206,6 +228,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet succeeds in changing protected field value if
      * equal to expected else fails
      */
+    @Test
     public void testCompareAndSetProtected() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("protectedField");
@@ -223,6 +246,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet succeeds in changing protected field value if
      * equal to expected else fails
      */
+    @Test
     public void testCompareAndSetProtectedInSubclass() {
         AtomicIntegerFieldUpdaterTestSubclass s =
             new AtomicIntegerFieldUpdaterTestSubclass();
@@ -233,6 +257,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         x = 1;
         final AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
@@ -255,6 +280,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -269,6 +295,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -281,6 +308,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -294,6 +322,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -306,6 +335,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -322,6 +352,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -335,6 +366,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -348,6 +380,7 @@ public class AtomicIntegerFieldUpdaterTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;
         a = updaterFor("x");
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerTest.java
index 111cd3fee5e..b1cdc4af375 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicIntegerTest.java
@@ -34,18 +34,32 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicIntegerTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicIntegerTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicIntegerTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicIntegerTest.class);
+    // }
 
     final int[] VALUES = {
         Integer.MIN_VALUE, -1, 0, 1, 42, Integer.MAX_VALUE,
@@ -54,6 +68,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * constructor initializes to given value
      */
+    @Test
     public void testConstructor() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.get());
@@ -62,6 +77,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor2() {
         AtomicInteger ai = new AtomicInteger();
         assertEquals(0, ai.get());
@@ -70,6 +86,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * get returns the last value set
      */
+    @Test
     public void testGetSet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.get());
@@ -82,6 +99,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet in same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.get());
@@ -94,6 +112,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertTrue(ai.compareAndSet(1, 2));
@@ -109,6 +128,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicInteger ai = new AtomicInteger(1);
         Thread t = new Thread(new CheckedRunnable() {
@@ -128,6 +148,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicInteger ai = new AtomicInteger(1);
         do {} while (!ai.weakCompareAndSet(1, 2));
@@ -140,6 +161,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.getAndSet(0));
@@ -150,6 +172,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.getAndAdd(2));
@@ -161,6 +184,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.getAndDecrement());
@@ -171,6 +195,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(1, ai.getAndIncrement());
@@ -185,6 +210,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(3, ai.addAndGet(2));
@@ -196,6 +222,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(0, ai.decrementAndGet());
@@ -207,6 +234,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicInteger ai = new AtomicInteger(1);
         assertEquals(2, ai.incrementAndGet());
@@ -221,6 +249,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * a deserialized serialized atomic holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicInteger x = new AtomicInteger();
         AtomicInteger y = serialClone(x);
@@ -235,6 +264,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         AtomicInteger ai = new AtomicInteger();
         assertEquals("0", ai.toString());
@@ -247,6 +277,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         AtomicInteger ai = new AtomicInteger();
         assertEquals(0, ai.intValue());
@@ -259,6 +290,7 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         AtomicInteger ai = new AtomicInteger();
         assertEquals(0L, ai.longValue());
@@ -271,24 +303,26 @@ public class AtomicIntegerTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         AtomicInteger ai = new AtomicInteger();
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         for (int x : VALUES) {
             ai.set(x);
-            assertEquals((float)x, ai.floatValue());
+            assertEquals((float)x, ai.floatValue(), 0.0f);
         }
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         AtomicInteger ai = new AtomicInteger();
-        assertEquals(0.0d, ai.doubleValue());
+        assertEquals(0.0d, ai.doubleValue(), 0.0d);
         for (int x : VALUES) {
             ai.set(x);
-            assertEquals((double)x, ai.doubleValue());
+            assertEquals((double)x, ai.doubleValue(), 0.0d);
         }
     }
 
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicLongArrayTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicLongArrayTest.java
index c271a061ec7..73aa2f51c53 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicLongArrayTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicLongArrayTest.java
@@ -34,23 +34,38 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLongArray;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicLongArrayTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicLongArrayTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicLongArrayTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicLongArrayTest.class);
+    // }
 
     /**
      * constructor creates array of given size with all elements zero
      */
+    @Test
     public void testConstructor() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++)
@@ -60,6 +75,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * constructor with null array throws NPE
      */
+    @Test
     public void testConstructor2NPE() {
         try {
             long[] a = null;
@@ -71,6 +87,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * constructor with array is of same size and has all elements
      */
+    @Test
     public void testConstructor2() {
         long[] a = { 17L, 3L, -42L, 99L, -7L };
         AtomicLongArray aa = new AtomicLongArray(a);
@@ -82,6 +99,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * get and set for out of bound indices throw IndexOutOfBoundsException
      */
+    @Test
     public void testIndexing() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int index : new int[] { -1, SIZE }) {
@@ -119,6 +137,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * get returns the last value set at index
      */
+    @Test
     public void testGetSet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -134,6 +153,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet at index by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -149,6 +169,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -167,6 +188,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws InterruptedException {
         final AtomicLongArray a = new AtomicLongArray(1);
         a.set(0, 1);
@@ -187,6 +209,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -202,6 +225,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value at given index
      */
+    @Test
     public void testGetAndSet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -215,6 +239,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -229,6 +254,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -242,6 +268,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -259,6 +286,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -273,6 +301,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -287,6 +316,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicLongArray aa = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -327,6 +357,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
      * Multiple threads using same array of counters successfully
      * update a number of times equal to total count
      */
+    @Test
     public void testCountingInMultipleThreads() throws InterruptedException {
         final AtomicLongArray aa = new AtomicLongArray(SIZE);
         long countdown = 10000;
@@ -344,6 +375,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * a deserialized serialized array holds same values
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicLongArray x = new AtomicLongArray(SIZE);
         for (int i = 0; i < SIZE; i++)
@@ -359,6 +391,7 @@ public class AtomicLongArrayTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         long[] a = { 17, 3, -42, 99, -7 };
         AtomicLongArray aa = new AtomicLongArray(a);
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicLongFieldUpdaterTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicLongFieldUpdaterTest.java
index 70f0bb98aa5..b8d3c2d237f 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicLongFieldUpdaterTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicLongFieldUpdaterTest.java
@@ -34,23 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     volatile long x = 0;
     protected volatile long protectedField;
     private volatile long privateField;
     long w;
     float z;
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicLongFieldUpdaterTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicLongFieldUpdaterTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicLongFieldUpdaterTest.class);
+    // }
 
     // for testing subclass access
     static class AtomicLongFieldUpdaterTestSubclass extends AtomicLongFieldUpdaterTest {
@@ -111,6 +125,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * Construction with non-existent field throws RuntimeException
      */
+    @Test
     public void testConstructor() {
         try {
             updaterFor("y");
@@ -123,6 +138,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction with field not of given type throws IllegalArgumentException
      */
+    @Test
     public void testConstructor2() {
         try {
             updaterFor("z");
@@ -133,6 +149,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction with non-volatile field throws IllegalArgumentException
      */
+    @Test
     public void testConstructor3() {
         try {
             updaterFor("w");
@@ -143,6 +160,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction using private field from subclass throws RuntimeException
      */
+    @Test
     public void testPrivateFieldInSubclass() {
         AtomicLongFieldUpdaterTestSubclass s =
             new AtomicLongFieldUpdaterTestSubclass();
@@ -153,6 +171,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
      * construction from unrelated class; package access is allowed,
      * private access is not
      */
+    @Test
     public void testUnrelatedClassAccess() {
         new UnrelatedClass().checkPackageAccess(this);
         new UnrelatedClass().checkPrivateAccess(this);
@@ -161,6 +180,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value set or assigned
      */
+    @Test
     public void testGetSet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -175,6 +195,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -189,6 +210,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -206,6 +228,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet succeeds in changing protected field value if
      * equal to expected else fails
      */
+    @Test
     public void testCompareAndSetProtected() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("protectedField");
@@ -223,6 +246,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet succeeds in changing protected field value if
      * equal to expected else fails
      */
+    @Test
     public void testCompareAndSetProtectedInSubclass() {
         AtomicLongFieldUpdaterTestSubclass s =
             new AtomicLongFieldUpdaterTestSubclass();
@@ -233,6 +257,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         x = 1;
         final AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
@@ -255,6 +280,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -269,6 +295,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -281,6 +308,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -294,6 +322,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -306,6 +335,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -322,6 +352,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -335,6 +366,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
@@ -348,6 +380,7 @@ public class AtomicLongFieldUpdaterTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;
         a = updaterFor("x");
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicLongTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicLongTest.java
index 5b657570a80..43bafba72ec 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicLongTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicLongTest.java
@@ -34,18 +34,32 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicLong;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicLongTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicLongTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicLongTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicLongTest.class);
+    // }
 
     final long[] VALUES = {
         Long.MIN_VALUE,
@@ -56,6 +70,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * constructor initializes to given value
      */
+    @Test
     public void testConstructor() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.get());
@@ -64,6 +79,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor2() {
         AtomicLong ai = new AtomicLong();
         assertEquals(0, ai.get());
@@ -72,6 +88,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * get returns the last value set
      */
+    @Test
     public void testGetSet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.get());
@@ -84,6 +101,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet in same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.get());
@@ -96,6 +114,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicLong ai = new AtomicLong(1);
         assertTrue(ai.compareAndSet(1, 2));
@@ -111,6 +130,7 @@ public class AtomicLongTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicLong ai = new AtomicLong(1);
         Thread t = new Thread(new CheckedRunnable() {
@@ -130,6 +150,7 @@ public class AtomicLongTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicLong ai = new AtomicLong(1);
         do {} while (!ai.weakCompareAndSet(1, 2));
@@ -142,6 +163,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.getAndSet(0));
@@ -152,6 +174,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * getAndAdd returns previous value and adds given value
      */
+    @Test
     public void testGetAndAdd() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.getAndAdd(2));
@@ -163,6 +186,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * getAndDecrement returns previous value and decrements
      */
+    @Test
     public void testGetAndDecrement() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.getAndDecrement());
@@ -173,6 +197,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * getAndIncrement returns previous value and increments
      */
+    @Test
     public void testGetAndIncrement() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(1, ai.getAndIncrement());
@@ -187,6 +212,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * addAndGet adds given value to current, and returns current value
      */
+    @Test
     public void testAddAndGet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(3, ai.addAndGet(2));
@@ -198,6 +224,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * decrementAndGet decrements and returns current value
      */
+    @Test
     public void testDecrementAndGet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(0, ai.decrementAndGet());
@@ -209,6 +236,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndGet() {
         AtomicLong ai = new AtomicLong(1);
         assertEquals(2, ai.incrementAndGet());
@@ -223,6 +251,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * a deserialized serialized atomic holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicLong x = new AtomicLong();
         AtomicLong y = serialClone(x);
@@ -238,6 +267,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         AtomicLong ai = new AtomicLong();
         assertEquals("0", ai.toString());
@@ -250,6 +280,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         AtomicLong ai = new AtomicLong();
         assertEquals(0, ai.intValue());
@@ -262,6 +293,7 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         AtomicLong ai = new AtomicLong();
         assertEquals(0L, ai.longValue());
@@ -274,24 +306,26 @@ public class AtomicLongTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         AtomicLong ai = new AtomicLong();
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         for (long x : VALUES) {
             ai.set(x);
-            assertEquals((float)x, ai.floatValue());
+            assertEquals((float)x, ai.floatValue(), 0.0f);
         }
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         AtomicLong ai = new AtomicLong();
-        assertEquals(0.0d, ai.doubleValue());
+        assertEquals(0.0d, ai.doubleValue(), 0.0d);
         for (long x : VALUES) {
             ai.set(x);
-            assertEquals((double)x, ai.doubleValue());
+            assertEquals((double)x, ai.doubleValue(), 0.0d);
         }
     }
 
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicMarkableReferenceTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicMarkableReferenceTest.java
index 8fc0369f640..5ce0fbb725d 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicMarkableReferenceTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicMarkableReferenceTest.java
@@ -34,22 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicMarkableReference;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicMarkableReferenceTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicMarkableReferenceTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicMarkableReferenceTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicMarkableReferenceTest.class);
+    // }
 
     /**
      * constructor initializes to given reference and mark
      */
+    @Test
     public void testConstructor() {
         AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
         assertSame(one, ai.getReference());
@@ -62,6 +77,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
     /**
      * get returns the last values of reference and mark set
      */
+    @Test
     public void testGetSet() {
         boolean[] mark = new boolean[1];
         AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
@@ -84,6 +100,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
     /**
      * attemptMark succeeds in single thread
      */
+    @Test
     public void testAttemptMark() {
         boolean[] mark = new boolean[1];
         AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
@@ -98,6 +115,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
      * compareAndSet succeeds in changing values if equal to expected reference
      * and mark else fails
      */
+    @Test
     public void testCompareAndSet() {
         boolean[] mark = new boolean[1];
         AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
@@ -122,6 +140,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for reference value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
         Thread t = new Thread(new CheckedRunnable() {
@@ -142,6 +161,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for mark value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads2() throws Exception {
         final AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
         Thread t = new Thread(new CheckedRunnable() {
@@ -162,6 +182,7 @@ public class AtomicMarkableReferenceTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing values when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         boolean[] mark = new boolean[1];
         AtomicMarkableReference ai = new AtomicMarkableReference(one, false);
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceArrayTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceArrayTest.java
index 6e078f837fc..eb9e82cb659 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceArrayTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceArrayTest.java
@@ -34,23 +34,38 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicReferenceArrayTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicReferenceArrayTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicReferenceArrayTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicReferenceArrayTest.class);
+    // }
 
     /**
      * constructor creates array of given size with all elements null
      */
+    @Test
     public void testConstructor() {
         AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<>(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -61,6 +76,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * constructor with null array throws NPE
      */
+    @Test
     public void testConstructor2NPE() {
         try {
             Integer[] a = null;
@@ -72,6 +88,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * constructor with array is of same size and has all elements
      */
+    @Test
     public void testConstructor2() {
         Integer[] a = { two, one, three, four, seven };
         AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<>(a);
@@ -83,6 +100,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * Initialize AtomicReferenceArray<Class> with SubClass[]
      */
+    @Test
     public void testConstructorSubClassArray() {
         Integer[] a = { two, one, three, four, seven };
         AtomicReferenceArray<Number> aa = new AtomicReferenceArray<Number>(a);
@@ -98,6 +116,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * get and set for out of bound indices throw IndexOutOfBoundsException
      */
+    @Test
     public void testIndexing() {
         AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<>(SIZE);
         for (int index : new int[] { -1, SIZE }) {
@@ -127,6 +146,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * get returns the last value set at index
      */
+    @Test
     public void testGetSet() {
         AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -142,6 +162,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet at index by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -157,6 +178,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -175,6 +197,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws InterruptedException {
         final AtomicReferenceArray a = new AtomicReferenceArray(1);
         a.set(0, one);
@@ -195,6 +218,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -210,6 +234,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value at given index
      */
+    @Test
     public void testGetAndSet() {
         AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -223,6 +248,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * a deserialized serialized array holds same values
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicReferenceArray x = new AtomicReferenceArray(SIZE);
         for (int i = 0; i < SIZE; i++) {
@@ -239,6 +265,7 @@ public class AtomicReferenceArrayTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         Integer[] a = { two, one, three, four, seven };
         AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<>(a);
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceFieldUpdaterTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceFieldUpdaterTest.java
index 2517842bd98..e8e76628ded 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceFieldUpdaterTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceFieldUpdaterTest.java
@@ -34,11 +34,23 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     volatile Integer x = null;
     protected volatile Integer protectedField;
@@ -46,13 +58,15 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     Object z;
     Integer w;
     volatile int i;
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicReferenceFieldUpdaterTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicReferenceFieldUpdaterTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicReferenceFieldUpdaterTest.class);
+    // }
+
 
     // for testing subclass access
     static class AtomicReferenceFieldUpdaterTestSubclass extends AtomicReferenceFieldUpdaterTest {
@@ -113,6 +127,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * Construction with non-existent field throws RuntimeException
      */
+    @Test
     public void testConstructor() {
         try {
             updaterFor("y");
@@ -125,6 +140,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction with field not of given type throws ClassCastException
      */
+    @Test
     public void testConstructor2() {
         try {
             updaterFor("z");
@@ -135,6 +151,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * Constructor with non-volatile field throws IllegalArgumentException
      */
+    @Test
     public void testConstructor3() {
         try {
             updaterFor("w");
@@ -145,6 +162,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * Constructor with non-reference field throws ClassCastException
      */
+    @Test
     public void testConstructor4() {
         try {
             updaterFor("i");
@@ -155,6 +173,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * construction using private field from subclass throws RuntimeException
      */
+    @Test
     public void testPrivateFieldInSubclass() {
         AtomicReferenceFieldUpdaterTestSubclass s =
             new AtomicReferenceFieldUpdaterTestSubclass();
@@ -165,6 +184,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
      * construction from unrelated class; package access is allowed,
      * private access is not
      */
+    @Test
     public void testUnrelatedClassAccess() {
         new UnrelatedClass().checkPackageAccess(this);
         new UnrelatedClass().checkPrivateAccess(this);
@@ -173,6 +193,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value set or assigned
      */
+    @Test
     public void testGetSet() {
         AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
         a = updaterFor("x");
@@ -187,6 +208,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet by same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
         a = updaterFor("x");
@@ -201,6 +223,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
         a = updaterFor("x");
@@ -218,6 +241,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         x = one;
         final AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
@@ -240,6 +264,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
         a = updaterFor("x");
@@ -254,6 +279,7 @@ public class AtomicReferenceFieldUpdaterTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;
         a = updaterFor("x");
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceTest.java
index 1c5e3032743..c470e61ff69 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicReferenceTest.java
@@ -34,22 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicReference;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicReferenceTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicReferenceTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicReferenceTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicReferenceTest.class);
+    // }
 
     /**
      * constructor initializes to given value
      */
+    @Test
     public void testConstructor() {
         AtomicReference ai = new AtomicReference(one);
         assertSame(one, ai.get());
@@ -58,6 +73,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * default constructed initializes to null
      */
+    @Test
     public void testConstructor2() {
         AtomicReference ai = new AtomicReference();
         assertNull(ai.get());
@@ -66,6 +82,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * get returns the last value set
      */
+    @Test
     public void testGetSet() {
         AtomicReference ai = new AtomicReference(one);
         assertSame(one, ai.get());
@@ -78,6 +95,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * get returns the last value lazySet in same thread
      */
+    @Test
     public void testGetLazySet() {
         AtomicReference ai = new AtomicReference(one);
         assertSame(one, ai.get());
@@ -90,6 +108,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * compareAndSet succeeds in changing value if equal to expected else fails
      */
+    @Test
     public void testCompareAndSet() {
         AtomicReference ai = new AtomicReference(one);
         assertTrue(ai.compareAndSet(one, two));
@@ -105,6 +124,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicReference ai = new AtomicReference(one);
         Thread t = new Thread(new CheckedRunnable() {
@@ -124,6 +144,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing value when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         AtomicReference ai = new AtomicReference(one);
         do {} while (!ai.weakCompareAndSet(one, two));
@@ -136,6 +157,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * getAndSet returns previous value and sets to given value
      */
+    @Test
     public void testGetAndSet() {
         AtomicReference ai = new AtomicReference(one);
         assertSame(one, ai.getAndSet(zero));
@@ -146,6 +168,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * a deserialized serialized atomic holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         AtomicReference x = new AtomicReference();
         AtomicReference y = serialClone(x);
@@ -161,6 +184,7 @@ public class AtomicReferenceTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         AtomicReference<Integer> ai = new AtomicReference<>(one);
         assertEquals(one.toString(), ai.toString());
diff --git a/ojluni/src/test/java/util/concurrent/tck/AtomicStampedReferenceTest.java b/ojluni/src/test/java/util/concurrent/tck/AtomicStampedReferenceTest.java
index 244bfed7081..08fbd1fa10e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/AtomicStampedReferenceTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/AtomicStampedReferenceTest.java
@@ -34,22 +34,37 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.atomic.AtomicStampedReference;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class AtomicStampedReferenceTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(AtomicStampedReferenceTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.AtomicStampedReferenceTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(AtomicStampedReferenceTest.class);
+    // }
 
     /**
      * constructor initializes to given reference and stamp
      */
+    @Test
     public void testConstructor() {
         AtomicStampedReference ai = new AtomicStampedReference(one, 0);
         assertSame(one, ai.getReference());
@@ -62,6 +77,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
     /**
      * get returns the last values of reference and stamp set
      */
+    @Test
     public void testGetSet() {
         int[] mark = new int[1];
         AtomicStampedReference ai = new AtomicStampedReference(one, 0);
@@ -84,6 +100,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
     /**
      * attemptStamp succeeds in single thread
      */
+    @Test
     public void testAttemptStamp() {
         int[] mark = new int[1];
         AtomicStampedReference ai = new AtomicStampedReference(one, 0);
@@ -98,6 +115,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
      * compareAndSet succeeds in changing values if equal to expected reference
      * and stamp else fails
      */
+    @Test
     public void testCompareAndSet() {
         int[] mark = new int[1];
         AtomicStampedReference ai = new AtomicStampedReference(one, 0);
@@ -122,6 +140,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for reference value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads() throws Exception {
         final AtomicStampedReference ai = new AtomicStampedReference(one, 0);
         Thread t = new Thread(new CheckedRunnable() {
@@ -142,6 +161,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
      * compareAndSet in one thread enables another waiting for stamp value
      * to succeed
      */
+    @Test
     public void testCompareAndSetInMultipleThreads2() throws Exception {
         final AtomicStampedReference ai = new AtomicStampedReference(one, 0);
         Thread t = new Thread(new CheckedRunnable() {
@@ -162,6 +182,7 @@ public class AtomicStampedReferenceTest extends JSR166TestCase {
      * repeated weakCompareAndSet succeeds in changing values when equal
      * to expected
      */
+    @Test
     public void testWeakCompareAndSet() {
         int[] mark = new int[1];
         AtomicStampedReference ai = new AtomicStampedReference(one, 0);
diff --git a/ojluni/src/test/java/util/concurrent/tck/BlockingQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/BlockingQueueTest.java
index 5d70bf441ed..ae99bbfd6ef 100644
--- a/ojluni/src/test/java/util/concurrent/tck/BlockingQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/BlockingQueueTest.java
@@ -36,6 +36,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -44,8 +52,7 @@ import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
 
 /**
  * Contains "contract" tests applicable to all BlockingQueue implementations.
@@ -62,11 +69,12 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
      */
 
     /** Like suite(), but non-static */
-    public Test testSuite() {
-        // TODO: filter the returned tests using the configuration
-        // information provided by the subclass via protected methods.
-        return new TestSuite(this.getClass());
-    }
+    // Android-removed: No usage of suite().
+    // public Test testSuite() {
+    //     // TODO: filter the returned tests using the configuration
+    //     // information provided by the subclass via protected methods.
+    //     return new TestSuite(this.getClass());
+    // }
 
     //----------------------------------------------------------------
     // Configuration methods
@@ -90,6 +98,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * offer(null) throws NullPointerException
      */
+    @Test
     public void testOfferNull() {
         final Queue q = emptyCollection();
         try {
@@ -101,6 +110,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * add(null) throws NullPointerException
      */
+    @Test
     public void testAddNull() {
         final Collection q = emptyCollection();
         try {
@@ -112,6 +122,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * timed offer(null) throws NullPointerException
      */
+    @Test
     public void testTimedOfferNull() throws InterruptedException {
         final BlockingQueue q = emptyCollection();
         long startTime = System.nanoTime();
@@ -125,6 +136,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * put(null) throws NullPointerException
      */
+    @Test
     public void testPutNull() throws InterruptedException {
         final BlockingQueue q = emptyCollection();
         try {
@@ -136,6 +148,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * put(null) throws NullPointerException
      */
+    @Test
     public void testAddAllNull() throws InterruptedException {
         final Collection q = emptyCollection();
         try {
@@ -147,6 +160,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NullPointerException
      */
+    @Test
     public void testAddAllNullElements() {
         final Collection q = emptyCollection();
         final Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
@@ -159,6 +173,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(null) throws NullPointerException
      */
+    @Test
     public void testToArray_NullArray() {
         final Collection q = emptyCollection();
         try {
@@ -170,6 +185,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(null) throws NullPointerException
      */
+    @Test
     public void testDrainToNull() {
         final BlockingQueue q = emptyCollection();
         try {
@@ -181,6 +197,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(this) throws IllegalArgumentException
      */
+    @Test
     public void testDrainToSelf() {
         final BlockingQueue q = emptyCollection();
         try {
@@ -192,6 +209,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(null, n) throws NullPointerException
      */
+    @Test
     public void testDrainToNullN() {
         final BlockingQueue q = emptyCollection();
         try {
@@ -203,6 +221,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(this, n) throws IllegalArgumentException
      */
+    @Test
     public void testDrainToSelfN() {
         final BlockingQueue q = emptyCollection();
         try {
@@ -214,6 +233,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) returns 0 and does nothing when n <= 0
      */
+    @Test
     public void testDrainToNonPositiveMaxElements() {
         final BlockingQueue q = emptyCollection();
         final int[] ns = { 0, -1, -42, Integer.MIN_VALUE };
@@ -236,6 +256,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
      * timed poll before a delayed offer times out; after offer succeeds;
      * on interruption throws
      */
+    @Test
     public void testTimedPollWithOffer() throws InterruptedException {
         final BlockingQueue q = emptyCollection();
         final CheckedBarrier barrier = new CheckedBarrier(2);
@@ -281,6 +302,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * take() blocks interruptibly when empty
      */
+    @Test
     public void testTakeFromEmptyBlocksInterruptibly() {
         final BlockingQueue q = emptyCollection();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -304,6 +326,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
      * take() throws InterruptedException immediately if interrupted
      * before waiting
      */
+    @Test
     public void testTakeFromEmptyAfterInterrupt() {
         final BlockingQueue q = emptyCollection();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -322,6 +345,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll() blocks interruptibly when empty
      */
+    @Test
     public void testTimedPollFromEmptyBlocksInterruptibly() {
         final BlockingQueue q = emptyCollection();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -345,6 +369,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
      * timed poll() throws InterruptedException immediately if
      * interrupted before waiting
      */
+    @Test
     public void testTimedPollFromEmptyAfterInterrupt() {
         final BlockingQueue q = emptyCollection();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -364,6 +389,7 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
      * remove(x) removes x and returns true if present
      * TODO: move to superclass CollectionTest.java
      */
+    @Test
     public void testRemoveElement() {
         final BlockingQueue q = emptyCollection();
         final int size = Math.min(q.remainingCapacity(), SIZE);
diff --git a/ojluni/src/test/java/util/concurrent/tck/Collection8Test.java b/ojluni/src/test/java/util/concurrent/tck/Collection8Test.java
index cab640a7af6..ec4bd457055 100644
--- a/ojluni/src/test/java/util/concurrent/tck/Collection8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/Collection8Test.java
@@ -35,6 +35,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -70,14 +78,14 @@ import junit.framework.Test;
  * Contains tests applicable to all jdk8+ Collection implementations.
  * An extension of CollectionTest.
  */
-// Android-changed: Mark this abstract to prevent scanned by the JUnit directly. http://b/181312360
+// Android-changed: Mark this class as abstract to prevent it being scanned and run by the JUnit
+// directly. http://b/181312360
 // public class Collection8Test extends JSR166TestCase {
 public abstract class Collection8Test extends JSR166TestCase {
     final CollectionImplementation impl;
 
     /** Tests are parameterized by a Collection implementation. */
     Collection8Test(CollectionImplementation impl, String methodName) {
-        super(methodName);
         this.impl = impl;
     }
 
@@ -93,9 +101,10 @@ public abstract class Collection8Test extends JSR166TestCase {
     public static Test testSuite(CollectionImplementation impl) {
         // Android-changed: Prevent scanned by the JUnit directly. http://b/181312360
         // return parameterizedTestSuite(Collection8Test.class,
-        return parameterizedTestSuite(AndroidCollection8Test.class,
-                                      CollectionImplementation.class,
-                                      impl);
+        // return parameterizedTestSuite(AndroidCollection8Test.class,
+        //                               CollectionImplementation.class,
+        //                               impl);
+        return null;
     }
 
     Object bomb() {
diff --git a/ojluni/src/test/java/util/concurrent/tck/CollectionTest.java b/ojluni/src/test/java/util/concurrent/tck/CollectionTest.java
deleted file mode 100644
index 8ec9b01afa5..00000000000
--- a/ojluni/src/test/java/util/concurrent/tck/CollectionTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file:
- *
- * Written by Doug Lea and Martin Buchholz with assistance from
- * members of JCP JSR-166 Expert Group and released to the public
- * domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package test.java.util.concurrent.tck;
-import junit.framework.Test;
-
-/**
- * Contains tests applicable to all Collection implementations.
- */
-public class CollectionTest extends JSR166TestCase {
-    final CollectionImplementation impl;
-
-    /** Tests are parameterized by a Collection implementation. */
-    CollectionTest(CollectionImplementation impl, String methodName) {
-        super(methodName);
-        this.impl = impl;
-    }
-
-    public static Test testSuite(CollectionImplementation impl) {
-        // Android-changed: Ignore CollectionTest. http://b/285113029
-        // This method apparently creates a new test suite without a test case,
-        // e.g. testCollectionDebugFail() is commented out.
-        /*
-        return newTestSuite
-            (parameterizedTestSuite(CollectionTest.class,
-                                    CollectionImplementation.class,
-                                    impl),
-             jdk8ParameterizedTestSuite(CollectionTest.class,
-                                        CollectionImplementation.class,
-                                        impl));
-
-         */
-        return null;
-    }
-
-//     public void testCollectionDebugFail() {
-//         fail(impl.klazz().getSimpleName());
-//     }
-}
diff --git a/ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java b/ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java
index 63c5d3cb9f1..dc5dae0bf5d 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java
@@ -33,6 +33,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -70,18 +79,21 @@ import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CompletableFutureTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(CompletableFutureTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CompletableFutureTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(CompletableFutureTest.class);
+    // }
 
     static class CFException extends RuntimeException {}
 
@@ -237,6 +249,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * A newly constructed CompletableFuture is incomplete, as indicated
      * by methods isDone, isCancelled, and getNow
      */
+    @Test
     public void testConstructor() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         checkIncomplete(f);
@@ -246,6 +259,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * complete completes normally, as indicated by methods isDone,
      * isCancelled, join, get, and getNow
      */
+    @Test
     public void testComplete() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -260,6 +274,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * completeExceptionally completes exceptionally, as indicated by
      * methods isDone, isCancelled, join, get, and getNow
      */
+    @Test
     public void testCompleteExceptionally() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CFException ex = new CFException();
@@ -272,6 +287,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * cancel completes exceptionally and reports cancelled, as indicated by
      * methods isDone, isCancelled, join, get, and getNow
      */
+    @Test
     public void testCancel() {
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
     {
@@ -286,6 +302,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * obtrudeValue forces completion with given value
      */
+    @Test
     public void testObtrudeValue() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         checkIncomplete(f);
@@ -309,6 +326,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * obtrudeException forces completion with given exception
      */
+    @Test
     public void testObtrudeException() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -343,6 +361,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * getNumberOfDependents returns number of dependent tasks
      */
+    @Test
     public void testGetNumberOfDependents() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -366,23 +385,27 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * toString indicates current completion state
      */
+    @Test
     public void testToString_incomplete() {
         CompletableFuture<String> f = new CompletableFuture<>();
         assertTrue(f.toString().matches(".*\\[.*Not completed.*\\]"));
     }
 
+    @Test
     public void testToString_normal() {
         CompletableFuture<String> f = new CompletableFuture<>();
         assertTrue(f.complete("foo"));
         assertTrue(f.toString().matches(".*\\[.*Completed normally.*\\]"));
     }
 
+    @Test
     public void testToString_exception() {
         CompletableFuture<String> f = new CompletableFuture<>();
         assertTrue(f.completeExceptionally(new IndexOutOfBoundsException()));
         assertTrue(f.toString().matches(".*\\[.*Completed exceptionally.*\\]"));
     }
 
+    @Test
     public void testToString_cancelled() {
         for (boolean mayInterruptIfRunning : new boolean[] { true, false }) {
             CompletableFuture<String> f = new CompletableFuture<>();
@@ -394,6 +417,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completedFuture returns a completed CompletableFuture with given value
      */
+    @Test
     public void testCompletedFuture() {
         CompletableFuture<String> f = CompletableFuture.completedFuture("test");
         checkCompletedNormally(f, "test");
@@ -939,6 +963,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * exceptionally action is not invoked when source completes
      * normally, and source result is propagated
      */
+    @Test
     public void testExceptionally_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -963,6 +988,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * exceptionally action completes with function value on source
      * exception
      */
+    @Test
     public void testExceptionally_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -989,6 +1015,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * If an "exceptionally action" throws an exception, it completes
      * exceptionally with that exception
      */
+    @Test
     public void testExceptionally_exceptionalCompletionActionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1016,6 +1043,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * whenComplete action executes on normal completion, propagating
      * source result.
      */
+    @Test
     public void testWhenComplete_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1043,6 +1071,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * whenComplete action executes on exceptional completion, propagating
      * source result.
      */
+    @Test
     public void testWhenComplete_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1070,6 +1099,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * whenComplete action executes on cancelled source, propagating
      * CancellationException.
      */
+    @Test
     public void testWhenComplete_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1097,6 +1127,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * If a whenComplete action throws an exception when triggered by
      * a normal completion, it completes exceptionally
      */
+    @Test
     public void testWhenComplete_sourceCompletedNormallyActionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (ExecutionMode m : ExecutionMode.values())
@@ -1127,6 +1158,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * a source completion that also throws an exception, the source
      * exception takes precedence (unlike handle)
      */
+    @Test
     public void testWhenComplete_sourceFailedActionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (ExecutionMode m : ExecutionMode.values())
@@ -1161,6 +1193,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * handle action completes normally with function value on normal
      * completion of source
      */
+    @Test
     public void testHandle_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1189,6 +1222,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * handle action completes normally with function value on
      * exceptional completion of source
      */
+    @Test
     public void testHandle_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1218,6 +1252,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * handle action completes normally with function value on
      * cancelled source
      */
+    @Test
     public void testHandle_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1247,6 +1282,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * If a "handle action" throws an exception when triggered by
      * a normal completion, it completes exceptionally
      */
+    @Test
     public void testHandle_sourceCompletedNormallyActionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -1277,6 +1313,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * a source completion that also throws an exception, the action
      * exception takes precedence (unlike whenComplete)
      */
+    @Test
     public void testHandle_sourceFailedActionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (ExecutionMode m : ExecutionMode.values())
@@ -1306,6 +1343,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * runAsync completes after running Runnable
      */
+    @Test
     public void testRunAsync_normalCompletion() {
         ExecutionMode[] executionModes = {
             ExecutionMode.ASYNC,
@@ -1323,6 +1361,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * failing runAsync completes exceptionally after running Runnable
      */
+    @Test
     public void testRunAsync_exceptionalCompletion() {
         ExecutionMode[] executionModes = {
             ExecutionMode.ASYNC,
@@ -1337,6 +1376,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     }}
 
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testRunAsync_rejectingExecutor() {
         CountingRejectingExecutor e = new CountingRejectingExecutor();
         try {
@@ -1352,6 +1392,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * supplyAsync completes with result of supplier
      */
+    @Test
     public void testSupplyAsync_normalCompletion() {
         ExecutionMode[] executionModes = {
             ExecutionMode.ASYNC,
@@ -1370,6 +1411,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * Failing supplyAsync completes exceptionally
      */
+    @Test
     public void testSupplyAsync_exceptionalCompletion() {
         ExecutionMode[] executionModes = {
             ExecutionMode.ASYNC,
@@ -1384,6 +1426,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     }}
 
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testSupplyAsync_rejectingExecutor() {
         CountingRejectingExecutor e = new CountingRejectingExecutor();
         try {
@@ -1401,6 +1444,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenRun result completes normally after normal completion of source
      */
+    @Test
     public void testThenRun_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1434,6 +1478,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenRun result completes exceptionally after exceptional
      * completion of source
      */
+    @Test
     public void testThenRun_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
     {
@@ -1466,6 +1511,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenRun result completes exceptionally if source cancelled
      */
+    @Test
     public void testThenRun_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1498,6 +1544,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenRun result completes exceptionally if action does
      */
+    @Test
     public void testThenRun_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1526,6 +1573,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenApply result completes normally after normal completion of source
      */
+    @Test
     public void testThenApply_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1554,6 +1602,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenApply result completes exceptionally after exceptional
      * completion of source
      */
+    @Test
     public void testThenApply_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
     {
@@ -1579,6 +1628,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenApply result completes exceptionally if source cancelled
      */
+    @Test
     public void testThenApply_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1604,6 +1654,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenApply result completes exceptionally if action does
      */
+    @Test
     public void testThenApply_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1628,6 +1679,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenAccept result completes normally after normal completion of source
      */
+    @Test
     public void testThenAccept_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1656,6 +1708,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenAccept result completes exceptionally after exceptional
      * completion of source
      */
+    @Test
     public void testThenAccept_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
     {
@@ -1681,6 +1734,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenAccept result completes exceptionally if source cancelled
      */
+    @Test
     public void testThenAccept_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1706,6 +1760,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenAccept result completes exceptionally if action does
      */
+    @Test
     public void testThenAccept_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -1731,6 +1786,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenCombine result completes normally after normal completion
      * of sources
      */
+    @Test
     public void testThenCombine_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -1776,6 +1832,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenCombine result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testThenCombine_exceptionalCompletion() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -1819,6 +1876,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCombine result completes exceptionally if either source cancelled
      */
+    @Test
     public void testThenCombine_sourceCancelled() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -1862,6 +1920,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCombine result completes exceptionally if action does
      */
+    @Test
     public void testThenCombine_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -1899,6 +1958,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenAcceptBoth result completes normally after normal
      * completion of sources
      */
+    @Test
     public void testThenAcceptBoth_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -1940,6 +2000,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenAcceptBoth result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testThenAcceptBoth_exceptionalCompletion() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -1983,6 +2044,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenAcceptBoth result completes exceptionally if either source cancelled
      */
+    @Test
     public void testThenAcceptBoth_sourceCancelled() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -2026,6 +2088,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenAcceptBoth result completes exceptionally if action does
      */
+    @Test
     public void testThenAcceptBoth_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2063,6 +2126,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * runAfterBoth result completes normally after normal
      * completion of sources
      */
+    @Test
     public void testRunAfterBoth_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2104,6 +2168,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * runAfterBoth result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testRunAfterBoth_exceptionalCompletion() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2147,6 +2212,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * runAfterBoth result completes exceptionally if either source cancelled
      */
+    @Test
     public void testRunAfterBoth_sourceCancelled() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -2190,6 +2256,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * runAfterBoth result completes exceptionally if action does
      */
+    @Test
     public void testRunAfterBoth_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2227,6 +2294,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * applyToEither result completes normally after normal completion
      * of either source
      */
+    @Test
     public void testApplyToEither_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2275,6 +2343,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * applyToEither result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testApplyToEither_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2328,6 +2397,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         for (int i = 0; i < 4; i++) rs[i].assertNotInvoked();
     }}
 
+    @Test
     public void testApplyToEither_exceptionalCompletion2() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2383,6 +2453,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * applyToEither result completes exceptionally if either source cancelled
      */
+    @Test
     public void testApplyToEither_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -2435,6 +2506,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         for (int i = 0; i < 4; i++) rs[i].assertNotInvoked();
     }}
 
+    @Test
     public void testApplyToEither_sourceCancelled2() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -2490,6 +2562,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * applyToEither result completes exceptionally if action does
      */
+    @Test
     public void testApplyToEither_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2532,6 +2605,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * acceptEither result completes normally after normal completion
      * of either source
      */
+    @Test
     public void testAcceptEither_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2584,6 +2658,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * acceptEither result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testAcceptEither_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2638,6 +2713,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         for (int i = 0; i < 4; i++) rs[i].assertNotInvoked();
     }}
 
+    @Test
     public void testAcceptEither_exceptionalCompletion2() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2693,6 +2769,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * acceptEither result completes exceptionally if either source cancelled
      */
+    @Test
     public void testAcceptEither_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -2749,6 +2826,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * acceptEither result completes exceptionally if action does
      */
+    @Test
     public void testAcceptEither_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2791,6 +2869,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * runAfterEither result completes normally after normal completion
      * of either source
      */
+    @Test
     public void testRunAfterEither_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2844,6 +2923,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * runAfterEither result completes exceptionally after exceptional
      * completion of either source
      */
+    @Test
     public void testRunAfterEither_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -2898,6 +2978,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         for (int i = 0; i < 4; i++) rs[i].assertNotInvoked();
     }}
 
+    @Test
     public void testRunAfterEither_exceptionalCompletion2() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean fFirst : new boolean[] { true, false })
@@ -2953,6 +3034,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * runAfterEither result completes exceptionally if either source cancelled
      */
+    @Test
     public void testRunAfterEither_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean mayInterruptIfRunning : new boolean[] { true, false })
@@ -3009,6 +3091,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * runAfterEither result completes exceptionally if action does
      */
+    @Test
     public void testRunAfterEither_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (Item v1 : new Item[] { itemOne, null })
@@ -3043,6 +3126,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCompose result completes normally after normal completion of source
      */
+    @Test
     public void testThenCompose_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3063,6 +3147,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * thenCompose result completes exceptionally after exceptional
      * completion of source
      */
+    @Test
     public void testThenCompose_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3082,6 +3167,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCompose result completes exceptionally if action does
      */
+    @Test
     public void testThenCompose_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3101,6 +3187,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCompose result completes exceptionally if source cancelled
      */
+    @Test
     public void testThenCompose_sourceCancelled() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3122,6 +3209,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * thenCompose result completes exceptionally if the result of the action does
      */
+    @Test
     public void testThenCompose_actionReturnsFailingFuture() {
         for (ExecutionMode m : ExecutionMode.values())
         for (int order = 0; order < 6; order++)
@@ -3175,6 +3263,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * exceptionallyCompose result completes normally after normal
      * completion of source
      */
+    @Test
     public void testExceptionallyCompose_normalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3196,6 +3285,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * exceptionallyCompose result completes normally after exceptional
      * completion of source
      */
+    @Test
     public void testExceptionallyCompose_exceptionalCompletion() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3216,6 +3306,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * exceptionallyCompose completes exceptionally on exception if action does
      */
+    @Test
     public void testExceptionallyCompose_actionFailed() {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean createIncomplete : new boolean[] { true, false })
@@ -3237,6 +3328,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * exceptionallyCompose result completes exceptionally if the
      * result of the action does
      */
+    @Test
     public void testExceptionallyCompose_actionReturnsFailingFuture() {
         for (ExecutionMode m : ExecutionMode.values())
         for (int order = 0; order < 6; order++)
@@ -3292,6 +3384,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * allOf(no component futures) returns a future completed normally
      * with the value null
      */
+    @Test
     public void testAllOf_empty() throws Exception {
         CompletableFuture<Void> f = CompletableFuture.allOf();
         checkCompletedNormally(f, null);
@@ -3301,6 +3394,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * allOf returns a future completed normally with the value null
      * when all components complete normally
      */
+    @Test
     public void testAllOf_normal() throws Exception {
         for (int k = 1; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3319,6 +3413,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         }
     }
 
+    @Test
     public void testAllOf_normal_backwards() throws Exception {
         for (int k = 1; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3337,6 +3432,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         }
     }
 
+    @Test
     public void testAllOf_exceptional() throws Exception {
         for (int k = 1; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3366,6 +3462,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * anyOf(no component futures) returns an incomplete future
      */
+    @Test
     public void testAnyOf_empty() throws Exception {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -3380,6 +3477,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * anyOf returns a future completed normally with a value when
      * a component future does
      */
+    @Test
     public void testAnyOf_normal() throws Exception {
         for (int k = 0; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3397,6 +3495,7 @@ public class CompletableFutureTest extends JSR166TestCase {
             }
         }
     }
+    @Test
     public void testAnyOf_normal_backwards() throws Exception {
         for (int k = 0; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3418,6 +3517,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * anyOf result completes exceptionally when any component does.
      */
+    @Test
     public void testAnyOf_exceptional() throws Exception {
         for (int k = 0; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3438,6 +3538,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         }
     }
 
+    @Test
     public void testAnyOf_exceptional_backwards() throws Exception {
         for (int k = 0; k < 10; k++) {
             @SuppressWarnings("unchecked")
@@ -3462,6 +3563,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * Completion methods throw NullPointerException with null arguments
      */
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testNPE() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CompletableFuture<Item> g = new CompletableFuture<>();
@@ -3581,6 +3683,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * Test submissions to an executor that rejects all tasks.
      */
+    @Test
     public void testRejectingExecutor() {
         for (Item v : new Item[] { itemOne, null })
     {
@@ -3669,6 +3772,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * should never be invoked because the dependent future is
      * explicitly completed.
      */
+    @Test
     public void testRejectingExecutorNeverInvoked() {
         for (Item v : new Item[] { itemOne, null })
     {
@@ -3720,6 +3824,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * toCompletableFuture returns this CompletableFuture.
      */
+    @Test
     public void testToCompletableFuture() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         assertSame(f, f.toCompletableFuture());
@@ -3730,6 +3835,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * newIncompleteFuture returns an incomplete CompletableFuture
      */
+    @Test
     public void testNewIncompleteFuture() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -3748,6 +3854,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completedStage returns a completed CompletionStage
      */
+    @Test
     public void testCompletedStage() {
         AtomicInteger x = new AtomicInteger(0);
         AtomicReference<Throwable> r = new AtomicReference<>();
@@ -3761,6 +3868,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * defaultExecutor by default returns the commonPool if
      * it supports more than one thread.
      */
+    @Test
     public void testDefaultExecutor() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         Executor e = f.defaultExecutor();
@@ -3775,6 +3883,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * failedFuture returns a CompletableFuture completed
      * exceptionally with the given Exception
      */
+    @Test
     public void testFailedFuture() {
         CFException ex = new CFException();
         CompletableFuture<Item> f = CompletableFuture.failedFuture(ex);
@@ -3785,6 +3894,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * copy returns a CompletableFuture that is completed normally,
      * with the same value, when source is.
      */
+    @Test
     public void testCopy_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -3805,6 +3915,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * copy returns a CompletableFuture that is completed exceptionally
      * when source is.
      */
+    @Test
     public void testCopy_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -3824,6 +3935,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * Completion of a copy does not complete its source.
      */
+    @Test
     public void testCopy_oneWayPropagation() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         assertTrue(f.copy().complete(itemOne));
@@ -3838,6 +3950,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * minimalCompletionStage returns a CompletableFuture that is
      * completed normally, with the same value, when source is.
      */
+    @Test
     public void testMinimalCompletionStage() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CompletionStage<Item> g = f.minimalCompletionStage();
@@ -3855,6 +3968,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * minimalCompletionStage returns a CompletableFuture that is
      * completed exceptionally when source is.
      */
+    @Test
     public void testMinimalCompletionStage2() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CompletionStage<Item> g = f.minimalCompletionStage();
@@ -3873,6 +3987,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * failedStage returns a CompletionStage completed
      * exceptionally with the given Exception
      */
+    @Test
     public void testFailedStage() {
         CFException ex = new CFException();
         CompletionStage<Item> f = CompletableFuture.failedStage(ex);
@@ -3886,6 +4001,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeAsync completes with value of given supplier
      */
+    @Test
     public void testCompleteAsync() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -3898,6 +4014,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeAsync completes exceptionally if given supplier throws
      */
+    @Test
     public void testCompleteAsync2() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CFException ex = new CFException();
@@ -3912,6 +4029,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeAsync with given executor completes with value of given supplier
      */
+    @Test
     public void testCompleteAsync3() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -3927,6 +4045,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * completeAsync with given executor completes exceptionally if
      * given supplier throws
      */
+    @Test
     public void testCompleteAsync4() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CFException ex = new CFException();
@@ -3943,6 +4062,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * orTimeout completes with TimeoutException if not complete
      */
+    @Test
     public void testOrTimeout_timesOut() {
         long timeoutMillis = timeoutMillis();
         CompletableFuture<Item> f = new CompletableFuture<>();
@@ -3955,6 +4075,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * orTimeout completes normally if completed before timeout
      */
+    @Test
     public void testOrTimeout_completed() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -3973,6 +4094,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeOnTimeout completes with given value if not complete
      */
+    @Test
     public void testCompleteOnTimeout_timesOut() {
         testInParallel(() -> testCompleteOnTimeout_timesOut(fortytwo),
                        () -> testCompleteOnTimeout_timesOut(null));
@@ -3981,7 +4103,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeOnTimeout completes with given value if not complete
      */
-    public void testCompleteOnTimeout_timesOut(Item v) {
+    private void testCompleteOnTimeout_timesOut(Item v) {
         long timeoutMillis = timeoutMillis();
         CompletableFuture<Item> f = new CompletableFuture<>();
         long startTime = System.nanoTime();
@@ -3995,6 +4117,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * completeOnTimeout has no effect if completed within timeout
      */
+    @Test
     public void testCompleteOnTimeout_completed() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -4013,6 +4136,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * delayedExecutor returns an executor that delays submission
      */
+    @Test
     public void testDelayedExecutor() {
         testInParallel(() -> testDelayedExecutor(null, null),
                        () -> testDelayedExecutor(null, itemOne),
@@ -4020,7 +4144,7 @@ public class CompletableFutureTest extends JSR166TestCase {
                        () -> testDelayedExecutor(new ThreadExecutor(), itemOne));
     }
 
-    public void testDelayedExecutor(Executor executor, Item v) throws Exception {
+    private void testDelayedExecutor(Executor executor, Item v) throws Exception {
         long timeoutMillis = timeoutMillis();
         // Use an "unreasonably long" long timeout to catch lingering threads
         long longTimeoutMillis = 1000 * 60 * 60 * 24;
@@ -4075,6 +4199,7 @@ public class CompletableFutureTest extends JSR166TestCase {
         }
     }
 
+    @Test
     public void testExceptionPropagationReusesResultObject() {
         if (!testImplementationDetails) return;
         for (ExecutionMode m : ExecutionMode.values())
@@ -4168,6 +4293,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * Minimal completion stages throw UOE for most non-CompletionStage methods
      */
+    @Test
     public void testMinimalCompletionStage_minimality() {
         if (!testImplementationDetails) return;
         Function<Method, String> toSignature =
@@ -4236,6 +4362,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * minimalStage.toCompletableFuture() returns a CompletableFuture that
      * is completed normally, with the same value, when source is.
      */
+    @Test
     public void testMinimalCompletionStage_toCompletableFuture_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4257,6 +4384,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * minimalStage.toCompletableFuture() returns a CompletableFuture that
      * is completed exceptionally when source is.
      */
+    @Test
     public void testMinimalCompletionStage_toCompletableFuture_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -4277,6 +4405,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * minimalStage.toCompletableFuture() gives mutable CompletableFuture
      */
+    @Test
     public void testMinimalCompletionStage_toCompletableFuture_mutable() {
         for (Item v1 : new Item[] { itemOne, null })
     {
@@ -4292,6 +4421,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * minimalStage.toCompletableFuture().join() awaits completion
      */
+    @Test
     public void testMinimalCompletionStage_toCompletableFuture_join() throws Exception {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4309,6 +4439,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * Completion of a toCompletableFuture copy of a minimal stage
      * does not complete its source.
      */
+    @Test
     public void testMinimalCompletionStage_toCompletableFuture_oneWayPropagation() {
         CompletableFuture<Item> f = new CompletableFuture<>();
         CompletionStage<Item> g = f.minimalCompletionStage();
@@ -4341,6 +4472,7 @@ public class CompletableFutureTest extends JSR166TestCase {
     /**
      * Joining a minimal stage "by hand" works
      */
+    @Test
     public void testMinimalCompletionStage_join_by_hand() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4447,6 +4579,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * CompletableFuture is an additive monad - sort of.
      * https://en.wikipedia.org/wiki/Monad_(functional_programming)#Additive_monads
      */
+    @Test
     public void testAdditiveMonad() throws Throwable {
         Function<Long, CompletableFuture<Long>> unit = Monad::unit;
         CompletableFuture<Long> zero = Monad.zero();
@@ -4505,6 +4638,7 @@ public class CompletableFutureTest extends JSR166TestCase {
 
     /** Test long recursive chains of CompletableFutures with cascading completions */
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testRecursiveChains() throws Throwable {
         for (ExecutionMode m : ExecutionMode.values())
         for (boolean addDeadEnds : new boolean[] { true, false })
@@ -4530,6 +4664,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * A demo of scalability - runtime is O(n).
      */
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testManyDependents() throws Throwable {
         final int n = expensiveTests ? 1_000_000 : 10;
         final CompletableFuture<Void> head = new CompletableFuture<>();
@@ -4560,6 +4695,7 @@ public class CompletableFutureTest extends JSR166TestCase {
 
     /** ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest tck */
     @SuppressWarnings("FutureReturnValueIgnored")
+    @Test
     public void testCoCompletionGarbageRetention() throws Throwable {
         final int n = expensiveTests ? 1_000_000 : 10;
         final CompletableFuture<Item> incomplete = new CompletableFuture<>();
@@ -4606,6 +4742,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * 8160402: Garbage retention with CompletableFuture.anyOf
      * cvs update -D '2016-05-01' ./src/main/java/util/concurrent/CompletableFuture.java && ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testAnyOfGarbageRetention tck; cvs update -A
      */
+    @Test
     public void testAnyOfGarbageRetention() throws Throwable {
         for (Item v : new Item[] { itemOne, null })
     {
@@ -4626,6 +4763,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * As of 2016-07, fails with OOME:
      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testCancelledAllOfGarbageRetention tck
      */
+    @Test
     public void testCancelledAllOfGarbageRetention() throws Throwable {
         final int n = expensiveTests ? 100_000 : 10;
         @SuppressWarnings("unchecked")
@@ -4645,6 +4783,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * As of 2016-07, fails with OOME:
      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testCancelledGarbageRetention tck
      */
+    @Test
     public void testCancelledGarbageRetention() throws Throwable {
         final int n = expensiveTests ? 100_000 : 10;
         CompletableFuture<Item> neverCompleted = new CompletableFuture<>();
@@ -4660,6 +4799,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * As of 2016-07, fails with OOME:
      * ant -Dvmoptions=-Xmx8m -Djsr166.expensiveTests=true -Djsr166.tckTestClass=CompletableFutureTest -Djsr166.methodFilter=testToCompletableFutureGarbageRetention tck
      */
+    @Test
     public void testToCompletableFutureGarbageRetention() throws Throwable {
         final int n = expensiveTests ? 900_000 : 10;
         CompletableFuture<Item> neverCompleted = new CompletableFuture<>();
@@ -4846,6 +4986,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyAsync action is not invoked when
      * source completes normally, and source result is propagated
      */
+    @Test
     public void testDefaultExceptionallyAsync_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4871,6 +5012,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyAsync action completes with
      * function value on source exception
      */
+    @Test
     public void testDefaultExceptionallyAsync_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4899,6 +5041,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * throws an exception, it completes exceptionally with that
      * exception
      */
+    @Test
     public void testDefaultExceptionallyAsync_exceptionalCompletionActionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -4927,6 +5070,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyCompose result completes
      * normally after normal completion of source
      */
+    @Test
     public void testDefaultExceptionallyCompose_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -4949,6 +5093,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyCompose result completes
      * normally after exceptional completion of source
      */
+    @Test
     public void testDefaultExceptionallyCompose_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -4971,6 +5116,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyCompose completes
      * exceptionally on exception if action does
      */
+    @Test
     public void testDefaultExceptionallyCompose_actionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -4993,6 +5139,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync result completes
      * normally after normal completion of source
      */
+    @Test
     public void testDefaultExceptionallyComposeAsync_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -5015,6 +5162,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync result completes
      * normally after exceptional completion of source
      */
+    @Test
     public void testDefaultExceptionallyComposeAsync_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -5037,6 +5185,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync completes
      * exceptionally on exception if action does
      */
+    @Test
     public void testDefaultExceptionallyComposeAsync_actionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -5059,6 +5208,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync result completes
      * normally after normal completion of source
      */
+    @Test
     public void testDefaultExceptionallyComposeAsyncExecutor_normalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
         for (Item v1 : new Item[] { itemOne, null })
@@ -5081,6 +5231,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync result completes
      * normally after exceptional completion of source
      */
+    @Test
     public void testDefaultExceptionallyComposeAsyncExecutor_exceptionalCompletion() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
@@ -5103,6 +5254,7 @@ public class CompletableFutureTest extends JSR166TestCase {
      * default-implemented exceptionallyComposeAsync completes
      * exceptionally on exception if action does
      */
+    @Test
     public void testDefaultExceptionallyComposeAsyncExecutor_actionFailed() {
         for (boolean createIncomplete : new boolean[] { true, false })
     {
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMap8Test.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMap8Test.java
index 324a5efc49b..06e879ae806 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMap8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMap8Test.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import static java.util.Spliterator.CONCURRENT;
 import static java.util.Spliterator.DISTINCT;
 import static java.util.Spliterator.NONNULL;
@@ -50,16 +59,21 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.BiFunction;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentHashMap8Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentHashMap8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentHashMap8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentHashMap8Test.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -80,6 +94,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * getOrDefault returns value if present, else default
      */
+    @Test
     public void testGetOrDefault() {
         ConcurrentHashMap map = map5();
         assertEquals(map.getOrDefault(one, "Z"), "A");
@@ -89,6 +104,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * computeIfAbsent adds when the given key is not present
      */
+    @Test
     public void testComputeIfAbsent() {
         ConcurrentHashMap map = map5();
         map.computeIfAbsent(six, x -> "Z");
@@ -98,6 +114,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * computeIfAbsent does not replace if the key is already present
      */
+    @Test
     public void testComputeIfAbsent2() {
         ConcurrentHashMap map = map5();
         assertEquals("A", map.computeIfAbsent(one, x -> "Z"));
@@ -106,6 +123,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * computeIfAbsent does not add if function returns null
      */
+    @Test
     public void testComputeIfAbsent3() {
         ConcurrentHashMap map = map5();
         map.computeIfAbsent(six, x -> null);
@@ -115,6 +133,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * computeIfPresent does not replace if the key is already present
      */
+    @Test
     public void testComputeIfPresent() {
         ConcurrentHashMap map = map5();
         map.computeIfPresent(six, (x, y) -> "Z");
@@ -124,6 +143,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * computeIfPresent adds when the given key is not present
      */
+    @Test
     public void testComputeIfPresent2() {
         ConcurrentHashMap map = map5();
         assertEquals("Z", map.computeIfPresent(one, (x, y) -> "Z"));
@@ -132,6 +152,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * compute does not replace if the function returns null
      */
+    @Test
     public void testCompute() {
         ConcurrentHashMap map = map5();
         map.compute(six, (x, y) -> null);
@@ -141,6 +162,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * compute adds when the given key is not present
      */
+    @Test
     public void testCompute2() {
         ConcurrentHashMap map = map5();
         assertEquals("Z", map.compute(six, (x, y) -> "Z"));
@@ -149,6 +171,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * compute replaces when the given key is present
      */
+    @Test
     public void testCompute3() {
         ConcurrentHashMap map = map5();
         assertEquals("Z", map.compute(one, (x, y) -> "Z"));
@@ -157,6 +180,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * compute removes when the given key is present and function returns null
      */
+    @Test
     public void testCompute4() {
         ConcurrentHashMap map = map5();
         map.compute(one, (x, y) -> null);
@@ -166,6 +190,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * merge adds when the given key is not present
      */
+    @Test
     public void testMerge1() {
         ConcurrentHashMap map = map5();
         assertEquals("Y", map.merge(six, "Y", (x, y) -> "Z"));
@@ -174,6 +199,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * merge replaces when the given key is present
      */
+    @Test
     public void testMerge2() {
         ConcurrentHashMap map = map5();
         assertEquals("Z", map.merge(one, "Y", (x, y) -> "Z"));
@@ -182,6 +208,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * merge removes when the given key is present and function returns null
      */
+    @Test
     public void testMerge3() {
         ConcurrentHashMap map = map5();
         map.merge(one, "Y", (x, y) -> null);
@@ -211,6 +238,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * replaceAll replaces all matching values.
      */
+    @Test
     public void testReplaceAll() {
         ConcurrentHashMap<Integer, String> map = map5();
         map.replaceAll((x, y) -> { return x > 3 ? "Z" : y; });
@@ -224,6 +252,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * Default-constructed set is empty
      */
+    @Test
     public void testNewKeySet() {
         Set a = ConcurrentHashMap.newKeySet();
         assertTrue(a.isEmpty());
@@ -233,6 +262,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * keySet.add adds the key with the established value to the map;
      * remove removes it.
      */
+    @Test
     public void testKeySetAddRemove() {
         ConcurrentHashMap map = map5();
         Set set1 = map.keySet();
@@ -254,6 +284,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keySet.addAll adds each element from the given collection
      */
+    @Test
     public void testAddAll() {
         Set full = populatedSet(3);
         assertTrue(full.addAll(Arrays.asList(three, four, five)));
@@ -266,6 +297,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * keySet.addAll adds each element from the given collection that did not
      * already exist in the set
      */
+    @Test
     public void testAddAll2() {
         Set full = populatedSet(3);
         // "one" is duplicate and will not be added
@@ -278,6 +310,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keySet.add will not add the element if it already exists in the set
      */
+    @Test
     public void testAdd2() {
         Set full = populatedSet(3);
         assertFalse(full.add(one));
@@ -287,6 +320,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keySet.add adds the element when it does not exist in the set
      */
+    @Test
     public void testAdd3() {
         Set full = populatedSet(3);
         assertTrue(full.add(three));
@@ -299,6 +333,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * keySet.add throws UnsupportedOperationException if no default
      * mapped value
      */
+    @Test
     public void testAdd4() {
         Set full = map5().keySet();
         try {
@@ -311,6 +346,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * keySet.add throws NullPointerException if the specified key is
      * null
      */
+    @Test
     public void testAdd5() {
         Set full = populatedSet(3);
         try {
@@ -322,6 +358,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySetView.getMappedValue returns the map's mapped value
      */
+    @Test
     public void testGetMappedValue() {
         ConcurrentHashMap map = map5();
         // Android-changed: ConcurrentHashMap.keySet() has 2 return type variants on Android.
@@ -349,6 +386,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySetView.spliterator returns spliterator over the elements in this set
      */
+    @Test
     public void testKeySetSpliterator() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap map = map5();
@@ -367,6 +405,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keyset.clear removes all elements from the set
      */
+    @Test
     public void testClear() {
         Set full = populatedSet(3);
         full.clear();
@@ -376,6 +415,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keyset.contains returns true for added elements
      */
+    @Test
     public void testContains() {
         Set full = populatedSet(3);
         assertTrue(full.contains(one));
@@ -385,6 +425,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySets with equal elements are equal
      */
+    @Test
     public void testEquals() {
         Set a = populatedSet(3);
         Set b = populatedSet(3);
@@ -403,6 +444,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.containsAll returns true for collections with subset of elements
      */
+    @Test
     public void testContainsAll() {
         Collection full = populatedSet(3);
         assertTrue(full.containsAll(Arrays.asList()));
@@ -415,6 +457,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.isEmpty is true when empty, else false
      */
+    @Test
     public void testIsEmpty() {
         assertTrue(populatedSet(0).isEmpty());
         assertFalse(populatedSet(3).isEmpty());
@@ -424,6 +467,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * KeySet.iterator() returns an iterator containing the elements of the
      * set
      */
+    @Test
     public void testIterator() {
         Collection empty = ConcurrentHashMap.newKeySet();
         int size = 20;
@@ -450,6 +494,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * iterator of empty collections has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(ConcurrentHashMap.newKeySet().iterator());
         assertIteratorExhausted(new ConcurrentHashMap().entrySet().iterator());
@@ -460,6 +505,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         Set q = populatedSet(3);
         Iterator it = q.iterator();
@@ -475,6 +521,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.toString holds toString of elements
      */
+    @Test
     public void testToString() {
         assertEquals("[]", ConcurrentHashMap.newKeySet().toString());
         Set full = populatedSet(3);
@@ -486,6 +533,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.removeAll removes all elements from the given collection
      */
+    @Test
     public void testRemoveAll() {
         Set full = populatedSet(3);
         assertTrue(full.removeAll(Arrays.asList(one, two)));
@@ -497,6 +545,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * KeySet.remove removes an element
      */
+    @Test
     public void testRemove() {
         Set full = populatedSet(3);
         full.remove(one);
@@ -507,6 +556,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * keySet.size returns the number of elements
      */
+    @Test
     public void testSize() {
         Set empty = ConcurrentHashMap.newKeySet();
         Set full = populatedSet(3);
@@ -518,6 +568,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * KeySet.toArray() returns an Object array containing all elements from
      * the set
      */
+    @Test
     public void testToArray() {
         Object[] a = ConcurrentHashMap.newKeySet().toArray();
         assertTrue(Arrays.equals(new Object[0], a));
@@ -538,6 +589,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * toArray(Integer array) returns an Integer array containing all
      * elements from the set
      */
+    @Test
     public void testToArray2() {
         Collection empty = ConcurrentHashMap.newKeySet();
         Integer[] a;
@@ -574,6 +626,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * A deserialized serialized set is equal
      */
+    @Test
     public void testSerialization() throws Exception {
         int size = 20;
         Set x = populatedSet(size);
@@ -609,6 +662,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachKeySequentially traverses all keys
      */
+    @Test
     public void testForEachKeySequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -619,6 +673,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachValueSequentially traverses all values
      */
+    @Test
     public void testForEachValueSequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -629,6 +684,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachSequentially traverses all mappings
      */
+    @Test
     public void testForEachSequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -639,6 +695,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachEntrySequentially traverses all entries
      */
+    @Test
     public void testForEachEntrySequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -649,6 +706,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachKeyInParallel traverses all keys
      */
+    @Test
     public void testForEachKeyInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -659,6 +717,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachValueInParallel traverses all values
      */
+    @Test
     public void testForEachValueInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -669,6 +728,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachInParallel traverses all mappings
      */
+    @Test
     public void testForEachInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -679,6 +739,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * forEachEntryInParallel traverses all entries
      */
+    @Test
     public void testForEachEntryInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -690,6 +751,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachKeySequentially traverses the given
      * transformations of all keys
      */
+    @Test
     public void testMappedForEachKeySequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -702,6 +764,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachValueSequentially traverses the given
      * transformations of all values
      */
+    @Test
     public void testMappedForEachValueSequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -714,6 +777,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachSequentially traverses the given
      * transformations of all mappings
      */
+    @Test
     public void testMappedForEachSequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -726,6 +790,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachEntrySequentially traverses the given
      * transformations of all entries
      */
+    @Test
     public void testMappedForEachEntrySequentially() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -738,6 +803,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachKeyInParallel traverses the given
      * transformations of all keys
      */
+    @Test
     public void testMappedForEachKeyInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -750,6 +816,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachValueInParallel traverses the given
      * transformations of all values
      */
+    @Test
     public void testMappedForEachValueInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -762,6 +829,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachInParallel traverses the given
      * transformations of all mappings
      */
+    @Test
     public void testMappedForEachInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -774,6 +842,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * Mapped forEachEntryInParallel traverses the given
      * transformations of all entries
      */
+    @Test
     public void testMappedForEachEntryInParallel() {
         LongAdder adder = new LongAdder();
         ConcurrentHashMap<Long, Long> m = longMap();
@@ -785,6 +854,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysSequentially accumulates across all keys,
      */
+    @Test
     public void testReduceKeysSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -795,6 +865,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesSequentially accumulates across all values
      */
+    @Test
     public void testReduceValuesSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -805,6 +876,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceEntriesSequentially accumulates across all entries
      */
+    @Test
     public void testReduceEntriesSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Map.Entry<Long,Long> r;
@@ -815,6 +887,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysInParallel accumulates across all keys
      */
+    @Test
     public void testReduceKeysInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -825,6 +898,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesInParallel accumulates across all values
      */
+    @Test
     public void testReduceValuesInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -835,6 +909,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceEntriesInParallel accumulate across all entries
      */
+    @Test
     public void testReduceEntriesInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Map.Entry<Long,Long> r;
@@ -845,6 +920,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * Mapped reduceKeysSequentially accumulates mapped keys
      */
+    @Test
     public void testMapReduceKeysSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r = m.reduceKeys(Long.MAX_VALUE, (Long x) -> Long.valueOf(4 * x.longValue()),
@@ -855,6 +931,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * Mapped reduceValuesSequentially accumulates mapped values
      */
+    @Test
     public void testMapReduceValuesSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r = m.reduceValues(Long.MAX_VALUE, (Long x) -> Long.valueOf(4 * x.longValue()),
@@ -865,6 +942,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceSequentially accumulates across all transformed mappings
      */
+    @Test
     public void testMappedReduceSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r = m.reduce(Long.MAX_VALUE, (Long x, Long y) -> Long.valueOf(x.longValue() + y.longValue()),
@@ -876,6 +954,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * Mapped reduceKeysInParallel, accumulates mapped keys
      */
+    @Test
     public void testMapReduceKeysInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r = m.reduceKeys(1L, (Long x) -> Long.valueOf(4 * x.longValue()),
@@ -886,6 +965,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * Mapped reduceValuesInParallel accumulates mapped values
      */
+    @Test
     public void testMapReduceValuesInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r = m.reduceValues(1L, (Long x) -> Long.valueOf(4 * x.longValue()),
@@ -896,6 +976,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceInParallel accumulate across all transformed mappings
      */
+    @Test
     public void testMappedReduceInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -907,6 +988,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysToLongSequentially accumulates mapped keys
      */
+    @Test
     public void testReduceKeysToLongSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         long lr = m.reduceKeysToLong(Long.MAX_VALUE, (Long x) -> x.longValue(), 0L, Long::sum);
@@ -916,6 +998,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysToIntSequentially accumulates mapped keys
      */
+    @Test
     public void testReduceKeysToIntSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         int ir = m.reduceKeysToInt(Long.MAX_VALUE, (Long x) -> x.intValue(), 0, Integer::sum);
@@ -925,15 +1008,17 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysToDoubleSequentially accumulates mapped keys
      */
+    @Test
     public void testReduceKeysToDoubleSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         double dr = m.reduceKeysToDouble(Long.MAX_VALUE, (Long x) -> x.doubleValue(), 0.0, Double::sum);
-        assertEquals(dr, (double)SIZE * (SIZE - 1) / 2);
+        assertEquals(dr, (double)SIZE * (SIZE - 1) / 2, 0.0d);
     }
 
     /**
      * reduceValuesToLongSequentially accumulates mapped values
      */
+    @Test
     public void testReduceValuesToLongSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         long lr = m.reduceValuesToLong(Long.MAX_VALUE, (Long x) -> x.longValue(), 0L, Long::sum);
@@ -943,6 +1028,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesToIntSequentially accumulates mapped values
      */
+    @Test
     public void testReduceValuesToIntSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         int ir = m.reduceValuesToInt(Long.MAX_VALUE, (Long x) -> x.intValue(), 0, Integer::sum);
@@ -952,15 +1038,17 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesToDoubleSequentially accumulates mapped values
      */
+    @Test
     public void testReduceValuesToDoubleSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         double dr = m.reduceValuesToDouble(Long.MAX_VALUE, (Long x) -> x.doubleValue(), 0.0, Double::sum);
-        assertEquals(dr, (double)SIZE * (SIZE - 1));
+        assertEquals(dr, (double)SIZE * (SIZE - 1), 0.0d);
     }
 
     /**
      * reduceKeysToLongInParallel accumulates mapped keys
      */
+    @Test
     public void testReduceKeysToLongInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         long lr = m.reduceKeysToLong(1L, (Long x) -> x.longValue(), 0L, Long::sum);
@@ -970,6 +1058,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysToIntInParallel accumulates mapped keys
      */
+    @Test
     public void testReduceKeysToIntInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         int ir = m.reduceKeysToInt(1L, (Long x) -> x.intValue(), 0, Integer::sum);
@@ -979,15 +1068,17 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceKeysToDoubleInParallel accumulates mapped values
      */
+    @Test
     public void testReduceKeysToDoubleInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         double dr = m.reduceKeysToDouble(1L, (Long x) -> x.doubleValue(), 0.0, Double::sum);
-        assertEquals(dr, (double)SIZE * (SIZE - 1) / 2);
+        assertEquals(dr, (double)SIZE * (SIZE - 1) / 2, 0.0d);
     }
 
     /**
      * reduceValuesToLongInParallel accumulates mapped values
      */
+    @Test
     public void testReduceValuesToLongInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         long lr = m.reduceValuesToLong(1L, (Long x) -> x.longValue(), 0L, Long::sum);
@@ -997,6 +1088,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesToIntInParallel accumulates mapped values
      */
+    @Test
     public void testReduceValuesToIntInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         int ir = m.reduceValuesToInt(1L, (Long x) -> x.intValue(), 0, Integer::sum);
@@ -1006,16 +1098,18 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
     /**
      * reduceValuesToDoubleInParallel accumulates mapped values
      */
+    @Test
     public void testReduceValuesToDoubleInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         double dr = m.reduceValuesToDouble(1L, (Long x) -> x.doubleValue(), 0.0, Double::sum);
-        assertEquals(dr, (double)SIZE * (SIZE - 1));
+        assertEquals(dr, (double)SIZE * (SIZE - 1), 0.0d);
     }
 
     /**
      * searchKeysSequentially returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchKeysSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1029,6 +1123,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchValuesSequentially returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchValuesSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1044,6 +1139,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchSequentially returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1057,6 +1153,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchEntriesSequentially returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchEntriesSequentially() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1070,6 +1167,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchKeysInParallel returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchKeysInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1083,6 +1181,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchValuesInParallel returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchValuesInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1096,6 +1195,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchInParallel returns a non-null result of search function,
      * or null if none
      */
+    @Test
     public void testSearchInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1109,6 +1209,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * searchEntriesInParallel returns a non-null result of search
      * function, or null if none
      */
+    @Test
     public void testSearchEntriesInParallel() {
         ConcurrentHashMap<Long, Long> m = longMap();
         Long r;
@@ -1123,6 +1224,7 @@ public class ConcurrentHashMap8Test extends JSR166TestCase {
      * See JDK-8161372
      * ant -Djsr166.tckTestClass=ConcurrentHashMapTest -Djsr166.methodFilter=testcomputeIfAbsent_performance -Djsr166.expensiveTests=true tck
      */
+    @Test
     public void testcomputeIfAbsent_performance() {
         final int mapSize = 20;
         final int iterations = expensiveTests ? (1 << 23) : mapSize * 2;
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMapTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMapTest.java
index 3973edaedd0..d50ec01e1d5 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMapTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentHashMapTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -47,16 +56,21 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentHashMapTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentHashMapTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentHashMapTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentHashMapTest.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -144,6 +158,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Inserted elements that are subclasses of the same Comparable
      * class are found.
      */
+    @Test
     public void testComparableFamily() {
         int size = 500;         // makes measured test run time -> 60ms
         ConcurrentHashMap<BI, Boolean> m =
@@ -161,6 +176,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Elements of classes with erased generic type parameters based
      * on Comparable can be inserted and found.
      */
+    @Test
     public void testGenericComparable() {
         int size = 120;         // makes measured test run time -> 60ms
         ConcurrentHashMap<Object, Boolean> m =
@@ -186,6 +202,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * with erased generic type parameters based on Comparable can be
      * inserted and found.
      */
+    @Test
     public void testGenericComparable2() {
         int size = 500;         // makes measured test run time -> 60ms
         ConcurrentHashMap<Object, Boolean> m =
@@ -204,6 +221,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Mixtures of instances of comparable and non-comparable classes
      * can be inserted and found.
      */
+    @Test
     public void testMixedComparable() {
         int size = 1200;        // makes measured test run time -> 35ms
         ConcurrentHashMap<Object, Object> map =
@@ -238,6 +256,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testClear() {
         ConcurrentHashMap map = map5();
         map.clear();
@@ -247,6 +266,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testEquals() {
         ConcurrentHashMap map1 = map5();
         ConcurrentHashMap map2 = map5();
@@ -260,6 +280,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * hashCode() equals sum of each key.hashCode ^ value.hashCode
      */
+    @Test
     public void testHashCode() {
         ConcurrentHashMap<Integer,String> map = map5();
         int sum = 0;
@@ -271,6 +292,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * contains returns true for contained value
      */
+    @Test
     public void testContains() {
         ConcurrentHashMap map = map5();
         assertTrue(map.contains("A"));
@@ -280,6 +302,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testContainsKey() {
         ConcurrentHashMap map = map5();
         assertTrue(map.containsKey(one));
@@ -289,6 +312,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testContainsValue() {
         ConcurrentHashMap map = map5();
         assertTrue(map.containsValue("A"));
@@ -299,6 +323,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * enumeration returns an enumeration containing the correct
      * elements
      */
+    @Test
     public void testEnumeration() {
         ConcurrentHashMap map = map5();
         Enumeration e = map.elements();
@@ -314,6 +339,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testGet() {
         ConcurrentHashMap map = map5();
         assertEquals("A", (String)map.get(one));
@@ -325,6 +351,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testIsEmpty() {
         ConcurrentHashMap empty = new ConcurrentHashMap();
         ConcurrentHashMap map = map5();
@@ -335,6 +362,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * keys returns an enumeration containing all the keys from the map
      */
+    @Test
     public void testKeys() {
         ConcurrentHashMap map = map5();
         Enumeration e = map.keys();
@@ -349,6 +377,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testKeySet() {
         ConcurrentHashMap map = map5();
         Set s = map.keySet();
@@ -363,6 +392,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * Test keySet().removeAll on empty map
      */
+    @Test
     public void testKeySet_empty_removeAll() {
         ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
         Set<Integer> set = map.keySet();
@@ -378,6 +408,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testKeySetToArray() {
         ConcurrentHashMap map = map5();
         Set s = map.keySet();
@@ -391,6 +422,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * Values.toArray contains all values
      */
+    @Test
     public void testValuesToArray() {
         ConcurrentHashMap map = map5();
         Collection v = map.values();
@@ -407,6 +439,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * entrySet.toArray contains all entries
      */
+    @Test
     public void testEntrySetToArray() {
         ConcurrentHashMap map = map5();
         Set s = map.entrySet();
@@ -421,6 +454,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testValues() {
         ConcurrentHashMap map = map5();
         Collection s = map.values();
@@ -435,6 +469,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testEntrySet() {
         ConcurrentHashMap map = map5();
         Set s = map.entrySet();
@@ -454,6 +489,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testPutAll() {
         ConcurrentHashMap empty = new ConcurrentHashMap();
         ConcurrentHashMap map = map5();
@@ -469,6 +505,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * putIfAbsent works when the given key is not present
      */
+    @Test
     public void testPutIfAbsent() {
         ConcurrentHashMap map = map5();
         map.putIfAbsent(six, "Z");
@@ -478,6 +515,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * putIfAbsent does not add the pair if the key is already present
      */
+    @Test
     public void testPutIfAbsent2() {
         ConcurrentHashMap map = map5();
         assertEquals("A", map.putIfAbsent(one, "Z"));
@@ -486,6 +524,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace fails when the given key is not present
      */
+    @Test
     public void testReplace() {
         ConcurrentHashMap map = map5();
         assertNull(map.replace(six, "Z"));
@@ -495,6 +534,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace succeeds if the key is already present
      */
+    @Test
     public void testReplace2() {
         ConcurrentHashMap map = map5();
         assertNotNull(map.replace(one, "Z"));
@@ -504,6 +544,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace value fails when the given key not mapped to expected value
      */
+    @Test
     public void testReplaceValue() {
         ConcurrentHashMap map = map5();
         assertEquals("A", map.get(one));
@@ -514,6 +555,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace value succeeds when the given key mapped to expected value
      */
+    @Test
     public void testReplaceValue2() {
         ConcurrentHashMap map = map5();
         assertEquals("A", map.get(one));
@@ -524,6 +566,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testRemove() {
         ConcurrentHashMap map = map5();
         map.remove(five);
@@ -534,6 +577,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * remove(key,value) removes only if pair present
      */
+    @Test
     public void testRemove2() {
         ConcurrentHashMap map = map5();
         map.remove(five, "E");
@@ -547,6 +591,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testSize() {
         ConcurrentHashMap map = map5();
         ConcurrentHashMap empty = new ConcurrentHashMap();
@@ -557,6 +602,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         ConcurrentHashMap map = map5();
         String s = map.toString();
@@ -570,6 +616,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * Cannot create with only negative capacity
      */
+    @Test
     public void testConstructor1() {
         try {
             new ConcurrentHashMap(-1);
@@ -581,6 +628,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Constructor (initialCapacity, loadFactor) throws
      * IllegalArgumentException if either argument is negative
      */
+    @Test
     public void testConstructor2() {
         try {
             new ConcurrentHashMap(-1, .75f);
@@ -597,6 +645,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Constructor (initialCapacity, loadFactor, concurrencyLevel)
      * throws IllegalArgumentException if any argument is negative
      */
+    @Test
     public void testConstructor3() {
         try {
             new ConcurrentHashMap(-1, .75f, 1);
@@ -618,6 +667,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * ConcurrentHashMap(map) throws NullPointerException if the given
      * map is null
      */
+    @Test
     public void testConstructor4() {
         try {
             new ConcurrentHashMap(null);
@@ -629,6 +679,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * ConcurrentHashMap(map) creates a new map with the same mappings
      * as the given map
      */
+    @Test
     public void testConstructor5() {
         ConcurrentHashMap map1 = map5();
         ConcurrentHashMap map2 = new ConcurrentHashMap(map5());
@@ -640,6 +691,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * get(null) throws NPE
      */
+    @Test
     public void testGet_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -651,6 +703,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * containsKey(null) throws NPE
      */
+    @Test
     public void testContainsKey_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -662,6 +715,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * containsValue(null) throws NPE
      */
+    @Test
     public void testContainsValue_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -673,6 +727,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * contains(null) throws NPE
      */
+    @Test
     public void testContains_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -684,6 +739,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testPut1_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -695,6 +751,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * put(x, null) throws NPE
      */
+    @Test
     public void testPut2_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -706,6 +763,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * putIfAbsent(null, x) throws NPE
      */
+    @Test
     public void testPutIfAbsent1_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -717,6 +775,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace(null, x) throws NPE
      */
+    @Test
     public void testReplace_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -728,6 +787,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace(null, x, y) throws NPE
      */
+    @Test
     public void testReplaceValue_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -739,6 +799,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * putIfAbsent(x, null) throws NPE
      */
+    @Test
     public void testPutIfAbsent2_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -750,6 +811,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace(x, null) throws NPE
      */
+    @Test
     public void testReplace2_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -761,6 +823,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace(x, null, y) throws NPE
      */
+    @Test
     public void testReplaceValue2_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -772,6 +835,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * replace(x, y, null) throws NPE
      */
+    @Test
     public void testReplaceValue3_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         try {
@@ -783,6 +847,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE
      */
+    @Test
     public void testRemove1_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         c.put("sadsdf", "asdads");
@@ -795,6 +860,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * remove(null, x) throws NPE
      */
+    @Test
     public void testRemove2_NullPointerException() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         c.put("sadsdf", "asdads");
@@ -807,6 +873,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * remove(x, null) returns false
      */
+    @Test
     public void testRemove3() {
         ConcurrentHashMap c = new ConcurrentHashMap(5);
         c.put("sadsdf", "asdads");
@@ -816,6 +883,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testSerialization() throws Exception {
         Map x = map5();
         Map y = serialClone(x);
@@ -829,6 +897,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
     /**
      * SetValue of an EntrySet entry sets value in the map.
      */
+    @Test
     public void testSetValueWriteThrough() {
         // Adapted from a bug report by Eric Zoerner
         ConcurrentHashMap map = new ConcurrentHashMap(2, 5.0f, 1);
@@ -852,6 +921,7 @@ public class ConcurrentHashMapTest extends JSR166TestCase {
      * Tests performance of removeAll when the other collection is much smaller.
      * ant -Djsr166.tckTestClass=ConcurrentHashMapTest -Djsr166.methodFilter=testRemoveAll_performance -Djsr166.expensiveTests=true tck
      */
+    @Test
     public void testRemoveAll_performance() {
         final int mapSize = expensiveTests ? 1_000_000 : 100;
         final int iterations = expensiveTests ? 500 : 2;
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedDequeTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedDequeTest.java
index 1547ed628ef..0265fe2d0a3 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedDequeTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedDequeTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
@@ -43,26 +52,30 @@ import java.util.Queue;
 import java.util.Random;
 import java.util.concurrent.ConcurrentLinkedDeque;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentLinkedDequeTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentLinkedDequeTest");
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return ConcurrentLinkedDeque.class; }
-            public Collection emptyCollection() { return new ConcurrentLinkedDeque(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(ConcurrentLinkedDequeTest.class,
-                            CollectionTest.testSuite(new Implementation()));
-    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return ConcurrentLinkedDeque.class; }
+    //         public Collection emptyCollection() { return new ConcurrentLinkedDeque(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(ConcurrentLinkedDequeTest.class,
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Returns a new deque of given size containing consecutive
@@ -83,6 +96,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * new deque is empty
      */
+    @Test
     public void testConstructor1() {
         assertTrue(new ConcurrentLinkedDeque().isEmpty());
         assertEquals(0, new ConcurrentLinkedDeque().size());
@@ -91,6 +105,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new ConcurrentLinkedDeque((Collection)null);
@@ -101,6 +116,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new ConcurrentLinkedDeque(Arrays.asList(new Integer[SIZE]));
@@ -111,6 +127,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -124,6 +141,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -136,6 +154,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         assertTrue(q.isEmpty());
@@ -150,6 +169,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * size() changes when elements added and removed
      */
+    @Test
     public void testSize() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -165,6 +185,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * push(null) throws NPE
      */
+    @Test
     public void testPushNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -176,6 +197,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * peekFirst() returns element inserted with push
      */
+    @Test
     public void testPush() {
         ConcurrentLinkedDeque q = populatedDeque(3);
         q.pollLast();
@@ -186,6 +208,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * pop() removes first element, or throws NSEE if empty
      */
+    @Test
     public void testPop() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -200,6 +223,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offer(null) throws NPE
      */
+    @Test
     public void testOfferNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -211,6 +235,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offerFirst(null) throws NPE
      */
+    @Test
     public void testOfferFirstNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -222,6 +247,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offerLast(null) throws NPE
      */
+    @Test
     public void testOfferLastNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -233,6 +259,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offer(x) succeeds
      */
+    @Test
     public void testOffer() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         assertTrue(q.offer(zero));
@@ -244,6 +271,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offerFirst(x) succeeds
      */
+    @Test
     public void testOfferFirst() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         assertTrue(q.offerFirst(zero));
@@ -255,6 +283,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * offerLast(x) succeeds
      */
+    @Test
     public void testOfferLast() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         assertTrue(q.offerLast(zero));
@@ -266,6 +295,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -277,6 +307,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addFirst(null) throws NPE
      */
+    @Test
     public void testAddFirstNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -288,6 +319,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addLast(null) throws NPE
      */
+    @Test
     public void testAddLastNull() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -299,6 +331,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * add(x) succeeds
      */
+    @Test
     public void testAdd() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         assertTrue(q.add(zero));
@@ -310,6 +343,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addFirst(x) succeeds
      */
+    @Test
     public void testAddFirst() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         q.addFirst(zero);
@@ -321,6 +355,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addLast(x) succeeds
      */
+    @Test
     public void testAddLast() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         q.addLast(zero);
@@ -332,6 +367,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -343,6 +379,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         try {
@@ -354,6 +391,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         try {
@@ -366,6 +404,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         Integer[] ints = new Integer[SIZE];
@@ -380,6 +419,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -395,6 +435,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * pollFirst() succeeds unless empty
      */
+    @Test
     public void testPollFirst() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -406,6 +447,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * pollLast() succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -417,6 +459,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * poll() succeeds unless empty
      */
+    @Test
     public void testPoll() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -428,6 +471,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * peek() returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -442,6 +486,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * element() returns first element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -457,6 +502,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * remove() removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -471,6 +517,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -492,6 +539,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * peekFirst() returns next element, or null if empty
      */
+    @Test
     public void testPeekFirst() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -506,6 +554,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * peekLast() returns next element, or null if empty
      */
+    @Test
     public void testPeekLast() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -520,6 +569,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * getFirst() returns first element, or throws NSEE if empty
      */
+    @Test
     public void testFirstElement() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -535,6 +585,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * getLast() returns last element, or throws NSEE if empty
      */
+    @Test
     public void testLastElement() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -551,6 +602,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * removeFirst() removes first element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveFirst() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -566,6 +618,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * removeLast() removes last element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveLast() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -581,6 +634,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * removeFirstOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveFirstOccurrence() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -596,6 +650,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * removeLastOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveLastOccurrence() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -611,6 +666,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -623,6 +679,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * clear() removes all elements
      */
+    @Test
     public void testClear() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         q.clear();
@@ -637,6 +694,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         ConcurrentLinkedDeque p = new ConcurrentLinkedDeque();
@@ -651,6 +709,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if change
      */
+    @Test
     public void testRetainAll() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         ConcurrentLinkedDeque p = populatedDeque(SIZE);
@@ -670,6 +729,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             ConcurrentLinkedDeque q = populatedDeque(SIZE);
@@ -686,6 +746,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * toArray() contains all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         Object[] o = q.toArray();
@@ -696,6 +757,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() {
         ConcurrentLinkedDeque<Integer> q = populatedDeque(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -708,6 +770,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * toArray(null) throws NullPointerException
      */
+    @Test
     public void testToArray_NullArg() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         try {
@@ -719,6 +782,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         try {
@@ -730,6 +794,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         Iterator it = q.iterator();
@@ -743,6 +808,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         Deque c = new ConcurrentLinkedDeque();
         assertIteratorExhausted(c.iterator());
@@ -752,6 +818,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         q.add(one);
@@ -769,6 +836,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         q.add(one);
@@ -786,6 +854,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * iterator.remove() removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         final Random rng = new Random();
@@ -814,6 +883,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Descending iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         int i = 0;
@@ -833,6 +903,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * Descending iterator ordering is reverse FIFO
      */
+    @Test
     public void testDescendingIteratorOrdering() {
         final ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         for (int iters = 0; iters < 100; ++iters) {
@@ -854,6 +925,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * descendingIterator.remove() removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();
         final Random rng = new Random();
@@ -882,6 +954,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * toString() contains toStrings of elements
      */
+    @Test
     public void testToString() {
         ConcurrentLinkedDeque q = populatedDeque(SIZE);
         String s = q.toString();
@@ -893,6 +966,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
     /**
      * A deserialized serialized deque has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedDeque(SIZE);
         Queue y = serialClone(x);
@@ -912,6 +986,7 @@ public class ConcurrentLinkedDequeTest extends JSR166TestCase {
      * contains(null) always return false.
      * remove(null) always throws NullPointerException.
      */
+    @Test
     public void testNeverContainsNull() {
         Deque<?>[] qs = {
             new ConcurrentLinkedDeque<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedQueueTest.java
index 4a1399cd01f..56386f19158 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentLinkedQueueTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
@@ -41,26 +50,30 @@ import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentLinkedQueueTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentLinkedQueueTest");
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return ConcurrentLinkedQueue.class; }
-            public Collection emptyCollection() { return new ConcurrentLinkedQueue(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(ConcurrentLinkedQueueTest.class,
-                            CollectionTest.testSuite(new Implementation()));
-    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return ConcurrentLinkedQueue.class; }
+    //         public Collection emptyCollection() { return new ConcurrentLinkedQueue(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(ConcurrentLinkedQueueTest.class,
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Returns a new queue of given size containing consecutive
@@ -80,6 +93,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * new queue is empty
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new ConcurrentLinkedQueue().size());
     }
@@ -87,6 +101,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new ConcurrentLinkedQueue((Collection)null);
@@ -97,6 +112,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new ConcurrentLinkedQueue(Arrays.asList(new Integer[SIZE]));
@@ -107,6 +123,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -120,6 +137,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -132,6 +150,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         assertTrue(q.isEmpty());
@@ -146,6 +165,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -161,6 +181,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * offer(null) throws NPE
      */
+    @Test
     public void testOfferNull() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         try {
@@ -172,6 +193,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         try {
@@ -183,6 +205,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Offer returns true
      */
+    @Test
     public void testOffer() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         assertTrue(q.offer(zero));
@@ -192,6 +215,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * add returns true
      */
+    @Test
     public void testAdd() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         for (int i = 0; i < SIZE; ++i) {
@@ -203,6 +227,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         try {
@@ -214,6 +239,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         try {
@@ -225,6 +251,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         try {
@@ -237,6 +264,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         Integer[] ints = new Integer[SIZE];
@@ -251,6 +279,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -266,6 +295,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -277,6 +307,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -291,6 +322,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -306,6 +338,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -320,6 +353,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -341,6 +375,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -353,6 +388,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         q.clear();
@@ -367,6 +403,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         ConcurrentLinkedQueue p = new ConcurrentLinkedQueue();
@@ -381,6 +418,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if change
      */
+    @Test
     public void testRetainAll() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         ConcurrentLinkedQueue p = populatedQueue(SIZE);
@@ -400,6 +438,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             ConcurrentLinkedQueue q = populatedQueue(SIZE);
@@ -416,6 +455,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * toArray contains all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -426,6 +466,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() {
         ConcurrentLinkedQueue<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -438,6 +479,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * toArray(null) throws NullPointerException
      */
+    @Test
     public void testToArray_NullArg() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         try {
@@ -449,6 +491,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         try {
@@ -460,6 +503,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -473,6 +517,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new ConcurrentLinkedQueue().iterator());
     }
@@ -480,6 +525,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         q.add(one);
@@ -497,6 +543,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         q.add(one);
@@ -514,6 +561,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
         q.add(one);
@@ -531,6 +579,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         ConcurrentLinkedQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -542,6 +591,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
@@ -560,6 +610,7 @@ public class ConcurrentLinkedQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?>[] qs = {
             new ConcurrentLinkedQueue<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListMapTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListMapTest.java
index 7e8594d3ac7..aa446e19589 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListMapTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListMapTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
@@ -45,16 +54,21 @@ import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.ConcurrentSkipListMap;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentSkipListMapTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentSkipListMapTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentSkipListMapTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentSkipListMapTest.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -75,6 +89,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testClear() {
         ConcurrentSkipListMap map = map5();
         map.clear();
@@ -84,6 +99,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * copy constructor creates map equal to source map
      */
+    @Test
     public void testConstructFromSorted() {
         ConcurrentSkipListMap map = map5();
         ConcurrentSkipListMap map2 = new ConcurrentSkipListMap(map);
@@ -93,6 +109,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testEquals() {
         ConcurrentSkipListMap map1 = map5();
         ConcurrentSkipListMap map2 = map5();
@@ -106,6 +123,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testContainsKey() {
         ConcurrentSkipListMap map = map5();
         assertTrue(map.containsKey(one));
@@ -115,6 +133,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testContainsValue() {
         ConcurrentSkipListMap map = map5();
         assertTrue(map.containsValue("A"));
@@ -125,6 +144,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testGet() {
         ConcurrentSkipListMap map = map5();
         assertEquals("A", (String)map.get(one));
@@ -135,6 +155,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testIsEmpty() {
         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
         ConcurrentSkipListMap map = map5();
@@ -145,6 +166,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testFirstKey() {
         ConcurrentSkipListMap map = map5();
         assertEquals(one, map.firstKey());
@@ -153,6 +175,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testLastKey() {
         ConcurrentSkipListMap map = map5();
         assertEquals(five, map.lastKey());
@@ -161,6 +184,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testKeySetToArray() {
         ConcurrentSkipListMap map = map5();
         Set s = map.keySet();
@@ -174,6 +198,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descendingkeySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingKeySetToArray() {
         ConcurrentSkipListMap map = map5();
         Set s = map.descendingKeySet();
@@ -187,6 +212,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testKeySet() {
         ConcurrentSkipListMap map = map5();
         Set s = map.keySet();
@@ -201,6 +227,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testKeySetOrder() {
         ConcurrentSkipListMap map = map5();
         Set s = map.keySet();
@@ -220,6 +247,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descending iterator of key set is inverse ordered
      */
+    @Test
     public void testKeySetDescendingIteratorOrder() {
         ConcurrentSkipListMap map = map5();
         NavigableSet s = map.navigableKeySet();
@@ -239,6 +267,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descendingKeySet is ordered
      */
+    @Test
     public void testDescendingKeySetOrder() {
         ConcurrentSkipListMap map = map5();
         Set s = map.descendingKeySet();
@@ -258,6 +287,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descending iterator of descendingKeySet is ordered
      */
+    @Test
     public void testDescendingKeySetDescendingIteratorOrder() {
         ConcurrentSkipListMap map = map5();
         NavigableSet s = map.descendingKeySet();
@@ -277,6 +307,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * Values.toArray contains all values
      */
+    @Test
     public void testValuesToArray() {
         ConcurrentSkipListMap map = map5();
         Collection v = map.values();
@@ -293,6 +324,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testValues() {
         ConcurrentSkipListMap map = map5();
         Collection s = map.values();
@@ -307,6 +339,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testEntrySet() {
         ConcurrentSkipListMap map = map5();
         Set s = map.entrySet();
@@ -326,6 +359,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descendingEntrySet contains all pairs
      */
+    @Test
     public void testDescendingEntrySet() {
         ConcurrentSkipListMap map = map5();
         Set s = map.descendingMap().entrySet();
@@ -345,6 +379,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * entrySet.toArray contains all entries
      */
+    @Test
     public void testEntrySetToArray() {
         ConcurrentSkipListMap map = map5();
         Set s = map.entrySet();
@@ -359,6 +394,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * descendingEntrySet.toArray contains all entries
      */
+    @Test
     public void testDescendingEntrySetToArray() {
         ConcurrentSkipListMap map = map5();
         Set s = map.descendingMap().entrySet();
@@ -373,6 +409,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testPutAll() {
         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
         ConcurrentSkipListMap map = map5();
@@ -388,6 +425,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * putIfAbsent works when the given key is not present
      */
+    @Test
     public void testPutIfAbsent() {
         ConcurrentSkipListMap map = map5();
         map.putIfAbsent(six, "Z");
@@ -397,6 +435,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * putIfAbsent does not add the pair if the key is already present
      */
+    @Test
     public void testPutIfAbsent2() {
         ConcurrentSkipListMap map = map5();
         assertEquals("A", map.putIfAbsent(one, "Z"));
@@ -405,6 +444,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace fails when the given key is not present
      */
+    @Test
     public void testReplace() {
         ConcurrentSkipListMap map = map5();
         assertNull(map.replace(six, "Z"));
@@ -414,6 +454,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace succeeds if the key is already present
      */
+    @Test
     public void testReplace2() {
         ConcurrentSkipListMap map = map5();
         assertNotNull(map.replace(one, "Z"));
@@ -423,6 +464,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace value fails when the given key not mapped to expected value
      */
+    @Test
     public void testReplaceValue() {
         ConcurrentSkipListMap map = map5();
         assertEquals("A", map.get(one));
@@ -433,6 +475,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace value succeeds when the given key mapped to expected value
      */
+    @Test
     public void testReplaceValue2() {
         ConcurrentSkipListMap map = map5();
         assertEquals("A", map.get(one));
@@ -443,6 +486,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testRemove() {
         ConcurrentSkipListMap map = map5();
         map.remove(five);
@@ -453,6 +497,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * remove(key,value) removes only if pair present
      */
+    @Test
     public void testRemove2() {
         ConcurrentSkipListMap map = map5();
         assertTrue(map.containsKey(five));
@@ -468,6 +513,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testLowerEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e1 = map.lowerEntry(three);
@@ -486,6 +532,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testHigherEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e1 = map.higherEntry(three);
@@ -504,6 +551,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testFloorEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e1 = map.floorEntry(three);
@@ -522,6 +570,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testCeilingEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e1 = map.ceilingEntry(three);
@@ -541,6 +590,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
      * lowerEntry, higherEntry, ceilingEntry, and floorEntry return
      * immutable entries
      */
+    @Test
     public void testEntryImmutability() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e = map.lowerEntry(three);
@@ -572,6 +622,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * lowerKey returns preceding element
      */
+    @Test
     public void testLowerKey() {
         ConcurrentSkipListMap q = map5();
         Object e1 = q.lowerKey(three);
@@ -590,6 +641,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * higherKey returns next element
      */
+    @Test
     public void testHigherKey() {
         ConcurrentSkipListMap q = map5();
         Object e1 = q.higherKey(three);
@@ -608,6 +660,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * floorKey returns preceding element
      */
+    @Test
     public void testFloorKey() {
         ConcurrentSkipListMap q = map5();
         Object e1 = q.floorKey(three);
@@ -626,6 +679,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * ceilingKey returns next element
      */
+    @Test
     public void testCeilingKey() {
         ConcurrentSkipListMap q = map5();
         Object e1 = q.ceilingKey(three);
@@ -644,6 +698,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testPollFirstEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e = map.pollFirstEntry();
@@ -671,6 +726,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testPollLastEntry() {
         ConcurrentSkipListMap map = map5();
         Map.Entry e = map.pollLastEntry();
@@ -698,6 +754,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testSize() {
         ConcurrentSkipListMap map = map5();
         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
@@ -708,6 +765,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         ConcurrentSkipListMap map = map5();
         String s = map.toString();
@@ -721,6 +779,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * get(null) of nonempty map throws NPE
      */
+    @Test
     public void testGet_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -732,6 +791,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * containsKey(null) of nonempty map throws NPE
      */
+    @Test
     public void testContainsKey_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -743,6 +803,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * containsValue(null) throws NPE
      */
+    @Test
     public void testContainsValue_NullPointerException() {
         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
         try {
@@ -754,6 +815,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testPut1_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -765,6 +827,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * putIfAbsent(null, x) throws NPE
      */
+    @Test
     public void testPutIfAbsent1_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -776,6 +839,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace(null, x) throws NPE
      */
+    @Test
     public void testReplace_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -787,6 +851,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * replace(null, x, y) throws NPE
      */
+    @Test
     public void testReplaceValue_NullPointerException() {
         ConcurrentSkipListMap c = map5();
         try {
@@ -798,6 +863,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE
      */
+    @Test
     public void testRemove1_NullPointerException() {
         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
         c.put("sadsdf", "asdads");
@@ -810,6 +876,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * remove(null, x) throws NPE
      */
+    @Test
     public void testRemove2_NullPointerException() {
         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
         c.put("sadsdf", "asdads");
@@ -822,6 +889,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * remove(x, null) returns false
      */
+    @Test
     public void testRemove3() {
         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
         c.put("sadsdf", "asdads");
@@ -831,6 +899,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableMap x = map5();
         NavigableMap y = serialClone(x);
@@ -845,6 +914,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testSubMapContents() {
         ConcurrentSkipListMap map = map5();
         NavigableMap sm = map.subMap(two, true, four, false);
@@ -883,6 +953,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testSubMapContents2() {
         ConcurrentSkipListMap map = map5();
         NavigableMap sm = map.subMap(two, true, three, false);
@@ -918,6 +989,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testHeadMapContents() {
         ConcurrentSkipListMap map = map5();
         NavigableMap sm = map.headMap(four, false);
@@ -944,6 +1016,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * tailMap returns map with keys in requested range
      */
+    @Test
     public void testTailMapContents() {
         ConcurrentSkipListMap map = map5();
         NavigableMap sm = map.tailMap(two, true);
@@ -1005,6 +1078,7 @@ public class ConcurrentSkipListMapTest extends JSR166TestCase {
     /**
      * Submaps of submaps subdivide correctly
      */
+    @Test
     public void testRecursiveSubMaps() throws Exception {
         int mapSize = expensiveTests ? 1000 : 100;
         Class cl = ConcurrentSkipListMap.class;
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSetTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSetTest.java
index d27c10f6813..992ee5038af 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSetTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSetTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Collection;
@@ -44,16 +53,21 @@ import java.util.Set;
 import java.util.SortedSet;
 import java.util.concurrent.ConcurrentSkipListSet;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentSkipListSetTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentSkipListSetTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentSkipListSetTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentSkipListSetTest.class);
+    // }
 
     static class MyReverseComparator implements Comparator {
         public int compare(Object x, Object y) {
@@ -96,6 +110,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * A new set has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new ConcurrentSkipListSet().size());
     }
@@ -103,6 +118,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new ConcurrentSkipListSet((Collection)null);
@@ -113,6 +129,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new ConcurrentSkipListSet(Arrays.asList(new Integer[SIZE]));
@@ -123,6 +140,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -136,6 +154,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -148,6 +167,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * The comparator used in constructor is used
      */
+    @Test
     public void testConstructor7() {
         MyReverseComparator cmp = new MyReverseComparator();
         ConcurrentSkipListSet q = new ConcurrentSkipListSet(cmp);
@@ -163,6 +183,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         assertTrue(q.isEmpty());
@@ -177,6 +198,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -192,6 +214,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         try {
@@ -203,6 +226,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testAdd() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         assertTrue(q.add(zero));
@@ -212,6 +236,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testAddDup() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         assertTrue(q.add(zero));
@@ -221,6 +246,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testAddNonComparable() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         try {
@@ -240,6 +266,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         try {
@@ -251,6 +278,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         Integer[] ints = new Integer[SIZE];
@@ -264,6 +292,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         Integer[] ints = new Integer[SIZE];
@@ -278,6 +307,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -293,6 +323,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * pollFirst succeeds unless empty
      */
+    @Test
     public void testPollFirst() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -304,6 +335,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * pollLast succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -315,6 +347,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -336,6 +369,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -348,6 +382,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         q.clear();
@@ -362,6 +397,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         ConcurrentSkipListSet p = new ConcurrentSkipListSet();
@@ -376,6 +412,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         ConcurrentSkipListSet p = populatedSet(SIZE);
@@ -395,6 +432,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             ConcurrentSkipListSet q = populatedSet(SIZE);
@@ -411,6 +449,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testLower() {
         ConcurrentSkipListSet q = set5();
         Object e1 = q.lower(three);
@@ -429,6 +468,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testHigher() {
         ConcurrentSkipListSet q = set5();
         Object e1 = q.higher(three);
@@ -447,6 +487,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testFloor() {
         ConcurrentSkipListSet q = set5();
         Object e1 = q.floor(three);
@@ -465,6 +506,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testCeiling() {
         ConcurrentSkipListSet q = set5();
         Object e1 = q.ceiling(three);
@@ -483,6 +525,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements in sorted order
      */
+    @Test
     public void testToArray() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -493,6 +536,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in sorted order
      */
+    @Test
     public void testToArray2() {
         ConcurrentSkipListSet<Integer> q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -504,6 +548,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         Iterator it = q.iterator();
@@ -517,6 +562,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testEmptyIterator() {
         NavigableSet s = new ConcurrentSkipListSet();
         assertIteratorExhausted(s.iterator());
@@ -526,6 +572,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final ConcurrentSkipListSet q = new ConcurrentSkipListSet();
         q.add(new Integer(2));
@@ -545,6 +592,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         ConcurrentSkipListSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -556,6 +604,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableSet x = populatedSet(SIZE);
         NavigableSet y = serialClone(x);
@@ -574,6 +623,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testSubSetContents() {
         ConcurrentSkipListSet set = set5();
         SortedSet sm = set.subSet(two, four);
@@ -605,6 +655,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testSubSetContents2() {
         ConcurrentSkipListSet set = set5();
         SortedSet sm = set.subSet(two, three);
@@ -635,6 +686,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testHeadSetContents() {
         ConcurrentSkipListSet set = set5();
         SortedSet sm = set.headSet(four);
@@ -661,6 +713,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testTailSetContents() {
         ConcurrentSkipListSet set = set5();
         SortedSet sm = set.tailSet(two);
@@ -695,6 +748,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * Subsets of subsets subdivide correctly
      */
+    @Test
     public void testRecursiveSubSets() throws Exception {
         int setSize = expensiveTests ? 1000 : 100;
         Class cl = ConcurrentSkipListSet.class;
@@ -717,6 +771,7 @@ public class ConcurrentSkipListSetTest extends JSR166TestCase {
     /**
      * addAll is idempotent
      */
+    @Test
     public void testAddAll_idempotent() throws Exception {
         Set x = populatedSet(SIZE);
         Set y = new ConcurrentSkipListSet(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubMapTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubMapTest.java
index d48b9f97bd5..d9421a536a9 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubMapTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubMapTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -43,16 +52,21 @@ import java.util.SortedMap;
 import java.util.concurrent.ConcurrentNavigableMap;
 import java.util.concurrent.ConcurrentSkipListMap;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentSkipListSubMapTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentSkipListSubMapTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentSkipListSubMapTest.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -103,6 +117,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testClear() {
         ConcurrentNavigableMap map = map5();
         map.clear();
@@ -112,6 +127,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testEquals() {
         ConcurrentNavigableMap map1 = map5();
         ConcurrentNavigableMap map2 = map5();
@@ -125,6 +141,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testContainsKey() {
         ConcurrentNavigableMap map = map5();
         assertTrue(map.containsKey(one));
@@ -134,6 +151,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testContainsValue() {
         ConcurrentNavigableMap map = map5();
         assertTrue(map.containsValue("A"));
@@ -144,6 +162,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testGet() {
         ConcurrentNavigableMap map = map5();
         assertEquals("A", (String)map.get(one));
@@ -154,6 +173,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testIsEmpty() {
         ConcurrentNavigableMap empty = map0();
         ConcurrentNavigableMap map = map5();
@@ -164,6 +184,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testFirstKey() {
         ConcurrentNavigableMap map = map5();
         assertEquals(one, map.firstKey());
@@ -172,6 +193,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testLastKey() {
         ConcurrentNavigableMap map = map5();
         assertEquals(five, map.lastKey());
@@ -180,6 +202,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testKeySet() {
         ConcurrentNavigableMap map = map5();
         Set s = map.keySet();
@@ -194,6 +217,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testKeySetOrder() {
         ConcurrentNavigableMap map = map5();
         Set s = map.keySet();
@@ -210,6 +234,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testValues() {
         ConcurrentNavigableMap map = map5();
         Collection s = map.values();
@@ -224,6 +249,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testKeySetToArray() {
         ConcurrentNavigableMap map = map5();
         Set s = map.keySet();
@@ -237,6 +263,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * descendingkeySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingKeySetToArray() {
         ConcurrentNavigableMap map = map5();
         Set s = map.descendingKeySet();
@@ -250,6 +277,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * Values.toArray contains all values
      */
+    @Test
     public void testValuesToArray() {
         ConcurrentNavigableMap map = map5();
         Collection v = map.values();
@@ -266,6 +294,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testEntrySet() {
         ConcurrentNavigableMap map = map5();
         Set s = map.entrySet();
@@ -285,6 +314,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testPutAll() {
         ConcurrentNavigableMap empty = map0();
         ConcurrentNavigableMap map = map5();
@@ -300,6 +330,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent works when the given key is not present
      */
+    @Test
     public void testPutIfAbsent() {
         ConcurrentNavigableMap map = map5();
         map.putIfAbsent(six, "Z");
@@ -309,6 +340,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent does not add the pair if the key is already present
      */
+    @Test
     public void testPutIfAbsent2() {
         ConcurrentNavigableMap map = map5();
         assertEquals("A", map.putIfAbsent(one, "Z"));
@@ -317,6 +349,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace fails when the given key is not present
      */
+    @Test
     public void testReplace() {
         ConcurrentNavigableMap map = map5();
         assertNull(map.replace(six, "Z"));
@@ -326,6 +359,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace succeeds if the key is already present
      */
+    @Test
     public void testReplace2() {
         ConcurrentNavigableMap map = map5();
         assertNotNull(map.replace(one, "Z"));
@@ -335,6 +369,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace value fails when the given key not mapped to expected value
      */
+    @Test
     public void testReplaceValue() {
         ConcurrentNavigableMap map = map5();
         assertEquals("A", map.get(one));
@@ -345,6 +380,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace value succeeds when the given key mapped to expected value
      */
+    @Test
     public void testReplaceValue2() {
         ConcurrentNavigableMap map = map5();
         assertEquals("A", map.get(one));
@@ -355,6 +391,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testRemove() {
         ConcurrentNavigableMap map = map5();
         map.remove(five);
@@ -365,6 +402,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(key,value) removes only if pair present
      */
+    @Test
     public void testRemove2() {
         ConcurrentNavigableMap map = map5();
         assertTrue(map.containsKey(five));
@@ -380,6 +418,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testLowerEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e1 = map.lowerEntry(three);
@@ -398,6 +437,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testHigherEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e1 = map.higherEntry(three);
@@ -416,6 +456,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testFloorEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e1 = map.floorEntry(three);
@@ -434,6 +475,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testCeilingEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e1 = map.ceilingEntry(three);
@@ -452,6 +494,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testPollFirstEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e = map.pollFirstEntry();
@@ -479,6 +522,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testPollLastEntry() {
         ConcurrentNavigableMap map = map5();
         Map.Entry e = map.pollLastEntry();
@@ -506,6 +550,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testSize() {
         ConcurrentNavigableMap map = map5();
         ConcurrentNavigableMap empty = map0();
@@ -516,6 +561,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         ConcurrentNavigableMap map = map5();
         String s = map.toString();
@@ -529,6 +575,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * get(null) of nonempty map throws NPE
      */
+    @Test
     public void testGet_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -540,6 +587,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsKey(null) of nonempty map throws NPE
      */
+    @Test
     public void testContainsKey_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -551,6 +599,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsValue(null) throws NPE
      */
+    @Test
     public void testContainsValue_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map0();
@@ -562,6 +611,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testPut1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -573,6 +623,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent(null, x) throws NPE
      */
+    @Test
     public void testPutIfAbsent1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -584,6 +635,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace(null, x) throws NPE
      */
+    @Test
     public void testReplace_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -595,6 +647,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace(null, x, y) throws NPE
      */
+    @Test
     public void testReplaceValue_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -606,6 +659,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE
      */
+    @Test
     public void testRemove1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -617,6 +671,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(null, x) throws NPE
      */
+    @Test
     public void testRemove2_NullPointerException() {
         try {
             ConcurrentNavigableMap c = map5();
@@ -628,6 +683,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableMap x = map5();
         NavigableMap y = serialClone(x);
@@ -642,6 +698,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testSubMapContents() {
         ConcurrentNavigableMap map = map5();
         SortedMap sm = map.subMap(two, four);
@@ -673,6 +730,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testSubMapContents2() {
         ConcurrentNavigableMap map = map5();
         SortedMap sm = map.subMap(two, three);
@@ -703,6 +761,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testHeadMapContents() {
         ConcurrentNavigableMap map = map5();
         SortedMap sm = map.headMap(four);
@@ -729,6 +788,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testTailMapContents() {
         ConcurrentNavigableMap map = map5();
         SortedMap sm = map.tailMap(two);
@@ -777,6 +837,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testDescendingClear() {
         ConcurrentNavigableMap map = dmap5();
         map.clear();
@@ -786,6 +847,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testDescendingEquals() {
         ConcurrentNavigableMap map1 = dmap5();
         ConcurrentNavigableMap map2 = dmap5();
@@ -799,6 +861,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testDescendingContainsKey() {
         ConcurrentNavigableMap map = dmap5();
         assertTrue(map.containsKey(m1));
@@ -808,6 +871,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testDescendingContainsValue() {
         ConcurrentNavigableMap map = dmap5();
         assertTrue(map.containsValue("A"));
@@ -818,6 +882,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testDescendingGet() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals("A", (String)map.get(m1));
@@ -828,6 +893,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testDescendingIsEmpty() {
         ConcurrentNavigableMap empty = dmap0();
         ConcurrentNavigableMap map = dmap5();
@@ -838,6 +904,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testDescendingFirstKey() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals(m1, map.firstKey());
@@ -846,6 +913,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testDescendingLastKey() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals(m5, map.lastKey());
@@ -854,6 +922,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testDescendingKeySet() {
         ConcurrentNavigableMap map = dmap5();
         Set s = map.keySet();
@@ -868,6 +937,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testDescendingKeySetOrder() {
         ConcurrentNavigableMap map = dmap5();
         Set s = map.keySet();
@@ -884,6 +954,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testDescendingValues() {
         ConcurrentNavigableMap map = dmap5();
         Collection s = map.values();
@@ -898,6 +969,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingAscendingKeySetToArray() {
         ConcurrentNavigableMap map = dmap5();
         Set s = map.keySet();
@@ -911,6 +983,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * descendingkeySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingDescendingKeySetToArray() {
         ConcurrentNavigableMap map = dmap5();
         Set s = map.descendingKeySet();
@@ -924,6 +997,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * Values.toArray contains all values
      */
+    @Test
     public void testDescendingValuesToArray() {
         ConcurrentNavigableMap map = dmap5();
         Collection v = map.values();
@@ -940,6 +1014,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testDescendingEntrySet() {
         ConcurrentNavigableMap map = dmap5();
         Set s = map.entrySet();
@@ -959,6 +1034,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testDescendingPutAll() {
         ConcurrentNavigableMap empty = dmap0();
         ConcurrentNavigableMap map = dmap5();
@@ -974,6 +1050,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent works when the given key is not present
      */
+    @Test
     public void testDescendingPutIfAbsent() {
         ConcurrentNavigableMap map = dmap5();
         map.putIfAbsent(six, "Z");
@@ -983,6 +1060,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent does not add the pair if the key is already present
      */
+    @Test
     public void testDescendingPutIfAbsent2() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals("A", map.putIfAbsent(m1, "Z"));
@@ -991,6 +1069,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace fails when the given key is not present
      */
+    @Test
     public void testDescendingReplace() {
         ConcurrentNavigableMap map = dmap5();
         assertNull(map.replace(six, "Z"));
@@ -1000,6 +1079,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace succeeds if the key is already present
      */
+    @Test
     public void testDescendingReplace2() {
         ConcurrentNavigableMap map = dmap5();
         assertNotNull(map.replace(m1, "Z"));
@@ -1009,6 +1089,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace value fails when the given key not mapped to expected value
      */
+    @Test
     public void testDescendingReplaceValue() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals("A", map.get(m1));
@@ -1019,6 +1100,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace value succeeds when the given key mapped to expected value
      */
+    @Test
     public void testDescendingReplaceValue2() {
         ConcurrentNavigableMap map = dmap5();
         assertEquals("A", map.get(m1));
@@ -1029,6 +1111,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testDescendingRemove() {
         ConcurrentNavigableMap map = dmap5();
         map.remove(m5);
@@ -1039,6 +1122,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(key,value) removes only if pair present
      */
+    @Test
     public void testDescendingRemove2() {
         ConcurrentNavigableMap map = dmap5();
         assertTrue(map.containsKey(m5));
@@ -1054,6 +1138,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testDescendingLowerEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e1 = map.lowerEntry(m3);
@@ -1072,6 +1157,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testDescendingHigherEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e1 = map.higherEntry(m3);
@@ -1090,6 +1176,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testDescendingFloorEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e1 = map.floorEntry(m3);
@@ -1108,6 +1195,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testDescendingCeilingEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e1 = map.ceilingEntry(m3);
@@ -1126,6 +1214,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testDescendingPollFirstEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e = map.pollFirstEntry();
@@ -1153,6 +1242,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testDescendingPollLastEntry() {
         ConcurrentNavigableMap map = dmap5();
         Map.Entry e = map.pollLastEntry();
@@ -1180,6 +1270,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testDescendingSize() {
         ConcurrentNavigableMap map = dmap5();
         ConcurrentNavigableMap empty = dmap0();
@@ -1190,6 +1281,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testDescendingToString() {
         ConcurrentNavigableMap map = dmap5();
         String s = map.toString();
@@ -1203,6 +1295,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * get(null) of empty map throws NPE
      */
+    @Test
     public void testDescendingGet_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1214,6 +1307,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsKey(null) of empty map throws NPE
      */
+    @Test
     public void testDescendingContainsKey_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1225,6 +1319,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * containsValue(null) throws NPE
      */
+    @Test
     public void testDescendingContainsValue_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap0();
@@ -1236,6 +1331,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testDescendingPut1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1247,6 +1343,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * putIfAbsent(null, x) throws NPE
      */
+    @Test
     public void testDescendingPutIfAbsent1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1258,6 +1355,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace(null, x) throws NPE
      */
+    @Test
     public void testDescendingReplace_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1269,6 +1367,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * replace(null, x, y) throws NPE
      */
+    @Test
     public void testDescendingReplaceValue_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1280,6 +1379,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE
      */
+    @Test
     public void testDescendingRemove1_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1291,6 +1391,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * remove(null, x) throws NPE
      */
+    @Test
     public void testDescendingRemove2_NullPointerException() {
         try {
             ConcurrentNavigableMap c = dmap5();
@@ -1302,6 +1403,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testDescendingSerialization() throws Exception {
         NavigableMap x = dmap5();
         NavigableMap y = serialClone(x);
@@ -1316,6 +1418,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingSubMapContents() {
         ConcurrentNavigableMap map = dmap5();
         SortedMap sm = map.subMap(m2, m4);
@@ -1347,6 +1450,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testDescendingSubMapContents2() {
         ConcurrentNavigableMap map = dmap5();
         SortedMap sm = map.subMap(m2, m3);
@@ -1377,6 +1481,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingHeadMapContents() {
         ConcurrentNavigableMap map = dmap5();
         SortedMap sm = map.headMap(m4);
@@ -1403,6 +1508,7 @@ public class ConcurrentSkipListSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingTailMapContents() {
         ConcurrentNavigableMap map = dmap5();
         SortedMap sm = map.tailMap(m2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubSetTest.java b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubSetTest.java
index 042fc628d98..806adc95761 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubSetTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ConcurrentSkipListSubSetTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -39,16 +48,21 @@ import java.util.NavigableSet;
 import java.util.SortedSet;
 import java.util.concurrent.ConcurrentSkipListSet;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ConcurrentSkipListSubSetTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ConcurrentSkipListSubSetTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ConcurrentSkipListSubSetTest.class);
+    // }
 
     static class MyReverseComparator implements Comparator {
         public int compare(Object x, Object y) {
@@ -126,6 +140,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * A new set has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, set0().size());
     }
@@ -133,6 +148,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         NavigableSet q = set0();
         assertTrue(q.isEmpty());
@@ -147,6 +163,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -162,6 +179,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         NavigableSet q = set0();
         try {
@@ -173,6 +191,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testAdd() {
         NavigableSet q = set0();
         assertTrue(q.add(six));
@@ -181,6 +200,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testAddDup() {
         NavigableSet q = set0();
         assertTrue(q.add(six));
@@ -190,6 +210,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testAddNonComparable() {
         NavigableSet q = set0();
         try {
@@ -202,6 +223,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         NavigableSet q = set0();
         try {
@@ -213,6 +235,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         NavigableSet q = set0();
         Integer[] ints = new Integer[SIZE];
@@ -226,6 +249,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         NavigableSet q = set0();
         Integer[] ints = new Integer[SIZE];
@@ -240,6 +264,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -255,6 +280,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -266,6 +292,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -287,6 +314,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -299,6 +327,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         NavigableSet q = populatedSet(SIZE);
         q.clear();
@@ -313,6 +342,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = set0();
@@ -327,6 +357,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = populatedSet(SIZE);
@@ -346,6 +377,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             NavigableSet q = populatedSet(SIZE);
@@ -362,6 +394,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testLower() {
         NavigableSet q = set5();
         Object e1 = q.lower(three);
@@ -380,6 +413,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testHigher() {
         NavigableSet q = set5();
         Object e1 = q.higher(three);
@@ -398,6 +432,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testFloor() {
         NavigableSet q = set5();
         Object e1 = q.floor(three);
@@ -416,6 +451,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testCeiling() {
         NavigableSet q = set5();
         Object e1 = q.ceiling(three);
@@ -434,6 +470,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements in sorted order
      */
+    @Test
     public void testToArray() {
         NavigableSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -444,6 +481,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in sorted order
      */
+    @Test
     public void testToArray2() {
         NavigableSet<Integer> q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -456,6 +494,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         NavigableSet q = populatedSet(SIZE);
         Iterator it = q.iterator();
@@ -469,6 +508,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(set0().iterator());
     }
@@ -476,6 +516,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final NavigableSet q = set0();
         q.add(new Integer(2));
@@ -495,6 +536,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         NavigableSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -506,6 +548,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableSet x = populatedSet(SIZE);
         NavigableSet y = serialClone(x);
@@ -524,6 +567,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testSubSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.subSet(two, four);
@@ -555,6 +599,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testSubSetContents2() {
         NavigableSet set = set5();
         SortedSet sm = set.subSet(two, three);
@@ -585,6 +630,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testHeadSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.headSet(four);
@@ -611,6 +657,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testTailSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.tailSet(two);
@@ -643,6 +690,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testDescendingSize() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -658,6 +706,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testDescendingAddNull() {
         NavigableSet q = dset0();
         try {
@@ -669,6 +718,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testDescendingAdd() {
         NavigableSet q = dset0();
         assertTrue(q.add(m6));
@@ -677,6 +727,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testDescendingAddDup() {
         NavigableSet q = dset0();
         assertTrue(q.add(m6));
@@ -686,6 +737,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testDescendingAddNonComparable() {
         NavigableSet q = dset0();
         try {
@@ -698,6 +750,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testDescendingAddAll1() {
         NavigableSet q = dset0();
         try {
@@ -709,6 +762,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testDescendingAddAll2() {
         NavigableSet q = dset0();
         Integer[] ints = new Integer[SIZE];
@@ -722,6 +776,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testDescendingAddAll3() {
         NavigableSet q = dset0();
         Integer[] ints = new Integer[SIZE];
@@ -736,6 +791,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testDescendingAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -751,6 +807,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testDescendingPoll() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -762,6 +819,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testDescendingRemoveElement() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -777,6 +835,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testDescendingContains() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -789,6 +848,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testDescendingClear() {
         NavigableSet q = populatedSet(SIZE);
         q.clear();
@@ -803,6 +863,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testDescendingContainsAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = dset0();
@@ -817,6 +878,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testDescendingRetainAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = populatedSet(SIZE);
@@ -836,6 +898,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testDescendingRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             NavigableSet q = populatedSet(SIZE);
@@ -852,6 +915,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testDescendingLower() {
         NavigableSet q = dset5();
         Object e1 = q.lower(m3);
@@ -870,6 +934,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testDescendingHigher() {
         NavigableSet q = dset5();
         Object e1 = q.higher(m3);
@@ -888,6 +953,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testDescendingFloor() {
         NavigableSet q = dset5();
         Object e1 = q.floor(m3);
@@ -906,6 +972,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testDescendingCeiling() {
         NavigableSet q = dset5();
         Object e1 = q.ceiling(m3);
@@ -924,6 +991,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements
      */
+    @Test
     public void testDescendingToArray() {
         NavigableSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -935,6 +1003,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements
      */
+    @Test
     public void testDescendingToArray2() {
         NavigableSet q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -947,6 +1016,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         NavigableSet q = populatedSet(SIZE);
         int i = 0;
@@ -961,6 +1031,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testDescendingEmptyIterator() {
         NavigableSet q = dset0();
         int i = 0;
@@ -975,6 +1046,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final NavigableSet q = dset0();
         q.add(new Integer(2));
@@ -994,6 +1066,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testDescendingToString() {
         NavigableSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -1005,6 +1078,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testDescendingSerialization() throws Exception {
         NavigableSet x = dset5();
         NavigableSet y = serialClone(x);
@@ -1023,6 +1097,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingSubSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.subSet(m2, m4);
@@ -1054,6 +1129,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testDescendingSubSetContents2() {
         NavigableSet set = dset5();
         SortedSet sm = set.subSet(m2, m3);
@@ -1084,6 +1160,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingHeadSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.headSet(m4);
@@ -1110,6 +1187,7 @@ public class ConcurrentSkipListSubSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingTailSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.tailSet(m2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArrayListTest.java b/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArrayListTest.java
index 70409c39391..a34f3a5221d 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArrayListTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArrayListTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -44,33 +53,37 @@ import java.util.ListIterator;
 import java.util.NoSuchElementException;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CopyOnWriteArrayListTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return CopyOnWriteArrayList.class; }
-            public List emptyCollection() { return new CopyOnWriteArrayList(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return true; }
-        }
-        class SubListImplementation extends Implementation {
-            public List emptyCollection() {
-                return super.emptyCollection().subList(0, 0);
-            }
-        }
-        return newTestSuite(
-                CopyOnWriteArrayListTest.class,
-                CollectionTest.testSuite(new Implementation()),
-                CollectionTest.testSuite(new SubListImplementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CopyOnWriteArrayListTest");
+    }
+
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return CopyOnWriteArrayList.class; }
+    //         public List emptyCollection() { return new CopyOnWriteArrayList(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return true; }
+    //     }
+    //     class SubListImplementation extends Implementation {
+    //         public List emptyCollection() {
+    //             return super.emptyCollection().subList(0, 0);
+    //         }
+    //     }
+    //     return newTestSuite(
+    //             CopyOnWriteArrayListTest.class,
+    //             CollectionTest.testSuite(new Implementation()),
+    //             CollectionTest.testSuite(new SubListImplementation()));
+    // }
 
     static CopyOnWriteArrayList<Integer> populatedArray(int n) {
         CopyOnWriteArrayList<Integer> a = new CopyOnWriteArrayList<>();
@@ -95,6 +108,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * a new list is empty
      */
+    @Test
     public void testConstructor() {
         CopyOnWriteArrayList a = new CopyOnWriteArrayList();
         assertTrue(a.isEmpty());
@@ -103,6 +117,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * new list contains all elements of initializing array
      */
+    @Test
     public void testConstructor2() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -115,6 +130,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * new list contains all elements of initializing collection
      */
+    @Test
     public void testConstructor3() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -127,6 +143,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * addAll adds each element from the given collection, including duplicates
      */
+    @Test
     public void testAddAll() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertTrue(full.addAll(Arrays.asList(three, four, five)));
@@ -139,6 +156,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * addAllAbsent adds each element from the given collection that did not
      * already exist in the List
      */
+    @Test
     public void testAddAllAbsent() {
         CopyOnWriteArrayList full = populatedArray(3);
         // "one" is duplicate and will not be added
@@ -151,6 +169,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * addIfAbsent will not add the element if it already exists in the list
      */
+    @Test
     public void testAddIfAbsent() {
         CopyOnWriteArrayList full = populatedArray(SIZE);
         full.addIfAbsent(one);
@@ -160,6 +179,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * addIfAbsent adds the element when it does not exist in the list
      */
+    @Test
     public void testAddIfAbsent2() {
         CopyOnWriteArrayList full = populatedArray(SIZE);
         full.addIfAbsent(three);
@@ -169,6 +189,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * clear removes all elements from the list
      */
+    @Test
     public void testClear() {
         CopyOnWriteArrayList full = populatedArray(SIZE);
         full.clear();
@@ -178,6 +199,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * Cloned list is equal
      */
+    @Test
     public void testClone() {
         CopyOnWriteArrayList l1 = populatedArray(SIZE);
         CopyOnWriteArrayList l2 = (CopyOnWriteArrayList)(l1.clone());
@@ -189,6 +211,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * contains is true for added elements
      */
+    @Test
     public void testContains() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertTrue(full.contains(one));
@@ -198,6 +221,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * adding at an index places it in the indicated index
      */
+    @Test
     public void testAddIndex() {
         CopyOnWriteArrayList full = populatedArray(3);
         full.add(0, m1);
@@ -214,6 +238,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * lists with same elements are equal and have same hashCode
      */
+    @Test
     public void testEquals() {
         CopyOnWriteArrayList a = populatedArray(3);
         CopyOnWriteArrayList b = populatedArray(3);
@@ -240,6 +265,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * containsAll returns true for collections with subset of elements
      */
+    @Test
     public void testContainsAll() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertTrue(full.containsAll(Arrays.asList()));
@@ -257,6 +283,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * get returns the value at the given index
      */
+    @Test
     public void testGet() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertEquals(0, full.get(0));
@@ -265,6 +292,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * indexOf gives the index for the given object
      */
+    @Test
     public void testIndexOf() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertEquals(1, full.indexOf(one));
@@ -275,6 +303,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * indexOf gives the index based on the given index
      * at which to start searching
      */
+    @Test
     public void testIndexOf2() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertEquals(1, full.indexOf(one, 0));
@@ -284,6 +313,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * isEmpty returns true when empty, else false
      */
+    @Test
     public void testIsEmpty() {
         CopyOnWriteArrayList empty = new CopyOnWriteArrayList();
         CopyOnWriteArrayList full = populatedArray(SIZE);
@@ -295,6 +325,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * iterator() returns an iterator containing the elements of the
      * list in insertion order
      */
+    @Test
     public void testIterator() {
         Collection empty = new CopyOnWriteArrayList();
         assertFalse(empty.iterator().hasNext());
@@ -320,6 +351,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         Collection c = new CopyOnWriteArrayList();
         assertIteratorExhausted(c.iterator());
@@ -328,6 +360,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * iterator.remove throws UnsupportedOperationException
      */
+    @Test
     public void testIteratorRemove() {
         CopyOnWriteArrayList full = populatedArray(SIZE);
         Iterator it = full.iterator();
@@ -341,6 +374,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         assertEquals("[]", new CopyOnWriteArrayList().toString());
         CopyOnWriteArrayList full = populatedArray(3);
@@ -354,6 +388,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * lastIndexOf returns the index for the given object
      */
+    @Test
     public void testLastIndexOf1() {
         CopyOnWriteArrayList full = populatedArray(3);
         full.add(one);
@@ -365,6 +400,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * lastIndexOf returns the index from the given starting point
      */
+    @Test
     public void testLastIndexOf2() {
         CopyOnWriteArrayList full = populatedArray(3);
         full.add(one);
@@ -376,6 +412,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * listIterator traverses all elements
      */
+    @Test
     public void testListIterator1() {
         CopyOnWriteArrayList full = populatedArray(SIZE);
         ListIterator i = full.listIterator();
@@ -388,6 +425,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * listIterator only returns those elements after the given index
      */
+    @Test
     public void testListIterator2() {
         CopyOnWriteArrayList full = populatedArray(3);
         ListIterator i = full.listIterator(1);
@@ -400,6 +438,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * remove(int) removes and returns the object at the given index
      */
+    @Test
     public void testRemove_int() {
         int SIZE = 3;
         for (int i = 0; i < SIZE; i++) {
@@ -413,6 +452,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * remove(Object) removes the object if found and returns true
      */
+    @Test
     public void testRemove_Object() {
         int SIZE = 3;
         for (int i = 0; i < SIZE; i++) {
@@ -435,6 +475,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * removeAll removes all elements from the given collection
      */
+    @Test
     public void testRemoveAll() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertTrue(full.removeAll(Arrays.asList(one, two)));
@@ -446,6 +487,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * set changes the element at the given index
      */
+    @Test
     public void testSet() {
         CopyOnWriteArrayList full = populatedArray(3);
         assertEquals(2, full.set(2, four));
@@ -455,6 +497,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * size returns the number of elements
      */
+    @Test
     public void testSize() {
         CopyOnWriteArrayList empty = new CopyOnWriteArrayList();
         CopyOnWriteArrayList full = populatedArray(SIZE);
@@ -466,6 +509,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * toArray() returns an Object array containing all elements from
      * the list in insertion order
      */
+    @Test
     public void testToArray() {
         Object[] a = new CopyOnWriteArrayList().toArray();
         assertTrue(Arrays.equals(new Object[0], a));
@@ -485,6 +529,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * toArray(Integer array) returns an Integer array containing all
      * elements from the list in insertion order
      */
+    @Test
     public void testToArray2() {
         Collection empty = new CopyOnWriteArrayList();
         Integer[] a;
@@ -528,6 +573,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * sublists contains elements at indexes offset from their base
      */
+    @Test
     public void testSubList() {
         CopyOnWriteArrayList a = populatedArray(10);
         assertTrue(a.subList(1,1).isEmpty());
@@ -554,6 +600,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * toArray throws an ArrayStoreException when the given array
      * can not store the objects inside the list
      */
+    @Test
     public void testToArray_ArrayStoreException() {
         CopyOnWriteArrayList c = new CopyOnWriteArrayList();
         c.add("zfasdfsdf");
@@ -567,6 +614,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * get throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testGet1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -581,6 +629,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * get throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testGet2_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -595,6 +644,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * set throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testSet1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -609,6 +659,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * set throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testSet2() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -623,6 +674,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * add throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testAdd1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -637,6 +689,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * add throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testAdd2_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -651,6 +704,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * remove throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testRemove1_IndexOutOfBounds() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -665,6 +719,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * remove throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testRemove2_IndexOutOfBounds() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -679,6 +734,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * addAll throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testAddAll1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -693,6 +749,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * addAll throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testAddAll2_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -707,6 +764,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * listIterator throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testListIterator1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -721,6 +779,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * listIterator throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testListIterator2_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -735,6 +794,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * subList throws an IndexOutOfBoundsException on a negative index
      */
+    @Test
     public void testSubList1_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -749,6 +809,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * subList throws an IndexOutOfBoundsException on a too high index
      */
+    @Test
     public void testSubList2_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -764,6 +825,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
      * subList throws IndexOutOfBoundsException when the second index
      * is lower then the first
      */
+    @Test
     public void testSubList3_IndexOutOfBoundsException() {
         CopyOnWriteArrayList c = populatedArray(5);
         List[] lists = { c, c.subList(1, c.size() - 1) };
@@ -778,6 +840,7 @@ public class CopyOnWriteArrayListTest extends JSR166TestCase {
     /**
      * a deserialized serialized list is equal
      */
+    @Test
     public void testSerialization() throws Exception {
         List x = populatedArray(SIZE);
         List y = serialClone(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArraySetTest.java b/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArraySetTest.java
index d7fea369a10..1e66abbe5eb 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArraySetTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CopyOnWriteArraySetTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -42,16 +51,21 @@ import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CopyOnWriteArraySetTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(CopyOnWriteArraySetTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CopyOnWriteArraySetTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(CopyOnWriteArraySetTest.class);
+    // }
 
     static CopyOnWriteArraySet<Integer> populatedSet(int n) {
         CopyOnWriteArraySet<Integer> a = new CopyOnWriteArraySet<>();
@@ -76,6 +90,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * Default-constructed set is empty
      */
+    @Test
     public void testConstructor() {
         CopyOnWriteArraySet a = new CopyOnWriteArraySet();
         assertTrue(a.isEmpty());
@@ -84,6 +99,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * Collection-constructed set holds all of its elements
      */
+    @Test
     public void testConstructor3() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -96,6 +112,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * addAll adds each non-duplicate element from the given collection
      */
+    @Test
     public void testAddAll() {
         Set full = populatedSet(3);
         assertTrue(full.addAll(Arrays.asList(three, four, five)));
@@ -107,6 +124,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * addAll adds each non-duplicate element from the given collection
      */
+    @Test
     public void testAddAll2() {
         Set full = populatedSet(3);
         // "one" is duplicate and will not be added
@@ -119,6 +137,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * add will not add the element if it already exists in the set
      */
+    @Test
     public void testAdd2() {
         Set full = populatedSet(3);
         full.add(one);
@@ -128,6 +147,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * add adds the element when it does not exist in the set
      */
+    @Test
     public void testAdd3() {
         Set full = populatedSet(3);
         full.add(three);
@@ -137,6 +157,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * clear removes all elements from the set
      */
+    @Test
     public void testClear() {
         Collection full = populatedSet(3);
         full.clear();
@@ -147,6 +168,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * contains returns true for added elements
      */
+    @Test
     public void testContains() {
         Collection full = populatedSet(3);
         assertTrue(full.contains(one));
@@ -156,6 +178,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * Sets with equal elements are equal
      */
+    @Test
     public void testEquals() {
         CopyOnWriteArraySet a = populatedSet(3);
         CopyOnWriteArraySet b = populatedSet(3);
@@ -206,6 +229,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * containsAll returns true for collections with subset of elements
      */
+    @Test
     public void testContainsAll() {
         Collection full = populatedSet(3);
         assertTrue(full.containsAll(full));
@@ -231,6 +255,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * isEmpty is true when empty, else false
      */
+    @Test
     public void testIsEmpty() {
         assertTrue(populatedSet(0).isEmpty());
         assertFalse(populatedSet(3).isEmpty());
@@ -240,6 +265,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
      * iterator() returns an iterator containing the elements of the
      * set in insertion order
      */
+    @Test
     public void testIterator() {
         Collection empty = new CopyOnWriteArraySet();
         assertFalse(empty.iterator().hasNext());
@@ -265,6 +291,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new CopyOnWriteArraySet().iterator());
     }
@@ -272,6 +299,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * iterator remove is unsupported
      */
+    @Test
     public void testIteratorRemove() {
         Collection full = populatedSet(3);
         Iterator it = full.iterator();
@@ -285,6 +313,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * toString holds toString of elements
      */
+    @Test
     public void testToString() {
         assertEquals("[]", new CopyOnWriteArraySet().toString());
         Collection full = populatedSet(3);
@@ -298,6 +327,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * removeAll removes all elements from the given collection
      */
+    @Test
     public void testRemoveAll() {
         Set full = populatedSet(3);
         assertTrue(full.removeAll(Arrays.asList(one, two)));
@@ -309,6 +339,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * remove removes an element
      */
+    @Test
     public void testRemove() {
         Collection full = populatedSet(3);
         full.remove(one);
@@ -319,6 +350,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * size returns the number of elements
      */
+    @Test
     public void testSize() {
         Collection empty = new CopyOnWriteArraySet();
         Collection full = populatedSet(3);
@@ -330,6 +362,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
      * toArray() returns an Object array containing all elements from
      * the set in insertion order
      */
+    @Test
     public void testToArray() {
         Object[] a = new CopyOnWriteArraySet().toArray();
         assertTrue(Arrays.equals(new Object[0], a));
@@ -349,6 +382,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
      * toArray(Integer array) returns an Integer array containing all
      * elements from the set in insertion order
      */
+    @Test
     public void testToArray2() {
         Collection empty = new CopyOnWriteArraySet();
         Integer[] a;
@@ -393,6 +427,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
      * toArray throws an ArrayStoreException when the given array can
      * not store the objects inside the set
      */
+    @Test
     public void testToArray_ArrayStoreException() {
         CopyOnWriteArraySet c = new CopyOnWriteArraySet();
         c.add("zfasdfsdf");
@@ -406,6 +441,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set is equal
      */
+    @Test
     public void testSerialization() throws Exception {
         Set x = populatedSet(SIZE);
         Set y = serialClone(x);
@@ -421,6 +457,7 @@ public class CopyOnWriteArraySetTest extends JSR166TestCase {
     /**
      * addAll is idempotent
      */
+    @Test
     public void testAddAll_idempotent() throws Exception {
         Set x = populatedSet(SIZE);
         Set y = new CopyOnWriteArraySet(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/CountDownLatchTest.java b/ojluni/src/test/java/util/concurrent/tck/CountDownLatchTest.java
index e9ab578bec1..6a98c088093 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CountDownLatchTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CountDownLatchTest.java
@@ -35,23 +35,37 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.CountDownLatch;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CountDownLatchTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(CountDownLatchTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CountDownLatchTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(CountDownLatchTest.class);
+    // }
 
     /**
      * negative constructor argument throws IAE
      */
+    @Test
     public void testConstructor() {
         try {
             new CountDownLatch(-1);
@@ -62,6 +76,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * getCount returns initial count and decreases after countDown
      */
+    @Test
     public void testGetCount() {
         final CountDownLatch l = new CountDownLatch(2);
         assertEquals(2, l.getCount());
@@ -72,6 +87,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * countDown decrements count when positive and has no effect when zero
      */
+    @Test
     public void testCountDown() {
         final CountDownLatch l = new CountDownLatch(1);
         assertEquals(1, l.getCount());
@@ -84,6 +100,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * await returns after countDown to zero, but not before
      */
+    @Test
     public void testAwait() {
         final CountDownLatch l = new CountDownLatch(2);
         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
@@ -109,6 +126,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * timed await returns after countDown to zero
      */
+    @Test
     public void testTimedAwait() {
         final CountDownLatch l = new CountDownLatch(2);
         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
@@ -134,6 +152,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * await throws IE if interrupted before counted down
      */
+    @Test
     public void testAwait_Interruptible() {
         final CountDownLatch l = new CountDownLatch(1);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -165,6 +184,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * timed await throws IE if interrupted before counted down
      */
+    @Test
     public void testTimedAwait_Interruptible() {
         final CountDownLatch l = new CountDownLatch(1);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -196,6 +216,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * timed await times out if not counted down before timeout
      */
+    @Test
     public void testAwaitTimeout() throws InterruptedException {
         final CountDownLatch l = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -212,6 +233,7 @@ public class CountDownLatchTest extends JSR166TestCase {
     /**
      * toString indicates current count
      */
+    @Test
     public void testToString() {
         CountDownLatch s = new CountDownLatch(2);
         assertTrue(s.toString().contains("Count = 2"));
diff --git a/ojluni/src/test/java/util/concurrent/tck/CountedCompleter8Test.java b/ojluni/src/test/java/util/concurrent/tck/CountedCompleter8Test.java
index 663c2b5ec59..32cc676dfca 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CountedCompleter8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CountedCompleter8Test.java
@@ -35,6 +35,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.ThreadLocalRandom;
@@ -42,18 +50,21 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CountedCompleter8Test extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        return new TestSuite(CountedCompleter8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CountedCompleter8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(CountedCompleter8Test.class);
+    // }
 
     /** CountedCompleter class javadoc code sample, version 1. */
     public static <E> void forEach1(E[] array, Consumer<E> action) {
@@ -145,7 +156,7 @@ public class CountedCompleter8Test extends JSR166TestCase {
             new Task(null, 0, array.length).invoke();
     }
 
-    void testRecursiveDecomposition(
+    private void testRecursiveDecomposition(
         BiConsumer<Integer[], Consumer<Integer>> action) {
         int n = ThreadLocalRandom.current().nextInt(8);
         Integer[] a = new Integer[n];
@@ -159,6 +170,7 @@ public class CountedCompleter8Test extends JSR166TestCase {
      * Variants of divide-by-two recursive decomposition into leaf tasks,
      * as described in the CountedCompleter class javadoc code samples
      */
+    @Test
     public void testRecursiveDecomposition() {
         testRecursiveDecomposition(CountedCompleter8Test::forEach1);
         testRecursiveDecomposition(CountedCompleter8Test::forEach2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/CountedCompleterTest.java b/ojluni/src/test/java/util/concurrent/tck/CountedCompleterTest.java
index 241ca031ca3..3c3eac8e5f4 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CountedCompleterTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CountedCompleterTest.java
@@ -34,6 +34,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.HashSet;
 import java.util.concurrent.CancellationException;
@@ -46,18 +54,22 @@ import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CountedCompleterTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CountedCompleterTest");
     }
 
-    public static Test suite() {
-        return new TestSuite(CountedCompleterTest.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(CountedCompleterTest.class);
+    // }
 
     // Runs with "mainPool" use > 1 thread. singletonPool tests use 1
     static final int mainPoolSize =
@@ -317,6 +329,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * A newly constructed CountedCompleter is not completed;
      * complete() causes completion. pendingCount is ignored.
      */
+    @Test
     public void testComplete() {
         for (Object x : new Object[] { Boolean.TRUE, null }) {
             for (int pendingCount : new int[] { 0, 42 }) {
@@ -325,7 +338,7 @@ public class CountedCompleterTest extends JSR166TestCase {
             }
         }
     }
-    void testComplete(NoopCC cc, Object x, int pendingCount) {
+    private void testComplete(NoopCC cc, Object x, int pendingCount) {
         cc.setPendingCount(pendingCount);
         cc.checkCompletes(x);
         assertEquals(pendingCount, cc.getPendingCount());
@@ -334,6 +347,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * completeExceptionally completes exceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         new NoopCC()
             .checkCompletesExceptionally(new FJException());
@@ -345,6 +359,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * completeExceptionally(null) surprisingly has the same effect as
      * completeExceptionally(new RuntimeException())
      */
+    @Test
     public void testCompleteExceptionally_null() {
         NoopCC a = new NoopCC();
         a.completeExceptionally(null);
@@ -361,6 +376,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * setPendingCount sets the reported pending count
      */
+    @Test
     public void testSetPendingCount() {
         NoopCC a = new NoopCC();
         assertEquals(0, a.getPendingCount());
@@ -378,6 +394,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * addToPendingCount adds to the reported pending count
      */
+    @Test
     public void testAddToPendingCount() {
         NoopCC a = new NoopCC();
         assertEquals(0, a.getPendingCount());
@@ -393,6 +410,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * decrementPendingCountUnlessZero decrements reported pending
      * count unless zero
      */
+    @Test
     public void testDecrementPendingCountUnlessZero() {
         NoopCC a = new NoopCC(null, 2);
         assertEquals(2, a.getPendingCount());
@@ -411,6 +429,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * compareAndSetPendingCount compares and sets the reported
      * pending count
      */
+    @Test
     public void testCompareAndSetPendingCount() {
         NoopCC a = new NoopCC();
         assertEquals(0, a.getPendingCount());
@@ -425,6 +444,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * getCompleter returns parent or null if at root
      */
+    @Test
     public void testGetCompleter() {
         NoopCC a = new NoopCC();
         assertNull(a.getCompleter());
@@ -437,6 +457,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * getRoot returns self if no parent, else parent's root
      */
+    @Test
     public void testGetRoot() {
         NoopCC a = new NoopCC();
         NoopCC b = new NoopCC(a);
@@ -450,6 +471,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * tryComplete decrements pending count unless zero, in which case
      * causes completion
      */
+    @Test
     public void testTryComplete() {
         NoopCC a = new NoopCC();
         assertEquals(0, a.getPendingCount());
@@ -473,6 +495,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * propagateCompletion decrements pending count unless zero, in
      * which case causes completion, without invoking onCompletion
      */
+    @Test
     public void testPropagateCompletion() {
         NoopCC a = new NoopCC();
         assertEquals(0, a.getPendingCount());
@@ -495,6 +518,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * firstComplete returns this if pending count is zero else null
      */
+    @Test
     public void testFirstComplete() {
         NoopCC a = new NoopCC();
         a.setPendingCount(1);
@@ -508,6 +532,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * firstComplete.nextComplete returns parent if pending count is
      * zero else null
      */
+    @Test
     public void testNextComplete() {
         NoopCC a = new NoopCC();
         NoopCC b = new NoopCC(a);
@@ -530,6 +555,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyCompleteRoot completes root task and only root task
      */
+    @Test
     public void testQuietlyCompleteRoot() {
         NoopCC a = new NoopCC();
         NoopCC b = new NoopCC(a);
@@ -650,6 +676,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvoke() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -666,6 +693,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -680,6 +708,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -695,6 +724,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -710,6 +740,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -725,6 +756,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPE() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -741,6 +773,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -757,6 +790,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesce() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -773,6 +807,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -790,6 +825,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -804,6 +840,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -822,6 +859,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -842,6 +880,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -862,6 +901,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -877,6 +917,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvoke() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -895,6 +936,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -914,6 +956,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGet() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -933,6 +976,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGet() throws Exception {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -952,6 +996,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoin() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -967,6 +1012,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * getPool of executing task returns its pool
      */
+    @Test
     public void testGetPool() {
         final ForkJoinPool mainPool = mainPool();
         ForkJoinTask a = new CheckedRecursiveAction() {
@@ -979,6 +1025,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -990,6 +1037,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * inForkJoinPool of executing task returns true
      */
+    @Test
     public void testInForkJoinPool() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1001,6 +1049,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1012,6 +1061,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * setRawResult(null) succeeds
      */
+    @Test
     public void testSetRawResult() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1024,6 +1074,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally2() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1040,6 +1091,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1057,6 +1109,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1071,6 +1124,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1091,6 +1145,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1115,6 +1170,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPE() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1132,6 +1188,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1150,6 +1207,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1167,6 +1225,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1186,6 +1245,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1210,6 +1270,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * tryUnfork returns true for most recent unexecuted task,
      * and suppresses execution
      */
+    @Test
     public void testTryUnfork() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1229,6 +1290,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * getSurplusQueuedTaskCount returns > 0 when
      * there are more tasks than threads
      */
+    @Test
     public void testGetSurplusQueuedTaskCount() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1251,6 +1313,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns most recent unexecuted task.
      */
+    @Test
     public void testPeekNextLocalTask() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1271,6 +1334,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * pollNextLocalTask returns most recent unexecuted task without
      * executing it
      */
+    @Test
     public void testPollNextLocalTask() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1290,6 +1354,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * pollTask returns an unexecuted task without executing it
      */
+    @Test
     public void testPollTask() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1308,6 +1373,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns least recent unexecuted task in async mode
      */
+    @Test
     public void testPeekNextLocalTaskAsync() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1329,6 +1395,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * pollNextLocalTask returns least recent unexecuted task without
      * executing it, in async mode
      */
+    @Test
     public void testPollNextLocalTaskAsync() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1349,6 +1416,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * pollTask returns an unexecuted task without executing it, in
      * async mode
      */
+    @Test
     public void testPollTaskAsync() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1372,6 +1440,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvokeSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1388,6 +1457,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvokeSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1402,6 +1472,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1417,6 +1488,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGetSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1432,6 +1504,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGetSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1447,6 +1520,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPESingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1463,6 +1537,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1479,6 +1554,7 @@ public class CountedCompleterTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesceSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1495,6 +1571,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvokeSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1512,6 +1589,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvokeSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1526,6 +1604,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1544,6 +1623,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGetSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1564,6 +1644,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGetSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1584,6 +1665,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1599,6 +1681,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvokeSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1617,6 +1700,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1636,6 +1720,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGetSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1655,6 +1740,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGetSingleton() throws Exception {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1674,6 +1760,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoinSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1689,6 +1776,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionallySingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1705,6 +1793,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1722,6 +1811,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1736,6 +1826,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1756,6 +1847,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollectionSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1780,6 +1872,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPESingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1797,6 +1890,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1815,6 +1909,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1832,6 +1927,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3Singleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1851,6 +1947,7 @@ public class CountedCompleterTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollectionSingleton() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
diff --git a/ojluni/src/test/java/util/concurrent/tck/CyclicBarrierTest.java b/ojluni/src/test/java/util/concurrent/tck/CyclicBarrierTest.java
index 08258c618c4..ec1432f3811 100644
--- a/ojluni/src/test/java/util/concurrent/tck/CyclicBarrierTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/CyclicBarrierTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.BrokenBarrierException;
 import java.util.concurrent.CountDownLatch;
@@ -43,16 +51,21 @@ import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class CyclicBarrierTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(CyclicBarrierTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.CyclicBarrierTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(CyclicBarrierTest.class);
+    // }
 
     /**
      * Spin-waits till the number of waiters == numberOfWaiters.
@@ -69,6 +82,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Creating with negative parties throws IAE
      */
+    @Test
     public void testConstructor1() {
         try {
             new CyclicBarrier(-1, (Runnable)null);
@@ -79,6 +93,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Creating with negative parties and no action throws IAE
      */
+    @Test
     public void testConstructor2() {
         try {
             new CyclicBarrier(-1);
@@ -89,6 +104,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * getParties returns the number of parties given in constructor
      */
+    @Test
     public void testGetParties() {
         CyclicBarrier b = new CyclicBarrier(2);
         assertEquals(2, b.getParties());
@@ -98,6 +114,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * A 1-party barrier triggers after single await
      */
+    @Test
     public void testSingleParty() throws Exception {
         CyclicBarrier b = new CyclicBarrier(1);
         assertEquals(1, b.getParties());
@@ -110,6 +127,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * The supplied barrier action is run at barrier
      */
+    @Test
     public void testBarrierAction() throws Exception {
         final AtomicInteger count = new AtomicInteger(0);
         final Runnable incCount = new Runnable() { public void run() {
@@ -126,6 +144,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * A 2-party/thread barrier triggers after both threads invoke await
      */
+    @Test
     public void testTwoParties() throws Exception {
         final CyclicBarrier b = new CyclicBarrier(2);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -147,6 +166,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * An interruption in one party causes others waiting in await to
      * throw BrokenBarrierException
      */
+    @Test
     public void testAwait1_Interrupted_BrokenBarrier() {
         final CyclicBarrier c = new CyclicBarrier(3);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
@@ -173,6 +193,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * An interruption in one party causes others waiting in timed await to
      * throw BrokenBarrierException
      */
+    @Test
     public void testAwait2_Interrupted_BrokenBarrier() throws Exception {
         final CyclicBarrier c = new CyclicBarrier(3);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
@@ -198,6 +219,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * A timeout in timed await throws TimeoutException
      */
+    @Test
     public void testAwait3_TimeoutException() throws InterruptedException {
         final CyclicBarrier c = new CyclicBarrier(2);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -217,6 +239,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * A timeout in one party causes others waiting in timed await to
      * throw BrokenBarrierException
      */
+    @Test
     public void testAwait4_Timeout_BrokenBarrier() throws InterruptedException {
         final CyclicBarrier c = new CyclicBarrier(3);
         Thread t1 = newStartedThread(new CheckedRunnable() {
@@ -245,6 +268,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * A timeout in one party causes others waiting in await to
      * throw BrokenBarrierException
      */
+    @Test
     public void testAwait5_Timeout_BrokenBarrier() throws InterruptedException {
         final CyclicBarrier c = new CyclicBarrier(3);
         Thread t1 = newStartedThread(new CheckedRunnable() {
@@ -273,6 +297,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * A reset of an active barrier causes waiting threads to throw
      * BrokenBarrierException
      */
+    @Test
     public void testReset_BrokenBarrier() throws InterruptedException {
         final CyclicBarrier c = new CyclicBarrier(3);
         final CountDownLatch pleaseReset = new CountDownLatch(2);
@@ -301,6 +326,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
      * A reset before threads enter barrier does not throw
      * BrokenBarrierException
      */
+    @Test
     public void testReset_NoBrokenBarrier() throws Exception {
         final CyclicBarrier c = new CyclicBarrier(3);
         c.reset();
@@ -322,6 +348,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * All threads block while a barrier is broken.
      */
+    @Test
     public void testReset_Leakage() throws InterruptedException {
         final CyclicBarrier c = new CyclicBarrier(2);
         final AtomicBoolean done = new AtomicBoolean();
@@ -351,6 +378,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Reset of a non-broken barrier does not break barrier
      */
+    @Test
     public void testResetWithoutBreakage() throws Exception {
         final CyclicBarrier barrier = new CyclicBarrier(3);
         for (int i = 0; i < 3; i++) {
@@ -382,6 +410,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Reset of a barrier after interruption reinitializes it.
      */
+    @Test
     public void testResetAfterInterrupt() throws Exception {
         final CyclicBarrier barrier = new CyclicBarrier(3);
         for (int i = 0; i < 2; i++) {
@@ -415,6 +444,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Reset of a barrier after timeout reinitializes it.
      */
+    @Test
     public void testResetAfterTimeout() throws Exception {
         final CyclicBarrier barrier = new CyclicBarrier(3);
         for (int i = 0; i < 2; i++) {
@@ -451,6 +481,7 @@ public class CyclicBarrierTest extends JSR166TestCase {
     /**
      * Reset of a barrier after a failed command reinitializes it.
      */
+    @Test
     public void testResetAfterCommandException() throws Exception {
         final CyclicBarrier barrier =
             new CyclicBarrier(3, new Runnable() {
diff --git a/ojluni/src/test/java/util/concurrent/tck/DelayQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/DelayQueueTest.java
index dfaf2d078d7..1b78f316dc5 100644
--- a/ojluni/src/test/java/util/concurrent/tck/DelayQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/DelayQueueTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -49,10 +57,16 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class DelayQueueTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Generic extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new DelayQueue();
@@ -63,21 +77,22 @@ public class DelayQueueTest extends JSR166TestCase {
     }
 
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.DelayQueueTest");
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return DelayQueue.class; }
-            public Collection emptyCollection() { return new DelayQueue(); }
-            public Object makeElement(int i) { return new PDelay(i); }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(DelayQueueTest.class,
-                            new Generic().testSuite(),
-                            CollectionTest.testSuite(new Implementation()));
-    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return DelayQueue.class; }
+    //         public Collection emptyCollection() { return new DelayQueue(); }
+    //         public Object makeElement(int i) { return new PDelay(i); }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(DelayQueueTest.class,
+    //                         new Generic().testSuite(),
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * A fake Delayed implementation for testing.
@@ -160,6 +175,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * A new queue has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(Integer.MAX_VALUE, new DelayQueue().remainingCapacity());
     }
@@ -167,6 +183,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new DelayQueue(null);
@@ -177,6 +194,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new DelayQueue(Arrays.asList(new PDelay[SIZE]));
@@ -187,6 +205,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         PDelay[] a = new PDelay[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -200,6 +219,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         PDelay[] ints = new PDelay[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -212,6 +232,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         DelayQueue q = new DelayQueue();
         assertTrue(q.isEmpty());
@@ -227,6 +248,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * remainingCapacity() always returns Integer.MAX_VALUE
      */
+    @Test
     public void testRemainingCapacity() {
         BlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -244,6 +266,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * offer non-null succeeds
      */
+    @Test
     public void testOffer() {
         DelayQueue q = new DelayQueue();
         assertTrue(q.offer(new PDelay(0)));
@@ -253,6 +276,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * add succeeds
      */
+    @Test
     public void testAdd() {
         DelayQueue q = new DelayQueue();
         for (int i = 0; i < SIZE; ++i) {
@@ -264,6 +288,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         DelayQueue q = populatedQueue(SIZE);
         try {
@@ -276,6 +301,7 @@ public class DelayQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         DelayQueue q = new DelayQueue();
         PDelay[] a = new PDelay[SIZE];
@@ -290,6 +316,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         PDelay[] empty = new PDelay[0];
         PDelay[] ints = new PDelay[SIZE];
@@ -305,6 +332,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() {
         DelayQueue q = new DelayQueue();
         for (int i = 0; i < SIZE; ++i) {
@@ -318,6 +346,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * put doesn't block waiting for take
      */
+    @Test
     public void testPutWithTake() throws InterruptedException {
         final DelayQueue q = new DelayQueue();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -335,6 +364,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * timed offer does not time out
      */
+    @Test
     public void testTimedOffer() throws InterruptedException {
         final DelayQueue q = new DelayQueue();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -351,6 +381,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * take retrieves elements in priority order
      */
+    @Test
     public void testTake() throws InterruptedException {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -361,6 +392,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final DelayQueue q = populatedQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -394,6 +426,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -405,6 +438,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -416,6 +450,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -433,6 +468,7 @@ public class DelayQueueTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         final DelayQueue q = populatedQueue(SIZE);
@@ -470,6 +506,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -486,6 +523,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -501,6 +539,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -515,6 +554,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         DelayQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -527,6 +567,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         DelayQueue q = populatedQueue(SIZE);
         q.clear();
@@ -544,6 +585,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         DelayQueue q = populatedQueue(SIZE);
         DelayQueue p = new DelayQueue();
@@ -558,6 +600,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         DelayQueue q = populatedQueue(SIZE);
         DelayQueue p = populatedQueue(SIZE);
@@ -577,6 +620,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             DelayQueue q = populatedQueue(SIZE);
@@ -593,6 +637,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * toArray contains all elements
      */
+    @Test
     public void testToArray() throws InterruptedException {
         DelayQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -604,6 +649,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements
      */
+    @Test
     public void testToArray2() {
         DelayQueue<PDelay> q = populatedQueue(SIZE);
         PDelay[] ints = new PDelay[SIZE];
@@ -617,6 +663,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         DelayQueue q = populatedQueue(SIZE);
         try {
@@ -628,6 +675,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         DelayQueue q = populatedQueue(SIZE);
         int i = 0;
@@ -643,6 +691,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new DelayQueue().iterator());
     }
@@ -650,6 +699,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final DelayQueue q = new DelayQueue();
         q.add(new PDelay(2));
@@ -667,6 +717,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         DelayQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -677,6 +728,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * timed poll transfers elements across Executor tasks
      */
+    @Test
     public void testPollInExecutor() {
         final DelayQueue q = new DelayQueue();
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -701,6 +753,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * Delayed actions do not occur until their delay elapses
      */
+    @Test
     public void testDelay() throws InterruptedException {
         DelayQueue<NanoDelay> q = new DelayQueue<>();
         for (int i = 0; i < SIZE; ++i)
@@ -721,6 +774,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * peek of a non-empty queue returns non-null even if not expired
      */
+    @Test
     public void testPeekDelayed() {
         DelayQueue q = new DelayQueue();
         q.add(new NanoDelay(Long.MAX_VALUE));
@@ -730,6 +784,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * poll of a non-empty queue returns null if no expired elements.
      */
+    @Test
     public void testPollDelayed() {
         DelayQueue q = new DelayQueue();
         q.add(new NanoDelay(Long.MAX_VALUE));
@@ -739,6 +794,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * timed poll of a non-empty queue returns null if no expired elements.
      */
+    @Test
     public void testTimedPollDelayed() throws InterruptedException {
         DelayQueue q = new DelayQueue();
         q.add(new NanoDelay(LONG_DELAY_MS * 1000000L));
@@ -748,6 +804,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties queue into another collection c
      */
+    @Test
     public void testDrainTo() {
         DelayQueue q = new DelayQueue();
         PDelay[] elems = new PDelay[SIZE];
@@ -776,6 +833,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * drainTo empties queue
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final DelayQueue q = populatedQueue(SIZE);
         Thread t = new Thread(new CheckedRunnable() {
@@ -794,6 +852,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         for (int i = 0; i < SIZE + 2; ++i) {
             DelayQueue q = populatedQueue(SIZE);
@@ -808,6 +867,7 @@ public class DelayQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?> q = populatedQueue(SIZE);
         assertFalse(q.contains(null));
diff --git a/ojluni/src/test/java/util/concurrent/tck/DoubleAccumulatorTest.java b/ojluni/src/test/java/util/concurrent/tck/DoubleAccumulatorTest.java
index ef42b44a737..f2466501ee6 100644
--- a/ojluni/src/test/java/util/concurrent/tck/DoubleAccumulatorTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/DoubleAccumulatorTest.java
@@ -32,68 +32,87 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Phaser;
 import java.util.concurrent.atomic.DoubleAccumulator;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class DoubleAccumulatorTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(DoubleAccumulatorTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.DoubleAccumulatorTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(DoubleAccumulatorTest.class);
+    // }
 
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
-        assertEquals(0.0, ai.get());
+        assertEquals(0.0, ai.get(), 0.0d);
     }
 
     /**
      * accumulate accumulates given value to current, and get returns current value
      */
+    @Test
     public void testAccumulateAndGet() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         ai.accumulate(2.0);
-        assertEquals(2.0, ai.get());
+        assertEquals(2.0, ai.get(), 0.0d);
         ai.accumulate(-4.0);
-        assertEquals(2.0, ai.get());
+        assertEquals(2.0, ai.get(), 0.0d);
         ai.accumulate(4.0);
-        assertEquals(4.0, ai.get());
+        assertEquals(4.0, ai.get(), 0.0d);
     }
 
     /**
      * reset() causes subsequent get() to return zero
      */
+    @Test
     public void testReset() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         ai.accumulate(2.0);
-        assertEquals(2.0, ai.get());
+        assertEquals(2.0, ai.get(), 0.0d);
         ai.reset();
-        assertEquals(0.0, ai.get());
+        assertEquals(0.0, ai.get(), 0.0d);
     }
 
     /**
      * getThenReset() returns current value; subsequent get() returns zero
      */
+    @Test
     public void testGetThenReset() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         ai.accumulate(2.0);
-        assertEquals(2.0, ai.get());
-        assertEquals(2.0, ai.getThenReset());
-        assertEquals(0.0, ai.get());
+        assertEquals(2.0, ai.get(), 0.0d);
+        assertEquals(2.0, ai.getThenReset(), 0.0d);
+        assertEquals(0.0, ai.get(), 0.0d);
     }
 
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         assertEquals("0.0", ai.toString());
@@ -104,6 +123,7 @@ public class DoubleAccumulatorTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         assertEquals(0, ai.intValue());
@@ -114,6 +134,7 @@ public class DoubleAccumulatorTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
         assertEquals(0, ai.longValue());
@@ -124,26 +145,29 @@ public class DoubleAccumulatorTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         ai.accumulate(1.0);
-        assertEquals(1.0f, ai.floatValue());
+        assertEquals(1.0f, ai.floatValue(), 0.0f);
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         DoubleAccumulator ai = new DoubleAccumulator(Double::max, 0.0);
-        assertEquals(0.0, ai.doubleValue());
+        assertEquals(0.0, ai.doubleValue(), 0.0d);
         ai.accumulate(1.0);
-        assertEquals(1.0, ai.doubleValue());
+        assertEquals(1.0, ai.doubleValue(), 0.0d);
     }
 
     /**
      * accumulates by multiple threads produce correct result
      */
+    @Test
     public void testAccumulateAndGetMT() {
         final int incs = 1000000;
         final int nthreads = 4;
@@ -156,7 +180,7 @@ public class DoubleAccumulatorTest extends JSR166TestCase {
         phaser.arriveAndAwaitAdvance();
         double expected = incs - 1;
         double result = a.get();
-        assertEquals(expected, result);
+        assertEquals(expected, result, 0.0d);
         pool.shutdown();
     }
 
diff --git a/ojluni/src/test/java/util/concurrent/tck/DoubleAdderTest.java b/ojluni/src/test/java/util/concurrent/tck/DoubleAdderTest.java
index dd89b563534..3dab55d7ef6 100644
--- a/ojluni/src/test/java/util/concurrent/tck/DoubleAdderTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/DoubleAdderTest.java
@@ -32,80 +32,100 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.DoubleAdder;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class DoubleAdderTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(DoubleAdderTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.DoubleAdderTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(DoubleAdderTest.class);
+    // }
 
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor() {
         DoubleAdder ai = new DoubleAdder();
-        assertEquals(0.0, ai.sum());
+        assertEquals(0.0, ai.sum(), 0.0d);
     }
 
     /**
      * add adds given value to current, and sum returns current value
      */
+    @Test
     public void testAddAndSum() {
         DoubleAdder ai = new DoubleAdder();
         ai.add(2.0);
-        assertEquals(2.0, ai.sum());
+        assertEquals(2.0, ai.sum(), 0.0d);
         ai.add(-4.0);
-        assertEquals(-2.0, ai.sum());
+        assertEquals(-2.0, ai.sum(), 0.0d);
     }
 
     /**
      * reset() causes subsequent sum() to return zero
      */
+    @Test
     public void testReset() {
         DoubleAdder ai = new DoubleAdder();
         ai.add(2.0);
-        assertEquals(2.0, ai.sum());
+        assertEquals(2.0, ai.sum(), 0.0d);
         ai.reset();
-        assertEquals(0.0, ai.sum());
+        assertEquals(0.0, ai.sum(), 0.0d);
     }
 
     /**
      * sumThenReset() returns sum; subsequent sum() returns zero
      */
+    @Test
     public void testSumThenReset() {
         DoubleAdder ai = new DoubleAdder();
         ai.add(2.0);
-        assertEquals(2.0, ai.sum());
-        assertEquals(2.0, ai.sumThenReset());
-        assertEquals(0.0, ai.sum());
+        assertEquals(2.0, ai.sum(), 0.0d);
+        assertEquals(2.0, ai.sumThenReset(), 0.0d);
+        assertEquals(0.0, ai.sum(), 0.0d);
     }
 
     /**
      * a deserialized serialized adder holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         DoubleAdder x = new DoubleAdder();
         DoubleAdder y = serialClone(x);
         assertNotSame(x, y);
         x.add(-22.0);
         DoubleAdder z = serialClone(x);
-        assertEquals(-22.0, x.sum());
-        assertEquals(0.0, y.sum());
-        assertEquals(-22.0, z.sum());
+        assertEquals(-22.0, x.sum(), 0.0d);
+        assertEquals(0.0, y.sum(), 0.0d);
+        assertEquals(-22.0, z.sum(), 0.0d);
     }
 
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         DoubleAdder ai = new DoubleAdder();
         assertEquals(Double.toString(0.0), ai.toString());
@@ -116,6 +136,7 @@ public class DoubleAdderTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         DoubleAdder ai = new DoubleAdder();
         assertEquals(0, ai.intValue());
@@ -126,6 +147,7 @@ public class DoubleAdderTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         DoubleAdder ai = new DoubleAdder();
         assertEquals(0, ai.longValue());
@@ -136,26 +158,29 @@ public class DoubleAdderTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         DoubleAdder ai = new DoubleAdder();
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         ai.add(1.0);
-        assertEquals(1.0f, ai.floatValue());
+        assertEquals(1.0f, ai.floatValue(), 0.0f);
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         DoubleAdder ai = new DoubleAdder();
-        assertEquals(0.0, ai.doubleValue());
+        assertEquals(0.0, ai.doubleValue(), 0.0d);
         ai.add(1.0);
-        assertEquals(1.0, ai.doubleValue());
+        assertEquals(1.0, ai.doubleValue(), 0.0d);
     }
 
     /**
      * adds by multiple threads produce correct sum
      */
+    @Test
     public void testAddAndSumMT() throws Throwable {
         final int incs = 1000000;
         final int nthreads = 4;
@@ -168,7 +193,7 @@ public class DoubleAdderTest extends JSR166TestCase {
         barrier.await();
         double total = (long)nthreads * incs;
         double sum = a.sum();
-        assertEquals(sum, total);
+        assertEquals(sum, total, 0.0d);
         pool.shutdown();
     }
 
diff --git a/ojluni/src/test/java/util/concurrent/tck/EntryTest.java b/ojluni/src/test/java/util/concurrent/tck/EntryTest.java
index c98541d2c39..cd5dddf79c8 100644
--- a/ojluni/src/test/java/util/concurrent/tck/EntryTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/EntryTest.java
@@ -32,19 +32,33 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.AbstractMap;
 import java.util.Map;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class EntryTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(EntryTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.EntryTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(EntryTest.class);
+    // }
 
     static final String k1 = "1";
     static final String v1 = "a";
@@ -54,6 +68,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * A new SimpleEntry(k, v) holds k, v.
      */
+    @Test
     public void testConstructor1() {
         Map.Entry e = new AbstractMap.SimpleEntry(k1, v1);
         assertEquals(k1, e.getKey());
@@ -63,6 +78,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * A new SimpleImmutableEntry(k, v) holds k, v.
      */
+    @Test
     public void testConstructor2() {
         Map.Entry s = new AbstractMap.SimpleImmutableEntry(k1, v1);
         assertEquals(k1, s.getKey());
@@ -72,6 +88,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * A new SimpleEntry(entry(k, v)) holds k, v.
      */
+    @Test
     public void testConstructor3() {
         Map.Entry e2 = new AbstractMap.SimpleEntry(k1, v1);
         Map.Entry e = new AbstractMap.SimpleEntry(e2);
@@ -82,6 +99,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * A new SimpleImmutableEntry(entry(k, v)) holds k, v.
      */
+    @Test
     public void testConstructor4() {
         Map.Entry s2 = new AbstractMap.SimpleImmutableEntry(k1, v1);
         Map.Entry s = new AbstractMap.SimpleImmutableEntry(s2);
@@ -93,6 +111,7 @@ public class EntryTest extends JSR166TestCase {
      * Entries with same key-value pairs are equal and have same
      * hashcodes
      */
+    @Test
     public void testEquals() {
         Map.Entry e2 = new AbstractMap.SimpleEntry(k1, v1);
         Map.Entry e = new AbstractMap.SimpleEntry(e2);
@@ -111,6 +130,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * Entries with different key-value pairs are not equal
      */
+    @Test
     public void testNotEquals() {
         Map.Entry e2 = new AbstractMap.SimpleEntry(k1, v1);
         Map.Entry e = new AbstractMap.SimpleEntry(k2, v1);
@@ -132,6 +152,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * getValue returns last setValue for SimpleEntry
      */
+    @Test
     public void testSetValue1() {
         Map.Entry e2 = new AbstractMap.SimpleEntry(k1, v1);
         Map.Entry e = new AbstractMap.SimpleEntry(e2);
@@ -145,6 +166,7 @@ public class EntryTest extends JSR166TestCase {
     /**
      * setValue for SimpleImmutableEntry throws UnsupportedOperationException
      */
+    @Test
     public void testSetValue2() {
         Map.Entry s2 = new AbstractMap.SimpleImmutableEntry(k1, v1);
         Map.Entry s = new AbstractMap.SimpleImmutableEntry(s2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ExchangerTest.java b/ojluni/src/test/java/util/concurrent/tck/ExchangerTest.java
index 95acafb1681..1c12978fdc8 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ExchangerTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ExchangerTest.java
@@ -35,26 +35,39 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Exchanger;
 import java.util.concurrent.TimeoutException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ExchangerTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ExchangerTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ExchangerTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ExchangerTest.class);
+    // }
 
     /**
      * exchange exchanges objects across two threads
      */
+    @Test
     public void testExchange() {
         final Exchanger e = new Exchanger();
         Thread t1 = newStartedThread(new CheckedRunnable() {
@@ -75,6 +88,7 @@ public class ExchangerTest extends JSR166TestCase {
     /**
      * timed exchange exchanges objects across two threads
      */
+    @Test
     public void testTimedExchange() {
         final Exchanger e = new Exchanger();
         Thread t1 = newStartedThread(new CheckedRunnable() {
@@ -95,6 +109,7 @@ public class ExchangerTest extends JSR166TestCase {
     /**
      * interrupt during wait for exchange throws IE
      */
+    @Test
     public void testExchange_InterruptedException() {
         final Exchanger e = new Exchanger();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -112,6 +127,7 @@ public class ExchangerTest extends JSR166TestCase {
     /**
      * interrupt during wait for timed exchange throws IE
      */
+    @Test
     public void testTimedExchange_InterruptedException() {
         final Exchanger e = new Exchanger();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -129,6 +145,7 @@ public class ExchangerTest extends JSR166TestCase {
     /**
      * timeout during wait for timed exchange throws TimeoutException
      */
+    @Test
     public void testExchange_TimeoutException() {
         final Exchanger e = new Exchanger();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -147,6 +164,7 @@ public class ExchangerTest extends JSR166TestCase {
     /**
      * If one exchanging thread is interrupted, another succeeds.
      */
+    @Test
     public void testReplacementAfterExchange() {
         final Exchanger e = new Exchanger();
         final CountDownLatch exchanged = new CountDownLatch(2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionService9Test.java b/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionService9Test.java
index 1af24cf3c12..7e1411ebc91 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionService9Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionService9Test.java
@@ -33,6 +33,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
@@ -46,16 +55,21 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorCompletionService;
 import java.util.concurrent.Future;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ExecutorCompletionService9Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ExecutorCompletionService9Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ExecutorCompletionService9Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ExecutorCompletionService9Test.class);
+    // }
 
     void solveAll(Executor e,
                   Collection<Callable<Integer>> solvers)
@@ -107,6 +121,7 @@ public class ExecutorCompletionService9Test extends JSR166TestCase {
     /**
      * The first "solvers" sample code in the class javadoc works.
      */
+    @Test
     public void testSolveAll()
         throws InterruptedException, ExecutionException {
         results = null;
@@ -124,6 +139,7 @@ public class ExecutorCompletionService9Test extends JSR166TestCase {
     /**
      * The second "solvers" sample code in the class javadoc works.
      */
+    @Test
     public void testSolveAny()
         throws InterruptedException {
         results = null;
diff --git a/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionServiceTest.java b/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionServiceTest.java
index 877031e8401..ede306972b6 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionServiceTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ExecutorCompletionServiceTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.Callable;
@@ -50,20 +58,26 @@ import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ExecutorCompletionServiceTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ExecutorCompletionServiceTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ExecutorCompletionServiceTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ExecutorCompletionServiceTest.class);
+    // }
 
     /**
      * new ExecutorCompletionService(null) throws NullPointerException
      */
+    @Test
     public void testConstructorNPE() {
         try {
             new ExecutorCompletionService(null);
@@ -74,6 +88,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * new ExecutorCompletionService(e, null) throws NullPointerException
      */
+    @Test
     public void testConstructorNPE2() {
         try {
             new ExecutorCompletionService(cachedThreadPool, null);
@@ -84,6 +99,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * ecs.submit(null) throws NullPointerException
      */
+    @Test
     public void testSubmitNullCallable() {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
         try {
@@ -95,6 +111,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * ecs.submit(null, val) throws NullPointerException
      */
+    @Test
     public void testSubmitNullRunnable() {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
         try {
@@ -106,6 +123,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * A taken submitted task is completed
      */
+    @Test
     public void testTake()
         throws InterruptedException, ExecutionException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
@@ -118,6 +136,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * Take returns the same future object returned by submit
      */
+    @Test
     public void testTake2() throws InterruptedException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
         Future f1 = cs.submit(new StringTask());
@@ -128,6 +147,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * poll returns non-null when the returned task is completed
      */
+    @Test
     public void testPoll1()
         throws InterruptedException, ExecutionException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
@@ -148,6 +168,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * timed poll returns non-null when the returned task is completed
      */
+    @Test
     public void testPoll2()
         throws InterruptedException, ExecutionException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
@@ -168,6 +189,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * poll returns null before the returned task is completed
      */
+    @Test
     public void testPollReturnsNull()
         throws InterruptedException, ExecutionException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
@@ -189,6 +211,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
     /**
      * successful and failed tasks are both returned
      */
+    @Test
     public void testTaskAssortment()
         throws InterruptedException, ExecutionException {
         CompletionService cs = new ExecutorCompletionService(cachedThreadPool);
@@ -219,6 +242,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
      * Submitting to underlying AES that overrides newTaskFor(Callable)
      * returns and eventually runs Future returned by newTaskFor.
      */
+    @Test
     public void testNewTaskForCallable() throws InterruptedException {
         final AtomicBoolean done = new AtomicBoolean(false);
         class MyCallableFuture<V> extends FutureTask<V> {
@@ -249,6 +273,7 @@ public class ExecutorCompletionServiceTest extends JSR166TestCase {
      * Submitting to underlying AES that overrides newTaskFor(Runnable,T)
      * returns and eventually runs Future returned by newTaskFor.
      */
+    @Test
     public void testNewTaskForRunnable() throws InterruptedException {
         final AtomicBoolean done = new AtomicBoolean(false);
         class MyRunnableFuture<V> extends FutureTask<V> {
diff --git a/ojluni/src/test/java/util/concurrent/tck/ExecutorsTest.java b/ojluni/src/test/java/util/concurrent/tck/ExecutorsTest.java
index fd4b7e46c7f..aa57c09875f 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ExecutorsTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ExecutorsTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.security.AccessControlContext;
 import java.security.AccessControlException;
@@ -51,20 +59,27 @@ import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadPoolExecutor;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ExecutorsTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ExecutorsTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ExecutorsTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ExecutorsTest.class);
+    // }
 
     /**
      * A newCachedThreadPool can execute runnables
      */
+    @Test
     public void testNewCachedThreadPool1() {
         final ExecutorService e = Executors.newCachedThreadPool();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -77,6 +92,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A newCachedThreadPool with given ThreadFactory can execute runnables
      */
+    @Test
     public void testNewCachedThreadPool2() {
         final ExecutorService e = Executors.newCachedThreadPool(new SimpleThreadFactory());
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -89,6 +105,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A newCachedThreadPool with null ThreadFactory throws NPE
      */
+    @Test
     public void testNewCachedThreadPool3() {
         try {
             ExecutorService e = Executors.newCachedThreadPool(null);
@@ -99,6 +116,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new SingleThreadExecutor can execute runnables
      */
+    @Test
     public void testNewSingleThreadExecutor1() {
         final ExecutorService e = Executors.newSingleThreadExecutor();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -111,6 +129,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new SingleThreadExecutor with given ThreadFactory can execute runnables
      */
+    @Test
     public void testNewSingleThreadExecutor2() {
         final ExecutorService e = Executors.newSingleThreadExecutor(new SimpleThreadFactory());
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -123,6 +142,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new SingleThreadExecutor with null ThreadFactory throws NPE
      */
+    @Test
     public void testNewSingleThreadExecutor3() {
         try {
             ExecutorService e = Executors.newSingleThreadExecutor(null);
@@ -133,6 +153,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new SingleThreadExecutor cannot be casted to concrete implementation
      */
+    @Test
     public void testCastNewSingleThreadExecutor() {
         final ExecutorService e = Executors.newSingleThreadExecutor();
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -146,6 +167,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new newFixedThreadPool can execute runnables
      */
+    @Test
     public void testNewFixedThreadPool1() {
         final ExecutorService e = Executors.newFixedThreadPool(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -158,6 +180,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new newFixedThreadPool with given ThreadFactory can execute runnables
      */
+    @Test
     public void testNewFixedThreadPool2() {
         final ExecutorService e = Executors.newFixedThreadPool(2, new SimpleThreadFactory());
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -170,6 +193,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new newFixedThreadPool with null ThreadFactory throws NPE
      */
+    @Test
     public void testNewFixedThreadPool3() {
         try {
             ExecutorService e = Executors.newFixedThreadPool(2, null);
@@ -180,6 +204,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * A new newFixedThreadPool with 0 threads throws IAE
      */
+    @Test
     public void testNewFixedThreadPool4() {
         try {
             ExecutorService e = Executors.newFixedThreadPool(0);
@@ -190,6 +215,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * An unconfigurable newFixedThreadPool can execute runnables
      */
+    @Test
     public void testUnconfigurableExecutorService() {
         final ExecutorService e = Executors.unconfigurableExecutorService(Executors.newFixedThreadPool(2));
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -202,6 +228,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * unconfigurableExecutorService(null) throws NPE
      */
+    @Test
     public void testUnconfigurableExecutorServiceNPE() {
         try {
             ExecutorService e = Executors.unconfigurableExecutorService(null);
@@ -212,6 +239,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * unconfigurableScheduledExecutorService(null) throws NPE
      */
+    @Test
     public void testUnconfigurableScheduledExecutorServiceNPE() {
         try {
             ExecutorService e = Executors.unconfigurableScheduledExecutorService(null);
@@ -222,6 +250,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * a newSingleThreadScheduledExecutor successfully runs delayed task
      */
+    @Test
     public void testNewSingleThreadScheduledExecutor() throws Exception {
         final ScheduledExecutorService p = Executors.newSingleThreadScheduledExecutor();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -246,6 +275,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * a newScheduledThreadPool successfully runs delayed task
      */
+    @Test
     public void testNewScheduledThreadPool() throws Exception {
         final ScheduledExecutorService p = Executors.newScheduledThreadPool(2);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -270,6 +300,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * an unconfigurable newScheduledThreadPool successfully runs delayed task
      */
+    @Test
     public void testUnconfigurableScheduledExecutorService() throws Exception {
         final ScheduledExecutorService p =
             Executors.unconfigurableScheduledExecutorService
@@ -296,6 +327,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * Future.get on submitted tasks will time out if they compute too long.
      */
+    @Test
     public void testTimedCallable() throws Exception {
         final ExecutorService[] executors = {
             Executors.newSingleThreadExecutor(),
@@ -327,6 +359,7 @@ public class ExecutorsTest extends JSR166TestCase {
      * ThreadPoolExecutor using defaultThreadFactory has
      * specified group, priority, daemon status, and name
      */
+    @Test
     public void testDefaultThreadFactory() throws Exception {
         final ThreadGroup egroup = Thread.currentThread().getThreadGroup();
         final CountDownLatch done = new CountDownLatch(1);
@@ -361,6 +394,8 @@ public class ExecutorsTest extends JSR166TestCase {
      * specified group, priority, daemon status, name,
      * access control context and context class loader
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testPrivilegedThreadFactory() throws Exception {
         final CountDownLatch done = new CountDownLatch(1);
         Runnable r = new CheckedRunnable() {
@@ -431,6 +466,8 @@ public class ExecutorsTest extends JSR166TestCase {
      * Without class loader permissions, creating
      * privilegedCallableUsingCurrentClassLoader throws ACE
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testCreatePrivilegedCallableUsingCCLWithNoPrivs() {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -449,6 +486,8 @@ public class ExecutorsTest extends JSR166TestCase {
      * With class loader permissions, calling
      * privilegedCallableUsingCurrentClassLoader does not throw ACE
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testPrivilegedCallableUsingCCLWithPrivs() throws Exception {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -465,6 +504,8 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * Without permissions, calling privilegedCallable throws ACE
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testPrivilegedCallableWithNoPrivs() throws Exception {
         // Avoid classloader-related SecurityExceptions in swingui.TestRunner
         Executors.privilegedCallable(new CheckCCL());
@@ -537,6 +578,8 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * With permissions, calling privilegedCallable succeeds
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testPrivilegedCallableWithPrivs() throws Exception {
         Runnable r = new CheckedRunnable() {
             public void realRun() throws Exception {
@@ -551,6 +594,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(Runnable) returns null when called
      */
+    @Test
     public void testCallable1() throws Exception {
         Callable c = Executors.callable(new NoOpRunnable());
         assertNull(c.call());
@@ -559,6 +603,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(Runnable, result) returns result when called
      */
+    @Test
     public void testCallable2() throws Exception {
         Callable c = Executors.callable(new NoOpRunnable(), one);
         assertSame(one, c.call());
@@ -567,6 +612,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(PrivilegedAction) returns its result when called
      */
+    @Test
     public void testCallable3() throws Exception {
         Callable c = Executors.callable(new PrivilegedAction() {
                 public Object run() { return one; }});
@@ -576,6 +622,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(PrivilegedExceptionAction) returns its result when called
      */
+    @Test
     public void testCallable4() throws Exception {
         Callable c = Executors.callable(new PrivilegedExceptionAction() {
                 public Object run() { return one; }});
@@ -585,6 +632,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(null Runnable) throws NPE
      */
+    @Test
     public void testCallableNPE1() {
         try {
             Callable c = Executors.callable((Runnable) null);
@@ -595,6 +643,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(null, result) throws NPE
      */
+    @Test
     public void testCallableNPE2() {
         try {
             Callable c = Executors.callable((Runnable) null, one);
@@ -605,6 +654,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(null PrivilegedAction) throws NPE
      */
+    @Test
     public void testCallableNPE3() {
         try {
             Callable c = Executors.callable((PrivilegedAction) null);
@@ -615,6 +665,7 @@ public class ExecutorsTest extends JSR166TestCase {
     /**
      * callable(null PrivilegedExceptionAction) throws NPE
      */
+    @Test
     public void testCallableNPE4() {
         try {
             Callable c = Executors.callable((PrivilegedExceptionAction) null);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ForkJoinPool8Test.java b/ojluni/src/test/java/util/concurrent/tck/ForkJoinPool8Test.java
index a39fc71fca1..9ccb79bd3f4 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ForkJoinPool8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ForkJoinPool8Test.java
@@ -34,6 +34,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.HashSet;
 import java.util.concurrent.CancellationException;
@@ -44,21 +52,26 @@ import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.TimeoutException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ForkJoinPool8Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        return new TestSuite(ForkJoinPool8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ForkJoinPool8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ForkJoinPool8Test.class);
+    // }
 
     /**
      * Common pool exists and has expected parallelism.
      */
+    @Test
     public void testCommonPoolParallelism() {
         assertEquals(ForkJoinPool.getCommonPoolParallelism(),
                      ForkJoinPool.commonPool().getParallelism());
@@ -67,6 +80,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * Common pool cannot be shut down
      */
+    @Test
     public void testCommonPoolShutDown() {
         assertFalse(ForkJoinPool.commonPool().isShutdown());
         assertFalse(ForkJoinPool.commonPool().isTerminating());
@@ -248,6 +262,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks. getRawResult of a RecursiveAction returns null;
      */
+    @Test
     public void testInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -264,6 +279,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -278,6 +294,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -293,6 +310,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join/quietlyJoin of a forked task succeeds in the presence of interrupts
      */
+    @Test
     public void testJoinIgnoresInterrupts() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -364,6 +382,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -379,6 +398,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -394,6 +414,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -410,6 +431,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -425,6 +447,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -442,6 +465,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -456,6 +480,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -474,6 +499,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -494,6 +520,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -514,6 +541,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -529,6 +557,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -547,6 +576,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -566,6 +596,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -585,6 +616,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -604,6 +636,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -619,6 +652,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -630,6 +664,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * A reinitialized normally completed task may be re-invoked
      */
+    @Test
     public void testReinitialize() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -650,6 +685,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * A reinitialized abnormally completed task may be re-invoked
      */
+    @Test
     public void testReinitializeAbnormal() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -673,6 +709,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -691,6 +728,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task suppresses execution invoking complete
      */
+    @Test
     public void testComplete() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -706,6 +744,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -723,6 +762,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -737,6 +777,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -760,6 +801,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -787,6 +829,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -804,6 +847,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -822,6 +866,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -839,6 +884,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -858,6 +904,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -987,6 +1034,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvokeCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1003,6 +1051,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvokeCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1017,6 +1066,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1032,6 +1082,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGetCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1047,6 +1098,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGetCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1062,6 +1114,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPECC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1078,6 +1131,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1093,6 +1147,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvokeCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1110,6 +1165,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvokeCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1124,6 +1180,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1142,6 +1199,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGetCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1162,6 +1220,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGetCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1182,6 +1241,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1197,6 +1257,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvokeCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1215,6 +1276,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1234,6 +1296,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGetCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1253,6 +1316,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGetCC() throws Exception {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1272,6 +1336,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoinCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1287,6 +1352,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1298,6 +1364,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1309,6 +1376,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * setRawResult(null) succeeds
      */
+    @Test
     public void testSetRawResultCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1321,6 +1389,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally2CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1339,6 +1408,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1356,6 +1426,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1370,6 +1441,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1390,6 +1462,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollectionCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1414,6 +1487,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPECC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1431,6 +1505,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1449,6 +1524,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1466,6 +1542,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3CC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1485,6 +1562,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollectionCC() {
         ForkJoinTask a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1509,6 +1587,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * awaitQuiescence by a worker is equivalent in effect to
      * ForkJoinTask.helpQuiesce()
      */
+    @Test
     public void testAwaitQuiescence1() throws Exception {
         final ForkJoinPool p = new ForkJoinPool();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -1560,6 +1639,7 @@ public class ForkJoinPool8Test extends JSR166TestCase {
      * awaitQuiescence returns when pool isQuiescent() or the indicated
      * timeout elapsed
      */
+    @Test
     public void testAwaitQuiescence2() throws Exception {
         /**
          * """It is possible to disable or limit the use of threads in the
diff --git a/ojluni/src/test/java/util/concurrent/tck/ForkJoinPoolTest.java b/ojluni/src/test/java/util/concurrent/tck/ForkJoinPoolTest.java
index d8ad1dd5fb5..f06393673cb 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ForkJoinPoolTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ForkJoinPoolTest.java
@@ -34,6 +34,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.security.PrivilegedAction;
 import java.security.PrivilegedExceptionAction;
@@ -55,18 +63,22 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReentrantLock;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ForkJoinPoolTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        return new TestSuite(ForkJoinPoolTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ForkJoinPoolTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ForkJoinPoolTest.class);
+    // }
 
     /*
      * Testing coverage notes:
@@ -184,6 +196,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
      * parallelism and async mode policies, no active threads or
      * tasks, and quiescent running state.
      */
+    @Test
     public void testDefaultInitialState() {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -204,6 +217,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Constructor throws if size argument is less than zero
      */
+    @Test
     public void testConstructor1() {
         try {
             new ForkJoinPool(-1);
@@ -214,6 +228,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Constructor throws if factory argument is null
      */
+    @Test
     public void testConstructor2() {
         try {
             new ForkJoinPool(1, null, null, false);
@@ -224,6 +239,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * getParallelism returns size set in constructor
      */
+    @Test
     public void testGetParallelism() {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -234,6 +250,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * getPoolSize returns number of started workers.
      */
+    @Test
     public void testGetPoolSize() {
         final CountDownLatch taskStarted = new CountDownLatch(1);
         final CountDownLatch done = new CountDownLatch(1);
@@ -260,6 +277,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * awaitTermination on a non-shutdown pool times out
      */
+    @Test
     public void testAwaitTermination_timesOut() throws InterruptedException {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -292,6 +310,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
      * Additionally tests: Overriding ForkJoinWorkerThread.onStart
      * performs its defined action
      */
+    @Test
     public void testSetUncaughtExceptionHandler() throws InterruptedException {
         final CountDownLatch uehInvoked = new CountDownLatch(1);
         final Thread.UncaughtExceptionHandler ueh =
@@ -320,6 +339,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
      * the task has completed successfully, and construction
      * parameters continue to hold
      */
+    @Test
     public void testIsQuiescent() throws Exception {
         ForkJoinPool p = new ForkJoinPool(2);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -331,7 +351,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
                        p.getFactory());
             while (! p.isQuiescent()) {
                 if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                    throw new AssertionFailedError("timed out");
+                    fail("timed out");
                 assertFalse(p.getAsyncMode());
                 assertFalse(p.isShutdown());
                 assertFalse(p.isTerminating());
@@ -359,6 +379,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Completed submit(ForkJoinTask) returns result
      */
+    @Test
     public void testSubmitForkJoinTask() throws Throwable {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -370,6 +391,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * A task submitted after shutdown is rejected
      */
+    @Test
     public void testSubmitAfterShutdown() {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -385,6 +407,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Pool maintains parallelism when using ManagedBlocker
      */
+    @Test
     public void testBlockingForkJoinTask() throws Throwable {
         ForkJoinPool p = new ForkJoinPool(4);
         try {
@@ -401,6 +424,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * pollSubmission returns unexecuted submitted task, if present
      */
+    @Test
     public void testPollSubmission() {
         final CountDownLatch done = new CountDownLatch(1);
         SubFJP p = new SubFJP();
@@ -418,6 +442,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * drainTasksTo transfers unexecuted submitted tasks, if present
      */
+    @Test
     public void testDrainTasksTo() {
         final CountDownLatch done = new CountDownLatch(1);
         SubFJP p = new SubFJP();
@@ -441,6 +466,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * execute(runnable) runs it to completion
      */
+    @Test
     public void testExecuteRunnable() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -460,6 +486,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Completed submit(callable) returns result
      */
+    @Test
     public void testSubmitCallable() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -473,6 +500,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Completed submit(runnable) returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -486,6 +514,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * Completed submit(runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -499,6 +528,8 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * A submitted privileged action runs to completion
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitPrivilegedAction() throws Exception {
         final Callable callable = Executors.callable(new PrivilegedAction() {
                 public Object run() { return TEST_STRING; }});
@@ -517,6 +548,8 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * A submitted privileged exception action runs to completion
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitPrivilegedExceptionAction() throws Exception {
         final Callable callable =
             Executors.callable(new PrivilegedExceptionAction() {
@@ -536,6 +569,8 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * A submitted failed privileged exception action reports exception
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testSubmitFailedPrivilegedExceptionAction() throws Exception {
         final Callable callable =
             Executors.callable(new PrivilegedExceptionAction() {
@@ -560,6 +595,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * execute(null runnable) throws NullPointerException
      */
+    @Test
     public void testExecuteNullRunnable() {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -573,6 +609,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * submit(null callable) throws NullPointerException
      */
+    @Test
     public void testSubmitNullCallable() {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -586,6 +623,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * submit(callable).get() throws InterruptedException if interrupted
      */
+    @Test
     public void testInterruptedSubmit() throws InterruptedException {
         final CountDownLatch submitted    = new CountDownLatch(1);
         final CountDownLatch quittingTime = new CountDownLatch(1);
@@ -613,6 +651,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
      * get of submit(callable) throws ExecutionException if callable
      * throws exception
      */
+    @Test
     public void testSubmitEE() throws Throwable {
         ForkJoinPool p = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -630,6 +669,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NullPointerException
      */
+    @Test
     public void testInvokeAny1() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -643,6 +683,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IllegalArgumentException
      */
+    @Test
     public void testInvokeAny2() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -656,6 +697,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NullPointerException if c has a single null element
      */
+    @Test
     public void testInvokeAny3() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -671,6 +713,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NullPointerException if c has null elements
      */
+    @Test
     public void testInvokeAny4() throws Throwable {
         CountDownLatch latch = new CountDownLatch(1);
         ExecutorService e = new ForkJoinPool(1);
@@ -689,6 +732,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task in c completes
      */
+    @Test
     public void testInvokeAny5() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -706,6 +750,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task in c if at least one completes
      */
+    @Test
     public void testInvokeAny6() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -720,6 +765,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NullPointerException
      */
+    @Test
     public void testInvokeAll1() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -733,6 +779,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws InterruptedException {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -745,6 +792,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NullPointerException if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws InterruptedException {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -762,6 +810,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
      * get of returned element of invokeAll(c) throws
      * ExecutionException on failed task
      */
+    @Test
     public void testInvokeAll4() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -781,6 +830,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks in c
      */
+    @Test
     public void testInvokeAll5() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -797,6 +847,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NullPointerException
      */
+    @Test
     public void testTimedInvokeAny1() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -810,6 +861,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(null time unit) throws NullPointerException
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -825,6 +877,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IllegalArgumentException
      */
+    @Test
     public void testTimedInvokeAny2() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -839,6 +892,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NullPointerException if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Throwable {
         CountDownLatch latch = new CountDownLatch(1);
         ExecutorService e = new ForkJoinPool(1);
@@ -857,6 +911,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -876,6 +931,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task in c
      */
+    @Test
     public void testTimedInvokeAny5() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -892,6 +948,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NullPointerException
      */
+    @Test
     public void testTimedInvokeAll1() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -905,6 +962,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAll(null time unit) throws NullPointerException
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -920,6 +978,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws InterruptedException {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -933,6 +992,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NullPointerException if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws InterruptedException {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -949,6 +1009,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * get of returned element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Throwable {
         ExecutorService e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -969,6 +1030,7 @@ public class ForkJoinPoolTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks in c
      */
+    @Test
     public void testTimedInvokeAll5() throws Throwable {
         ForkJoinPool e = new ForkJoinPool(1);
         try (PoolCleaner cleaner = cleaner(e)) {
diff --git a/ojluni/src/test/java/util/concurrent/tck/ForkJoinTask8Test.java b/ojluni/src/test/java/util/concurrent/tck/ForkJoinTask8Test.java
index bf9d17c1cb3..d49fd3a562e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ForkJoinTask8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ForkJoinTask8Test.java
@@ -34,6 +34,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
@@ -44,9 +52,12 @@ import java.util.concurrent.ForkJoinWorkerThread;
 import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.TimeoutException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ForkJoinTask8Test extends JSR166TestCase {
 
     /*
@@ -63,13 +74,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     static final short COMPLETE_STATE = 0;
     static final short EXCEPTION_STATE = 1;
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ForkJoinTask8Test");
     }
 
-    public static Test suite() {
-        return new TestSuite(ForkJoinTask8Test.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(ForkJoinTask8Test.class);
+    // }
 
     // Runs with "mainPool" use > 1 thread. singletonPool tests use 1
     static final int mainPoolSize =
@@ -402,13 +415,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvoke() {
         testInvoke(mainPool());
     }
+    @Test
     public void testInvoke_Singleton() {
         testInvoke(singletonPool());
     }
-    public void testInvoke(ForkJoinPool pool) {
+    private void testInvoke(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -423,13 +438,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         testQuietlyInvoke(mainPool());
     }
+    @Test
     public void testQuietlyInvoke_Singleton() {
         testQuietlyInvoke(singletonPool());
     }
-    public void testQuietlyInvoke(ForkJoinPool pool) {
+    private void testQuietlyInvoke(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -442,13 +459,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         testForkJoin(mainPool());
     }
+    @Test
     public void testForkJoin_Singleton() {
         testForkJoin(singletonPool());
     }
-    public void testForkJoin(ForkJoinPool pool) {
+    private void testForkJoin(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -462,13 +481,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         testForkGet(mainPool());
     }
+    @Test
     public void testForkGet_Singleton() {
         testForkGet(singletonPool());
     }
-    public void testForkGet(ForkJoinPool pool) {
+    private void testForkGet(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
                 AsyncFib f = new AsyncFib(8);
@@ -482,13 +503,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         testForkTimedGet(mainPool());
     }
+    @Test
     public void testForkTimedGet_Singleton() {
         testForkTimedGet(singletonPool());
     }
-    public void testForkTimedGet(ForkJoinPool pool) {
+    private void testForkTimedGet(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
                 AsyncFib f = new AsyncFib(8);
@@ -502,13 +525,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * timed get with null time unit throws NullPointerException
      */
+    @Test
     public void testForkTimedGetNullTimeUnit() {
         testForkTimedGetNullTimeUnit(mainPool());
     }
+    @Test
     public void testForkTimedGetNullTimeUnit_Singleton() {
         testForkTimedGet(singletonPool());
     }
-    public void testForkTimedGetNullTimeUnit(ForkJoinPool pool) {
+    private void testForkTimedGetNullTimeUnit(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
                 AsyncFib f = new AsyncFib(8);
@@ -524,13 +549,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         testForkQuietlyJoin(mainPool());
     }
+    @Test
     public void testForkQuietlyJoin_Singleton() {
         testForkQuietlyJoin(singletonPool());
     }
-    public void testForkQuietlyJoin(ForkJoinPool pool) {
+    private void testForkQuietlyJoin(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -545,13 +572,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesce() {
         testForkHelpQuiesce(mainPool());
     }
+    @Test
     public void testForkHelpQuiesce_Singleton() {
         testForkHelpQuiesce(singletonPool());
     }
-    public void testForkHelpQuiesce(ForkJoinPool pool) {
+    private void testForkHelpQuiesce(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -566,13 +595,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         testAbnormalInvoke(mainPool());
     }
+    @Test
     public void testAbnormalInvoke_Singleton() {
         testAbnormalInvoke(singletonPool());
     }
-    public void testAbnormalInvoke(ForkJoinPool pool) {
+    private void testAbnormalInvoke(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -589,13 +620,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         testAbnormalQuietlyInvoke(mainPool());
     }
+    @Test
     public void testAbnormalQuietlyInvoke_Singleton() {
         testAbnormalQuietlyInvoke(singletonPool());
     }
-    public void testAbnormalQuietlyInvoke(ForkJoinPool pool) {
+    private void testAbnormalQuietlyInvoke(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -609,13 +642,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         testAbnormalForkJoin(mainPool());
     }
+    @Test
     public void testAbnormalForkJoin_Singleton() {
         testAbnormalForkJoin(singletonPool());
     }
-    public void testAbnormalForkJoin(ForkJoinPool pool) {
+    private void testAbnormalForkJoin(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -633,13 +668,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         testAbnormalForkGet(mainPool());
     }
+    @Test
     public void testAbnormalForkGet_Singleton() {
         testAbnormalForkJoin(singletonPool());
     }
-    public void testAbnormalForkGet(ForkJoinPool pool) {
+    private void testAbnormalForkGet(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -659,13 +696,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         testAbnormalForkTimedGet(mainPool());
     }
+    @Test
     public void testAbnormalForkTimedGet_Singleton() {
         testAbnormalForkTimedGet(singletonPool());
     }
-    public void testAbnormalForkTimedGet(ForkJoinPool pool) {
+    private void testAbnormalForkTimedGet(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -685,13 +724,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         testAbnormalForkQuietlyJoin(mainPool());
     }
+    @Test
     public void testAbnormalForkQuietlyJoin_Singleton() {
         testAbnormalForkQuietlyJoin(singletonPool());
     }
-    public void testAbnormalForkQuietlyJoin(ForkJoinPool pool) {
+    private void testAbnormalForkQuietlyJoin(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -706,13 +747,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * getPool of executing task returns its pool
      */
+    @Test
     public void testGetPool() {
         testGetPool(mainPool());
     }
+    @Test
     public void testGetPool_Singleton() {
         testGetPool(singletonPool());
     }
-    public void testGetPool(ForkJoinPool pool) {
+    private void testGetPool(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 assertSame(pool, getPool());
@@ -723,6 +766,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -734,13 +778,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * inForkJoinPool of executing task returns true
      */
+    @Test
     public void testInForkJoinPool() {
         testInForkJoinPool(mainPool());
     }
+    @Test
     public void testInForkJoinPool_Singleton() {
         testInForkJoinPool(singletonPool());
     }
-    public void testInForkJoinPool(ForkJoinPool pool) {
+    private void testInForkJoinPool(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 assertTrue(inForkJoinPool());
@@ -751,6 +797,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -762,6 +809,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * setRawResult(null) succeeds
      */
+    @Test
     public void testSetRawResult() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -774,13 +822,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         testCompleteExceptionally(mainPool());
     }
+    @Test
     public void testCompleteExceptionally_Singleton() {
         testCompleteExceptionally(singletonPool());
     }
-    public void testCompleteExceptionally(ForkJoinPool pool) {
+    private void testCompleteExceptionally(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -798,13 +848,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         testInvokeAll1(mainPool());
     }
+    @Test
     public void testInvokeAll1_Singleton() {
         testInvokeAll1(singletonPool());
     }
-    public void testInvokeAll1(ForkJoinPool pool) {
+    private void testInvokeAll1(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -817,13 +869,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         testInvokeAll2(mainPool());
     }
+    @Test
     public void testInvokeAll2_Singleton() {
         testInvokeAll2(singletonPool());
     }
-    public void testInvokeAll2(ForkJoinPool pool) {
+    private void testInvokeAll2(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib[] tasks = {
@@ -840,13 +894,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         testInvokeAll3(mainPool());
     }
+    @Test
     public void testInvokeAll3_Singleton() {
         testInvokeAll3(singletonPool());
     }
-    public void testInvokeAll3(ForkJoinPool pool) {
+    private void testInvokeAll3(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib[] tasks = {
@@ -864,13 +920,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         testInvokeAllCollection(mainPool());
     }
+    @Test
     public void testInvokeAllCollection_Singleton() {
         testInvokeAllCollection(singletonPool());
     }
-    public void testInvokeAllCollection(ForkJoinPool pool) {
+    private void testInvokeAllCollection(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib[] tasks = {
@@ -888,13 +946,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NullPointerException
      */
+    @Test
     public void testInvokeAllNullTask() {
         testInvokeAllNullTask(mainPool());
     }
+    @Test
     public void testInvokeAllNullTask_Singleton() {
         testInvokeAllNullTask(singletonPool());
     }
-    public void testInvokeAllNullTask(ForkJoinPool pool) {
+    private void testInvokeAllNullTask(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib nul = null;
@@ -913,13 +973,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         testAbnormalInvokeAll1(mainPool());
     }
+    @Test
     public void testAbnormalInvokeAll1_Singleton() {
         testAbnormalInvokeAll1(singletonPool());
     }
-    public void testAbnormalInvokeAll1(ForkJoinPool pool) {
+    private void testAbnormalInvokeAll1(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib g = new FailingAsyncFib(9);
@@ -936,13 +998,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         testAbnormalInvokeAll2(mainPool());
     }
+    @Test
     public void testAbnormalInvokeAll2_Singleton() {
         testAbnormalInvokeAll2(singletonPool());
     }
-    public void testAbnormalInvokeAll2(ForkJoinPool pool) {
+    private void testAbnormalInvokeAll2(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -962,13 +1026,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         testAbnormalInvokeAll3(mainPool());
     }
+    @Test
     public void testAbnormalInvokeAll3_Singleton() {
         testAbnormalInvokeAll3(singletonPool());
     }
-    public void testAbnormalInvokeAll3(ForkJoinPool pool) {
+    private void testAbnormalInvokeAll3(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 AsyncFib f = new AsyncFib(8);
@@ -989,13 +1055,15 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         testAbnormalInvokeAllCollection(mainPool());
     }
+    @Test
     public void testAbnormalInvokeAllCollection_Singleton() {
         testAbnormalInvokeAllCollection(singletonPool());
     }
-    public void testAbnormalInvokeAllCollection(ForkJoinPool pool) {
+    private void testAbnormalInvokeAllCollection(ForkJoinPool pool) {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
                 FailingAsyncFib f = new FailingAsyncFib(8);
@@ -1017,6 +1085,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * tryUnfork returns true for most recent unexecuted task,
      * and suppresses execution
      */
+    @Test
     public void testTryUnfork() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1036,6 +1105,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * getSurplusQueuedTaskCount returns > 0 when
      * there are more tasks than threads
      */
+    @Test
     public void testGetSurplusQueuedTaskCount() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1058,6 +1128,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * peekNextLocalTask returns most recent unexecuted task.
      */
+    @Test
     public void testPeekNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1078,6 +1149,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * pollNextLocalTask returns most recent unexecuted task without
      * executing it
      */
+    @Test
     public void testPollNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1096,6 +1168,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * pollTask returns an unexecuted task without executing it
      */
+    @Test
     public void testPollTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1114,6 +1187,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * peekNextLocalTask returns least recent unexecuted task in async mode
      */
+    @Test
     public void testPeekNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1134,6 +1208,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * pollNextLocalTask returns least recent unexecuted task without
      * executing it, in async mode
      */
+    @Test
     public void testPollNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1153,6 +1228,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * pollTask returns an unexecuted task without executing it, in
      * async mode
      */
+    @Test
     public void testPollTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1174,6 +1250,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
      * established by setRawResult(V) (or null by default) is returned
      * from invoke.
      */
+    @Test
     public void testQuietlyComplete() {
         RecursiveAction a = new CheckedRecursiveAction() {
                 protected void realCompute() {
@@ -1194,6 +1271,7 @@ public class ForkJoinTask8Test extends JSR166TestCase {
     /**
      * pollSubmission returns unexecuted submitted task, if present
      */
+    @Test
     public void testPollSubmission() {
         final CountDownLatch done = new CountDownLatch(1);
         final ForkJoinTask a = ForkJoinTask.adapt(awaiter(done));
diff --git a/ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java b/ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java
index 2255fda7c21..f1bd06899c0 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java
@@ -34,6 +34,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.HashSet;
@@ -45,18 +53,23 @@ import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ForkJoinTaskTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ForkJoinTaskTest");
     }
 
-    public static Test suite() {
-        return new TestSuite(ForkJoinTaskTest.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(ForkJoinTaskTest.class);
+    // }
 
     // Runs with "mainPool" use > 1 thread. singletonPool tests use 1
     static final int mainPoolSize =
@@ -412,6 +425,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -428,6 +442,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -442,6 +457,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -457,6 +473,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -472,6 +489,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -487,6 +505,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -503,6 +522,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -519,6 +539,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesce() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -535,6 +556,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -552,6 +574,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -566,6 +589,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -584,6 +608,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -604,6 +629,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -624,6 +650,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -639,6 +666,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -657,6 +685,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -676,6 +705,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -695,6 +725,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGet() throws Exception {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -714,6 +745,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -729,6 +761,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * getPool of executing task returns its pool
      */
+    @Test
     public void testGetPool() {
         final ForkJoinPool mainPool = mainPool();
         RecursiveAction a = new CheckedRecursiveAction() {
@@ -741,6 +774,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -752,6 +786,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * inForkJoinPool of executing task returns true
      */
+    @Test
     public void testInForkJoinPool() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -763,6 +798,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -774,6 +810,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * setRawResult(null) succeeds
      */
+    @Test
     public void testSetRawResult() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -786,6 +823,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -805,6 +843,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * completeExceptionally(null) surprisingly has the same effect as
      * completeExceptionally(new RuntimeException())
      */
+    @Test
     public void testCompleteExceptionally_null() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -825,6 +864,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -842,6 +882,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -856,6 +897,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -876,6 +918,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -900,6 +943,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -917,6 +961,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -937,6 +982,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -954,6 +1000,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -975,6 +1022,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -997,6 +1045,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * tryUnfork returns true for most recent unexecuted task,
      * and suppresses execution
      */
+    @Test
     public void testTryUnfork() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1016,6 +1065,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * getSurplusQueuedTaskCount returns > 0 when
      * there are more tasks than threads
      */
+    @Test
     public void testGetSurplusQueuedTaskCount() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1038,6 +1088,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns most recent unexecuted task.
      */
+    @Test
     public void testPeekNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1058,6 +1109,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * pollNextLocalTask returns most recent unexecuted task without
      * executing it
      */
+    @Test
     public void testPollNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1077,6 +1129,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * pollTask returns an unexecuted task without executing it
      */
+    @Test
     public void testPollTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1095,6 +1148,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns least recent unexecuted task in async mode
      */
+    @Test
     public void testPeekNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1116,6 +1170,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * pollNextLocalTask returns least recent unexecuted task without
      * executing it, in async mode
      */
+    @Test
     public void testPollNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1136,6 +1191,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * pollTask returns an unexecuted task without executing it, in
      * async mode
      */
+    @Test
     public void testPollTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1159,6 +1215,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks; getRawResult returns null.
      */
+    @Test
     public void testInvokeSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1175,6 +1232,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvokeSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1189,6 +1247,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1204,6 +1263,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGetSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1219,6 +1279,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGetSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1234,6 +1295,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPESingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1250,6 +1312,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1266,6 +1329,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesceSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1282,6 +1346,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvokeSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1299,6 +1364,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvokeSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1313,6 +1379,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1331,6 +1398,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGetSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1351,6 +1419,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGetSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1371,6 +1440,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1386,6 +1456,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvokeSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1404,6 +1475,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1423,6 +1495,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGetSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1442,6 +1515,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGetSingleton() throws Exception {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -1461,6 +1535,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoinSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1476,6 +1551,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionallySingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1494,6 +1570,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1511,6 +1588,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1525,6 +1603,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1545,6 +1624,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollectionSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1569,6 +1649,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPESingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1586,6 +1667,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1606,6 +1688,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1623,6 +1706,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3Singleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1644,6 +1728,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollectionSingleton() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1668,6 +1753,7 @@ public class ForkJoinTaskTest extends JSR166TestCase {
      * established by setRawResult(V) (or null by default) is returned
      * from invoke.
      */
+    @Test
     public void testQuietlyComplete() {
         RecursiveAction a = new CheckedRecursiveAction() {
                 protected void realCompute() {
diff --git a/ojluni/src/test/java/util/concurrent/tck/FutureTaskTest.java b/ojluni/src/test/java/util/concurrent/tck/FutureTaskTest.java
index 40f0a841618..11d8ce9b26a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/FutureTaskTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/FutureTaskTest.java
@@ -37,6 +37,14 @@ package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -52,17 +60,21 @@ import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class FutureTaskTest extends JSR166TestCase {
-
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(FutureTaskTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.FutureTaskTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(FutureTaskTest.class);
+    // }
 
     void checkIsDone(Future<?> f) {
         assertTrue(f.isDone());
@@ -258,6 +270,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * creating a future with a null callable throws NullPointerException
      */
+    @Test
     public void testConstructor() {
         try {
             new FutureTask(null);
@@ -268,6 +281,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * creating a future with null runnable throws NullPointerException
      */
+    @Test
     public void testConstructor2() {
         try {
             new FutureTask(null, Boolean.TRUE);
@@ -278,6 +292,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * isDone is true when a task completes
      */
+    @Test
     public void testIsDone() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         assertFalse(task.isDone());
@@ -290,6 +305,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * runAndReset of a non-cancelled task succeeds
      */
+    @Test
     public void testRunAndReset() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         for (int i = 0; i < 3; i++) {
@@ -305,6 +321,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * runAndReset after cancellation fails
      */
+    @Test
     public void testRunAndResetAfterCancel() {
         for (boolean mayInterruptIfRunning : new boolean[] { true, false }) {
             PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
@@ -324,6 +341,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * setting value causes get to return it
      */
+    @Test
     public void testSet() throws Exception {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         task.set(one);
@@ -340,6 +358,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * setException causes get to throw ExecutionException
      */
+    @Test
     public void testSetException_get() throws Exception {
         Exception nse = new NoSuchElementException();
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
@@ -371,6 +390,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(false) before run succeeds
      */
+    @Test
     public void testCancelBeforeRun() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         assertTrue(task.cancel(false));
@@ -388,6 +408,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(true) before run succeeds
      */
+    @Test
     public void testCancelBeforeRun2() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         assertTrue(task.cancel(true));
@@ -405,6 +426,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(false) of a completed task fails
      */
+    @Test
     public void testCancelAfterRun() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         task.run();
@@ -420,6 +442,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(true) of a completed task fails
      */
+    @Test
     public void testCancelAfterRun2() {
         PublicFutureTask task = new PublicFutureTask(new NoOpCallable());
         task.run();
@@ -435,6 +458,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(true) interrupts a running task that subsequently succeeds
      */
+    @Test
     public void testCancelInterrupt() {
         final CountDownLatch pleaseCancel = new CountDownLatch(1);
         final PublicFutureTask task =
@@ -465,6 +489,7 @@ public class FutureTaskTest extends JSR166TestCase {
      * Thread.interrupt throws (simulating a restrictive security
      * manager)
      */
+    @Test
     public void testCancelInterrupt_ThrowsSecurityException() {
         final CountDownLatch pleaseCancel = new CountDownLatch(1);
         final CountDownLatch cancelled = new CountDownLatch(1);
@@ -509,6 +534,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(true) interrupts a running task that subsequently throws
      */
+    @Test
     public void testCancelInterrupt_taskFails() {
         final CountDownLatch pleaseCancel = new CountDownLatch(1);
         final PublicFutureTask task =
@@ -538,6 +564,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * cancel(false) does not interrupt a running task
      */
+    @Test
     public void testCancelNoInterrupt() {
         final CountDownLatch pleaseCancel = new CountDownLatch(1);
         final CountDownLatch cancelled = new CountDownLatch(1);
@@ -566,6 +593,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * run in one thread causes get in another thread to retrieve value
      */
+    @Test
     public void testGetRun() {
         final CountDownLatch pleaseRun = new CountDownLatch(2);
 
@@ -605,6 +633,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * set in one thread causes get in another thread to retrieve value
      */
+    @Test
     public void testGetSet() {
         final CountDownLatch pleaseSet = new CountDownLatch(2);
 
@@ -644,13 +673,15 @@ public class FutureTaskTest extends JSR166TestCase {
      * Cancelling a task causes timed get in another thread to throw
      * CancellationException
      */
+    @Test
     public void testTimedGet_Cancellation() {
         testTimedGet_Cancellation(false);
     }
+    @Test
     public void testTimedGet_Cancellation_interrupt() {
         testTimedGet_Cancellation(true);
     }
-    public void testTimedGet_Cancellation(final boolean mayInterruptIfRunning) {
+    private void testTimedGet_Cancellation(final boolean mayInterruptIfRunning) {
         final CountDownLatch pleaseCancel = new CountDownLatch(3);
         final CountDownLatch cancelled = new CountDownLatch(1);
         final Callable<Object> callable =
@@ -699,6 +730,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * A runtime exception in task causes get to throw ExecutionException
      */
+    @Test
     public void testGet_ExecutionException() throws InterruptedException {
         final ArithmeticException e = new ArithmeticException();
         final PublicFutureTask task = new PublicFutureTask(new Callable() {
@@ -723,6 +755,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * A runtime exception in task causes timed get to throw ExecutionException
      */
+    @Test
     public void testTimedGet_ExecutionException2() throws Exception {
         final ArithmeticException e = new ArithmeticException();
         final PublicFutureTask task = new PublicFutureTask(new Callable() {
@@ -744,6 +777,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * get is interruptible
      */
+    @Test
     public void testGet_interruptible() {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         final FutureTask task = new FutureTask(new NoOpCallable());
@@ -773,6 +807,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * timed get is interruptible
      */
+    @Test
     public void testTimedGet_interruptible() {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         final FutureTask task = new FutureTask(new NoOpCallable());
@@ -802,6 +837,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * A timed out timed get throws TimeoutException
      */
+    @Test
     public void testGet_TimeoutException() throws Exception {
         FutureTask task = new FutureTask(new NoOpCallable());
         long startTime = System.nanoTime();
@@ -816,6 +852,7 @@ public class FutureTaskTest extends JSR166TestCase {
     /**
      * timed get with null TimeUnit throws NullPointerException
      */
+    @Test
     public void testGet_NullTimeUnit() throws Exception {
         FutureTask task = new FutureTask(new NoOpCallable());
         long[] timeouts = { Long.MIN_VALUE, 0L, Long.MAX_VALUE };
@@ -841,6 +878,7 @@ public class FutureTaskTest extends JSR166TestCase {
      * timed get with most negative timeout works correctly (i.e. no
      * underflow bug)
      */
+    @Test
     public void testGet_NegativeInfinityTimeout() throws Exception {
         final ExecutorService pool = Executors.newFixedThreadPool(10);
         final Runnable nop = new Runnable() { public void run() {}};
diff --git a/ojluni/src/test/java/util/concurrent/tck/JSR166TestCase.java b/ojluni/src/test/java/util/concurrent/tck/JSR166TestCase.java
index 62d293cc87b..ed75717b03d 100644
--- a/ojluni/src/test/java/util/concurrent/tck/JSR166TestCase.java
+++ b/ojluni/src/test/java/util/concurrent/tck/JSR166TestCase.java
@@ -69,6 +69,15 @@ package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -123,11 +132,12 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestResult;
-import junit.framework.TestSuite;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+import org.junit.runners.Suite.SuiteClasses;
 
 /**
  * Base class for JSR166 Junit TCK tests.  Defines some constants,
@@ -201,7 +211,118 @@ import junit.framework.TestSuite;
  *
  * </ul>
  */
-public class JSR166TestCase extends TestCase {
+// Android-changed: Use JUnit4.
+@RunWith(Suite.class)
+@SuiteClasses({
+    ForkJoinPoolTest.class,
+    ForkJoinTaskTest.class,
+    RecursiveActionTest.class,
+    RecursiveTaskTest.class,
+    LinkedTransferQueueTest.class,
+    LinkedTransferQueueTest.Generic.class,
+    PhaserTest.class,
+    ThreadLocalRandomTest.class,
+    AbstractExecutorServiceTest.class,
+    AbstractQueueTest.class,
+    AbstractQueuedSynchronizerTest.class,
+    AbstractQueuedLongSynchronizerTest.class,
+    ArrayBlockingQueueTest.class,
+    ArrayBlockingQueueTest.Fair.class,
+    ArrayBlockingQueueTest.NonFair.class,
+    ArrayDequeTest.class,
+    // ArrayListTest.class,
+    AtomicBooleanTest.class,
+    AtomicIntegerArrayTest.class,
+    AtomicIntegerFieldUpdaterTest.class,
+    AtomicIntegerTest.class,
+    AtomicLongArrayTest.class,
+    AtomicLongFieldUpdaterTest.class,
+    AtomicLongTest.class,
+    AtomicMarkableReferenceTest.class,
+    AtomicReferenceArrayTest.class,
+    AtomicReferenceFieldUpdaterTest.class,
+    AtomicReferenceTest.class,
+    AtomicStampedReferenceTest.class,
+    ConcurrentHashMapTest.class,
+    ConcurrentLinkedDequeTest.class,
+    ConcurrentLinkedQueueTest.class,
+    ConcurrentSkipListMapTest.class,
+    ConcurrentSkipListSubMapTest.class,
+    ConcurrentSkipListSetTest.class,
+    ConcurrentSkipListSubSetTest.class,
+    CopyOnWriteArrayListTest.class,
+    CopyOnWriteArraySetTest.class,
+    CountDownLatchTest.class,
+    CountedCompleterTest.class,
+    CyclicBarrierTest.class,
+    DelayQueueTest.class,
+    DelayQueueTest.Generic.class,
+    EntryTest.class,
+    ExchangerTest.class,
+    ExecutorsTest.class,
+    ExecutorCompletionServiceTest.class,
+    FutureTaskTest.class,
+    LinkedBlockingDequeTest.class,
+    LinkedBlockingDequeTest.Unbounded.class,
+    LinkedBlockingDequeTest.Bounded.class,
+    LinkedBlockingQueueTest.class,
+    LinkedBlockingQueueTest.Unbounded.class,
+    LinkedBlockingQueueTest.Bounded.class,
+    LinkedListTest.class,
+    LockSupportTest.class,
+    PriorityBlockingQueueTest.class,
+    PriorityBlockingQueueTest.Generic.class,
+    PriorityBlockingQueueTest.InitialCapacity.class,
+    PriorityQueueTest.class,
+    ReentrantLockTest.class,
+    ReentrantReadWriteLockTest.class,
+    ScheduledExecutorTest.class,
+    ScheduledExecutorSubclassTest.class,
+    SemaphoreTest.class,
+    SynchronousQueueTest.class,
+    SynchronousQueueTest.Fair.class,
+    SynchronousQueueTest.NonFair.class,
+    SystemTest.class,
+    ThreadLocalTest.class,
+    ThreadPoolExecutorTest.class,
+    ThreadPoolExecutorSubclassTest.class,
+    ThreadTest.class,
+    TimeUnitTest.class,
+    TreeMapTest.class,
+    TreeSetTest.class,
+    TreeSubMapTest.class,
+    TreeSubSetTest.class,
+    VectorTest.class,
+    ArrayDeque8Test.class,
+    Atomic8Test.class,
+    CompletableFutureTest.class,
+    ConcurrentHashMap8Test.class,
+    CountedCompleter8Test.class,
+    DoubleAccumulatorTest.class,
+    DoubleAdderTest.class,
+    ForkJoinPool8Test.class,
+    ForkJoinTask8Test.class,
+    LinkedBlockingDeque8Test.class,
+    LinkedBlockingQueue8Test.class,
+    LongAccumulatorTest.class,
+    LongAdderTest.class,
+    SplittableRandomTest.class,
+    StampedLockTest.class,
+    SubmissionPublisherTest.class,
+    ThreadLocalRandom8Test.class,
+    TimeUnit8Test.class,
+    // AtomicBoolean9Test.class,
+    // AtomicInteger9Test.class,
+    // AtomicIntegerArray9Test.class,
+    // AtomicLong9Test.class,
+    // AtomicLongArray9Test.class,
+    // AtomicReference9Test.class,
+    // AtomicReferenceArray9Test.class,
+    // ExecutorCompletionService9Test.class,
+    // ForkJoinPool9Test.class,
+    SubmissionPublisherTest.class,
+})
+public class JSR166TestCase {
     private static final boolean useSecurityManager =
         Boolean.getBoolean("jsr166.useSecurityManager");
 
@@ -279,9 +400,6 @@ public class JSR166TestCase extends TestCase {
         return 1.0f;
     }
 
-    public JSR166TestCase() { super(); }
-    public JSR166TestCase(String name) { super(name); }
-
     /**
      * A filter for tests to run, matching strings of the form
      * methodName(className), e.g. "testInvokeAll5(ForkJoinPoolTest)"
@@ -294,6 +412,8 @@ public class JSR166TestCase extends TestCase {
         return (regex == null) ? null : Pattern.compile(regex);
     }
 
+    // BEGIN Android-removed: Usage of TestCase.
+    /*
     // Instrumentation to debug very rare, but very annoying hung test runs.
     static volatile TestCase currentTestCase;
     // static volatile int currentRun = 0;
@@ -327,6 +447,8 @@ public class JSR166TestCase extends TestCase {
         thread.setDaemon(true);
         thread.start();
     }
+     */
+    // END Android-removed: Usage of TestCase.
 
 //     public static String cpuModel() {
 //         try {
@@ -338,6 +460,8 @@ public class JSR166TestCase extends TestCase {
 //         } catch (Exception ex) { return null; }
 //     }
 
+    // BEGIN Android-removed: Not used for JUnit4.
+    /*
     public void runBare() throws Throwable {
         currentTestCase = this;
         if (methodFilter == null
@@ -368,14 +492,20 @@ public class JSR166TestCase extends TestCase {
                 System.out.printf("%n%s: %d%n", toString(), elapsedMillis);
         }
     }
+    */
+    // END Android-removed: Not used for JUnit4.
 
     /**
      * Runs all JSR166 unit tests using junit.textui.TestRunner.
      */
     public static void main(String[] args) {
-        main(suite(), args);
+        // Android-changed: Use JUnitCore.main.
+        // main(suite(), args);
+        // org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.JSR166TestCase");
     }
 
+    // BEGIN Android-removed: Not needed for JUnit4.
+    /*
     static class PithyResultPrinter extends junit.textui.ResultPrinter {
         PithyResultPrinter(java.io.PrintStream writer) { super(writer); }
         long runTime;
@@ -397,7 +527,7 @@ public class JSR166TestCase extends TestCase {
     /**
      * Returns a TestRunner that doesn't bother with unnecessary
      * fluff, like printing a "." for each test case.
-     */
+     * /
     static junit.textui.TestRunner newPithyTestRunner() {
         junit.textui.TestRunner runner = new junit.textui.TestRunner();
         runner.setPrinter(new PithyResultPrinter(System.out));
@@ -407,7 +537,7 @@ public class JSR166TestCase extends TestCase {
     /**
      * Runs all unit tests in the given test suite.
      * Actual behavior influenced by jsr166.* system properties.
-     */
+     * /
     static void main(Test suite, String[] args) {
         if (useSecurityManager) {
             System.err.println("Setting a permissive security manager");
@@ -454,6 +584,8 @@ public class JSR166TestCase extends TestCase {
             }
         }
     }
+    */
+    // END Android-removed: Not needed for JUnit4.
 
     public static final double JAVA_CLASS_VERSION;
     public static final String JAVA_SPECIFICATION_VERSION;
@@ -485,9 +617,11 @@ public class JSR166TestCase extends TestCase {
             || JAVA_SPECIFICATION_VERSION.matches("^(1\\.)?[0-9][0-9]$");
     }
 
+    // BEGIN Android-removed: Use JUnit4's SuiteClasses annotation.
+    /*
     /**
      * Collects all JSR166 unit tests as one suite.
-     */
+     * /
     public static Test suite() {
         // Java7+ test classes
         TestSuite suite = newTestSuite(
@@ -604,7 +738,7 @@ public class JSR166TestCase extends TestCase {
         return suite;
     }
 
-    /** Returns list of junit-style test method names in given class. */
+    /** Returns list of junit-style test method names in given class. * /
     public static ArrayList<String> testMethodNames(Class<?> testClass) {
         Method[] methods = testClass.getDeclaredMethods();
         ArrayList<String> names = new ArrayList<>(methods.length);
@@ -622,7 +756,7 @@ public class JSR166TestCase extends TestCase {
     /**
      * Returns junit-style testSuite for the given test class, but
      * parameterized by passing extra data to each test.
-     */
+     * /
     public static <ExtraData> Test parameterizedTestSuite
         (Class<? extends JSR166TestCase> testClass,
          Class<ExtraData> dataClass,
@@ -643,7 +777,7 @@ public class JSR166TestCase extends TestCase {
      * Returns junit-style testSuite for the jdk8 extension of the
      * given test class, but parameterized by passing extra data to
      * each test.  Uses reflection to allow compilation in jdk7.
-     */
+     * /
     public static <ExtraData> Test jdk8ParameterizedTestSuite
         (Class<? extends JSR166TestCase> testClass,
          Class<ExtraData> dataClass,
@@ -664,6 +798,8 @@ public class JSR166TestCase extends TestCase {
             return new TestSuite();
         }
     }
+    */
+    // END Android-removed: Use JUnit4's SuiteClasses annotation.
 
     // Delays for timing-dependent tests, in milliseconds.
 
@@ -760,6 +896,7 @@ public class JSR166TestCase extends TestCase {
         threadFailure.compareAndSet(null, t);
     }
 
+    @Before
     public void setUp() {
         setDelays();
     }
@@ -768,7 +905,7 @@ public class JSR166TestCase extends TestCase {
         String msg = toString() + ": " + String.format(format, args);
         System.err.println(msg);
         dumpTestThreads();
-        throw new AssertionFailedError(msg);
+        fail(msg);
     }
 
     /**
@@ -780,6 +917,7 @@ public class JSR166TestCase extends TestCase {
      *
      * Triggers test case failure if interrupt status is set in the main thread.
      */
+    @After
     public void tearDown() throws Exception {
         Throwable t = threadFailure.getAndSet(null);
         if (t != null) {
@@ -790,10 +928,7 @@ public class JSR166TestCase extends TestCase {
             else if (t instanceof Exception)
                 throw (Exception) t;
             else {
-                AssertionFailedError afe =
-                    new AssertionFailedError(t.toString());
-                afe.initCause(t);
-                throw afe;
+                failWithCause(t);
             }
         }
 
@@ -803,6 +938,20 @@ public class JSR166TestCase extends TestCase {
         checkForkJoinPoolThreadLeaks();
     }
 
+    // Android-added: Mechanism for throwing a failure with a specified cause
+    // This is needed since AssertionFailedError has been removed in JUnit 4.
+    public static void failWithCause(Throwable cause, String msg) {
+        try {
+            fail(msg);
+        } catch (Throwable afe) {
+            afe.initCause(cause);
+            throw afe;
+        }
+    }
+    public static void failWithCause(Throwable cause) {
+        failWithCause(cause, cause.toString());
+    }
+
     /**
      * Finds missing PoolCleaners
      */
@@ -828,13 +977,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like fail(reason), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadFail(String reason) {
         try {
             fail(reason);
-        } catch (AssertionFailedError t) {
+        } catch (AssertionError t) {
             threadRecordFailure(t);
             throw t;
         }
@@ -842,13 +991,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertTrue(b), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertTrue(boolean b) {
         try {
             assertTrue(b);
-        } catch (AssertionFailedError t) {
+        } catch (AssertionError t) {
             threadRecordFailure(t);
             throw t;
         }
@@ -856,13 +1005,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertFalse(b), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertFalse(boolean b) {
         try {
             assertFalse(b);
-        } catch (AssertionFailedError t) {
+        } catch (AssertionError t) {
             threadRecordFailure(t);
             throw t;
         }
@@ -870,13 +1019,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertNull(x), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertNull(Object x) {
         try {
             assertNull(x);
-        } catch (AssertionFailedError t) {
+        } catch (AssertionError t) {
             threadRecordFailure(t);
             throw t;
         }
@@ -884,13 +1033,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertEquals(x, y), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertEquals(long x, long y) {
         try {
             assertEquals(x, y);
-        } catch (AssertionFailedError t) {
+        } catch (AssertionError t) {
             threadRecordFailure(t);
             throw t;
         }
@@ -898,13 +1047,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertEquals(x, y), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertEquals(Object x, Object y) {
         try {
             assertEquals(x, y);
-        } catch (AssertionFailedError fail) {
+        } catch (AssertionError fail) {
             threadRecordFailure(fail);
             throw fail;
         } catch (Throwable fail) {
@@ -914,13 +1063,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Just like assertSame(x, y), but additionally recording (using
-     * threadRecordFailure) any AssertionFailedError thrown, so that
+     * threadRecordFailure) any AssertionError thrown, so that
      * the current testcase will fail.
      */
     public void threadAssertSame(Object x, Object y) {
         try {
             assertSame(x, y);
-        } catch (AssertionFailedError fail) {
+        } catch (AssertionError fail) {
             threadRecordFailure(fail);
             throw fail;
         }
@@ -943,7 +1092,7 @@ public class JSR166TestCase extends TestCase {
     /**
      * Records the given exception using {@link #threadRecordFailure},
      * then rethrows the exception, wrapping it in an
-     * AssertionFailedError if necessary.
+     * AssertionError if necessary.
      */
     public void threadUnexpectedException(Throwable t) {
         threadRecordFailure(t);
@@ -953,10 +1102,7 @@ public class JSR166TestCase extends TestCase {
         else if (t instanceof Error)
             throw (Error) t;
         else {
-            AssertionFailedError afe =
-                new AssertionFailedError("unexpected exception: " + t);
-            afe.initCause(t);
-            throw afe;
+            failWithCause(t, "unexpected exception: " + t);
         }
     }
 
@@ -1068,7 +1214,7 @@ public class JSR166TestCase extends TestCase {
      * Useful for running multiple variants of tests that are
      * necessarily individually slow because they must block.
      */
-    void testInParallel(Action ... actions) {
+    protected void testInParallel(Action ... actions) {
         ExecutorService pool = Executors.newCachedThreadPool();
         try (PoolCleaner cleaner = cleaner(pool)) {
             ArrayList<Future<?>> futures = new ArrayList<>(actions.length);
@@ -1462,16 +1608,13 @@ public class JSR166TestCase extends TestCase {
 
     /**
      * Sleeps until the given time has elapsed.
-     * Throws AssertionFailedError if interrupted.
+     * Throws AssertionError if interrupted.
      */
     static void sleep(long millis) {
         try {
             delay(millis);
         } catch (InterruptedException fail) {
-            AssertionFailedError afe =
-                new AssertionFailedError("Unexpected InterruptedException");
-            afe.initCause(fail);
-            throw afe;
+            failWithCause(fail, "Unexpected InterruptedException");
         }
     }
 
@@ -1579,7 +1722,7 @@ public class JSR166TestCase extends TestCase {
             assertEquals(expectedValue, f.get(timeoutMillis, MILLISECONDS));
         } catch (Throwable fail) { threadUnexpectedException(fail); }
         if (millisElapsedSince(startTime) > timeoutMillis/2)
-            throw new AssertionFailedError("timed get did not return promptly");
+            fail("timed get did not return promptly");
     }
 
     <T> void checkTimedGet(Future<T> f, T expectedValue) {
@@ -2030,13 +2173,11 @@ public class JSR166TestCase extends TestCase {
             try {
                 return super.await(2 * LONG_DELAY_MS, MILLISECONDS);
             } catch (TimeoutException timedOut) {
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             } catch (Exception fail) {
-                AssertionFailedError afe =
-                    new AssertionFailedError("Unexpected exception: " + fail);
-                afe.initCause(fail);
-                throw afe;
+                failWithCause(fail, "Unexpected exception: " + fail);
             }
+            return -1;
         }
     }
 
@@ -2159,12 +2300,8 @@ public class JSR166TestCase extends TestCase {
             catch (Throwable t) {
                 threw = true;
                 if (!expectedExceptionClass.isInstance(t)) {
-                    AssertionFailedError afe =
-                        new AssertionFailedError
-                        ("Expected " + expectedExceptionClass.getName() +
-                         ", got " + t.getClass().getName());
-                    afe.initCause(t);
-                    threadUnexpectedException(afe);
+                    failWithCause(t, "Expected " + expectedExceptionClass.getName() +
+                            ", got " + t.getClass().getName());
                 }
             }
             if (!threw)
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDeque8Test.java b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDeque8Test.java
index 29b2704ec6d..0bea784cba1 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDeque8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDeque8Test.java
@@ -33,24 +33,38 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.Spliterator;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedBlockingDeque8Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        return newTestSuite(LinkedBlockingDeque8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedBlockingDeque8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(LinkedBlockingDeque8Test.class);
+    // }
 
     /**
      * Spliterator.getComparator always throws IllegalStateException
      */
+    @Test
     public void testSpliterator_getComparator() {
         assertThrows(IllegalStateException.class,
                      () -> new LinkedBlockingDeque().spliterator().getComparator());
@@ -59,6 +73,7 @@ public class LinkedBlockingDeque8Test extends JSR166TestCase {
     /**
      * Spliterator characteristics are as advertised
      */
+    @Test
     public void testSpliterator_characteristics() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         Spliterator s = q.spliterator();
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDequeTest.java b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDequeTest.java
index c8cc4a19f95..a57b7e65bbc 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDequeTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingDequeTest.java
@@ -33,6 +33,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -48,39 +56,50 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingDeque;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedBlockingDequeTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Unbounded extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new LinkedBlockingDeque();
         }
     }
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Bounded extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new LinkedBlockingDeque(SIZE);
         }
     }
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return LinkedBlockingDeque.class; }
-            public Collection emptyCollection() { return new LinkedBlockingDeque(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(LinkedBlockingDequeTest.class,
-                            new Unbounded().testSuite(),
-                            new Bounded().testSuite(),
-                            CollectionTest.testSuite(new Implementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedBlockingDequeTest");
+    }
+
+    // Android-removed: No usage of suite().
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return LinkedBlockingDeque.class; }
+    //         public Collection emptyCollection() { return new LinkedBlockingDeque(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(LinkedBlockingDequeTest.class,
+    //                         new Unbounded().testSuite(),
+    //                         new Bounded().testSuite(),
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Returns a new deque of given size containing consecutive
@@ -103,6 +122,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         assertTrue(q.isEmpty());
@@ -117,6 +137,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -132,6 +153,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * offerFirst(null) throws NullPointerException
      */
+    @Test
     public void testOfferFirstNull() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         try {
@@ -143,6 +165,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * offerLast(null) throws NullPointerException
      */
+    @Test
     public void testOfferLastNull() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         try {
@@ -154,6 +177,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * OfferFirst succeeds
      */
+    @Test
     public void testOfferFirst() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         assertTrue(q.offerFirst(new Integer(0)));
@@ -163,6 +187,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * OfferLast succeeds
      */
+    @Test
     public void testOfferLast() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         assertTrue(q.offerLast(new Integer(0)));
@@ -172,6 +197,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * pollFirst succeeds unless empty
      */
+    @Test
     public void testPollFirst() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -183,6 +209,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * pollLast succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -194,6 +221,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peekFirst returns next element, or null if empty
      */
+    @Test
     public void testPeekFirst() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -208,6 +236,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -222,6 +251,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peekLast returns next element, or null if empty
      */
+    @Test
     public void testPeekLast() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -236,6 +266,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * getFirst() returns first element, or throws NSEE if empty
      */
+    @Test
     public void testFirstElement() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -252,6 +283,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * getLast() returns last element, or throws NSEE if empty
      */
+    @Test
     public void testLastElement() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -268,6 +300,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * removeFirst() removes first element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveFirst() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -283,6 +316,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * removeLast() removes last element, or throws NSEE if empty
      */
+    @Test
     public void testRemoveLast() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -298,6 +332,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -312,6 +347,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * removeFirstOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveFirstOccurrence() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -327,6 +363,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * removeLastOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveLastOccurrence() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -342,6 +379,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peekFirst returns element inserted with addFirst
      */
+    @Test
     public void testAddFirst() {
         LinkedBlockingDeque q = populatedDeque(3);
         q.pollLast();
@@ -352,6 +390,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peekLast returns element inserted with addLast
      */
+    @Test
     public void testAddLast() {
         LinkedBlockingDeque q = populatedDeque(3);
         q.pollLast();
@@ -363,6 +402,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * A new deque has the indicated capacity, or Integer.MAX_VALUE if
      * none given
      */
+    @Test
     public void testConstructor1() {
         assertEquals(SIZE, new LinkedBlockingDeque(SIZE).remainingCapacity());
         assertEquals(Integer.MAX_VALUE, new LinkedBlockingDeque().remainingCapacity());
@@ -371,6 +411,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Constructor throws IllegalArgumentException if capacity argument nonpositive
      */
+    @Test
     public void testConstructor2() {
         try {
             new LinkedBlockingDeque(0);
@@ -381,6 +422,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NullPointerException
      */
+    @Test
     public void testConstructor3() {
         try {
             new LinkedBlockingDeque(null);
@@ -391,6 +433,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NullPointerException
      */
+    @Test
     public void testConstructor4() {
         Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
         try {
@@ -403,6 +446,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * Initializing from Collection with some null elements throws
      * NullPointerException
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -417,6 +461,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -429,6 +474,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Deque transitions from empty to full when elements added
      */
+    @Test
     public void testEmptyFull() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         assertTrue(q.isEmpty());
@@ -444,6 +490,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * remainingCapacity decreases on add, increases on remove
      */
+    @Test
     public void testRemainingCapacity() {
         BlockingQueue q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -461,6 +508,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * push(null) throws NPE
      */
+    @Test
     public void testPushNull() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(1);
         try {
@@ -472,6 +520,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * push succeeds if not full; throws ISE if full
      */
+    @Test
     public void testPush() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -489,6 +538,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * peekFirst returns element inserted with push
      */
+    @Test
     public void testPushWithPeek() {
         LinkedBlockingDeque q = populatedDeque(3);
         q.pollLast();
@@ -499,6 +549,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * pop removes next element, or throws NSEE if empty
      */
+    @Test
     public void testPop() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -513,6 +564,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Offer succeeds if not full; fails if full
      */
+    @Test
     public void testOffer() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(1);
         assertTrue(q.offer(zero));
@@ -522,6 +574,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * add succeeds if not full; throws ISE if full
      */
+    @Test
     public void testAdd() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         for (int i = 0; i < SIZE; ++i)
@@ -536,6 +589,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         try {
@@ -548,6 +602,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -563,6 +618,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * addAll throws IllegalStateException if not enough room
      */
+    @Test
     public void testAddAll4() {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE - 1);
         Integer[] ints = new Integer[SIZE];
@@ -578,6 +634,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Deque contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -593,6 +650,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() throws InterruptedException {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -606,6 +664,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * put blocks interruptibly if full
      */
+    @Test
     public void testBlockingPut() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -642,6 +701,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * put blocks interruptibly waiting for take when full
      */
+    @Test
     public void testPutWithTake() throws InterruptedException {
         final int capacity = 2;
         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
@@ -676,6 +736,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed offer times out if full and elements not taken
      */
+    @Test
     public void testTimedOffer() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -702,6 +763,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * take retrieves elements in FIFO order
      */
+    @Test
     public void testTake() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -712,6 +774,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -745,6 +808,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -756,6 +820,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -767,6 +832,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -784,6 +850,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedDeque(SIZE);
         final CountDownLatch aboutToWait = new CountDownLatch(1);
@@ -812,6 +879,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putFirst(null) throws NPE
      */
+    @Test
     public void testPutFirstNull() throws InterruptedException {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         try {
@@ -823,6 +891,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * all elements successfully putFirst are contained
      */
+    @Test
     public void testPutFirst() throws InterruptedException {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -836,6 +905,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putFirst blocks interruptibly if full
      */
+    @Test
     public void testBlockingPutFirst() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -872,6 +942,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putFirst blocks interruptibly waiting for take when full
      */
+    @Test
     public void testPutFirstWithTake() throws InterruptedException {
         final int capacity = 2;
         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
@@ -906,6 +977,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed offerFirst times out if full and elements not taken
      */
+    @Test
     public void testTimedOfferFirst() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -932,6 +1004,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * take retrieves elements in FIFO order
      */
+    @Test
     public void testTakeFirst() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -942,6 +1015,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * takeFirst() blocks interruptibly when empty
      */
+    @Test
     public void testTakeFirstFromEmptyBlocksInterruptibly() {
         final BlockingDeque q = new LinkedBlockingDeque();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -965,6 +1039,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * takeFirst() throws InterruptedException immediately if interrupted
      * before waiting
      */
+    @Test
     public void testTakeFirstFromEmptyAfterInterrupt() {
         final BlockingDeque q = new LinkedBlockingDeque();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -983,6 +1058,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * takeLast() blocks interruptibly when empty
      */
+    @Test
     public void testTakeLastFromEmptyBlocksInterruptibly() {
         final BlockingDeque q = new LinkedBlockingDeque();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -1006,6 +1082,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * takeLast() throws InterruptedException immediately if interrupted
      * before waiting
      */
+    @Test
     public void testTakeLastFromEmptyAfterInterrupt() {
         final BlockingDeque q = new LinkedBlockingDeque();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -1024,6 +1101,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * takeFirst removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTakeFirst() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1057,6 +1135,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed pollFirst with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPollFirst0() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1068,6 +1147,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed pollFirst with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPollFirst() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1085,6 +1165,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * Interrupted timed pollFirst throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPollFirst() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1121,6 +1202,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * timed pollFirst before a delayed offerFirst fails; after offerFirst succeeds;
      * on interruption throws
      */
+    @Test
     public void testTimedPollFirstWithOfferFirst() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CheckedBarrier barrier = new CheckedBarrier(2);
@@ -1161,6 +1243,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putLast(null) throws NPE
      */
+    @Test
     public void testPutLastNull() throws InterruptedException {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         try {
@@ -1172,6 +1255,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * all elements successfully putLast are contained
      */
+    @Test
     public void testPutLast() throws InterruptedException {
         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1185,6 +1269,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putLast blocks interruptibly if full
      */
+    @Test
     public void testBlockingPutLast() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1221,6 +1306,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * putLast blocks interruptibly waiting for take when full
      */
+    @Test
     public void testPutLastWithTake() throws InterruptedException {
         final int capacity = 2;
         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
@@ -1255,6 +1341,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed offerLast times out if full and elements not taken
      */
+    @Test
     public void testTimedOfferLast() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1281,6 +1368,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * takeLast retrieves elements in FIFO order
      */
+    @Test
     public void testTakeLast() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1291,6 +1379,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * takeLast removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTakeLast() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1324,6 +1413,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed pollLast with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPollLast0() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1335,6 +1425,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed pollLast with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPollLast() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1352,6 +1443,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * Interrupted timed pollLast throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPollLast() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1391,6 +1483,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
      * timed poll before a delayed offerLast fails; after offerLast succeeds;
      * on interruption throws
      */
+    @Test
     public void testTimedPollWithOfferLast() throws InterruptedException {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CheckedBarrier barrier = new CheckedBarrier(2);
@@ -1435,6 +1528,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1450,6 +1544,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -1462,6 +1557,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         q.clear();
@@ -1478,6 +1574,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         LinkedBlockingDeque p = new LinkedBlockingDeque(SIZE);
@@ -1492,6 +1589,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         LinkedBlockingDeque p = populatedDeque(SIZE);
@@ -1511,6 +1609,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             LinkedBlockingDeque q = populatedDeque(SIZE);
@@ -1527,6 +1626,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * toArray contains all elements in FIFO order
      */
+    @Test
     public void testToArray() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         Object[] o = q.toArray();
@@ -1537,6 +1637,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() {
         LinkedBlockingDeque<Integer> q = populatedDeque(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -1549,6 +1650,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         try {
@@ -1560,6 +1662,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() throws InterruptedException {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         Iterator it = q.iterator();
@@ -1579,6 +1682,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         Deque c = new LinkedBlockingDeque();
         assertIteratorExhausted(c.iterator());
@@ -1588,6 +1692,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(3);
         q.add(two);
@@ -1607,6 +1712,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(3);
         q.add(one);
@@ -1623,6 +1729,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(3);
         q.add(one);
@@ -1638,6 +1745,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Descending iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         int i = 0;
@@ -1657,6 +1765,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * Descending iterator ordering is reverse FIFO
      */
+    @Test
     public void testDescendingIteratorOrdering() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque();
         for (int iters = 0; iters < 100; ++iters) {
@@ -1678,6 +1787,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * descendingIterator.remove removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque();
         for (int iters = 0; iters < 100; ++iters) {
@@ -1700,6 +1810,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         String s = q.toString();
@@ -1711,6 +1822,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * offer transfers elements across Executor tasks
      */
+    @Test
     public void testOfferInExecutor() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         q.add(one);
@@ -1737,6 +1849,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * timed poll retrieves elements across Executor threads
      */
+    @Test
     public void testPollInExecutor() {
         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -1761,6 +1874,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * A deserialized serialized deque has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedDeque(SIZE);
         Queue y = serialClone(x);
@@ -1779,6 +1893,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * drainTo(c) empties deque into another collection c
      */
+    @Test
     public void testDrainTo() {
         LinkedBlockingDeque q = populatedDeque(SIZE);
         ArrayList l = new ArrayList();
@@ -1803,6 +1918,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * drainTo empties full deque, unblocking a waiting put.
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final LinkedBlockingDeque q = populatedDeque(SIZE);
         Thread t = new Thread(new CheckedRunnable() {
@@ -1823,6 +1939,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         LinkedBlockingDeque q = new LinkedBlockingDeque();
         for (int i = 0; i < SIZE + 2; ++i) {
@@ -1842,6 +1959,7 @@ public class LinkedBlockingDequeTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Deque<?>[] qs = {
             new LinkedBlockingDeque<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueue8Test.java b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueue8Test.java
index 4a6e42ac72b..dbc2d97b8d1 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueue8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueue8Test.java
@@ -33,24 +33,38 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.Spliterator;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedBlockingQueue8Test extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        return newTestSuite(LinkedBlockingQueue8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedBlockingQueue8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(LinkedBlockingQueue8Test.class);
+    // }
 
     /**
      * Spliterator.getComparator always throws IllegalStateException
      */
+    @Test
     public void testSpliterator_getComparator() {
         assertThrows(IllegalStateException.class,
                      () -> new LinkedBlockingQueue().spliterator().getComparator());
@@ -59,6 +73,7 @@ public class LinkedBlockingQueue8Test extends JSR166TestCase {
     /**
      * Spliterator characteristics are as advertised
      */
+    @Test
     public void testSpliterator_characteristics() {
         LinkedBlockingQueue q = new LinkedBlockingQueue();
         Spliterator s = q.spliterator();
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueueTest.java
index 4580f860ef6..a8f0321965f 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedBlockingQueueTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -48,39 +56,50 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedBlockingQueueTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Unbounded extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new LinkedBlockingQueue();
         }
     }
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Bounded extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new LinkedBlockingQueue(SIZE);
         }
     }
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return LinkedBlockingQueue.class; }
-            public Collection emptyCollection() { return new LinkedBlockingQueue(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(LinkedBlockingQueueTest.class,
-                            new Unbounded().testSuite(),
-                            new Bounded().testSuite(),
-                            CollectionTest.testSuite(new Implementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedBlockingQueueTest");
+    }
+
+    // Android-removed: No usage of suite().
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return LinkedBlockingQueue.class; }
+    //         public Collection emptyCollection() { return new LinkedBlockingQueue(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(LinkedBlockingQueueTest.class,
+    //                         new Unbounded().testSuite(),
+    //                         new Bounded().testSuite(),
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Returns a new queue of given size containing consecutive
@@ -103,6 +122,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
      * A new queue has the indicated capacity, or Integer.MAX_VALUE if
      * none given
      */
+    @Test
     public void testConstructor1() {
         assertEquals(SIZE, new LinkedBlockingQueue(SIZE).remainingCapacity());
         assertEquals(Integer.MAX_VALUE, new LinkedBlockingQueue().remainingCapacity());
@@ -111,6 +131,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Constructor throws IllegalArgumentException if capacity argument nonpositive
      */
+    @Test
     public void testConstructor2() {
         try {
             new LinkedBlockingQueue(0);
@@ -121,6 +142,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NullPointerException
      */
+    @Test
     public void testConstructor3() {
         try {
             new LinkedBlockingQueue(null);
@@ -131,6 +153,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NullPointerException
      */
+    @Test
     public void testConstructor4() {
         Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
         try {
@@ -143,6 +166,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
      * Initializing from Collection with some null elements throws
      * NullPointerException
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -157,6 +181,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -169,6 +194,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue transitions from empty to full when elements added
      */
+    @Test
     public void testEmptyFull() {
         LinkedBlockingQueue q = new LinkedBlockingQueue(2);
         assertTrue(q.isEmpty());
@@ -184,6 +210,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * remainingCapacity decreases on add, increases on remove
      */
+    @Test
     public void testRemainingCapacity() {
         BlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -201,6 +228,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Offer succeeds if not full; fails if full
      */
+    @Test
     public void testOffer() {
         LinkedBlockingQueue q = new LinkedBlockingQueue(1);
         assertTrue(q.offer(zero));
@@ -210,6 +238,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * add succeeds if not full; throws IllegalStateException if full
      */
+    @Test
     public void testAdd() {
         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; ++i)
@@ -224,6 +253,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IllegalArgumentException
      */
+    @Test
     public void testAddAllSelf() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -236,6 +266,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -251,6 +282,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * addAll throws IllegalStateException if not enough room
      */
+    @Test
     public void testAddAll4() {
         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE - 1);
         Integer[] ints = new Integer[SIZE];
@@ -266,6 +298,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -281,6 +314,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() throws InterruptedException {
         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -294,6 +328,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly if full
      */
+    @Test
     public void testBlockingPut() throws InterruptedException {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -330,6 +365,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly waiting for take when full
      */
+    @Test
     public void testPutWithTake() throws InterruptedException {
         final int capacity = 2;
         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
@@ -364,6 +400,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * timed offer times out if full and elements not taken
      */
+    @Test
     public void testTimedOffer() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -390,6 +427,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * take retrieves elements in FIFO order
      */
+    @Test
     public void testTake() throws InterruptedException {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -400,6 +438,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final BlockingQueue q = populatedQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -433,6 +472,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -444,6 +484,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -455,6 +496,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         LinkedBlockingQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -472,6 +514,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedQueue(SIZE);
         final CountDownLatch aboutToWait = new CountDownLatch(1);
@@ -500,6 +543,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -514,6 +558,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -529,6 +574,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -543,6 +589,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * An add following remove(x) succeeds
      */
+    @Test
     public void testRemoveElementAndAdd() throws InterruptedException {
         LinkedBlockingQueue q = new LinkedBlockingQueue();
         assertTrue(q.add(new Integer(1)));
@@ -556,6 +603,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -568,6 +616,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         q.clear();
@@ -584,6 +633,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         LinkedBlockingQueue p = new LinkedBlockingQueue(SIZE);
@@ -598,6 +648,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         LinkedBlockingQueue p = populatedQueue(SIZE);
@@ -617,6 +668,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             LinkedBlockingQueue q = populatedQueue(SIZE);
@@ -633,6 +685,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray contains all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -643,6 +696,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() throws InterruptedException {
         LinkedBlockingQueue<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -655,6 +709,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -666,6 +721,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() throws InterruptedException {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -685,6 +741,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new LinkedBlockingQueue().iterator());
     }
@@ -692,6 +749,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
         q.add(two);
@@ -711,6 +769,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
         q.add(one);
@@ -727,6 +786,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
         q.add(one);
@@ -742,6 +802,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -753,6 +814,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * offer transfers elements across Executor tasks
      */
+    @Test
     public void testOfferInExecutor() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
         q.add(one);
@@ -779,6 +841,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll retrieves elements across Executor threads
      */
+    @Test
     public void testPollInExecutor() {
         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -803,6 +866,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
@@ -821,6 +885,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties queue into another collection c
      */
+    @Test
     public void testDrainTo() {
         LinkedBlockingQueue q = populatedQueue(SIZE);
         ArrayList l = new ArrayList();
@@ -845,6 +910,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo empties full queue, unblocking a waiting put.
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final LinkedBlockingQueue q = populatedQueue(SIZE);
         Thread t = new Thread(new CheckedRunnable() {
@@ -865,6 +931,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         LinkedBlockingQueue q = new LinkedBlockingQueue();
         for (int i = 0; i < SIZE + 2; ++i) {
@@ -884,6 +951,7 @@ public class LinkedBlockingQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?>[] qs = {
             new LinkedBlockingQueue<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedListTest.java b/ojluni/src/test/java/util/concurrent/tck/LinkedListTest.java
index 6c570cbf683..9d19d6a744d 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedListTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedListTest.java
@@ -34,38 +34,52 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.NoSuchElementException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedListTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return LinkedList.class; }
-            public Collection emptyCollection() { return new LinkedList(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return false; }
-            public boolean permitsNulls() { return true; }
-        }
-        class SubListImplementation extends Implementation {
-            public Collection emptyCollection() {
-                return new LinkedList().subList(0, 0);
-            }
-        }
-        return newTestSuite(
-                LinkedListTest.class,
-                CollectionTest.testSuite(new Implementation()),
-                CollectionTest.testSuite(new SubListImplementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedListTest");
+    }
+
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return LinkedList.class; }
+    //         public Collection emptyCollection() { return new LinkedList(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return false; }
+    //         public boolean permitsNulls() { return true; }
+    //     }
+    //     class SubListImplementation extends Implementation {
+    //         public Collection emptyCollection() {
+    //             return new LinkedList().subList(0, 0);
+    //         }
+    //     }
+    //     return newTestSuite(
+    //             LinkedListTest.class,
+    //             CollectionTest.testSuite(new Implementation()),
+    //             CollectionTest.testSuite(new SubListImplementation()));
+    // }
 
     /**
      * Returns a new queue of given size containing consecutive
@@ -86,6 +100,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * new queue is empty
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new LinkedList().size());
     }
@@ -93,6 +108,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new LinkedList((Collection)null);
@@ -103,6 +119,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -115,6 +132,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         LinkedList q = new LinkedList();
         assertTrue(q.isEmpty());
@@ -129,6 +147,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -144,6 +163,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * offer(null) succeeds
      */
+    @Test
     public void testOfferNull() {
         LinkedList q = new LinkedList();
         q.offer(null);
@@ -154,6 +174,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Offer succeeds
      */
+    @Test
     public void testOffer() {
         LinkedList q = new LinkedList();
         assertTrue(q.offer(new Integer(0)));
@@ -163,6 +184,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * add succeeds
      */
+    @Test
     public void testAdd() {
         LinkedList q = new LinkedList();
         for (int i = 0; i < SIZE; ++i) {
@@ -174,6 +196,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         LinkedList q = new LinkedList();
         try {
@@ -185,6 +208,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Queue contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -200,6 +224,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * addAll with too large an index throws IOOBE
      */
+    @Test
     public void testAddAll2_IndexOutOfBoundsException() {
         LinkedList l = new LinkedList();
         l.add(new Object());
@@ -214,6 +239,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * addAll with negative index throws IOOBE
      */
+    @Test
     public void testAddAll4_BadIndex() {
         LinkedList l = new LinkedList();
         l.add(new Object());
@@ -228,6 +254,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -239,6 +266,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -253,6 +281,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -268,6 +297,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -282,6 +312,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -303,6 +334,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -315,6 +347,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         LinkedList q = populatedQueue(SIZE);
         q.clear();
@@ -329,6 +362,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         LinkedList q = populatedQueue(SIZE);
         LinkedList p = new LinkedList();
@@ -343,6 +377,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         LinkedList q = populatedQueue(SIZE);
         LinkedList p = populatedQueue(SIZE);
@@ -362,6 +397,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             LinkedList q = populatedQueue(SIZE);
@@ -378,6 +414,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * toArray contains all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         LinkedList q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -388,6 +425,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() {
         LinkedList<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -400,6 +438,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * toArray(null) throws NullPointerException
      */
+    @Test
     public void testToArray_NullArg() {
         LinkedList l = new LinkedList();
         l.add(new Object());
@@ -412,6 +451,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         LinkedList l = new LinkedList();
         l.add(new Integer(5));
@@ -424,6 +464,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         LinkedList q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -437,6 +478,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new LinkedList().iterator());
     }
@@ -444,6 +486,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final LinkedList q = new LinkedList();
         q.add(new Integer(1));
@@ -460,6 +503,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final LinkedList q = new LinkedList();
         q.add(new Integer(1));
@@ -477,6 +521,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Descending iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         LinkedList q = populatedQueue(SIZE);
         int i = 0;
@@ -496,6 +541,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * Descending iterator ordering is reverse FIFO
      */
+    @Test
     public void testDescendingIteratorOrdering() {
         final LinkedList q = new LinkedList();
         q.add(new Integer(3));
@@ -512,6 +558,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * descendingIterator.remove removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final LinkedList q = new LinkedList();
         q.add(three);
@@ -529,6 +576,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         LinkedList q = populatedQueue(SIZE);
         String s = q.toString();
@@ -540,6 +588,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * peek returns element inserted with addFirst
      */
+    @Test
     public void testAddFirst() {
         LinkedList q = populatedQueue(3);
         q.addFirst(four);
@@ -549,6 +598,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * peekFirst returns element inserted with push
      */
+    @Test
     public void testPush() {
         LinkedList q = populatedQueue(3);
         q.push(four);
@@ -558,6 +608,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * pop removes next element, or throws NSEE if empty
      */
+    @Test
     public void testPop() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -572,6 +623,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * OfferFirst succeeds
      */
+    @Test
     public void testOfferFirst() {
         LinkedList q = new LinkedList();
         assertTrue(q.offerFirst(new Integer(0)));
@@ -581,6 +633,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * OfferLast succeeds
      */
+    @Test
     public void testOfferLast() {
         LinkedList q = new LinkedList();
         assertTrue(q.offerLast(new Integer(0)));
@@ -590,6 +643,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * pollLast succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -601,6 +655,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * peekFirst returns next element, or null if empty
      */
+    @Test
     public void testPeekFirst() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -615,6 +670,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * peekLast returns next element, or null if empty
      */
+    @Test
     public void testPeekLast() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -626,6 +682,7 @@ public class LinkedListTest extends JSR166TestCase {
         assertNull(q.peekLast());
     }
 
+    @Test
     public void testFirstElement() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -641,6 +698,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * getLast returns next element, or throws NSEE if empty
      */
+    @Test
     public void testLastElement() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -657,6 +715,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * removeFirstOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveFirstOccurrence() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -672,6 +731,7 @@ public class LinkedListTest extends JSR166TestCase {
     /**
      * removeLastOccurrence(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveLastOccurrence() {
         LinkedList q = populatedQueue(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
diff --git a/ojluni/src/test/java/util/concurrent/tck/LinkedTransferQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/LinkedTransferQueueTest.java
index ee53cf937d5..03ecceb17d2 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LinkedTransferQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LinkedTransferQueueTest.java
@@ -34,6 +34,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -49,37 +57,46 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedTransferQueue;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 @SuppressWarnings({"unchecked", "rawtypes"})
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LinkedTransferQueueTest extends JSR166TestCase {
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Generic extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new LinkedTransferQueue();
         }
     }
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LinkedTransferQueueTest");
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return LinkedTransferQueue.class; }
-            public Collection emptyCollection() { return new LinkedTransferQueue(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(LinkedTransferQueueTest.class,
-                            new Generic().testSuite(),
-                            CollectionTest.testSuite(new Implementation()));
-    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return LinkedTransferQueue.class; }
+    //         public Collection emptyCollection() { return new LinkedTransferQueue(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(LinkedTransferQueueTest.class,
+    //                         new Generic().testSuite(),
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /**
      * Constructor builds new queue with size being zero and empty
      * being true
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new LinkedTransferQueue().size());
         assertTrue(new LinkedTransferQueue().isEmpty());
@@ -89,6 +106,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * Initializing constructor with null collection throws
      * NullPointerException
      */
+    @Test
     public void testConstructor2() {
         try {
             new LinkedTransferQueue(null);
@@ -100,6 +118,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * Initializing from Collection of null elements throws
      * NullPointerException
      */
+    @Test
     public void testConstructor3() {
         Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
         try {
@@ -112,6 +131,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * Initializing constructor with a collection containing some null elements
      * throws NullPointerException
      */
+    @Test
     public void testConstructor4() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -126,6 +146,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of the collection it is initialized by
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i) {
@@ -150,6 +171,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * remainingCapacity() always returns Integer.MAX_VALUE
      */
+    @Test
     public void testRemainingCapacity() {
         BlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -167,6 +189,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IllegalArgumentException
      */
+    @Test
     public void testAddAllSelf() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         try {
@@ -179,6 +202,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws
      * NullPointerException after possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         LinkedTransferQueue q = new LinkedTransferQueue();
         Integer[] ints = new Integer[SIZE];
@@ -193,6 +217,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements, in traversal order, of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -210,6 +235,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() {
         LinkedTransferQueue<Integer> q = new LinkedTransferQueue<>();
         for (int i = 0; i < SIZE; ++i) {
@@ -222,6 +248,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * take retrieves elements in FIFO order
      */
+    @Test
     public void testTake() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -232,6 +259,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final BlockingQueue q = populatedQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -265,6 +293,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -277,6 +306,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -289,6 +319,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         long startTime = System.nanoTime();
@@ -306,6 +337,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedQueue(SIZE);
         final CountDownLatch aboutToWait = new CountDownLatch(1);
@@ -333,6 +365,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * timed poll after thread interrupted throws InterruptedException
      * instead of returning timeout status
      */
+    @Test
     public void testTimedPollAfterInterrupt() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedQueue(SIZE);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -355,6 +388,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -370,6 +404,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NoSuchElementException if empty
      */
+    @Test
     public void testElement() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -386,6 +421,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NoSuchElementException if empty
      */
+    @Test
     public void testRemove() throws InterruptedException {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -401,6 +437,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * An add following remove(x) succeeds
      */
+    @Test
     public void testRemoveElementAndAdd() throws InterruptedException {
         LinkedTransferQueue q = new LinkedTransferQueue();
         assertTrue(q.add(one));
@@ -414,6 +451,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -426,6 +464,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() throws InterruptedException {
         LinkedTransferQueue q = populatedQueue(SIZE);
         q.clear();
@@ -442,6 +481,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         LinkedTransferQueue<Integer> p = new LinkedTransferQueue<>();
@@ -457,6 +497,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * retainAll(c) retains only those elements of c and reports true
      * if changed
      */
+    @Test
     public void testRetainAll() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         LinkedTransferQueue p = populatedQueue(SIZE);
@@ -477,6 +518,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * removeAll(c) removes only those elements of c and reports true
      * if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             LinkedTransferQueue q = populatedQueue(SIZE);
@@ -492,6 +534,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * toArray() contains all elements in FIFO order
      */
+    @Test
     public void testToArray() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -503,6 +546,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in FIFO order
      */
+    @Test
     public void testToArray2() {
         LinkedTransferQueue<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -516,6 +560,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         try {
@@ -527,6 +572,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() throws InterruptedException {
         LinkedTransferQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -546,6 +592,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new LinkedTransferQueue().iterator());
     }
@@ -553,6 +600,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * iterator.remove() removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         q.add(two);
@@ -572,6 +620,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * iterator ordering is FIFO
      */
+    @Test
     public void testIteratorOrdering() {
         final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<>();
         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
@@ -589,6 +638,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * Modifications do not cause iterators to fail
      */
+    @Test
     public void testWeaklyConsistentIteration() {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         q.add(one);
@@ -604,6 +654,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -615,6 +666,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * offer transfers elements across Executor tasks
      */
+    @Test
     public void testOfferInExecutor() {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -641,6 +693,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * timed poll retrieves elements across Executor threads
      */
+    @Test
     public void testPollInExecutor() {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -668,6 +721,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements in same order
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
@@ -686,6 +740,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties queue into another collection c
      */
+    @Test
     public void testDrainTo() {
         LinkedTransferQueue q = populatedQueue(SIZE);
         ArrayList l = new ArrayList();
@@ -712,6 +767,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties full queue, unblocking a waiting put.
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final LinkedTransferQueue q = populatedQueue(SIZE);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -730,6 +786,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         LinkedTransferQueue q = new LinkedTransferQueue();
         for (int i = 0; i < SIZE + 2; ++i) {
@@ -751,6 +808,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * timed poll() or take() increments the waiting consumer count;
      * offer(e) decrements the waiting consumer count
      */
+    @Test
     public void testWaitingConsumer() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         assertEquals(0, q.getWaitingConsumerCount());
@@ -784,6 +842,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * transfer(null) throws NullPointerException
      */
+    @Test
     public void testTransfer1() throws InterruptedException {
         try {
             LinkedTransferQueue q = new LinkedTransferQueue();
@@ -796,6 +855,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * transfer waits until a poll occurs. The transfered element
      * is returned by the associated poll.
      */
+    @Test
     public void testTransfer2() throws InterruptedException {
         final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<>();
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -821,6 +881,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * transfer waits until a poll occurs, and then transfers in fifo order
      */
+    @Test
     public void testTransfer3() throws InterruptedException {
         final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<>();
 
@@ -854,6 +915,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * transfer waits until a poll occurs, at which point the polling
      * thread returns the element
      */
+    @Test
     public void testTransfer4() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
 
@@ -877,6 +939,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * transfer waits until a take occurs. The transfered element
      * is returned by the associated take.
      */
+    @Test
     public void testTransfer5() throws InterruptedException {
         final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<>();
 
@@ -898,6 +961,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * tryTransfer(null) throws NullPointerException
      */
+    @Test
     public void testTryTransfer1() {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         try {
@@ -910,6 +974,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * tryTransfer returns false and does not enqueue if there are no
      * consumers waiting to poll or take.
      */
+    @Test
     public void testTryTransfer2() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         assertFalse(q.tryTransfer(new Object()));
@@ -921,6 +986,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * If there is a consumer waiting in timed poll, tryTransfer
      * returns true while successfully transfering object.
      */
+    @Test
     public void testTryTransfer3() throws InterruptedException {
         final Object hotPotato = new Object();
         final LinkedTransferQueue q = new LinkedTransferQueue();
@@ -945,6 +1011,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * If there is a consumer waiting in take, tryTransfer returns
      * true while successfully transfering object.
      */
+    @Test
     public void testTryTransfer4() throws InterruptedException {
         final Object hotPotato = new Object();
         final LinkedTransferQueue q = new LinkedTransferQueue();
@@ -966,6 +1033,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * tryTransfer blocks interruptibly if no takers
      */
+    @Test
     public void testTryTransfer5() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -1000,6 +1068,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * tryTransfer gives up after the timeout and returns false
      */
+    @Test
     public void testTryTransfer6() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
 
@@ -1020,6 +1089,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * tryTransfer waits for any elements previously in to be removed
      * before transfering to a poll or take
      */
+    @Test
     public void testTryTransfer7() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         assertTrue(q.offer(four));
@@ -1045,6 +1115,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
      * tryTransfer attempts to enqueue into the queue and fails
      * returning false not enqueueing and the successive poll is null
      */
+    @Test
     public void testTryTransfer8() throws InterruptedException {
         final LinkedTransferQueue q = new LinkedTransferQueue();
         assertTrue(q.offer(four));
@@ -1073,6 +1144,7 @@ public class LinkedTransferQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?>[] qs = {
             new LinkedTransferQueue<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/LockSupportTest.java b/ojluni/src/test/java/util/concurrent/tck/LockSupportTest.java
index 1a31cbdba31..cfe37ca8a55 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LockSupportTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LockSupportTest.java
@@ -36,22 +36,35 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.LockSupport;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LockSupportTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LockSupportTest");
     }
 
-    public static Test suite() {
-        return new TestSuite(LockSupportTest.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(LockSupportTest.class);
+    // }
 
     static {
         // Reduce the risk of rare disastrous classloading in first call to
@@ -119,25 +132,31 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * park is released by subsequent unpark
      */
+    @Test
     public void testParkBeforeUnpark_park() {
         testParkBeforeUnpark(ParkMethod.park);
     }
+    @Test
     public void testParkBeforeUnpark_parkNanos() {
         testParkBeforeUnpark(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkBeforeUnpark_parkUntil() {
         testParkBeforeUnpark(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkBeforeUnpark_parkBlocker() {
         testParkBeforeUnpark(ParkMethod.parkBlocker);
     }
+    @Test
     public void testParkBeforeUnpark_parkNanosBlocker() {
         testParkBeforeUnpark(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkBeforeUnpark_parkUntilBlocker() {
         testParkBeforeUnpark(ParkMethod.parkUntilBlocker);
     }
-    public void testParkBeforeUnpark(final ParkMethod parkMethod) {
+    private void testParkBeforeUnpark(final ParkMethod parkMethod) {
         final CountDownLatch pleaseUnpark = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
@@ -153,25 +172,31 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * park is released by preceding unpark
      */
+    @Test
     public void testParkAfterUnpark_park() {
         testParkAfterUnpark(ParkMethod.park);
     }
+    @Test
     public void testParkAfterUnpark_parkNanos() {
         testParkAfterUnpark(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkAfterUnpark_parkUntil() {
         testParkAfterUnpark(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkAfterUnpark_parkBlocker() {
         testParkAfterUnpark(ParkMethod.parkBlocker);
     }
+    @Test
     public void testParkAfterUnpark_parkNanosBlocker() {
         testParkAfterUnpark(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkAfterUnpark_parkUntilBlocker() {
         testParkAfterUnpark(ParkMethod.parkUntilBlocker);
     }
-    public void testParkAfterUnpark(final ParkMethod parkMethod) {
+    private void testParkAfterUnpark(final ParkMethod parkMethod) {
         final CountDownLatch pleaseUnpark = new CountDownLatch(1);
         final AtomicBoolean pleasePark = new AtomicBoolean(false);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -191,25 +216,31 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * park is released by subsequent interrupt
      */
+    @Test
     public void testParkBeforeInterrupt_park() {
         testParkBeforeInterrupt(ParkMethod.park);
     }
+    @Test
     public void testParkBeforeInterrupt_parkNanos() {
         testParkBeforeInterrupt(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkBeforeInterrupt_parkUntil() {
         testParkBeforeInterrupt(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkBeforeInterrupt_parkBlocker() {
         testParkBeforeInterrupt(ParkMethod.parkBlocker);
     }
+    @Test
     public void testParkBeforeInterrupt_parkNanosBlocker() {
         testParkBeforeInterrupt(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkBeforeInterrupt_parkUntilBlocker() {
         testParkBeforeInterrupt(ParkMethod.parkUntilBlocker);
     }
-    public void testParkBeforeInterrupt(final ParkMethod parkMethod) {
+    private void testParkBeforeInterrupt(final ParkMethod parkMethod) {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
@@ -229,25 +260,31 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * park is released by preceding interrupt
      */
+    @Test
     public void testParkAfterInterrupt_park() {
         testParkAfterInterrupt(ParkMethod.park);
     }
+    @Test
     public void testParkAfterInterrupt_parkNanos() {
         testParkAfterInterrupt(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkAfterInterrupt_parkUntil() {
         testParkAfterInterrupt(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkAfterInterrupt_parkBlocker() {
         testParkAfterInterrupt(ParkMethod.parkBlocker);
     }
+    @Test
     public void testParkAfterInterrupt_parkNanosBlocker() {
         testParkAfterInterrupt(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkAfterInterrupt_parkUntilBlocker() {
         testParkAfterInterrupt(ParkMethod.parkUntilBlocker);
     }
-    public void testParkAfterInterrupt(final ParkMethod parkMethod) {
+    private void testParkAfterInterrupt(final ParkMethod parkMethod) {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         final AtomicBoolean pleasePark = new AtomicBoolean(false);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -269,19 +306,23 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * timed park times out if not unparked
      */
+    @Test
     public void testParkTimesOut_parkNanos() {
         testParkTimesOut(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkTimesOut_parkUntil() {
         testParkTimesOut(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkTimesOut_parkNanosBlocker() {
         testParkTimesOut(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkTimesOut_parkUntilBlocker() {
         testParkTimesOut(ParkMethod.parkUntilBlocker);
     }
-    public void testParkTimesOut(final ParkMethod parkMethod) {
+    private void testParkTimesOut(final ParkMethod parkMethod) {
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
                 for (;;) {
@@ -299,6 +340,7 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * getBlocker(null) throws NullPointerException
      */
+    @Test
     public void testGetBlockerNull() {
         try {
             LockSupport.getBlocker(null);
@@ -309,16 +351,19 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * getBlocker returns the blocker object passed to park
      */
+    @Test
     public void testGetBlocker_parkBlocker() {
         testGetBlocker(ParkMethod.parkBlocker);
     }
+    @Test
     public void testGetBlocker_parkNanosBlocker() {
         testGetBlocker(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testGetBlocker_parkUntilBlocker() {
         testGetBlocker(ParkMethod.parkUntilBlocker);
     }
-    public void testGetBlocker(final ParkMethod parkMethod) {
+    private void testGetBlocker(final ParkMethod parkMethod) {
         final CountDownLatch started = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
@@ -357,19 +402,23 @@ public class LockSupportTest extends JSR166TestCase {
      * 6763959 java.util.concurrent.locks.LockSupport.parkUntil(0) blocks forever
      * which is in jdk7-b118 and 6u25.
      */
+    @Test
     public void testPark0_parkNanos() {
         testPark0(ParkMethod.parkNanos);
     }
+    @Test
     public void testPark0_parkUntil() {
         testPark0(ParkMethod.parkUntil);
     }
+    @Test
     public void testPark0_parkNanosBlocker() {
         testPark0(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testPark0_parkUntilBlocker() {
         testPark0(ParkMethod.parkUntilBlocker);
     }
-    public void testPark0(final ParkMethod parkMethod) {
+    private void testPark0(final ParkMethod parkMethod) {
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
                 parkMethod.park(0L);
@@ -381,19 +430,23 @@ public class LockSupportTest extends JSR166TestCase {
     /**
      * timed park(Long.MIN_VALUE) returns immediately.
      */
+    @Test
     public void testParkNeg_parkNanos() {
         testParkNeg(ParkMethod.parkNanos);
     }
+    @Test
     public void testParkNeg_parkUntil() {
         testParkNeg(ParkMethod.parkUntil);
     }
+    @Test
     public void testParkNeg_parkNanosBlocker() {
         testParkNeg(ParkMethod.parkNanosBlocker);
     }
+    @Test
     public void testParkNeg_parkUntilBlocker() {
         testParkNeg(ParkMethod.parkUntilBlocker);
     }
-    public void testParkNeg(final ParkMethod parkMethod) {
+    private void testParkNeg(final ParkMethod parkMethod) {
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() {
                 parkMethod.park(Long.MIN_VALUE);
diff --git a/ojluni/src/test/java/util/concurrent/tck/LongAccumulatorTest.java b/ojluni/src/test/java/util/concurrent/tck/LongAccumulatorTest.java
index 36386fc2a6e..ebcf7e999dc 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LongAccumulatorTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LongAccumulatorTest.java
@@ -32,25 +32,40 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Phaser;
 import java.util.concurrent.atomic.LongAccumulator;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LongAccumulatorTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(LongAccumulatorTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LongAccumulatorTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(LongAccumulatorTest.class);
+    // }
 
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         assertEquals(0, ai.get());
@@ -59,6 +74,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * accumulate accumulates given value to current, and get returns current value
      */
+    @Test
     public void testAccumulateAndGet() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         ai.accumulate(2);
@@ -72,6 +88,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * reset() causes subsequent get() to return zero
      */
+    @Test
     public void testReset() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         ai.accumulate(2);
@@ -83,6 +100,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * getThenReset() returns current value; subsequent get() returns zero
      */
+    @Test
     public void testGetThenReset() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         ai.accumulate(2);
@@ -94,6 +112,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         assertEquals("0", ai.toString());
@@ -104,6 +123,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         assertEquals(0, ai.intValue());
@@ -114,6 +134,7 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
         assertEquals(0, ai.longValue());
@@ -124,26 +145,29 @@ public class LongAccumulatorTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         ai.accumulate(1);
-        assertEquals(1.0f, ai.floatValue());
+        assertEquals(1.0f, ai.floatValue(), 0.0f);
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         LongAccumulator ai = new LongAccumulator(Long::max, 0L);
-        assertEquals(0.0, ai.doubleValue());
+        assertEquals(0.0, ai.doubleValue(), 0.0d);
         ai.accumulate(1);
-        assertEquals(1.0, ai.doubleValue());
+        assertEquals(1.0, ai.doubleValue(), 0.0d);
     }
 
     /**
      * accumulates by multiple threads produce correct result
      */
+    @Test
     public void testAccumulateAndGetMT() {
         final int incs = 1000000;
         final int nthreads = 4;
diff --git a/ojluni/src/test/java/util/concurrent/tck/LongAdderTest.java b/ojluni/src/test/java/util/concurrent/tck/LongAdderTest.java
index d980185a4b1..325381cb093 100644
--- a/ojluni/src/test/java/util/concurrent/tck/LongAdderTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/LongAdderTest.java
@@ -32,25 +32,40 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.LongAdder;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class LongAdderTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(LongAdderTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.LongAdderTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(LongAdderTest.class);
+    // }
 
     /**
      * default constructed initializes to zero
      */
+    @Test
     public void testConstructor() {
         LongAdder ai = new LongAdder();
         assertEquals(0, ai.sum());
@@ -59,6 +74,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * add adds given value to current, and sum returns current value
      */
+    @Test
     public void testAddAndSum() {
         LongAdder ai = new LongAdder();
         ai.add(2);
@@ -70,6 +86,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * decrement decrements and sum returns current value
      */
+    @Test
     public void testDecrementAndsum() {
         LongAdder ai = new LongAdder();
         ai.decrement();
@@ -81,6 +98,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * incrementAndGet increments and returns current value
      */
+    @Test
     public void testIncrementAndsum() {
         LongAdder ai = new LongAdder();
         ai.increment();
@@ -92,6 +110,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * reset() causes subsequent sum() to return zero
      */
+    @Test
     public void testReset() {
         LongAdder ai = new LongAdder();
         ai.add(2);
@@ -103,6 +122,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * sumThenReset() returns sum; subsequent sum() returns zero
      */
+    @Test
     public void testSumThenReset() {
         LongAdder ai = new LongAdder();
         ai.add(2);
@@ -114,6 +134,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * a deserialized serialized adder holds same value
      */
+    @Test
     public void testSerialization() throws Exception {
         LongAdder x = new LongAdder();
         LongAdder y = serialClone(x);
@@ -129,6 +150,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * toString returns current value.
      */
+    @Test
     public void testToString() {
         LongAdder ai = new LongAdder();
         assertEquals("0", ai.toString());
@@ -139,6 +161,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * intValue returns current value.
      */
+    @Test
     public void testIntValue() {
         LongAdder ai = new LongAdder();
         assertEquals(0, ai.intValue());
@@ -149,6 +172,7 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * longValue returns current value.
      */
+    @Test
     public void testLongValue() {
         LongAdder ai = new LongAdder();
         assertEquals(0, ai.longValue());
@@ -159,26 +183,29 @@ public class LongAdderTest extends JSR166TestCase {
     /**
      * floatValue returns current value.
      */
+    @Test
     public void testFloatValue() {
         LongAdder ai = new LongAdder();
-        assertEquals(0.0f, ai.floatValue());
+        assertEquals(0.0f, ai.floatValue(), 0.0f);
         ai.increment();
-        assertEquals(1.0f, ai.floatValue());
+        assertEquals(1.0f, ai.floatValue(), 0.0f);
     }
 
     /**
      * doubleValue returns current value.
      */
+    @Test
     public void testDoubleValue() {
         LongAdder ai = new LongAdder();
-        assertEquals(0.0, ai.doubleValue());
+        assertEquals(0.0, ai.doubleValue(), 0.0d);
         ai.increment();
-        assertEquals(1.0, ai.doubleValue());
+        assertEquals(1.0, ai.doubleValue(), 0.0d);
     }
 
     /**
      * adds by multiple threads produce correct sum
      */
+    @Test
     public void testAddAndSumMT() throws Throwable {
         final int incs = 1000000;
         final int nthreads = 4;
diff --git a/ojluni/src/test/java/util/concurrent/tck/PhaserTest.java b/ojluni/src/test/java/util/concurrent/tck/PhaserTest.java
index f6764c894be..cfcec86f8b8 100644
--- a/ojluni/src/test/java/util/concurrent/tck/PhaserTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/PhaserTest.java
@@ -34,6 +34,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -42,18 +50,23 @@ import java.util.concurrent.Phaser;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class PhaserTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.PhaserTest");
     }
 
-    public static Test suite() {
-        return new TestSuite(PhaserTest.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(PhaserTest.class);
+    // }
 
     private static final int maxParties = 65535;
 
@@ -86,6 +99,7 @@ public class PhaserTest extends JSR166TestCase {
      * Empty constructor builds a new Phaser with no parent, no registered
      * parties and initial phase number of 0
      */
+    @Test
     public void testConstructorDefaultValues() {
         Phaser phaser = new Phaser();
         assertNull(phaser.getParent());
@@ -99,6 +113,7 @@ public class PhaserTest extends JSR166TestCase {
      * Constructing with a negative number of parties throws
      * IllegalArgumentException
      */
+    @Test
     public void testConstructorNegativeParties() {
         try {
             new Phaser(-1);
@@ -110,6 +125,7 @@ public class PhaserTest extends JSR166TestCase {
      * Constructing with a negative number of parties throws
      * IllegalArgumentException
      */
+    @Test
     public void testConstructorNegativeParties2() {
         try {
             new Phaser(new Phaser(), -1);
@@ -121,6 +137,7 @@ public class PhaserTest extends JSR166TestCase {
      * Constructing with a number of parties > 65535 throws
      * IllegalArgumentException
      */
+    @Test
     public void testConstructorPartiesExceedsLimit() {
         new Phaser(maxParties);
         try {
@@ -139,6 +156,7 @@ public class PhaserTest extends JSR166TestCase {
      * The parent provided to the constructor should be returned from
      * a later call to getParent
      */
+    @Test
     public void testConstructor3() {
         Phaser parent = new Phaser();
         assertSame(parent, new Phaser(parent).getParent());
@@ -149,6 +167,7 @@ public class PhaserTest extends JSR166TestCase {
      * The parent being input into the parameter should equal the original
      * parent when being returned
      */
+    @Test
     public void testConstructor5() {
         Phaser parent = new Phaser();
         assertSame(parent, new Phaser(parent, 0).getParent());
@@ -159,6 +178,7 @@ public class PhaserTest extends JSR166TestCase {
      * register() will increment the number of unarrived parties by
      * one and not affect its arrived parties
      */
+    @Test
     public void testRegister1() {
         Phaser phaser = new Phaser();
         assertState(phaser, 0, 0, 0);
@@ -169,6 +189,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * Registering more than 65536 parties causes IllegalStateException
      */
+    @Test
     public void testRegister2() {
         Phaser phaser = new Phaser(0);
         assertState(phaser, 0, 0, 0);
@@ -197,6 +218,7 @@ public class PhaserTest extends JSR166TestCase {
      * register() correctly returns the current barrier phase number
      * when invoked
      */
+    @Test
     public void testRegister3() {
         Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -209,6 +231,7 @@ public class PhaserTest extends JSR166TestCase {
      * register causes the next arrive to not increment the phase
      * rather retain the phase number
      */
+    @Test
     public void testRegister4() {
         Phaser phaser = new Phaser(1);
         assertEquals(0, phaser.arrive());
@@ -221,6 +244,7 @@ public class PhaserTest extends JSR166TestCase {
      * register on a subphaser that is currently empty succeeds, even
      * in the presence of another non-empty subphaser
      */
+    @Test
     public void testRegisterEmptySubPhaser() {
         Phaser root = new Phaser();
         Phaser child1 = new Phaser(root, 1);
@@ -248,6 +272,7 @@ public class PhaserTest extends JSR166TestCase {
      * Invoking bulkRegister with a negative parameter throws an
      * IllegalArgumentException
      */
+    @Test
     public void testBulkRegister1() {
         try {
             new Phaser().bulkRegister(-1);
@@ -259,6 +284,7 @@ public class PhaserTest extends JSR166TestCase {
      * bulkRegister should correctly record the number of unarrived
      * parties with the number of parties being registered
      */
+    @Test
     public void testBulkRegister2() {
         Phaser phaser = new Phaser();
         assertEquals(0, phaser.bulkRegister(0));
@@ -271,6 +297,7 @@ public class PhaserTest extends JSR166TestCase {
      * Registering with a number of parties greater than or equal to 1<<16
      * throws IllegalStateException.
      */
+    @Test
     public void testBulkRegister3() {
         assertEquals(0, new Phaser().bulkRegister((1 << 16) - 1));
 
@@ -288,6 +315,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * the phase number increments correctly when tripping the barrier
      */
+    @Test
     public void testPhaseIncrement1() {
         for (int size = 1; size < nine; size++) {
             final Phaser phaser = new Phaser(size);
@@ -301,6 +329,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arrive() on a registered phaser increments phase.
      */
+    @Test
     public void testArrive1() {
         Phaser phaser = new Phaser(1);
         assertState(phaser, 0, 1, 1);
@@ -311,6 +340,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arriveAndDeregister does not wait for others to arrive at barrier
      */
+    @Test
     public void testArriveAndDeregister() {
         final Phaser phaser = new Phaser(1);
         for (int i = 0; i < 10; i++) {
@@ -327,6 +357,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arriveAndDeregister does not wait for others to arrive at barrier
      */
+    @Test
     public void testArrive2() {
         final Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -349,6 +380,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arrive() returns a negative number if the Phaser is terminated
      */
+    @Test
     public void testArrive3() {
         Phaser phaser = new Phaser(1);
         phaser.forceTermination();
@@ -365,6 +397,7 @@ public class PhaserTest extends JSR166TestCase {
      * arriveAndDeregister() throws IllegalStateException if number of
      * registered or unarrived parties would become negative
      */
+    @Test
     public void testArriveAndDeregister1() {
         Phaser phaser = new Phaser();
         try {
@@ -376,6 +409,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arriveAndDeregister reduces the number of arrived parties
      */
+    @Test
     public void testArriveAndDeregister2() {
         final Phaser phaser = new Phaser(1);
         assertEquals(0, phaser.register());
@@ -390,6 +424,7 @@ public class PhaserTest extends JSR166TestCase {
      * when a deregistration occurs and causes the phaser to have zero parties
      * its parent will be deregistered as well
      */
+    @Test
     public void testArriveAndDeregister3() {
         Phaser parent = new Phaser();
         Phaser child = new Phaser(parent);
@@ -407,6 +442,7 @@ public class PhaserTest extends JSR166TestCase {
      * arriveAndDeregister deregisters one party from its parent when
      * the number of parties of child is zero after deregistration
      */
+    @Test
     public void testArriveAndDeregister4() {
         Phaser parent = new Phaser();
         Phaser child = new Phaser(parent);
@@ -423,6 +459,7 @@ public class PhaserTest extends JSR166TestCase {
      * arriveAndDeregister deregisters one party from its parent when
      * the number of parties of root is nonzero after deregistration.
      */
+    @Test
     public void testArriveAndDeregister5() {
         Phaser root = new Phaser();
         Phaser parent = new Phaser(root);
@@ -444,6 +481,7 @@ public class PhaserTest extends JSR166TestCase {
      * arriveAndDeregister returns the phase in which it leaves the
      * phaser in after deregistration
      */
+    @Test
     public void testArriveAndDeregister6() {
         final Phaser phaser = new Phaser(2);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -462,6 +500,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvance succeeds upon advance
      */
+    @Test
     public void testAwaitAdvance1() {
         final Phaser phaser = new Phaser(1);
         assertEquals(0, phaser.arrive());
@@ -472,6 +511,7 @@ public class PhaserTest extends JSR166TestCase {
      * awaitAdvance with a negative parameter will return without affecting the
      * phaser
      */
+    @Test
     public void testAwaitAdvance2() {
         Phaser phaser = new Phaser();
         assertTrue(phaser.awaitAdvance(-1) < 0);
@@ -481,6 +521,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvanceInterruptibly blocks interruptibly
      */
+    @Test
     public void testAwaitAdvanceInterruptibly_interruptible() throws InterruptedException {
         final Phaser phaser = new Phaser(1);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
@@ -534,6 +575,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvance continues waiting if interrupted before waiting
      */
+    @Test
     public void testAwaitAdvanceAfterInterrupt() {
         final Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -563,6 +605,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      *  awaitAdvance continues waiting if interrupted while waiting
      */
+    @Test
     public void testAwaitAdvanceBeforeInterrupt() {
         final Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -592,6 +635,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arriveAndAwaitAdvance continues waiting if interrupted before waiting
      */
+    @Test
     public void testArriveAndAwaitAdvanceAfterInterrupt() {
         final Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -618,6 +662,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * arriveAndAwaitAdvance continues waiting if interrupted while waiting
      */
+    @Test
     public void testArriveAndAwaitAdvanceBeforeInterrupt() {
         final Phaser phaser = new Phaser();
         assertEquals(0, phaser.register());
@@ -645,6 +690,7 @@ public class PhaserTest extends JSR166TestCase {
      * awaitAdvance atomically waits for all parties within the same phase to
      * complete before continuing
      */
+    @Test
     public void testAwaitAdvance4() {
         final Phaser phaser = new Phaser(4);
         final AtomicInteger count = new AtomicInteger(0);
@@ -667,6 +713,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvance returns the current phase
      */
+    @Test
     public void testAwaitAdvance5() {
         final Phaser phaser = new Phaser(1);
         assertEquals(1, phaser.awaitAdvance(phaser.arrive()));
@@ -698,6 +745,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvance returns the current phase in child phasers
      */
+    @Test
     public void testAwaitAdvanceTieredPhaser() throws Exception {
         final Phaser parent = new Phaser();
         final List<Phaser> zeroPartyChildren = new ArrayList<>(3);
@@ -745,6 +793,7 @@ public class PhaserTest extends JSR166TestCase {
     /**
      * awaitAdvance returns when the phaser is externally terminated
      */
+    @Test
     public void testAwaitAdvance6() {
         final Phaser phaser = new Phaser(3);
         final CountDownLatch pleaseForceTermination = new CountDownLatch(2);
@@ -775,6 +824,7 @@ public class PhaserTest extends JSR166TestCase {
      * arriveAndAwaitAdvance throws IllegalStateException with no
      * unarrived parties
      */
+    @Test
     public void testArriveAndAwaitAdvance1() {
         Phaser phaser = new Phaser();
         try {
@@ -788,6 +838,7 @@ public class PhaserTest extends JSR166TestCase {
      * number of arrived parties is the same number that is accounted
      * for when the main thread awaitsAdvance
      */
+    @Test
     public void testArriveAndAwaitAdvance3() {
         final Phaser phaser = new Phaser(1);
         final int THREADS = 3;
diff --git a/ojluni/src/test/java/util/concurrent/tck/PriorityBlockingQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/PriorityBlockingQueueTest.java
index 9aacce31a25..ef5a130644a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/PriorityBlockingQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/PriorityBlockingQueueTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -49,39 +57,50 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.PriorityBlockingQueue;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class PriorityBlockingQueueTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Generic extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new PriorityBlockingQueue();
         }
     }
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class InitialCapacity extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new PriorityBlockingQueue(SIZE);
         }
     }
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return PriorityBlockingQueue.class; }
-            public Collection emptyCollection() { return new PriorityBlockingQueue(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return true; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(PriorityBlockingQueueTest.class,
-                            new Generic().testSuite(),
-                            new InitialCapacity().testSuite(),
-                            CollectionTest.testSuite(new Implementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.PriorityBlockingQueueTest");
+    }
+
+    // Android-removed: No usage of suite().
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return PriorityBlockingQueue.class; }
+    //         public Collection emptyCollection() { return new PriorityBlockingQueue(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return true; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(PriorityBlockingQueueTest.class,
+    //                         new Generic().testSuite(),
+    //                         new InitialCapacity().testSuite(),
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     /** Sample Comparator */
     static class MyReverseComparator implements Comparator {
@@ -112,6 +131,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * A new queue has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(Integer.MAX_VALUE,
                      new PriorityBlockingQueue(SIZE).remainingCapacity());
@@ -120,6 +140,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Constructor throws IAE if capacity argument nonpositive
      */
+    @Test
     public void testConstructor2() {
         try {
             new PriorityBlockingQueue(0);
@@ -130,6 +151,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new PriorityBlockingQueue(null);
@@ -140,6 +162,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);
         try {
@@ -151,6 +174,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -165,6 +189,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -177,6 +202,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * The comparator used in constructor is used
      */
+    @Test
     public void testConstructor7() {
         MyReverseComparator cmp = new MyReverseComparator();
         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE, cmp);
@@ -192,6 +218,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(2);
         assertTrue(q.isEmpty());
@@ -207,6 +234,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * remainingCapacity() always returns Integer.MAX_VALUE
      */
+    @Test
     public void testRemainingCapacity() {
         BlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -224,6 +252,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Offer of comparable element succeeds
      */
+    @Test
     public void testOffer() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
         assertTrue(q.offer(zero));
@@ -233,6 +262,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Offer of non-Comparable throws CCE
      */
+    @Test
     public void testOfferNonComparable() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(1);
         try {
@@ -248,6 +278,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * add of comparable succeeds
      */
+    @Test
     public void testAdd() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -259,6 +290,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IAE
      */
+    @Test
     public void testAddAllSelf() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -271,6 +303,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -285,6 +318,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -300,6 +334,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * all elements successfully put are contained
      */
+    @Test
     public void testPut() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -313,6 +348,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * put doesn't block waiting for take
      */
+    @Test
     public void testPutWithTake() throws InterruptedException {
         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
         final int size = 4;
@@ -330,6 +366,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * timed offer does not time out
      */
+    @Test
     public void testTimedOffer() throws InterruptedException {
         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -346,6 +383,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * take retrieves elements in priority order
      */
+    @Test
     public void testTake() throws InterruptedException {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -356,6 +394,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * Take removes existing elements until empty, then blocks interruptibly
      */
+    @Test
     public void testBlockingTake() throws InterruptedException {
         final PriorityBlockingQueue q = populatedQueue(SIZE);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -389,6 +428,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -400,6 +440,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll0() throws InterruptedException {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -411,6 +452,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout succeeds when non-empty, else times out
      */
+    @Test
     public void testTimedPoll() throws InterruptedException {
         PriorityBlockingQueue<Integer> q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -428,6 +470,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
      * Interrupted timed poll throws InterruptedException instead of
      * returning timeout status
      */
+    @Test
     public void testInterruptedTimedPoll() throws InterruptedException {
         final BlockingQueue<Integer> q = populatedQueue(SIZE);
         final CountDownLatch aboutToWait = new CountDownLatch(1);
@@ -455,6 +498,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -469,6 +513,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -484,6 +529,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -498,6 +544,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -510,6 +557,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         q.clear();
@@ -525,6 +573,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         PriorityBlockingQueue p = new PriorityBlockingQueue(SIZE);
@@ -539,6 +588,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         PriorityBlockingQueue p = populatedQueue(SIZE);
@@ -558,6 +608,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             PriorityBlockingQueue q = populatedQueue(SIZE);
@@ -574,6 +625,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray contains all elements
      */
+    @Test
     public void testToArray() throws InterruptedException {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -585,6 +637,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements
      */
+    @Test
     public void testToArray2() throws InterruptedException {
         PriorityBlockingQueue<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -598,6 +651,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * toArray(incompatible array type) throws ArrayStoreException
      */
+    @Test
     public void testToArray1_BadArg() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         try {
@@ -609,6 +663,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -622,6 +677,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new PriorityBlockingQueue().iterator());
     }
@@ -629,6 +685,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final PriorityBlockingQueue q = new PriorityBlockingQueue(3);
         q.add(new Integer(2));
@@ -648,6 +705,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -659,6 +717,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * timed poll transfers elements across Executor tasks
      */
+    @Test
     public void testPollInExecutor() {
         final PriorityBlockingQueue q = new PriorityBlockingQueue(2);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
@@ -683,6 +742,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
@@ -699,6 +759,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) empties queue into another collection c
      */
+    @Test
     public void testDrainTo() {
         PriorityBlockingQueue q = populatedQueue(SIZE);
         ArrayList l = new ArrayList();
@@ -723,6 +784,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo empties queue
      */
+    @Test
     public void testDrainToWithActivePut() throws InterruptedException {
         final PriorityBlockingQueue q = populatedQueue(SIZE);
         Thread t = new Thread(new CheckedRunnable() {
@@ -743,6 +805,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties first min(n, size) elements of queue into c
      */
+    @Test
     public void testDrainToN() {
         PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE * 2);
         for (int i = 0; i < SIZE + 2; ++i) {
@@ -762,6 +825,7 @@ public class PriorityBlockingQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?>[] qs = {
             new PriorityBlockingQueue<Object>(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/PriorityQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/PriorityQueueTest.java
index b7f2e9fc23c..5162852a1a1 100644
--- a/ojluni/src/test/java/util/concurrent/tck/PriorityQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/PriorityQueueTest.java
@@ -34,6 +34,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
@@ -42,29 +51,34 @@ import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import android.compat.Compatibility;
 
 import dalvik.annotation.compat.VersionCodes;
 import dalvik.system.VMRuntime;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class PriorityQueueTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return PriorityQueue.class; }
-            public Collection emptyCollection() { return new PriorityQueue(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return false; }
-            public boolean permitsNulls() { return false; }
-        }
-        return newTestSuite(PriorityQueueTest.class,
-                            CollectionTest.testSuite(new Implementation()));
-    }
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.PriorityQueueTest");
+    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return PriorityQueue.class; }
+    //         public Collection emptyCollection() { return new PriorityQueue(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return false; }
+    //         public boolean permitsNulls() { return false; }
+    //     }
+    //     return newTestSuite(PriorityQueueTest.class,
+    //                         CollectionTest.testSuite(new Implementation()));
+    // }
 
     static class MyReverseComparator implements Comparator {
         public int compare(Object x, Object y) {
@@ -92,6 +106,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * A new queue has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new PriorityQueue(SIZE).size());
     }
@@ -99,6 +114,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Constructor throws IAE if capacity argument nonpositive
      */
+    @Test
     public void testConstructor2() {
         try {
             new PriorityQueue(0);
@@ -109,6 +125,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new PriorityQueue((Collection)null);
@@ -119,6 +136,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new PriorityQueue(Arrays.asList(new Integer[SIZE]));
@@ -129,6 +147,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -142,6 +161,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -154,6 +174,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * The comparator used in constructor is used
      */
+    @Test
     public void testConstructor7() {
         MyReverseComparator cmp = new MyReverseComparator();
         PriorityQueue q = new PriorityQueue(SIZE, cmp);
@@ -169,6 +190,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         PriorityQueue q = new PriorityQueue(2);
         assertTrue(q.isEmpty());
@@ -183,6 +205,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -198,6 +221,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * offer(null) throws NPE
      */
+    @Test
     public void testOfferNull() {
         PriorityQueue q = new PriorityQueue(1);
         try {
@@ -209,6 +233,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         PriorityQueue q = new PriorityQueue(1);
         try {
@@ -220,6 +245,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Offer of comparable element succeeds
      */
+    @Test
     public void testOffer() {
         PriorityQueue q = new PriorityQueue(1);
         assertTrue(q.offer(zero));
@@ -229,6 +255,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Offer of non-Comparable throws CCE
      */
+    @Test
     public void testOfferNonComparable() {
         PriorityQueue q = new PriorityQueue(1);
         // Android-added: test old behavior in < U.
@@ -250,6 +277,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * add of comparable succeeds
      */
+    @Test
     public void testAdd() {
         PriorityQueue q = new PriorityQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -261,6 +289,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         PriorityQueue q = new PriorityQueue(1);
         try {
@@ -272,6 +301,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         PriorityQueue q = new PriorityQueue(SIZE);
         try {
@@ -284,6 +314,7 @@ public class PriorityQueueTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         PriorityQueue q = new PriorityQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -298,6 +329,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * Queue contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -313,6 +345,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -324,6 +357,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * peek returns next element, or null if empty
      */
+    @Test
     public void testPeek() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -338,6 +372,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * element returns next element, or throws NSEE if empty
      */
+    @Test
     public void testElement() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -353,6 +388,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * remove removes next element, or throws NSEE if empty
      */
+    @Test
     public void testRemove() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -367,6 +403,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -388,6 +425,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         PriorityQueue q = populatedQueue(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -400,6 +438,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         PriorityQueue q = populatedQueue(SIZE);
         q.clear();
@@ -414,6 +453,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         PriorityQueue q = populatedQueue(SIZE);
         PriorityQueue p = new PriorityQueue(SIZE);
@@ -428,6 +468,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         PriorityQueue q = populatedQueue(SIZE);
         PriorityQueue p = populatedQueue(SIZE);
@@ -447,6 +488,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             PriorityQueue q = populatedQueue(SIZE);
@@ -463,6 +505,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * toArray contains all elements
      */
+    @Test
     public void testToArray() {
         PriorityQueue q = populatedQueue(SIZE);
         Object[] o = q.toArray();
@@ -474,6 +517,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements
      */
+    @Test
     public void testToArray2() {
         PriorityQueue<Integer> q = populatedQueue(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -487,6 +531,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         PriorityQueue q = populatedQueue(SIZE);
         Iterator it = q.iterator();
@@ -500,6 +545,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * iterator of empty collection has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new PriorityQueue().iterator());
     }
@@ -507,6 +553,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final PriorityQueue q = new PriorityQueue(3);
         q.add(new Integer(2));
@@ -526,6 +573,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         PriorityQueue q = populatedQueue(SIZE);
         String s = q.toString();
@@ -537,6 +585,7 @@ public class PriorityQueueTest extends JSR166TestCase {
     /**
      * A deserialized serialized queue has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         Queue x = populatedQueue(SIZE);
         Queue y = serialClone(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/RecursiveActionTest.java b/ojluni/src/test/java/util/concurrent/tck/RecursiveActionTest.java
index 7ec6cc8d180..13221f71f4a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/RecursiveActionTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/RecursiveActionTest.java
@@ -33,6 +33,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.HashSet;
@@ -46,18 +54,23 @@ import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeoutException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class RecursiveActionTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.RecursiveActionTest");
     }
 
-    public static Test suite() {
-        return new TestSuite(RecursiveActionTest.class);
-    }
+    // public static Test suite() {
+    //     return new TestSuite(RecursiveActionTest.class);
+    // }
 
     private static ForkJoinPool mainPool() {
         return new ForkJoinPool();
@@ -237,6 +250,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks. getRawResult of a RecursiveAction returns null;
      */
+    @Test
     public void testInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -253,6 +267,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -267,6 +282,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -282,6 +298,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * join/quietlyJoin of a forked task succeeds in the presence of interrupts
      */
+    @Test
     public void testJoinIgnoresInterrupts() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -354,6 +371,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * join/quietlyJoin of a forked task when not in ForkJoinPool
      * succeeds in the presence of interrupts
      */
+    @Test
     public void testJoinIgnoresInterruptsOutsideForkJoinPool() {
         final SynchronousQueue<FibAction[]> sq =
             new SynchronousQueue<FibAction[]>();
@@ -450,6 +468,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -465,6 +484,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -480,6 +500,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * timed get with null time unit throws NPE
      */
+    @Test
     public void testForkTimedGetNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -496,6 +517,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -512,6 +534,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesce() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -530,6 +553,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -547,6 +571,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -561,6 +586,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -579,6 +605,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -599,6 +626,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -619,6 +647,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -634,6 +663,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvoke() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -652,6 +682,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -671,6 +702,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -690,6 +722,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGet() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() throws Exception {
@@ -709,6 +742,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoin() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -724,6 +758,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * getPool of executing task returns its pool
      */
+    @Test
     public void testGetPool() {
         final ForkJoinPool mainPool = mainPool();
         RecursiveAction a = new CheckedRecursiveAction() {
@@ -736,6 +771,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -747,6 +783,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * inForkJoinPool of executing task returns true
      */
+    @Test
     public void testInForkJoinPool() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -758,6 +795,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -769,6 +807,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * getPool of current thread in pool returns its pool
      */
+    @Test
     public void testWorkerGetPool() {
         final ForkJoinPool mainPool = mainPool();
         RecursiveAction a = new CheckedRecursiveAction() {
@@ -783,6 +822,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * getPoolIndex of current thread in pool returns 0 <= value < poolSize
      */
+    @Test
     public void testWorkerGetPoolIndex() {
         final ForkJoinPool mainPool = mainPool();
         RecursiveAction a = new CheckedRecursiveAction() {
@@ -799,6 +839,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * setRawResult(null) succeeds
      */
+    @Test
     public void testSetRawResult() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -811,6 +852,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * A reinitialized normally completed task may be re-invoked
      */
+    @Test
     public void testReinitialize() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -831,6 +873,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * A reinitialized abnormally completed task may be re-invoked
      */
+    @Test
     public void testReinitializeAbnormal() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -854,6 +897,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -872,6 +916,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invoke task suppresses execution invoking complete
      */
+    @Test
     public void testComplete() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -887,6 +932,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -904,6 +950,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -918,6 +965,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -941,6 +989,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -968,6 +1017,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPE() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -985,6 +1035,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1003,6 +1054,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1020,6 +1072,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1039,6 +1092,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1063,6 +1117,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * tryUnfork returns true for most recent unexecuted task,
      * and suppresses execution
      */
+    @Test
     public void testTryUnfork() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1082,6 +1137,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * getSurplusQueuedTaskCount returns > 0 when
      * there are more tasks than threads
      */
+    @Test
     public void testGetSurplusQueuedTaskCount() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1104,6 +1160,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns most recent unexecuted task.
      */
+    @Test
     public void testPeekNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1125,6 +1182,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * pollNextLocalTask returns most recent unexecuted task
      * without executing it
      */
+    @Test
     public void testPollNextLocalTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1143,6 +1201,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * pollTask returns an unexecuted task without executing it
      */
+    @Test
     public void testPollTask() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1161,6 +1220,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns least recent unexecuted task in async mode
      */
+    @Test
     public void testPeekNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1181,6 +1241,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * pollNextLocalTask returns least recent unexecuted task without
      * executing it, in async mode
      */
+    @Test
     public void testPollNextLocalTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1200,6 +1261,7 @@ public class RecursiveActionTest extends JSR166TestCase {
      * pollTask returns an unexecuted task without executing it, in
      * async mode
      */
+    @Test
     public void testPollTaskAsync() {
         RecursiveAction a = new CheckedRecursiveAction() {
             protected void realCompute() {
@@ -1248,6 +1310,7 @@ public class RecursiveActionTest extends JSR166TestCase {
     /**
      * SortTask demo works as advertised
      */
+    @Test
     public void testSortTaskDemo() {
         ThreadLocalRandom rnd = ThreadLocalRandom.current();
         long[] array = new long[1007];
diff --git a/ojluni/src/test/java/util/concurrent/tck/RecursiveTaskTest.java b/ojluni/src/test/java/util/concurrent/tck/RecursiveTaskTest.java
index 39b3010e649..d88aaccfa91 100644
--- a/ojluni/src/test/java/util/concurrent/tck/RecursiveTaskTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/RecursiveTaskTest.java
@@ -33,6 +33,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.HashSet;
 import java.util.concurrent.CancellationException;
@@ -42,17 +50,22 @@ import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeoutException;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class RecursiveTaskTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(RecursiveTaskTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.RecursiveTaskTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(RecursiveTaskTest.class);
+    // }
 
     private static ForkJoinPool mainPool() {
         return new ForkJoinPool();
@@ -253,6 +266,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * completed tasks. getRawResult of a completed non-null task
      * returns value;
      */
+    @Test
     public void testInvoke() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -270,6 +284,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * isCompletedAbnormally and isCancelled return false for normally
      * completed tasks
      */
+    @Test
     public void testQuietlyInvoke() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -284,6 +299,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * join of a forked task returns when task completes
      */
+    @Test
     public void testForkJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -300,6 +316,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * get of a forked task returns when task completes
      */
+    @Test
     public void testForkGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -316,6 +333,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task returns when task completes
      */
+    @Test
     public void testForkTimedGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -332,6 +350,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes
      */
+    @Test
     public void testForkQuietlyJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -350,6 +369,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * helpQuiesce returns when tasks are complete.
      * getQueuedTaskCount returns 0 when quiescent
      */
+    @Test
     public void testForkHelpQuiesce() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -368,6 +388,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalInvoke() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -386,6 +407,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * quietlyInvoke task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalQuietlyInvoke() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -401,6 +423,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -420,6 +443,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -441,6 +465,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task completes abnormally
      */
+    @Test
     public void testAbnormalForkTimedGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -462,6 +487,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task completes abnormally
      */
+    @Test
     public void testAbnormalForkQuietlyJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -478,6 +504,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception when task cancelled
      */
+    @Test
     public void testCancelledInvoke() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -497,6 +524,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * join of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -517,6 +545,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -537,6 +566,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * timed get of a forked task throws exception when task cancelled
      */
+    @Test
     public void testCancelledForkTimedGet() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() throws Exception {
@@ -557,6 +587,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * quietlyJoin of a forked task returns when task cancelled
      */
+    @Test
     public void testCancelledForkQuietlyJoin() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -573,6 +604,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * getPool of executing task returns its pool
      */
+    @Test
     public void testGetPool() {
         final ForkJoinPool mainPool = mainPool();
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
@@ -586,6 +618,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * getPool of non-FJ task returns null
      */
+    @Test
     public void testGetPool2() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -598,6 +631,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * inForkJoinPool of executing task returns true
      */
+    @Test
     public void testInForkJoinPool() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -610,6 +644,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * inForkJoinPool of non-FJ task returns false
      */
+    @Test
     public void testInForkJoinPool2() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -622,6 +657,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * The value set by setRawResult is returned by getRawResult
      */
+    @Test
     public void testSetRawResult() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -636,6 +672,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * A reinitialized normally completed task may be re-invoked
      */
+    @Test
     public void testReinitialize() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -658,6 +695,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * A reinitialized abnormally completed task may be re-invoked
      */
+    @Test
     public void testReinitializeAbnormal() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -682,6 +720,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invoke task throws exception after invoking completeExceptionally
      */
+    @Test
     public void testCompleteExceptionally() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -701,6 +740,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invoke task suppresses execution invoking complete
      */
+    @Test
     public void testComplete() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -717,6 +757,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) invokes all task arguments
      */
+    @Test
     public void testInvokeAll2() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -733,6 +774,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument invokes task
      */
+    @Test
     public void testInvokeAll1() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -747,6 +789,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument invokes tasks
      */
+    @Test
     public void testInvokeAll3() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -768,6 +811,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) invokes all tasks in the collection
      */
+    @Test
     public void testInvokeAllCollection() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -793,6 +837,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with any null task throws NPE
      */
+    @Test
     public void testInvokeAllNPE() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -811,6 +856,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(t1, t2) throw exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll2() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -830,6 +876,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with 1 argument throws exception if task does
      */
+    @Test
     public void testAbnormalInvokeAll1() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -848,6 +895,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(tasks) with > 2 argument throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAll3() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -868,6 +916,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * invokeAll(collection) throws exception if any task does
      */
+    @Test
     public void testAbnormalInvokeAllCollection() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -893,6 +942,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * tryUnfork returns true for most recent unexecuted task,
      * and suppresses execution
      */
+    @Test
     public void testTryUnfork() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -913,6 +963,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * getSurplusQueuedTaskCount returns > 0 when
      * there are more tasks than threads
      */
+    @Test
     public void testGetSurplusQueuedTaskCount() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -936,6 +987,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns most recent unexecuted task.
      */
+    @Test
     public void testPeekNextLocalTask() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -956,6 +1008,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * pollNextLocalTask returns most recent unexecuted task
      * without executing it
      */
+    @Test
     public void testPollNextLocalTask() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -975,6 +1028,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * pollTask returns an unexecuted task without executing it
      */
+    @Test
     public void testPollTask() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -994,6 +1048,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
     /**
      * peekNextLocalTask returns least recent unexecuted task in async mode
      */
+    @Test
     public void testPeekNextLocalTaskAsync() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -1015,6 +1070,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * pollNextLocalTask returns least recent unexecuted task without
      * executing it, in async mode
      */
+    @Test
     public void testPollNextLocalTaskAsync() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
@@ -1035,6 +1091,7 @@ public class RecursiveTaskTest extends JSR166TestCase {
      * pollTask returns an unexecuted task without executing it, in
      * async mode
      */
+    @Test
     public void testPollTaskAsync() {
         RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {
             public Integer realCompute() {
diff --git a/ojluni/src/test/java/util/concurrent/tck/ReentrantLockTest.java b/ojluni/src/test/java/util/concurrent/tck/ReentrantLockTest.java
index 2e518d37d70..533ed17200a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ReentrantLockTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ReentrantLockTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -44,17 +52,21 @@ import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ReentrantLockTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ReentrantLockTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ReentrantLockTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ReentrantLockTest.class);
+    // }
 
     /**
      * A checked runnable calling lockInterruptibly
@@ -113,7 +125,7 @@ public class ReentrantLockTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!lock.hasQueuedThread(t)) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
         assertTrue(t.isAlive());
@@ -203,6 +215,7 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * Constructor sets given fairness, and is in unlocked state
      */
+    @Test
     public void testConstructor() {
         PublicReentrantLock lock;
 
@@ -222,9 +235,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * locking an unlocked lock succeeds
      */
+    @Test
     public void testLock()      { testLock(false); }
+    @Test
     public void testLock_fair() { testLock(true); }
-    public void testLock(boolean fair) {
+    private void testLock(boolean fair) {
         PublicReentrantLock lock = new PublicReentrantLock(fair);
         lock.lock();
         assertLockedByMoi(lock);
@@ -234,9 +249,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * Unlocking an unlocked lock throws IllegalMonitorStateException
      */
+    @Test
     public void testUnlock_IMSE()      { testUnlock_IMSE(false); }
+    @Test
     public void testUnlock_IMSE_fair() { testUnlock_IMSE(true); }
-    public void testUnlock_IMSE(boolean fair) {
+    private void testUnlock_IMSE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         try {
             lock.unlock();
@@ -247,9 +264,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * tryLock on an unlocked lock succeeds
      */
+    @Test
     public void testTryLock()      { testTryLock(false); }
+    @Test
     public void testTryLock_fair() { testTryLock(true); }
-    public void testTryLock(boolean fair) {
+    private void testTryLock(boolean fair) {
         PublicReentrantLock lock = new PublicReentrantLock(fair);
         assertTrue(lock.tryLock());
         assertLockedByMoi(lock);
@@ -262,9 +281,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasQueuedThreads reports whether there are waiting threads
      */
+    @Test
     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
+    @Test
     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
-    public void testHasQueuedThreads(boolean fair) {
+    private void testHasQueuedThreads(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
@@ -288,9 +309,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getQueueLength reports number of waiting threads
      */
+    @Test
     public void testGetQueueLength()      { testGetQueueLength(false); }
+    @Test
     public void testGetQueueLength_fair() { testGetQueueLength(true); }
-    public void testGetQueueLength(boolean fair) {
+    private void testGetQueueLength(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
@@ -313,9 +336,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasQueuedThread(null) throws NPE
      */
+    @Test
     public void testHasQueuedThreadNPE()      { testHasQueuedThreadNPE(false); }
+    @Test
     public void testHasQueuedThreadNPE_fair() { testHasQueuedThreadNPE(true); }
-    public void testHasQueuedThreadNPE(boolean fair) {
+    private void testHasQueuedThreadNPE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         try {
             lock.hasQueuedThread(null);
@@ -326,9 +351,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasQueuedThread reports whether a thread is queued
      */
+    @Test
     public void testHasQueuedThread()      { testHasQueuedThread(false); }
+    @Test
     public void testHasQueuedThread_fair() { testHasQueuedThread(true); }
-    public void testHasQueuedThread(boolean fair) {
+    private void testHasQueuedThread(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
@@ -356,9 +383,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getQueuedThreads includes waiting threads
      */
+    @Test
     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
+    @Test
     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
-    public void testGetQueuedThreads(boolean fair) {
+    private void testGetQueuedThreads(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
@@ -387,9 +416,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * timed tryLock is interruptible
      */
+    @Test
     public void testTryLock_Interruptible()      { testTryLock_Interruptible(false); }
+    @Test
     public void testTryLock_Interruptible_fair() { testTryLock_Interruptible(true); }
-    public void testTryLock_Interruptible(boolean fair) {
+    private void testTryLock_Interruptible(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         lock.lock();
         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
@@ -406,9 +437,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * tryLock on a locked lock fails
      */
+    @Test
     public void testTryLockWhenLocked()      { testTryLockWhenLocked(false); }
+    @Test
     public void testTryLockWhenLocked_fair() { testTryLockWhenLocked(true); }
-    public void testTryLockWhenLocked(boolean fair) {
+    private void testTryLockWhenLocked(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         lock.lock();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -423,9 +456,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * Timed tryLock on a locked lock times out
      */
+    @Test
     public void testTryLock_Timeout()      { testTryLock_Timeout(false); }
+    @Test
     public void testTryLock_Timeout_fair() { testTryLock_Timeout(true); }
-    public void testTryLock_Timeout(boolean fair) {
+    private void testTryLock_Timeout(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final long timeoutMillis = timeoutMillis();
         lock.lock();
@@ -443,9 +478,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getHoldCount returns number of recursive holds
      */
+    @Test
     public void testGetHoldCount()      { testGetHoldCount(false); }
+    @Test
     public void testGetHoldCount_fair() { testGetHoldCount(true); }
-    public void testGetHoldCount(boolean fair) {
+    private void testGetHoldCount(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         for (int i = 1; i <= SIZE; i++) {
             lock.lock();
@@ -460,9 +497,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * isLocked is true when locked and false when not
      */
+    @Test
     public void testIsLocked()      { testIsLocked(false); }
+    @Test
     public void testIsLocked_fair() { testIsLocked(true); }
-    public void testIsLocked(boolean fair) {
+    private void testIsLocked(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         try {
             assertFalse(lock.isLocked());
@@ -495,9 +534,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * lockInterruptibly succeeds when unlocked, else is interruptible
      */
+    @Test
     public void testLockInterruptibly()      { testLockInterruptibly(false); }
+    @Test
     public void testLockInterruptibly_fair() { testLockInterruptibly(true); }
-    public void testLockInterruptibly(boolean fair) {
+    private void testLockInterruptibly(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         try {
             lock.lockInterruptibly();
@@ -515,9 +556,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * Calling await without holding lock throws IllegalMonitorStateException
      */
+    @Test
     public void testAwait_IMSE()      { testAwait_IMSE(false); }
+    @Test
     public void testAwait_IMSE_fair() { testAwait_IMSE(true); }
-    public void testAwait_IMSE(boolean fair) {
+    private void testAwait_IMSE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         for (AwaitMethod awaitMethod : AwaitMethod.values()) {
@@ -534,9 +577,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * Calling signal without holding lock throws IllegalMonitorStateException
      */
+    @Test
     public void testSignal_IMSE()      { testSignal_IMSE(false); }
+    @Test
     public void testSignal_IMSE_fair() { testSignal_IMSE(true); }
-    public void testSignal_IMSE(boolean fair) {
+    private void testSignal_IMSE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         try {
@@ -548,9 +593,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * awaitNanos without a signal times out
      */
+    @Test
     public void testAwaitNanos_Timeout()      { testAwaitNanos_Timeout(false); }
+    @Test
     public void testAwaitNanos_Timeout_fair() { testAwaitNanos_Timeout(true); }
-    public void testAwaitNanos_Timeout(boolean fair) {
+    private void testAwaitNanos_Timeout(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         final long timeoutMillis = timeoutMillis();
@@ -568,9 +615,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * timed await without a signal times out
      */
+    @Test
     public void testAwait_Timeout()      { testAwait_Timeout(false); }
+    @Test
     public void testAwait_Timeout_fair() { testAwait_Timeout(true); }
-    public void testAwait_Timeout(boolean fair) {
+    private void testAwait_Timeout(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         final long timeoutMillis = timeoutMillis();
@@ -586,9 +635,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * awaitUntil without a signal times out
      */
+    @Test
     public void testAwaitUntil_Timeout()      { testAwaitUntil_Timeout(false); }
+    @Test
     public void testAwaitUntil_Timeout_fair() { testAwaitUntil_Timeout(true); }
-    public void testAwaitUntil_Timeout(boolean fair) {
+    private void testAwaitUntil_Timeout(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         lock.lock();
@@ -605,9 +656,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * await returns when signalled
      */
+    @Test
     public void testAwait()      { testAwait(false); }
+    @Test
     public void testAwait_fair() { testAwait(true); }
-    public void testAwait(boolean fair) {
+    private void testAwait(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch locked = new CountDownLatch(1);
@@ -632,9 +685,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws NPE if null
      */
+    @Test
     public void testHasWaitersNPE()      { testHasWaitersNPE(false); }
+    @Test
     public void testHasWaitersNPE_fair() { testHasWaitersNPE(true); }
-    public void testHasWaitersNPE(boolean fair) {
+    private void testHasWaitersNPE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         try {
             lock.hasWaiters(null);
@@ -645,9 +700,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws NPE if null
      */
+    @Test
     public void testGetWaitQueueLengthNPE()      { testGetWaitQueueLengthNPE(false); }
+    @Test
     public void testGetWaitQueueLengthNPE_fair() { testGetWaitQueueLengthNPE(true); }
-    public void testGetWaitQueueLengthNPE(boolean fair) {
+    private void testGetWaitQueueLengthNPE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         try {
             lock.getWaitQueueLength(null);
@@ -658,9 +715,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws NPE if null
      */
+    @Test
     public void testGetWaitingThreadsNPE()      { testGetWaitingThreadsNPE(false); }
+    @Test
     public void testGetWaitingThreadsNPE_fair() { testGetWaitingThreadsNPE(true); }
-    public void testGetWaitingThreadsNPE(boolean fair) {
+    private void testGetWaitingThreadsNPE(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         try {
             lock.getWaitingThreads(null);
@@ -671,9 +730,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalArgumentException if not owned
      */
+    @Test
     public void testHasWaitersIAE()      { testHasWaitersIAE(false); }
+    @Test
     public void testHasWaitersIAE_fair() { testHasWaitersIAE(true); }
-    public void testHasWaitersIAE(boolean fair) {
+    private void testHasWaitersIAE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         final ReentrantLock lock2 = new ReentrantLock(fair);
@@ -686,9 +747,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testHasWaitersIMSE()      { testHasWaitersIMSE(false); }
+    @Test
     public void testHasWaitersIMSE_fair() { testHasWaitersIMSE(true); }
-    public void testHasWaitersIMSE(boolean fair) {
+    private void testHasWaitersIMSE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         try {
@@ -700,9 +763,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitQueueLengthIAE()      { testGetWaitQueueLengthIAE(false); }
+    @Test
     public void testGetWaitQueueLengthIAE_fair() { testGetWaitQueueLengthIAE(true); }
-    public void testGetWaitQueueLengthIAE(boolean fair) {
+    private void testGetWaitQueueLengthIAE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         final ReentrantLock lock2 = new ReentrantLock(fair);
@@ -715,9 +780,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testGetWaitQueueLengthIMSE()      { testGetWaitQueueLengthIMSE(false); }
+    @Test
     public void testGetWaitQueueLengthIMSE_fair() { testGetWaitQueueLengthIMSE(true); }
-    public void testGetWaitQueueLengthIMSE(boolean fair) {
+    private void testGetWaitQueueLengthIMSE(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         try {
@@ -729,9 +796,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitingThreadsIAE()      { testGetWaitingThreadsIAE(false); }
+    @Test
     public void testGetWaitingThreadsIAE_fair() { testGetWaitingThreadsIAE(true); }
-    public void testGetWaitingThreadsIAE(boolean fair) {
+    private void testGetWaitingThreadsIAE(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final PublicReentrantLock lock2 = new PublicReentrantLock(fair);
@@ -744,9 +813,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testGetWaitingThreadsIMSE()      { testGetWaitingThreadsIMSE(false); }
+    @Test
     public void testGetWaitingThreadsIMSE_fair() { testGetWaitingThreadsIMSE(true); }
-    public void testGetWaitingThreadsIMSE(boolean fair) {
+    private void testGetWaitingThreadsIMSE(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         try {
@@ -758,9 +829,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * hasWaiters returns true when a thread is waiting, else false
      */
+    @Test
     public void testHasWaiters()      { testHasWaiters(false); }
+    @Test
     public void testHasWaiters_fair() { testHasWaiters(true); }
-    public void testHasWaiters(boolean fair) {
+    private void testHasWaiters(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch pleaseSignal = new CountDownLatch(1);
@@ -791,9 +864,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength returns number of waiting threads
      */
+    @Test
     public void testGetWaitQueueLength()      { testGetWaitQueueLength(false); }
+    @Test
     public void testGetWaitQueueLength_fair() { testGetWaitQueueLength(true); }
-    public void testGetWaitQueueLength(boolean fair) {
+    private void testGetWaitQueueLength(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch locked1 = new CountDownLatch(1);
@@ -849,9 +924,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads returns only and all waiting threads
      */
+    @Test
     public void testGetWaitingThreads()      { testGetWaitingThreads(false); }
+    @Test
     public void testGetWaitingThreads_fair() { testGetWaitingThreads(true); }
-    public void testGetWaitingThreads(boolean fair) {
+    private void testGetWaitingThreads(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch locked1 = new CountDownLatch(1);
@@ -909,9 +986,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * awaitUninterruptibly is uninterruptible
      */
+    @Test
     public void testAwaitUninterruptibly()      { testAwaitUninterruptibly(false); }
+    @Test
     public void testAwaitUninterruptibly_fair() { testAwaitUninterruptibly(true); }
-    public void testAwaitUninterruptibly(boolean fair) {
+    private void testAwaitUninterruptibly(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
@@ -956,15 +1035,23 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil is interruptible
      */
+    @Test
     public void testInterruptible_await()           { testInterruptible(false, AwaitMethod.await); }
+    @Test
     public void testInterruptible_await_fair()      { testInterruptible(true,  AwaitMethod.await); }
+    @Test
     public void testInterruptible_awaitTimed()      { testInterruptible(false, AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitTimed_fair() { testInterruptible(true,  AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitNanos()      { testInterruptible(false, AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitNanos_fair() { testInterruptible(true,  AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitUntil()      { testInterruptible(false, AwaitMethod.awaitUntil); }
+    @Test
     public void testInterruptible_awaitUntil_fair() { testInterruptible(true,  AwaitMethod.awaitUntil); }
-    public void testInterruptible(boolean fair, final AwaitMethod awaitMethod) {
+    private void testInterruptible(boolean fair, final AwaitMethod awaitMethod) {
         final PublicReentrantLock lock =
             new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
@@ -995,15 +1082,23 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * signalAll wakes up all threads
      */
+    @Test
     public void testSignalAll_await()           { testSignalAll(false, AwaitMethod.await); }
+    @Test
     public void testSignalAll_await_fair()      { testSignalAll(true,  AwaitMethod.await); }
+    @Test
     public void testSignalAll_awaitTimed()      { testSignalAll(false, AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitTimed_fair() { testSignalAll(true,  AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitNanos()      { testSignalAll(false, AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitNanos_fair() { testSignalAll(true,  AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitUntil()      { testSignalAll(false, AwaitMethod.awaitUntil); }
+    @Test
     public void testSignalAll_awaitUntil_fair() { testSignalAll(true,  AwaitMethod.awaitUntil); }
-    public void testSignalAll(boolean fair, final AwaitMethod awaitMethod) {
+    private void testSignalAll(boolean fair, final AwaitMethod awaitMethod) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch pleaseSignal = new CountDownLatch(2);
@@ -1032,9 +1127,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * signal wakes up waiting threads in FIFO order
      */
+    @Test
     public void testSignalWakesFifo()      { testSignalWakesFifo(false); }
+    @Test
     public void testSignalWakesFifo_fair() { testSignalWakesFifo(true); }
-    public void testSignalWakesFifo(boolean fair) {
+    private void testSignalWakesFifo(boolean fair) {
         final PublicReentrantLock lock =
             new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
@@ -1079,9 +1176,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * await after multiple reentrant locking preserves lock count
      */
+    @Test
     public void testAwaitLockCount()      { testAwaitLockCount(false); }
+    @Test
     public void testAwaitLockCount_fair() { testAwaitLockCount(true); }
-    public void testAwaitLockCount(boolean fair) {
+    private void testAwaitLockCount(boolean fair) {
         final PublicReentrantLock lock = new PublicReentrantLock(fair);
         final Condition c = lock.newCondition();
         final CountDownLatch pleaseSignal = new CountDownLatch(2);
@@ -1125,9 +1224,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * A serialized lock deserializes as unlocked
      */
+    @Test
     public void testSerialization()      { testSerialization(false); }
+    @Test
     public void testSerialization_fair() { testSerialization(true); }
-    public void testSerialization(boolean fair) {
+    private void testSerialization(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         lock.lock();
 
@@ -1151,9 +1252,11 @@ public class ReentrantLockTest extends JSR166TestCase {
     /**
      * toString indicates current lock state
      */
+    @Test
     public void testToString()      { testToString(false); }
+    @Test
     public void testToString_fair() { testToString(true); }
-    public void testToString(boolean fair) {
+    private void testToString(boolean fair) {
         final ReentrantLock lock = new ReentrantLock(fair);
         assertTrue(lock.toString().contains("Unlocked"));
         lock.lock();
diff --git a/ojluni/src/test/java/util/concurrent/tck/ReentrantReadWriteLockTest.java b/ojluni/src/test/java/util/concurrent/tck/ReentrantReadWriteLockTest.java
index dd2f4f3882d..773d68b1ab9 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ReentrantReadWriteLockTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ReentrantReadWriteLockTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -45,17 +53,21 @@ import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ReentrantReadWriteLockTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ReentrantReadWriteLockTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ReentrantReadWriteLockTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ReentrantReadWriteLockTest.class);
+    // }
 
     /**
      * A runnable calling lockInterruptibly
@@ -115,7 +127,7 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!lock.hasQueuedThread(t)) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
         assertTrue(t.isAlive());
@@ -212,6 +224,7 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Constructor sets given fairness, and is in unlocked state
      */
+    @Test
     public void testConstructor() {
         PublicReentrantReadWriteLock lock;
 
@@ -234,9 +247,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write-locking and read-locking an unlocked lock succeed
      */
+    @Test
     public void testLock()      { testLock(false); }
+    @Test
     public void testLock_fair() { testLock(true); }
-    public void testLock(boolean fair) {
+    private void testLock(boolean fair) {
         PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         assertNotWriteLocked(lock);
@@ -256,9 +271,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWriteHoldCount returns number of recursive holds
      */
+    @Test
     public void testGetWriteHoldCount()      { testGetWriteHoldCount(false); }
+    @Test
     public void testGetWriteHoldCount_fair() { testGetWriteHoldCount(true); }
-    public void testGetWriteHoldCount(boolean fair) {
+    private void testGetWriteHoldCount(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         for (int i = 1; i <= SIZE; i++) {
             lock.writeLock().lock();
@@ -273,9 +290,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * writelock.getHoldCount returns number of recursive holds
      */
+    @Test
     public void testGetHoldCount()      { testGetHoldCount(false); }
+    @Test
     public void testGetHoldCount_fair() { testGetHoldCount(true); }
-    public void testGetHoldCount(boolean fair) {
+    private void testGetHoldCount(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         for (int i = 1; i <= SIZE; i++) {
             lock.writeLock().lock();
@@ -290,9 +309,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getReadHoldCount returns number of recursive holds
      */
+    @Test
     public void testGetReadHoldCount()      { testGetReadHoldCount(false); }
+    @Test
     public void testGetReadHoldCount_fair() { testGetReadHoldCount(true); }
-    public void testGetReadHoldCount(boolean fair) {
+    private void testGetReadHoldCount(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         for (int i = 1; i <= SIZE; i++) {
             lock.readLock().lock();
@@ -307,9 +328,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write-unlocking an unlocked lock throws IllegalMonitorStateException
      */
+    @Test
     public void testWriteUnlock_IMSE()      { testWriteUnlock_IMSE(false); }
+    @Test
     public void testWriteUnlock_IMSE_fair() { testWriteUnlock_IMSE(true); }
-    public void testWriteUnlock_IMSE(boolean fair) {
+    private void testWriteUnlock_IMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         try {
             lock.writeLock().unlock();
@@ -320,9 +343,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * read-unlocking an unlocked lock throws IllegalMonitorStateException
      */
+    @Test
     public void testReadUnlock_IMSE()      { testReadUnlock_IMSE(false); }
+    @Test
     public void testReadUnlock_IMSE_fair() { testReadUnlock_IMSE(true); }
-    public void testReadUnlock_IMSE(boolean fair) {
+    private void testReadUnlock_IMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         try {
             lock.readLock().unlock();
@@ -333,9 +358,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write-lockInterruptibly is interruptible
      */
+    @Test
     public void testWriteLockInterruptibly_Interruptible()      { testWriteLockInterruptibly_Interruptible(false); }
+    @Test
     public void testWriteLockInterruptibly_Interruptible_fair() { testWriteLockInterruptibly_Interruptible(true); }
-    public void testWriteLockInterruptibly_Interruptible(boolean fair) {
+    private void testWriteLockInterruptibly_Interruptible(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -353,9 +380,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * timed write-tryLock is interruptible
      */
+    @Test
     public void testWriteTryLock_Interruptible()      { testWriteTryLock_Interruptible(false); }
+    @Test
     public void testWriteTryLock_Interruptible_fair() { testWriteTryLock_Interruptible(true); }
-    public void testWriteTryLock_Interruptible(boolean fair) {
+    private void testWriteTryLock_Interruptible(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -373,9 +402,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * read-lockInterruptibly is interruptible
      */
+    @Test
     public void testReadLockInterruptibly_Interruptible()      { testReadLockInterruptibly_Interruptible(false); }
+    @Test
     public void testReadLockInterruptibly_Interruptible_fair() { testReadLockInterruptibly_Interruptible(true); }
-    public void testReadLockInterruptibly_Interruptible(boolean fair) {
+    private void testReadLockInterruptibly_Interruptible(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -393,9 +424,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * timed read-tryLock is interruptible
      */
+    @Test
     public void testReadTryLock_Interruptible()      { testReadTryLock_Interruptible(false); }
+    @Test
     public void testReadTryLock_Interruptible_fair() { testReadTryLock_Interruptible(true); }
-    public void testReadTryLock_Interruptible(boolean fair) {
+    private void testReadTryLock_Interruptible(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -413,9 +446,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write-tryLock on an unlocked lock succeeds
      */
+    @Test
     public void testWriteTryLock()      { testWriteTryLock(false); }
+    @Test
     public void testWriteTryLock_fair() { testWriteTryLock(true); }
-    public void testWriteTryLock(boolean fair) {
+    private void testWriteTryLock(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         assertTrue(lock.writeLock().tryLock());
@@ -429,9 +464,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write-tryLock fails if locked
      */
+    @Test
     public void testWriteTryLockWhenLocked()      { testWriteTryLockWhenLocked(false); }
+    @Test
     public void testWriteTryLockWhenLocked_fair() { testWriteTryLockWhenLocked(true); }
-    public void testWriteTryLockWhenLocked(boolean fair) {
+    private void testWriteTryLockWhenLocked(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -447,9 +484,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * read-tryLock fails if locked
      */
+    @Test
     public void testReadTryLockWhenLocked()      { testReadTryLockWhenLocked(false); }
+    @Test
     public void testReadTryLockWhenLocked_fair() { testReadTryLockWhenLocked(true); }
-    public void testReadTryLockWhenLocked(boolean fair) {
+    private void testReadTryLockWhenLocked(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -465,9 +504,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Multiple threads can hold a read lock when not write-locked
      */
+    @Test
     public void testMultipleReadLocks()      { testMultipleReadLocks(false); }
+    @Test
     public void testMultipleReadLocks_fair() { testMultipleReadLocks(true); }
-    public void testMultipleReadLocks(boolean fair) {
+    private void testMultipleReadLocks(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.readLock().lock();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -487,9 +528,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * A writelock succeeds only after a reading thread unlocks
      */
+    @Test
     public void testWriteAfterReadLock()      { testWriteAfterReadLock(false); }
+    @Test
     public void testWriteAfterReadLock_fair() { testWriteAfterReadLock(true); }
-    public void testWriteAfterReadLock(boolean fair) {
+    private void testWriteAfterReadLock(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.readLock().lock();
@@ -512,9 +555,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * A writelock succeeds only after reading threads unlock
      */
+    @Test
     public void testWriteAfterMultipleReadLocks()      { testWriteAfterMultipleReadLocks(false); }
+    @Test
     public void testWriteAfterMultipleReadLocks_fair() { testWriteAfterMultipleReadLocks(true); }
-    public void testWriteAfterMultipleReadLocks(boolean fair) {
+    private void testWriteAfterMultipleReadLocks(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.readLock().lock();
@@ -548,6 +593,7 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
      * A thread that tries to acquire a fair read lock (non-reentrantly)
      * will block if there is a waiting writer thread
      */
+    @Test
     public void testReaderWriterReaderFairFifo() {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(true);
@@ -585,9 +631,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Readlocks succeed only after a writing thread unlocks
      */
+    @Test
     public void testReadAfterWriteLock()      { testReadAfterWriteLock(false); }
+    @Test
     public void testReadAfterWriteLock_fair() { testReadAfterWriteLock(true); }
-    public void testReadAfterWriteLock(boolean fair) {
+    private void testReadAfterWriteLock(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -612,9 +660,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Read trylock succeeds if write locked by current thread
      */
+    @Test
     public void testReadHoldingWriteLock()      { testReadHoldingWriteLock(false); }
+    @Test
     public void testReadHoldingWriteLock_fair() { testReadHoldingWriteLock(true); }
-    public void testReadHoldingWriteLock(boolean fair) {
+    private void testReadHoldingWriteLock(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.writeLock().lock();
         assertTrue(lock.readLock().tryLock());
@@ -626,9 +676,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
      * Read trylock succeeds (barging) even in the presence of waiting
      * readers and/or writers
      */
+    @Test
     public void testReadTryLockBarging()      { testReadTryLockBarging(false); }
+    @Test
     public void testReadTryLockBarging_fair() { testReadTryLockBarging(true); }
-    public void testReadTryLockBarging(boolean fair) {
+    private void testReadTryLockBarging(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.readLock().lock();
@@ -669,9 +721,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
      * Read lock succeeds if write locked by current thread even if
      * other threads are waiting for readlock
      */
+    @Test
     public void testReadHoldingWriteLock2()      { testReadHoldingWriteLock2(false); }
+    @Test
     public void testReadHoldingWriteLock2_fair() { testReadHoldingWriteLock2(true); }
-    public void testReadHoldingWriteLock2(boolean fair) {
+    private void testReadHoldingWriteLock2(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -703,9 +757,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
      * Read lock succeeds if write locked by current thread even if
      * other threads are waiting for writelock
      */
+    @Test
     public void testReadHoldingWriteLock3()      { testReadHoldingWriteLock3(false); }
+    @Test
     public void testReadHoldingWriteLock3_fair() { testReadHoldingWriteLock3(true); }
-    public void testReadHoldingWriteLock3(boolean fair) {
+    private void testReadHoldingWriteLock3(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -738,9 +794,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
      * Write lock succeeds if write locked by current thread even if
      * other threads are waiting for writelock
      */
+    @Test
     public void testWriteHoldingWriteLock4()      { testWriteHoldingWriteLock4(false); }
+    @Test
     public void testWriteHoldingWriteLock4_fair() { testWriteHoldingWriteLock4(true); }
-    public void testWriteHoldingWriteLock4(boolean fair) {
+    private void testWriteHoldingWriteLock4(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         lock.writeLock().lock();
@@ -776,9 +834,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Read tryLock succeeds if readlocked but not writelocked
      */
+    @Test
     public void testTryLockWhenReadLocked()      { testTryLockWhenReadLocked(false); }
+    @Test
     public void testTryLockWhenReadLocked_fair() { testTryLockWhenReadLocked(true); }
-    public void testTryLockWhenReadLocked(boolean fair) {
+    private void testTryLockWhenReadLocked(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.readLock().lock();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -794,9 +854,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write tryLock fails when readlocked
      */
+    @Test
     public void testWriteTryLockWhenReadLocked()      { testWriteTryLockWhenReadLocked(false); }
+    @Test
     public void testWriteTryLockWhenReadLocked_fair() { testWriteTryLockWhenReadLocked(true); }
-    public void testWriteTryLockWhenReadLocked(boolean fair) {
+    private void testWriteTryLockWhenReadLocked(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.readLock().lock();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -811,9 +873,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write timed tryLock times out if locked
      */
+    @Test
     public void testWriteTryLock_Timeout()      { testWriteTryLock_Timeout(false); }
+    @Test
     public void testWriteTryLock_Timeout_fair() { testWriteTryLock_Timeout(true); }
-    public void testWriteTryLock_Timeout(boolean fair) {
+    private void testWriteTryLock_Timeout(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final long timeoutMillis = timeoutMillis();
@@ -832,9 +896,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * read timed tryLock times out if write-locked
      */
+    @Test
     public void testReadTryLock_Timeout()      { testReadTryLock_Timeout(false); }
+    @Test
     public void testReadTryLock_Timeout_fair() { testReadTryLock_Timeout(true); }
-    public void testReadTryLock_Timeout(boolean fair) {
+    private void testReadTryLock_Timeout(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.writeLock().lock();
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -853,9 +919,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * write lockInterruptibly succeeds if unlocked, else is interruptible
      */
+    @Test
     public void testWriteLockInterruptibly()      { testWriteLockInterruptibly(false); }
+    @Test
     public void testWriteLockInterruptibly_fair() { testWriteLockInterruptibly(true); }
-    public void testWriteLockInterruptibly(boolean fair) {
+    private void testWriteLockInterruptibly(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         try {
@@ -876,9 +944,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * read lockInterruptibly succeeds if lock free else is interruptible
      */
+    @Test
     public void testReadLockInterruptibly()      { testReadLockInterruptibly(false); }
+    @Test
     public void testReadLockInterruptibly_fair() { testReadLockInterruptibly(true); }
-    public void testReadLockInterruptibly(boolean fair) {
+    private void testReadLockInterruptibly(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         try {
@@ -900,9 +970,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Calling await without holding lock throws IllegalMonitorStateException
      */
+    @Test
     public void testAwait_IMSE()      { testAwait_IMSE(false); }
+    @Test
     public void testAwait_IMSE_fair() { testAwait_IMSE(true); }
-    public void testAwait_IMSE(boolean fair) {
+    private void testAwait_IMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         for (AwaitMethod awaitMethod : AwaitMethod.values()) {
@@ -921,9 +993,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Calling signal without holding lock throws IllegalMonitorStateException
      */
+    @Test
     public void testSignal_IMSE()      { testSignal_IMSE(false); }
+    @Test
     public void testSignal_IMSE_fair() { testSignal_IMSE(true); }
-    public void testSignal_IMSE(boolean fair) {
+    private void testSignal_IMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         try {
@@ -935,9 +1009,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * Calling signalAll without holding lock throws IllegalMonitorStateException
      */
+    @Test
     public void testSignalAll_IMSE()      { testSignalAll_IMSE(false); }
+    @Test
     public void testSignalAll_IMSE_fair() { testSignalAll_IMSE(true); }
-    public void testSignalAll_IMSE(boolean fair) {
+    private void testSignalAll_IMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         try {
@@ -949,9 +1025,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * awaitNanos without a signal times out
      */
+    @Test
     public void testAwaitNanos_Timeout()      { testAwaitNanos_Timeout(false); }
+    @Test
     public void testAwaitNanos_Timeout_fair() { testAwaitNanos_Timeout(true); }
-    public void testAwaitNanos_Timeout(boolean fair) {
+    private void testAwaitNanos_Timeout(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         final long timeoutMillis = timeoutMillis();
@@ -969,9 +1047,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * timed await without a signal times out
      */
+    @Test
     public void testAwait_Timeout()      { testAwait_Timeout(false); }
+    @Test
     public void testAwait_Timeout_fair() { testAwait_Timeout(true); }
-    public void testAwait_Timeout(boolean fair) {
+    private void testAwait_Timeout(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         final long timeoutMillis = timeoutMillis();
@@ -987,9 +1067,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * awaitUntil without a signal times out
      */
+    @Test
     public void testAwaitUntil_Timeout()      { testAwaitUntil_Timeout(false); }
+    @Test
     public void testAwaitUntil_Timeout_fair() { testAwaitUntil_Timeout(true); }
-    public void testAwaitUntil_Timeout(boolean fair) {
+    private void testAwaitUntil_Timeout(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         lock.writeLock().lock();
@@ -1006,9 +1088,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * await returns when signalled
      */
+    @Test
     public void testAwait()      { testAwait(false); }
+    @Test
     public void testAwait_fair() { testAwait(true); }
-    public void testAwait(boolean fair) {
+    private void testAwait(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1034,9 +1118,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * awaitUninterruptibly is uninterruptible
      */
+    @Test
     public void testAwaitUninterruptibly()      { testAwaitUninterruptibly(false); }
+    @Test
     public void testAwaitUninterruptibly_fair() { testAwaitUninterruptibly(true); }
-    public void testAwaitUninterruptibly(boolean fair) {
+    private void testAwaitUninterruptibly(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
@@ -1081,15 +1167,23 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * await/awaitNanos/awaitUntil is interruptible
      */
+    @Test
     public void testInterruptible_await()           { testInterruptible(false, AwaitMethod.await); }
+    @Test
     public void testInterruptible_await_fair()      { testInterruptible(true,  AwaitMethod.await); }
+    @Test
     public void testInterruptible_awaitTimed()      { testInterruptible(false, AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitTimed_fair() { testInterruptible(true,  AwaitMethod.awaitTimed); }
+    @Test
     public void testInterruptible_awaitNanos()      { testInterruptible(false, AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitNanos_fair() { testInterruptible(true,  AwaitMethod.awaitNanos); }
+    @Test
     public void testInterruptible_awaitUntil()      { testInterruptible(false, AwaitMethod.awaitUntil); }
+    @Test
     public void testInterruptible_awaitUntil_fair() { testInterruptible(true,  AwaitMethod.awaitUntil); }
-    public void testInterruptible(boolean fair, final AwaitMethod awaitMethod) {
+    private void testInterruptible(boolean fair, final AwaitMethod awaitMethod) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1120,15 +1214,23 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * signalAll wakes up all threads
      */
+    @Test
     public void testSignalAll_await()           { testSignalAll(false, AwaitMethod.await); }
+    @Test
     public void testSignalAll_await_fair()      { testSignalAll(true,  AwaitMethod.await); }
+    @Test
     public void testSignalAll_awaitTimed()      { testSignalAll(false, AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitTimed_fair() { testSignalAll(true,  AwaitMethod.awaitTimed); }
+    @Test
     public void testSignalAll_awaitNanos()      { testSignalAll(false, AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitNanos_fair() { testSignalAll(true,  AwaitMethod.awaitNanos); }
+    @Test
     public void testSignalAll_awaitUntil()      { testSignalAll(false, AwaitMethod.awaitUntil); }
+    @Test
     public void testSignalAll_awaitUntil_fair() { testSignalAll(true,  AwaitMethod.awaitUntil); }
-    public void testSignalAll(boolean fair, final AwaitMethod awaitMethod) {
+    private void testSignalAll(boolean fair, final AwaitMethod awaitMethod) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1159,9 +1261,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * signal wakes up waiting threads in FIFO order
      */
+    @Test
     public void testSignalWakesFifo()      { testSignalWakesFifo(false); }
+    @Test
     public void testSignalWakesFifo_fair() { testSignalWakesFifo(true); }
-    public void testSignalWakesFifo(boolean fair) {
+    private void testSignalWakesFifo(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1207,9 +1311,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * await after multiple reentrant locking preserves lock count
      */
+    @Test
     public void testAwaitLockCount()      { testAwaitLockCount(false); }
+    @Test
     public void testAwaitLockCount_fair() { testAwaitLockCount(true); }
-    public void testAwaitLockCount(boolean fair) {
+    private void testAwaitLockCount(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1253,9 +1359,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * A serialized lock deserializes as unlocked
      */
+    @Test
     public void testSerialization()      { testSerialization(false); }
+    @Test
     public void testSerialization_fair() { testSerialization(true); }
-    public void testSerialization(boolean fair) {
+    private void testSerialization(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         lock.writeLock().lock();
         lock.readLock().lock();
@@ -1280,9 +1388,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasQueuedThreads reports whether there are waiting threads
      */
+    @Test
     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
+    @Test
     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
-    public void testHasQueuedThreads(boolean fair) {
+    private void testHasQueuedThreads(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
@@ -1307,9 +1417,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasQueuedThread(null) throws NPE
      */
+    @Test
     public void testHasQueuedThreadNPE()      { testHasQueuedThreadNPE(false); }
+    @Test
     public void testHasQueuedThreadNPE_fair() { testHasQueuedThreadNPE(true); }
-    public void testHasQueuedThreadNPE(boolean fair) {
+    private void testHasQueuedThreadNPE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         try {
             lock.hasQueuedThread(null);
@@ -1320,9 +1432,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasQueuedThread reports whether a thread is queued
      */
+    @Test
     public void testHasQueuedThread()      { testHasQueuedThread(false); }
+    @Test
     public void testHasQueuedThread_fair() { testHasQueuedThread(true); }
-    public void testHasQueuedThread(boolean fair) {
+    private void testHasQueuedThread(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
@@ -1351,9 +1465,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getQueueLength reports number of waiting threads
      */
+    @Test
     public void testGetQueueLength()      { testGetQueueLength(false); }
+    @Test
     public void testGetQueueLength_fair() { testGetQueueLength(true); }
-    public void testGetQueueLength(boolean fair) {
+    private void testGetQueueLength(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
@@ -1377,9 +1493,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getQueuedThreads includes waiting threads
      */
+    @Test
     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
+    @Test
     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
-    public void testGetQueuedThreads(boolean fair) {
+    private void testGetQueuedThreads(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
@@ -1409,9 +1527,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws NPE if null
      */
+    @Test
     public void testHasWaitersNPE()      { testHasWaitersNPE(false); }
+    @Test
     public void testHasWaitersNPE_fair() { testHasWaitersNPE(true); }
-    public void testHasWaitersNPE(boolean fair) {
+    private void testHasWaitersNPE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         try {
             lock.hasWaiters(null);
@@ -1422,9 +1542,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws NPE if null
      */
+    @Test
     public void testGetWaitQueueLengthNPE()      { testGetWaitQueueLengthNPE(false); }
+    @Test
     public void testGetWaitQueueLengthNPE_fair() { testGetWaitQueueLengthNPE(true); }
-    public void testGetWaitQueueLengthNPE(boolean fair) {
+    private void testGetWaitQueueLengthNPE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         try {
             lock.getWaitQueueLength(null);
@@ -1435,9 +1557,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws NPE if null
      */
+    @Test
     public void testGetWaitingThreadsNPE()      { testGetWaitingThreadsNPE(false); }
+    @Test
     public void testGetWaitingThreadsNPE_fair() { testGetWaitingThreadsNPE(true); }
-    public void testGetWaitingThreadsNPE(boolean fair) {
+    private void testGetWaitingThreadsNPE(boolean fair) {
         final PublicReentrantReadWriteLock lock = new PublicReentrantReadWriteLock(fair);
         try {
             lock.getWaitingThreads(null);
@@ -1448,9 +1572,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalArgumentException if not owned
      */
+    @Test
     public void testHasWaitersIAE()      { testHasWaitersIAE(false); }
+    @Test
     public void testHasWaitersIAE_fair() { testHasWaitersIAE(true); }
-    public void testHasWaitersIAE(boolean fair) {
+    private void testHasWaitersIAE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         final ReentrantReadWriteLock lock2 = new ReentrantReadWriteLock(fair);
@@ -1463,9 +1589,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasWaiters throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testHasWaitersIMSE()      { testHasWaitersIMSE(false); }
+    @Test
     public void testHasWaitersIMSE_fair() { testHasWaitersIMSE(true); }
-    public void testHasWaitersIMSE(boolean fair) {
+    private void testHasWaitersIMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         try {
@@ -1477,9 +1605,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitQueueLengthIAE()      { testGetWaitQueueLengthIAE(false); }
+    @Test
     public void testGetWaitQueueLengthIAE_fair() { testGetWaitQueueLengthIAE(true); }
-    public void testGetWaitQueueLengthIAE(boolean fair) {
+    private void testGetWaitQueueLengthIAE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         final ReentrantReadWriteLock lock2 = new ReentrantReadWriteLock(fair);
@@ -1492,9 +1622,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testGetWaitQueueLengthIMSE()      { testGetWaitQueueLengthIMSE(false); }
+    @Test
     public void testGetWaitQueueLengthIMSE_fair() { testGetWaitQueueLengthIMSE(true); }
-    public void testGetWaitQueueLengthIMSE(boolean fair) {
+    private void testGetWaitQueueLengthIMSE(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
         try {
@@ -1506,9 +1638,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalArgumentException if not owned
      */
+    @Test
     public void testGetWaitingThreadsIAE()      { testGetWaitingThreadsIAE(false); }
+    @Test
     public void testGetWaitingThreadsIAE_fair() { testGetWaitingThreadsIAE(true); }
-    public void testGetWaitingThreadsIAE(boolean fair) {
+    private void testGetWaitingThreadsIAE(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1523,9 +1657,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads throws IllegalMonitorStateException if not locked
      */
+    @Test
     public void testGetWaitingThreadsIMSE()      { testGetWaitingThreadsIMSE(false); }
+    @Test
     public void testGetWaitingThreadsIMSE_fair() { testGetWaitingThreadsIMSE(true); }
-    public void testGetWaitingThreadsIMSE(boolean fair) {
+    private void testGetWaitingThreadsIMSE(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1538,9 +1674,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * hasWaiters returns true when a thread is waiting, else false
      */
+    @Test
     public void testHasWaiters()      { testHasWaiters(false); }
+    @Test
     public void testHasWaiters_fair() { testHasWaiters(true); }
-    public void testHasWaiters(boolean fair) {
+    private void testHasWaiters(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1572,9 +1710,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitQueueLength returns number of waiting threads
      */
+    @Test
     public void testGetWaitQueueLength()      { testGetWaitQueueLength(false); }
+    @Test
     public void testGetWaitQueueLength_fair() { testGetWaitQueueLength(true); }
-    public void testGetWaitQueueLength(boolean fair) {
+    private void testGetWaitQueueLength(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1602,9 +1742,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * getWaitingThreads returns only and all waiting threads
      */
+    @Test
     public void testGetWaitingThreads()      { testGetWaitingThreads(false); }
+    @Test
     public void testGetWaitingThreads_fair() { testGetWaitingThreads(true); }
-    public void testGetWaitingThreads(boolean fair) {
+    private void testGetWaitingThreads(boolean fair) {
         final PublicReentrantReadWriteLock lock =
             new PublicReentrantReadWriteLock(fair);
         final Condition c = lock.writeLock().newCondition();
@@ -1655,9 +1797,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * toString indicates current lock state
      */
+    @Test
     public void testToString()      { testToString(false); }
+    @Test
     public void testToString_fair() { testToString(true); }
-    public void testToString(boolean fair) {
+    private void testToString(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         assertTrue(lock.toString().contains("Write locks = 0"));
         assertTrue(lock.toString().contains("Read locks = 0"));
@@ -1680,9 +1824,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * readLock.toString indicates current lock state
      */
+    @Test
     public void testReadLockToString()      { testReadLockToString(false); }
+    @Test
     public void testReadLockToString_fair() { testReadLockToString(true); }
-    public void testReadLockToString(boolean fair) {
+    private void testReadLockToString(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         assertTrue(lock.readLock().toString().contains("Read locks = 0"));
         lock.readLock().lock();
@@ -1698,9 +1844,11 @@ public class ReentrantReadWriteLockTest extends JSR166TestCase {
     /**
      * writeLock.toString indicates current lock state
      */
+    @Test
     public void testWriteLockToString()      { testWriteLockToString(false); }
+    @Test
     public void testWriteLockToString_fair() { testWriteLockToString(true); }
-    public void testWriteLockToString(boolean fair) {
+    private void testWriteLockToString(boolean fair) {
         final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(fair);
         assertTrue(lock.writeLock().toString().contains("Unlocked"));
         lock.writeLock().lock();
diff --git a/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java b/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java
index 11a164a4c21..7b6f0420844 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java
@@ -35,6 +35,14 @@ package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import android.platform.test.annotations.LargeTest;
 
@@ -62,16 +70,21 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ScheduledExecutorSubclassTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ScheduledExecutorSubclassTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ScheduledExecutorSubclassTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ScheduledExecutorSubclassTest.class);
+    // }
 
     static class CustomTask<V> implements RunnableScheduledFuture<V> {
         private final RunnableScheduledFuture<V> task;
@@ -130,6 +143,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute successfully executes a runnable
      */
+    @Test
     public void testExecute() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -144,6 +158,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * delayed schedule of callable successfully executes after delay
      */
+    @Test
     public void testSchedule1() throws Exception {
         final CountDownLatch done = new CountDownLatch(1);
         final CustomExecutor p = new CustomExecutor(1);
@@ -164,6 +179,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * delayed schedule of runnable successfully executes after delay
      */
+    @Test
     public void testSchedule3() throws Exception {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -184,6 +200,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * scheduleAtFixedRate executes runnable after given initial delay
      */
+    @Test
     public void testSchedule4() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -206,6 +223,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * scheduleWithFixedDelay executes runnable after given initial delay
      */
+    @Test
     public void testSchedule5() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -235,6 +253,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * Eventually, it must hold that:
      *   cycles - 1 <= elapsedMillis/delay < cycles
      */
+    @Test
     public void testFixedRateSequence() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -264,6 +283,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * Eventually, it must hold that each task starts at least delay and at
      * most 2 * delay after the termination of the previous task.
      */
+    @Test
     public void testFixedDelaySequence() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -308,6 +328,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute(null) throws NPE
      */
+    @Test
     public void testExecuteNull() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -321,6 +342,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * schedule(null) throws NPE
      */
+    @Test
     public void testScheduleNull() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -335,6 +357,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule1_RejectedExecutionException() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -351,6 +374,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * schedule throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule2_RejectedExecutionException() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -367,6 +391,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * schedule callable throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule3_RejectedExecutionException() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -383,6 +408,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * scheduleAtFixedRate throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testScheduleAtFixedRate1_RejectedExecutionException() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -399,6 +425,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * scheduleWithFixedDelay throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testScheduleWithFixedDelay1_RejectedExecutionException() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -416,6 +443,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * getActiveCount increases but doesn't overestimate, when a
      * thread becomes active
      */
+    @Test
     public void testGetActiveCount() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p = new CustomExecutor(2);
@@ -437,6 +465,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * getCompletedTaskCount increases, but doesn't overestimate,
      * when tasks complete
      */
+    @Test
     public void testGetCompletedTaskCount() throws InterruptedException {
         final ThreadPoolExecutor p = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -467,6 +496,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * getCorePoolSize returns size given in constructor if not otherwise set
      */
+    @Test
     public void testGetCorePoolSize() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -478,6 +508,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * getLargestPoolSize increases, but doesn't overestimate, when
      * multiple threads active
      */
+    @Test
     public void testGetLargestPoolSize() throws InterruptedException {
         final int THREADS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -502,6 +533,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * getPoolSize increases, but doesn't overestimate, when threads
      * become active
      */
+    @Test
     public void testGetPoolSize() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p = new CustomExecutor(1);
@@ -523,6 +555,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * getTaskCount increases, but doesn't overestimate, when tasks
      * submitted
      */
+    @Test
     public void testGetTaskCount() throws InterruptedException {
         final int TASKS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -558,6 +591,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * getThreadFactory returns factory in constructor if not set
      */
+    @Test
     public void testGetThreadFactory() {
         final ThreadFactory threadFactory = new SimpleThreadFactory();
         final CustomExecutor p = new CustomExecutor(1, threadFactory);
@@ -569,6 +603,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * setThreadFactory sets the thread factory returned by getThreadFactory
      */
+    @Test
     public void testSetThreadFactory() {
         final ThreadFactory threadFactory = new SimpleThreadFactory();
         final CustomExecutor p = new CustomExecutor(1);
@@ -581,6 +616,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * setThreadFactory(null) throws NPE
      */
+    @Test
     public void testSetThreadFactoryNull() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -594,6 +630,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * isShutdown is false before shutdown, true after
      */
+    @Test
     public void testIsShutdown() {
         final CustomExecutor p = new CustomExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -606,6 +643,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * isTerminated is false before termination, true after
      */
+    @Test
     public void testIsTerminated() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p = new CustomExecutor(1);
@@ -630,6 +668,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * isTerminating is not true when running or when terminated
      */
+    @Test
     public void testIsTerminating() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p = new CustomExecutor(1);
@@ -655,6 +694,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * getQueue returns the work queue, which contains queued tasks
      */
+    @Test
     public void testGetQueue() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ScheduledThreadPoolExecutor p = new CustomExecutor(1);
@@ -679,6 +719,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * remove(task) removes queued task, and fails to remove active task
      */
+    @Test
     public void testRemove() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ScheduledThreadPoolExecutor p = new CustomExecutor(1);
@@ -710,6 +751,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * purge removes cancelled tasks from the queue
      */
+    @Test
     public void testPurge() throws InterruptedException {
         final ScheduledFuture[] tasks = new ScheduledFuture[5];
         final Runnable releaser = new Runnable() { public void run() {
@@ -740,6 +782,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow() throws InterruptedException {
         final int poolSize = 2;
         final int count = 5;
@@ -777,6 +820,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow_delayedTasks() throws InterruptedException {
         final CustomExecutor p = new CustomExecutor(1);
         List<ScheduledFuture> tasks = new ArrayList<>();
@@ -816,6 +860,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
      * - setContinueExistingPeriodicTasksAfterShutdownPolicy
      */
     @LargeTest
+    @Test
     public void testShutdown_cancellation() throws Exception {
         Boolean[] allBooleans = { null, Boolean.FALSE, Boolean.TRUE };
         for (Boolean policy : allBooleans)
@@ -907,6 +952,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of callable returns result
      */
+    @Test
     public void testSubmitCallable() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -919,6 +965,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of runnable returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -931,6 +978,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of (runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -943,6 +991,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NPE
      */
+    @Test
     public void testInvokeAny1() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -956,6 +1005,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testInvokeAny2() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -969,6 +1019,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAny3() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e = new CustomExecutor(2);
@@ -987,6 +1038,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testInvokeAny4() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1004,6 +1056,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task
      */
+    @Test
     public void testInvokeAny5() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1018,6 +1071,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NPE
      */
+    @Test
     public void testInvokeAll1() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1031,6 +1085,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1042,6 +1097,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1058,6 +1114,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * get of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testInvokeAll4() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1077,6 +1134,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testInvokeAll5() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1093,6 +1151,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAny1() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1106,6 +1165,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1121,6 +1181,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testTimedInvokeAny2() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1134,6 +1195,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e = new CustomExecutor(2);
@@ -1152,6 +1214,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1171,6 +1234,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task
      */
+    @Test
     public void testTimedInvokeAny5() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1187,6 +1251,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAll1() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1200,6 +1265,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1215,6 +1281,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1226,6 +1293,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1242,6 +1310,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1262,6 +1331,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testTimedInvokeAll5() throws Exception {
         final ExecutorService e = new CustomExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1279,6 +1349,7 @@ public class ScheduledExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) cancels tasks not completed by timeout
      */
+    @Test
     public void testTimedInvokeAll6() throws Exception {
         for (long timeout = timeoutMillis();;) {
             final CountDownLatch done = new CountDownLatch(1);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorTest.java b/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorTest.java
index bcc8e22d575..dde78f3e5c1 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ScheduledExecutorTest.java
@@ -38,6 +38,15 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import android.platform.test.annotations.LargeTest;
 
 import java.util.ArrayList;
@@ -46,6 +55,7 @@ import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -59,20 +69,36 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import libcore.junit.util.compat.CoreCompatChangeRule;
+import libcore.junit.util.compat.CoreCompatChangeRule.DisableCompatChanges;
+import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ScheduledExecutorTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ScheduledExecutorTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ScheduledExecutorTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ScheduledExecutorTest.class);
+    // }
+
+    // Android-changed: b/288912692 need this to support added test cases.
+    @Rule
+    public final TestRule compatChangeRule = new CoreCompatChangeRule();
 
     /**
      * execute successfully executes a runnable
      */
+    @Test
     public void testExecute() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -87,6 +113,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * delayed schedule of callable successfully executes after delay
      */
+    @Test
     public void testSchedule1() throws Exception {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -108,6 +135,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * delayed schedule of runnable successfully executes after delay
      */
+    @Test
     public void testSchedule3() throws Exception {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -128,6 +156,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * scheduleAtFixedRate executes runnable after given initial delay
      */
+    @Test
     public void testSchedule4() throws Exception {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -150,6 +179,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * scheduleWithFixedDelay executes runnable after given initial delay
      */
+    @Test
     public void testSchedule5() throws Exception {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -179,6 +209,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * Eventually, it must hold that:
      *   cycles - 1 <= elapsedMillis/delay < cycles
      */
+    @Test
     public void testFixedRateSequence() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -203,11 +234,122 @@ public class ScheduledExecutorTest extends JSR166TestCase {
         }
     }
 
+    /**
+     * scheduleAtFixedRate executes series of tasks at given rate.
+     * The first task intentionally sleeps for 3 periods.
+     * Expect to catch up to only 1 missed execution.
+     * This is a variation on {@link testFixedRateSequence} but with
+     * {@link ScheduledThreadPoolExecutor.STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS}
+     * enabled.
+     */
+    // Android-changed: b/288912692 added this test case to test new behavior.
+    @EnableCompatChanges({ScheduledThreadPoolExecutor.STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS})
+    @Test
+    public void testFixedRateSequenceSkipMultipleMissedFixedRateTasksEnabled()
+            throws InterruptedException {
+        assertTrue(
+           ScheduledThreadPoolExecutor.skipMultipleMissedPeriodicTasks());
+
+        final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
+        final ConcurrentLinkedQueue<Long> executionTimes =
+                new ConcurrentLinkedQueue<>();
+        try (PoolCleaner cleaner = cleaner(p)) {
+            for (int delay = 1; delay <= 1_000; delay *= 3) {
+                final long startTime = System.nanoTime();
+                final int cycles = 8;
+                // Sleep for 3 periods before running the first task, causing us
+                // to miss 3 executions.
+                final int slept = 3;
+                final CountDownLatch done = new CountDownLatch(cycles);
+                final int thisDelay = delay;
+                final Runnable task = new CheckedRunnable() {
+                    private boolean isFirstRun = true;
+                    public void realRun() throws InterruptedException {
+                        if (isFirstRun) {
+                            isFirstRun = false;
+                            Thread.sleep(thisDelay * ((long) slept));
+                        }
+                        executionTimes.add(System.nanoTime());
+                        done.countDown();
+                    }
+                };
+                final ScheduledFuture periodicTask =
+                    p.scheduleAtFixedRate(task, 0, delay, MILLISECONDS);
+                final int totalDelayMillis = (cycles - 1) * delay;
+                await(done, totalDelayMillis + LONG_DELAY_MS);
+                periodicTask.cancel(true);
+                final long elapsedMillis = millisElapsedSince(startTime);
+                assertTrue(elapsedMillis >= totalDelayMillis);
+                if (elapsedMillis <= (cycles + slept - 1) * delay) {
+                    return;
+                }
+                // else retry with longer delay
+            }
+            fail("unexpected execution rate; times: " + executionTimes);
+        }
+    }
+
+    /**
+     * scheduleAtFixedRate executes series of tasks at given rate.
+     * The first task intentionally sleeps for 3 periods.
+     * We expect to catch up to all 3 missed execution.
+     * This is a variation on {@link testFixedRateSequence} but with
+     * {@link ScheduledThreadPoolExecutor.STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS} disabled.
+     */
+    // Android-changed: b/288912692 added this test case to test new behavior.
+    @DisableCompatChanges({ScheduledThreadPoolExecutor.STPE_SKIP_MULTIPLE_MISSED_PERIODIC_TASKS})
+    @Test
+    public void testFixedRateSequenceSkipMultipleMissedFixedRateTasksDisabled()
+            throws InterruptedException {
+        assertFalse(
+           ScheduledThreadPoolExecutor.skipMultipleMissedPeriodicTasks());
+
+        final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
+        final ConcurrentLinkedQueue<Long> executionTimes =
+                new ConcurrentLinkedQueue<>();
+        try (PoolCleaner cleaner = cleaner(p)) {
+            for (int delay = 1; delay <= 1_000; delay *= 3) {
+                final long startTime = System.nanoTime();
+                final int cycles = 8;
+                // Sleep for 3 periods before running the first task, causing us
+                // to miss 3 executions.
+                final int slept = 3;
+                final CountDownLatch done = new CountDownLatch(cycles);
+                final int thisDelay = delay;
+                final Runnable task = new CheckedRunnable() {
+                    private boolean isFirstRun = true;
+                    public void realRun() throws InterruptedException {
+                        if (isFirstRun) {
+                            isFirstRun = false;
+                            Thread.sleep(thisDelay * ((long) slept));
+                        }
+                        executionTimes.add(System.nanoTime());
+                        done.countDown();
+                    }
+                };
+                final ScheduledFuture periodicTask =
+                    p.scheduleAtFixedRate(task, 0, delay, MILLISECONDS);
+                final int totalDelayMillis = (cycles - 1) * delay;
+                await(done, totalDelayMillis + LONG_DELAY_MS);
+                periodicTask.cancel(true);
+                final long elapsedMillis = millisElapsedSince(startTime);
+                assertTrue(elapsedMillis >= totalDelayMillis);
+                // Expect to have caught up to all missed executions.
+                if (elapsedMillis <= cycles * delay) {
+                    return;
+                }
+                // else retry with longer delay
+            }
+            fail("unexpected execution rate; times: " + executionTimes);
+        }
+    }
+
     /**
      * scheduleWithFixedDelay executes series of tasks with given period.
      * Eventually, it must hold that each task starts at least delay and at
      * most 2 * delay after the termination of the previous task.
      */
+    @Test
     public void testFixedDelaySequence() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -252,6 +394,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * execute(null) throws NPE
      */
+    @Test
     public void testExecuteNull() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -265,6 +408,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * schedule(null) throws NPE
      */
+    @Test
     public void testScheduleNull() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -279,6 +423,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule1_RejectedExecutionException() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -295,6 +440,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * schedule throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule2_RejectedExecutionException() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -311,6 +457,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * schedule callable throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testSchedule3_RejectedExecutionException() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -327,6 +474,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * scheduleAtFixedRate throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testScheduleAtFixedRate1_RejectedExecutionException() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -343,6 +491,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * scheduleWithFixedDelay throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testScheduleWithFixedDelay1_RejectedExecutionException() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -360,6 +509,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * getActiveCount increases but doesn't overestimate, when a
      * thread becomes active
      */
+    @Test
     public void testGetActiveCount() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(2);
@@ -381,6 +531,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * getCompletedTaskCount increases, but doesn't overestimate,
      * when tasks complete
      */
+    @Test
     public void testGetCompletedTaskCount() throws InterruptedException {
         final ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -411,6 +562,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * getCorePoolSize returns size given in constructor if not otherwise set
      */
+    @Test
     public void testGetCorePoolSize() throws InterruptedException {
         ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -422,6 +574,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * getLargestPoolSize increases, but doesn't overestimate, when
      * multiple threads active
      */
+    @Test
     public void testGetLargestPoolSize() throws InterruptedException {
         final int THREADS = 3;
         final ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(THREADS);
@@ -446,6 +599,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * getPoolSize increases, but doesn't overestimate, when threads
      * become active
      */
+    @Test
     public void testGetPoolSize() throws InterruptedException {
         final ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -467,6 +621,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * getTaskCount increases, but doesn't overestimate, when tasks
      * submitted
      */
+    @Test
     public void testGetTaskCount() throws InterruptedException {
         final int TASKS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -502,6 +657,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * getThreadFactory returns factory in constructor if not set
      */
+    @Test
     public void testGetThreadFactory() throws InterruptedException {
         final ThreadFactory threadFactory = new SimpleThreadFactory();
         final ScheduledThreadPoolExecutor p =
@@ -514,6 +670,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * setThreadFactory sets the thread factory returned by getThreadFactory
      */
+    @Test
     public void testSetThreadFactory() throws InterruptedException {
         ThreadFactory threadFactory = new SimpleThreadFactory();
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
@@ -526,6 +683,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * setThreadFactory(null) throws NPE
      */
+    @Test
     public void testSetThreadFactoryNull() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -539,6 +697,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * isShutdown is false before shutdown, true after
      */
+    @Test
     public void testIsShutdown() {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         assertFalse(p.isShutdown());
@@ -553,6 +712,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * isTerminated is false before termination, true after
      */
+    @Test
     public void testIsTerminated() throws InterruptedException {
         final ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -577,6 +737,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * isTerminating is not true when running or when terminated
      */
+    @Test
     public void testIsTerminating() throws InterruptedException {
         final ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         final CountDownLatch threadStarted = new CountDownLatch(1);
@@ -602,6 +763,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * getQueue returns the work queue, which contains queued tasks
      */
+    @Test
     public void testGetQueue() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
@@ -626,6 +788,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * remove(task) removes queued task, and fails to remove active task
      */
+    @Test
     public void testRemove() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
@@ -657,6 +820,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * purge eventually removes cancelled tasks from the queue
      */
+    @Test
     public void testPurge() throws InterruptedException {
         final ScheduledFuture[] tasks = new ScheduledFuture[5];
         final Runnable releaser = new Runnable() { public void run() {
@@ -687,6 +851,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow() throws InterruptedException {
         final int poolSize = 2;
         final int count = 5;
@@ -725,6 +890,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow_delayedTasks() throws InterruptedException {
         final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);
         List<ScheduledFuture> tasks = new ArrayList<>();
@@ -763,6 +929,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * - setContinueExistingPeriodicTasksAfterShutdownPolicy
      */
     @LargeTest
+    @Test
     public void testShutdown_cancellation() throws Exception {
         Boolean[] allBooleans = { null, Boolean.FALSE, Boolean.TRUE };
         for (Boolean policy : allBooleans)
@@ -855,6 +1022,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * completed submit of callable returns result
      */
+    @Test
     public void testSubmitCallable() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -867,6 +1035,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * completed submit of runnable returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -879,6 +1048,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * completed submit of (runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -891,6 +1061,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NPE
      */
+    @Test
     public void testInvokeAny1() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -904,6 +1075,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testInvokeAny2() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -917,6 +1089,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAny3() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
@@ -935,6 +1108,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testInvokeAny4() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -952,6 +1126,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task
      */
+    @Test
     public void testInvokeAny5() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -966,6 +1141,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NPE
      */
+    @Test
     public void testInvokeAll1() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -979,6 +1155,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -990,6 +1167,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1006,6 +1184,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * get of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testInvokeAll4() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1025,6 +1204,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testInvokeAll5() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1041,6 +1221,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAny1() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1054,6 +1235,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1069,6 +1251,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testTimedInvokeAny2() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1082,6 +1265,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
@@ -1100,6 +1284,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1119,6 +1304,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task
      */
+    @Test
     public void testTimedInvokeAny5() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1135,6 +1321,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAll1() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1148,6 +1335,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1163,6 +1351,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1175,6 +1364,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1191,6 +1381,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1211,6 +1402,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testTimedInvokeAll5() throws Exception {
         final ExecutorService e = new ScheduledThreadPoolExecutor(2);
         try (PoolCleaner cleaner = cleaner(e)) {
@@ -1228,6 +1420,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) cancels tasks not completed by timeout
      */
+    @Test
     public void testTimedInvokeAll6() throws Exception {
         for (long timeout = timeoutMillis();;) {
             final CountDownLatch done = new CountDownLatch(1);
@@ -1268,6 +1461,7 @@ public class ScheduledExecutorTest extends JSR166TestCase {
      * one-shot task from executing.
      * https://bugs.openjdk.java.net/browse/JDK-8051859
      */
+    @Test
     public void testScheduleWithFixedDelay_overflow() throws Exception {
         final CountDownLatch delayedDone = new CountDownLatch(1);
         final CountDownLatch immediateDone = new CountDownLatch(1);
diff --git a/ojluni/src/test/java/util/concurrent/tck/SemaphoreTest.java b/ojluni/src/test/java/util/concurrent/tck/SemaphoreTest.java
index 3c0321f6c94..9bc106fb649 100644
--- a/ojluni/src/test/java/util/concurrent/tck/SemaphoreTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/SemaphoreTest.java
@@ -35,22 +35,34 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.Collection;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Semaphore;
 
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class SemaphoreTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(SemaphoreTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.SemaphoreTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(SemaphoreTest.class);
+    // }
 
     /**
      * Subclass to expose protected methods
@@ -101,7 +113,7 @@ public class SemaphoreTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!s.hasQueuedThread(t)) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
         assertTrue(s.hasQueuedThreads());
@@ -115,7 +127,7 @@ public class SemaphoreTest extends JSR166TestCase {
         long startTime = System.nanoTime();
         while (!s.hasQueuedThreads()) {
             if (millisElapsedSince(startTime) > LONG_DELAY_MS)
-                throw new AssertionFailedError("timed out");
+                fail("timed out");
             Thread.yield();
         }
     }
@@ -178,9 +190,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * Zero, negative, and positive initial values are allowed in constructor
      */
+    @Test
     public void testConstructor()      { testConstructor(false); }
+    @Test
     public void testConstructor_fair() { testConstructor(true); }
-    public void testConstructor(boolean fair) {
+    private void testConstructor(boolean fair) {
         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
             Semaphore s = new Semaphore(permits, fair);
             assertEquals(permits, s.availablePermits());
@@ -191,6 +205,7 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * Constructor without fairness argument behaves as nonfair
      */
+    @Test
     public void testConstructorDefaultsToNonFair() {
         for (int permits : new int[] { -42, -1, 0, 1, 42 }) {
             Semaphore s = new Semaphore(permits);
@@ -202,9 +217,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * tryAcquire succeeds when sufficient permits, else fails
      */
+    @Test
     public void testTryAcquireInSameThread()      { testTryAcquireInSameThread(false); }
+    @Test
     public void testTryAcquireInSameThread_fair() { testTryAcquireInSameThread(true); }
-    public void testTryAcquireInSameThread(boolean fair) {
+    private void testTryAcquireInSameThread(boolean fair) {
         Semaphore s = new Semaphore(2, fair);
         assertEquals(2, s.availablePermits());
         assertTrue(s.tryAcquire());
@@ -218,9 +235,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * timed tryAcquire times out
      */
+    @Test
     public void testTryAcquire_timeout()      { testTryAcquire_timeout(false); }
+    @Test
     public void testTryAcquire_timeout_fair() { testTryAcquire_timeout(true); }
-    public void testTryAcquire_timeout(boolean fair) {
+    private void testTryAcquire_timeout(boolean fair) {
         Semaphore s = new Semaphore(0, fair);
         long startTime = System.nanoTime();
         try { assertFalse(s.tryAcquire(timeoutMillis(), MILLISECONDS)); }
@@ -231,9 +250,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * timed tryAcquire(N) times out
      */
+    @Test
     public void testTryAcquireN_timeout()      { testTryAcquireN_timeout(false); }
+    @Test
     public void testTryAcquireN_timeout_fair() { testTryAcquireN_timeout(true); }
-    public void testTryAcquireN_timeout(boolean fair) {
+    private void testTryAcquireN_timeout(boolean fair) {
         Semaphore s = new Semaphore(2, fair);
         long startTime = System.nanoTime();
         try { assertFalse(s.tryAcquire(3, timeoutMillis(), MILLISECONDS)); }
@@ -245,15 +266,23 @@ public class SemaphoreTest extends JSR166TestCase {
      * acquire(), acquire(N), timed tryAcquired, timed tryAcquire(N)
      * are interruptible
      */
+    @Test
     public void testInterruptible_acquire()               { testInterruptible(false, AcquireMethod.acquire); }
+    @Test
     public void testInterruptible_acquire_fair()          { testInterruptible(true,  AcquireMethod.acquire); }
+    @Test
     public void testInterruptible_acquireN()              { testInterruptible(false, AcquireMethod.acquireN); }
+    @Test
     public void testInterruptible_acquireN_fair()         { testInterruptible(true,  AcquireMethod.acquireN); }
+    @Test
     public void testInterruptible_tryAcquireTimed()       { testInterruptible(false, AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testInterruptible_tryAcquireTimed_fair()  { testInterruptible(true,  AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testInterruptible_tryAcquireTimedN()      { testInterruptible(false, AcquireMethod.tryAcquireTimedN); }
+    @Test
     public void testInterruptible_tryAcquireTimedN_fair() { testInterruptible(true,  AcquireMethod.tryAcquireTimedN); }
-    public void testInterruptible(boolean fair, final AcquireMethod acquirer) {
+    private void testInterruptible(boolean fair, final AcquireMethod acquirer) {
         final PublicSemaphore s = new PublicSemaphore(0, fair);
         final Semaphore pleaseInterrupt = new Semaphore(0, fair);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -299,11 +328,15 @@ public class SemaphoreTest extends JSR166TestCase {
      * acquireUninterruptibly(), acquireUninterruptibly(N) are
      * uninterruptible
      */
+    @Test
     public void testUninterruptible_acquireUninterruptibly()       { testUninterruptible(false, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testUninterruptible_acquireUninterruptibly_fair()  { testUninterruptible(true,  AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testUninterruptible_acquireUninterruptiblyN()      { testUninterruptible(false, AcquireMethod.acquireUninterruptiblyN); }
+    @Test
     public void testUninterruptible_acquireUninterruptiblyN_fair() { testUninterruptible(true,  AcquireMethod.acquireUninterruptiblyN); }
-    public void testUninterruptible(boolean fair, final AcquireMethod acquirer) {
+    private void testUninterruptible(boolean fair, final AcquireMethod acquirer) {
         final PublicSemaphore s = new PublicSemaphore(0, fair);
         final Semaphore pleaseInterrupt = new Semaphore(-1, fair);
 
@@ -341,9 +374,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * hasQueuedThreads reports whether there are waiting threads
      */
+    @Test
     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
+    @Test
     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
-    public void testHasQueuedThreads(boolean fair) {
+    private void testHasQueuedThreads(boolean fair) {
         final PublicSemaphore lock = new PublicSemaphore(1, fair);
         assertFalse(lock.hasQueuedThreads());
         lock.acquireUninterruptibly();
@@ -364,9 +399,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * getQueueLength reports number of waiting threads
      */
+    @Test
     public void testGetQueueLength()      { testGetQueueLength(false); }
+    @Test
     public void testGetQueueLength_fair() { testGetQueueLength(true); }
-    public void testGetQueueLength(boolean fair) {
+    private void testGetQueueLength(boolean fair) {
         final PublicSemaphore lock = new PublicSemaphore(1, fair);
         assertEquals(0, lock.getQueueLength());
         lock.acquireUninterruptibly();
@@ -387,9 +424,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * getQueuedThreads includes waiting threads
      */
+    @Test
     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
+    @Test
     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
-    public void testGetQueuedThreads(boolean fair) {
+    private void testGetQueuedThreads(boolean fair) {
         final PublicSemaphore lock = new PublicSemaphore(1, fair);
         assertTrue(lock.getQueuedThreads().isEmpty());
         lock.acquireUninterruptibly();
@@ -413,9 +452,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * drainPermits reports and removes given number of permits
      */
+    @Test
     public void testDrainPermits()      { testDrainPermits(false); }
+    @Test
     public void testDrainPermits_fair() { testDrainPermits(true); }
-    public void testDrainPermits(boolean fair) {
+    private void testDrainPermits(boolean fair) {
         Semaphore s = new Semaphore(0, fair);
         assertEquals(0, s.availablePermits());
         assertEquals(0, s.drainPermits());
@@ -429,9 +470,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * release(-N) throws IllegalArgumentException
      */
+    @Test
     public void testReleaseIAE()      { testReleaseIAE(false); }
+    @Test
     public void testReleaseIAE_fair() { testReleaseIAE(true); }
-    public void testReleaseIAE(boolean fair) {
+    private void testReleaseIAE(boolean fair) {
         Semaphore s = new Semaphore(10, fair);
         try {
             s.release(-1);
@@ -442,9 +485,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * reducePermits(-N) throws IllegalArgumentException
      */
+    @Test
     public void testReducePermitsIAE()      { testReducePermitsIAE(false); }
+    @Test
     public void testReducePermitsIAE_fair() { testReducePermitsIAE(true); }
-    public void testReducePermitsIAE(boolean fair) {
+    private void testReducePermitsIAE(boolean fair) {
         PublicSemaphore s = new PublicSemaphore(10, fair);
         try {
             s.reducePermits(-1);
@@ -455,9 +500,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * reducePermits reduces number of permits
      */
+    @Test
     public void testReducePermits()      { testReducePermits(false); }
+    @Test
     public void testReducePermits_fair() { testReducePermits(true); }
-    public void testReducePermits(boolean fair) {
+    private void testReducePermits(boolean fair) {
         PublicSemaphore s = new PublicSemaphore(10, fair);
         assertEquals(10, s.availablePermits());
         s.reducePermits(0);
@@ -476,9 +523,11 @@ public class SemaphoreTest extends JSR166TestCase {
      * a reserialized semaphore has same number of permits and
      * fairness, but no queued threads
      */
+    @Test
     public void testSerialization()      { testSerialization(false); }
+    @Test
     public void testSerialization_fair() { testSerialization(true); }
-    public void testSerialization(boolean fair) {
+    private void testSerialization(boolean fair) {
         try {
             Semaphore s = new Semaphore(3, fair);
             s.acquire();
@@ -521,9 +570,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * tryAcquire(n) succeeds when sufficient permits, else fails
      */
+    @Test
     public void testTryAcquireNInSameThread()      { testTryAcquireNInSameThread(false); }
+    @Test
     public void testTryAcquireNInSameThread_fair() { testTryAcquireNInSameThread(true); }
-    public void testTryAcquireNInSameThread(boolean fair) {
+    private void testTryAcquireNInSameThread(boolean fair) {
         Semaphore s = new Semaphore(2, fair);
         assertEquals(2, s.availablePermits());
         assertFalse(s.tryAcquire(3));
@@ -538,23 +589,39 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * acquire succeeds if permits available
      */
+    @Test
     public void testReleaseAcquireSameThread_acquire()       { testReleaseAcquireSameThread(false, AcquireMethod.acquire); }
+    @Test
     public void testReleaseAcquireSameThread_acquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquire); }
+    @Test
     public void testReleaseAcquireSameThread_acquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireN); }
+    @Test
     public void testReleaseAcquireSameThread_acquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireN); }
+    @Test
     public void testReleaseAcquireSameThread_acquireUninterruptibly()       { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireSameThread_acquireUninterruptibly_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireSameThread_acquireUninterruptiblyN()      { testReleaseAcquireSameThread(false, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireSameThread_acquireUninterruptiblyN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquire()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquire); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquire_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquire); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireN); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireN); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireTimed()       { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireTimed_fair()  { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireTimedN()      { testReleaseAcquireSameThread(false, AcquireMethod.tryAcquireTimedN); }
+    @Test
     public void testReleaseAcquireSameThread_tryAcquireTimedN_fair() { testReleaseAcquireSameThread(true, AcquireMethod.tryAcquireTimedN); }
-    public void testReleaseAcquireSameThread(boolean fair,
+    private void testReleaseAcquireSameThread(boolean fair,
                                              final AcquireMethod acquirer) {
         Semaphore s = new Semaphore(1, fair);
         for (int i = 1; i < 6; i++) {
@@ -570,19 +637,31 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * release in one thread enables acquire in another thread
      */
+    @Test
     public void testReleaseAcquireDifferentThreads_acquire()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquire); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquire_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquire); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireN); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireN); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireUninterruptibly_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireDifferentThreads_acquireUninterruptiblyN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.acquireUninterruptibly); }
+    @Test
     public void testReleaseAcquireDifferentThreads_tryAcquireTimed()       { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testReleaseAcquireDifferentThreads_tryAcquireTimed_fair()  { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimed); }
+    @Test
     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN()      { testReleaseAcquireDifferentThreads(false, AcquireMethod.tryAcquireTimedN); }
+    @Test
     public void testReleaseAcquireDifferentThreads_tryAcquireTimedN_fair() { testReleaseAcquireDifferentThreads(true, AcquireMethod.tryAcquireTimedN); }
-    public void testReleaseAcquireDifferentThreads(boolean fair,
+    private void testReleaseAcquireDifferentThreads(boolean fair,
                                                    final AcquireMethod acquirer) {
         final Semaphore s = new Semaphore(0, fair);
         final int rounds = 4;
@@ -614,6 +693,7 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * fair locks are strictly FIFO
      */
+    @Test
     public void testFairLocksFifo() {
         final PublicSemaphore s = new PublicSemaphore(1, true);
         final CountDownLatch pleaseRelease = new CountDownLatch(1);
@@ -654,9 +734,11 @@ public class SemaphoreTest extends JSR166TestCase {
     /**
      * toString indicates current number of permits
      */
+    @Test
     public void testToString()      { testToString(false); }
+    @Test
     public void testToString_fair() { testToString(true); }
-    public void testToString(boolean fair) {
+    private void testToString(boolean fair) {
         PublicSemaphore s = new PublicSemaphore(0, fair);
         assertTrue(s.toString().contains("Permits = 0"));
         s.release();
diff --git a/ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java b/ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java
index 7acc192a825..24dc15487e5 100644
--- a/ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java
@@ -33,6 +33,15 @@
 
 package test.java.util.concurrent.tck;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.SplittableRandom;
@@ -45,17 +54,22 @@ import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class SplittableRandomTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(SplittableRandomTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.SplittableRandomTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(SplittableRandomTest.class);
+    // }
 
     /*
      * Testing coverage notes:
@@ -89,6 +103,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextInt produce at least two distinct results
      */
+    @Test
     public void testNextInt() {
         SplittableRandom sr = new SplittableRandom();
         int f = sr.nextInt();
@@ -101,6 +116,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextLong produce at least two distinct results
      */
+    @Test
     public void testNextLong() {
         SplittableRandom sr = new SplittableRandom();
         long f = sr.nextLong();
@@ -113,6 +129,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextDouble produce at least two distinct results
      */
+    @Test
     public void testNextDouble() {
         SplittableRandom sr = new SplittableRandom();
         double f = sr.nextDouble();
@@ -126,6 +143,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * Two SplittableRandoms created with the same seed produce the
      * same values for nextLong.
      */
+    @Test
     public void testSeedConstructor() {
         for (long seed = 2; seed < MAX_LONG_BOUND; seed += 15485863) {
             SplittableRandom sr1 = new SplittableRandom(seed);
@@ -139,6 +157,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * A SplittableRandom produced by split() of a default-constructed
      * SplittableRandom generates a different sequence
      */
+    @Test
     public void testSplit1() {
         SplittableRandom sr = new SplittableRandom();
         for (int reps = 0; reps < REPS; ++reps) {
@@ -154,6 +173,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * A SplittableRandom produced by split() of a seeded-constructed
      * SplittableRandom generates a different sequence
      */
+    @Test
     public void testSplit2() {
         SplittableRandom sr = new SplittableRandom(12345);
         for (int reps = 0; reps < REPS; ++reps) {
@@ -168,6 +188,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextInt(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextIntBoundNonPositive() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -180,6 +201,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextInt(least >= bound) throws IllegalArgumentException
      */
+    @Test
     public void testNextIntBadBounds() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -193,6 +215,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * nextInt(bound) returns 0 <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextIntBounded() {
         SplittableRandom sr = new SplittableRandom();
         for (int i = 0; i < 2; i++) assertEquals(0, sr.nextInt(1));
@@ -215,6 +238,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * nextInt(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextIntBounded2() {
         SplittableRandom sr = new SplittableRandom();
         for (int least = -15485863; least < MAX_INT_BOUND; least += 524959) {
@@ -236,6 +260,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextLong(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextLongBoundNonPositive() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -248,6 +273,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextLong(least >= bound) throws IllegalArgumentException
      */
+    @Test
     public void testNextLongBadBounds() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -261,6 +287,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * nextLong(bound) returns 0 <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextLongBounded() {
         SplittableRandom sr = new SplittableRandom();
         for (int i = 0; i < 2; i++) assertEquals(0L, sr.nextLong(1L));
@@ -282,6 +309,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * nextLong(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextLongBounded2() {
         SplittableRandom sr = new SplittableRandom();
         for (long least = -86028121; least < MAX_LONG_BOUND; least += 982451653L) {
@@ -303,6 +331,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextDouble(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextDoubleBoundNonPositive() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -317,6 +346,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * nextDouble(! (least < bound)) throws IllegalArgumentException
      */
+    @Test
     public void testNextDoubleBadBounds() {
         SplittableRandom sr = new SplittableRandom();
         assertThrows(
@@ -336,6 +366,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * nextDouble(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextDoubleBounded2() {
         SplittableRandom sr = new SplittableRandom();
         for (double least = 0.0001; least < 1.0e20; least *= 8) {
@@ -358,6 +389,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * Invoking sized ints, long, doubles, with negative sizes throws
      * IllegalArgumentException
      */
+    @Test
     public void testBadStreamSize() {
         SplittableRandom r = new SplittableRandom();
         assertThrows(
@@ -374,6 +406,7 @@ public class SplittableRandomTest extends JSR166TestCase {
      * Invoking bounded ints, long, doubles, with illegal bounds throws
      * IllegalArgumentException
      */
+    @Test
     public void testBadStreamBounds() {
         SplittableRandom r = new SplittableRandom();
         assertThrows(
@@ -389,6 +422,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel sized stream of ints generates the given number of values
      */
+    @Test
     public void testIntsCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -404,6 +438,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel sized stream of longs generates the given number of values
      */
+    @Test
     public void testLongsCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -419,6 +454,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel sized stream of doubles generates the given number of values
      */
+    @Test
     public void testDoublesCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -434,6 +470,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded ints is within bounds
      */
+    @Test
     public void testBoundedInts() {
         AtomicInteger fails = new AtomicInteger(0);
         SplittableRandom r = new SplittableRandom();
@@ -453,6 +490,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded longs is within bounds
      */
+    @Test
     public void testBoundedLongs() {
         AtomicInteger fails = new AtomicInteger(0);
         SplittableRandom r = new SplittableRandom();
@@ -472,6 +510,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded doubles is within bounds
      */
+    @Test
     public void testBoundedDoubles() {
         AtomicInteger fails = new AtomicInteger(0);
         SplittableRandom r = new SplittableRandom();
@@ -491,6 +530,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel unsized stream of ints generates at least 100 values
      */
+    @Test
     public void testUnsizedIntsCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -502,6 +542,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel unsized stream of longs generates at least 100 values
      */
+    @Test
     public void testUnsizedLongsCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -513,6 +554,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A parallel unsized stream of doubles generates at least 100 values
      */
+    @Test
     public void testUnsizedDoublesCount() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -524,6 +566,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A sequential unsized stream of ints generates at least 100 values
      */
+    @Test
     public void testUnsizedIntsCountSeq() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -535,6 +578,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A sequential unsized stream of longs generates at least 100 values
      */
+    @Test
     public void testUnsizedLongsCountSeq() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -546,6 +590,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * A sequential unsized stream of doubles generates at least 100 values
      */
+    @Test
     public void testUnsizedDoublesCountSeq() {
         LongAdder counter = new LongAdder();
         SplittableRandom r = new SplittableRandom();
@@ -557,6 +602,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * SplittableRandom should implement most of Random's public methods
      */
+    @Test
     public void testShouldImplementMostRandomMethods() throws Throwable {
         Predicate<Method> wasForgotten = method -> {
             String name = method.getName();
@@ -589,6 +635,7 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextBytes produce at least values of different signs for every byte
      */
+    @Test
     public void testNextBytes() {
         SplittableRandom sr = new SplittableRandom();
         int n = sr.nextInt(1, 20);
@@ -609,10 +656,12 @@ public class SplittableRandomTest extends JSR166TestCase {
     /**
      * Filling an empty array with random bytes succeeds without effect.
      */
+    @Test
     public void testNextBytes_emptyArray() {
         new SplittableRandom().nextBytes(new byte[0]);
     }
 
+    @Test
     public void testNextBytes_nullArray() {
         try {
             new SplittableRandom().nextBytes(null);
diff --git a/ojluni/src/test/java/util/concurrent/tck/StampedLockTest.java b/ojluni/src/test/java/util/concurrent/tck/StampedLockTest.java
index 5ca2410412a..4e76c02e6c9 100644
--- a/ojluni/src/test/java/util/concurrent/tck/StampedLockTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/StampedLockTest.java
@@ -36,6 +36,14 @@ package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -47,16 +55,21 @@ import java.util.concurrent.locks.StampedLock;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class StampedLockTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(StampedLockTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.StampedLockTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(StampedLockTest.class);
+    // }
 
     /**
      * Releases write lock, checking isWriteLocked before and after
@@ -154,6 +167,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Constructed StampedLock is in unlocked state
      */
+    @Test
     public void testConstructor() {
         assertUnlocked(new StampedLock());
     }
@@ -161,6 +175,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * write-locking, then unlocking, an unlocked lock succeed
      */
+    @Test
     public void testWriteLock_lockUnlock() {
         StampedLock lock = new StampedLock();
 
@@ -183,6 +198,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * read-locking, then unlocking, an unlocked lock succeed
      */
+    @Test
     public void testReadLock_lockUnlock() {
         StampedLock lock = new StampedLock();
 
@@ -208,6 +224,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryUnlockWrite fails if not write locked
      */
+    @Test
     public void testTryUnlockWrite_failure() {
         StampedLock lock = new StampedLock();
         assertFalse(lock.tryUnlockWrite());
@@ -225,6 +242,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryUnlockRead fails if not read locked
      */
+    @Test
     public void testTryUnlockRead_failure() {
         StampedLock lock = new StampedLock();
         assertFalse(lock.tryUnlockRead());
@@ -242,6 +260,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * validate(0L) fails
      */
+    @Test
     public void testValidate0() {
         StampedLock lock = new StampedLock();
         assertFalse(lock.validate(0L));
@@ -250,6 +269,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * A stamp obtained from a successful lock operation validates while the lock is held
      */
+    @Test
     public void testValidate() throws InterruptedException {
         StampedLock lock = new StampedLock();
 
@@ -271,6 +291,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * A stamp obtained from an unsuccessful lock operation does not validate
      */
+    @Test
     public void testValidate2() throws InterruptedException {
         StampedLock lock = new StampedLock();
         long s = assertNonZero(lock.writeLock());
@@ -299,6 +320,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * interruptible operations throw InterruptedException when pre-interrupted
      */
+    @Test
     public void testInterruptibleOperationsThrowInterruptedExceptionWhenPreInterrupted() {
         final StampedLock lock = new StampedLock();
 
@@ -363,6 +385,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * interruptible operations throw InterruptedException when write locked and interrupted
      */
+    @Test
     public void testInterruptibleOperationsThrowInterruptedExceptionWriteLockedInterrupted() {
         final StampedLock lock = new StampedLock();
         long s = lock.writeLock();
@@ -385,6 +408,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * interruptible operations throw InterruptedException when read locked and interrupted
      */
+    @Test
     public void testInterruptibleOperationsThrowInterruptedExceptionReadLockedInterrupted() {
         final StampedLock lock = new StampedLock();
         long s = lock.readLock();
@@ -403,6 +427,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Non-interruptible operations ignore and preserve interrupt status
      */
+    @Test
     public void testNonInterruptibleOperationsIgnoreInterrupts() {
         final StampedLock lock = new StampedLock();
         Thread.currentThread().interrupt();
@@ -433,6 +458,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryWriteLock on an unlocked lock succeeds
      */
+    @Test
     public void testTryWriteLock() {
         final StampedLock lock = new StampedLock();
         long s = lock.tryWriteLock();
@@ -445,6 +471,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryWriteLock fails if locked
      */
+    @Test
     public void testTryWriteLockWhenLocked() {
         final StampedLock lock = new StampedLock();
         long s = lock.writeLock();
@@ -461,6 +488,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryReadLock fails if write-locked
      */
+    @Test
     public void testTryReadLockWhenLocked() {
         final StampedLock lock = new StampedLock();
         long s = lock.writeLock();
@@ -477,6 +505,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Multiple threads can hold a read lock when not write-locked
      */
+    @Test
     public void testMultipleReadLocks() {
         final StampedLock lock = new StampedLock();
         final long s = lock.readLock();
@@ -506,6 +535,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * writeLock() succeeds only after a reading thread unlocks
      */
+    @Test
     public void testWriteAfterReadLock() throws InterruptedException {
         final CountDownLatch aboutToLock = new CountDownLatch(1);
         final StampedLock lock = new StampedLock();
@@ -531,6 +561,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * writeLock() succeeds only after reading threads unlock
      */
+    @Test
     public void testWriteAfterMultipleReadLocks() {
         final StampedLock lock = new StampedLock();
         long s = lock.readLock();
@@ -558,6 +589,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * readLock() succeed only after a writing thread unlocks
      */
+    @Test
     public void testReadAfterWriteLock() {
         final StampedLock lock = new StampedLock();
         final CountDownLatch threadsStarted = new CountDownLatch(2);
@@ -587,6 +619,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryReadLock succeeds if read locked but not write locked
      */
+    @Test
     public void testTryLockWhenReadLocked() {
         final StampedLock lock = new StampedLock();
         long s = lock.readLock();
@@ -604,6 +637,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryWriteLock fails when read locked
      */
+    @Test
     public void testTryWriteLockWhenReadLocked() {
         final StampedLock lock = new StampedLock();
         long s = lock.readLock();
@@ -619,6 +653,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * timed lock operations time out if lock not available
      */
+    @Test
     public void testTimedLock_Timeout() throws Exception {
         ArrayList<Future<?>> futures = new ArrayList<>();
 
@@ -673,6 +708,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * writeLockInterruptibly succeeds if unlocked
      */
+    @Test
     public void testWriteLockInterruptibly() throws InterruptedException {
         final StampedLock lock = new StampedLock();
         long s = lock.writeLockInterruptibly();
@@ -683,6 +719,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * readLockInterruptibly succeeds if lock free
      */
+    @Test
     public void testReadLockInterruptibly() throws InterruptedException {
         final StampedLock lock = new StampedLock();
 
@@ -698,6 +735,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * A serialized lock deserializes as unlocked
      */
+    @Test
     public void testSerialization() {
         StampedLock lock = new StampedLock();
         lock.writeLock();
@@ -713,6 +751,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * toString indicates current lock state
      */
+    @Test
     public void testToString() {
         StampedLock lock = new StampedLock();
         assertTrue(lock.toString().contains("Unlocked"));
@@ -727,6 +766,7 @@ public class StampedLockTest extends JSR166TestCase {
      * tryOptimisticRead succeeds and validates if unlocked, fails if
      * exclusively locked
      */
+    @Test
     public void testValidateOptimistic() throws InterruptedException {
         StampedLock lock = new StampedLock();
 
@@ -751,6 +791,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryOptimisticRead stamp does not validate if a write lock intervenes
      */
+    @Test
     public void testValidateOptimisticWriteLocked() {
         final StampedLock lock = new StampedLock();
         final long p = assertValid(lock, lock.tryOptimisticRead());
@@ -765,6 +806,7 @@ public class StampedLockTest extends JSR166TestCase {
      * tryOptimisticRead stamp does not validate if a write lock
      * intervenes in another thread
      */
+    @Test
     public void testValidateOptimisticWriteLocked2()
             throws InterruptedException {
         final CountDownLatch locked = new CountDownLatch(1);
@@ -790,6 +832,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryConvertToOptimisticRead succeeds and validates if successfully locked
      */
+    @Test
     public void testTryConvertToOptimisticRead() throws InterruptedException {
         StampedLock lock = new StampedLock();
         long s, p, q;
@@ -825,6 +868,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryConvertToReadLock succeeds for valid stamps
      */
+    @Test
     public void testTryConvertToReadLock() throws InterruptedException {
         StampedLock lock = new StampedLock();
         long s, p;
@@ -871,6 +915,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * tryConvertToWriteLock succeeds if lock available; fails if multiply read locked
      */
+    @Test
     public void testTryConvertToWriteLock() throws InterruptedException {
         StampedLock lock = new StampedLock();
         long s, p;
@@ -918,6 +963,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * asWriteLock can be locked and unlocked
      */
+    @Test
     public void testAsWriteLock() throws Throwable {
         StampedLock sl = new StampedLock();
         Lock lock = sl.asWriteLock();
@@ -934,6 +980,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * asReadLock can be locked and unlocked
      */
+    @Test
     public void testAsReadLock() throws Throwable {
         StampedLock sl = new StampedLock();
         Lock lock = sl.asReadLock();
@@ -954,6 +1001,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * asReadWriteLock.writeLock can be locked and unlocked
      */
+    @Test
     public void testAsReadWriteLockWriteLock() throws Throwable {
         StampedLock sl = new StampedLock();
         Lock lock = sl.asReadWriteLock().writeLock();
@@ -970,6 +1018,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * asReadWriteLock.readLock can be locked and unlocked
      */
+    @Test
     public void testAsReadWriteLockReadLock() throws Throwable {
         StampedLock sl = new StampedLock();
         Lock lock = sl.asReadWriteLock().readLock();
@@ -990,6 +1039,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Lock.newCondition throws UnsupportedOperationException
      */
+    @Test
     public void testLockViewsDoNotSupportConditions() {
         StampedLock sl = new StampedLock();
         assertThrows(UnsupportedOperationException.class,
@@ -1003,6 +1053,7 @@ public class StampedLockTest extends JSR166TestCase {
      * Passing optimistic read stamps to unlock operations result in
      * IllegalMonitorStateException
      */
+    @Test
     public void testCannotUnlockOptimisticReadStamps() {
         Runnable[] actions = {
             () -> {
@@ -1129,6 +1180,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Invalid stamps result in IllegalMonitorStateException
      */
+    @Test
     public void testInvalidStampsThrowIllegalMonitorStateException() {
         final StampedLock sl = new StampedLock();
 
@@ -1184,6 +1236,7 @@ public class StampedLockTest extends JSR166TestCase {
     /**
      * Read locks can be very deeply nested
      */
+    @Test
     public void testDeeplyNestedReadLocks() {
         final StampedLock lock = new StampedLock();
         final int depth = 300;
diff --git a/ojluni/src/test/java/util/concurrent/tck/SubmissionPublisherTest.java b/ojluni/src/test/java/util/concurrent/tck/SubmissionPublisherTest.java
index bfdecbe2b21..103529f6a56 100644
--- a/ojluni/src/test/java/util/concurrent/tck/SubmissionPublisherTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/SubmissionPublisherTest.java
@@ -33,6 +33,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -41,21 +50,26 @@ import java.util.concurrent.Flow;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.SubmissionPublisher;
 import java.util.concurrent.atomic.AtomicInteger;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static java.util.concurrent.Flow.Subscriber;
 import static java.util.concurrent.Flow.Subscription;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class SubmissionPublisherTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(SubmissionPublisherTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.SubmissionPublisherTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(SubmissionPublisherTest.class);
+    // }
 
     final Executor basicExecutor = basicPublisher().getExecutor();
 
@@ -174,6 +188,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * is not closed, has default buffer size, and uses the
      * defaultExecutor
      */
+    @Test
     public void testConstructor1() {
         SubmissionPublisher<Integer> p = new SubmissionPublisher<>();
         checkInitialState(p);
@@ -189,6 +204,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * A new SubmissionPublisher has no subscribers, is not closed,
      * has the given buffer size, and uses the given executor
      */
+    @Test
     public void testConstructor2() {
         Executor e = Executors.newFixedThreadPool(1);
         SubmissionPublisher<Integer> p = new SubmissionPublisher<>(e, 8);
@@ -201,6 +217,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * A null Executor argument to SubmissionPublisher constructor
      * throws NullPointerException
      */
+    @Test
     public void testConstructor3() {
         try {
             new SubmissionPublisher<Integer>(null, 8);
@@ -212,6 +229,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * A negative capacity argument to SubmissionPublisher constructor
      * throws IllegalArgumentException
      */
+    @Test
     public void testConstructor4() {
         Executor e = Executors.newFixedThreadPool(1);
         try {
@@ -226,6 +244,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * subsequent close or closeExceptionally has no additional
      * effect.
      */
+    @Test
     public void testClose() {
         SubmissionPublisher<Integer> p = basicPublisher();
         checkInitialState(p);
@@ -248,6 +267,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * submission; a subsequent close or closeExceptionally has no
      * additional effect.
      */
+    @Test
     public void testCloseExceptionally() {
         SubmissionPublisher<Integer> p = basicPublisher();
         checkInitialState(p);
@@ -270,6 +290,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * hasSubscribers, isSubscribed is true, and existing
      * subscriptions are unaffected.
      */
+    @Test
     public void testSubscribe1() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -303,6 +324,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * If closed, upon subscription, the subscriber's onComplete
      * method is invoked
      */
+    @Test
     public void testSubscribe2() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -318,6 +340,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * If closedExceptionally, upon subscription, the subscriber's
      * onError method is invoked
      */
+    @Test
     public void testSubscribe3() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -335,6 +358,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * Upon attempted resubscription, the subscriber's onError is
      * called and the subscription is cancelled.
      */
+    @Test
     public void testSubscribe4() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -358,6 +382,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * An exception thrown in onSubscribe causes onError
      */
+    @Test
     public void testSubscribe5() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -372,6 +397,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * subscribe(null) throws NPE
      */
+    @Test
     public void testSubscribe6() {
         SubmissionPublisher<Integer> p = basicPublisher();
         try {
@@ -384,6 +410,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Closing a publisher causes onComplete to subscribers
      */
+    @Test
     public void testCloseCompletes() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -406,6 +433,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * Closing a publisher exceptionally causes onError to subscribers
      * after they are subscribed
      */
+    @Test
     public void testCloseExceptionallyError() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -428,6 +456,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Cancelling a subscription eventually causes no more onNexts to be issued
      */
+    @Test
     public void testCancel() {
         SubmissionPublisher<Integer> p =
             new SubmissionPublisher<>(basicExecutor, 4); // must be < 20
@@ -451,6 +480,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Throwing an exception in onNext causes onError
      */
+    @Test
     public void testThrowOnNext() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -472,6 +502,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * If a handler is supplied in constructor, it is invoked when
      * subscriber throws an exception in onNext
      */
+    @Test
     public void testThrowOnNextHandler() {
         AtomicInteger calls = new AtomicInteger();
         SubmissionPublisher<Integer> p = new SubmissionPublisher<>(
@@ -496,6 +527,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * onNext items are issued in the same order to each subscriber
      */
+    @Test
     public void testOrder() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -516,6 +548,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * onNext is issued only if requested
      */
+    @Test
     public void testRequest1() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -543,6 +576,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * onNext is not issued when requests become zero
      */
+    @Test
     public void testRequest2() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -565,6 +599,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Non-positive request causes error
      */
+    @Test
     public void testRequest3() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -596,6 +631,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * estimateMinimumDemand reports 0 until request, nonzero after
      * request
      */
+    @Test
     public void testEstimateMinimumDemand() {
         TestSubscriber s = new TestSubscriber();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -610,6 +646,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * submit to a publisher with no subscribers returns lag 0
      */
+    @Test
     public void testEmptySubmit() {
         SubmissionPublisher<Integer> p = basicPublisher();
         assertEquals(0, p.submit(1));
@@ -618,6 +655,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * submit(null) throws NPE
      */
+    @Test
     public void testNullSubmit() {
         SubmissionPublisher<Integer> p = basicPublisher();
         try {
@@ -630,6 +668,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * submit returns number of lagged items, compatible with result
      * of estimateMaximumLag.
      */
+    @Test
     public void testLaggedSubmit() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -659,6 +698,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * submit eventually issues requested items when buffer capacity is 1
      */
+    @Test
     public void testCap1Submit() {
         SubmissionPublisher<Integer> p
             = new SubmissionPublisher<>(basicExecutor, 1);
@@ -692,6 +732,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer to a publisher with no subscribers returns lag 0
      */
+    @Test
     public void testEmptyOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         assertEquals(0, p.offer(1, null));
@@ -700,6 +741,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer(null) throws NPE
      */
+    @Test
     public void testNullOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         try {
@@ -711,6 +753,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer returns number of lagged items if not saturated
      */
+    @Test
     public void testLaggedOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -737,6 +780,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer reports drops if saturated
      */
+    @Test
     public void testDroppedOffer() {
         SubmissionPublisher<Integer> p
             = new SubmissionPublisher<>(basicExecutor, 4);
@@ -765,6 +809,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer invokes drop handler if saturated
      */
+    @Test
     public void testHandledDroppedOffer() {
         AtomicInteger calls = new AtomicInteger();
         SubmissionPublisher<Integer> p
@@ -793,6 +838,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * offer succeeds if drop handler forces request
      */
+    @Test
     public void testRecoveredHandledDroppedOffer() {
         AtomicInteger calls = new AtomicInteger();
         SubmissionPublisher<Integer> p
@@ -820,6 +866,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer to a publisher with no subscribers returns lag 0
      */
+    @Test
     public void testEmptyTimedOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         long startTime = System.nanoTime();
@@ -830,6 +877,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer with null item or TimeUnit throws NPE
      */
+    @Test
     public void testNullTimedOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         long startTime = System.nanoTime();
@@ -847,6 +895,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer returns number of lagged items if not saturated
      */
+    @Test
     public void testLaggedTimedOffer() {
         SubmissionPublisher<Integer> p = basicPublisher();
         TestSubscriber s1 = new TestSubscriber();
@@ -875,6 +924,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer reports drops if saturated
      */
+    @Test
     public void testDroppedTimedOffer() {
         SubmissionPublisher<Integer> p
             = new SubmissionPublisher<>(basicExecutor, 4);
@@ -906,6 +956,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer invokes drop handler if saturated
      */
+    @Test
     public void testHandledDroppedTimedOffer() {
         AtomicInteger calls = new AtomicInteger();
         SubmissionPublisher<Integer> p
@@ -936,6 +987,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * Timed offer succeeds if drop handler forces request
      */
+    @Test
     public void testRecoveredHandledDroppedTimedOffer() {
         AtomicInteger calls = new AtomicInteger();
         SubmissionPublisher<Integer> p
@@ -967,6 +1019,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * consume returns a CompletableFuture that is done when
      * publisher completes
      */
+    @Test
     public void testConsume() {
         AtomicInteger sum = new AtomicInteger();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -983,6 +1036,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * consume(null) throws NPE
      */
+    @Test
     public void testConsumeNPE() {
         SubmissionPublisher<Integer> p = basicPublisher();
         try {
@@ -994,6 +1048,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
     /**
      * consume eventually stops processing published items if cancelled
      */
+    @Test
     public void testCancelledConsume() {
         AtomicInteger count = new AtomicInteger();
         SubmissionPublisher<Integer> p = basicPublisher();
@@ -1010,6 +1065,7 @@ public class SubmissionPublisherTest extends JSR166TestCase {
      * JDK-8187947: A race condition in SubmissionPublisher
      * cvs update -D '2017-11-25' src/main/java/util/concurrent/SubmissionPublisher.java && ant -Djsr166.expensiveTests=true -Djsr166.tckTestClass=SubmissionPublisherTest -Djsr166.methodFilter=testMissedSignal tck; cvs update -A src/main/java/util/concurrent/SubmissionPublisher.java
      */
+    @Test
     public void testMissedSignal_8187947() throws Exception {
         if (!atLeastJava9()) return; // backport to jdk8 too hard
         final int N = expensiveTests ? (1 << 20) : (1 << 10);
diff --git a/ojluni/src/test/java/util/concurrent/tck/SynchronousQueueTest.java b/ojluni/src/test/java/util/concurrent/tck/SynchronousQueueTest.java
index ce4c1e51130..3a3494754d4 100644
--- a/ojluni/src/test/java/util/concurrent/tck/SynchronousQueueTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/SynchronousQueueTest.java
@@ -35,6 +35,14 @@
 
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -47,38 +55,51 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
 
-import junit.framework.Test;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class SynchronousQueueTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class Fair extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new SynchronousQueue(true);
         }
     }
 
+    // Android-changed: Use JUnit4.
+    @RunWith(JUnit4.class)
     public static class NonFair extends BlockingQueueTest {
         protected BlockingQueue emptyCollection() {
             return new SynchronousQueue(false);
         }
     }
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.SynchronousQueueTest");
     }
 
-    public static Test suite() {
-        return newTestSuite(SynchronousQueueTest.class,
-                            new Fair().testSuite(),
-                            new NonFair().testSuite());
-    }
+    // Android-removed: No usage of suite().
+    // public static Test suite() {
+    //     return newTestSuite(SynchronousQueueTest.class,
+    //                         new Fair().testSuite(),
+    //                         new NonFair().testSuite());
+    // }
 
     /**
      * Any SynchronousQueue is both empty and full
      */
+    @Test
     public void testEmptyFull()      { testEmptyFull(false); }
+    @Test
     public void testEmptyFull_fair() { testEmptyFull(true); }
-    public void testEmptyFull(boolean fair) {
+    private void testEmptyFull(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         assertTrue(q.isEmpty());
         assertEquals(0, q.size());
@@ -89,9 +110,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * offer fails if no active taker
      */
+    @Test
     public void testOffer()      { testOffer(false); }
+    @Test
     public void testOffer_fair() { testOffer(true); }
-    public void testOffer(boolean fair) {
+    private void testOffer(boolean fair) {
         SynchronousQueue q = new SynchronousQueue(fair);
         assertFalse(q.offer(one));
     }
@@ -99,9 +122,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * add throws IllegalStateException if no active taker
      */
+    @Test
     public void testAdd()      { testAdd(false); }
+    @Test
     public void testAdd_fair() { testAdd(true); }
-    public void testAdd(boolean fair) {
+    private void testAdd(boolean fair) {
         SynchronousQueue q = new SynchronousQueue(fair);
         assertEquals(0, q.remainingCapacity());
         try {
@@ -113,9 +138,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * addAll(this) throws IllegalArgumentException
      */
+    @Test
     public void testAddAll_self()      { testAddAll_self(false); }
+    @Test
     public void testAddAll_self_fair() { testAddAll_self(true); }
-    public void testAddAll_self(boolean fair) {
+    private void testAddAll_self(boolean fair) {
         SynchronousQueue q = new SynchronousQueue(fair);
         try {
             q.addAll(q);
@@ -126,9 +153,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * addAll throws ISE if no active taker
      */
+    @Test
     public void testAddAll_ISE()      { testAddAll_ISE(false); }
+    @Test
     public void testAddAll_ISE_fair() { testAddAll_ISE(true); }
-    public void testAddAll_ISE(boolean fair) {
+    private void testAddAll_ISE(boolean fair) {
         SynchronousQueue q = new SynchronousQueue(fair);
         Integer[] ints = new Integer[1];
         for (int i = 0; i < ints.length; i++)
@@ -143,9 +172,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly if no active taker
      */
+    @Test
     public void testBlockingPut()      { testBlockingPut(false); }
+    @Test
     public void testBlockingPut_fair() { testBlockingPut(true); }
-    public void testBlockingPut(boolean fair) {
+    private void testBlockingPut(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -175,9 +206,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * put blocks interruptibly waiting for take
      */
+    @Test
     public void testPutWithTake()      { testPutWithTake(false); }
+    @Test
     public void testPutWithTake_fair() { testPutWithTake(true); }
-    public void testPutWithTake(boolean fair) {
+    private void testPutWithTake(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CountDownLatch pleaseTake = new CountDownLatch(1);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -209,9 +242,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * timed offer times out if elements not taken
      */
+    @Test
     public void testTimedOffer()      { testTimedOffer(false); }
+    @Test
     public void testTimedOffer_fair() { testTimedOffer(true); }
-    public void testTimedOffer(boolean fair) {
+    private void testTimedOffer(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -235,9 +270,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * poll return null if no active putter
      */
+    @Test
     public void testPoll()      { testPoll(false); }
+    @Test
     public void testPoll_fair() { testPoll(true); }
-    public void testPoll(boolean fair) {
+    private void testPoll(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         assertNull(q.poll());
     }
@@ -245,9 +282,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * timed poll with zero timeout times out if no active putter
      */
+    @Test
     public void testTimedPoll0()      { testTimedPoll0(false); }
+    @Test
     public void testTimedPoll0_fair() { testTimedPoll0(true); }
-    public void testTimedPoll0(boolean fair) {
+    private void testTimedPoll0(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         try { assertNull(q.poll(0, MILLISECONDS)); }
         catch (InterruptedException e) { threadUnexpectedException(e); }
@@ -256,9 +295,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * timed poll with nonzero timeout times out if no active putter
      */
+    @Test
     public void testTimedPoll()      { testTimedPoll(false); }
+    @Test
     public void testTimedPoll_fair() { testTimedPoll(true); }
-    public void testTimedPoll(boolean fair) {
+    private void testTimedPoll(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         long startTime = System.nanoTime();
         try { assertNull(q.poll(timeoutMillis(), MILLISECONDS)); }
@@ -270,9 +311,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
      * timed poll before a delayed offer times out, returning null;
      * after offer succeeds; on interruption throws
      */
+    @Test
     public void testTimedPollWithOffer()      { testTimedPollWithOffer(false); }
+    @Test
     public void testTimedPollWithOffer_fair() { testTimedPollWithOffer(true); }
-    public void testTimedPollWithOffer(boolean fair) {
+    private void testTimedPollWithOffer(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CountDownLatch pleaseOffer = new CountDownLatch(1);
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
@@ -318,9 +361,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * peek() returns null if no active putter
      */
+    @Test
     public void testPeek()      { testPeek(false); }
+    @Test
     public void testPeek_fair() { testPeek(true); }
-    public void testPeek(boolean fair) {
+    private void testPeek(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         assertNull(q.peek());
     }
@@ -328,9 +373,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * element() throws NoSuchElementException if no active putter
      */
+    @Test
     public void testElement()      { testElement(false); }
+    @Test
     public void testElement_fair() { testElement(true); }
-    public void testElement(boolean fair) {
+    private void testElement(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         try {
             q.element();
@@ -341,9 +388,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * remove() throws NoSuchElementException if no active putter
      */
+    @Test
     public void testRemove()      { testRemove(false); }
+    @Test
     public void testRemove_fair() { testRemove(true); }
-    public void testRemove(boolean fair) {
+    private void testRemove(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         try {
             q.remove();
@@ -354,9 +403,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * contains returns false
      */
+    @Test
     public void testContains()      { testContains(false); }
+    @Test
     public void testContains_fair() { testContains(true); }
-    public void testContains(boolean fair) {
+    private void testContains(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         assertFalse(q.contains(zero));
     }
@@ -364,9 +415,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * clear ensures isEmpty
      */
+    @Test
     public void testClear()      { testClear(false); }
+    @Test
     public void testClear_fair() { testClear(true); }
-    public void testClear(boolean fair) {
+    private void testClear(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         q.clear();
         assertTrue(q.isEmpty());
@@ -375,9 +428,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * containsAll returns false unless empty
      */
+    @Test
     public void testContainsAll()      { testContainsAll(false); }
+    @Test
     public void testContainsAll_fair() { testContainsAll(true); }
-    public void testContainsAll(boolean fair) {
+    private void testContainsAll(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Integer[] empty = new Integer[0];
         assertTrue(q.containsAll(Arrays.asList(empty)));
@@ -388,9 +443,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * retainAll returns false
      */
+    @Test
     public void testRetainAll()      { testRetainAll(false); }
+    @Test
     public void testRetainAll_fair() { testRetainAll(true); }
-    public void testRetainAll(boolean fair) {
+    private void testRetainAll(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Integer[] empty = new Integer[0];
         assertFalse(q.retainAll(Arrays.asList(empty)));
@@ -401,9 +458,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * removeAll returns false
      */
+    @Test
     public void testRemoveAll()      { testRemoveAll(false); }
+    @Test
     public void testRemoveAll_fair() { testRemoveAll(true); }
-    public void testRemoveAll(boolean fair) {
+    private void testRemoveAll(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Integer[] empty = new Integer[0];
         assertFalse(q.removeAll(Arrays.asList(empty)));
@@ -414,9 +473,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * toArray is empty
      */
+    @Test
     public void testToArray()      { testToArray(false); }
+    @Test
     public void testToArray_fair() { testToArray(true); }
-    public void testToArray(boolean fair) {
+    private void testToArray(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Object[] o = q.toArray();
         assertEquals(0, o.length);
@@ -426,9 +487,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
      * toArray(Integer array) returns its argument with the first
      * element (if present) nulled out
      */
+    @Test
     public void testToArray2()      { testToArray2(false); }
+    @Test
     public void testToArray2_fair() { testToArray2(true); }
-    public void testToArray2(boolean fair) {
+    private void testToArray2(boolean fair) {
         final SynchronousQueue<Integer> q = new SynchronousQueue<>(fair);
         Integer[] a;
 
@@ -446,9 +509,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * toArray(null) throws NPE
      */
+    @Test
     public void testToArray_null()      { testToArray_null(false); }
+    @Test
     public void testToArray_null_fair() { testToArray_null(true); }
-    public void testToArray_null(boolean fair) {
+    private void testToArray_null(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         try {
             Object[] o = q.toArray((Object[])null);
@@ -459,18 +524,22 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * iterator does not traverse any elements
      */
+    @Test
     public void testIterator()      { testIterator(false); }
+    @Test
     public void testIterator_fair() { testIterator(true); }
-    public void testIterator(boolean fair) {
+    private void testIterator(boolean fair) {
         assertIteratorExhausted(new SynchronousQueue(fair).iterator());
     }
 
     /**
      * iterator remove throws ISE
      */
+    @Test
     public void testIteratorRemove()      { testIteratorRemove(false); }
+    @Test
     public void testIteratorRemove_fair() { testIteratorRemove(true); }
-    public void testIteratorRemove(boolean fair) {
+    private void testIteratorRemove(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Iterator it = q.iterator();
         try {
@@ -482,9 +551,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * toString returns a non-null string
      */
+    @Test
     public void testToString()      { testToString(false); }
+    @Test
     public void testToString_fair() { testToString(true); }
-    public void testToString(boolean fair) {
+    private void testToString(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         String s = q.toString();
         assertNotNull(s);
@@ -493,9 +564,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * offer transfers elements across Executor tasks
      */
+    @Test
     public void testOfferInExecutor()      { testOfferInExecutor(false); }
+    @Test
     public void testOfferInExecutor_fair() { testOfferInExecutor(true); }
-    public void testOfferInExecutor(boolean fair) {
+    private void testOfferInExecutor(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
         final ExecutorService executor = Executors.newFixedThreadPool(2);
@@ -520,9 +593,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * timed poll retrieves elements across Executor threads
      */
+    @Test
     public void testPollInExecutor()      { testPollInExecutor(false); }
+    @Test
     public void testPollInExecutor_fair() { testPollInExecutor(true); }
-    public void testPollInExecutor(boolean fair) {
+    private void testPollInExecutor(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
         final ExecutorService executor = Executors.newFixedThreadPool(2);
@@ -546,6 +621,7 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * a deserialized serialized queue is usable
      */
+    @Test
     public void testSerialization() {
         final SynchronousQueue x = new SynchronousQueue();
         final SynchronousQueue y = new SynchronousQueue(false);
@@ -567,9 +643,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * drainTo(c) of empty queue doesn't transfer elements
      */
+    @Test
     public void testDrainTo()      { testDrainTo(false); }
+    @Test
     public void testDrainTo_fair() { testDrainTo(true); }
-    public void testDrainTo(boolean fair) {
+    private void testDrainTo(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         ArrayList l = new ArrayList();
         q.drainTo(l);
@@ -580,9 +658,11 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * drainTo empties queue, unblocking a waiting put.
      */
+    @Test
     public void testDrainToWithActivePut()      { testDrainToWithActivePut(false); }
+    @Test
     public void testDrainToWithActivePut_fair() { testDrainToWithActivePut(true); }
-    public void testDrainToWithActivePut(boolean fair) {
+    private void testDrainToWithActivePut(boolean fair) {
         final SynchronousQueue q = new SynchronousQueue(fair);
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() throws InterruptedException {
@@ -605,6 +685,7 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * drainTo(c, n) empties up to n elements of queue into c
      */
+    @Test
     public void testDrainToN() throws InterruptedException {
         final SynchronousQueue q = new SynchronousQueue();
         Thread t1 = newStartedThread(new CheckedRunnable() {
@@ -634,6 +715,7 @@ public class SynchronousQueueTest extends JSR166TestCase {
     /**
      * remove(null), contains(null) always return false
      */
+    @Test
     public void testNeverContainsNull() {
         Collection<?> q = new SynchronousQueue();
         assertFalse(q.contains(null));
diff --git a/ojluni/src/test/java/util/concurrent/tck/SystemTest.java b/ojluni/src/test/java/util/concurrent/tck/SystemTest.java
index fc2a05b9bcb..7c081d83952 100644
--- a/ojluni/src/test/java/util/concurrent/tck/SystemTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/SystemTest.java
@@ -34,17 +34,31 @@
  */
 
 package test.java.util.concurrent.tck;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class SystemTest extends JSR166TestCase {
-    public static void main(String[] args) {
-        main(suite(), args);
-    }
 
-    public static Test suite() {
-        return new TestSuite(SystemTest.class);
+    // Android-changed: Use JUnitCore.main.
+    public static void main(String[] args) {
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.SystemTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(SystemTest.class);
+    // }
 
     /**
      * Worst case rounding for millisecs; set for 60 cycle millis clock.
@@ -58,6 +72,7 @@ public class SystemTest extends JSR166TestCase {
      * possible rounding).
      * This shows only that nano timing not (much) worse than milli.
      */
+    @Test
     public void testNanoTime1() throws InterruptedException {
         long m1 = System.currentTimeMillis();
         Thread.sleep(1);
@@ -78,6 +93,7 @@ public class SystemTest extends JSR166TestCase {
      * for rounding.
      * This shows only that nano timing not (much) worse than milli.
      */
+    @Test
     public void testNanoTime2() throws InterruptedException {
         long n1 = System.nanoTime();
         Thread.sleep(1);
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandom8Test.java b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandom8Test.java
index 37ecba176ca..16c679cb66a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandom8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandom8Test.java
@@ -32,21 +32,35 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.LongAdder;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadLocalRandom8Test extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ThreadLocalRandom8Test.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadLocalRandom8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadLocalRandom8Test.class);
+    // }
 
     // max sampled int bound
     static final int MAX_INT_BOUND = (1 << 26);
@@ -62,6 +76,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
      * Invoking sized ints, long, doubles, with negative sizes throws
      * IllegalArgumentException
      */
+        @Test
     public void testBadStreamSize() {
         ThreadLocalRandom r = ThreadLocalRandom.current();
         Runnable[] throwingActions = {
@@ -79,6 +94,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
      * Invoking bounded ints, long, doubles, with illegal bounds throws
      * IllegalArgumentException
      */
+    @Test
     public void testBadStreamBounds() {
         ThreadLocalRandom r = ThreadLocalRandom.current();
         Runnable[] throwingActions = {
@@ -95,6 +111,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel sized stream of ints generates the given number of values
      */
+    @Test
     public void testIntsCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -110,6 +127,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel sized stream of longs generates the given number of values
      */
+    @Test
     public void testLongsCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -125,6 +143,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel sized stream of doubles generates the given number of values
      */
+    @Test
     public void testDoublesCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -140,6 +159,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded ints is within bounds
      */
+    @Test
     public void testBoundedInts() {
         AtomicInteger fails = new AtomicInteger(0);
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -159,6 +179,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded longs is within bounds
      */
+    @Test
     public void testBoundedLongs() {
         AtomicInteger fails = new AtomicInteger(0);
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -178,6 +199,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * Each of a parallel sized stream of bounded doubles is within bounds
      */
+    @Test
     public void testBoundedDoubles() {
         AtomicInteger fails = new AtomicInteger(0);
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -197,6 +219,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel unsized stream of ints generates at least 100 values
      */
+    @Test
     public void testUnsizedIntsCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -208,6 +231,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel unsized stream of longs generates at least 100 values
      */
+    @Test
     public void testUnsizedLongsCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -219,6 +243,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A parallel unsized stream of doubles generates at least 100 values
      */
+    @Test
     public void testUnsizedDoublesCount() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -230,6 +255,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A sequential unsized stream of ints generates at least 100 values
      */
+    @Test
     public void testUnsizedIntsCountSeq() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -241,6 +267,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A sequential unsized stream of longs generates at least 100 values
      */
+    @Test
     public void testUnsizedLongsCountSeq() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -252,6 +279,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
     /**
      * A sequential unsized stream of doubles generates at least 100 values
      */
+    @Test
     public void testUnsizedDoublesCountSeq() {
         LongAdder counter = new LongAdder();
         ThreadLocalRandom r = ThreadLocalRandom.current();
@@ -264,6 +292,7 @@ public class ThreadLocalRandom8Test extends JSR166TestCase {
      * A deserialized ThreadLocalRandom is always identical to
      * ThreadLocalRandom.current()
      */
+    @Test
     public void testSerialization() {
         assertSame(
             ThreadLocalRandom.current(),
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandomTest.java b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandomTest.java
index 9fa46b5cd98..62d9f989c89 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandomTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalRandomTest.java
@@ -32,21 +32,35 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadLocalRandomTest extends JSR166TestCase {
 
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ThreadLocalRandomTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadLocalRandomTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadLocalRandomTest.class);
+    // }
 
     /*
      * Testing coverage notes:
@@ -72,6 +86,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * setSeed throws UnsupportedOperationException
      */
+    @Test
     public void testSetSeed() {
         try {
             ThreadLocalRandom.current().setSeed(17);
@@ -84,6 +99,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * at least two distinct results, and repeated calls produce all
      * possible values.
      */
+    @Test
     public void testNext() throws ReflectiveOperationException {
         ThreadLocalRandom rnd = ThreadLocalRandom.current();
         final java.lang.reflect.Method m;
@@ -126,6 +142,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextInt produce at least two distinct results
      */
+    @Test
     public void testNextInt() {
         int f = ThreadLocalRandom.current().nextInt();
         int i = 0;
@@ -137,6 +154,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextLong produce at least two distinct results
      */
+    @Test
     public void testNextLong() {
         long f = ThreadLocalRandom.current().nextLong();
         int i = 0;
@@ -148,6 +166,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextBoolean produce at least two distinct results
      */
+    @Test
     public void testNextBoolean() {
         boolean f = ThreadLocalRandom.current().nextBoolean();
         int i = 0;
@@ -159,6 +178,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextFloat produce at least two distinct results
      */
+    @Test
     public void testNextFloat() {
         float f = ThreadLocalRandom.current().nextFloat();
         int i = 0;
@@ -170,6 +190,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextDouble produce at least two distinct results
      */
+    @Test
     public void testNextDouble() {
         double f = ThreadLocalRandom.current().nextDouble();
         int i = 0;
@@ -181,6 +202,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Repeated calls to nextGaussian produce at least two distinct results
      */
+    @Test
     public void testNextGaussian() {
         double f = ThreadLocalRandom.current().nextGaussian();
         int i = 0;
@@ -192,6 +214,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * nextInt(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextIntBoundNonPositive() {
         ThreadLocalRandom rnd = ThreadLocalRandom.current();
         for (int bound : new int[] { 0, -17, Integer.MIN_VALUE }) {
@@ -205,6 +228,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * nextInt(least >= bound) throws IllegalArgumentException
      */
+    @Test
     public void testNextIntBadBounds() {
         int[][] badBoundss = {
             { 17, 2 },
@@ -224,6 +248,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * nextInt(bound) returns 0 <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextIntBounded() {
         // sample bound space across prime number increments
         for (int bound = 2; bound < MAX_INT_BOUND; bound += 524959) {
@@ -244,6 +269,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * nextInt(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextIntBounded2() {
         for (int least = -15485863; least < MAX_INT_BOUND; least += 524959) {
             for (int bound = least + 2; bound > least && bound < MAX_INT_BOUND; bound += 49979687) {
@@ -264,6 +290,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * nextLong(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextLongBoundNonPositive() {
         ThreadLocalRandom rnd = ThreadLocalRandom.current();
         for (long bound : new long[] { 0L, -17L, Long.MIN_VALUE }) {
@@ -277,6 +304,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * nextLong(least >= bound) throws IllegalArgumentException
      */
+    @Test
     public void testNextLongBadBounds() {
         long[][] badBoundss = {
             { 17L, 2L },
@@ -296,6 +324,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * nextLong(bound) returns 0 <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextLongBounded() {
         for (long bound = 2; bound < MAX_LONG_BOUND; bound += 15485863) {
             long f = ThreadLocalRandom.current().nextLong(bound);
@@ -315,6 +344,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * nextLong(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextLongBounded2() {
         for (long least = -86028121; least < MAX_LONG_BOUND; least += 982451653L) {
             for (long bound = least + 2; bound > least && bound < MAX_LONG_BOUND; bound += Math.abs(bound * 7919)) {
@@ -335,6 +365,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * nextDouble(non-positive) throws IllegalArgumentException
      */
+    @Test
     public void testNextDoubleBoundNonPositive() {
         ThreadLocalRandom rnd = ThreadLocalRandom.current();
         double[] badBounds = {
@@ -356,6 +387,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
      * nextDouble(least, bound) returns least <= value < bound;
      * repeated calls produce at least two distinct results
      */
+    @Test
     public void testNextDoubleBounded2() {
         for (double least = 0.0001; least < 1.0e20; least *= 8) {
             for (double bound = least * 1.001; bound < 1.0e20; bound *= 16) {
@@ -376,6 +408,7 @@ public class ThreadLocalRandomTest extends JSR166TestCase {
     /**
      * Different threads produce different pseudo-random sequences
      */
+    @Test
     public void testDifferentSequences() {
         // Don't use main thread's ThreadLocalRandom - it is likely to
         // be polluted by previous tests.
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalTest.java b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalTest.java
index 05588baaf37..3612da2735e 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadLocalTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadLocalTest.java
@@ -34,17 +34,31 @@
  */
 
 package test.java.util.concurrent.tck;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadLocalTest extends JSR166TestCase {
-    public static void main(String[] args) {
-        main(suite(), args);
-    }
 
-    public static Test suite() {
-        return new TestSuite(ThreadLocalTest.class);
+    // Android-changed: Use JUnitCore.main.
+    public static void main(String[] args) {
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadLocalTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadLocalTest.class);
+    // }
 
     static ThreadLocal<Integer> tl = new ThreadLocal<Integer>() {
             public Integer initialValue() {
@@ -66,6 +80,7 @@ public class ThreadLocalTest extends JSR166TestCase {
     /**
      * remove causes next access to return initial value
      */
+    @Test
     public void testRemove() {
         assertSame(tl.get(), one);
         tl.set(two);
@@ -78,6 +93,7 @@ public class ThreadLocalTest extends JSR166TestCase {
      * remove in InheritableThreadLocal causes next access to return
      * initial value
      */
+    @Test
     public void testRemoveITL() {
         assertSame(itl.get(), zero);
         itl.set(two);
@@ -116,6 +132,7 @@ public class ThreadLocalTest extends JSR166TestCase {
     /**
      * InheritableThreadLocal propagates generic values.
      */
+    @Test
     public void testGenericITL() throws InterruptedException {
         final int threadCount = 10;
         final int[] x = new int[threadCount];
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorSubclassTest.java b/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorSubclassTest.java
index 2e84a6edfa3..de62b4fe178 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorSubclassTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorSubclassTest.java
@@ -36,6 +36,14 @@
 package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -61,16 +69,21 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ThreadPoolExecutorSubclassTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadPoolExecutorSubclassTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadPoolExecutorSubclassTest.class);
+    // }
 
     static class CustomTask<V> implements RunnableFuture<V> {
         final Callable<V> callable;
@@ -256,6 +269,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute successfully executes a runnable
      */
+    @Test
     public void testExecute() throws InterruptedException {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -274,6 +288,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * getActiveCount increases but doesn't overestimate, when a
      * thread becomes active
      */
+    @Test
     public void testGetActiveCount() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -297,6 +312,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * prestartCoreThread starts a thread if under corePoolSize, else doesn't
      */
+    @Test
     public void testPrestartCoreThread() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 6,
@@ -323,6 +339,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * prestartAllCoreThreads starts all corePoolSize threads
      */
+    @Test
     public void testPrestartAllCoreThreads() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 6,
@@ -346,6 +363,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * getCompletedTaskCount increases, but doesn't overestimate,
      * when tasks complete
      */
+    @Test
     public void testGetCompletedTaskCount() throws InterruptedException {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 2,
@@ -379,6 +397,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getCorePoolSize returns size given in constructor if not otherwise set
      */
+    @Test
     public void testGetCorePoolSize() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -392,6 +411,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getKeepAliveTime returns value given in constructor if not otherwise set
      */
+    @Test
     public void testGetKeepAliveTime() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 2,
@@ -405,6 +425,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getThreadFactory returns factory in constructor if not set
      */
+    @Test
     public void testGetThreadFactory() {
         final ThreadFactory threadFactory = new SimpleThreadFactory();
         final ThreadPoolExecutor p =
@@ -421,6 +442,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * setThreadFactory sets the thread factory returned by getThreadFactory
      */
+    @Test
     public void testSetThreadFactory() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -436,6 +458,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * setThreadFactory(null) throws NPE
      */
+    @Test
     public void testSetThreadFactoryNull() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -452,6 +475,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getRejectedExecutionHandler returns handler in constructor if not set
      */
+    @Test
     public void testGetRejectedExecutionHandler() {
         final RejectedExecutionHandler handler = new NoOpREHandler();
         final ThreadPoolExecutor p =
@@ -468,6 +492,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * setRejectedExecutionHandler sets the handler returned by
      * getRejectedExecutionHandler
      */
+    @Test
     public void testSetRejectedExecutionHandler() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -483,6 +508,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * setRejectedExecutionHandler(null) throws NPE
      */
+    @Test
     public void testSetRejectedExecutionHandlerNull() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -500,6 +526,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * getLargestPoolSize increases, but doesn't overestimate, when
      * multiple threads active
      */
+    @Test
     public void testGetLargestPoolSize() throws InterruptedException {
         final int THREADS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -527,6 +554,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * getMaximumPoolSize returns value given in constructor if not
      * otherwise set
      */
+    @Test
     public void testGetMaximumPoolSize() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 3,
@@ -545,6 +573,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * getPoolSize increases, but doesn't overestimate, when threads
      * become active
      */
+    @Test
     public void testGetPoolSize() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -568,6 +597,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getTaskCount increases, but doesn't overestimate, when tasks submitted
      */
+    @Test
     public void testGetTaskCount() throws InterruptedException {
         final int TASKS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -606,6 +636,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * isShutdown is false before shutdown, true after
      */
+    @Test
     public void testIsShutdown() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -621,6 +652,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * isTerminated is false before termination, true after
      */
+    @Test
     public void testIsTerminated() throws InterruptedException {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -649,6 +681,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * isTerminating is not true when running or when terminated
      */
+    @Test
     public void testIsTerminating() throws InterruptedException {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -677,6 +710,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * getQueue returns the work queue, which contains queued tasks
      */
+    @Test
     public void testGetQueue() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final BlockingQueue<Runnable> q = new ArrayBlockingQueue<>(10);
@@ -709,6 +743,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * remove(task) removes queued task, and fails to remove active task
      */
+    @Test
     public void testRemove() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         BlockingQueue<Runnable> q = new ArrayBlockingQueue<>(10);
@@ -743,6 +778,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * purge removes cancelled tasks from the queue
      */
+    @Test
     public void testPurge() throws InterruptedException {
         final CountDownLatch threadStarted = new CountDownLatch(1);
         final CountDownLatch done = new CountDownLatch(1);
@@ -783,6 +819,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow() throws InterruptedException {
         final int poolSize = 2;
         final int count = 5;
@@ -824,6 +861,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor1() {
         try {
             new CustomTPE(-1, 1, 1L, SECONDS,
@@ -835,6 +873,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor2() {
         try {
             new CustomTPE(1, -1, 1L, SECONDS,
@@ -846,6 +885,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor3() {
         try {
             new CustomTPE(1, 0, 1L, SECONDS,
@@ -857,6 +897,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor4() {
         try {
             new CustomTPE(1, 2, -1L, SECONDS,
@@ -868,6 +909,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor5() {
         try {
             new CustomTPE(2, 1, 1L, SECONDS,
@@ -879,6 +921,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS, null);
@@ -889,6 +932,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor6() {
         try {
             new CustomTPE(-1, 1, 1L, SECONDS,
@@ -901,6 +945,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor7() {
         try {
             new CustomTPE(1,-1, 1L, SECONDS,
@@ -913,6 +958,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor8() {
         try {
             new CustomTPE(1, 0, 1L, SECONDS,
@@ -925,6 +971,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor9() {
         try {
             new CustomTPE(1, 2, -1L, SECONDS,
@@ -937,6 +984,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor10() {
         try {
             new CustomTPE(2, 1, 1L, SECONDS,
@@ -949,6 +997,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException2() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS, null, new SimpleThreadFactory());
@@ -959,6 +1008,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if threadFactory is set to null
      */
+    @Test
     public void testConstructorNullPointerException3() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -971,6 +1021,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor11() {
         try {
             new CustomTPE(-1, 1, 1L, SECONDS,
@@ -983,6 +1034,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor12() {
         try {
             new CustomTPE(1, -1, 1L, SECONDS,
@@ -995,6 +1047,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor13() {
         try {
             new CustomTPE(1, 0, 1L, SECONDS,
@@ -1007,6 +1060,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor14() {
         try {
             new CustomTPE(1, 2, -1L, SECONDS,
@@ -1019,6 +1073,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor15() {
         try {
             new CustomTPE(2, 1, 1L, SECONDS,
@@ -1031,6 +1086,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException4() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -1043,6 +1099,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if handler is set to null
      */
+    @Test
     public void testConstructorNullPointerException5() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -1055,6 +1112,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor16() {
         try {
             new CustomTPE(-1, 1, 1L, SECONDS,
@@ -1068,6 +1126,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor17() {
         try {
             new CustomTPE(1, -1, 1L, SECONDS,
@@ -1081,6 +1140,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor18() {
         try {
             new CustomTPE(1, 0, 1L, SECONDS,
@@ -1094,6 +1154,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor19() {
         try {
             new CustomTPE(1, 2, -1L, SECONDS,
@@ -1107,6 +1168,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor20() {
         try {
             new CustomTPE(2, 1, 1L, SECONDS,
@@ -1120,6 +1182,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is null
      */
+    @Test
     public void testConstructorNullPointerException6() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -1133,6 +1196,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if handler is null
      */
+    @Test
     public void testConstructorNullPointerException7() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -1146,6 +1210,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * Constructor throws if ThreadFactory is null
      */
+    @Test
     public void testConstructorNullPointerException8() {
         try {
             new CustomTPE(1, 2, 1L, SECONDS,
@@ -1159,6 +1224,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if saturated.
      */
+    @Test
     public void testSaturatedExecute() {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1185,6 +1251,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * executor using CallerRunsPolicy runs task if saturated.
      */
+    @Test
     public void testSaturatedExecute2() {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1212,6 +1279,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * executor using DiscardPolicy drops task if saturated.
      */
+    @Test
     public void testSaturatedExecute3() {
         final TrackedNoOpRunnable[] tasks = new TrackedNoOpRunnable[5];
         for (int i = 0; i < tasks.length; ++i)
@@ -1238,6 +1306,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * executor using DiscardOldestPolicy drops oldest task if saturated.
      */
+    @Test
     public void testSaturatedExecute4() {
         final CountDownLatch done = new CountDownLatch(1);
         LatchAwaiter r1 = awaiter(done);
@@ -1267,6 +1336,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testRejectedExecutionExceptionOnShutdown() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -1284,6 +1354,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute using CallerRunsPolicy drops task on shutdown
      */
+    @Test
     public void testCallerRunsOnShutdown() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -1301,6 +1372,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute using DiscardPolicy drops task on shutdown
      */
+    @Test
     public void testDiscardOnShutdown() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -1318,6 +1390,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute using DiscardOldestPolicy drops task on shutdown
      */
+    @Test
     public void testDiscardOldestOnShutdown() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 1,
@@ -1336,6 +1409,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * execute(null) throws NPE
      */
+    @Test
     public void testExecuteNull() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -1352,6 +1426,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * setCorePoolSize of negative value throws IllegalArgumentException
      */
+    @Test
     public void testCorePoolSizeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new CustomTPE(1, 2,
@@ -1369,6 +1444,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * setMaximumPoolSize(int) throws IllegalArgumentException
      * if given a value less the core pool size
      */
+    @Test
     public void testMaximumPoolSizeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 3,
@@ -1386,6 +1462,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * setMaximumPoolSize throws IllegalArgumentException
      * if given a negative value
      */
+    @Test
     public void testMaximumPoolSizeIllegalArgumentException2() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 3,
@@ -1403,6 +1480,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * setKeepAliveTime throws IllegalArgumentException
      * when given a negative value
      */
+    @Test
     public void testKeepAliveTimeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 3,
@@ -1419,6 +1497,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * terminated() is called on termination
      */
+    @Test
     public void testTerminated() {
         CustomTPE p = new CustomTPE();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -1431,6 +1510,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * beforeExecute and afterExecute are called when executing task
      */
+    @Test
     public void testBeforeAfter() throws InterruptedException {
         CustomTPE p = new CustomTPE();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -1449,6 +1529,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of callable returns result
      */
+    @Test
     public void testSubmitCallable() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1464,6 +1545,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of runnable returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1479,6 +1561,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * completed submit of (runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1494,6 +1577,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NPE
      */
+    @Test
     public void testInvokeAny1() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1510,6 +1594,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testInvokeAny2() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1526,6 +1611,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAny3() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e =
@@ -1547,6 +1633,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testInvokeAny4() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1567,6 +1654,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task
      */
+    @Test
     public void testInvokeAny5() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1584,6 +1672,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NPE
      */
+    @Test
     public void testInvokeAll1() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1600,6 +1689,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1614,6 +1704,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1633,6 +1724,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testInvokeAll4() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1655,6 +1747,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testInvokeAll5() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1674,6 +1767,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAny1() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1690,6 +1784,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1708,6 +1803,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testTimedInvokeAny2() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1725,6 +1821,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e =
@@ -1746,6 +1843,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1768,6 +1866,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task
      */
+    @Test
     public void testTimedInvokeAny5() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1787,6 +1886,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAll1() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1803,6 +1903,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1821,6 +1922,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1836,6 +1938,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1855,6 +1958,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1878,6 +1982,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testTimedInvokeAll5() throws Exception {
         final ExecutorService e =
             new CustomTPE(2, 2,
@@ -1898,6 +2003,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) cancels tasks not completed by timeout
      */
+    @Test
     public void testTimedInvokeAll6() throws Exception {
         for (long timeout = timeoutMillis();;) {
             final CountDownLatch done = new CountDownLatch(1);
@@ -1940,6 +2046,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * Execution continues if there is at least one thread even if
      * thread factory fails to create more
      */
+    @Test
     public void testFailingThreadFactory() throws InterruptedException {
         final ExecutorService e =
             new CustomTPE(100, 100,
@@ -1961,6 +2068,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * allowsCoreThreadTimeOut is by default false.
      */
+    @Test
     public void testAllowsCoreThreadTimeOut() {
         final ThreadPoolExecutor p =
             new CustomTPE(2, 2,
@@ -1974,6 +2082,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * allowCoreThreadTimeOut(true) causes idle threads to time out
      */
+    @Test
     public void testAllowCoreThreadTimeOut_true() throws Exception {
         long keepAliveTime = timeoutMillis();
         final ThreadPoolExecutor p =
@@ -2002,6 +2111,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
     /**
      * allowCoreThreadTimeOut(false) causes idle threads not to time out
      */
+    @Test
     public void testAllowCoreThreadTimeOut_false() throws Exception {
         long keepAliveTime = timeoutMillis();
         final ThreadPoolExecutor p =
@@ -2025,6 +2135,7 @@ public class ThreadPoolExecutorSubclassTest extends JSR166TestCase {
      * get(cancelled task) throws CancellationException
      * (in part, a test of CustomTPE itself)
      */
+    @Test
     public void testGet_cancelled() throws Exception {
         final CountDownLatch done = new CountDownLatch(1);
         final ExecutorService e =
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorTest.java b/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorTest.java
index 90f9eb30083..fba45041608 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadPoolExecutorTest.java
@@ -37,6 +37,14 @@ package test.java.util.concurrent.tck;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -58,16 +66,22 @@ import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadPoolExecutorTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(ThreadPoolExecutorTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadPoolExecutorTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadPoolExecutorTest.class);
+    // }
 
     static class ExtendedTPE extends ThreadPoolExecutor {
         final CountDownLatch beforeCalled = new CountDownLatch(1);
@@ -109,6 +123,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute successfully executes a runnable
      */
+    @Test
     public void testExecute() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -127,6 +142,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * getActiveCount increases but doesn't overestimate, when a
      * thread becomes active
      */
+    @Test
     public void testGetActiveCount() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -150,6 +166,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * prestartCoreThread starts a thread if under corePoolSize, else doesn't
      */
+    @Test
     public void testPrestartCoreThread() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 6,
@@ -176,6 +193,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * prestartAllCoreThreads starts all corePoolSize threads
      */
+    @Test
     public void testPrestartAllCoreThreads() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 6,
@@ -199,6 +217,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * getCompletedTaskCount increases, but doesn't overestimate,
      * when tasks complete
      */
+    @Test
     public void testGetCompletedTaskCount() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 2,
@@ -232,6 +251,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getCorePoolSize returns size given in constructor if not otherwise set
      */
+    @Test
     public void testGetCorePoolSize() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -245,6 +265,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getKeepAliveTime returns value given in constructor if not otherwise set
      */
+    @Test
     public void testGetKeepAliveTime() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 2,
@@ -258,6 +279,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getThreadFactory returns factory in constructor if not set
      */
+    @Test
     public void testGetThreadFactory() {
         ThreadFactory threadFactory = new SimpleThreadFactory();
         final ThreadPoolExecutor p =
@@ -274,6 +296,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * setThreadFactory sets the thread factory returned by getThreadFactory
      */
+    @Test
     public void testSetThreadFactory() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -289,6 +312,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * setThreadFactory(null) throws NPE
      */
+    @Test
     public void testSetThreadFactoryNull() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -305,6 +329,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getRejectedExecutionHandler returns handler in constructor if not set
      */
+    @Test
     public void testGetRejectedExecutionHandler() {
         final RejectedExecutionHandler handler = new NoOpREHandler();
         final ThreadPoolExecutor p =
@@ -321,6 +346,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * setRejectedExecutionHandler sets the handler returned by
      * getRejectedExecutionHandler
      */
+    @Test
     public void testSetRejectedExecutionHandler() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -336,6 +362,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * setRejectedExecutionHandler(null) throws NPE
      */
+    @Test
     public void testSetRejectedExecutionHandlerNull() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -353,6 +380,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * getLargestPoolSize increases, but doesn't overestimate, when
      * multiple threads active
      */
+    @Test
     public void testGetLargestPoolSize() throws InterruptedException {
         final int THREADS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -380,6 +408,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * getMaximumPoolSize returns value given in constructor if not
      * otherwise set
      */
+    @Test
     public void testGetMaximumPoolSize() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 3,
@@ -398,6 +427,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * getPoolSize increases, but doesn't overestimate, when threads
      * become active
      */
+    @Test
     public void testGetPoolSize() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -421,6 +451,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getTaskCount increases, but doesn't overestimate, when tasks submitted
      */
+    @Test
     public void testGetTaskCount() throws InterruptedException {
         final int TASKS = 3;
         final CountDownLatch done = new CountDownLatch(1);
@@ -459,6 +490,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * isShutdown is false before shutdown, true after
      */
+    @Test
     public void testIsShutdown() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -474,6 +506,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * awaitTermination on a non-shutdown pool times out
      */
+    @Test
     public void testAwaitTermination_timesOut() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -506,6 +539,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * isTerminated is false before termination, true after
      */
+    @Test
     public void testIsTerminated() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -534,6 +568,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * isTerminating is not true when running or when terminated
      */
+    @Test
     public void testIsTerminating() throws InterruptedException {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -562,6 +597,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * getQueue returns the work queue, which contains queued tasks
      */
+    @Test
     public void testGetQueue() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final BlockingQueue<Runnable> q = new ArrayBlockingQueue<>(10);
@@ -594,6 +630,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * remove(task) removes queued task, and fails to remove active task
      */
+    @Test
     public void testRemove() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         BlockingQueue<Runnable> q = new ArrayBlockingQueue<>(10);
@@ -628,6 +665,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * purge removes cancelled tasks from the queue
      */
+    @Test
     public void testPurge() throws InterruptedException {
         final CountDownLatch threadStarted = new CountDownLatch(1);
         final CountDownLatch done = new CountDownLatch(1);
@@ -668,6 +706,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * shutdownNow returns a list containing tasks that were not run,
      * and those tasks are drained from the queue
      */
+    @Test
     public void testShutdownNow() throws InterruptedException {
         final int poolSize = 2;
         final int count = 5;
@@ -709,6 +748,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor1() {
         try {
             new ThreadPoolExecutor(-1, 1, 1L, SECONDS,
@@ -720,6 +760,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor2() {
         try {
             new ThreadPoolExecutor(1, -1, 1L, SECONDS,
@@ -731,6 +772,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor3() {
         try {
             new ThreadPoolExecutor(1, 0, 1L, SECONDS,
@@ -742,6 +784,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor4() {
         try {
             new ThreadPoolExecutor(1, 2, -1L, SECONDS,
@@ -753,6 +796,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor5() {
         try {
             new ThreadPoolExecutor(2, 1, 1L, SECONDS,
@@ -764,6 +808,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -775,6 +820,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor6() {
         try {
             new ThreadPoolExecutor(-1, 1, 1L, SECONDS,
@@ -787,6 +833,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor7() {
         try {
             new ThreadPoolExecutor(1, -1, 1L, SECONDS,
@@ -799,6 +846,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor8() {
         try {
             new ThreadPoolExecutor(1, 0, 1L, SECONDS,
@@ -811,6 +859,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor9() {
         try {
             new ThreadPoolExecutor(1, 2, -1L, SECONDS,
@@ -823,6 +872,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor10() {
         try {
             new ThreadPoolExecutor(2, 1, 1L, SECONDS,
@@ -835,6 +885,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException2() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -847,6 +898,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if threadFactory is set to null
      */
+    @Test
     public void testConstructorNullPointerException3() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -859,6 +911,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor11() {
         try {
             new ThreadPoolExecutor(-1, 1, 1L, SECONDS,
@@ -871,6 +924,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor12() {
         try {
             new ThreadPoolExecutor(1, -1, 1L, SECONDS,
@@ -883,6 +937,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor13() {
         try {
             new ThreadPoolExecutor(1, 0, 1L, SECONDS,
@@ -895,6 +950,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor14() {
         try {
             new ThreadPoolExecutor(1, 2, -1L, SECONDS,
@@ -907,6 +963,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor15() {
         try {
             new ThreadPoolExecutor(2, 1, 1L, SECONDS,
@@ -919,6 +976,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is set to null
      */
+    @Test
     public void testConstructorNullPointerException4() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -931,6 +989,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if handler is set to null
      */
+    @Test
     public void testConstructorNullPointerException5() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -943,6 +1002,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize argument is less than zero
      */
+    @Test
     public void testConstructor16() {
         try {
             new ThreadPoolExecutor(-1, 1, 1L, SECONDS,
@@ -956,6 +1016,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is less than zero
      */
+    @Test
     public void testConstructor17() {
         try {
             new ThreadPoolExecutor(1, -1, 1L, SECONDS,
@@ -969,6 +1030,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if maximumPoolSize is equal to zero
      */
+    @Test
     public void testConstructor18() {
         try {
             new ThreadPoolExecutor(1, 0, 1L, SECONDS,
@@ -982,6 +1044,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if keepAliveTime is less than zero
      */
+    @Test
     public void testConstructor19() {
         try {
             new ThreadPoolExecutor(1, 2, -1L, SECONDS,
@@ -995,6 +1058,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if corePoolSize is greater than the maximumPoolSize
      */
+    @Test
     public void testConstructor20() {
         try {
             new ThreadPoolExecutor(2, 1, 1L, SECONDS,
@@ -1008,6 +1072,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if workQueue is null
      */
+    @Test
     public void testConstructorNullPointerException6() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -1021,6 +1086,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if handler is null
      */
+    @Test
     public void testConstructorNullPointerException7() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -1034,6 +1100,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * Constructor throws if ThreadFactory is null
      */
+    @Test
     public void testConstructorNullPointerException8() {
         try {
             new ThreadPoolExecutor(1, 2, 1L, SECONDS,
@@ -1047,6 +1114,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * get of submitted callable throws InterruptedException if interrupted
      */
+    @Test
     public void testInterruptedSubmit() throws InterruptedException {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1076,6 +1144,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if saturated.
      */
+    @Test
     public void testSaturatedExecute() {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1102,6 +1171,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * submit(runnable) throws RejectedExecutionException if saturated.
      */
+    @Test
     public void testSaturatedSubmitRunnable() {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1128,6 +1198,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * submit(callable) throws RejectedExecutionException if saturated.
      */
+    @Test
     public void testSaturatedSubmitCallable() {
         final CountDownLatch done = new CountDownLatch(1);
         final ThreadPoolExecutor p =
@@ -1154,6 +1225,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * executor using CallerRunsPolicy runs task if saturated.
      */
+    @Test
     public void testSaturatedExecute2() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -1183,6 +1255,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * executor using DiscardPolicy drops task if saturated.
      */
+    @Test
     public void testSaturatedExecute3() {
         final CountDownLatch done = new CountDownLatch(1);
         final TrackedNoOpRunnable[] tasks = new TrackedNoOpRunnable[5];
@@ -1209,6 +1282,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * executor using DiscardOldestPolicy drops oldest task if saturated.
      */
+    @Test
     public void testSaturatedExecute4() {
         final CountDownLatch done = new CountDownLatch(1);
         LatchAwaiter r1 = awaiter(done);
@@ -1238,6 +1312,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute throws RejectedExecutionException if shutdown
      */
+    @Test
     public void testRejectedExecutionExceptionOnShutdown() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -1255,6 +1330,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute using CallerRunsPolicy drops task on shutdown
      */
+    @Test
     public void testCallerRunsOnShutdown() {
         RejectedExecutionHandler h = new ThreadPoolExecutor.CallerRunsPolicy();
         final ThreadPoolExecutor p =
@@ -1273,6 +1349,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute using DiscardPolicy drops task on shutdown
      */
+    @Test
     public void testDiscardOnShutdown() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -1291,6 +1368,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute using DiscardOldestPolicy drops task on shutdown
      */
+    @Test
     public void testDiscardOldestOnShutdown() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -1309,6 +1387,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * execute(null) throws NPE
      */
+    @Test
     public void testExecuteNull() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -1325,6 +1404,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * setCorePoolSize of negative value throws IllegalArgumentException
      */
+    @Test
     public void testCorePoolSizeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 2,
@@ -1342,6 +1422,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * setMaximumPoolSize(int) throws IllegalArgumentException if
      * given a value less the core pool size
      */
+    @Test
     public void testMaximumPoolSizeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 3,
@@ -1359,6 +1440,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * setMaximumPoolSize throws IllegalArgumentException
      * if given a negative value
      */
+    @Test
     public void testMaximumPoolSizeIllegalArgumentException2() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 3,
@@ -1376,6 +1458,8 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * Configuration changes that allow core pool size greater than
      * max pool size result in IllegalArgumentException.
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testPoolSizeInvariants() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(1, 1,
@@ -1405,6 +1489,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * setKeepAliveTime throws IllegalArgumentException
      * when given a negative value
      */
+    @Test
     public void testKeepAliveTimeIllegalArgumentException() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 3,
@@ -1421,6 +1506,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * terminated() is called on termination
      */
+    @Test
     public void testTerminated() {
         ExtendedTPE p = new ExtendedTPE();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -1433,6 +1519,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * beforeExecute and afterExecute are called when executing task
      */
+    @Test
     public void testBeforeAfter() throws InterruptedException {
         ExtendedTPE p = new ExtendedTPE();
         try (PoolCleaner cleaner = cleaner(p)) {
@@ -1451,6 +1538,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * completed submit of callable returns result
      */
+    @Test
     public void testSubmitCallable() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1466,6 +1554,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * completed submit of runnable returns successfully
      */
+    @Test
     public void testSubmitRunnable() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1481,6 +1570,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * completed submit of (runnable, result) returns result
      */
+    @Test
     public void testSubmitRunnable2() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1496,6 +1586,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(null) throws NPE
      */
+    @Test
     public void testInvokeAny1() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1512,6 +1603,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testInvokeAny2() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1528,6 +1620,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAny3() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e =
@@ -1549,6 +1642,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testInvokeAny4() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1569,6 +1663,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAny(c) returns result of some task
      */
+    @Test
     public void testInvokeAny5() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1586,6 +1681,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(null) throws NPE
      */
+    @Test
     public void testInvokeAll1() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1602,6 +1698,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testInvokeAll2() throws InterruptedException {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1616,6 +1713,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testInvokeAll3() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1635,6 +1733,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testInvokeAll4() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1657,6 +1756,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testInvokeAll5() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1676,6 +1776,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAny1() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1692,6 +1793,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAnyNullTimeUnit() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1710,6 +1812,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(empty collection) throws IAE
      */
+    @Test
     public void testTimedInvokeAny2() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1727,6 +1830,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAny3() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final ExecutorService e =
@@ -1748,6 +1852,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) throws ExecutionException if no task completes
      */
+    @Test
     public void testTimedInvokeAny4() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1770,6 +1875,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAny(c) returns result of some task
      */
+    @Test
     public void testTimedInvokeAny5() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1789,6 +1895,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(null) throws NPE
      */
+    @Test
     public void testTimedInvokeAll1() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1805,6 +1912,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(,,null) throws NPE
      */
+    @Test
     public void testTimedInvokeAllNullTimeUnit() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1823,6 +1931,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(empty collection) returns empty collection
      */
+    @Test
     public void testTimedInvokeAll2() throws InterruptedException {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1838,6 +1947,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) throws NPE if c has null elements
      */
+    @Test
     public void testTimedInvokeAll3() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1857,6 +1967,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * get of element of invokeAll(c) throws exception on failed task
      */
+    @Test
     public void testTimedInvokeAll4() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1880,6 +1991,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) returns results of all completed tasks
      */
+    @Test
     public void testTimedInvokeAll5() throws Exception {
         final ExecutorService e =
             new ThreadPoolExecutor(2, 2,
@@ -1900,6 +2012,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * timed invokeAll(c) cancels tasks not completed by timeout
      */
+    @Test
     public void testTimedInvokeAll6() throws Exception {
         for (long timeout = timeoutMillis();;) {
             final CountDownLatch done = new CountDownLatch(1);
@@ -1942,6 +2055,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * Execution continues if there is at least one thread even if
      * thread factory fails to create more
      */
+    @Test
     public void testFailingThreadFactory() throws InterruptedException {
         final ExecutorService e =
             new ThreadPoolExecutor(100, 100,
@@ -1963,6 +2077,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * allowsCoreThreadTimeOut is by default false.
      */
+    @Test
     public void testAllowsCoreThreadTimeOut() {
         final ThreadPoolExecutor p =
             new ThreadPoolExecutor(2, 2,
@@ -1976,6 +2091,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * allowCoreThreadTimeOut(true) causes idle threads to time out
      */
+    @Test
     public void testAllowCoreThreadTimeOut_true() throws Exception {
         long keepAliveTime = timeoutMillis();
         final ThreadPoolExecutor p =
@@ -2004,6 +2120,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * allowCoreThreadTimeOut(false) causes idle threads not to time out
      */
+    @Test
     public void testAllowCoreThreadTimeOut_false() throws Exception {
         long keepAliveTime = timeoutMillis();
         final ThreadPoolExecutor p =
@@ -2027,6 +2144,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
      * execute allows the same task to be submitted multiple times, even
      * if rejected
      */
+    @Test
     public void testRejectedRecycledTask() throws InterruptedException {
         final int nTasks = 1000;
         final CountDownLatch done = new CountDownLatch(nTasks);
@@ -2056,6 +2174,7 @@ public class ThreadPoolExecutorTest extends JSR166TestCase {
     /**
      * get(cancelled task) throws CancellationException
      */
+    @Test
     public void testGet_cancelled() throws Exception {
         final CountDownLatch done = new CountDownLatch(1);
         final ExecutorService e =
diff --git a/ojluni/src/test/java/util/concurrent/tck/ThreadTest.java b/ojluni/src/test/java/util/concurrent/tck/ThreadTest.java
index d15ef929540..e2bb6a1a7af 100644
--- a/ojluni/src/test/java/util/concurrent/tck/ThreadTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/ThreadTest.java
@@ -34,17 +34,32 @@
  */
 
 package test.java.util.concurrent.tck;
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class ThreadTest extends JSR166TestCase {
-    public static void main(String[] args) {
-        main(suite(), args);
-    }
 
-    public static Test suite() {
-        return new TestSuite(ThreadTest.class);
+    // Android-changed: Use JUnitCore.main.
+    public static void main(String[] args) {
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.ThreadTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(ThreadTest.class);
+    // }
 
     static class MyHandler implements Thread.UncaughtExceptionHandler {
         public void uncaughtException(Thread t, Throwable e) {
@@ -56,6 +71,7 @@ public class ThreadTest extends JSR166TestCase {
      * getUncaughtExceptionHandler returns ThreadGroup unless set,
      * otherwise returning value of last setUncaughtExceptionHandler.
      */
+    @Test
     public void testGetAndSetUncaughtExceptionHandler() {
         // these must be done all at once to avoid state
         // dependencies across tests
@@ -76,6 +92,8 @@ public class ThreadTest extends JSR166TestCase {
      * getDefaultUncaughtExceptionHandler returns value of last
      * setDefaultUncaughtExceptionHandler.
      */
+    @Test
+    @Ignore("Not run in Android")
     public void testGetAndSetDefaultUncaughtExceptionHandler() {
         assertEquals(null, Thread.getDefaultUncaughtExceptionHandler());
         // failure due to SecurityException is OK.
diff --git a/ojluni/src/test/java/util/concurrent/tck/TimeUnit8Test.java b/ojluni/src/test/java/util/concurrent/tck/TimeUnit8Test.java
index 5cddf1c2dfb..4109d9d063a 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TimeUnit8Test.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TimeUnit8Test.java
@@ -40,6 +40,14 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.time.Duration;
 import java.time.temporal.ChronoUnit;
@@ -48,21 +56,27 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.LongStream;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TimeUnit8Test extends JSR166TestCase {
-    public static void main(String[] args) {
-        main(suite(), args);
-    }
 
-    public static Test suite() {
-        return new TestSuite(TimeUnit8Test.class);
+    // Android-changed: Use JUnitCore.main.
+    public static void main(String[] args) {
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TimeUnit8Test");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TimeUnit8Test.class);
+    // }
 
     /**
      * tests for toChronoUnit.
      */
+    @Test
     public void testToChronoUnit() throws Exception {
         assertSame(ChronoUnit.NANOS,   NANOSECONDS.toChronoUnit());
         assertSame(ChronoUnit.MICROS,  MICROSECONDS.toChronoUnit());
@@ -80,6 +94,7 @@ public class TimeUnit8Test extends JSR166TestCase {
     /**
      * tests for TimeUnit.of(ChronoUnit).
      */
+    @Test
     public void testTimeUnitOf() throws Exception {
         assertSame(NANOSECONDS,  TimeUnit.of(ChronoUnit.NANOS));
         assertSame(MICROSECONDS, TimeUnit.of(ChronoUnit.MICROS));
@@ -108,6 +123,7 @@ public class TimeUnit8Test extends JSR166TestCase {
     /**
      * convert(Duration) roundtrips with Duration.ofXXXX and Duration.of(long, ChronoUnit)
      */
+    @Test
     public void testConvertDuration_roundtripDurationOf() {
         long n = ThreadLocalRandom.current().nextLong();
 
@@ -131,6 +147,7 @@ public class TimeUnit8Test extends JSR166TestCase {
     /**
      * convert(Duration.ofNanos(n)) agrees with convert(n, NANOSECONDS)
      */
+    @Test
     public void testConvertDuration_roundtripDurationOfNanos() {
         // Test values near unit transitions and near overflow.
         LongStream.concat(
@@ -148,6 +165,7 @@ public class TimeUnit8Test extends JSR166TestCase {
     /**
      * convert(Duration) doesn't misbehave near Long.MAX_VALUE and Long.MIN_VALUE.
      */
+    @Test
     public void testConvertDuration_nearOverflow() {
         ChronoUnit NANOS = ChronoUnit.NANOS;
         Duration maxDuration = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);
diff --git a/ojluni/src/test/java/util/concurrent/tck/TimeUnitTest.java b/ojluni/src/test/java/util/concurrent/tck/TimeUnitTest.java
index 8ff88597f5c..9eec30d6105 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TimeUnitTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TimeUnitTest.java
@@ -41,27 +41,41 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TimeUnitTest extends JSR166TestCase {
-    public static void main(String[] args) {
-        main(suite(), args);
-    }
 
-    public static Test suite() {
-        return new TestSuite(TimeUnitTest.class);
+    // Android-changed: Use JUnitCore.main.
+    public static void main(String[] args) {
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TimeUnitTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TimeUnitTest.class);
+    // }
 
     // (loops to 88888 check increments at all time divisions.)
 
     /**
      * convert correctly converts sample values across the units
      */
+    @Test
     public void testConvert() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*60*60*24,
@@ -139,6 +153,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toNanos correctly converts sample values in different units to
      * nanoseconds
      */
+    @Test
     public void testToNanos() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*1000000000L*60*60*24,
@@ -162,6 +177,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMicros correctly converts sample values in different units to
      * microseconds
      */
+    @Test
     public void testToMicros() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*1000000L*60*60*24,
@@ -185,6 +201,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMillis correctly converts sample values in different units to
      * milliseconds
      */
+    @Test
     public void testToMillis() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*1000L*60*60*24,
@@ -208,6 +225,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toSeconds correctly converts sample values in different units to
      * seconds
      */
+    @Test
     public void testToSeconds() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*60*60*24,
@@ -231,6 +249,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMinutes correctly converts sample values in different units to
      * minutes
      */
+    @Test
     public void testToMinutes() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*60*24,
@@ -254,6 +273,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toHours correctly converts sample values in different units to
      * hours
      */
+    @Test
     public void testToHours() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t*24,
@@ -277,6 +297,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toDays correctly converts sample values in different units to
      * days
      */
+    @Test
     public void testToDays() {
         for (long t = 0; t < 88888; ++t) {
             assertEquals(t,
@@ -300,6 +321,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * convert saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testConvertSaturate() {
         assertEquals(Long.MAX_VALUE,
                      NANOSECONDS.convert(Long.MAX_VALUE / 2, SECONDS));
@@ -344,6 +366,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toNanos saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToNanosSaturate() {
         assertEquals(Long.MAX_VALUE,
                      MILLISECONDS.toNanos(Long.MAX_VALUE / 2));
@@ -375,6 +398,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMicros saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToMicrosSaturate() {
         for (TimeUnit x : TimeUnit.values()) {
             long ratio = x.toNanos(1) / MICROSECONDS.toNanos(1);
@@ -401,6 +425,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMillis saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToMillisSaturate() {
         for (TimeUnit x : TimeUnit.values()) {
             long ratio = x.toNanos(1) / MILLISECONDS.toNanos(1);
@@ -427,6 +452,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toSeconds saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToSecondsSaturate() {
         for (TimeUnit x : TimeUnit.values()) {
             long ratio = x.toNanos(1) / SECONDS.toNanos(1);
@@ -453,6 +479,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toMinutes saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToMinutesSaturate() {
         for (TimeUnit x : TimeUnit.values()) {
             long ratio = x.toNanos(1) / MINUTES.toNanos(1);
@@ -473,6 +500,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * toHours saturates positive too-large values to Long.MAX_VALUE
      * and negative to LONG.MIN_VALUE
      */
+    @Test
     public void testToHoursSaturate() {
         for (TimeUnit x : TimeUnit.values()) {
             long ratio = x.toNanos(1) / HOURS.toNanos(1);
@@ -494,6 +522,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * toString returns name of unit
      */
+    @Test
     public void testToString() {
         assertEquals("SECONDS", SECONDS.toString());
     }
@@ -501,6 +530,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * name returns name of unit
      */
+    @Test
     public void testName() {
         assertEquals("SECONDS", SECONDS.name());
     }
@@ -509,6 +539,7 @@ public class TimeUnitTest extends JSR166TestCase {
      * Timed wait without holding lock throws
      * IllegalMonitorStateException
      */
+    @Test
     public void testTimedWait_IllegalMonitorException() {
         Thread t = newStartedThread(new CheckedRunnable() {
             public void realRun() throws InterruptedException {
@@ -527,6 +558,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * timedWait throws InterruptedException when interrupted
      */
+    @Test
     public void testTimedWait_Interruptible() {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -562,6 +594,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * timedJoin throws InterruptedException when interrupted
      */
+    @Test
     public void testTimedJoin_Interruptible() {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         final Thread s = newStartedThread(new CheckedInterruptedRunnable() {
@@ -597,6 +630,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * timedSleep throws InterruptedException when interrupted
      */
+    @Test
     public void testTimedSleep_Interruptible() {
         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
         Thread t = newStartedThread(new CheckedRunnable() {
@@ -626,6 +660,7 @@ public class TimeUnitTest extends JSR166TestCase {
     /**
      * a deserialized serialized unit is the same instance
      */
+    @Test
     public void testSerialization() throws Exception {
         for (TimeUnit x : TimeUnit.values())
             assertSame(x, serialClone(x));
diff --git a/ojluni/src/test/java/util/concurrent/tck/TreeMapTest.java b/ojluni/src/test/java/util/concurrent/tck/TreeMapTest.java
index 0953302ee51..a7ed8714d41 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TreeMapTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TreeMapTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Collection;
@@ -44,16 +53,21 @@ import java.util.Random;
 import java.util.Set;
 import java.util.TreeMap;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TreeMapTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(TreeMapTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TreeMapTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TreeMapTest.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -74,6 +88,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testClear() {
         TreeMap map = map5();
         map.clear();
@@ -83,6 +98,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * copy constructor creates map equal to source map
      */
+    @Test
     public void testConstructFromSorted() {
         TreeMap map = map5();
         TreeMap map2 = new TreeMap(map);
@@ -92,6 +108,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testEquals() {
         TreeMap map1 = map5();
         TreeMap map2 = map5();
@@ -105,6 +122,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testContainsKey() {
         TreeMap map = map5();
         assertTrue(map.containsKey(one));
@@ -114,6 +132,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testContainsValue() {
         TreeMap map = map5();
         assertTrue(map.containsValue("A"));
@@ -124,6 +143,7 @@ public class TreeMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testGet() {
         TreeMap map = map5();
         assertEquals("A", (String)map.get(one));
@@ -134,6 +154,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testIsEmpty() {
         TreeMap empty = new TreeMap();
         TreeMap map = map5();
@@ -144,6 +165,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testFirstKey() {
         TreeMap map = map5();
         assertEquals(one, map.firstKey());
@@ -152,6 +174,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testLastKey() {
         TreeMap map = map5();
         assertEquals(five, map.lastKey());
@@ -160,6 +183,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testKeySetToArray() {
         TreeMap map = map5();
         Set s = map.keySet();
@@ -173,6 +197,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descendingkeySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingKeySetToArray() {
         TreeMap map = map5();
         Set s = map.descendingKeySet();
@@ -186,6 +211,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testKeySet() {
         TreeMap map = map5();
         Set s = map.keySet();
@@ -200,6 +226,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testKeySetOrder() {
         TreeMap map = map5();
         Set s = map.keySet();
@@ -219,6 +246,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descending iterator of key set is inverse ordered
      */
+    @Test
     public void testKeySetDescendingIteratorOrder() {
         TreeMap map = map5();
         NavigableSet s = map.navigableKeySet();
@@ -238,6 +266,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descendingKeySet is ordered
      */
+    @Test
     public void testDescendingKeySetOrder() {
         TreeMap map = map5();
         Set s = map.descendingKeySet();
@@ -257,6 +286,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descending iterator of descendingKeySet is ordered
      */
+    @Test
     public void testDescendingKeySetDescendingIteratorOrder() {
         TreeMap map = map5();
         NavigableSet s = map.descendingKeySet();
@@ -276,6 +306,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testValues() {
         TreeMap map = map5();
         Collection s = map.values();
@@ -290,6 +321,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testEntrySet() {
         TreeMap map = map5();
         Set s = map.entrySet();
@@ -309,6 +341,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descendingEntrySet contains all pairs
      */
+    @Test
     public void testDescendingEntrySet() {
         TreeMap map = map5();
         Set s = map.descendingMap().entrySet();
@@ -328,6 +361,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * entrySet.toArray contains all entries
      */
+    @Test
     public void testEntrySetToArray() {
         TreeMap map = map5();
         Set s = map.entrySet();
@@ -342,6 +376,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * descendingEntrySet.toArray contains all entries
      */
+    @Test
     public void testDescendingEntrySetToArray() {
         TreeMap map = map5();
         Set s = map.descendingMap().entrySet();
@@ -356,6 +391,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testPutAll() {
         TreeMap empty = new TreeMap();
         TreeMap map = map5();
@@ -371,6 +407,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testRemove() {
         TreeMap map = map5();
         map.remove(five);
@@ -381,6 +418,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testLowerEntry() {
         TreeMap map = map5();
         Map.Entry e1 = map.lowerEntry(three);
@@ -399,6 +437,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testHigherEntry() {
         TreeMap map = map5();
         Map.Entry e1 = map.higherEntry(three);
@@ -417,6 +456,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testFloorEntry() {
         TreeMap map = map5();
         Map.Entry e1 = map.floorEntry(three);
@@ -435,6 +475,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testCeilingEntry() {
         TreeMap map = map5();
         Map.Entry e1 = map.ceilingEntry(three);
@@ -453,6 +494,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * lowerKey returns preceding element
      */
+    @Test
     public void testLowerKey() {
         TreeMap q = map5();
         Object e1 = q.lowerKey(three);
@@ -471,6 +513,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * higherKey returns next element
      */
+    @Test
     public void testHigherKey() {
         TreeMap q = map5();
         Object e1 = q.higherKey(three);
@@ -489,6 +532,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * floorKey returns preceding element
      */
+    @Test
     public void testFloorKey() {
         TreeMap q = map5();
         Object e1 = q.floorKey(three);
@@ -507,6 +551,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * ceilingKey returns next element
      */
+    @Test
     public void testCeilingKey() {
         TreeMap q = map5();
         Object e1 = q.ceilingKey(three);
@@ -525,6 +570,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testPollFirstEntry() {
         TreeMap map = map5();
         Map.Entry e = map.pollFirstEntry();
@@ -552,6 +598,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testPollLastEntry() {
         TreeMap map = map5();
         Map.Entry e = map.pollLastEntry();
@@ -579,6 +626,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testSize() {
         TreeMap map = map5();
         TreeMap empty = new TreeMap();
@@ -589,6 +637,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         TreeMap map = map5();
         String s = map.toString();
@@ -602,6 +651,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * get(null) of nonempty map throws NPE
      */
+    @Test
     public void testGet_NullPointerException() {
         TreeMap c = map5();
         try {
@@ -613,6 +663,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * containsKey(null) of nonempty map throws NPE
      */
+    @Test
     public void testContainsKey_NullPointerException() {
         TreeMap c = map5();
         try {
@@ -624,6 +675,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE for nonempty map
      */
+    @Test
     public void testRemove1_NullPointerException() {
         TreeMap c = new TreeMap();
         c.put("sadsdf", "asdads");
@@ -636,6 +688,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableMap x = map5();
         NavigableMap y = serialClone(x);
@@ -650,6 +703,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testSubMapContents() {
         TreeMap map = map5();
         NavigableMap sm = map.subMap(two, true, four, false);
@@ -688,6 +742,7 @@ public class TreeMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testSubMapContents2() {
         TreeMap map = map5();
         NavigableMap sm = map.subMap(two, true, three, false);
@@ -723,6 +778,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testHeadMapContents() {
         TreeMap map = map5();
         NavigableMap sm = map.headMap(four, false);
@@ -749,6 +805,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testTailMapContents() {
         TreeMap map = map5();
         NavigableMap sm = map.tailMap(two, true);
@@ -810,6 +867,7 @@ public class TreeMapTest extends JSR166TestCase {
     /**
      * Submaps of submaps subdivide correctly
      */
+    @Test
     public void testRecursiveSubMaps() throws Exception {
         int mapSize = expensiveTests ? 1000 : 100;
         Class cl = TreeMap.class;
diff --git a/ojluni/src/test/java/util/concurrent/tck/TreeSetTest.java b/ojluni/src/test/java/util/concurrent/tck/TreeSetTest.java
index 9f40007e20b..ce2c623e028 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TreeSetTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TreeSetTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Collection;
@@ -44,16 +53,21 @@ import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TreeSetTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(TreeSetTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TreeSetTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TreeSetTest.class);
+    // }
 
     static class MyReverseComparator implements Comparator {
         public int compare(Object x, Object y) {
@@ -100,6 +114,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * A new set has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, new TreeSet().size());
     }
@@ -107,6 +122,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Initializing from null Collection throws NPE
      */
+    @Test
     public void testConstructor3() {
         try {
             new TreeSet((Collection)null);
@@ -117,6 +133,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Initializing from Collection of null elements throws NPE
      */
+    @Test
     public void testConstructor4() {
         try {
             new TreeSet(Arrays.asList(new Integer[SIZE]));
@@ -127,6 +144,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Initializing from Collection with some null elements throws NPE
      */
+    @Test
     public void testConstructor5() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE - 1; ++i)
@@ -140,6 +158,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of collection used to initialize
      */
+    @Test
     public void testConstructor6() {
         Integer[] ints = new Integer[SIZE];
         for (int i = 0; i < SIZE; ++i)
@@ -152,6 +171,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * The comparator used in constructor is used
      */
+    @Test
     public void testConstructor7() {
         MyReverseComparator cmp = new MyReverseComparator();
         TreeSet q = new TreeSet(cmp);
@@ -167,6 +187,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         TreeSet q = new TreeSet();
         assertTrue(q.isEmpty());
@@ -181,6 +202,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         TreeSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -196,6 +218,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * add(null) throws NPE if nonempty
      */
+    @Test
     public void testAddNull() {
         TreeSet q = populatedSet(SIZE);
         try {
@@ -207,6 +230,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testAdd() {
         TreeSet q = new TreeSet();
         assertTrue(q.add(zero));
@@ -216,6 +240,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testAddDup() {
         TreeSet q = new TreeSet();
         assertTrue(q.add(zero));
@@ -225,6 +250,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testAddNonComparable() {
         TreeSet q = new TreeSet();
         try {
@@ -237,6 +263,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         TreeSet q = new TreeSet();
         try {
@@ -248,6 +275,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         TreeSet q = new TreeSet();
         Integer[] ints = new Integer[SIZE];
@@ -261,6 +289,7 @@ public class TreeSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         TreeSet q = new TreeSet();
         Integer[] ints = new Integer[SIZE];
@@ -275,6 +304,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -290,6 +320,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * pollFirst succeeds unless empty
      */
+    @Test
     public void testPollFirst() {
         TreeSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -301,6 +332,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * pollLast succeeds unless empty
      */
+    @Test
     public void testPollLast() {
         TreeSet q = populatedSet(SIZE);
         for (int i = SIZE - 1; i >= 0; --i) {
@@ -312,6 +344,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         TreeSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -333,6 +366,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         TreeSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -345,6 +379,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         TreeSet q = populatedSet(SIZE);
         q.clear();
@@ -359,6 +394,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         TreeSet q = populatedSet(SIZE);
         TreeSet p = new TreeSet();
@@ -373,6 +409,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         TreeSet q = populatedSet(SIZE);
         TreeSet p = populatedSet(SIZE);
@@ -392,6 +429,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             TreeSet q = populatedSet(SIZE);
@@ -408,6 +446,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testLower() {
         TreeSet q = set5();
         Object e1 = q.lower(three);
@@ -426,6 +465,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testHigher() {
         TreeSet q = set5();
         Object e1 = q.higher(three);
@@ -444,6 +484,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testFloor() {
         TreeSet q = set5();
         Object e1 = q.floor(three);
@@ -462,6 +503,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testCeiling() {
         TreeSet q = set5();
         Object e1 = q.ceiling(three);
@@ -480,6 +522,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements in sorted order
      */
+    @Test
     public void testToArray() {
         TreeSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -490,6 +533,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in sorted order
      */
+    @Test
     public void testToArray2() {
         TreeSet<Integer> q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -502,6 +546,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         TreeSet q = populatedSet(SIZE);
         Iterator it = q.iterator();
@@ -515,6 +560,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(new TreeSet().iterator());
     }
@@ -522,6 +568,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final TreeSet q = new TreeSet();
         q.add(new Integer(2));
@@ -541,6 +588,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         TreeSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -552,6 +600,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableSet x = populatedSet(SIZE);
         NavigableSet y = serialClone(x);
@@ -570,6 +619,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testSubSetContents() {
         TreeSet set = set5();
         SortedSet sm = set.subSet(two, four);
@@ -601,6 +651,7 @@ public class TreeSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testSubSetContents2() {
         TreeSet set = set5();
         SortedSet sm = set.subSet(two, three);
@@ -631,6 +682,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testHeadSetContents() {
         TreeSet set = set5();
         SortedSet sm = set.headSet(four);
@@ -657,6 +709,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testTailSetContents() {
         TreeSet set = set5();
         SortedSet sm = set.tailSet(two);
@@ -692,6 +745,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * Subsets of subsets subdivide correctly
      */
+    @Test
     public void testRecursiveSubSets() throws Exception {
         int setSize = expensiveTests ? 1000 : 100;
         Class cl = TreeSet.class;
@@ -714,6 +768,7 @@ public class TreeSetTest extends JSR166TestCase {
     /**
      * addAll is idempotent
      */
+    @Test
     public void testAddAll_idempotent() throws Exception {
         Set x = populatedSet(SIZE);
         Set y = new TreeSet(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/TreeSubMapTest.java b/ojluni/src/test/java/util/concurrent/tck/TreeSubMapTest.java
index 77ff558051a..b3f97baeebb 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TreeSubMapTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TreeSubMapTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -42,16 +51,21 @@ import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TreeSubMapTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(TreeSubMapTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TreeSubMapTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TreeSubMapTest.class);
+    // }
 
     /**
      * Returns a new map from Integers 1-5 to Strings "A"-"E".
@@ -102,6 +116,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testClear() {
         NavigableMap map = map5();
         map.clear();
@@ -111,6 +126,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testEquals() {
         NavigableMap map1 = map5();
         NavigableMap map2 = map5();
@@ -124,6 +140,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testContainsKey() {
         NavigableMap map = map5();
         assertTrue(map.containsKey(one));
@@ -133,6 +150,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testContainsValue() {
         NavigableMap map = map5();
         assertTrue(map.containsValue("A"));
@@ -143,6 +161,7 @@ public class TreeSubMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testGet() {
         NavigableMap map = map5();
         assertEquals("A", (String)map.get(one));
@@ -153,6 +172,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testIsEmpty() {
         NavigableMap empty = map0();
         NavigableMap map = map5();
@@ -163,6 +183,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testFirstKey() {
         NavigableMap map = map5();
         assertEquals(one, map.firstKey());
@@ -171,6 +192,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testLastKey() {
         NavigableMap map = map5();
         assertEquals(five, map.lastKey());
@@ -179,6 +201,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testKeySet() {
         NavigableMap map = map5();
         Set s = map.keySet();
@@ -193,6 +216,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testKeySetOrder() {
         NavigableMap map = map5();
         Set s = map.keySet();
@@ -209,6 +233,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testValues() {
         NavigableMap map = map5();
         Collection s = map.values();
@@ -223,6 +248,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testEntrySet() {
         NavigableMap map = map5();
         Set s = map.entrySet();
@@ -242,6 +268,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testPutAll() {
         NavigableMap empty = map0();
         NavigableMap map = map5();
@@ -257,6 +284,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testRemove() {
         NavigableMap map = map5();
         map.remove(five);
@@ -267,6 +295,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testLowerEntry() {
         NavigableMap map = map5();
         Map.Entry e1 = map.lowerEntry(three);
@@ -285,6 +314,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testHigherEntry() {
         NavigableMap map = map5();
         Map.Entry e1 = map.higherEntry(three);
@@ -303,6 +333,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testFloorEntry() {
         NavigableMap map = map5();
         Map.Entry e1 = map.floorEntry(three);
@@ -321,6 +352,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testCeilingEntry() {
         NavigableMap map = map5();
         Map.Entry e1 = map.ceilingEntry(three);
@@ -339,6 +371,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testPollFirstEntry() {
         NavigableMap map = map5();
         Map.Entry e = map.pollFirstEntry();
@@ -369,6 +402,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testPollLastEntry() {
         NavigableMap map = map5();
         Map.Entry e = map.pollLastEntry();
@@ -396,6 +430,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testSize() {
         NavigableMap map = map5();
         NavigableMap empty = map0();
@@ -406,6 +441,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testToString() {
         NavigableMap map = map5();
         String s = map.toString();
@@ -419,6 +455,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * get(null) of nonempty map throws NPE
      */
+    @Test
     public void testGet_NullPointerException() {
         NavigableMap c = map5();
         try {
@@ -430,6 +467,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * containsKey(null) of nonempty map throws NPE
      */
+    @Test
     public void testContainsKey_NullPointerException() {
         NavigableMap c = map5();
         try {
@@ -441,6 +479,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testPut1_NullPointerException() {
         NavigableMap c = map5();
         try {
@@ -452,6 +491,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * remove(null) throws NPE
      */
+    @Test
     public void testRemove1_NullPointerException() {
         NavigableMap c = map5();
         try {
@@ -463,6 +503,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableMap x = map5();
         NavigableMap y = serialClone(x);
@@ -477,6 +518,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testSubMapContents() {
         NavigableMap map = map5();
         SortedMap sm = map.subMap(two, four);
@@ -508,6 +550,7 @@ public class TreeSubMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testSubMapContents2() {
         NavigableMap map = map5();
         SortedMap sm = map.subMap(two, three);
@@ -538,6 +581,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testHeadMapContents() {
         NavigableMap map = map5();
         SortedMap sm = map.headMap(four);
@@ -564,6 +608,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testTailMapContents() {
         NavigableMap map = map5();
         SortedMap sm = map.tailMap(two);
@@ -612,6 +657,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * clear removes all pairs
      */
+    @Test
     public void testDescendingClear() {
         NavigableMap map = dmap5();
         map.clear();
@@ -621,6 +667,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * Maps with same contents are equal
      */
+    @Test
     public void testDescendingEquals() {
         NavigableMap map1 = dmap5();
         NavigableMap map2 = dmap5();
@@ -634,6 +681,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * containsKey returns true for contained key
      */
+    @Test
     public void testDescendingContainsKey() {
         NavigableMap map = dmap5();
         assertTrue(map.containsKey(m1));
@@ -643,6 +691,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * containsValue returns true for held values
      */
+    @Test
     public void testDescendingContainsValue() {
         NavigableMap map = dmap5();
         assertTrue(map.containsValue("A"));
@@ -653,6 +702,7 @@ public class TreeSubMapTest extends JSR166TestCase {
      * get returns the correct element at the given key,
      * or null if not present
      */
+    @Test
     public void testDescendingGet() {
         NavigableMap map = dmap5();
         assertEquals("A", (String)map.get(m1));
@@ -663,6 +713,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * isEmpty is true of empty map and false for non-empty
      */
+    @Test
     public void testDescendingIsEmpty() {
         NavigableMap empty = dmap0();
         NavigableMap map = dmap5();
@@ -673,6 +724,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * firstKey returns first key
      */
+    @Test
     public void testDescendingFirstKey() {
         NavigableMap map = dmap5();
         assertEquals(m1, map.firstKey());
@@ -681,6 +733,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * lastKey returns last key
      */
+    @Test
     public void testDescendingLastKey() {
         NavigableMap map = dmap5();
         assertEquals(m5, map.lastKey());
@@ -689,6 +742,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * keySet returns a Set containing all the keys
      */
+    @Test
     public void testDescendingKeySet() {
         NavigableMap map = dmap5();
         Set s = map.keySet();
@@ -703,6 +757,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * keySet is ordered
      */
+    @Test
     public void testDescendingKeySetOrder() {
         NavigableMap map = dmap5();
         Set s = map.keySet();
@@ -719,6 +774,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * values collection contains all values
      */
+    @Test
     public void testDescendingValues() {
         NavigableMap map = dmap5();
         Collection s = map.values();
@@ -733,6 +789,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * keySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingAscendingKeySetToArray() {
         NavigableMap map = dmap5();
         Set s = map.keySet();
@@ -746,6 +803,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * descendingkeySet.toArray returns contains all keys
      */
+    @Test
     public void testDescendingDescendingKeySetToArray() {
         NavigableMap map = dmap5();
         Set s = map.descendingKeySet();
@@ -759,6 +817,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * Values.toArray contains all values
      */
+    @Test
     public void testDescendingValuesToArray() {
         NavigableMap map = dmap5();
         Collection v = map.values();
@@ -775,6 +834,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * entrySet contains all pairs
      */
+    @Test
     public void testDescendingEntrySet() {
         NavigableMap map = dmap5();
         Set s = map.entrySet();
@@ -794,6 +854,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * putAll adds all key-value pairs from the given map
      */
+    @Test
     public void testDescendingPutAll() {
         NavigableMap empty = dmap0();
         NavigableMap map = dmap5();
@@ -809,6 +870,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * remove removes the correct key-value pair from the map
      */
+    @Test
     public void testDescendingRemove() {
         NavigableMap map = dmap5();
         map.remove(m5);
@@ -819,6 +881,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * lowerEntry returns preceding entry.
      */
+    @Test
     public void testDescendingLowerEntry() {
         NavigableMap map = dmap5();
         Map.Entry e1 = map.lowerEntry(m3);
@@ -837,6 +900,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * higherEntry returns next entry.
      */
+    @Test
     public void testDescendingHigherEntry() {
         NavigableMap map = dmap5();
         Map.Entry e1 = map.higherEntry(m3);
@@ -855,6 +919,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * floorEntry returns preceding entry.
      */
+    @Test
     public void testDescendingFloorEntry() {
         NavigableMap map = dmap5();
         Map.Entry e1 = map.floorEntry(m3);
@@ -873,6 +938,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * ceilingEntry returns next entry.
      */
+    @Test
     public void testDescendingCeilingEntry() {
         NavigableMap map = dmap5();
         Map.Entry e1 = map.ceilingEntry(m3);
@@ -891,6 +957,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * pollFirstEntry returns entries in order
      */
+    @Test
     public void testDescendingPollFirstEntry() {
         NavigableMap map = dmap5();
         Map.Entry e = map.pollFirstEntry();
@@ -918,6 +985,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * pollLastEntry returns entries in order
      */
+    @Test
     public void testDescendingPollLastEntry() {
         NavigableMap map = dmap5();
         Map.Entry e = map.pollLastEntry();
@@ -945,6 +1013,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * size returns the correct values
      */
+    @Test
     public void testDescendingSize() {
         NavigableMap map = dmap5();
         NavigableMap empty = dmap0();
@@ -955,6 +1024,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * toString contains toString of elements
      */
+    @Test
     public void testDescendingToString() {
         NavigableMap map = dmap5();
         String s = map.toString();
@@ -968,6 +1038,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * get(null) of nonempty map throws NPE
      */
+    @Test
     public void testDescendingGet_NullPointerException() {
         NavigableMap c = dmap5();
         try {
@@ -979,6 +1050,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * put(null,x) throws NPE
      */
+    @Test
     public void testDescendingPut1_NullPointerException() {
         NavigableMap c = dmap5();
         try {
@@ -990,6 +1062,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * A deserialized map equals original
      */
+    @Test
     public void testDescendingSerialization() throws Exception {
         NavigableMap x = dmap5();
         NavigableMap y = serialClone(x);
@@ -1004,6 +1077,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * subMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingSubMapContents() {
         NavigableMap map = dmap5();
         SortedMap sm = map.subMap(m2, m4);
@@ -1035,6 +1109,7 @@ public class TreeSubMapTest extends JSR166TestCase {
         assertEquals(3, map.size());
     }
 
+    @Test
     public void testDescendingSubMapContents2() {
         NavigableMap map = dmap5();
         SortedMap sm = map.subMap(m2, m3);
@@ -1065,6 +1140,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingHeadMapContents() {
         NavigableMap map = dmap5();
         SortedMap sm = map.headMap(m4);
@@ -1091,6 +1167,7 @@ public class TreeSubMapTest extends JSR166TestCase {
     /**
      * headMap returns map with keys in requested range
      */
+    @Test
     public void testDescendingTailMapContents() {
         NavigableMap map = dmap5();
         SortedMap sm = map.tailMap(m2);
diff --git a/ojluni/src/test/java/util/concurrent/tck/TreeSubSetTest.java b/ojluni/src/test/java/util/concurrent/tck/TreeSubSetTest.java
index 8b4dddff481..0554227cf65 100644
--- a/ojluni/src/test/java/util/concurrent/tck/TreeSubSetTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/TreeSubSetTest.java
@@ -32,6 +32,15 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -40,16 +49,21 @@ import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class TreeSubSetTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
-    }
-    public static Test suite() {
-        return new TestSuite(TreeSubSetTest.class);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.TreeSubSetTest");
     }
+    // public static Test suite() {
+    //     return new TestSuite(TreeSubSetTest.class);
+    // }
 
     static class MyReverseComparator implements Comparator {
         public int compare(Object x, Object y) {
@@ -123,6 +137,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * A new set has unbounded capacity
      */
+    @Test
     public void testConstructor1() {
         assertEquals(0, set0().size());
     }
@@ -130,6 +145,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * isEmpty is true before add, false after
      */
+    @Test
     public void testEmpty() {
         NavigableSet q = set0();
         assertTrue(q.isEmpty());
@@ -144,6 +160,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testSize() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -159,6 +176,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * add(null) throws NPE
      */
+    @Test
     public void testAddNull() {
         NavigableSet q = set0();
         try {
@@ -170,6 +188,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testAdd() {
         NavigableSet q = set0();
         assertTrue(q.add(six));
@@ -178,6 +197,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testAddDup() {
         NavigableSet q = set0();
         assertTrue(q.add(six));
@@ -187,6 +207,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testAddNonComparable() {
         NavigableSet q = set0();
         try {
@@ -199,6 +220,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testAddAll1() {
         NavigableSet q = set0();
         try {
@@ -210,6 +232,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testAddAll2() {
         NavigableSet q = set0();
         Integer[] ints = new Integer[SIZE];
@@ -223,6 +246,7 @@ public class TreeSubSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testAddAll3() {
         NavigableSet q = set0();
         Integer[] ints = new Integer[SIZE];
@@ -237,6 +261,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -252,6 +277,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testPoll() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -263,6 +289,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testRemoveElement() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -284,6 +311,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testContains() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -296,6 +324,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testClear() {
         NavigableSet q = populatedSet(SIZE);
         q.clear();
@@ -310,6 +339,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testContainsAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = set0();
@@ -324,6 +354,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testRetainAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = populatedSet(SIZE);
@@ -343,6 +374,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             NavigableSet q = populatedSet(SIZE);
@@ -359,6 +391,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testLower() {
         NavigableSet q = set5();
         Object e1 = q.lower(three);
@@ -377,6 +410,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testHigher() {
         NavigableSet q = set5();
         Object e1 = q.higher(three);
@@ -395,6 +429,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testFloor() {
         NavigableSet q = set5();
         Object e1 = q.floor(three);
@@ -413,6 +448,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testCeiling() {
         NavigableSet q = set5();
         Object e1 = q.ceiling(three);
@@ -431,6 +467,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements in sorted order
      */
+    @Test
     public void testToArray() {
         NavigableSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -441,6 +478,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements in sorted order
      */
+    @Test
     public void testToArray2() {
         NavigableSet<Integer> q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -453,6 +491,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testIterator() {
         NavigableSet q = populatedSet(SIZE);
         Iterator it = q.iterator();
@@ -466,6 +505,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testEmptyIterator() {
         assertIteratorExhausted(set0().iterator());
     }
@@ -473,6 +513,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testIteratorRemove() {
         final NavigableSet q = set0();
         q.add(new Integer(2));
@@ -492,6 +533,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testToString() {
         NavigableSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -503,6 +545,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testSerialization() throws Exception {
         NavigableSet x = populatedSet(SIZE);
         NavigableSet y = serialClone(x);
@@ -521,6 +564,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testSubSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.subSet(two, four);
@@ -552,6 +596,7 @@ public class TreeSubSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testSubSetContents2() {
         NavigableSet set = set5();
         SortedSet sm = set.subSet(two, three);
@@ -582,6 +627,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testHeadSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.headSet(four);
@@ -608,6 +654,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testTailSetContents() {
         NavigableSet set = set5();
         SortedSet sm = set.tailSet(two);
@@ -640,6 +687,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * size changes when elements added and removed
      */
+    @Test
     public void testDescendingSize() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -655,6 +703,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of comparable element succeeds
      */
+    @Test
     public void testDescendingAdd() {
         NavigableSet q = dset0();
         assertTrue(q.add(m6));
@@ -663,6 +712,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of duplicate element fails
      */
+    @Test
     public void testDescendingAddDup() {
         NavigableSet q = dset0();
         assertTrue(q.add(m6));
@@ -672,6 +722,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Add of non-Comparable throws CCE
      */
+    @Test
     public void testDescendingAddNonComparable() {
         NavigableSet q = dset0();
         try {
@@ -684,6 +735,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * addAll(null) throws NPE
      */
+    @Test
     public void testDescendingAddAll1() {
         NavigableSet q = dset0();
         try {
@@ -695,6 +747,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * addAll of a collection with null elements throws NPE
      */
+    @Test
     public void testDescendingAddAll2() {
         NavigableSet q = dset0();
         Integer[] ints = new Integer[SIZE];
@@ -708,6 +761,7 @@ public class TreeSubSetTest extends JSR166TestCase {
      * addAll of a collection with any null elements throws NPE after
      * possibly adding some elements
      */
+    @Test
     public void testDescendingAddAll3() {
         NavigableSet q = dset0();
         Integer[] ints = new Integer[SIZE];
@@ -722,6 +776,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * Set contains all elements of successful addAll
      */
+    @Test
     public void testDescendingAddAll5() {
         Integer[] empty = new Integer[0];
         Integer[] ints = new Integer[SIZE];
@@ -737,6 +792,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * poll succeeds unless empty
      */
+    @Test
     public void testDescendingPoll() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -748,6 +804,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * remove(x) removes x and returns true if present
      */
+    @Test
     public void testDescendingRemoveElement() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 1; i < SIZE; i += 2) {
@@ -763,6 +820,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * contains(x) reports true when elements added but not yet removed
      */
+    @Test
     public void testDescendingContains() {
         NavigableSet q = populatedSet(SIZE);
         for (int i = 0; i < SIZE; ++i) {
@@ -775,6 +833,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * clear removes all elements
      */
+    @Test
     public void testDescendingClear() {
         NavigableSet q = populatedSet(SIZE);
         q.clear();
@@ -789,6 +848,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * containsAll(c) is true when c contains a subset of elements
      */
+    @Test
     public void testDescendingContainsAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = dset0();
@@ -803,6 +863,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * retainAll(c) retains only those elements of c and reports true if changed
      */
+    @Test
     public void testDescendingRetainAll() {
         NavigableSet q = populatedSet(SIZE);
         NavigableSet p = populatedSet(SIZE);
@@ -822,6 +883,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * removeAll(c) removes only those elements of c and reports true if changed
      */
+    @Test
     public void testDescendingRemoveAll() {
         for (int i = 1; i < SIZE; ++i) {
             NavigableSet q = populatedSet(SIZE);
@@ -838,6 +900,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * lower returns preceding element
      */
+    @Test
     public void testDescendingLower() {
         NavigableSet q = dset5();
         Object e1 = q.lower(m3);
@@ -856,6 +919,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * higher returns next element
      */
+    @Test
     public void testDescendingHigher() {
         NavigableSet q = dset5();
         Object e1 = q.higher(m3);
@@ -874,6 +938,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * floor returns preceding element
      */
+    @Test
     public void testDescendingFloor() {
         NavigableSet q = dset5();
         Object e1 = q.floor(m3);
@@ -892,6 +957,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * ceiling returns next element
      */
+    @Test
     public void testDescendingCeiling() {
         NavigableSet q = dset5();
         Object e1 = q.ceiling(m3);
@@ -910,6 +976,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toArray contains all elements
      */
+    @Test
     public void testDescendingToArray() {
         NavigableSet q = populatedSet(SIZE);
         Object[] o = q.toArray();
@@ -921,6 +988,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toArray(a) contains all elements
      */
+    @Test
     public void testDescendingToArray2() {
         NavigableSet q = populatedSet(SIZE);
         Integer[] ints = new Integer[SIZE];
@@ -933,6 +1001,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator iterates through all elements
      */
+    @Test
     public void testDescendingIterator() {
         NavigableSet q = populatedSet(SIZE);
         int i = 0;
@@ -947,6 +1016,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator of empty set has no elements
      */
+    @Test
     public void testDescendingEmptyIterator() {
         NavigableSet q = dset0();
         int i = 0;
@@ -961,6 +1031,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * iterator.remove removes current element
      */
+    @Test
     public void testDescendingIteratorRemove() {
         final NavigableSet q = dset0();
         q.add(new Integer(2));
@@ -980,6 +1051,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * toString contains toStrings of elements
      */
+    @Test
     public void testDescendingToString() {
         NavigableSet q = populatedSet(SIZE);
         String s = q.toString();
@@ -991,6 +1063,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * A deserialized serialized set has same elements
      */
+    @Test
     public void testDescendingSerialization() throws Exception {
         NavigableSet x = dset5();
         NavigableSet y = serialClone(x);
@@ -1010,6 +1083,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * subSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingSubSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.subSet(m2, m4);
@@ -1041,6 +1115,7 @@ public class TreeSubSetTest extends JSR166TestCase {
         assertEquals(3, set.size());
     }
 
+    @Test
     public void testDescendingSubSetContents2() {
         NavigableSet set = dset5();
         SortedSet sm = set.subSet(m2, m3);
@@ -1071,6 +1146,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * headSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingHeadSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.headSet(m4);
@@ -1097,6 +1173,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * tailSet returns set with keys in requested range
      */
+    @Test
     public void testDescendingTailSetContents() {
         NavigableSet set = dset5();
         SortedSet sm = set.tailSet(m2);
@@ -1129,6 +1206,7 @@ public class TreeSubSetTest extends JSR166TestCase {
     /**
      * addAll is idempotent
      */
+    @Test
     public void testAddAll_idempotent() throws Exception {
         Set x = populatedSet(SIZE);
         Set y = new TreeSet(x);
diff --git a/ojluni/src/test/java/util/concurrent/tck/VectorTest.java b/ojluni/src/test/java/util/concurrent/tck/VectorTest.java
index 4100843bfcf..8b3e8dc096b 100644
--- a/ojluni/src/test/java/util/concurrent/tck/VectorTest.java
+++ b/ojluni/src/test/java/util/concurrent/tck/VectorTest.java
@@ -33,40 +33,55 @@
  */
 
 package test.java.util.concurrent.tck;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.util.Vector;
 import java.util.Collection;
 import java.util.List;
 
-import junit.framework.Test;
-import junit.framework.TestSuite;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+// Android-changed: Use JUnit4.
+@RunWith(JUnit4.class)
 public class VectorTest extends JSR166TestCase {
+    // Android-changed: Use JUnitCore.main.
     public static void main(String[] args) {
-        main(suite(), args);
+        // main(suite(), args);
+        org.junit.runner.JUnitCore.main("test.java.util.concurrent.tck.VectorTest");
     }
 
-    public static Test suite() {
-        class Implementation implements CollectionImplementation {
-            public Class<?> klazz() { return Vector.class; }
-            public List emptyCollection() { return new Vector(); }
-            public Object makeElement(int i) { return i; }
-            public boolean isConcurrent() { return false; }
-            public boolean permitsNulls() { return true; }
-        }
-        class SubListImplementation extends Implementation {
-            public List emptyCollection() {
-                return super.emptyCollection().subList(0, 0);
-            }
-        }
-        return newTestSuite(
-                VectorTest.class,
-                CollectionTest.testSuite(new Implementation()),
-                CollectionTest.testSuite(new SubListImplementation()));
-    }
+    // public static Test suite() {
+    //     class Implementation implements CollectionImplementation {
+    //         public Class<?> klazz() { return Vector.class; }
+    //         public List emptyCollection() { return new Vector(); }
+    //         public Object makeElement(int i) { return i; }
+    //         public boolean isConcurrent() { return false; }
+    //         public boolean permitsNulls() { return true; }
+    //     }
+    //     class SubListImplementation extends Implementation {
+    //         public List emptyCollection() {
+    //             return super.emptyCollection().subList(0, 0);
+    //         }
+    //     }
+    //     return newTestSuite(
+    //             VectorTest.class,
+    //             CollectionTest.testSuite(new Implementation()),
+    //             CollectionTest.testSuite(new SubListImplementation()));
+    // }
 
     /**
      * tests for setSize()
      */
+    @Test
     public void testSetSize() {
         final Vector v = new Vector();
         for (int n : new int[] { 100, 5, 50 }) {
diff --git a/ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java b/ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java
new file mode 100644
index 00000000000..d151ca6ee93
--- /dev/null
+++ b/ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8024500
+ * @run testng BiFunctionTest
+ */
+
+package test.java.util.function.BiFunction;
+
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+
+@Test(groups = "unit")
+public class BiFunctionTest {
+    static class Quote {
+        double unit_price;
+
+        Quote(double price) {
+            unit_price = price;
+        }
+    };
+
+    static class Order {
+        int quantity;
+
+        Order(int quantity) {
+            this.quantity = quantity;
+        }
+    };
+
+    BiFunction<Quote, Order, Double> estimate = (quote, order) -> {
+        if (quote.unit_price < 0) {
+            throw new IllegalArgumentException("quote");
+        }
+
+        if (order.quantity < 0) {
+            throw new IllegalArgumentException("order");
+        }
+
+        return quote.unit_price * order.quantity;
+    };
+
+    Function<Double, Long> creditcheck = total -> {
+        if (total > 100.00) {
+            throw new RuntimeException("overlimit");
+        }
+        return total.longValue();
+    };
+
+    public void testAndThen() {
+        try {
+            BiFunction<Quote, Order, Long> checkout = estimate.andThen(null);
+            fail("Null argument should throw NPE");
+        } catch (NullPointerException npe) {
+            // ignore
+        }
+
+        BiFunction<Quote, Order, Long> checkout = estimate.andThen(creditcheck);
+        try {
+            checkout.apply(new Quote(20.0), new Order(-1));
+            fail("First function delivers exception");
+        } catch (IllegalArgumentException e) {
+            assertEquals(e.getMessage(), "order");
+        }
+
+        try {
+            checkout.apply(new Quote(20.0), new Order(10));
+            fail("Second function delivers exception");
+        } catch (RuntimeException e) {
+            assertEquals(e.getMessage(), "overlimit");
+        }
+
+        assertEquals(49, checkout.apply(new Quote(24.99), new Order(2)).longValue());
+        assertEquals(50, checkout.apply(new Quote(25), new Order(2)).longValue());
+    }
+}
diff --git a/ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java b/ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java
new file mode 100644
index 00000000000..dfe1ad2560b
--- /dev/null
+++ b/ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8009736 8010279
+ * @run testng BasicTest
+ */
+
+package test.java.util.function.BinaryOperator;
+
+import java.util.Comparator;
+import java.util.function.BinaryOperator;
+import java.util.function.Function;
+import java.util.function.ToIntFunction;
+import org.testng.annotations.Test;
+
+
+import static java.util.function.BinaryOperator.minBy;
+import static java.util.function.BinaryOperator.maxBy;
+import static org.testng.Assert.assertSame;
+import static org.testng.Assert.fail;
+
+/**
+ * Unit tests for helper methods in Comparators
+ */
+@Test(groups = "unit")
+public class BasicTest {
+
+    private static class People {
+        final String firstName;
+        final String lastName;
+        final int age;
+
+        People(String first, String last, int age) {
+            firstName = first;
+            lastName = last;
+            this.age = age;
+        }
+
+        String getFirstName() { return firstName; }
+        String getLastName() { return lastName; }
+        int getAge() { return age; }
+    }
+
+    private final People people[] = {
+        new People("John", "Doe", 34),
+        new People("Mary", "Doe", 30),
+    };
+
+    public void testMaxBy() {
+        Comparator<People> cmp = Comparator.comparing(People::getFirstName);
+        // lesser
+        assertSame(maxBy(cmp).apply(people[0], people[1]), people[1]);
+        // euqal
+        cmp = Comparator.comparing(People::getLastName);
+        assertSame(maxBy(cmp).apply(people[0], people[1]), people[0]);
+        // greater
+        cmp = Comparator.comparingInt(People::getAge);
+        assertSame(maxBy(cmp).apply(people[0], people[1]), people[0]);
+    }
+
+    public void testMinBy() {
+        Comparator<People> cmp = Comparator.comparing(People::getFirstName);
+        // lesser
+        assertSame(minBy(cmp).apply(people[0], people[1]), people[0]);
+        // euqal
+        cmp = Comparator.comparing(People::getLastName);
+        assertSame(minBy(cmp).apply(people[0], people[1]), people[0]);
+        // greater
+        cmp = Comparator.comparingInt(People::getAge);
+        assertSame(minBy(cmp).apply(people[0], people[1]), people[1]);
+    }
+
+    public void testNulls() {
+        try {
+            BinaryOperator<String> op = minBy(null);
+            fail("minBy(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+
+        try {
+            BinaryOperator<String> op = maxBy(null);
+            fail("maxBy(null) should throw NPE");
+        } catch (NullPointerException npe) {}
+    }
+}
diff --git a/ojluni/src/test/java/util/function/PredicateNotTest.java b/ojluni/src/test/java/util/function/PredicateNotTest.java
index fd1fb59dfb2..0920cdcfb7f 100644
--- a/ojluni/src/test/java/util/function/PredicateNotTest.java
+++ b/ojluni/src/test/java/util/function/PredicateNotTest.java
@@ -41,6 +41,7 @@ import static java.util.stream.Collectors.joining;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.fail;
 
+@Test(groups = "unit")
 public class PredicateNotTest {
     // BEGIN Android-added
     // MethodHandle for invoking Predicate.not() to prevent d8 inserting it's backported
@@ -73,7 +74,6 @@ public class PredicateNotTest {
         }
     }
 
-    @Test
     public void test() {
         List<String> test = List.of(
            "A non-empty line",
diff --git a/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java b/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
index cb612c62f49..9ff7812f414 100644
--- a/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
+++ b/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,6 +34,7 @@ import org.openjdk.testlib.java.util.stream.TestData.Factory;
 
 import java.util.List;
 import java.util.Objects;
+import java.util.stream.Collector;
 import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
@@ -98,4 +99,21 @@ public class IterateTest extends OpTestCase {
         checkNPE(() -> DoubleStream.iterate(0, null, x -> x + 1));
         checkNPE(() -> DoubleStream.iterate(0, x -> x < 10, null));
     }
+
+    @Test
+    public void testParallelize() {
+        checkHasSplit(Stream.iterate(0, x -> x < 10, x -> x + 1));
+        checkHasSplit(IntStream.iterate(0, x -> x < 10, x -> x + 1).boxed());
+        checkHasSplit(LongStream.iterate(0, x -> x < 10, x -> x + 1).boxed());
+        checkHasSplit(DoubleStream.iterate(0, x -> x < 10, x -> x + 1).boxed());
+    }
+
+    private void checkHasSplit(Stream<?> stream) {
+        int[] numberOfNonEmptyParts = stream.parallel().collect(
+                Collector.of(() -> new int[1], (acc, e) -> acc[0] = 1, (acc1, acc2) -> {
+                  acc1[0] += acc2[0];
+                  return acc1;
+                }));
+        assertTrue(numberOfNonEmptyParts[0] >= 2);
+    }
 }
diff --git a/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java b/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
index e3e2ac04a04..2926d75cd66 100644
--- a/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
+++ b/ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -70,8 +70,8 @@ public class SpliteratorTest {
     /*
     @Test(dataProvider = "SegmentSpliterator", dataProviderClass = SegmentTestDataProvider.class )
     public void testSegmentSpliterator(String name, SequenceLayout layout, SpliteratorTestHelper.ContentAsserter<MemorySegment> contentAsserter) {
-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);
+        try (Arena arena = Arena.ofConfined()) {
+            MemorySegment segment = arena.allocate(layout);
             SegmentTestDataProvider.initSegment(segment);
             SpliteratorTestHelper.testSpliterator(() -> segment.spliterator(layout),
                     SegmentTestDataProvider::segmentCopier, contentAsserter);
diff --git a/openjdk_java_files.bp b/openjdk_java_files.bp
index 848293c016c..8d28bf58de2 100644
--- a/openjdk_java_files.bp
+++ b/openjdk_java_files.bp
@@ -166,6 +166,7 @@ filegroup {
         "ojluni/src/main/java/java/lang/LiveStackFrameInfo.java",
         "ojluni/src/main/java/java/lang/Long.java",
         "ojluni/src/main/java/java/lang/Math.java",
+        "ojluni/src/main/java/java/lang/MatchException.java",
         "ojluni/src/main/java/java/lang/NegativeArraySizeException.java",
         "ojluni/src/main/java/java/lang/NoClassDefFoundError.java",
         "ojluni/src/main/java/java/lang/NoSuchFieldError.java",
@@ -221,6 +222,7 @@ filegroup {
         "ojluni/src/main/java/java/lang/ref/SoftReference.java",
         "ojluni/src/main/java/java/lang/ref/WeakReference.java",
         "ojluni/src/main/java/java/lang/ref/package-info.java",
+        "ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java",
         "ojluni/src/main/java/java/lang/runtime/ObjectMethods.java",
         "ojluni/src/main/java/java/lang/runtime/package-info.java",
         "ojluni/src/main/java/java/lang/Runnable.java",
@@ -1500,6 +1502,7 @@ filegroup {
         "ojluni/src/main/java/com/sun/nio/file/ExtendedWatchEventModifier.java",
         "ojluni/src/main/java/com/sun/nio/file/SensitivityWatchEventModifier.java",
         "ojluni/src/main/java/java/beans/ChangeListenerMap.java",
+        "ojluni/src/main/java/java/lang/BaseVirtualThread.java",
         "ojluni/src/main/java/java/lang/StringLatin1.java",
         "ojluni/src/main/java/java/lang/StringUTF16.java",
         // Hide the java.lang.constant APIs until master switches away from Android UDC. b/270028670
@@ -1536,15 +1539,22 @@ filegroup {
         "ojluni/src/main/java/jdk/net/Sockets.java",
         "ojluni/src/main/java/jdk/internal/HotSpotIntrinsicCandidate.java",
         "ojluni/src/main/java/jdk/internal/ValueBased.java",
-        "ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java",
         "ojluni/src/main/java/jdk/internal/access/JavaIOFileDescriptorAccess.java",
+        "ojluni/src/main/java/jdk/internal/access/JavaLangAccess.java",
         "ojluni/src/main/java/jdk/internal/access/JavaObjectInputStreamAccess.java",
+        "ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java",
         "ojluni/src/main/java/jdk/internal/access/SharedSecrets.java",
+        "ojluni/src/main/java/jdk/internal/event/Event.java",
+        "ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java",
+        "ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java",
+        "ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java",
+        "ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java",
         "ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java",
         "ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java",
         "ojluni/src/main/java/jdk/internal/misc/Unsafe.java",
         "ojluni/src/main/java/jdk/internal/misc/UnsafeConstants.java",
         "ojluni/src/main/java/jdk/internal/misc/VM.java",
+        "ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java",
         "ojluni/src/main/java/jdk/internal/ref/Cleaner.java",
         "ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java",
         "ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java",
@@ -1552,14 +1562,22 @@ filegroup {
         "ojluni/src/main/java/jdk/internal/reflect/CallerSensitive.java",
         "ojluni/src/main/java/jdk/internal/reflect/Reflection.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/Contended.java",
+        "ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/IntrinsicCandidate.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/ReservedStackAccess.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/Stable.java",
+        "ojluni/src/main/java/jdk/internal/vm/StackChunk.java",
         "ojluni/src/main/java/jdk/internal/util/ArraysSupport.java",
         "ojluni/src/main/java/jdk/internal/util/NullableKeyValueHolder.java",
         "ojluni/src/main/java/jdk/internal/util/Preconditions.java",
-        "ojluni/src/main/java/jdk/internal/util/jar/JarIndex.java",
+        "ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java",
+        "ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java",
+        "ojluni/src/main/java/jdk/internal/util/ReferenceKey.java",
+        "ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java",
         "ojluni/src/main/java/jdk/internal/util/StaticProperty.java",
+        "ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java",
+        "ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java",
+        "ojluni/src/main/java/jdk/internal/util/jar/JarIndex.java",
         "ojluni/src/main/java/jdk/random/L128X1024MixRandom.java",
         "ojluni/src/main/java/jdk/random/L128X128MixRandom.java",
         "ojluni/src/main/java/jdk/random/L128X256MixRandom.java",
diff --git a/toolchainapi/Android.bp b/toolchainapi/Android.bp
index 4b4db25069f..faf11ce1ee5 100644
--- a/toolchainapi/Android.bp
+++ b/toolchainapi/Android.bp
@@ -47,6 +47,16 @@ droidstubs {
             removed_api_file: "api/removed.txt",
         },
     },
+    libs: [
+        "framework-api-annotations-lib",
+        "libcore-aconfig-flags-lib",
+    ],
+    aconfig_declarations: [
+        "libcore-aconfig-flags",
+    ],
+    merge_inclusion_annotations_dirs: [
+        "toolchainapi-annotated-flagged-stubs",
+    ],
     // LambdaMetaFactory depends on CallSite etc. which are provided by
     // the system module art-module-intra-core-api-stubs-bootstrap-system-modules
     // via art.module.intra.core.api.stubs
diff --git a/tools/checkstyle/libcore-checkstyle.sh b/tools/checkstyle/libcore-checkstyle.sh
index 580c7be82f9..55d289d8ee3 100755
--- a/tools/checkstyle/libcore-checkstyle.sh
+++ b/tools/checkstyle/libcore-checkstyle.sh
@@ -59,6 +59,7 @@ declare -A PATH_TO_CONFIG=(
     [luni/src/test/java/tests/security]=tools/checkstyle/not-gpl.xml
     [luni/src/test/java/tests/support]=tools/checkstyle/aosp-copyright.xml
     [luni/src/test/java/tests/targets]=tools/checkstyle/aosp-copyright.xml
+    [luni/src/test/java21language]=tools/checkstyle/aosp-copyright.xml
     [luni/src/test/java17language]=tools/checkstyle/aosp-copyright.xml
     [luni/src/test/java11language]=tools/checkstyle/aosp-copyright.xml
     [luni/src/test/java9compatibility]=tools/checkstyle/aosp-copyright.xml
diff --git a/tools/checkstyle/openjdk-gplv2-copyright.pattern b/tools/checkstyle/openjdk-gplv2-copyright.pattern
index 03fffea89a9..05fc61f3a5b 100644
--- a/tools/checkstyle/openjdk-gplv2-copyright.pattern
+++ b/tools/checkstyle/openjdk-gplv2-copyright.pattern
@@ -1,6 +1,6 @@
 ^(/\*)?$
 /* Copyright.*(Android|Google|Red Hat|SAP SE|Azul Systems|Goldman Sachs).*
-[ /][*o] Copyright \(c\) \d\d\d\d,( ?\d\d\d\d,?)? Oracle and/or its affiliates\. All rights reserved\.
+[ /][*o] Copyright \(c\) \d\d\d\d,( ?\d\d\d\d,?)? Oracle( and/or its affiliates|, Inc)\. All rights reserved\.
  \* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER\.
  \*
  \* This code is free software; you can redistribute it and/or modify it
diff --git a/tools/checkstyle/openjdk-gplv2-plus-classpath-copyright.pattern b/tools/checkstyle/openjdk-gplv2-plus-classpath-copyright.pattern
index b73521a5dc4..0390b0d9431 100644
--- a/tools/checkstyle/openjdk-gplv2-plus-classpath-copyright.pattern
+++ b/tools/checkstyle/openjdk-gplv2-plus-classpath-copyright.pattern
@@ -1,6 +1,6 @@
 /\*.*
  \*.*Android.*
- \* Copyright \(c\) \d\d\d\d,( ?\d\d\d\d,?)? Oracle and/or its affiliates\. All rights reserved\.
+ \* Copyright \(c\) \d\d\d\d,( ?\d\d\d\d,?)? Oracle( and/or its affiliates|, Inc)\. All rights reserved\.
  \*.*(Android|Google|Red Hat|SAP SE|Azul Systems).*
  \*$
  \* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER\.
diff --git a/tools/expected_upstream/ojluni_merge_package.sh b/tools/expected_upstream/ojluni_merge_package.sh
index ac027f27597..1f8477d22fa 100755
--- a/tools/expected_upstream/ojluni_merge_package.sh
+++ b/tools/expected_upstream/ojluni_merge_package.sh
@@ -1,23 +1,21 @@
 #!/bin/bash
 
 SELF=$(basename "${0}")
-DEFAULT_TAG="jdk17u/jdk-17.0.6-ga"
+DEFAULT_TAG="jdk21u/jdk-21.0.2-ga"
 SUPPORTED_TAGS="jdk7u/jdk7u40-b60"
 SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk8u/jdk8u121-b13"
 SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk8u/jdk8u60-b31"
 SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk9/jdk-9+181"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk11u/jdk-11+28"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk11u/jdk-11.0.13-ga"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk17u/jdk-17.0.2-ga"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk17u/jdk-17.0.5-ga"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk17u/jdk-17.0.6-ga"
+SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk11u/jdk-11.0.22-ga"
+SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk17u/jdk-17.0.10-ga"
+SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk21u/jdk-21.0.2-ga"
 
 
 USAGE=$(cat << EndOfUsage
 Usage:
   ${SELF} [-b <bug_number>] [-t <upstream_tag>] <package_name> <package_name> ...
   For example:
-    ${SELF} -b 123456 -t jdk17u/jdk-17.0.6-ga java.util.concurrent java.util.concurrent.atomic
+    ${SELF} -b 123456 -t jdk21u/jdk-21.0.2-ga java.util.concurrent java.util.concurrent.atomic
     ${SELF} java.util.concurrent.atomic -c AtomicInteger,AtomicBoolean,AtomicLong
     ${SELF} java.util.concurrent.atomic -c AtomicInteger -c AtomicBoolean -c AtomicLong
 
diff --git a/tools/openjdk-analyzer/src/libcore/tools/analyzer/openjdk/DependencyAnalyzer.java b/tools/openjdk-analyzer/src/libcore/tools/analyzer/openjdk/DependencyAnalyzer.java
index 12fd8337747..c2a8a0cdab2 100644
--- a/tools/openjdk-analyzer/src/libcore/tools/analyzer/openjdk/DependencyAnalyzer.java
+++ b/tools/openjdk-analyzer/src/libcore/tools/analyzer/openjdk/DependencyAnalyzer.java
@@ -565,9 +565,9 @@ public class DependencyAnalyzer {
         /**
          * It contains mappings of classes and / or packages renamed in a new OpenJDK version.
          */
-        private static final Map<String, String> PREFIX_RENAMES = new HashMap<>() {{
-            put("sun/", "jdk/internal/");
-        }};
+        private static final Map<String, String> PREFIX_RENAMES = Map.of(
+                "sun/", "jdk/internal/"
+        );
 
         /**
          * Contains the dependency of a given class in the expected upstream version.
diff --git a/xml/src/main/java/com/android/org/kxml2/io/TEST_MAPPING b/xml/src/main/java/com/android/org/kxml2/io/TEST_MAPPING
index d8c9759faeb..9a71ddfd656 100644
--- a/xml/src/main/java/com/android/org/kxml2/io/TEST_MAPPING
+++ b/xml/src/main/java/com/android/org/kxml2/io/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_xml"
     }
   ]
 }
\ No newline at end of file
diff --git a/xml/src/main/java/org/xmlpull/v1/TEST_MAPPING b/xml/src/main/java/org/xmlpull/v1/TEST_MAPPING
index d8c9759faeb..9a71ddfd656 100644
--- a/xml/src/main/java/org/xmlpull/v1/TEST_MAPPING
+++ b/xml/src/main/java/org/xmlpull/v1/TEST_MAPPING
@@ -1,12 +1,7 @@
 {
   "presubmit": [
     {
-      "name": "CtsLibcoreTestCases",
-      "options": [
-        {
-          "include-filter": "libcore.xml"
-        }
-      ]
+      "name": "CtsLibcoreTestCases_javax_xml"
     }
   ]
 }
\ No newline at end of file
```

