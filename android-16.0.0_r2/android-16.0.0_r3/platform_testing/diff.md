```diff
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 000000000..e4132eaec
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,14 @@
+# Python
+__pycache__/
+*.pyc
+*.pyo
+*.pyd
+*.so
+*.egg-info/
+dist/
+build/
+wheels/
+*.egg
+*.manifest
+*.lib
+*.whl
\ No newline at end of file
diff --git a/Android.bp b/Android.bp
index 009f39083..e6e020af3 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
@@ -210,9 +226,609 @@ test_package {
         default: [],
     }),
 
+    dists: [
+        {
+            targets: ["platform_tests"],
+            prepend_artifact_with_product: true,
+            dest: "tests-FILE_NAME_TAG_PLACEHOLDER.zip",
+        },
+        {
+            targets: ["platform_tests"],
+            prepend_artifact_with_product: true,
+            dest: "platform_tests-symbols-FILE_NAME_TAG_PLACEHOLDER.zip",
+            tag: ".symbols",
+        },
+        {
+            targets: ["platform_tests"],
+            prepend_artifact_with_product: true,
+            dest: "platform_tests-symbols-mapping-FILE_NAME_TAG_PLACEHOLDER.textproto",
+            tag: ".elf_mapping",
+        },
+    ],
+}
+
+test_package {
+    name: "continuous_native_tests",
+    device_first_tests: [
+        "adbd_test",
+        "keystore2_test",
+        "lmkd_unit_test",
+    ] + select(soong_config_variable("perf", "board_perfsetup_script"), {
+        any: ["perf-setup"],
+        default: [],
+    }),
+
+    device_both_tests: [
+        "aaudio_test_mmap_path",
+        "android_logger_test_src_lib",
+        "android_logger_test_tests_config_log_level",
+        "android_logger_test_tests_default_init",
+        "android_logger_test_tests_multiple_init",
+        "anyhow_test_src_lib",
+        "anyhow_test_tests_test_autotrait",
+        "anyhow_test_tests_test_boxed",
+        "anyhow_test_tests_test_chain",
+        "anyhow_test_tests_test_context",
+        "anyhow_test_tests_test_convert",
+        "anyhow_test_tests_test_downcast",
+        "anyhow_test_tests_test_fmt",
+        "anyhow_test_tests_test_macros",
+        "anyhow_test_tests_test_repr",
+        "anyhow_test_tests_test_source",
+        "audio_health_tests",
+        "bionic-unit-tests",
+        "bionic-unit-tests-static",
+        "bluetooth_test_common",
+        "bootstat_tests",
+        "boringssl_crypto_test",
+        "boringssl_ssl_test",
+        "bsdiff_unittest",
+        "bugreportz_test",
+        "bytes_test_tests_test_buf",
+        "bytes_test_tests_test_buf_mut",
+        "bytes_test_tests_test_bytes",
+        "bytes_test_tests_test_bytes_odd_alloc",
+        "bytes_test_tests_test_bytes_vec_alloc",
+        "bytes_test_tests_test_chain",
+        "bytes_test_tests_test_debug",
+        "bytes_test_tests_test_iter",
+        "bytes_test_tests_test_reader",
+        "bytes_test_tests_test_take",
+        "camera_client_test",
+        "cesu8_test_src_lib",
+        "clatd_test",
+        "confirmationui_invocation_test",
+        "debuggerd_test",
+        "doh_ffi_test",
+        "doh_unit_test",
+        "dumpstate_test",
+        "dumpstate_test_fixture",
+        "dumpsys_test",
+        "gpuservice_unittest",
+        "gwp_asan_unittest",
+        "hello_world_test",
+        "hwui_unit_tests",
+        "incident_helper_test",
+        "incidentd_test",
+        "inputflinger_tests",
+        "installd_cache_test",
+        "installd_dexopt_test",
+        "installd_file_test",
+        "installd_otapreopt_test",
+        "installd_service_test",
+        "installd_utils_test",
+        "jni_test_src_lib",
+        "keystore2_crypto_test_rust",
+        "keystore2_selinux_test",
+        "lazy_static_test_tests_test",
+        "libandroidfw_tests",
+        "libappfuse_test",
+        "libbase_test",
+        "libbinder_rs-internal_test",
+        "libbpf_android_test",
+        "libcutils_test",
+        "libcutils_test_static",
+        "libgui_test",
+        "libhidl_test",
+        "libinput_tests",
+        "libjavacore-unit-tests",
+        "liblog-unit-tests",
+        "libminijail_unittest_gtest",
+        "libnativehelper_tests",
+        "libnetworkstats_test",
+        "libnfc-nci-jni-tests",
+        "libnfc-nci-tests",
+        "libprocinfo_test",
+        "librenderengine_test",
+        "libtextclassifier_tests-tplus",
+        "libtextclassifier_tests-sminus",
+        "libsurfaceflinger_unittest",
+        "libunwindstack_unit_test",
+        "libuwb_core_tests",
+        "libuwb_uci_jni_rust_tests",
+        "libuwb_uci_packet_tests",
+        "libuci_hal_android_tests",
+        "libvintf_test",
+        "linker-unit-tests",
+        "logcat-unit-tests",
+        "logd-unit-tests",
+        "logger_device_unit_tests",
+        "kernel-config-unit-tests",
+        "malloc_debug_unit_tests",
+        "memory_replay_tests",
+        "memunreachable_test",
+        "minadbd_test",
+        "minikin_tests",
+        "mj_system_unittest_gtest",
+        "mj_util_unittest_gtest",
+        "mtp_ffs_handle_test",
+        "netd_integration_test",
+        "netd_unit_test",
+        "netdutils_test",
+        "num-traits_test_src_lib",
+        "num-traits_test_tests_cast",
+        "perfetto_integrationtests",
+        "posix_async_io_test",
+        "prioritydumper_test",
+        "puffin_unittest",
+        "quiche_device_test_src_lib",
+        "recovery_unit_test",
+        "resolv_gold_test",
+        "resolv_integration_test",
+        "resolv_unit_test",
+        "ring_test_src_lib",
+        "ring_test_tests_aead_tests",
+        "ring_test_tests_agreement_tests",
+        "ring_test_tests_constant_time_tests",
+        "ring_test_tests_digest_tests",
+        "ring_test_tests_ecdsa_tests",
+        "ring_test_tests_ed25519_tests",
+        "ring_test_tests_hkdf_tests",
+        "ring_test_tests_hmac_tests",
+        "ring_test_tests_pbkdf2_tests",
+        "ring_test_tests_quic_tests",
+        "ring_test_tests_rand_tests",
+        "ring_test_tests_rsa_tests",
+        "ring_test_tests_signature_tests",
+        "scrape_mmap_addr",
+        "simpleperf_cpu_hotplug_test",
+        "simpleperf_unit_test",
+        "statsd_test",
+        "syscall_filter_unittest_gtest",
+        "time-unit-tests",
+        "tokio_test_tests__require_full",
+        "tokio_test_tests_buffered",
+        "tokio_test_tests_io_async_fd",
+        "tokio_test_tests_io_async_read",
+        "tokio_test_tests_io_chain",
+        "tokio_test_tests_io_copy",
+        "tokio_test_tests_io_copy_bidirectional",
+        "tokio_test_tests_io_driver",
+        "tokio_test_tests_io_driver_drop",
+        "tokio_test_tests_io_lines",
+        "tokio_test_tests_io_mem_stream",
+        "tokio_test_tests_io_read",
+        "tokio_test_tests_io_read_buf",
+        "tokio_test_tests_io_read_exact",
+        "tokio_test_tests_io_read_line",
+        "tokio_test_tests_io_read_to_end",
+        "tokio_test_tests_io_read_to_string",
+        "tokio_test_tests_io_read_until",
+        "tokio_test_tests_io_split",
+        "tokio_test_tests_io_take",
+        "tokio_test_tests_io_write",
+        "tokio_test_tests_io_write_all",
+        "tokio_test_tests_io_write_buf",
+        "tokio_test_tests_io_write_int",
+        "tokio_test_tests_macros_join",
+        "tokio_test_tests_macros_pin",
+        "tokio_test_tests_macros_select",
+        "tokio_test_tests_macros_test",
+        "tokio_test_tests_macros_try_join",
+        "tokio_test_tests_net_bind_resource",
+        "tokio_test_tests_net_lookup_host",
+        "tokio_test_tests_no_rt",
+        "tokio_test_tests_process_kill_on_drop",
+        "tokio_test_tests_rt_basic",
+        "tokio_test_tests_rt_common",
+        "tokio_test_tests_rt_threaded",
+        "tokio_test_tests_sync_barrier",
+        "tokio_test_tests_sync_broadcast",
+        "tokio_test_tests_sync_errors",
+        "tokio_test_tests_sync_mutex",
+        "tokio_test_tests_sync_mutex_owned",
+        "tokio_test_tests_sync_notify",
+        "tokio_test_tests_sync_oneshot",
+        "tokio_test_tests_sync_rwlock",
+        "tokio_test_tests_sync_semaphore",
+        "tokio_test_tests_sync_semaphore_owned",
+        "tokio_test_tests_sync_watch",
+        "tokio_test_tests_task_abort",
+        "tokio_test_tests_task_blocking",
+        "tokio_test_tests_task_local",
+        "tokio_test_tests_task_local_set",
+        "tokio_test_tests_tcp_accept",
+        "tokio_test_tests_tcp_connect",
+        "tokio_test_tests_tcp_echo",
+        "tokio_test_tests_tcp_into_split",
+        "tokio_test_tests_tcp_into_std",
+        "tokio_test_tests_tcp_peek",
+        "tokio_test_tests_tcp_shutdown",
+        "tokio_test_tests_tcp_socket",
+        "tokio_test_tests_tcp_split",
+        "tokio_test_tests_time_rt",
+        "tokio_test_tests_udp",
+        "tokio_test_tests_uds_cred",
+        "tokio_test_tests_uds_split",
+        "tokio-test_test_tests_block_on",
+        "tokio-test_test_tests_io",
+        "tokio-test_test_tests_macros",
+        "unicode-xid_test_src_lib",
+        "update_engine_unittests",
+        "url_test_src_lib",
+        "url_test_tests_unit",
+        "vintf_object_test",
+        "wificond_unit_test",
+        "ziparchive-tests",
+        "GraphicBuffer_test",
+        "NeuralNetworksTest_mt_static",
+        "NeuralNetworksTest_operations",
+        "NeuralNetworksTest_static",
+        "NeuralNetworksTest_utils",
+        "SurfaceFlinger_test",
+    ] + select(soong_config_variable("ANDROID", "board_is_automotive"), {
+        true: [
+            "evsmanagerd_test",
+            "libwatchdog_test",
+        ],
+        default: [],
+    }),
+    tests_if_exist_device_both: select(soong_config_variable("ci_tests", "uses_darwinn_tests"), {
+        true: [
+            "DarwiNNTest",
+        ],
+        default: [],
+    }),
+    dists: [
+        {
+            targets: ["continuous_native_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_tests-FILE_NAME_TAG_PLACEHOLDER.zip",
+        },
+        {
+            targets: ["continuous_native_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_tests-symbols-FILE_NAME_TAG_PLACEHOLDER.zip",
+            tag: ".symbols",
+        },
+        {
+            targets: ["continuous_native_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_tests-symbols-mapping-FILE_NAME_TAG_PLACEHOLDER.textproto",
+            tag: ".elf_mapping",
+        },
+    ],
+}
+
+test_package {
+    name: "continuous_native_metric_tests",
+    device_first_tests: [
+    ] + select(soong_config_variable("perf", "board_perfsetup_script"), {
+        any: ["perf-setup"],
+        default: [],
+    }),
+
+    device_both_tests: [
+        "binderAddInts",
+        "binderRpcBenchmark",
+        "bionic-benchmarks",
+        "binder_thread_stats",
+        "hwuimacro",
+        "hwuimicro",
+        "inputflinger_benchmarks",
+        "libandroidfw_benchmarks",
+        "libhwbinder_benchmark",
+        "libjavacore-benchmarks",
+        "libgui_benchmarks",
+        "libpowermanager_benchmarks",
+        "libvibratorservice_benchmarks",
+        "minikin_perftests",
+        "mmapPerf",
+        "netd_benchmark",
+        "VibratorHalIntegrationBenchmark",
+        "librenderengine_bench",
+        "statsd_benchmark",
+        "surfaceflinger_microbenchmarks",
+    ],
+    tests_if_exist_device_both: [
+    ],
+
+    dists: [
+        {
+            targets: ["continuous_native_metric_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_metric_tests-FILE_NAME_TAG_PLACEHOLDER.zip",
+        },
+        {
+            targets: ["continuous_native_metric_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_metric_tests-symbols-FILE_NAME_TAG_PLACEHOLDER.zip",
+            tag: ".symbols",
+        },
+        {
+            targets: ["continuous_native_metric_tests"],
+            prepend_artifact_with_product: true,
+            dest: "continuous_native_metric_tests-symbols-mapping-FILE_NAME_TAG_PLACEHOLDER.textproto",
+            tag: ".elf_mapping",
+        },
+    ],
+}
+
+test_package {
+    name: "continuous_instrumentation_tests",
+
+    tests: [
+        "HelloWorldTests",
+        "BluetoothInstrumentationTests",
+        "LongevityPlatformLibTests",
+        "ManagedProvisioningTests",
+        "FrameworksCoreTests",
+        "FrameworksCoreGameManagerTests",
+        "FrameworksMockingCoreTests",
+        "BinderProxyCountingTestApp",
+        "BinderProxyCountingTestService",
+        "FrameworksNetTests",
+        "FrameworksUiServicesTests",
+        "FrameworksUiServicesNotificationTests",
+        "FrameworksUiServicesZenTests",
+        "BstatsTestApp",
+        "FrameworksServicesTests",
+        "FrameworksMockingServicesTests",
+        "WmTests",
+        "WmPerfTests",
+        "DisplayServiceTests",
+        "SuspendTestApp",
+        "FrameworksUtilTests",
+        "MtpServiceTests",
+        "MtpTests",
+        "DocumentsUITests",
+        "ShellTests",
+        "SystemUITests",
+        "TvSystemUITests",
+        "TestablesTests",
+        "FrameworksWifiApiTests",
+        "FrameworksWifiNonUpdatableApiTests",
+        "FrameworksWifiTests",
+        "FrameworksTelephonyTests",
+        "ContactsProviderTests",
+        "SettingsUnitTests",
+        "TelecomUnitTests",
+        "TraceurUiTests",
+        "AndroidVCardTests",
+        "PermissionFunctionalTests",
+        "BlockedNumberProviderTest",
+        "DownloadAppFunctionalTests",
+        "DynamicCodeLoggerIntegrationTests",
+        "UsbTests",
+        "DownloadProviderTests",
+        "EmergencyInfoUnitTests",
+        "CalendarProviderTests",
+        "SettingsLibTests",
+        "RSTest",
+        "PrintSpoolerOutOfProcessTests",
+        "CellBroadcastReceiverUnitTests",
+        "CellBroadcastServiceTests",
+        "TelephonyProviderTests",
+        "CarrierConfigTests",
+        "TeleServiceTests",
+        "PresencePollingTests",
+        "ImsCommonTests",
+        "SettingsProviderTest",
+        "FrameworksPrivacyLibraryTests",
+        "SettingsUITests",
+        "SettingsPerfTests",
+        "ExtServicesUnitTests-tplus",
+        "ExtServicesUnitTests-sminus",
+        "FrameworksNetSmokeTests",
+        "FlickerLibTest",
+        "WMShellUnitTests",
+        "CarDeveloperOptionsUnitTests",
+        "SpaPrivilegedLibTests",
+        "SettingsSpaUnitTests",
+        "SpaLibTests",
+        "PermissionServiceMockingTests",
+    ] + select(soong_config_variable("ci_tests", "uses_storage_manager_tests"), {
+        any: ["StorageManagerUnitTests"],
+        default: [],
+    }),
+    device_first_tests: [
+        "trace_config_detailed.textproto",
+    ] + select(soong_config_variable("perf", "board_perfsetup_script"), {
+        any: ["perf-setup"],
+        default: [],
+    }),
+
+    device_both_tests: [
+    ],
+    tests_if_exist_common: [
+        "CarrierSetupTests",
+        "DocumentsUIGoogleTests",
+        "GenericBootstrappingArchitectureTests",
+        "GoogleBluetoothInstrumentationTests",
+        "GoogleCellBroadcastReceiverUnitTests",
+        "ImsStackJavaTests",
+        "Launcher3",
+        "Launcher3Tests",
+        "LauncherFunctionalTests",
+        "MultiuserAppLaunchTests",
+        "NexusLauncherDebug",
+        "NexusLauncherOutOfProcTests",
+        "NexusLauncherProguard",
+        "NexusLauncherTests",
+        "NexusLauncherImageTests",
+        "NexusLauncherViewScreenshotTests",
+        "PixelImsMediaJavaUnitTests",
+        "PixelSatelliteServiceTests",
+        "QualifiedNetworksServiceTests",
+        "SettingsGoogleUnitTests",
+        "SettingsFunctionalTests",
+        "StorageManagerGoogleUnitTests",
+        "SystemUIGoogleTests",
+    ],
+    tests_if_exist_device_both: [
+    ],
+    tests_if_exist_device_first: [
+        "ImsStackNativeTests",
+    ],
+    host_tests: [
+        "perfetto_trace_processor_shell",
+    ],
+    tests_if_exist_host: [
+        "MultiuserHostsideIntegrationTests",
+    ],
+
+    dist: {
+        targets: ["continuous_instrumentation_tests"],
+        prepend_artifact_with_product: true,
+        dest: "continuous_instrumentation_tests-FILE_NAME_TAG_PLACEHOLDER.zip",
+    },
+}
+
+test_package {
+    name: "continuous_instrumentation_metric_tests",
+
+    tests: [
+        "AconfigPerfTests",
+        "ActivityManagerPerfTests",
+        "ActivityManagerPerfTestsTestApp",
+        "ActivityManagerPerfTestsStubApp1",
+        "ActivityManagerPerfTestsStubApp2",
+        "ActivityManagerPerfTestsStubApp3",
+        "AutofillPerfTests",
+        "BlobStorePerfTests",
+        "CorePerfTests",
+        "ContentCapturePerfTests",
+        "CoroutineTracingPerfTests",
+        "DocumentsUIAppPerfTests",
+        "InputPerfTests",
+        "MtpServicePerfTests",
+        "RsBlasBenchmark",
+        "ImageProcessingJB",
+        "MediaProviderClientTests",
+        "MultiUserPerfDummyApp",
+        "MultiUserPerfTests",
+        "NeuralNetworksApiBenchmark",
+        "PackageManagerPerfTests",
+        "QueriesAll0",
+        "QueriesAll1",
+        "QueriesAll2",
+        "QueriesAll3",
+        "QueriesAll4",
+        "QueriesAll5",
+        "QueriesAll6",
+        "QueriesAll7",
+        "QueriesAll8",
+        "QueriesAll9",
+        "QueriesAll10",
+        "QueriesAll11",
+        "QueriesAll12",
+        "QueriesAll13",
+        "QueriesAll14",
+        "QueriesAll15",
+        "QueriesAll16",
+        "QueriesAll17",
+        "QueriesAll18",
+        "QueriesAll19",
+        "QueriesAll20",
+        "QueriesAll21",
+        "QueriesAll22",
+        "QueriesAll23",
+        "QueriesAll24",
+        "QueriesAll25",
+        "QueriesAll26",
+        "QueriesAll27",
+        "QueriesAll28",
+        "QueriesAll29",
+        "QueriesAll30",
+        "QueriesAll31",
+        "QueriesAll32",
+        "QueriesAll33",
+        "QueriesAll34",
+        "QueriesAll35",
+        "QueriesAll36",
+        "QueriesAll37",
+        "QueriesAll38",
+        "QueriesAll39",
+        "QueriesAll40",
+        "QueriesAll41",
+        "QueriesAll42",
+        "QueriesAll43",
+        "QueriesAll44",
+        "QueriesAll45",
+        "QueriesAll46",
+        "QueriesAll47",
+        "QueriesAll48",
+        "QueriesAll49",
+        "SettingsProviderPerfTests",
+        "TextClassifierPerfTests",
+        "WmPerfTests",
+        "ImePerfTests",
+        "SurfaceFlingerPerfTests",
+        "PermissionServicePerfTests",
+        "UsePermissionApp0",
+        "UsePermissionApp1",
+        "UsePermissionApp2",
+        "UsePermissionApp3",
+        "UsePermissionApp4",
+        "UsePermissionApp5",
+        "UsePermissionApp6",
+        "UsePermissionApp7",
+        "UsePermissionApp8",
+        "UsePermissionApp9",
+        "UsePermissionApp10",
+        "UsePermissionApp11",
+        "UsePermissionApp12",
+        "UsePermissionApp13",
+        "UsePermissionApp14",
+        "UsePermissionApp15",
+        "UsePermissionApp16",
+        "UsePermissionApp17",
+        "UsePermissionApp18",
+        "UsePermissionApp19",
+        "UsePermissionApp20",
+        "UsePermissionApp21",
+        "UsePermissionApp22",
+        "UsePermissionApp23",
+        "UsePermissionApp24",
+        "UsePermissionApp25",
+        "UsePermissionApp26",
+        "UsePermissionApp27",
+        "UsePermissionApp28",
+        "UsePermissionApp29",
+        //"DocumentsUIPerfTests", TODO(b/72332760): Uncomment when fixed
+    ],
+    device_first_tests: [
+        "trace_config_detailed.textproto",
+        "trace_config_multi_user.textproto",
+    ] + select(soong_config_variable("perf", "board_perfsetup_script"), {
+        any: ["perf-setup"],
+        default: [],
+    }),
+
+    device_both_tests: [
+    ],
+    tests_if_exist_common: [
+        "ResourcesPerfWorkloads",
+    ],
+    tests_if_exist_device_both: [
+    ],
+    host_tests: [
+        "perfetto_trace_processor_shell",
+    ],
+
     dist: {
-        targets: ["platform_tests"],
+        targets: ["continuous_instrumentation_metric_tests"],
         prepend_artifact_with_product: true,
-        dest: "tests-FILE_NAME_TAG_PLACEHOLDER.zip",
+        dest: "continuous_instrumentation_metric_tests-FILE_NAME_TAG_PLACEHOLDER.zip",
     },
 }
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
index 88c60f785..1704ca14e 100644
--- a/PREUPLOAD.cfg
+++ b/PREUPLOAD.cfg
@@ -11,5 +11,8 @@ checkstyle_hook = ${REPO_ROOT}/prebuilts/checkstyle/checkstyle.py --sha ${PREUPL
 
 ktlint_hook = ${REPO_ROOT}/prebuilts/ktlint/ktlint.py --no-verify-format -f ${PREUPLOAD_FILES}
 
+# go/alint for details
+alint_hook = ${REPO_ROOT}/vendor/google/tools/alint
+
 [Tool Paths]
 ktfmt = ${REPO_ROOT}/external/ktfmt/ktfmt.sh
diff --git a/build/tasks/continuous_instrumentation_metric_tests.mk b/build/tasks/continuous_instrumentation_metric_tests.mk
index 0ff0aba51..dba77fee4 100644
--- a/build/tasks/continuous_instrumentation_metric_tests.mk
+++ b/build/tasks/continuous_instrumentation_metric_tests.mk
@@ -15,22 +15,6 @@
 # Rules to generate a tests zip file that included test modules
 # based on the configuration.
 
-LOCAL_PATH := $(call my-dir)
-include $(LOCAL_PATH)/tests/instrumentation_metric_test_list.mk
--include $(wildcard vendor/*/build/tasks/tests/instrumentation_metric_test_list.mk)
-
-my_modules := \
-    $(instrumentation_metric_tests)
-
-my_package_name := continuous_instrumentation_metric_tests
-
-include $(BUILD_SYSTEM)/tasks/tools/package-modules.mk
-
-.PHONY: continuous_instrumentation_metric_tests
-continuous_instrumentation_metric_tests : $(my_package_zip)
-
-name := $(TARGET_PRODUCT)-continuous_instrumentation_metric_tests-FILE_NAME_TAG_PLACEHOLDER
-$(call dist-for-goals, continuous_instrumentation_metric_tests, $(my_package_zip):$(name).zip)
-
+# TODO: Clean up the tests phony target to replace with 'phony_rule' in soong.
 # Also build this when you run "make tests".
 tests: continuous_instrumentation_metric_tests
diff --git a/build/tasks/continuous_instrumentation_tests.mk b/build/tasks/continuous_instrumentation_tests.mk
index f8da9fc06..9a8fff9c8 100644
--- a/build/tasks/continuous_instrumentation_tests.mk
+++ b/build/tasks/continuous_instrumentation_tests.mk
@@ -16,22 +16,8 @@
 # based on the configuration.
 
 LOCAL_PATH := $(call my-dir)
-include $(LOCAL_PATH)/tests/instrumentation_test_list.mk
--include $(wildcard vendor/*/build/tasks/tests/instrumentation_test_list.mk)
-
-my_modules := \
-    $(instrumentation_tests)
-
-my_package_name := continuous_instrumentation_tests
-
-include $(BUILD_SYSTEM)/tasks/tools/package-modules.mk
-
-.PHONY: continuous_instrumentation_tests
-continuous_instrumentation_tests : $(my_package_zip)
-
-name := $(TARGET_PRODUCT)-continuous_instrumentation_tests-FILE_NAME_TAG_PLACEHOLDER
-$(call dist-for-goals, continuous_instrumentation_tests, $(my_package_zip):$(name).zip)
 
+# TODO: Clean up the tests phony target to replace with 'phony_rule' in soong.
 # Also build this when you run "make tests".
 tests: continuous_instrumentation_tests
 
diff --git a/build/tasks/continuous_native_metric_tests.mk b/build/tasks/continuous_native_metric_tests.mk
index 14ae3f69b..8ac3fe5eb 100644
--- a/build/tasks/continuous_native_metric_tests.mk
+++ b/build/tasks/continuous_native_metric_tests.mk
@@ -12,25 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-# Rules to generate a tests zip file that included test modules
-# based on the configuration for continuous metric testing.
-
-LOCAL_PATH := $(call my-dir)
-include $(LOCAL_PATH)/tests/native_metric_test_list.mk
--include $(wildcard vendor/*/build/tasks/tests/native_metric_test_list.mk)
-
-my_modules := \
-    $(native_metric_tests)
-
-my_package_name := continuous_native_metric_tests
-
-include $(BUILD_SYSTEM)/tasks/tools/package-modules.mk
-
-.PHONY: continuous_native_metric_tests
-continuous_native_metric_tests : $(my_package_zip)
-
-name := $(TARGET_PRODUCT)-continuous_native_metric_tests-FILE_NAME_TAG_PLACEHOLDER
-$(call dist-for-goals, continuous_native_metric_tests, $(my_package_zip):$(name).zip)
-
+# TODO: Clean up the tests phony target to replace with 'phony_rule' in soong.
 # Also build this when you run "make tests".
 tests: continuous_native_metric_tests
diff --git a/build/tasks/continuous_native_tests.mk b/build/tasks/continuous_native_tests.mk
index ef452f8cb..655a82475 100644
--- a/build/tasks/continuous_native_tests.mk
+++ b/build/tasks/continuous_native_tests.mk
@@ -15,22 +15,6 @@
 # Rules to generate a tests zip file that included test modules
 # based on the configuration for continuous testing.
 
-LOCAL_PATH := $(call my-dir)
-include $(LOCAL_PATH)/tests/native_test_list.mk
--include $(wildcard vendor/*/build/tasks/tests/native_test_list.mk)
-
-my_modules := \
-    $(native_tests)
-
-my_package_name := continuous_native_tests
-
-include $(BUILD_SYSTEM)/tasks/tools/package-modules.mk
-
-.PHONY: continuous_native_tests
-continuous_native_tests : $(my_package_zip)
-
-name := $(TARGET_PRODUCT)-continuous_native_tests-FILE_NAME_TAG_PLACEHOLDER
-$(call dist-for-goals, continuous_native_tests, $(my_package_zip):$(name).zip)
-
+# TODO: Clean up the tests phony target to replace with 'phony_rule' in soong.
 # Also build this when you run "make tests".
 tests: continuous_native_tests
diff --git a/build/tasks/tests/instrumentation_metric_test_list.mk b/build/tasks/tests/instrumentation_metric_test_list.mk
deleted file mode 100644
index 783867414..000000000
--- a/build/tasks/tests/instrumentation_metric_test_list.mk
+++ /dev/null
@@ -1,131 +0,0 @@
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-instrumentation_metric_tests := \
-    AconfigPerfTests \
-    ActivityManagerPerfTests \
-    ActivityManagerPerfTestsTestApp \
-    ActivityManagerPerfTestsStubApp1 \
-    ActivityManagerPerfTestsStubApp2 \
-    ActivityManagerPerfTestsStubApp3 \
-    AutofillPerfTests \
-    BlobStorePerfTests \
-    CorePerfTests \
-    ContentCapturePerfTests \
-    CoroutineTracingPerfTests \
-    DocumentsUIAppPerfTests \
-    MtpServicePerfTests \
-    RsBlasBenchmark \
-    ImageProcessingJB \
-    MediaProviderClientTests \
-    MultiUserPerfDummyApp \
-    MultiUserPerfTests \
-    NeuralNetworksApiBenchmark \
-    PackageManagerPerfTests \
-    QueriesAll0 \
-    QueriesAll1 \
-    QueriesAll2 \
-    QueriesAll3 \
-    QueriesAll4 \
-    QueriesAll5 \
-    QueriesAll6 \
-    QueriesAll7 \
-    QueriesAll8 \
-    QueriesAll9 \
-    QueriesAll10 \
-    QueriesAll11 \
-    QueriesAll12 \
-    QueriesAll13 \
-    QueriesAll14 \
-    QueriesAll15 \
-    QueriesAll16 \
-    QueriesAll17 \
-    QueriesAll18 \
-    QueriesAll19 \
-    QueriesAll20 \
-    QueriesAll21 \
-    QueriesAll22 \
-    QueriesAll23 \
-    QueriesAll24 \
-    QueriesAll25 \
-    QueriesAll26 \
-    QueriesAll27 \
-    QueriesAll28 \
-    QueriesAll29 \
-    QueriesAll30 \
-    QueriesAll31 \
-    QueriesAll32 \
-    QueriesAll33 \
-    QueriesAll34 \
-    QueriesAll35 \
-    QueriesAll36 \
-    QueriesAll37 \
-    QueriesAll38 \
-    QueriesAll39 \
-    QueriesAll40 \
-    QueriesAll41 \
-    QueriesAll42 \
-    QueriesAll43 \
-    QueriesAll44 \
-    QueriesAll45 \
-    QueriesAll46 \
-    QueriesAll47 \
-    QueriesAll48 \
-    QueriesAll49 \
-    SettingsProviderPerfTests \
-    TextClassifierPerfTests \
-    WmPerfTests \
-    ImePerfTests \
-    SurfaceFlingerPerfTests \
-    trace_config_detailed.textproto \
-    trace_config_multi_user.textproto \
-    perfetto_trace_processor_shell \
-    PermissionServicePerfTests \
-    UsePermissionApp0 \
-    UsePermissionApp1 \
-    UsePermissionApp2 \
-    UsePermissionApp3 \
-    UsePermissionApp4 \
-    UsePermissionApp5 \
-    UsePermissionApp6 \
-    UsePermissionApp7 \
-    UsePermissionApp8 \
-    UsePermissionApp9 \
-    UsePermissionApp10 \
-    UsePermissionApp11 \
-    UsePermissionApp12 \
-    UsePermissionApp13 \
-    UsePermissionApp14 \
-    UsePermissionApp15 \
-    UsePermissionApp16 \
-    UsePermissionApp17 \
-    UsePermissionApp18 \
-    UsePermissionApp19 \
-    UsePermissionApp20 \
-    UsePermissionApp21 \
-    UsePermissionApp22 \
-    UsePermissionApp23 \
-    UsePermissionApp24 \
-    UsePermissionApp25 \
-    UsePermissionApp26 \
-    UsePermissionApp27 \
-    UsePermissionApp28 \
-    UsePermissionApp29
-
-    # TODO(b/72332760): Uncomment when fixed
-    #DocumentsUIPerfTests
-
-ifneq ($(strip $(BOARD_PERFSETUP_SCRIPT)),)
-instrumentation_metric_tests += perf-setup
-endif
diff --git a/build/tasks/tests/instrumentation_test_list.mk b/build/tasks/tests/instrumentation_test_list.mk
deleted file mode 100644
index ab1dbe7d5..000000000
--- a/build/tasks/tests/instrumentation_test_list.mk
+++ /dev/null
@@ -1,97 +0,0 @@
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-instrumentation_tests := \
-    HelloWorldTests \
-    BluetoothInstrumentationTests \
-    LongevityPlatformLibTests \
-    ManagedProvisioningTests \
-    FrameworksCoreTests \
-    FrameworksCoreGameManagerTests \
-    FrameworksMockingCoreTests \
-    BinderProxyCountingTestApp \
-    BinderProxyCountingTestService \
-    FrameworksNetTests \
-    FrameworksUiServicesTests \
-    FrameworksUiServicesNotificationTests \
-    FrameworksUiServicesZenTests \
-    BstatsTestApp \
-    FrameworksServicesTests \
-    FrameworksMockingServicesTests \
-    WmTests \
-    WmPerfTests \
-    DisplayServiceTests \
-    SuspendTestApp \
-    FrameworksUtilTests \
-    MtpServiceTests \
-    MtpTests \
-    DocumentsUITests \
-    ShellTests \
-    SystemUITests \
-    TvSystemUITests \
-    TestablesTests \
-    FrameworksWifiApiTests \
-    FrameworksWifiNonUpdatableApiTests \
-    FrameworksWifiTests \
-    FrameworksTelephonyTests \
-    ContactsProviderTests \
-    SettingsUnitTests \
-    TelecomUnitTests \
-    TraceurUiTests \
-    AndroidVCardTests \
-    PermissionFunctionalTests \
-    BlockedNumberProviderTest \
-    DownloadAppFunctionalTests \
-    DynamicCodeLoggerIntegrationTests \
-    UsbTests \
-    DownloadProviderTests \
-    EmergencyInfoUnitTests \
-    CalendarProviderTests \
-    SettingsLibTests \
-    RSTest \
-    PrintSpoolerOutOfProcessTests \
-    CellBroadcastReceiverUnitTests \
-    CellBroadcastServiceTests \
-    TelephonyProviderTests \
-    CarrierConfigTests \
-    TeleServiceTests \
-    PresencePollingTests \
-    ImsCommonTests \
-    SettingsProviderTest \
-    FrameworksPrivacyLibraryTests \
-    SettingsUITests \
-    SettingsPerfTests \
-    ExtServicesUnitTests-tplus \
-    ExtServicesUnitTests-sminus \
-    FrameworksNetSmokeTests \
-    FlickerLibTest \
-    WMShellUnitTests \
-    trace_config_detailed.textproto \
-    perfetto_trace_processor_shell \
-    CarDeveloperOptionsUnitTests \
-    SpaPrivilegedLibTests \
-    SettingsSpaUnitTests \
-    SpaLibTests \
-    PermissionServiceMockingTests
-
-ifneq ($(strip $(BOARD_PERFSETUP_SCRIPT)),)
-instrumentation_tests += perf-setup
-endif
-
-# Storage Manager may not exist on device
-ifneq ($(filter StorageManager, $(PRODUCT_PACKAGES)),)
-
-instrumentation_tests += StorageManagerUnitTests
-
-endif
diff --git a/build/tasks/tests/native_metric_test_list.mk b/build/tasks/tests/native_metric_test_list.mk
deleted file mode 100644
index 6d7dccfde..000000000
--- a/build/tasks/tests/native_metric_test_list.mk
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-native_metric_tests := \
-    binderAddInts \
-    binderRpcBenchmark \
-    bionic-benchmarks \
-    binder_thread_stats \
-    hwuimacro \
-    hwuimicro \
-    inputflinger_benchmarks \
-    libandroidfw_benchmarks \
-    libhwbinder_benchmark \
-    libjavacore-benchmarks \
-    libgui_benchmarks \
-    libpowermanager_benchmarks \
-    libvibratorservice_benchmarks \
-    minikin_perftests \
-    mmapPerf \
-    netd_benchmark \
-    VibratorHalIntegrationBenchmark \
-    librenderengine_bench \
-    statsd_benchmark \
-    surfaceflinger_microbenchmarks
-
-ifneq ($(strip $(BOARD_PERFSETUP_SCRIPT)),)
-native_metric_tests += perf-setup
-endif
diff --git a/build/tasks/tests/native_test_list.mk b/build/tasks/tests/native_test_list.mk
deleted file mode 100644
index a311729d2..000000000
--- a/build/tasks/tests/native_test_list.mk
+++ /dev/null
@@ -1,245 +0,0 @@
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-native_tests := \
-    aaudio_test_mmap_path \
-    adbd_test \
-    android_logger_test_src_lib \
-    android_logger_test_tests_config_log_level \
-    android_logger_test_tests_default_init \
-    android_logger_test_tests_multiple_init \
-    anyhow_test_src_lib \
-    anyhow_test_tests_test_autotrait \
-    anyhow_test_tests_test_boxed \
-    anyhow_test_tests_test_chain \
-    anyhow_test_tests_test_context \
-    anyhow_test_tests_test_convert \
-    anyhow_test_tests_test_downcast \
-    anyhow_test_tests_test_fmt \
-    anyhow_test_tests_test_macros \
-    anyhow_test_tests_test_repr \
-    anyhow_test_tests_test_source \
-    audio_health_tests \
-    bionic-unit-tests \
-    bionic-unit-tests-static \
-    bluetooth_test_common \
-    bootstat_tests \
-    boringssl_crypto_test \
-    boringssl_ssl_test \
-    bsdiff_unittest \
-    bugreportz_test \
-    bytes_test_tests_test_buf \
-    bytes_test_tests_test_buf_mut \
-    bytes_test_tests_test_bytes \
-    bytes_test_tests_test_bytes_odd_alloc \
-    bytes_test_tests_test_bytes_vec_alloc \
-    bytes_test_tests_test_chain \
-    bytes_test_tests_test_debug \
-    bytes_test_tests_test_iter \
-    bytes_test_tests_test_reader \
-    bytes_test_tests_test_take \
-    camera_client_test \
-    cesu8_test_src_lib \
-    clatd_test \
-    confirmationui_invocation_test \
-    debuggerd_test \
-    doh_ffi_test \
-    doh_unit_test \
-    dumpstate_test \
-    dumpstate_test_fixture \
-    dumpsys_test \
-    gpuservice_unittest \
-    gwp_asan_unittest \
-    hello_world_test \
-    hwui_unit_tests \
-    incident_helper_test \
-    incidentd_test \
-    inputflinger_tests \
-    installd_cache_test \
-    installd_dexopt_test \
-    installd_file_test \
-    installd_otapreopt_test \
-    installd_service_test \
-    installd_utils_test \
-    jni_test_src_lib \
-    keystore2_crypto_test_rust \
-    keystore2_selinux_test \
-    keystore2_test \
-    lazy_static_test_tests_test \
-    libandroidfw_tests \
-    libappfuse_test \
-    libbase_test \
-    libbinder_rs-internal_test \
-    libbpf_android_test \
-    libcutils_test \
-    libcutils_test_static \
-    libgui_test \
-    libhidl_test \
-    libinput_tests \
-    libjavacore-unit-tests \
-    liblog-unit-tests \
-    libminijail_unittest_gtest \
-    libnativehelper_tests \
-    libnetworkstats_test \
-    libnfc-nci-jni-tests\
-    libnfc-nci-tests\
-    libprocinfo_test \
-    librenderengine_test \
-    libtextclassifier_tests-tplus \
-    libtextclassifier_tests-sminus \
-    libsurfaceflinger_unittest \
-    libunwindstack_unit_test \
-    libuwb_core_tests \
-    libuwb_uci_jni_rust_tests \
-    libuwb_uci_packet_tests \
-    libuci_hal_android_tests \
-    libvintf_test \
-    linker-unit-tests \
-    logcat-unit-tests \
-    logd-unit-tests \
-    logger_device_unit_tests \
-    kernel-config-unit-tests \
-    malloc_debug_unit_tests \
-    memory_replay_tests \
-    memunreachable_test \
-    minadbd_test \
-    minikin_tests \
-    mj_system_unittest_gtest \
-    mj_util_unittest_gtest \
-    mtp_ffs_handle_test \
-    netd_integration_test \
-    netd_unit_test \
-    netdutils_test \
-    num-traits_test_src_lib \
-    num-traits_test_tests_cast \
-    perfetto_integrationtests \
-    posix_async_io_test \
-    prioritydumper_test \
-    puffin_unittest \
-    quiche_device_test_src_lib \
-    recovery_unit_test \
-    resolv_gold_test \
-    resolv_integration_test \
-    resolv_unit_test \
-    ring_test_src_lib \
-    ring_test_tests_aead_tests \
-    ring_test_tests_agreement_tests \
-    ring_test_tests_constant_time_tests \
-    ring_test_tests_digest_tests \
-    ring_test_tests_ecdsa_tests \
-    ring_test_tests_ed25519_tests \
-    ring_test_tests_hkdf_tests \
-    ring_test_tests_hmac_tests \
-    ring_test_tests_pbkdf2_tests \
-    ring_test_tests_quic_tests \
-    ring_test_tests_rand_tests \
-    ring_test_tests_rsa_tests \
-    ring_test_tests_signature_tests \
-    scrape_mmap_addr \
-    simpleperf_cpu_hotplug_test \
-    simpleperf_unit_test \
-    statsd_test \
-    syscall_filter_unittest_gtest \
-    time-unit-tests \
-    tokio_test_tests__require_full \
-    tokio_test_tests_buffered \
-    tokio_test_tests_io_async_fd \
-    tokio_test_tests_io_async_read \
-    tokio_test_tests_io_chain \
-    tokio_test_tests_io_copy \
-    tokio_test_tests_io_copy_bidirectional \
-    tokio_test_tests_io_driver \
-    tokio_test_tests_io_driver_drop \
-    tokio_test_tests_io_lines \
-    tokio_test_tests_io_mem_stream \
-    tokio_test_tests_io_read \
-    tokio_test_tests_io_read_buf \
-    tokio_test_tests_io_read_exact \
-    tokio_test_tests_io_read_line \
-    tokio_test_tests_io_read_to_end \
-    tokio_test_tests_io_read_to_string \
-    tokio_test_tests_io_read_until \
-    tokio_test_tests_io_split \
-    tokio_test_tests_io_take \
-    tokio_test_tests_io_write \
-    tokio_test_tests_io_write_all \
-    tokio_test_tests_io_write_buf \
-    tokio_test_tests_io_write_int \
-    tokio_test_tests_macros_join \
-    tokio_test_tests_macros_pin \
-    tokio_test_tests_macros_select \
-    tokio_test_tests_macros_test \
-    tokio_test_tests_macros_try_join \
-    tokio_test_tests_net_bind_resource \
-    tokio_test_tests_net_lookup_host \
-    tokio_test_tests_no_rt \
-    tokio_test_tests_process_kill_on_drop \
-    tokio_test_tests_rt_basic \
-    tokio_test_tests_rt_common \
-    tokio_test_tests_rt_threaded \
-    tokio_test_tests_sync_barrier \
-    tokio_test_tests_sync_broadcast \
-    tokio_test_tests_sync_errors \
-    tokio_test_tests_sync_mutex \
-    tokio_test_tests_sync_mutex_owned \
-    tokio_test_tests_sync_notify \
-    tokio_test_tests_sync_oneshot \
-    tokio_test_tests_sync_rwlock \
-    tokio_test_tests_sync_semaphore \
-    tokio_test_tests_sync_semaphore_owned \
-    tokio_test_tests_sync_watch \
-    tokio_test_tests_task_abort \
-    tokio_test_tests_task_blocking \
-    tokio_test_tests_task_local \
-    tokio_test_tests_task_local_set \
-    tokio_test_tests_tcp_accept \
-    tokio_test_tests_tcp_connect \
-    tokio_test_tests_tcp_echo \
-    tokio_test_tests_tcp_into_split \
-    tokio_test_tests_tcp_into_std \
-    tokio_test_tests_tcp_peek \
-    tokio_test_tests_tcp_shutdown \
-    tokio_test_tests_tcp_socket \
-    tokio_test_tests_tcp_split \
-    tokio_test_tests_time_rt \
-    tokio_test_tests_udp \
-    tokio_test_tests_uds_cred \
-    tokio_test_tests_uds_split \
-    tokio-test_test_tests_block_on \
-    tokio-test_test_tests_io \
-    tokio-test_test_tests_macros \
-    unicode-xid_test_src_lib \
-    update_engine_unittests \
-    url_test_src_lib \
-    url_test_tests_unit \
-    vintf_object_test \
-    wificond_unit_test \
-    ziparchive-tests \
-    GraphicBuffer_test \
-    NeuralNetworksTest_mt_static \
-    NeuralNetworksTest_operations \
-    NeuralNetworksTest_static \
-    NeuralNetworksTest_utils \
-    SurfaceFlinger_test \
-    lmkd_unit_test
-
-ifeq ($(BOARD_IS_AUTOMOTIVE), true)
-native_tests += \
-    libwatchdog_test \
-    evsmanagerd_test
-endif
-
-ifneq ($(strip $(BOARD_PERFSETUP_SCRIPT)),)
-native_tests += perf-setup
-endif
diff --git a/host_runners/boot/Android.bp b/host_runners/boot/Android.bp
index bfebc84f3..b46a40fd2 100644
--- a/host_runners/boot/Android.bp
+++ b/host_runners/boot/Android.bp
@@ -21,6 +21,7 @@ java_test_host {
     team: "trendy_team_android_platform_performance_testing",
     srcs: ["src/**/*.java"],
     static_libs: ["loganalysis","host_runner_utils"],
+    libs: ["tradefed"],
     test_suites: [
         "device-tests",
         "performance-tests",
diff --git a/host_runners/boot/tests/Android.bp b/host_runners/boot/tests/Android.bp
index 61600557a..6d2ad9f93 100644
--- a/host_runners/boot/tests/Android.bp
+++ b/host_runners/boot/tests/Android.bp
@@ -24,4 +24,7 @@ java_library_host {
         "mockito",
         "objenesis",
     ],
+    libs: [
+        "tradefed",
+    ],
 }
diff --git a/host_runners/power/Android.bp b/host_runners/power/Android.bp
index fc41af679..cd24c6952 100644
--- a/host_runners/power/Android.bp
+++ b/host_runners/power/Android.bp
@@ -21,5 +21,6 @@ java_test_host {
     team: "trendy_team_android_platform_performance_testing",
     srcs: ["src/**/*.java"],
     static_libs: ["host_runner_utils"],
+    libs: ["tradefed"],
     test_suites: ["device-tests","performance-tests",],
 }
diff --git a/host_runners/power/tests/Android.bp b/host_runners/power/tests/Android.bp
index 7081d11e9..38370a460 100644
--- a/host_runners/power/tests/Android.bp
+++ b/host_runners/power/tests/Android.bp
@@ -24,4 +24,7 @@ java_library_host {
         "mockito",
         "objenesis",
     ],
+    libs: [
+        "tradefed",
+    ],
 }
diff --git a/host_runners/utils/Android.bp b/host_runners/utils/Android.bp
index 6e5feb6f9..15f1ab9d8 100644
--- a/host_runners/utils/Android.bp
+++ b/host_runners/utils/Android.bp
@@ -19,5 +19,5 @@ package {
 java_library_host {
     name: "host_runner_utils",
     srcs: ["src/**/*.java"],
-    static_libs: ["tradefed"],
+    libs: ["tradefed"],
 }
diff --git a/host_runners/utils/src/com/android/runner/utils/InstrumentationResultProtoParser.java b/host_runners/utils/src/com/android/runner/utils/InstrumentationResultProtoParser.java
index 94e070a41..2fcc79da1 100644
--- a/host_runners/utils/src/com/android/runner/utils/InstrumentationResultProtoParser.java
+++ b/host_runners/utils/src/com/android/runner/utils/InstrumentationResultProtoParser.java
@@ -23,7 +23,7 @@ import com.android.commands.am.InstrumentationData.SessionStatus;
 import com.android.commands.am.InstrumentationData.TestStatus;
 import com.android.ddmlib.IShellOutputReceiver;
 import com.android.ddmlib.testrunner.ITestRunListener;
-import com.android.ddmlib.testrunner.InstrumentationResultParser;
+import com.android.tradefed.result.ddmlib.InstrumentationResultParser;
 
 import com.google.protobuf.InvalidProtocolBufferException;
 
diff --git a/host_runners/utils/tests/Android.bp b/host_runners/utils/tests/Android.bp
index cdd9b922b..1fac6f7d0 100644
--- a/host_runners/utils/tests/Android.bp
+++ b/host_runners/utils/tests/Android.bp
@@ -24,4 +24,7 @@ java_library_host {
         "mockito",
         "objenesis",
     ],
+    libs: [
+        "tradefed",
+    ],
 }
diff --git a/libraries/androidbuildinternal/Android.bp b/libraries/androidbuildinternal/Android.bp
new file mode 100644
index 000000000..4bcc05746
--- /dev/null
+++ b/libraries/androidbuildinternal/Android.bp
@@ -0,0 +1,28 @@
+license {
+    name: "unbundled_google_libraries",
+    visibility: [":__subpackages__"],
+    license_kinds: [
+        "legacy_notice",
+        "legacy_proprietary",
+    ],
+}
+
+package {
+    // See: http://go/android-license-faq
+    // Added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "unbundled_google_libraries"
+    // to get the below license kinds:
+    //   legacy_notice
+    //   legacy_proprietary
+    default_applicable_licenses: ["unbundled_google_libraries"],
+}
+
+java_import_host {
+    name: "libandroid_build_v2beta1_java",
+    jars: ["libandroid_build_v2beta1_java.jar"],
+}
+
+java_import_host {
+    name: "libandroid_build_v3_java",
+    jars: ["libandroid_build_v3_java.jar"],
+}
diff --git a/libraries/androidbuildinternal/README b/libraries/androidbuildinternal/README
new file mode 100644
index 000000000..728f975ed
--- /dev/null
+++ b/libraries/androidbuildinternal/README
@@ -0,0 +1,22 @@
+What is Android Build Internal Library?
+------------------------------------
+Android Build service is used as a destination to upload test results and logs from
+TF test runs. This is an autogenerated library for the Android Build API client.
+The library is generated automatically from API definitions.
+
+What is the difference between v2beta1 and v3?
+-------------------------------------
+Those are different versions of the library. V3 introduced some incompatible changes
+and v3 library can't be used as a drop-in replacement. V3 library is compiled so that
+it has a version number embedded in the pacakge name and it can be used alongside v2beta1.
+
+Building Android Build Internal Client libraries
+-------------------------------------
+
+To build v3 (CL/683732996):
+Run the following blaze command:
+blaze --blazerc=/dev/null build //wireless/android/launchcontrol/apiary:libandroid_build_versioned_v3_java.jar
+
+To build v2beta1 (CL/281174129):
+Run the following blaze command:
+blaze --blazerc=/dev/null build //wireless/android/launchcontrol/apiary:libandroid_build_v2beta1_java.jar
diff --git a/libraries/androidbuildinternal/libandroid_build_v2beta1_java.jar b/libraries/androidbuildinternal/libandroid_build_v2beta1_java.jar
new file mode 100755
index 000000000..d09bfe23d
Binary files /dev/null and b/libraries/androidbuildinternal/libandroid_build_v2beta1_java.jar differ
diff --git a/libraries/androidbuildinternal/libandroid_build_v3_java.jar b/libraries/androidbuildinternal/libandroid_build_v3_java.jar
new file mode 100755
index 000000000..c13b0f624
Binary files /dev/null and b/libraries/androidbuildinternal/libandroid_build_v3_java.jar differ
diff --git a/libraries/compatibility-common-util/src/com/android/compatibility/common/util/DesktopTest.java b/libraries/annotations/src/android/platform/test/annotations/DesktopTest.java
similarity index 85%
rename from libraries/compatibility-common-util/src/com/android/compatibility/common/util/DesktopTest.java
rename to libraries/annotations/src/android/platform/test/annotations/DesktopTest.java
index bf2b372f0..2de2a6a63 100644
--- a/libraries/compatibility-common-util/src/com/android/compatibility/common/util/DesktopTest.java
+++ b/libraries/annotations/src/android/platform/test/annotations/DesktopTest.java
@@ -14,18 +14,18 @@
  * limitations under the License.
  */
 
-package com.android.compatibility.common.util;
+package android.platform.test.annotations;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Marks the type of test with purpose of asserting Desktop requirements.
- */
+/** Marks the type of test with purpose of asserting Desktop requirements and cujs. */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.TYPE})
 public @interface DesktopTest {
     String[] requirements() default {""};
+
+    String[] cujs() default {""};
 }
diff --git a/libraries/annotations/src/android/platform/test/annotations/WithDesktopScreenshotTest.java b/libraries/annotations/src/android/platform/test/annotations/WithDesktopScreenshotTest.java
new file mode 100644
index 000000000..36548d631
--- /dev/null
+++ b/libraries/annotations/src/android/platform/test/annotations/WithDesktopScreenshotTest.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a screenshot test that should run on desktop as well as on other platforms, such as phone.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD, ElementType.TYPE})
+public @interface WithDesktopScreenshotTest {
+}
diff --git a/libraries/annotations/src/py/DesktopTest.py b/libraries/annotations/src/py/DesktopTest.py
index a6c31045e..3d443e3b1 100644
--- a/libraries/annotations/src/py/DesktopTest.py
+++ b/libraries/annotations/src/py/DesktopTest.py
@@ -18,17 +18,19 @@ from typing import List
 
 
 class DesktopTest(object):
-  """Marks the type of test with purpose of asserting Desktop requirements.
+  """Marks the type of test with purpose of asserting Desktop requirements and cujs.
 
   Args:
       requirements: the list of Desktop requirements.
+      cujs: the list of Desktop cujs.
 
   Example:
-      @DesktopTest(requirements=['D-0-1', 'D-0-2'])
+      @DesktopTest(requirements=['D-0-1', 'D-0-2'], cujs=['cuj-1', 'cuj-2'])
   """
 
-  def __init__(self, requirements: List[str] = []):
+  def __init__(self, requirements: List[str] = [], cujs: List[str] = []):
     self._requirements = requirements
+    self._cujs = cujs
 
   def __call__(self, func):
-    return func
\ No newline at end of file
+    return func
diff --git a/libraries/app-helpers/interfaces/auto/OWNERS b/libraries/app-helpers/interfaces/auto/OWNERS
index 84dd7d9a3..184f65850 100644
--- a/libraries/app-helpers/interfaces/auto/OWNERS
+++ b/libraries/app-helpers/interfaces/auto/OWNERS
@@ -4,3 +4,4 @@ rrwoods@google.com
 shubhras@google.com
 vitalidim@google.com
 rustamx@google.com
+rishus@google.com
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppGridHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppGridHelper.java
index fd77d918d..6adbb010f 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppGridHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppGridHelper.java
@@ -84,4 +84,32 @@ public interface IAutoAppGridHelper extends IAppHelper {
      * <p>Press home button.
      */
     void goToHomePage();
+
+    /**
+     * Setup expectations: Go To Home.
+     *
+     * <p>Long press app grid facet button.
+     */
+    void longTapAllAppsButton();
+
+    /**
+     * Setup expectations: Go To Home.
+     *
+     * <p>Press app grid facet button.
+     */
+    void singleTapAllAppsButton();
+
+    /**
+     * Setup expectations: Recent AppS creen is displayed.
+     *
+     * <p>Validates Recent App Screen is displaying.
+     */
+    boolean isRecentsScreenLaunched();
+
+    /**
+     * Setup expectations: Appgrid is not opened.
+     *
+     * <p>Validates whether app is present in app grid.
+     */
+    boolean isAppPresentInAppgrid(String appName);
 }
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppInfoSettingsHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppInfoSettingsHelper.java
index 8a482bbc5..dcd0a0c90 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppInfoSettingsHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoAppInfoSettingsHelper.java
@@ -58,7 +58,16 @@ public interface IAutoAppInfoSettingsHelper extends IAppHelper {
     /**
      * Setup expectation: An application in Apps & notifications setting is open
      *
-     * This method is to check whether an application is running in background from UI
+     * <p>This method is to enable/disable an application
+     *
+     * @param state - ENABLE: to enable, DISABLE: to disable
+     */
+    void selectAppAndEnableDisableApp(String application, State state);
+
+    /**
+     * Setup expectation: An application in Apps & notifications setting is open
+     *
+     * <p>This method is to check whether an application is running in background from UI
      */
     boolean isCurrentApplicationRunning();
 
@@ -69,6 +78,13 @@ public interface IAutoAppInfoSettingsHelper extends IAppHelper {
      */
     void forceStop();
 
+    /**
+     * Setup expectation: An application in Apps & notifications setting is open
+     *
+     * <p>clicks stopapp button and checks stop app popup is displaying
+     */
+    boolean isStopappPopupDisplayed();
+
     /**
      * Setup expectation: Apps & notifications setting is open
      *
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoDialHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoDialHelper.java
index e22d65c63..1c49b8333 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoDialHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoDialHelper.java
@@ -426,4 +426,11 @@ public interface IAutoDialHelper extends IAppHelper, Scrollable {
      * <p>This method is used to check if dialer settings is present in dialer page
      */
     boolean verifyDialerSettings();
+
+    /**
+     * Setup expectations: The phone app is open
+     *
+     * <p>This method is used to check if connect to bluetooth message is present in dialer page
+     */
+    boolean isConnectToBluetoothDisplayed();
 }
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoGooglePlayHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoGooglePlayHelper.java
index d3330db57..592ba7192 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoGooglePlayHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoGooglePlayHelper.java
@@ -32,6 +32,13 @@ public interface IAutoGooglePlayHelper extends IAppHelper, Scrollable {
      */
     void searchApp(String appName);
 
+    /**
+     * Setup expectations: Google keyboard is open.
+     *
+     * <p>This method is used to click on search button in keyboard.
+     */
+    void clickKeyboardSearch();
+
     /**
      * Setup expectations: Google Play app is open.
      *
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoHomeHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoHomeHelper.java
index e998722c7..f70eb4be7 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoHomeHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoHomeHelper.java
@@ -41,6 +41,13 @@ public interface IAutoHomeHelper extends IAppHelper {
      */
     boolean hasBluetoothButton();
 
+    /**
+     * Setup expectations: Should be on home screen.
+     *
+     * <p>Opens bluetooth palette palette.
+     */
+    void openBluetoothButton();
+
     /**
      * Setup expectations: Should be on home screen.
      *
@@ -48,6 +55,13 @@ public interface IAutoHomeHelper extends IAppHelper {
      */
     boolean hasNetworkButton();
 
+    /**
+     * Setup expectations: Should be on home screen.
+     *
+     * <p>Opens network palette.
+     */
+    void openNetworkPalette();
+
     /**
      * Setup expectations: Should be on home screen.
      *
@@ -55,6 +69,20 @@ public interface IAutoHomeHelper extends IAppHelper {
      */
     boolean hasDisplayBrightness();
 
+    /**
+     * Setup expectations: Should be on home screen.
+     *
+     * <p>Checks if exists a Sound settings widget.
+     */
+    boolean hasSoundSettings();
+
+    /**
+     * Setup expectations: Should be on home screen.
+     *
+     * <p>Opens sound settings palette.
+     */
+    void openSoundSettingsPalette();
+
     /**
      * Setup expectations: Verifying the Guest label displayed in profile icon in status bar
      *
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMapsHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMapsHelper.java
index 16891793e..2b4b8f563 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMapsHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMapsHelper.java
@@ -91,6 +91,27 @@ public interface IAutoMapsHelper extends IAppHelper {
      */
     void launchKeyboard();
 
+    /**
+     * Setup expectations: Maps app search bar is open
+     *
+     * <p>This method will click maps search back button.
+     */
+    void clickMapsSearchBackButton();
+
+    /**
+     * Setup expectations: Maps keyboard is trying to access microphone
+     *
+     * <p>This method will allow keyboard to access microphone.
+     */
+    void allowGoogleKeyboardToRecordAudio();
+
+    /**
+     * Setup expectations: microphone is used
+     *
+     * <p>checks whether microphone status panel is opened or not.
+     */
+     boolean isMicrophoneStatusPanelOpened();
+
     /**
      * Setup expectations: Maps app is open
      *
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMediaHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMediaHelper.java
index 2fab6d2fe..e50501035 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMediaHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoMediaHelper.java
@@ -230,6 +230,13 @@ public interface IAutoMediaHelper extends IAppHelper, Scrollable {
      */
     boolean isConnectToBluetoothLabelVisible();
 
+    /**
+     * Setup expectations: Bluetooth Audio page opened.
+     *
+     * <p>This method returns whether cancel button visible or not.
+     */
+    boolean isCancelButtonVisible();
+
     /**
      * Setup expectations: on home screen.
      *
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoNotificationHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoNotificationHelper.java
index ac7bf7564..e9ff09e47 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoNotificationHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoNotificationHelper.java
@@ -16,13 +16,18 @@
 
 package android.platform.helpers;
 
+import androidx.test.uiautomator.UiObject2;
+
 public interface IAutoNotificationHelper extends Scrollable, IAppHelper {
+
     /**
      * Setup expectations: Notification app is open and scrolled to the bottom.
      *
-     * <p>Tap clear all button if present.
+     * <p>Find notification with specific title.
+     *
+     * @param title of the notification to be found.
      */
-    void tapClearAllBtn();
+    UiObject2 findNotificationInCenterWithTitle(String title);
 
     /**
      * Setup expectations: A notification is received.
@@ -33,6 +38,13 @@ public interface IAutoNotificationHelper extends Scrollable, IAppHelper {
     */
     boolean checkNotificationExists(String title);
 
+    /**
+     * Setup expectations: Notification app is open and scrolled to the bottom.
+     *
+     * <p>Tap clear all button if present.
+     */
+    void tapClearAllBtn();
+
     /**
      * Setup expectations: A notification is received.
      *
@@ -51,6 +63,15 @@ public interface IAutoNotificationHelper extends Scrollable, IAppHelper {
      */
     boolean isNotificationDisplayedInCenterWithContent(String content);
 
+    /**
+     * Setup expectations: A notification is received.
+     *
+     * <p>Get the content of the notification.
+     *
+     * @param title of the notification.
+     */
+    String getNotificationContent(String title);
+
     /**
      * Setup expectations: A notification is received.
      *
@@ -101,4 +122,23 @@ public interface IAutoNotificationHelper extends Scrollable, IAppHelper {
      * <p>Checks App Permissions is present
      */
     boolean checkAppPermissionsExists(String title);
+
+    /**
+     * Setup expectations: A notification is received.
+     *
+     * <p>Get the count of SMS notifications.
+     *
+     * @param title of the notification.
+     */
+    int getSmsNotificationCount(String title);
+
+    /**
+     * Setup expectations: A notification is received.
+     *
+     * <p>Get the content of the SMS notification. If SMS count is present, click on it to expand
+     * the notification and get the content.
+     *
+     * @param title of the notification.
+     */
+    String getSmsNotificationContent(String title);
 }
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoPrivacySettingsHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoPrivacySettingsHelper.java
index 16906ad80..f28a0d31b 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoPrivacySettingsHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoPrivacySettingsHelper.java
@@ -266,4 +266,18 @@ public interface IAutoPrivacySettingsHelper extends IAppHelper {
      * <p>Click on Mic
      */
     void clickMicroPhoneOnScreen();
+
+    /**
+     * Setup expectation: Manager Permission - Privacy Settings is open
+     *
+     * <p>This method clicks on other permissions.
+     */
+    void clickOtherPermissionsPage();
+
+    /**
+     * Setup expectation: Manager Permission- other permissions settings page is open
+     *
+     * <p>This method checks if CarInformation is displayed in other permissions settings page
+     */
+    boolean isCarInformationUIElementDisplayed();
 }
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUISettingsHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUISettingsHelper.java
index beb2a770c..bff7a4b79 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUISettingsHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUISettingsHelper.java
@@ -43,4 +43,13 @@ public interface IAutoUISettingsHelper extends IAppHelper {
      * @param element - element name
      */
     boolean hasUIElement(String element);
+
+    /**
+     * Setup expectation: Verify if UI element is present
+     *
+     * <p>To Verify if UI element is present
+     *
+     * @param element - element name
+     */
+    boolean hasSettingsMenu(String element);
 }
diff --git a/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IPlayStoreHelper.java b/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IPlayStoreHelper.java
index 3579b4c15..c3e61e63f 100644
--- a/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IPlayStoreHelper.java
+++ b/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IPlayStoreHelper.java
@@ -23,23 +23,23 @@ public interface IPlayStoreHelper extends IAppHelper {
     /**
      * Setup expectations: The app is open.
      *
-     * Looks for the search bar or button by scrolling up or pressing back. It then enters a query,
-     * and displays the results. This method blocks until the results are selectable.
+     * <p>Looks for the search bar or button by scrolling up or pressing back. It then enters a
+     * query, and displays the results. This method blocks until the results are selectable.
      */
     public void doSearch(String query);
 
     /**
      * Setup expectations: There are visible search results.
      *
-     * Selects the first search result card and blocks until the app's install page is open.
+     * <p>Selects the first search result card and blocks until the app's install page is open.
      */
     public void selectFirstResult();
 
     /**
      * Setup expectations: An app's install page is open, but the app is not installed.
      *
-     * Press the install button and dismiss any confirmation dialogs. This method will block until
-     * the app starts downloading, though installation cannot be guaranteed.
+     * <p>Press the install button and dismiss any confirmation dialogs. This method will block
+     * until the app starts downloading, though installation cannot be guaranteed.
      */
     public void installApp();
 
@@ -53,8 +53,8 @@ public interface IPlayStoreHelper extends IAppHelper {
     /**
      * Setup expectations: An app's install page is open, and the app is installed.
      *
-     * Press the uninstall button. This method will block until
-     * the app completes uninstallation, though uninstallation cannot be guaranteed.
+     * <p>Press the uninstall button. This method will block until the app completes uninstallation,
+     * though uninstallation cannot be guaranteed.
      */
     public void uninstallApp();
 
@@ -80,4 +80,12 @@ public interface IPlayStoreHelper extends IAppHelper {
      * <p>This method will get a UiObject2 object for Play Store Apps page scroll container.
      */
     UiObject2 getScrollPageContainer();
+
+    /**
+     * Setup expectations: Verify stay on Play Store page after finish scroll.
+     *
+     * <p>This is for verify has the UiObject2 object on Play Store Apps page after finish
+     * the scroll test.
+     */
+    public boolean isOnPlayStorePage();
 }
diff --git a/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/IGoogleSlidesHelper.java b/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/IGoogleSlidesHelper.java
index 212616da3..fea9269ac 100644
--- a/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/IGoogleSlidesHelper.java
+++ b/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/IGoogleSlidesHelper.java
@@ -20,32 +20,44 @@ import androidx.test.uiautomator.UiObject2;
 /** An App Helper interface for Google Slides. */
 public interface IGoogleSlidesHelper extends IAppHelper {
     /**
-     * Setup expectation: Google Slides is open.
+     * Setup expectation: Google Slides is opened.
      *
      * <p>This method will open slides file from shared with me drawer.
+     *
+     * @throws UnknownUiException If the slides file cannot be opened.
      */
     void openSlidesFromSharedMenu();
 
     /**
-     * Setup expectation: Google Slides is open and open slide file.
+     * Setup expectation: Google Slides is opened.
      *
-     * <p>Check if device is now in Slides page.
+     * <p>Check if device is now in the Slides page.
      *
-     * @return Returns true if device is in Slides page, false if not.
+     * @return Returns true if device is in the Slides page, false if not.
      */
     boolean isOnSlidesPage();
 
     /**
-     * Setup expectation: Google Slides is open and open slide file..
+     * Setup expectation: Google Slides is opened and is in the Slides page.
      *
      * <p>This method will get a UiObject2 object for Slides page container
      */
     UiObject2 getScrollView();
 
     /**
-     * Setup expectation: Google Slides is open and open slide file.
+     * Setup expectation: Google Slides is opened and is in the Slides page.
      *
      * <p>This method will close slides file.
      */
     void closeSlides();
+
+    /**
+     * Setup expectation: Google Slides is open.
+     *
+     * <p>This method will open slides file by its title.
+     *
+     * @param title The title text of the slides file to open.
+     * @throws UnknownUiException If the slides file cannot be opened.
+     */
+    void openSlidesByTitle(String title);
 }
diff --git a/libraries/automotive-helpers/app-grid-helper/src/android/platform/helpers/AppGridHelperImpl.java b/libraries/automotive-helpers/app-grid-helper/src/android/platform/helpers/AppGridHelperImpl.java
index f7096842e..d1ec4075a 100644
--- a/libraries/automotive-helpers/app-grid-helper/src/android/platform/helpers/AppGridHelperImpl.java
+++ b/libraries/automotive-helpers/app-grid-helper/src/android/platform/helpers/AppGridHelperImpl.java
@@ -269,4 +269,44 @@ public class AppGridHelperImpl extends AbstractStandardAppHelper implements IAut
         getSpectatioUiUtil().pressHome();
         getSpectatioUiUtil().wait1Second();
     }
+
+    @Override
+    public void longTapAllAppsButton() {
+        BySelector appGridFacetSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.APP_GRID_FACET_BUTTON);
+        UiObject2 appGridFacet = getSpectatioUiUtil().findUiObject(appGridFacetSelector);
+        getSpectatioUiUtil().longPress(appGridFacet);
+    }
+
+    @Override
+    public void singleTapAllAppsButton() {
+        BySelector appGridFacetSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.APP_GRID_FACET_BUTTON);
+        UiObject2 appGridFacet = getSpectatioUiUtil().findUiObject(appGridFacetSelector);
+        getSpectatioUiUtil().clickAndWait(appGridFacet);
+    }
+
+    @Override
+    public boolean isRecentsScreenLaunched() {
+        BySelector recentAppsThumbnailSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.RECENT_APPS_THUMBNAIL);
+        return getSpectatioUiUtil().hasUiElement(recentAppsThumbnailSelector);
+    }
+
+    @Override
+    public boolean isAppPresentInAppgrid(String appName) {
+        BySelector appNameSelector = By.text(appName);
+
+        UiObject2 app =
+                mScrollUtility.scrollAndFindUiObject(
+                        mScrollAction,
+                        mScrollDirection,
+                        mForwardButtonSelector,
+                        mBackwardButtonSelector,
+                        mScrollableElementSelector,
+                        appNameSelector,
+                        String.format("Scroll on app grid to find %s", appName));
+
+        return app != null;
+    }
 }
diff --git a/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json b/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
index 2d947e304..12fe028fe 100644
--- a/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
+++ b/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
@@ -53,6 +53,9 @@
     "USER_SETTINGS_SCROLL_DIRECTION": "VERTICAL",
     "USER_SETTINGS_SCROLL_MARGIN": "6",
     "USER_SETTINGS_SCROLL_WAIT_TIME": "2",
+    "PRIVACY_SETTINGS_SCROLL_MARGIN": "10",
+    "PRIVACY_SETTINGS_SCROLL_WAIT_TIME": "10",
+    "PRIVACY_SETTINGS_SCROLL_ACTION": "USE_GESTURE",
     "ACCOUNT_SETTINGS_SCROLL_ACTION": "USE_GESTURE",
     "ACCOUNT_SETTINGS_SCROLL_DIRECTION": "VERTICAL",
     "SETTINGS_SUB_SETTING_SCROLL_ACTION": "USE_GESTURE",
@@ -69,7 +72,6 @@
     "OPEN_NOTIFICATIONS_COMMAND": "service call statusbar 1",
     "STOP_SETTING_APP_COMMAND": "am force-stop com.android.car.settings",
     "OPEN_SETTINGS_COMMAND": "am start --user $user_id -a android.settings.SETTINGS",
-    "MEDIA_LAUNCH_COMMAND": "am start --user $user_id -a android.car.intent.action.MEDIA_TEMPLATE -e android.car.intent.extra.MEDIA_COMPONENT com.android.bluetooth/com.android.bluetooth.avrcpcontroller.BluetoothMediaBrowserService",
     "MEDIA_LAUNCH_BLUETOOTH_AUDIO_COMMAND": "am start -a android.car.intent.action.MEDIA_TEMPLATE -e android.car.intent.extra.MEDIA_COMPONENT com.google.android.bluetooth/com.android.bluetooth.avrcpcontroller.BluetoothMediaBrowserService",
     "NIGHT_MODE_COMMAND": "dumpsys activity service com.android.car/.CarService day-night-mode  night",
     "DAY_MODE_COMMAND": "dumpsys activity service com.android.car/.CarService day-night-mode  day",
@@ -114,6 +116,11 @@
       "TYPE": "CLASS",
       "VALUE": "android.widget.EditText"
     },
+    "MOBILE_DIALPAD_TITLE_INPUT": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "title",
+      "PACKAGE": "com.android.car.dialer"
+    },
     "END_CALL": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "end_call_button",
@@ -825,7 +832,7 @@
     },
     "APP_INFO_SETTINGS_FORCE_STOP_BUTTON": {
       "TYPE": "TEXT",
-      "VALUE": "Force stop"
+      "VALUE": "Stop app"
     },
     "APP_INFO_SETTINGS_TITTLE": {
       "TYPE": "RESOURCE_ID",
@@ -901,6 +908,11 @@
       "VALUE": "notification_body_content",
       "PACKAGE": "com.android.systemui"
     },
+    "NOTIFICATION_SMS_COUNT": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "message_count",
+      "PACKAGE": "com.android.systemui"
+    },
     "NOTIFICATION_LIST_EMPTY": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "empty_notification_text",
@@ -1789,6 +1801,11 @@
       "VALUE": "fragment_container",
       "PACKAGE": "com.android.car.settings"
     },
+    "SETTINGS_UI_SCROLL_ELEMENT": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "car_ui_recycler_view",
+      "PACKAGE": "com.chassis.car.ui.plugin"
+    },
     "BLOCKING_MESSAGE": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "blocking_text",
@@ -1930,6 +1947,11 @@
       "VALUE": "summary",
       "PACKAGE": "android"
     },
+    "RECENT_APPS_THUMBNAIL": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "task_thumbnail",
+      "PACKAGE": "com.android.car.carlauncher"
+    },
     "CONTACT_NAME_TITLE": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "title",
@@ -2016,7 +2038,7 @@
     },
     "LOCATION_SETTINGS_RECENTLY_ACCESSED_MAPS": {
       "TYPE": "TEXT",
-      "VALUE": "Maps"
+      "VALUE": "Google Maps"
     },
     "LOCATION_SETTINGS_VIEW_ALL": {
       "TYPE": "TEXT",
@@ -2148,6 +2170,11 @@
       "TYPE": "TEXT",
       "VALUE": "Permission manager"
     },
+    "TURN_WIFI_AUTOMATICALLY_TOGGLE": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "switch_widget",
+      "PACKAGE": "android"
+    },
     "BLUETOOTH_CONNECTED_DISCONNECTED_TEXT": {
       "TYPE": "MULTIPLE",
       "SPECIFIERS": [
@@ -2269,6 +2296,14 @@
         }
       ]
     },
+    "WIFI_PREFERENCES": {
+      "TYPE": "TEXT",
+      "VALUE": "WiFi preferences"
+    },
+    "JOIN_OTHER_NETWORK": {
+      "TYPE": "TEXT",
+      "VALUE": "Join other network"
+    },
     "PHONE_CARD_DIALER_BUTTON": {
       "TYPE": "MULTIPLE",
       "SPECIFIERS": [
@@ -2401,6 +2436,19 @@
           "VALUE": "android.widget.Switch"
         }
       ]
+    },
+    "PRIVACY_OTHER_PERMISSIONS":
+        {
+          "TYPE": "TEXT",
+          "VALUE": "Other permissions"
+    },
+    "CAR_INFORMATION": {
+      "TYPE": "TEXT",
+      "VALUE": "Car information"
+    },
+    "PERMISSION_USED_BY_SYSTEM": {
+      "TYPE": "TEXT",
+      "VALUE": "Permission used by the system"
     }
   },
   "WORKFLOWS": {
diff --git a/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java b/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
index 452ecdb93..055ccb095 100644
--- a/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
+++ b/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
@@ -187,6 +187,7 @@ public class AutomotiveConfigConstants {
     public static final String NOTIFICATION_BODY = "NOTIFICATION_BODY";
     public static final String NOTIFICATION_TITLE = "NOTIFICATION_TITLE";
     public static final String NOTIFICATION_CONTENT = "NOTIFICATION_CONTENT";
+    public static final String NOTIFICATION_SMS_COUNT = "NOTIFICATION_SMS_COUNT";
     public static final String NOTIFICATION_LIST_EMPTY = "NOTIFICATION_LIST_EMPTY";
     public static final String NOTIFICATION_LIST_SCROLL_FORWARD_BUTTON =
             "NOTIFICATION_LIST_SCROLL_FORWARD_BUTTON";
@@ -309,7 +310,6 @@ public class AutomotiveConfigConstants {
 
     // Media Center
     public static final String MEDIA_CENTER_PACKAGE = "MEDIA_CENTER_PACKAGE";
-    public static final String MEDIA_LAUNCH_COMMAND = "MEDIA_LAUNCH_COMMAND";
     // Media Center Screen
     public static final String PLAY_PAUSE_BUTTON = "PLAY_PAUSE_BUTTON";
     public static final String MEDIA_SONGS_LIST = "MEDIA_SONGS_LIST";
@@ -579,8 +579,11 @@ public class AutomotiveConfigConstants {
     public static final String NETWORK_PALETTE_WIFI = "NETWORK_PALETTE_WIFI";
     public static final String NETWORK_PALETTE_SUMMARY = "NETWORK_PALETTE_SUMMARY";
     public static final String NETWORK_PALETTE_SWITCH_WIDGET = "NETWORK_PALETTE_SWITCH_WIDGET";
+    public static final String TURN_WIFI_AUTOMATICALLY_TOGGLE = "TURN_WIFI_AUTOMATICALLY_TOGGLE";
     public static final String CONNECTED_WIFI = "CONNECTED_WIFI";
     public static final String FORGET_WIFI = "FORGET_WIFI";
+    public static final String WIFI_PREFERENCES = "WIFI_PREFERENCES";
+    public static final String JOIN_OTHER_NETWORK = "JOIN_OTHER_NETWORK";
     public static final String CLOCK_TIME = "CLOCK_TIME";
     public static final String DATE_COMMAND = "DATE_COMMAND";
     public static final String ADAPTIVE_BRIGHTNESS_COMMAND = "ADAPTIVE_BRIGHTNESS_COMMAND";
@@ -630,9 +633,16 @@ public class AutomotiveConfigConstants {
     public static final String SETTINGS_BACK_BUTTON = "SETTINGS_BACK_BUTTON";
     public static final String SETTINGS_UI_SUB_SETTING_SCROLL_ELEMENT =
             "SETTINGS_UI_SUB_SETTING_SCROLL_ELEMENT";
+    public static final String SETTINGS_UI_SCROLL_ELEMENT = "SETTINGS_UI_SCROLL_ELEMENT";
     public static final String SETTINGS_PERMISSIONS_BACK_BUTTON =
             "SETTINGS_PERMISSIONS_BACK_BUTTON";
-
+    public static final String CAR_INFORMATION = "CAR_INFORMATION";
+    public static final String PRIVACY_OTHER_PERMISSIONS = "PRIVACY_OTHER_PERMISSIONS";
+    public static final String PERMISSION_USED_BY_SYSTEM = "PERMISSION_USED_BY_SYSTEM";
+    public static final String PRIVACY_SETTINGS_SCROLL_WAIT_TIME =
+            "PRIVACY_SETTINGS_SCROLL_WAIT_TIME";
+    public static final String PRIVACY_SETTINGS_SCROLL_MARGIN = "PRIVACY_SETTINGS_SCROLL_MARGIN";
+    public static final String PRIVACY_SETTINGS_SCROLL_ACTION = "PRIVACY_SETTINGS_SCROLL_ACTION";
     // Storage Settings
     public static final String STORAGE_SYSTEM_SUB_SETTINGS = "STORAGE_SYSTEM_SUB_SETTINGS";
     public static final String STORAGE_MUSIC_AUDIO_SETTINGS = "STORAGE_MUSIC_AUDIO_SETTINGS";
@@ -713,6 +723,7 @@ public class AutomotiveConfigConstants {
     public static final String MOBILE_PHONE_ICON = "MOBILE_PHONE_ICON";
     public static final String PHONE_DEVICE_PACKAGE = "PHONE_DEVICE_PACAKAGE";
     public static final String MOBILE_DIALPAD_INPUT = "MOBILE_DIALPAD_INPUT";
+    public static final String MOBILE_DIALPAD_TITLE_INPUT = "MOBILE_DIALPAD_TITLE_INPUT";
 
     // Phone Card Identifiers
     public static final String PHONE_CARD_DIALER_BUTTON = "PHONE_CARD_DIALER_BUTTON";
@@ -743,4 +754,6 @@ public class AutomotiveConfigConstants {
 
     // Soft Keyboard UI elements
     public static final String SOFT_KEYBOARD_HIDE_BUTTON = "SOFT_KEYBOARD_HIDE_BUTTON";
+
+    public static final String RECENT_APPS_THUMBNAIL = "RECENT_APPS_THUMBNAIL";
 }
diff --git a/libraries/automotive-helpers/dial-app-helper/src/android/platform/helpers/DialHelperImpl.java b/libraries/automotive-helpers/dial-app-helper/src/android/platform/helpers/DialHelperImpl.java
index 384a57444..3d64127de 100644
--- a/libraries/automotive-helpers/dial-app-helper/src/android/platform/helpers/DialHelperImpl.java
+++ b/libraries/automotive-helpers/dial-app-helper/src/android/platform/helpers/DialHelperImpl.java
@@ -175,7 +175,7 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
 
     /** {@inheritDoc} */
     public void dialANumber(String phoneNumber) {
-        enterNumber(phoneNumber);
+        enterNumberOnDialpad(phoneNumber);
         getSpectatioUiUtil().wait1Second();
     }
 
@@ -427,6 +427,7 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
         openSearchContact();
         UiObject2 searchBox = getSearchBox();
         searchBox.setText(contact);
+        getSpectatioUiUtil().wait15Seconds(); // Wait for the Search results to appear
     }
 
     /** {@inheritDoc} */
@@ -434,6 +435,7 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
         openSearchContact();
         UiObject2 searchBox = getSearchBox();
         searchBox.setText(number);
+        getSpectatioUiUtil().wait15Seconds(); // Wait for the Search results to appear
     }
 
     /** {@inheritDoc} */
@@ -785,6 +787,10 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
         getSpectatioUiUtil().validateUiObject(dialPad, AutomotiveConfigConstants.DIAL_PAD_FRAGMENT);
         char[] array = phoneNumber.toCharArray();
         for (char ch : array) {
+            boolean shouldLongPressZero = ch == '+';
+            if (shouldLongPressZero) {
+                ch = '0';
+            }
             UiObject2 numberButton =
                     getSpectatioUiUtil()
                             .findUiObject(getUiElementFromConfig(Character.toString(ch)));
@@ -794,8 +800,42 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
             getSpectatioUiUtil()
                     .validateUiObject(
                             numberButton, String.format("Number %s", Character.toString(ch)));
-            getSpectatioUiUtil().clickAndWait(numberButton);
+            if (shouldLongPressZero) {
+                getSpectatioUiUtil().longPress(numberButton);
+            } else {
+                getSpectatioUiUtil().clickAndWait(numberButton);
+            }
+        }
+    }
+
+    /**
+     * This method is used to enter phonenumber from the on-screen number input text field
+     *
+     * @param phoneNumber number to be dialed
+     */
+    private void enterNumberOnDialpad(String phoneNumber) {
+        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {
+            throw new IllegalArgumentException("No phone number provided");
         }
+        getSpectatioUiUtil().pressHome();
+        getSpectatioUiUtil().wait1Second();
+        getSpectatioUiUtil()
+                .executeShellCommand(
+                        getCommandFromConfig(AutomotiveConfigConstants.OPEN_DIAL_PAD_COMMAND));
+        BySelector dialPadMenuSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.DIAL_PAD_MENU);
+        UiObject2 dialMenuButton = getSpectatioUiUtil().findUiObject(dialPadMenuSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(dialMenuButton, AutomotiveConfigConstants.DIAL_PAD_MENU);
+        getSpectatioUiUtil().clickAndWait(dialMenuButton);
+        getSpectatioUiUtil().wait1Second();
+        BySelector dialPadInputSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.MOBILE_DIALPAD_TITLE_INPUT);
+        UiObject2 dialPadInput = getSpectatioUiUtil().findUiObject(dialPadInputSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(
+                        dialPadInput, AutomotiveConfigConstants.MOBILE_DIALPAD_TITLE_INPUT);
+        dialPadInput.setText(phoneNumber);
     }
 
     /** This method is used check if ongoing call is displayed on home. */
@@ -925,4 +965,12 @@ public class DialHelperImpl extends AbstractStandardAppHelper implements IAutoDi
                 getUiElementFromConfig(AutomotiveConfigConstants.DIALER_SETTINGS_BUTTON);
         return getSpectatioUiUtil().hasUiElement(dialerSettingsSelector);
     }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean isConnectToBluetoothDisplayed() {
+        BySelector dialerSettingsSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.CONNECT_TO_BLUETOOTH);
+        return getSpectatioUiUtil().hasUiElement(dialerSettingsSelector);
+    }
 }
diff --git a/libraries/automotive-helpers/home-helper/src/android/platform/helpers/HomeHelperImpl.java b/libraries/automotive-helpers/home-helper/src/android/platform/helpers/HomeHelperImpl.java
index 761883a66..00e2a8fea 100644
--- a/libraries/automotive-helpers/home-helper/src/android/platform/helpers/HomeHelperImpl.java
+++ b/libraries/automotive-helpers/home-helper/src/android/platform/helpers/HomeHelperImpl.java
@@ -55,6 +55,18 @@ public class HomeHelperImpl extends AbstractStandardAppHelper implements IAutoHo
         return getSpectatioUiUtil().hasUiElement(bluetoothWidgetSelector);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void openBluetoothButton() {
+        BySelector bluetoothButtonSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.STATUS_BAR_BLUETOOTH_BUTTON);
+        UiObject2 bluetoothButton = getSpectatioUiUtil().findUiObject(bluetoothButtonSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(
+                        bluetoothButton, AutomotiveConfigConstants.STATUS_BAR_BLUETOOTH_BUTTON);
+        getSpectatioUiUtil().clickAndWait(bluetoothButton);
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean hasNetworkButton() {
@@ -63,6 +75,17 @@ public class HomeHelperImpl extends AbstractStandardAppHelper implements IAutoHo
         return getSpectatioUiUtil().hasUiElement(networkWidgetSelector);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void openNetworkPalette() {
+        BySelector networkButtonSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.NETWORK_PALETTE);
+        UiObject2 networkButton = getSpectatioUiUtil().findUiObject(networkButtonSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(networkButton, AutomotiveConfigConstants.NETWORK_PALETTE);
+        getSpectatioUiUtil().clickAndWait(networkButton);
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean hasDisplayBrightness() {
@@ -71,6 +94,25 @@ public class HomeHelperImpl extends AbstractStandardAppHelper implements IAutoHo
         return getSpectatioUiUtil().hasUiElement(displayBrightnessWidgetSelector);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean hasSoundSettings() {
+        BySelector soundSettingsWidgetSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.SOUND_FACET_BUTTON);
+        return getSpectatioUiUtil().hasUiElement(soundSettingsWidgetSelector);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void openSoundSettingsPalette() {
+        BySelector soundSettingsSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.SOUND_FACET_BUTTON);
+        UiObject2 soundSettings = getSpectatioUiUtil().findUiObject(soundSettingsSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(soundSettings, AutomotiveConfigConstants.SOUND_FACET_BUTTON);
+        getSpectatioUiUtil().clickAndWait(soundSettings);
+    }
+
     public boolean hasAssistantWidget() {
         BySelector assistantWidgetSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.HOME_TOP_CARD);
diff --git a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
index 4052637bb..abbef3663 100644
--- a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
+++ b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
@@ -40,6 +40,8 @@ import java.util.regex.Pattern;
 /** Helper class for functional test for Mediacenter test */
 public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements IAutoMediaHelper {
 
+    private static final String LOG_TAG = MediaCenterHelperImpl.class.getSimpleName();
+
     private MediaSessionManager mMediaSessionManager;
     private UiAutomation mUiAutomation;
 
@@ -77,8 +79,9 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
      */
     @Override
     public void exit() {
+        Log.i(LOG_TAG, "Going to the Homescreen");
         getSpectatioUiUtil().pressHome();
-        getSpectatioUiUtil().wait1Second();
+        getSpectatioUiUtil().waitNSeconds(5);
     }
 
     /**
@@ -129,26 +132,30 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
     }
 
     private void openMediaApp() {
+        Log.i(LOG_TAG, "Opening the media application");
         getSpectatioUiUtil().pressHome();
         getSpectatioUiUtil().waitForIdle();
         getSpectatioUiUtil()
                 .executeShellCommand(
-                        getCommandFromConfig(AutomotiveConfigConstants.MEDIA_LAUNCH_COMMAND));
+                        getCommandFromConfig(
+                                AutomotiveConfigConstants.MEDIA_LAUNCH_BLUETOOTH_AUDIO_COMMAND));
     }
 
     /**
      * {@inheritDoc}
      */
     public void playMedia() {
-        if (!isPlaying()) {
-            BySelector playButtonSelector =
-                    getUiElementFromConfig(AutomotiveConfigConstants.PLAY_PAUSE_BUTTON);
-            UiObject2 playButton = getSpectatioUiUtil().findUiObject(playButtonSelector);
-            getSpectatioUiUtil()
-                    .validateUiObject(playButton, AutomotiveConfigConstants.PLAY_PAUSE_BUTTON);
-            getSpectatioUiUtil().clickAndWait(playButton);
-            getSpectatioUiUtil().wait5Seconds();
+        Log.i(LOG_TAG, "Playing the media song");
+        if (isPlaying()) {
+            return;
         }
+        BySelector playButtonSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.PLAY_PAUSE_BUTTON);
+        UiObject2 playButton = getSpectatioUiUtil().findUiObject(playButtonSelector);
+        getSpectatioUiUtil()
+                .validateUiObject(playButton, AutomotiveConfigConstants.PLAY_PAUSE_BUTTON);
+        getSpectatioUiUtil().clickAndWait(playButton);
+        getSpectatioUiUtil().waitForIdle();
     }
 
     /**
@@ -163,13 +170,14 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
                         playButtonHomeScreen,
                         AutomotiveConfigConstants.PLAY_PAUSE_BUTTON_HOME_SCREEN);
         getSpectatioUiUtil().clickAndWait(playButtonHomeScreen);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitForIdle();
     }
 
     /**
      * {@inheritDoc}
      */
     public void pauseMedia() {
+        Log.i(LOG_TAG, "Pausing the song");
         if (!isPlaying()) {
             playMedia();
         }
@@ -179,18 +187,20 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
         getSpectatioUiUtil()
                 .validateUiObject(pauseButton, AutomotiveConfigConstants.PLAY_PAUSE_BUTTON);
         getSpectatioUiUtil().clickAndWait(pauseButton);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitForIdle();
+        Log.i(LOG_TAG, "Song should be paused");
     }
 
     /** {@inheritDoc} */
     public void clickNextTrack() {
+        Log.i(LOG_TAG, "Click the next track");
         BySelector nextTrackButtonSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.NEXT_BUTTON);
         UiObject2 nextTrackButton = getSpectatioUiUtil().findUiObject(nextTrackButtonSelector);
         getSpectatioUiUtil()
                 .validateUiObject(nextTrackButton, AutomotiveConfigConstants.NEXT_BUTTON);
         getSpectatioUiUtil().clickAndWait(nextTrackButton);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitForIdle();
     }
 
     /**
@@ -206,13 +216,14 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
                         nextTrackHomeScreenButton,
                         AutomotiveConfigConstants.NEXT_BUTTON_HOME_SCREEN);
         getSpectatioUiUtil().clickAndWait(nextTrackHomeScreenButton);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitForIdle();
     }
 
     /**
      * {@inheritDoc}
      */
     public void clickPreviousTrack() {
+        Log.i(LOG_TAG, "Click the previous track");
         BySelector previousTrackButtonSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.PREVIOUS_BUTTON);
         UiObject2 previousTrackMediaCenterButton =
@@ -221,7 +232,7 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
                 .validateUiObject(
                         previousTrackMediaCenterButton, AutomotiveConfigConstants.PREVIOUS_BUTTON);
         getSpectatioUiUtil().clickAndWait(previousTrackMediaCenterButton);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitForIdle();
     }
 
     /**
@@ -365,12 +376,11 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
      */
     @Override
     public void minimizeNowPlaying() {
-        Log.d("media_test", "Trying to minimize now");
+        Log.i(LOG_TAG, "Minizing the Now Playing");
         getSpectatioUiUtil().wait5Seconds();
         BySelector trackNameSelector = getUiElementFromConfig(AutomotiveConfigConstants.TRACK_NAME);
         UiObject2 trackNameText = getSpectatioUiUtil().findUiObject(trackNameSelector);
         if (trackNameText != null) {
-            Log.d("media_test", "Trying to swipe now ");
             trackNameText.swipe(Direction.DOWN, 1.0f, 500);
         }
     }
@@ -381,6 +391,7 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
      */
     @Override
     public void maximizeNowPlaying() {
+        Log.i(LOG_TAG, "Maximizing the Now Playing");
         BySelector trackNameSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.MINIMIZED_MEDIA_CONTROLS);
         UiObject2 trackNameText = getSpectatioUiUtil().findUiObject(trackNameSelector);
@@ -410,6 +421,7 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
      */
     @Override
     public boolean isPlaying() {
+        Log.i(LOG_TAG, "Checking if the song is playing");
         List<MediaController> controllers = mMediaSessionManager.getActiveSessions(null);
         if (controllers.size() == 0) {
             throw new RuntimeException("Unable to find Media Controller");
@@ -420,6 +432,7 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
 
     @Override
     public boolean isPaused() {
+        Log.i(LOG_TAG, "Checking if the song is paused");
         List<MediaController> controllers = mMediaSessionManager.getActiveSessions(null);
         if (controllers.size() == 0) {
             throw new RuntimeException("Unable to find Media Controller");
@@ -572,6 +585,14 @@ public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements
         return getSpectatioUiUtil().hasUiElement(connectToBluetoothLabel);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean isCancelButtonVisible() {
+        BySelector cancelBluetoothAudioConncetionButton =
+                getUiElementFromConfig(AutomotiveConfigConstants.CANCEL_BT_AUDIO_CONNECTION_BUTTON);
+        return getSpectatioUiUtil().hasUiElement(cancelBluetoothAudioConncetionButton);
+    }
+
     private UiObject2 scrollAndFindApp(BySelector selector) {
 
         UiObject2 object =
diff --git a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/TestMediaAppHelperImpl.java b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/TestMediaAppHelperImpl.java
index 4eba6745e..4d5dd3441 100644
--- a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/TestMediaAppHelperImpl.java
+++ b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/TestMediaAppHelperImpl.java
@@ -17,6 +17,7 @@
 package android.platform.helpers;
 
 import android.app.Instrumentation;
+import android.util.Log;
 
 import androidx.test.uiautomator.BySelector;
 import androidx.test.uiautomator.UiObject2;
@@ -26,6 +27,7 @@ import java.util.List;
 /** Helper class for Test Media app for MediaCenter test */
 public class TestMediaAppHelperImpl extends AbstractStandardAppHelper
         implements IAutoTestMediaAppHelper {
+    private static final String LOG_TAG = TestMediaAppHelperImpl.class.getSimpleName();
     // Wait Time
     private static final int SHORT_RESPONSE_WAIT_MS = 1000;
 
@@ -84,6 +86,7 @@ public class TestMediaAppHelperImpl extends AbstractStandardAppHelper
     }
 
     private void selectSongInTestMediaApp() {
+        Log.i(LOG_TAG, "Select Song In TestMediaApp");
         BySelector songListSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.MEDIA_SONGS_LIST);
 
@@ -91,8 +94,9 @@ public class TestMediaAppHelperImpl extends AbstractStandardAppHelper
         getSpectatioUiUtil()
                 .validateUiObjects(songList, AutomotiveConfigConstants.MEDIA_SONGS_LIST);
         getSpectatioUiUtil().clickAndWait(songList.get(1));
-        getSpectatioUiUtil().wait1Second();
+        getSpectatioUiUtil().waitForIdle();
 
+        Log.i(LOG_TAG, "Minimize the window");
         // minimize songs
         BySelector goBackToSongsListSelector =
                 getUiElementFromConfig(AutomotiveConfigConstants.MEDIA_APP_NAVIGATION_ICON);
@@ -100,7 +104,8 @@ public class TestMediaAppHelperImpl extends AbstractStandardAppHelper
         getSpectatioUiUtil()
                 .validateUiObject(
                         goBackToSongsList, AutomotiveConfigConstants.MEDIA_APP_NAVIGATION_ICON);
-        getSpectatioUiUtil().wait1Second();
+        getSpectatioUiUtil().clickAndWait(goBackToSongsList);
+        getSpectatioUiUtil().waitForIdle();
     }
 
     private void clickAndWait(String autoConfigConstants, String fieldName) {
@@ -111,7 +116,7 @@ public class TestMediaAppHelperImpl extends AbstractStandardAppHelper
                 .validateUiObject(
                         mediaTestAppField, String.format("Test Media App field: %s", fieldName));
         getSpectatioUiUtil().clickAndWait(mediaTestAppField);
-        getSpectatioUiUtil().wait1Second();
+        getSpectatioUiUtil().waitForIdle();
     }
 
 }
diff --git a/libraries/automotive-helpers/notifications-app-helper/src/android/platform/helpers/AutoNotificationHelperImpl.java b/libraries/automotive-helpers/notifications-app-helper/src/android/platform/helpers/AutoNotificationHelperImpl.java
index df93a8105..8c0e3a48b 100644
--- a/libraries/automotive-helpers/notifications-app-helper/src/android/platform/helpers/AutoNotificationHelperImpl.java
+++ b/libraries/automotive-helpers/notifications-app-helper/src/android/platform/helpers/AutoNotificationHelperImpl.java
@@ -115,6 +115,118 @@ public class AutoNotificationHelperImpl extends AbstractStandardAppHelper
         return getSpectatioUiUtil().hasUiElement(notificationViewSelector);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean checkNotificationExists(String title) {
+        open();
+        BySelector selector = By.text(title);
+        UiObject2 postedNotification = findInNotificationList(selector);
+        return postedNotification != null;
+    }
+
+    /**
+     * Setup expectations: None.
+     *
+     * <p>Find notification with specific title in notification center.
+     */
+    @Override
+    public UiObject2 findNotificationInCenterWithTitle(String title) {
+        Log.i(LOG_TAG, "Searching for notification in the notification center with title: " + title);
+
+        List<UiObject2> notifications = getNotifications();
+        for (UiObject2 notification : notifications) {
+            UiObject2 titleObj = notification.findObject(
+                getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_TITLE)
+            );
+            String titleText = titleObj.getText().toLowerCase();
+            if (titleObj != null && titleText.contains(title.toLowerCase())) {
+                return notification;
+            }
+        }
+
+        Log.w(LOG_TAG, "Cannot find notification in the notification center with title: " + title);
+        return null;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean isNotificationDisplayedInCenterWithTitle(String title) {
+        Log.i(LOG_TAG, "Checking if notification in the notification center with title: " + title + " is displayed.");
+        UiObject2 notification = findNotificationInCenterWithTitle(title);
+        return notification != null;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean isNotificationDisplayedInCenterWithContent(String content) {
+        Log.i(LOG_TAG, "Checking if notification in the notification center with content: " + content + " is displayed.");
+
+        List<UiObject2> notifications = getNotifications();
+        for (UiObject2 notification : notifications) {
+            UiObject2 contentObj = notification.findObject(
+                getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_CONTENT)
+            );
+            String contentText = contentObj.getText().toLowerCase();
+            if (contentObj != null && contentText.contains(content.toLowerCase())) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public String getNotificationContent(String title) {
+        Log.i(LOG_TAG, String.format("Getting the content of notification in the notification center with title %s.", title));
+
+        UiObject2 notification = findNotificationInCenterWithTitle(title);
+        UiObject2 content = notification.findObject(
+            getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_CONTENT)
+        );
+        if (content == null) {
+            throw new RuntimeException(String.format("Cannot find content for notification with title '%s'.", title));
+        }
+
+        return content.getText();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public int getSmsNotificationCount(String title) {
+        Log.i(LOG_TAG, String.format("Getting the count of SMS notification in the notification center with title %s.", title));
+
+        UiObject2 notification = findNotificationInCenterWithTitle(title);
+        UiObject2 smsCount = notification.findObject(
+            getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_SMS_COUNT)
+        );
+        if (smsCount == null) {
+            throw new RuntimeException(String.format("Cannot find SMS count for notification with title '%s'.", title));
+        }
+
+        String smsCountText = smsCount.getText();
+        Log.i(LOG_TAG, "Sms count text: " + smsCountText);
+        int count = Integer.parseInt(smsCountText.split("")[0]);
+
+        return count;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public String getSmsNotificationContent(String title) {
+        Log.i(LOG_TAG, String.format("Getting the content of SMS notification in the notification center with title %s.", title));
+
+        // Click on SMS count to expand the notification and get the content. If present.
+        UiObject2 notification = findNotificationInCenterWithTitle(title);
+        UiObject2 smsCount = notification.findObject(
+            getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_SMS_COUNT)
+        );
+        if (smsCount != null) {
+            getSpectatioUiUtil().clickAndWait(smsCount);
+        }
+        return getNotificationContent(title);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void tapClearAllBtn() {
@@ -159,63 +271,6 @@ public class AutoNotificationHelperImpl extends AbstractStandardAppHelper
         }
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public boolean checkNotificationExists(String title) {
-        open();
-        BySelector selector = By.text(title);
-        UiObject2 postedNotification = findInNotificationList(selector);
-        return postedNotification != null;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public boolean isNotificationDisplayedInCenterWithTitle(String title) {
-        Log.i(
-                LOG_TAG,
-                "Checking if notification with title: "
-                        + title
-                        + " is displayed in the notification center.");
-
-        List<UiObject2> notifications = getNotifications();
-        for (UiObject2 notification : notifications) {
-            UiObject2 titleObj = notification.findObject(
-                getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_TITLE)
-            );
-            String titleText = titleObj.getText().toLowerCase();
-            Log.i("Title: ", "" + titleText);
-            if (titleObj != null && titleText.contains(title.toLowerCase())) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public boolean isNotificationDisplayedInCenterWithContent(String content) {
-        Log.i(
-                LOG_TAG,
-                "Checking if notification with content: "
-                        + content
-                        + " is displayed in the notification center.");
-
-        List<UiObject2> notifications = getNotifications();
-        for (UiObject2 notification : notifications) {
-            UiObject2 contentObj = notification.findObject(
-                getUiElementFromConfig(AutomotiveConfigConstants.NOTIFICATION_CONTENT)
-            );
-            String contentText = contentObj.getText().toLowerCase();
-            Log.i("Content: ", "" + contentText);
-            if (contentObj != null && contentText.contains(content.toLowerCase())) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
     @Override
     public boolean checkAppPermissionsExists(String title) {
         return getSpectatioUiUtil().hasUiElement(title);
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
index e24ffc3ea..3fbacdad5 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
@@ -488,7 +488,7 @@ public class SettingHelperImpl extends AbstractStandardAppHelper implements IAut
     /** {@inheritDoc} */
     @Override
     public boolean isRecentAppDisplayedInLocationSettings(String app) {
-        UiObject2 recentApp = getSpectatioUiUtil().findUiObject("Maps");
+        UiObject2 recentApp = getSpectatioUiUtil().findUiObject("Google Maps");
         getSpectatioUiUtil()
                 .validateUiObject(recentApp, String.format("Recently accessed app - %s", app));
         UiObject2 recentAppsTime = recentApp.getParent();
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
index d03530cd0..317f8504a 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
@@ -229,6 +229,13 @@ public class SettingsAppInfoHelperImpl extends AbstractStandardAppHelper
         }
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void selectAppAndEnableDisableApp(String application, State state) {
+        selectApp(application);
+        enableDisableApplication(state);
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean isCurrentApplicationRunning() {
@@ -252,6 +259,17 @@ public class SettingsAppInfoHelperImpl extends AbstractStandardAppHelper
         getSpectatioUiUtil().clickAndWait(okBtn);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean isStopappPopupDisplayed() {
+        UiObject2 forceStopButton = getForceStopButton();
+        getSpectatioUiUtil().clickAndWait(forceStopButton);
+        BySelector okBtnSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.APP_INFO_SETTINGS_OK_BUTTON);
+        UiObject2 okBtn = getSpectatioUiUtil().findUiObject(okBtnSelector);
+        return okBtn != null;
+    }
+
     /** {@inheritDoc} */
     @Override
     public void setAppPermission(String permission, State state) {
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsPrivacyHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsPrivacyHelperImpl.java
index c2fd4077e..60acdb5f8 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsPrivacyHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsPrivacyHelperImpl.java
@@ -16,6 +16,8 @@
 package android.platform.helpers;
 
 import android.app.Instrumentation;
+import android.platform.helpers.ScrollUtility.ScrollActions;
+import android.platform.helpers.ScrollUtility.ScrollDirection;
 
 import androidx.test.uiautomator.By;
 import androidx.test.uiautomator.BySelector;
@@ -25,8 +27,46 @@ import androidx.test.uiautomator.UiObject2;
 public class SettingsPrivacyHelperImpl extends AbstractStandardAppHelper
         implements IAutoPrivacySettingsHelper {
     private static final int MAX_WAIT_COUNT = 5;
+    private static final int WAIT_TIME = 10000;
+
+    private HelperAccessor<IAutoUISettingsHelper> mSettingUIHelper;
+    private ScrollUtility mScrollUtility;
+    private ScrollActions mScrollAction;
+    private BySelector mBackwardButtonSelector;
+    private BySelector mForwardButtonSelector;
+    private BySelector mScrollableElementSelector;
+    private ScrollDirection mScrollDirection;
+
     public SettingsPrivacyHelperImpl(Instrumentation instr) {
         super(instr);
+        mSettingUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
+
+        mScrollUtility = ScrollUtility.getInstance(getSpectatioUiUtil());
+        mScrollAction =
+                ScrollActions.valueOf(
+                        getActionFromConfig(
+                                AutomotiveConfigConstants.PRIVACY_SETTINGS_SCROLL_ACTION));
+        mBackwardButtonSelector =
+                getUiElementFromConfig(
+                        AutomotiveConfigConstants.SETTINGS_SUB_SETTING_SCROLL_BACKWARD_BUTTON);
+        mForwardButtonSelector =
+                getUiElementFromConfig(
+                        AutomotiveConfigConstants.SETTINGS_SUB_SETTING_SCROLL_FORWARD_BUTTON);
+        mScrollableElementSelector =
+                getUiElementFromConfig(
+                        AutomotiveConfigConstants.SETTINGS_SUB_SETTING_SCROLL_ELEMENT);
+        mScrollDirection =
+                ScrollDirection.valueOf(
+                        getActionFromConfig(
+                                AutomotiveConfigConstants.SETTINGS_SUB_SETTING_SCROLL_DIRECTION));
+        mScrollUtility.setScrollValues(
+                Integer.valueOf(
+                        getActionFromConfig(
+                                AutomotiveConfigConstants.PRIVACY_SETTINGS_SCROLL_MARGIN)),
+                Integer.valueOf(
+                        getActionFromConfig(
+                                AutomotiveConfigConstants.PRIVACY_SETTINGS_SCROLL_WAIT_TIME)));
+        mSettingUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
     }
     /** {@inheritDoc} */
     @Override
@@ -391,6 +431,7 @@ public class SettingsPrivacyHelperImpl extends AbstractStandardAppHelper
         getSpectatioUiUtil()
                 .validateUiObject(locationObject, AutomotiveConfigConstants.PRIVACY_LOCATION);
         getSpectatioUiUtil().clickAndWait(locationObject);
+        getSpectatioUiUtil().wait5Seconds();
         getSpectatioUiUtil().waitForIdle();
     }
 
@@ -405,4 +446,37 @@ public class SettingsPrivacyHelperImpl extends AbstractStandardAppHelper
         getSpectatioUiUtil().clickAndWait(homeMic);
         getSpectatioUiUtil().waitForIdle();
     }
+
+    /** {@inheritDoc} */
+    @Override
+    public void clickOtherPermissionsPage() {
+        BySelector otherPermissionSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.PRIVACY_OTHER_PERMISSIONS);
+        UiObject2 otherPermissionObject =
+                mScrollUtility.scrollAndFindUiObject(
+                        mScrollAction,
+                        mScrollDirection,
+                        mForwardButtonSelector,
+                        mBackwardButtonSelector,
+                        mScrollableElementSelector,
+                        otherPermissionSelector,
+                        String.format(
+                                "Scroll on Manage Permission to find  %s",
+                                otherPermissionSelector));
+        getSpectatioUiUtil().waitNSeconds(WAIT_TIME);
+        getSpectatioUiUtil()
+                .validateUiObject(
+                        otherPermissionObject,
+                        String.format("Unable to find UI Element %s.", otherPermissionSelector));
+        getSpectatioUiUtil().clickAndWait(otherPermissionObject);
+        BySelector permissionUsedSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.PERMISSION_USED_BY_SYSTEM);
+        getSpectatioUiUtil().waitForUiObject(permissionUsedSelector, WAIT_TIME);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean isCarInformationUIElementDisplayed() {
+        return mSettingUIHelper.get().hasUIElement(AutomotiveConfigConstants.CAR_INFORMATION);
+    }
 }
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSoundsHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSoundsHelperImpl.java
index 7bc0c377d..1ffe92c80 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSoundsHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSoundsHelperImpl.java
@@ -80,13 +80,6 @@ public class SettingsSoundsHelperImpl extends AbstractStandardAppHelper
                 ScrollDirection.valueOf(
                         getActionFromConfig(
                                 AutomotiveConfigConstants.SOUND_SETTINGS_LIST_SCROLL_DIRECTION));
-        mScrollUtility.setScrollValues(
-                Integer.valueOf(
-                        getActionFromConfig(
-                                AutomotiveConfigConstants.SOUND_SETTINGS_SCROLL_MARGIN)),
-                Integer.valueOf(
-                        getActionFromConfig(
-                                AutomotiveConfigConstants.SOUND_SETTINGS_SCROLL_WAIT_TIME)));
     }
 
     /** {@inheritDoc} */
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
index 8da2bd912..14b009968 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
@@ -41,6 +41,7 @@ public class SettingsSystemHelperImpl extends AbstractStandardAppHelper
     private BySelector mForwardButtonSelector;
     private BySelector mScrollableElementSelector;
     private ScrollDirection mScrollDirection;
+    private static final int TWENTY_SECONDS_WAIT_TIME = 20000;
 
     public SettingsSystemHelperImpl(Instrumentation instr) {
         super(instr);
@@ -361,6 +362,10 @@ public class SettingsSystemHelperImpl extends AbstractStandardAppHelper
     @Override
     public boolean verifyUsageinGB(String option) {
         boolean isUsageinGB = false;
+        BySelector scrollSelector =
+                getUiElementFromConfig(
+                        AutomotiveConfigConstants.SETTINGS_UI_SUB_SETTING_SCROLL_ELEMENT);
+        getSpectatioUiUtil().waitForUiObject(scrollSelector, TWENTY_SECONDS_WAIT_TIME);
         List<UiObject2> scrollElements =
                 getSpectatioUiUtil()
                         .findUiObjects(
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsUIHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsUIHelperImpl.java
index 8f0d33d9f..3b5a62f7e 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsUIHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsUIHelperImpl.java
@@ -96,6 +96,27 @@ public class SettingsUIHelperImpl extends AbstractStandardAppHelper
         return isElementPresent;
     }
 
+    @Override
+    public boolean hasSettingsMenu(String element) {
+        boolean isElementPresent;
+        BySelector elementSelector = getUiElementFromConfig(element);
+        BySelector settingsMenu =
+                getUiElementFromConfig(AutomotiveConfigConstants.SETTINGS_UI_SCROLL_ELEMENT);
+        isElementPresent = getSpectatioUiUtil().hasUiElement(elementSelector);
+        if (!isElementPresent) {
+            isElementPresent =
+                    mScrollUtility.scrollAndCheckIfUiElementExist(
+                            mScrollAction,
+                            mScrollDirection,
+                            mForwardButtonSelector,
+                            mBackwardButtonSelector,
+                            settingsMenu,
+                            elementSelector,
+                            "scroll and find UI Element");
+        }
+        return isElementPresent;
+    }
+
     /** {@inheritDoc} */
     @Override
     public void openUIOptions(String targetConstant) {
diff --git a/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java b/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
index 60012c7d1..9b2f39dab 100644
--- a/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
+++ b/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
@@ -31,6 +31,7 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.Random;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -59,6 +60,8 @@ public class PerfettoHelper {
     private static final String REMOVE_CMD = "rm %s";
     // Add the trace output file /data/misc/perfetto-traces/trace_output.perfetto-trace
     private static final String CREATE_FILE_CMD = "touch %s";
+    // Command to check the file size.
+    private static final String CHECK_FILE_SIZE_CMD = "wc -c %s";
     // Command to copy the perfetto output trace file to given folder.
     private static final String COPY_CMD = "cp %s %s";
     // Command to set the read permission for all users on the given file.
@@ -83,6 +86,7 @@ public class PerfettoHelper {
     private String mConfigFileName;
     private boolean mIsTextProtoConfig;
     private boolean mTrackPerfettoPidFlag;
+    private boolean mCheckEmptyMetrics = false;
     private String mTrackPerfettoRootDir = "sdcard/";
     private File mPerfettoPidFile;
 
@@ -98,8 +102,12 @@ public class PerfettoHelper {
      *                      sessions happening at the same time
      */
     public PerfettoHelper(String tmpFilePrefix) {
-        mTmpOutputFilePath = "/data/misc/perfetto-traces/" + tmpFilePrefix
-                + "trace_output.perfetto-trace";
+        mTmpOutputFilePath =
+                "/data/misc/perfetto-traces/"
+                        + tmpFilePrefix
+                        + "_trace_output_"
+                        + new Random().nextInt(100)
+                        + ".perfetto-trace";
     }
 
     /** Set content of the perfetto configuration to be used when tracing */
@@ -291,9 +299,7 @@ public class PerfettoHelper {
         Log.i(LOG_TAG, String.format("Perfetto output file cleanup - %s", output));
 
         // Create new temporary output trace file before tracing.
-        output =
-                mUIDevice.executeShellCommand(
-                        String.format(CREATE_FILE_CMD, mTmpOutputFilePath));
+        output = mUIDevice.executeShellCommand(String.format(CREATE_FILE_CMD, mTmpOutputFilePath));
         if (output.isEmpty()) {
             Log.i(LOG_TAG, "Perfetto output file create success.");
         } else {
@@ -487,6 +493,24 @@ public class PerfettoHelper {
      * @return true if the trace file copied successfully otherwise false.
      */
     private boolean copyFileOutput(String destinationFile) {
+        // Check if the perfetto trace file is empty. If yes, then do not copy the file.
+        if (mCheckEmptyMetrics) {
+            try {
+                String checkFileSizeResult =
+                        mUIDevice.executeShellCommand(
+                                String.format(CHECK_FILE_SIZE_CMD, mTmpOutputFilePath));
+                Log.i(LOG_TAG, "checkFileSizeResult = " + checkFileSizeResult);
+                String[] result = checkFileSizeResult.split("\\s+");
+                if (Integer.parseInt(result[0]) == 0) {
+                    Log.i(LOG_TAG, "Perfetto trace file is empty.");
+                    return false;
+                }
+            } catch (IOException ioe) {
+                Log.e(LOG_TAG, "Unable to check the perfetto trace file size." + ioe.getMessage());
+                return false;
+            }
+        }
+
         // Create the destination directory if it doesn't already exist.
         Path path = Paths.get(destinationFile);
         String destDirectory = path.getParent().toString();
@@ -508,8 +532,9 @@ public class PerfettoHelper {
         //       Moreover, the copied trace file may end up with different permissions, resulting
         //       in b/162072200, to prevent this, ensure the files are readable after copying
         try {
-            String copyResult = mUIDevice.executeShellCommand(String.format(
-                    COPY_CMD, mTmpOutputFilePath, destinationFile));
+            String copyResult =
+                    mUIDevice.executeShellCommand(
+                            String.format(COPY_CMD, mTmpOutputFilePath, destinationFile));
             if (!copyResult.isEmpty()) {
                 Log.e(LOG_TAG, String.format(
                         "Unable to copy perfetto output file from %s to %s due to %s",
@@ -529,9 +554,11 @@ public class PerfettoHelper {
             String removeResult = mUIDevice.executeShellCommand(String.format(
                     REMOVE_CMD, mTmpOutputFilePath));
             if (!removeResult.isEmpty()) {
-                Log.e(LOG_TAG, String.format(
-                        "Unable to remove temporary perfetto output file %s due to %s",
-                        mTmpOutputFilePath, removeResult));
+                Log.e(
+                        LOG_TAG,
+                        String.format(
+                                "Unable to remove temporary perfetto output file %s due to %s",
+                                mTmpOutputFilePath, removeResult));
                 return false;
             }
         } catch (IOException ioe) {
@@ -543,6 +570,10 @@ public class PerfettoHelper {
         return true;
     }
 
+    public void setCheckEmptyMetrics(Boolean flag) {
+        mCheckEmptyMetrics = flag;
+    }
+
     public void setPerfettoConfigRootDir(String rootDir) {
         mConfigRootDir = rootDir;
     }
diff --git a/libraries/collectors-helper/simpleperf/src/com/android/helpers/SimpleperfHelper.java b/libraries/collectors-helper/simpleperf/src/com/android/helpers/SimpleperfHelper.java
index c56660b75..5f3761887 100644
--- a/libraries/collectors-helper/simpleperf/src/com/android/helpers/SimpleperfHelper.java
+++ b/libraries/collectors-helper/simpleperf/src/com/android/helpers/SimpleperfHelper.java
@@ -148,8 +148,8 @@ public class SimpleperfHelper {
      */
     public boolean stopSimpleperf() throws IOException {
         if (!isSimpleperfRunning()) {
-            Log.e(LOG_TAG, "Simpleperf stop called, but simpleperf is not running.");
-            return false;
+            Log.i(LOG_TAG, "Simpleperf stop called, but simpleperf is not running.");
+            return true;
         }
 
         String stopOutput = mUiDevice.executeShellCommand(SIMPLEPERF_STOP_CMD);
diff --git a/libraries/compatibility-common-util/src/com/android/compatibility/common/util/BackupUtils.java b/libraries/compatibility-common-util/src/com/android/compatibility/common/util/BackupUtils.java
index ccc89110a..dd8be8d56 100644
--- a/libraries/compatibility-common-util/src/com/android/compatibility/common/util/BackupUtils.java
+++ b/libraries/compatibility-common-util/src/com/android/compatibility/common/util/BackupUtils.java
@@ -24,12 +24,15 @@ import static java.util.stream.Collectors.joining;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.io.Closeables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.FormatMethod;
+import com.google.errorprone.annotations.FormatString;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.nio.charset.StandardCharsets;
+import java.util.Locale;
 import java.util.Scanner;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
@@ -46,6 +49,8 @@ public abstract class BackupUtils {
     private static final String LOCAL_TRANSPORT_PACKAGE = "com.android.localtransport";
     public static final String LOCAL_TRANSPORT_TOKEN = "1";
 
+    private static final int USER_SYSTEM = 0;
+
     private static final int BACKUP_PROVISIONING_TIMEOUT_SECONDS = 30;
     private static final int BACKUP_PROVISIONING_POLL_INTERVAL_SECONDS = 1;
     private static final long BACKUP_SERVICE_INIT_TIMEOUT_SECS = TimeUnit.MINUTES.toSeconds(2);
@@ -53,7 +58,7 @@ public abstract class BackupUtils {
     private static final Pattern BACKUP_MANAGER_CURRENTLY_ENABLE_STATUS_PATTERN =
             Pattern.compile("^Backup Manager currently (enabled|disabled)$");
     private static final String MATCH_LINE_BACKUP_MANAGER_IS_NOT_PENDING_INIT =
-            "(?s)" + "^Backup Manager is .* not pending init.*";  // DOTALL
+            "Backup Manager is .* not pending init.*"; // DOTALL
     private static final String MATCH_LINE_ONLY_GMS_BACKUP_TRANSPORT_PENDING_INIT =
             "(?s)" + ".*Pending init: 1.*com.google.android.gms/.backup.BackupTransportService.*";
 
@@ -66,6 +71,12 @@ public abstract class BackupUtils {
     @CanIgnoreReturnValue
     protected abstract InputStream executeShellCommand(String command) throws IOException;
 
+    @FormatMethod
+    protected final InputStream executeShellCommand(
+            @FormatString String commandTemplate, Object... commandArgs) throws IOException {
+        return executeShellCommand(String.format(Locale.ENGLISH, commandTemplate, commandArgs));
+    }
+
     public void executeShellCommandSync(String command) throws IOException {
         StreamUtil.drainAndClose(new InputStreamReader(executeShellCommand(command)));
     }
@@ -77,6 +88,12 @@ public abstract class BackupUtils {
         return result;
     }
 
+    @FormatMethod
+    protected final String getShellCommandOutput(
+            @FormatString String commandTemplate, Object... commandArgs) throws IOException {
+        return getShellCommandOutput(String.format(Locale.ENGLISH, commandTemplate, commandArgs));
+    }
+
     /** Executes shell command "bmgr backupnow <package>" and assert success. */
     public void backupNowAndAssertSuccess(String packageName) throws IOException {
         assertBackupIsSuccessful(packageName, backupNow(packageName));
@@ -120,9 +137,16 @@ public abstract class BackupUtils {
         return StreamUtil.readInputStream(restore(token, packageName));
     }
 
+    /** Executes shell command "bmgr wipe <transport> <package>" and assert success. */
+    public void wipeAndAssertSuccess(String transport, String packageName) throws IOException {
+        String output = wipe(transport, packageName);
+        if (!output.startsWith("Wiped backup data for ")) {
+            fail("Wipe not successful");
+        }
+    }
+
     public boolean isLocalTransportSelected() throws IOException {
-        return getShellCommandOutput("bmgr list transports")
-                .contains("* " + getLocalTransportName());
+        return isLocalTransportSelectedForUser(getCurrentUserId());
     }
 
     /**
@@ -130,12 +154,12 @@ public abstract class BackupUtils {
      * transport and returns {@code true} if the local transport is the selected one.
      */
     public boolean isLocalTransportSelectedForUser(int userId) throws IOException {
-        return getShellCommandOutput(String.format("bmgr --user %d list transports", userId))
+        return getShellCommandOutput("bmgr --user %d list transports", userId)
                 .contains("* " + getLocalTransportName());
     }
 
     public boolean isBackupEnabled() throws IOException {
-        return getShellCommandOutput("bmgr enabled").contains("currently enabled");
+        return isBackupEnabledForUser(getCurrentUserId());
     }
 
     /**
@@ -143,7 +167,7 @@ public abstract class BackupUtils {
      * user {@code userId}.
      */
     public boolean isBackupEnabledForUser(int userId) throws IOException {
-        return getShellCommandOutput(String.format("bmgr --user %d enabled", userId))
+        return getShellCommandOutput("bmgr --user %d enabled", userId)
                 .contains("currently enabled");
     }
 
@@ -161,9 +185,37 @@ public abstract class BackupUtils {
                 ? LOCAL_TRANSPORT_NAME : LOCAL_TRANSPORT_NAME_PRE_Q;
     }
 
-    /** Executes "bmgr backupnow <package>" and returns an {@link InputStream} for its output. */
+    /** Toggles scheduling enabled or disabled. */
+    public String setSchedulingEnabled(boolean enabled) throws IOException {
+        return setSchedulingEnabled(enabled, getCurrentUserId());
+    }
+
+    /**
+     * Toggles scheduling enabled or disabled for given user.
+     *
+     * <p>Executes "bmgr --user USER_ID scheduling BOOL".
+     */
+    public String setSchedulingEnabled(boolean enabled, int userId) throws IOException {
+        return getShellCommandOutput(
+                "bmgr --user %d scheduling %b", userId, enabled);
+    }
+
+    /** Cancels backup for current user and returns its output. */
+    public String cancelBackups() throws IOException {
+        return cancelBackupsForUser(getCurrentUserId());
+    }
+
+    /**
+     * Cancels backup for given user and returns its output.
+     *
+     * <p>Executes "bmgr --user USER_ID cancel backups".
+     */
+    public String cancelBackupsForUser(int userId) throws IOException {
+        return getShellCommandOutput("bmgr --user %d cancel backups", userId);
+    }
+
     private InputStream backupNow(String packageName) throws IOException {
-        return executeShellCommand("bmgr backupnow " + packageName);
+        return backupNowForUser(packageName, getCurrentUserId());
     }
 
     /**
@@ -171,8 +223,7 @@ public abstract class BackupUtils {
      * output.
      */
     private InputStream backupNowForUser(String packageName, int userId) throws IOException {
-        return executeShellCommand(
-                String.format("bmgr --user %d backupnow %s", userId, packageName));
+        return executeShellCommand("bmgr --user %d backupnow %s", userId, packageName);
     }
 
     /**
@@ -226,12 +277,8 @@ public abstract class BackupUtils {
         }
     }
 
-    /**
-     * Executes "bmgr restore <token> <packageName>" and returns an {@link InputStream} for its
-     * output.
-     */
     private InputStream restore(String token, String packageName) throws IOException {
-        return executeShellCommand(String.format("bmgr restore %s %s", token, packageName));
+        return restoreForUser(token, packageName, getCurrentUserId());
     }
 
     /**
@@ -240,8 +287,7 @@ public abstract class BackupUtils {
      */
     private InputStream restoreForUser(String token, String packageName, int userId)
             throws IOException {
-        return executeShellCommand(
-                String.format("bmgr --user %d restore %s %s", userId, token, packageName));
+        return executeShellCommand("bmgr --user %d restore %s %s", userId, token, packageName);
     }
 
     /**
@@ -266,6 +312,17 @@ public abstract class BackupUtils {
         }
     }
 
+    private String wipe(String transport, String packageName) throws IOException {
+        return wipeForUser(transport, packageName, getCurrentUserId());
+    }
+
+    /** Executes "bmgr --user <id> wipe <transport> <package>" and returns its output. */
+    private String wipeForUser(String transport, String packageName, int userId)
+            throws IOException {
+        return getLineString(
+                executeShellCommand("bmgr --user %d wipe %s %s", userId, transport, packageName));
+    }
+
     /**
      * Execute shell command and return output from this command.
      */
@@ -284,8 +341,9 @@ public abstract class BackupUtils {
 
     // Copied over from BackupQuotaTest
     public boolean enableBackup(boolean enable) throws Exception {
+        int userId = getCurrentUserId();
         boolean previouslyEnabled;
-        String output = getLineString(executeShellCommand("bmgr enabled"));
+        String output = getLineString(executeShellCommand("bmgr --user %d enabled", userId));
         Matcher matcher = BACKUP_MANAGER_CURRENTLY_ENABLE_STATUS_PATTERN.matcher(output.trim());
         if (matcher.find()) {
             previouslyEnabled = "enabled".equals(matcher.group(1));
@@ -293,7 +351,7 @@ public abstract class BackupUtils {
             throw new RuntimeException("non-parsable output setting bmgr enabled: " + output);
         }
 
-        Closeables.closeQuietly(executeShellCommand("bmgr enable " + enable));
+        Closeables.closeQuietly(executeShellCommand("bmgr --user %d enable %s", userId, enable));
         return previouslyEnabled;
     }
 
@@ -318,10 +376,20 @@ public abstract class BackupUtils {
      * the user {@code userId}.
      */
     public boolean isBackupActivatedForUser(int userId) throws IOException {
-        return getShellCommandOutput(String.format("bmgr --user %d activated", userId))
+        return getShellCommandOutput("bmgr --user %d activated", userId)
                 .contains("currently activated");
     }
 
+    /** Returns the current user ID obtained from "am get-current-user". */
+    public int getCurrentUserId() throws IOException {
+        String out = getShellCommandOutput("am get-current-user");
+        try {
+            return Integer.parseInt(out.trim());
+        } catch (NumberFormatException e) {
+            throw new RuntimeException("Failed to parse user id", e);
+        }
+    }
+
     private String getLineString(InputStream inputStream) throws IOException {
         BufferedReader reader =
                 new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
@@ -340,13 +408,22 @@ public abstract class BackupUtils {
         return reader.lines().collect(joining());
     }
 
+    private String getPatternForBackupManagerIsNotPendingInit(int userId) {
+        String userIdPrefix = "";
+        if (userId != USER_SYSTEM) {
+            userIdPrefix = "User " + userId + ":";
+        }
+        return "(?s)^" + userIdPrefix + MATCH_LINE_BACKUP_MANAGER_IS_NOT_PENDING_INIT;
+    }
+
     /** Blocks until all backup transports has initialised */
     public void waitForBackupInitialization() throws IOException {
+        int userId = getCurrentUserId();
         long tryUntilNanos = System.nanoTime()
                 + TimeUnit.SECONDS.toNanos(BACKUP_PROVISIONING_TIMEOUT_SECONDS);
         while (System.nanoTime() < tryUntilNanos) {
             String output = getLineString(executeShellCommand("dumpsys backup"));
-            if (output.matches(MATCH_LINE_BACKUP_MANAGER_IS_NOT_PENDING_INIT)) {
+            if (output.matches(getPatternForBackupManagerIsNotPendingInit(userId))) {
                 return;
             }
             try {
@@ -364,11 +441,12 @@ public abstract class BackupUtils {
      * initialised yet.
      */
     public void waitForNonGmsTransportInitialization() throws IOException {
+        int userId = getCurrentUserId();
         long tryUntilNanos =
                 System.nanoTime() + TimeUnit.SECONDS.toNanos(BACKUP_PROVISIONING_TIMEOUT_SECONDS);
         while (System.nanoTime() < tryUntilNanos) {
             String output = getAllLinesString(executeShellCommand("dumpsys backup"));
-            if (output.matches(MATCH_LINE_BACKUP_MANAGER_IS_NOT_PENDING_INIT)) {
+            if (output.matches(getPatternForBackupManagerIsNotPendingInit(userId))) {
                 return;
             }
             if (output.matches(MATCH_LINE_ONLY_GMS_BACKUP_TRANSPORT_PENDING_INIT)) {
@@ -408,9 +486,7 @@ public abstract class BackupUtils {
      */
     public boolean userHasBackupTransport(String transport, int userId) throws IOException {
         String output =
-                getLineString(
-                        executeShellCommand(
-                                String.format("bmgr --user %d list transports", userId)));
+                getLineString(executeShellCommand("bmgr --user %d list transports", userId));
         for (String t : output.split("\n")) {
             // Parse out the '*' character used to denote the selected transport.
             t = t.replace("*", "").trim();
@@ -421,6 +497,20 @@ public abstract class BackupUtils {
         return false;
     }
 
+    /**
+     * Sets the local transport for the current user and returns the previously selected transport.
+     */
+    public String setLocalTransport() throws IOException {
+        return setBackupTransport(getLocalTransportName());
+    }
+
+    /**
+     * Sets the backup transport for the current user and returns the previously selected transport.
+     */
+    public String setBackupTransport(String transport) throws IOException {
+        return setBackupTransportForUser(transport, getCurrentUserId());
+    }
+
     /**
      * Executes shell command "bmgr --user <id> transport <transport>" and returns the old
      * transport.
diff --git a/libraries/compatibility-common-util/tests/src/com/android/compatibility/common/util/BackupUtilsTest.java b/libraries/compatibility-common-util/tests/src/com/android/compatibility/common/util/BackupUtilsTest.java
index 9749709c9..926996ae3 100644
--- a/libraries/compatibility-common-util/tests/src/com/android/compatibility/common/util/BackupUtilsTest.java
+++ b/libraries/compatibility-common-util/tests/src/com/android/compatibility/common/util/BackupUtilsTest.java
@@ -16,13 +16,14 @@
 
 package com.android.compatibility.common.util;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.android.tradefed.util.RunUtil;
 
+import com.google.common.truth.Expect;
+
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,6 +31,9 @@ import org.junit.runners.JUnit4;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.regex.Pattern;
 
 /**
  * Unit tests for {@link BackupUtils}
@@ -37,427 +41,307 @@ import java.io.InputStream;
 @RunWith(JUnit4.class)
 public class BackupUtilsTest {
     private static final int BACKUP_SERVICE_INIT_TIMEOUT_SECS = 1;
-    private static final int TEST_USER_ID = 10;
+
+    private static final Pattern ENABLE_COMMAND_PATTERN =
+            Pattern.compile("bmgr --user \\d+ enable (true|false)$");
+    private static final Pattern ACTIVATE_COMMAND_PATTERN =
+            Pattern.compile("bmgr --user \\d+ activate (true|false)$");
+
+    @Rule public final Expect expect = Expect.create();
 
     private boolean mIsDumpsysCommandCalled;
     private boolean mIsEnableCommandCalled;
     private boolean mIsActivateCommandCalled;
 
+    private BackupUtils mBackupUtils;
+
+    // Map of command -> mock output.
+    private final HashMap<String, String> mMockCommandOutputMap = new HashMap<>();
+
+    // Map of command -> mock exception.
+    private final HashMap<String, IOException> mMockCommandExceptionMap = new HashMap<>();
+
+    private void onCommandReturns(String command, String output) {
+        mMockCommandOutputMap.put(command, output);
+    }
+
+    private void onCommandFails(String command, IOException ex) {
+        mMockCommandExceptionMap.put(command, ex);
+    }
+
     @Before
     public void setUp() {
         mIsDumpsysCommandCalled = false;
         mIsEnableCommandCalled = false;
+        mIsActivateCommandCalled = false;
+
+        mMockCommandExceptionMap.clear();
+        mMockCommandOutputMap.clear();
+        // Returns the system user 0 by default.
+        mMockCommandOutputMap.put("am get-current-user", "0");
+
+        mBackupUtils =
+                new BackupUtils() {
+                    @Override
+                    protected InputStream executeShellCommand(String command) throws IOException {
+                        if (command.equals("dumpsys backup")
+                                || command.equals("dumpsys backup users")) {
+                            mIsDumpsysCommandCalled = true;
+                        } else if (ENABLE_COMMAND_PATTERN.matcher(command).find()) {
+                            mIsEnableCommandCalled = true;
+                        } else if (ACTIVATE_COMMAND_PATTERN.matcher(command).find()) {
+                            mIsActivateCommandCalled = true;
+                        }
+
+                        IOException ex = mMockCommandExceptionMap.get(command);
+                        if (ex != null) {
+                            throw ex;
+                        }
+
+                        String output = mMockCommandOutputMap.get(command);
+                        if (output == null) {
+                            fail("Unexpected shell command: " + command);
+                        }
+                        return new ByteArrayInputStream(output.getBytes(StandardCharsets.UTF_8));
+                    }
+                };
     }
 
     @Test
     public void testEnableBackup_whenEnableTrueAndEnabled_returnsTrue() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently enabled";
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        assertTrue(backupUtils.enableBackup(true));
-        assertTrue(mIsEnableCommandCalled);
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently enabled");
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled");
+        expect.that(mBackupUtils.enableBackup(true)).isTrue();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenEnableTrueAndDisabled_returnsFalse() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently disabled";
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        assertFalse(backupUtils.enableBackup(true));
-        assertTrue(mIsEnableCommandCalled);
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently disabled");
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled");
+        expect.that(mBackupUtils.enableBackup(true)).isFalse();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenEnableFalseAndEnabled_returnsTrue() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently enabled";
-                } else if (command.equals("bmgr enable false")) {
-                    output = "Backup Manager now disabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        assertTrue(backupUtils.enableBackup(false));
-        assertTrue(mIsEnableCommandCalled);
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently enabled");
+        onCommandReturns("bmgr --user 0 enable false", "Backup Manager now disabled");
+        expect.that(mBackupUtils.enableBackup(false)).isTrue();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenEnableFalseAndDisabled_returnsFalse() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently disabled";
-                } else if (command.equals("bmgr enable false")) {
-                    output = "Backup Manager now disabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        assertFalse(backupUtils.enableBackup(false));
-        assertTrue(mIsEnableCommandCalled);
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently disabled");
+        onCommandReturns("bmgr --user 0 enable false", "Backup Manager now disabled");
+        expect.that(mBackupUtils.enableBackup(false)).isFalse();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenEnableTrueAndEnabledAndCommandsReturnMultipleLines()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently enabled" + "\n...";
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled" + "\n...";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        assertTrue(backupUtils.enableBackup(true));
-        assertTrue(mIsEnableCommandCalled);
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently enabled\n...");
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled\n...");
+        expect.that(mBackupUtils.enableBackup(true)).isTrue();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenQueryCommandThrows_propagatesException() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    throw new IOException(String.format(
-                            "enableBackup: Failed to run command: %s", command));
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled");
+        onCommandFails(
+                "bmgr --user 0 enabled",
+                new IOException("enableBackup: Failed to run command: bmgr --user 0 enabled"));
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.enableBackup(true);
+            mBackupUtils.enableBackup(true);
         } catch (IOException e) {
             // enableBackup: Failed to run command: bmgr enabled
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertFalse(mIsEnableCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsEnableCommandCalled).isFalse();
     }
 
     @Test
     public void testEnableBackup_whenSetCommandThrows_propagatesException() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager currently enabled";
-                } else if (command.equals("bmgr enable true")) {
-                    mIsEnableCommandCalled = true;
-                    throw new IOException(String.format(
-                            "enableBackup: Failed to run command: %s", command));
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager currently enabled");
+        onCommandFails(
+                "bmgr --user 0 enable true",
+                new IOException("enableBackup: Failed to run command: bmgr --user 0 enable true"));
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.enableBackup(true);
+            mBackupUtils.enableBackup(true);
         } catch (IOException e) {
             // enableBackup: Failed to run command: bmgr enable true
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertTrue(mIsEnableCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsEnableCommandCalled).isTrue();
     }
 
     @Test
     public void testEnableBackup_whenQueryCommandReturnsInvalidString_throwsException()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    output = "Backup Manager ???";
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandReturns("bmgr --user 0 enabled", "Backup Manager ???");
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled");
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.enableBackup(true);
+            mBackupUtils.enableBackup(true);
         } catch (RuntimeException e) {
             // non-parsable output setting bmgr enabled: Backup Manager ???
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertFalse(mIsEnableCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsEnableCommandCalled).isFalse();
     }
 
     @Test
     public void testEnableBackup_whenQueryCommandReturnsEmptyString_throwsException()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("bmgr enabled")) {
-                    // output is empty already
-                } else if (command.equals("bmgr enable true")) {
-                    output = "Backup Manager now enabled";
-                    mIsEnableCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandReturns("bmgr --user 0 enabled", ""); // output is empty
+        onCommandReturns("bmgr --user 0 enable true", "Backup Manager now enabled");
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.enableBackup(true);
+            mBackupUtils.enableBackup(true);
         } catch (NullPointerException e) {
             // null output by running command, bmgr enabled
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertFalse(mIsEnableCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsEnableCommandCalled).isFalse();
     }
 
     @Test
     public void testWaitForBackupInitialization_whenEnabled() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup")) {
-                    output = "Backup Manager is enabled / provisioned / not pending init";
-                    mIsDumpsysCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        backupUtils.waitForBackupInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup", "Backup Manager is enabled / provisioned / not pending init");
+        mBackupUtils.waitForBackupInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void testWaitForBackupInitialization_whenDisabled() throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup")) {
-                    output = "Backup Manager is disabled / provisioned / not pending init";
-                    mIsDumpsysCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        backupUtils.waitForBackupInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup", "Backup Manager is disabled / provisioned / not pending init");
+        mBackupUtils.waitForBackupInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
+    }
+
+    @Test
+    public void testWaitForBackupInitialization_whenNonSystemUser() throws Exception {
+        onCommandReturns("am get-current-user", "10"); // non-system user
+        onCommandReturns(
+                "dumpsys backup",
+                "User 10:Backup Manager is enabled / provisioned / not pending init");
+        mBackupUtils.waitForBackupInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void waitForNonGmsTransportInitialization_whenEnabled() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals("dumpsys backup")) {
-                            output = "Backup Manager is enabled / provisioned / not pending init";
-                            mIsDumpsysCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        backupUtils.waitForNonGmsTransportInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup", "Backup Manager is enabled / provisioned / not pending init");
+        mBackupUtils.waitForNonGmsTransportInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void waitForNonGmsTransportInitialization_whenPendingInitForGmsTransportOnly()
             throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals("dumpsys backup")) {
-                            output =
-                                    "Backup Manager is enabled / setup complete / pending init\n"
-                                            + "Pending init: 1\n    com.google.android.gms/.backup"
-                                            + ".BackupTransportService";
-                            mIsDumpsysCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        backupUtils.waitForNonGmsTransportInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup",
+                "Backup Manager is enabled / setup complete / pending init\n"
+                        + "Pending init: 1\n"
+                        + "    com.google.android.gms/.backup.BackupTransportService");
+        mBackupUtils.waitForNonGmsTransportInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void waitForNonGmsTransportInitialization_whenDisabled() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals("dumpsys backup")) {
-                            output = "Backup Manager is disabled / provisioned / not pending init";
-                            mIsDumpsysCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        backupUtils.waitForNonGmsTransportInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup", "Backup Manager is disabled / provisioned / not pending init");
+        mBackupUtils.waitForNonGmsTransportInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void testWaitUntilBackupServiceIsRunning_whenRunning_doesntThrow() throws Exception {
-        BackupUtils backupUtils = constructDumpsysForBackupUsers(TEST_USER_ID);
+        // User 10.
+        onCommandReturns("dumpsys backup users", "Backup Manager is running for users: 10");
 
         try {
-            backupUtils.waitUntilBackupServiceIsRunning(
-                    TEST_USER_ID, BACKUP_SERVICE_INIT_TIMEOUT_SECS);
+            // User 10.
+            mBackupUtils.waitUntilBackupServiceIsRunning(10, BACKUP_SERVICE_INIT_TIMEOUT_SECS);
         } catch (AssertionError e) {
             fail("BackupUtils#waitUntilBackupServiceIsRunning threw an exception");
         }
-        assertTrue(mIsDumpsysCommandCalled);
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void testWaitUntilBackupServiceIsRunning_whenNotRunning_throws() throws Exception {
-        // Pass in a different userId to not have the current one among running ids.
-        BackupUtils backupUtils = constructDumpsysForBackupUsers(TEST_USER_ID + 1);
+        // Pass in a different userId (11) to not have the current one among running ids.
+        onCommandReturns("dumpsys backup users", "Backup Manager is running for users: 11");
 
         boolean wasExceptionThrown = false;
         try {
-            backupUtils.waitUntilBackupServiceIsRunning(
-                    TEST_USER_ID, BACKUP_SERVICE_INIT_TIMEOUT_SECS);
+            // User 10.
+            mBackupUtils.waitUntilBackupServiceIsRunning(10, BACKUP_SERVICE_INIT_TIMEOUT_SECS);
         } catch (AssertionError e) {
             wasExceptionThrown = true;
         }
 
-        assertTrue(mIsDumpsysCommandCalled);
-        assertTrue(wasExceptionThrown);
-    }
-
-    private BackupUtils constructDumpsysForBackupUsers(int runningUserId) {
-        return new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup users")) {
-                    output = "Backup Manager is running for users: " + runningUserId;
-                    mIsDumpsysCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        expect.that(mIsDumpsysCommandCalled).isTrue();
+        expect.that(wasExceptionThrown).isTrue();
     }
 
     @Test
     public void testWaitForBackupInitialization_whenEnabledAndCommandReturnsMultipleLines()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup")) {
-                    output = "Backup Manager is enabled / provisioned / not pending init" + "\n...";
-                    mIsDumpsysCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
-        backupUtils.waitForBackupInitialization();
-        assertTrue(mIsDumpsysCommandCalled);
+        onCommandReturns(
+                "dumpsys backup",
+                "Backup Manager is enabled / provisioned / not pending init\n...");
+        mBackupUtils.waitForBackupInitialization();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void testWaitForBackupInitialization_whenCommandThrows_propagatesException()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup")) {
-                    mIsDumpsysCommandCalled = true;
-                    throw new IOException(String.format(
-                            "waitForBackupInitialization: Failed to run command: %s", command));
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandFails(
+                "dumpsys backup",
+                new IOException(
+                        "waitForBackupInitialization: Failed to run command: dumpsys backup"));
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.waitForBackupInitialization();
+            mBackupUtils.waitForBackupInitialization();
         } catch (IOException e) {
             // waitForBackupInitialization: Failed to run command: dumpsys backup
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertTrue(mIsDumpsysCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
     }
 
     @Test
     public void testWaitForBackupInitialization_whenCommandReturnsInvalidString()
             throws Exception {
+        onCommandReturns("dumpsys backup", "Backup Manager ???");
+
         class TestRunnable implements Runnable {
             @Override
             public void run() {
                 try {
-                    BackupUtils backupUtils = new BackupUtils() {
-                        @Override
-                        protected InputStream executeShellCommand(String command)
-                                throws IOException {
-                            String output = "";
-                            if (command.equals("dumpsys backup")) {
-                                output = "Backup Manager ???";
-                                mIsDumpsysCommandCalled = true;
-                            }
-                            return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                        }
-                    };
-                    backupUtils.waitForBackupInitialization();
+                    mBackupUtils.waitForBackupInitialization();
                 } catch (IOException e) {
                     // ignore
                 }
@@ -470,8 +354,8 @@ public class BackupUtilsTest {
         try {
             testThread.start();
             RunUtil.getDefault().sleep(100);
-            assertTrue(mIsDumpsysCommandCalled);
-            assertTrue(testThread.isAlive());
+            expect.that(mIsDumpsysCommandCalled).isTrue();
+            expect.that(testThread.isAlive()).isTrue();
         } catch (Exception e) {
             // ignore
         } finally {
@@ -482,110 +366,81 @@ public class BackupUtilsTest {
     @Test
     public void testWaitForBackupInitialization_whenCommandReturnsEmptyString_throwsException()
             throws Exception {
-        BackupUtils backupUtils = new BackupUtils() {
-            @Override
-            protected InputStream executeShellCommand(String command) throws IOException {
-                String output = "";
-                if (command.equals("dumpsys backup")) {
-                    // output is empty already
-                    mIsDumpsysCommandCalled = true;
-                }
-                return new ByteArrayInputStream(output.getBytes("UTF-8"));
-            }
-        };
+        onCommandReturns("dumpsys backup", ""); // output is empty
 
         boolean isExceptionHappened = false;
         try {
-            backupUtils.waitForBackupInitialization();
+            mBackupUtils.waitForBackupInitialization();
         } catch (NullPointerException e) {
             // null output by running command, dumpsys backup
             isExceptionHappened = true;
         }
-        assertTrue(isExceptionHappened);
-        assertTrue(mIsDumpsysCommandCalled);
+        expect.that(isExceptionHappened).isTrue();
+        expect.that(mIsDumpsysCommandCalled).isTrue();
+    }
+
+    @Test
+    public void testWaitForBackupInitialization_whenUserIdDoesNotMatch() throws Exception {
+        onCommandReturns(
+                "dumpsys backup",
+                "User 10:Backup Manager is enabled / provisioned / not pending init");
+        onCommandReturns("am get-current-user", "11"); // User ID doesn't match.
+
+        class TestRunnable implements Runnable {
+            @Override
+            public void run() {
+                try {
+                    mBackupUtils.waitForBackupInitialization();
+                } catch (IOException e) {
+                    // ignore
+                }
+            }
+        }
+
+        TestRunnable testRunnable = new TestRunnable();
+        Thread testThread = new Thread(testRunnable);
+
+        try {
+            testThread.start();
+            RunUtil.getDefault().sleep(100);
+            expect.that(mIsDumpsysCommandCalled).isTrue();
+            expect.that(testThread.isAlive()).isTrue();
+        } catch (Exception e) {
+            // ignore
+        } finally {
+            testThread.interrupt();
+        }
     }
 
     @Test
     public void testActivateBackup_whenEnableTrueAndEnabled_returnsTrue() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals(getBmgrCommand("activated", TEST_USER_ID))) {
-                            output = "Backup Manager currently activated";
-                        } else if (command.equals(getBmgrCommand("activate true", TEST_USER_ID))) {
-                            output = "Backup Manager now activated";
-                            mIsActivateCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        assertTrue(backupUtils.activateBackupForUser(true, TEST_USER_ID));
-        assertTrue(mIsActivateCommandCalled);
+        onCommandReturns("bmgr --user 10 activated", "Backup Manager currently activated");
+        onCommandReturns("bmgr --user 10 activate true", "Backup Manager now activated");
+        expect.that(mBackupUtils.activateBackupForUser(true, 10)).isTrue();
+        expect.that(mIsActivateCommandCalled).isTrue();
     }
 
     @Test
     public void testActivateBackup_whenEnableTrueAndDisabled_returnsFalse() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals(getBmgrCommand("activated", TEST_USER_ID))) {
-                            output = "Backup Manager currently deactivated";
-                        } else if (command.equals(getBmgrCommand("activate true", TEST_USER_ID))) {
-                            output = "Backup Manager now activated";
-                            mIsActivateCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        assertFalse(backupUtils.activateBackupForUser(true, TEST_USER_ID));
-        assertTrue(mIsActivateCommandCalled);
+        onCommandReturns("bmgr --user 10 activated", "Backup Manager currently deactivated");
+        onCommandReturns("bmgr --user 10 activate true", "Backup Manager now activated");
+        expect.that(mBackupUtils.activateBackupForUser(true, 10)).isFalse();
+        expect.that(mIsActivateCommandCalled).isTrue();
     }
 
     @Test
     public void testActivateBackup_whenEnableFalseAndEnabled_returnsTrue() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals(getBmgrCommand("activated", TEST_USER_ID))) {
-                            output = "Backup Manager currently activated";
-                        } else if (command.equals(getBmgrCommand("activate false", TEST_USER_ID))) {
-                            output = "Backup Manager now deactivated";
-                            mIsActivateCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        assertTrue(backupUtils.activateBackupForUser(false, TEST_USER_ID));
-        assertTrue(mIsActivateCommandCalled);
+        onCommandReturns("bmgr --user 10 activated", "Backup Manager currently activated");
+        onCommandReturns("bmgr --user 10 activate false", "Backup Manager now deactivated");
+        expect.that(mBackupUtils.activateBackupForUser(false, 10)).isTrue();
+        expect.that(mIsActivateCommandCalled).isTrue();
     }
 
     @Test
     public void testActivateBackup_whenEnableFalseAndDisabled_returnsFalse() throws Exception {
-        BackupUtils backupUtils =
-                new BackupUtils() {
-                    @Override
-                    protected InputStream executeShellCommand(String command) throws IOException {
-                        String output = "";
-                        if (command.equals(getBmgrCommand("activated", TEST_USER_ID))) {
-                            output = "Backup Manager currently deactivated";
-                        } else if (command.equals(getBmgrCommand("activate false", TEST_USER_ID))) {
-                            output = "Backup Manager now deactivated";
-                            mIsActivateCommandCalled = true;
-                        }
-                        return new ByteArrayInputStream(output.getBytes("UTF-8"));
-                    }
-                };
-        assertFalse(backupUtils.activateBackupForUser(false, TEST_USER_ID));
-        assertTrue(mIsActivateCommandCalled);
-    }
-
-    private String getBmgrCommand(String command, int userId) {
-        return "bmgr --user " + userId + " " + command;
+        onCommandReturns("bmgr --user 10 activated", "Backup Manager currently deactivated");
+        onCommandReturns("bmgr --user 10 activate false", "Backup Manager now deactivated");
+        expect.that(mBackupUtils.activateBackupForUser(false, 10)).isFalse();
+        expect.that(mIsActivateCommandCalled).isTrue();
     }
 }
diff --git a/libraries/desktop-test-lib/Android.bp b/libraries/desktop-test-lib/Android.bp
index 6737d7567..14ace22a9 100644
--- a/libraries/desktop-test-lib/Android.bp
+++ b/libraries/desktop-test-lib/Android.bp
@@ -20,13 +20,17 @@ package {
 
 java_library {
     name: "desktop-test-lib",
-    libs: [
+    static_libs: [
         "androidx.test.runner",
         "androidx.test.rules",
         "kotlin-stdlib",
         "kotlinx_coroutines",
+        "mockito-target-minus-junit4",
+        "uiautomator-helpers",
+        "truth",
     ],
     srcs: [
         "src/**/*.kt",
+        "src/**/*.java",
     ],
 }
diff --git a/libraries/desktop-test-lib/TEST_MAPPING b/libraries/desktop-test-lib/TEST_MAPPING
new file mode 100644
index 000000000..013a93013
--- /dev/null
+++ b/libraries/desktop-test-lib/TEST_MAPPING
@@ -0,0 +1,7 @@
+{
+  "presubmit": [
+    {
+      "name": "DesktopTestLibTests"
+    }
+  ]
+}
diff --git a/libraries/desktop-test-lib/src/platform/android/test/desktop/SimulatedConnectedDisplayTestRule.kt b/libraries/desktop-test-lib/src/platform/android/test/desktop/SimulatedConnectedDisplayTestRule.kt
deleted file mode 100644
index 6ef049741..000000000
--- a/libraries/desktop-test-lib/src/platform/android/test/desktop/SimulatedConnectedDisplayTestRule.kt
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package platform.test.desktop
-
-import android.graphics.Point
-import android.hardware.display.DisplayManager
-import android.hardware.display.DisplayManager.DisplayListener
-import android.os.Handler
-import android.os.Looper
-import android.provider.Settings
-import android.util.Log
-import androidx.test.platform.app.InstrumentationRegistry
-import kotlin.time.Duration.Companion.seconds
-import kotlinx.coroutines.channels.awaitClose
-import kotlinx.coroutines.flow.Flow
-import kotlinx.coroutines.flow.callbackFlow
-import kotlinx.coroutines.flow.take
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.withTimeoutOrNull
-import org.junit.rules.TestRule
-import org.junit.runner.Description
-import org.junit.runners.model.Statement
-
-/**
- * A TestRule to manage multiple simulated connected overlay displays.
- */
-class SimulatedConnectedDisplayTestRule : TestRule {
-
-    private val context = InstrumentationRegistry.getInstrumentation().targetContext
-    private val displayManager = context.getSystemService(DisplayManager::class.java)
-    private val addedDisplays = mutableListOf<Int>()
-
-    override fun apply(base: Statement, description: Description): Statement =
-        object : Statement() {
-            override fun evaluate() {
-                try {
-                    base.evaluate()
-                } finally {
-                    teardown()
-                }
-            }
-        }
-
-    private fun teardown() {
-        cleanupTestDisplays()
-    }
-
-    /**
-     * Adds multiple overlay displays with specified dimensions. Any existing overlay displays
-     * will be removed before adding the new ones.
-     *
-     * @param displays A list of [Point] objects, where each [Point] represents the
-     *                 width and height of a simulated display.
-     * @return List of displayIds of added displays.
-     */
-    fun setupTestDisplays(displays: List<Point>): List<Int> = runBlocking {
-        // Cleanup any existing overlay displays.
-        cleanupTestDisplays()
-
-        if (displays.isEmpty()) {
-            Log.w(TAG, "setupTestDisplays called with an empty list. No displays created.")
-            return@runBlocking emptyList()
-        }
-
-        val displayAddedFlow: Flow<Int> = callbackFlow {
-            val listener = object : DisplayListener {
-                override fun onDisplayAdded(displayId: Int) {
-                    trySend(displayId)
-                }
-
-                override fun onDisplayRemoved(displayId: Int) {}
-                override fun onDisplayChanged(displayId: Int) {}
-            }
-
-            val handler = Handler(Looper.getMainLooper())
-            displayManager.registerDisplayListener(listener, handler)
-
-            awaitClose {
-                displayManager.unregisterDisplayListener(listener)
-            }
-        }
-
-        val displaySettings = displays.joinToString(separator = ";") { size ->
-            "${size.x}x${size.y}/$DEFAULT_DENSITY"
-        }
-
-        // Add the overlay displays
-        Settings.Global.putString(
-            InstrumentationRegistry.getInstrumentation().context.contentResolver,
-            Settings.Global.OVERLAY_DISPLAY_DEVICES,
-            displaySettings
-        )
-        withTimeoutOrNull(TIMEOUT) {
-            displayAddedFlow.take(displays.size).collect { displayId ->
-                addedDisplays.add(displayId)
-            }
-        } ?: error("Timed out waiting for displays to be added.")
-        addedDisplays
-    }
-
-    /**
-     * Adds multiple overlay displays with default dimensions. Any existing overlay displays
-     * will be removed before adding the new ones.
-     *
-     * @param count number of displays to add.
-     * @return List of displayIds of added displays.
-     */
-    fun setupTestDisplays(count: Int): List<Int> {
-        val displays = List(count) { Point(DEFAULT_WIDTH, DEFAULT_HEIGHT) }
-        return setupTestDisplays(displays)
-    }
-
-    private fun cleanupTestDisplays() = runBlocking {
-        val displayRemovedFlow: Flow<Int> = callbackFlow {
-            val listener = object : DisplayListener {
-                override fun onDisplayAdded(displayId: Int) {}
-                override fun onDisplayRemoved(displayId: Int) {
-                    trySend(displayId)
-                }
-
-                override fun onDisplayChanged(displayId: Int) {}
-            }
-            val handler = Handler(Looper.getMainLooper())
-            displayManager.registerDisplayListener(listener, handler)
-
-            awaitClose {
-                displayManager.unregisterDisplayListener(listener)
-            }
-        }
-
-        // Remove overlay displays. We'll execute this regardless of addedDisplays just to
-        // ensure all overlay displays are removed before and after the test.
-        // Note: If we want to restore the original overlay display added before this test (and its
-        // topology), it will be complicated as re-adding overlay display would lead to different
-        // displayId and topology could not be restored easily.
-        Settings.Global.putString(
-            InstrumentationRegistry.getInstrumentation().context.contentResolver,
-            Settings.Global.OVERLAY_DISPLAY_DEVICES,
-            null
-        )
-
-        if (!addedDisplays.isEmpty()) {
-            withTimeoutOrNull(TIMEOUT) {
-                displayRemovedFlow.take(addedDisplays.size).collect { displayId ->
-                    addedDisplays.remove(displayId)
-                }
-            } ?: error("Timed out waiting for displays to be removed: $addedDisplays")
-        }
-    }
-
-    private companion object {
-        const val DEFAULT_WIDTH = 1280
-        const val DEFAULT_HEIGHT = 720
-        const val DEFAULT_DENSITY = 160
-        const val TAG = "SimulatedConnectedDisplayTestRule"
-        val TIMEOUT = 10.seconds
-    }
-}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/DesktopMouseTestRule.kt b/libraries/desktop-test-lib/src/platform/test/desktop/DesktopMouseTestRule.kt
new file mode 100644
index 000000000..cdda52e73
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/DesktopMouseTestRule.kt
@@ -0,0 +1,569 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.Manifest
+import android.companion.virtual.VirtualDeviceManager
+import android.companion.virtual.VirtualDeviceParams
+import android.graphics.Point
+import android.graphics.PointF
+import android.graphics.RectF
+import android.hardware.display.DisplayManager
+import android.hardware.display.DisplayTopology
+import android.hardware.display.DisplayTopology.dpToPx
+import android.hardware.display.DisplayTopologyGraph
+import android.hardware.input.InputManager
+import android.hardware.input.VirtualMouse
+import android.hardware.input.VirtualMouseButtonEvent
+import android.hardware.input.VirtualMouseButtonEvent.ACTION_BUTTON_PRESS
+import android.hardware.input.VirtualMouseButtonEvent.ACTION_BUTTON_RELEASE
+import android.hardware.input.VirtualMouseButtonEvent.BUTTON_PRIMARY
+import android.hardware.input.VirtualMouseConfig
+import android.hardware.input.VirtualMouseRelativeEvent
+import android.os.Handler
+import android.os.Looper
+import android.platform.uiautomatorhelpers.AdoptShellPermissionsRule
+import android.platform.uiautomatorhelpers.WaitUtils
+import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
+import android.view.DisplayInfo
+import androidx.annotation.VisibleForTesting
+import androidx.test.platform.app.InstrumentationRegistry
+import kotlin.math.abs
+import kotlin.math.max
+import kotlin.math.min
+import kotlin.math.roundToInt
+import kotlin.time.Duration
+import kotlin.time.Duration.Companion.milliseconds
+import kotlin.time.Duration.Companion.seconds
+import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.flow.callbackFlow
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withTimeoutOrNull
+import org.junit.rules.ExternalResource
+import org.junit.rules.RuleChain
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * A [TestRule] to support [VirtualMouse] move and drag within a single display / crossing across
+ * displays.
+ */
+class DesktopMouseTestRule() : TestRule {
+    private val adoptShellPermissionsTestRule = AdoptShellPermissionsRule(*PERMISSIONS)
+    private val fakeAssociationRule = FakeAssociationRule()
+    private val context = InstrumentationRegistry.getInstrumentation().targetContext
+    private val uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation()
+    private val displayManager = context.getSystemService(DisplayManager::class.java)
+    private val inputManager = context.getSystemService(InputManager::class.java)
+    private val resourceTracker = ResourceTracker()
+    private val ruleChain =
+        RuleChain.outerRule(adoptShellPermissionsTestRule)
+            .around(fakeAssociationRule)
+            .around(resourceTracker)
+
+    override fun apply(base: Statement, description: Description) =
+        ruleChain.apply(base, description)
+
+    /**
+     * Internal test rule that tracks created virtual mouse and modified display topology and
+     * ensures they are properly closed / restored after the test.
+     */
+    private inner class ResourceTracker() : ExternalResource() {
+        private val virtualDeviceManager =
+            context.getSystemService(VirtualDeviceManager::class.java)
+
+        // TODO: b/392534769 - Refactor this to use UinputMouse.
+        private var virtualDevice: VirtualDeviceManager.VirtualDevice? = null
+        private var virtualMouse: VirtualMouse? = null
+        private val displayIdsWithMouseScalingDisabled = mutableListOf<Int>()
+        private val handler = Handler(Looper.getMainLooper())
+        private val displayListener =
+            object : DisplayManager.DisplayListener {
+                override fun onDisplayAdded(displayId: Int) {
+                    disableMouseScaling(displayId)
+                }
+
+                override fun onDisplayRemoved(displayId: Int) {}
+
+                override fun onDisplayChanged(displayId: Int) {}
+            }
+
+        val requireVirtualMouse: VirtualMouse
+            get() = checkNotNull(virtualMouse) { "Failed to initialize VirtualMouse" }
+
+        /**
+         * Sets up a virtual mouse that will start at [DEFAULT_DISPLAY].
+         *
+         * Note: This will move any existing cursor in the same topology as [DEFAULT_DISPLAY], to
+         * [DEFAULT_DISPLAY]. If the mouse needs to start at different display, first call
+         * `DesktopMouseTestRule#move(displayId, x, y)`.
+         */
+        override fun before() = runBlocking {
+            val createdVirtualDevice =
+                virtualDeviceManager.createVirtualDevice(
+                    fakeAssociationRule.associationInfo.id,
+                    VirtualDeviceParams.Builder().build(),
+                )
+            virtualDevice = createdVirtualDevice
+
+            val inputDeviceFlow = callbackFlow {
+                val inputDeviceListener =
+                    object : InputManager.InputDeviceListener {
+                        override fun onInputDeviceAdded(deviceId: Int) {
+                            val device = inputManager.getInputDevice(deviceId) ?: return
+                            if (
+                                device.vendorId == VIRTUAL_MOUSE_VENDOR_ID &&
+                                    device.productId == VIRTUAL_MOUSE_PRODUCT_ID
+                            ) {
+                                trySend(deviceId)
+                                close()
+                            }
+                        }
+
+                        override fun onInputDeviceRemoved(deviceId: Int) {}
+
+                        override fun onInputDeviceChanged(deviceId: Int) {}
+                    }
+                inputManager.registerInputDeviceListener(inputDeviceListener, handler)
+
+                // Note: AssociatedDisplayId is not actually used in connected displays, since
+                // cursor will be able to cross displays and no longer gets "associated" anymore,
+                // with an exception if display is excluded from the current DisplayTopology.
+                virtualMouse =
+                    createdVirtualDevice.createVirtualMouse(
+                        VirtualMouseConfig.Builder()
+                            .setVendorId(VIRTUAL_MOUSE_VENDOR_ID)
+                            .setProductId(VIRTUAL_MOUSE_PRODUCT_ID)
+                            .setInputDeviceName("VirtualMouse_ConnectedDisplaysTest")
+                            .setAssociatedDisplayId(DEFAULT_DISPLAY)
+                            .build()
+                    )
+                awaitClose { inputManager.unregisterInputDeviceListener(inputDeviceListener) }
+            }
+
+            withTimeoutOrNull(TIMEOUT) { inputDeviceFlow.first() }
+                ?: error("Timed out waiting for input device to be added.")
+
+            for (display in displayManager.displays) {
+                disableMouseScaling(display.displayId)
+            }
+            displayManager.registerDisplayListener(displayListener, handler)
+            ensureCursorStartsOnDefaultDisplay()
+        }
+
+        private fun disableMouseScaling(displayId: Int) {
+            displayIdsWithMouseScalingDisabled += displayId
+            inputManager.setMouseScalingEnabled(false, displayId)
+        }
+
+        private fun ensureCursorStartsOnDefaultDisplay() {
+            val display = displayManager.getDisplay(DEFAULT_DISPLAY)
+            move(DEFAULT_DISPLAY, display.width / 2, display.height / 2)
+        }
+
+        override fun after() {
+            displayManager.unregisterDisplayListener(displayListener)
+            for (displayId in displayIdsWithMouseScalingDisabled) {
+                try {
+                    inputManager.setMouseScalingEnabled(true, displayId)
+                } catch (e: Exception) {
+                    Log.e(TAG, "Failed to restore mouse scaling for display#$displayId", e)
+                }
+            }
+            virtualMouse?.close()
+            virtualDevice?.close()
+            virtualMouse = null
+            virtualDevice = null
+            super.after()
+        }
+    }
+
+    fun startDrag() {
+        resourceTracker.requireVirtualMouse.sendButtonEvent(
+            VirtualMouseButtonEvent.Builder()
+                .setAction(ACTION_BUTTON_PRESS)
+                .setButtonCode(BUTTON_PRIMARY)
+                .build()
+        )
+        Thread.sleep(MOUSE_INPUT_DELAY.inWholeMilliseconds)
+    }
+
+    fun stopDrag() {
+        resourceTracker.requireVirtualMouse.sendButtonEvent(
+            VirtualMouseButtonEvent.Builder()
+                .setAction(ACTION_BUTTON_RELEASE)
+                .setButtonCode(BUTTON_PRIMARY)
+                .build()
+        )
+        Thread.sleep(MOUSE_INPUT_DELAY.inWholeMilliseconds)
+    }
+
+    /**
+     * Moves the mouse cursor to the `(targetXPx, targetYPx)` on target display. If the target
+     * display is different from the current display, it finds a path and moves the cursor across
+     * display(s).
+     *
+     * NOTE: While InputManager APIs are using PointF for both get/set, the underlying
+     * implementation is actually using Int. For example, evdev injection only supports Int.
+     * Therefore, it's currently not possible to move to a floating point coordinates.
+     *
+     * @param targetDisplayId The ID of the destination display.
+     * @param targetX The target X (PX) coordinate relative to the target display.
+     * @param targetY The target Y (PX) coordinate relative to the target display.
+     */
+    fun move(targetDisplayId: Int, targetXPx: Int, targetYPx: Int) {
+        val currentCursorDisplayId = getCursorDisplayId()
+
+        if (targetDisplayId != currentCursorDisplayId) {
+            moveToDisplay(currentCursorDisplayId, targetDisplayId)
+        }
+
+        val currentPosition = getCursorPosition(targetDisplayId).roundToInt()
+        performSteppedMove(Point(targetXPx, targetYPx) - currentPosition)
+
+        WaitUtils.ensureThat {
+            val finalPosition = getCursorPosition(targetDisplayId).roundToInt()
+            val delta = finalPosition - Point(targetXPx, targetYPx)
+            // As mentioned in the javadoc above, InputManager API doesn't support floating-point
+            // movements. Hence, with all the floating-point calculation above, there might be
+            // slight difference (within `FLOATING_ROUND_CORRECTION`) in the final cursor position.
+            delta.dx <= FLOATING_ROUNDING_CORRECTION && delta.dy <= FLOATING_ROUNDING_CORRECTION
+        }
+    }
+
+    /**
+     * Requests to move the mouse cursor by the specified delta. Different from the [move] method,
+     * this does not consider where the current mouse cursor is, and does not ensure that the cursor
+     * will move to any target position.
+     *
+     * @param xPx The delta X (PX) coordinate.
+     * @param yPx The delta Y (PX) coordinate.
+     */
+    fun moveDelta(xPx: Int, yPx: Int) {
+        moveInternal(Delta(xPx, yPx))
+    }
+
+    private fun moveToDisplay(startingDisplayId: Int, targetDisplayId: Int) {
+        var currentCursorDisplayId = startingDisplayId
+        val topology =
+            checkNotNull(displayManager.displayTopology) { "DisplayTopology must be available." }
+        val displayAbsoluteBounds = topology.absoluteBounds
+        val topologyGraph = topology.graph
+        val path = findPath(currentCursorDisplayId, targetDisplayId, topologyGraph)
+
+        path.forEach { (nextDisplayId, position) ->
+            val dpi = getDpiForDisplay(currentCursorDisplayId)
+            val currentBounds = displayAbsoluteBounds[currentCursorDisplayId]
+            val nextBounds = displayAbsoluteBounds[nextDisplayId]
+
+            // Calculate where to cross and the crossing delta
+            val crossingDetail = calculateCrossingDetailsDp(currentBounds, nextBounds, position)
+            // Cursor moves in PX, however there's no notion of global PX bounds since density
+            // of each displays could be different, and there's only global DP bounds.
+            // Therefore, to solve the calculation, first convert globalDP -> localDP, then
+            // apply DP->PX conversion.
+            val edgeIntersectionPx =
+                PointF(
+                    dpToPx(crossingDetail.targetPointDp.x - currentBounds.left, dpi),
+                    dpToPx(crossingDetail.targetPointDp.y - currentBounds.top, dpi),
+                )
+            val crossingDeltaPx =
+                DeltaF(
+                    dpToPx(crossingDetail.toCrossDxDp, dpi),
+                    dpToPx(crossingDetail.toCrossDyDp, dpi),
+                )
+
+            val currentPosition = getCursorPosition(currentCursorDisplayId)
+            // Move to the center of the edge intersection.
+            val toBorderDeltaPx = edgeIntersectionPx - currentPosition
+            performSteppedMove(toBorderDeltaPx.roundToInt())
+
+            // Perform a small move to cross the boundary
+            performSteppedMove(crossingDeltaPx.roundToInt())
+            // Validate cursor crossed display
+            WaitUtils.ensureThat { getCursorDisplayId() == nextDisplayId }
+            currentCursorDisplayId = nextDisplayId
+
+            // InputDevice reconfiguration will happen when cursor changed display, and might jam
+            // the input queue. Waiting for input transactions to finish ensure any subsequent
+            // `getCursorPosition()` calls return accurate position
+            uiAutomation.syncInputTransactions()
+        }
+    }
+
+    /**
+     * Divides delta to multiple small movements
+     *
+     * @param deltaPx delta movement, either dx or dy must be non-zero
+     * @param maxSteps the maximum number of times move events would be sent
+     */
+    private fun performSteppedMove(deltaPx: Delta, maxSteps: Int = MAX_MOUSE_MOVE_STEPS_COUNT) {
+        if (deltaPx.dx == 0 && deltaPx.dy == 0) return
+        // Find ideal number of steps to move a number of PX
+        val idealSteps = max(abs(deltaPx.dx), abs(deltaPx.dy)) / MIN_PX_PER_STEP
+
+        // Limit the number of steps while ensuring it's not zero
+        val steps = max(1, min(maxSteps, idealSteps))
+        val stepX = deltaPx.dx / steps
+        val stepY = deltaPx.dy / steps
+        repeat(steps) { moveInternal(Delta(stepX, stepY)) }
+
+        // Move any remaining delta
+        val remainingDx = deltaPx.dx - (stepX * steps)
+        val remainingDy = deltaPx.dy - (stepY * steps)
+        moveInternal(Delta(remainingDx, remainingDy))
+    }
+
+    private fun moveInternal(deltaPx: Delta) {
+        resourceTracker.requireVirtualMouse.sendRelativeEvent(
+            VirtualMouseRelativeEvent.Builder()
+                .setRelativeX(deltaPx.dx.toFloat())
+                .setRelativeY(deltaPx.dy.toFloat())
+                .build()
+        )
+        Thread.sleep(MOUSE_INPUT_DELAY.inWholeMilliseconds)
+    }
+
+    private fun getCursorPosition(displayId: Int): PointF =
+        checkNotNull(inputManager.getCursorPosition(displayId)) {
+            "Cursor is not on display#$displayId"
+        }
+
+    private fun getCursorDisplayId(): Int {
+        // Query cursor position on all displays and find the one with non-null values
+        // This is a hack since getCursorPosition API, doesn't directly provide the displayId it's
+        // currently at.
+        for (display in displayManager.displays) {
+            val cursorPosition = inputManager.getCursorPosition(display.displayId)
+            if (cursorPosition != null) {
+                return display.displayId
+            }
+        }
+        throw NoCursorFoundException("Cursor doesn't exist on any display")
+    }
+
+    private fun getDpiForDisplay(displayId: Int): Int {
+        val display =
+            checkNotNull(displayManager.getDisplay(displayId)) { "Display#$displayId not found" }
+        val displayInfo = DisplayInfo()
+        display.getDisplayInfo(displayInfo)
+        return displayInfo.logicalDensityDpi
+    }
+
+    /**
+     * Representing details on how to cross from one display to another based on their adjacency
+     * relation.
+     *
+     * @property targetPointDp The center of an intersection edge of 2 adjacent displays. This will
+     *   be the target (x, y) to move to, wherever the current cursor is.
+     * @property toCrossDeltaDp The small (dx, dy) required to cross display boundary when cursor is
+     *   already on the `targetPointDp.
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    data class DisplayCrossingDetail(
+        val targetPointDp: PointF,
+        private val toCrossDeltaDp: DeltaF,
+    ) {
+
+        // Sample explanation
+        //
+        //   +-------------------------------+
+        //   |           Display 2           |
+        //   |                               |
+        //   +=========*****X*****===========+
+        //             R    |    R Bottom of D2 / Top of D1
+        //              +-------+
+        //              |Display|
+        //              |   1   |
+        //              |       |
+        //              |       |
+        //              +-------+
+        //  R = range of the intersection
+        //  X = center of the intersection (`targetPointDp`)
+
+        val toCrossDxDp: Float
+            get() = toCrossDeltaDp.dx
+
+        val toCrossDyDp: Float
+            get() = toCrossDeltaDp.dy
+    }
+
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    data class AdjacentDisplay(val displayId: Int, val position: Position) {
+        // Side of the other display which touches this display.
+        enum class Position {
+            LEFT,
+            RIGHT,
+            TOP,
+            BOTTOM;
+
+            companion object {
+                fun from(@DisplayTopology.TreeNode.Position value: Int): Position {
+                    return when (value) {
+                        DisplayTopology.TreeNode.POSITION_LEFT -> LEFT
+                        DisplayTopology.TreeNode.POSITION_TOP -> TOP
+                        DisplayTopology.TreeNode.POSITION_RIGHT -> RIGHT
+                        DisplayTopology.TreeNode.POSITION_BOTTOM -> BOTTOM
+                        else ->
+                            throw IllegalArgumentException(
+                                "Invalid integer value for Position: $value"
+                            )
+                    }
+                }
+            }
+        }
+    }
+
+    data class DeltaF(val dx: Float, val dy: Float) {
+        fun roundToInt() = Delta(dx.roundToInt(), dy.roundToInt())
+    }
+
+    data class Delta(val dx: Int, val dy: Int)
+
+    class NoCursorFoundException(message: String) : Exception(message)
+
+    class NoPathFoundException(message: String) : Exception(message)
+
+    companion object {
+
+        /**
+         * Finds a path of adjacent display IDs from `startId` to `endId` using BFS.
+         *
+         * Returned path doesn't include the start node. If `startId` == `endId`, then empty list
+         * will be returned
+         */
+        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+        fun findPath(
+            startId: Int,
+            endId: Int,
+            topologyGraph: DisplayTopologyGraph,
+        ): List<AdjacentDisplay> {
+            if (startId == endId) return listOf()
+            val adjacencyGraph = topologyGraph.displayNodes.associateBy { it.displayId }
+            val queue = ArrayDeque<Int>().apply { add(startId) }
+            val visited = mutableSetOf(startId)
+            // Maps display id to its parent in the context of `startId`->`endIf` traversal.
+            val parentMap = mutableMapOf<Int, AdjacentDisplay>()
+
+            while (queue.isNotEmpty()) {
+                val currentId = queue.removeFirst()
+                if (currentId == endId) {
+                    // Path found, reconstruct path
+                    val path = ArrayDeque<AdjacentDisplay>()
+                    var backtrackId = endId
+                    while (backtrackId != startId) {
+                        val parentNode =
+                            parentMap[backtrackId]
+                                ?: throw IllegalStateException(
+                                    "Path should exist since start node can be reached"
+                                )
+                        path.addFirst(AdjacentDisplay(backtrackId, parentNode.position))
+                        backtrackId = parentNode.displayId
+                    }
+                    return path
+                }
+
+                val currentNode = adjacencyGraph[currentId] ?: continue
+                // Check neighbors
+                for (adjacentDisplay in currentNode.adjacentDisplays) {
+                    val neighborId = adjacentDisplay.displayId
+                    val position = adjacentDisplay.position
+                    if (neighborId in visited) continue
+                    visited.add(neighborId)
+                    parentMap[neighborId] =
+                        AdjacentDisplay(currentId, AdjacentDisplay.Position.from(position))
+                    queue.add(neighborId)
+                }
+            }
+            throw NoPathFoundException("No path found from $startId to $endId")
+        }
+
+        /**
+         * Calculates crossing details (intersection-midpoint, crossing-delta) in DP, between
+         * adjacent bounds.
+         *
+         * @see [DisplayCrossingDetail] for details
+         */
+        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+        fun calculateCrossingDetailsDp(
+            source: RectF,
+            target: RectF,
+            position: AdjacentDisplay.Position,
+        ): DisplayCrossingDetail {
+            val overlapTop = max(source.top, target.top)
+            val overlapBottom = min(source.bottom, target.bottom)
+            val overlapLeft = max(source.left, target.left)
+            val overlapRight = min(source.right, target.right)
+            val offset = MOUSE_CROSS_DISPLAY_OFFSET_DP
+
+            return when (position) {
+                AdjacentDisplay.Position.RIGHT -> // target is to the right of source
+                DisplayCrossingDetail(
+                        PointF(source.right, (overlapTop + overlapBottom) / 2f),
+                        DeltaF(offset, 0f),
+                    )
+                AdjacentDisplay.Position.LEFT -> // target is to the left of source
+                DisplayCrossingDetail(
+                        PointF(source.left, (overlapTop + overlapBottom) / 2f),
+                        DeltaF(-offset, 0f),
+                    )
+                AdjacentDisplay.Position.BOTTOM -> // target is below source
+                DisplayCrossingDetail(
+                        PointF((overlapLeft + overlapRight) / 2f, source.bottom),
+                        DeltaF(0f, offset),
+                    )
+                AdjacentDisplay.Position.TOP -> // target is above source
+                DisplayCrossingDetail(
+                        PointF((overlapLeft + overlapRight) / 2f, source.top),
+                        DeltaF(0f, -offset),
+                    )
+            }
+        }
+
+        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+        const val MOUSE_CROSS_DISPLAY_OFFSET_DP = 5.0f
+        private const val FLOATING_ROUNDING_CORRECTION = 1f
+        private const val MIN_PX_PER_STEP = 1
+        private const val MAX_MOUSE_MOVE_STEPS_COUNT = 20
+        private const val VIRTUAL_MOUSE_VENDOR_ID = 123
+        private const val VIRTUAL_MOUSE_PRODUCT_ID = 456
+        private const val TAG = "DesktopMouseTestRule"
+
+        // Mimics UiAutomator delay for injecting MotionEvent
+        private val MOUSE_INPUT_DELAY = 5.milliseconds
+        private val TIMEOUT: Duration = 10.seconds
+
+        private val PERMISSIONS =
+            arrayOf(
+                Manifest.permission.ASSOCIATE_COMPANION_DEVICES,
+                "android.permission.MANAGE_COMPANION_DEVICES",
+                Manifest.permission.CREATE_VIRTUAL_DEVICE,
+                Manifest.permission.INJECT_EVENTS,
+                "android.permission.MANAGE_DISPLAYS",
+                Manifest.permission.SET_POINTER_SPEED,
+            )
+
+        private fun PointF.roundToInt() = Point(x.roundToInt(), y.roundToInt())
+
+        private operator fun Point.minus(other: Point) = Delta(x - other.x, y - other.y)
+
+        private operator fun PointF.minus(other: PointF) = DeltaF(x - other.x, y - other.y)
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/FakeAssociationRule.java b/libraries/desktop-test-lib/src/platform/test/desktop/FakeAssociationRule.java
new file mode 100644
index 000000000..cfdd953e5
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/FakeAssociationRule.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+
+import static junit.framework.Assert.assertTrue;
+
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.verify;
+
+import android.companion.AssociationInfo;
+import android.companion.AssociationRequest;
+import android.companion.CompanionDeviceManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Build;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.filters.SdkSuppress;
+
+import org.junit.rules.ExternalResource;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A test rule that creates a {@link CompanionDeviceManager} association with the instrumented
+ * package for the duration of the test.
+ *
+ * <p>NOTE: This is duplicated from
+ * cts/tests/tests/virtualdevice/common/src/android/virtualdevice/cts/common/FakeAssociationRule as
+ * a simplified version that only works for API 36 and above, and not pulling extra libs required by
+ * VirtualDeviceRule.
+ *
+ * <p>TODO: b/392534769 - Remove this once DesktopMouseTestRule migrated to use UinputMouse.
+ */
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.BAKLAVA, codeName = "Baklava")
+class FakeAssociationRule extends ExternalResource {
+    private static final String TAG = "FakeAssociationRule";
+
+    private static final String DEVICE_PROFILE = AssociationRequest.DEVICE_PROFILE_APP_STREAMING;
+    private static final String DISPLAY_NAME = "CTS CDM VDM Association";
+
+    private static final int TIMEOUT_MS = 10000;
+
+    private final Context mContext = getInstrumentation().getContext();
+
+    private final Executor mCallbackExecutor = Runnable::run;
+    private final CompanionDeviceManager mCompanionDeviceManager =
+            mContext.getSystemService(CompanionDeviceManager.class);
+
+    @Mock
+    private CompanionDeviceManager.OnAssociationsChangedListener mOnAssociationsChangedListener;
+
+    private AssociationInfo mAssociationInfo;
+
+    private AssociationInfo createManagedAssociation() {
+        final AssociationInfo[] managedAssociation = new AssociationInfo[1];
+        AssociationRequest request =
+                new AssociationRequest.Builder()
+                        .setDeviceProfile(DEVICE_PROFILE)
+                        .setDisplayName(DISPLAY_NAME)
+                        .setSelfManaged(true)
+                        .setSkipRoleGrant(true)
+                        .build();
+        CountDownLatch latch = new CountDownLatch(1);
+        CompanionDeviceManager.Callback callback =
+                new CompanionDeviceManager.Callback() {
+                    @Override
+                    public void onAssociationCreated(@NonNull AssociationInfo associationInfo) {
+                        managedAssociation[0] = associationInfo;
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onFailure(@Nullable CharSequence error) {
+                        fail(error == null ? "Failed to create CDM association" : error.toString());
+                    }
+                };
+        reset(mOnAssociationsChangedListener);
+        mCompanionDeviceManager.associate(request, Runnable::run, callback);
+
+        try {
+            latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        } catch (InterruptedException e) {
+            fail("Interrupted while waiting for CDM association: " + e);
+        }
+
+        verifyAssociationsChanged();
+        return managedAssociation[0];
+    }
+
+    @Override
+    protected void before() throws Throwable {
+        super.before();
+        MockitoAnnotations.initMocks(this);
+        assumeTrue(hasSystemFeature(PackageManager.FEATURE_COMPANION_DEVICE_SETUP));
+        mCompanionDeviceManager.addOnAssociationsChangedListener(
+                mCallbackExecutor, mOnAssociationsChangedListener);
+        clearExistingAssociations();
+        mAssociationInfo = createManagedAssociation();
+    }
+
+    @Override
+    protected void after() {
+        super.after();
+        clearExistingAssociations();
+        mCompanionDeviceManager.removeOnAssociationsChangedListener(mOnAssociationsChangedListener);
+    }
+
+    private void clearExistingAssociations() {
+        List<AssociationInfo> associations = mCompanionDeviceManager.getMyAssociations();
+        for (AssociationInfo association : associations) {
+            disassociate(association.getId());
+        }
+        assertTrue(mCompanionDeviceManager.getMyAssociations().isEmpty());
+        mAssociationInfo = null;
+    }
+
+    AssociationInfo getAssociationInfo() {
+        return mAssociationInfo;
+    }
+
+    private void disassociate(int associationId) {
+        reset(mOnAssociationsChangedListener);
+        mCompanionDeviceManager.disassociate(associationId);
+        verifyAssociationsChanged();
+    }
+
+    private void verifyAssociationsChanged() {
+        verify(
+                        mOnAssociationsChangedListener,
+                        timeout(TIMEOUT_MS)
+                                .description(
+                                        TAG
+                                                + ": onAssociationChanged not called, total"
+                                                + " associations: "
+                                                + mCompanionDeviceManager
+                                                        .getMyAssociations()
+                                                        .size()))
+                .onAssociationsChanged(any());
+    }
+
+    /** Returns true if the device has a given system feature */
+    private boolean hasSystemFeature(String feature) {
+        return mContext.getPackageManager().hasSystemFeature(feature);
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/PeripheralDeviceTestRule.kt b/libraries/desktop-test-lib/src/platform/test/desktop/PeripheralDeviceTestRule.kt
new file mode 100644
index 000000000..6f855a718
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/PeripheralDeviceTestRule.kt
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.view.Display
+import com.google.common.truth.Truth.assertWithMessage
+import org.junit.Assume.assumeTrue
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/** An interface for a controller to request peripherals. */
+fun interface PeripheralsController {
+    /**
+     * Requests the peripherals specified in the [request]. If the list is empty, disconnects all
+     * the peripherals. Returns [PeripheralsResponse] containing [PeripheralDevices] that were
+     * connected or disconnected.
+     */
+    fun requestPeripherals(request: PeripheralsRequest): PeripheralsResponse
+}
+
+/** An interface for a peripheral device returned by a [PeripheralsController]. */
+sealed interface PeripheralDevice {
+    val peripheral: Peripheral
+    val connected: Boolean
+}
+
+/** An interface for a display device returned by a [PeripheralsController]. */
+sealed interface DisplayDevice : PeripheralDevice {
+    val displayId: Int
+    val display: Display?
+}
+
+/**
+ * A display device used internally by a [PeripheralsController].
+ *
+ * @property peripheral The peripheral that was requested.
+ * @property connected Whether the display is connected.
+ * @property displayId The display identifier.
+ * @property display The display object.
+ */
+internal data class AnyDisplayDevice(
+    override val peripheral: Peripheral,
+    override val connected: Boolean,
+    override val displayId: Int,
+    override val display: Display?,
+) : DisplayDevice
+
+/** Interface for peripherals to simplify their classification. */
+sealed interface Peripheral {
+    val type: PeripheralType
+}
+
+/** The type of the peripheral. */
+enum class PeripheralType {
+    SIMULATED,
+    PHYSICAL,
+    PHYSICAL_OR_SIMULATED,
+}
+
+/** A display resolution. */
+enum class DisplaySize(val width: Int, val height: Int) {
+    SIZE_1080P(1920, 1080),
+    SIZE_1080P_ULTRA_WIDE(2560, 1080),
+    SIZE_2K(2560, 1440),
+    SIZE_2K_ULTRA_WIDE(3440, 1440),
+    SIZE_4K(3840, 2160),
+    SIZE_4K_ULTRA_WIDE(5120, 2160),
+}
+
+/** A display peripheral. */
+data class DisplayPeripheral(override val type: PeripheralType, val size: DisplaySize) : Peripheral
+
+/** A request to connect [peripherals]. */
+class PeripheralsRequest(val peripherals: List<Peripheral> = emptyList()) {
+
+    /** Returns a new [PeripheralsRequest] with all peripherals of the specified [type]. */
+    fun getByType(type: PeripheralType): PeripheralsRequest =
+        PeripheralsRequest(peripherals.filter { it.type == type })
+
+    /** Validates that all peripherals are of the [supportedTypes]. */
+    fun validate(vararg types: PeripheralType) {
+        val supportedTypes = types.toList()
+
+        assertWithMessage("There shouldn't be any non-supported peripherals")
+            .that(peripherals.filter { it.type !in supportedTypes })
+            .isEmpty()
+    }
+
+    operator fun plus(other: PeripheralsRequest): PeripheralsRequest =
+        PeripheralsRequest(peripherals + other.peripherals)
+
+    /** Returns a new [PeripheralsRequest] with all peripherals that are not connected. */
+    fun notConnected(response: PeripheralsResponse): PeripheralsRequest {
+        val connectedPeripherals = response.devices.filter { it.connected }.map { it.peripheral }
+        return PeripheralsRequest(
+            peripherals.filter { p -> connectedPeripherals.none { it === p } }
+        )
+    }
+
+    override fun toString(): String = "peripherals=${peripherals.joinToString(", ")}"
+}
+
+/** A response with [devices] after connecting and disconnecting peripherals. */
+class PeripheralsResponse(val devices: List<PeripheralDevice> = emptyList()) {
+    override fun toString(): String = "devices=${devices.joinToString(", ")}"
+
+    operator fun plus(other: PeripheralsResponse): PeripheralsResponse =
+        PeripheralsResponse(devices + other.devices)
+}
+
+/**
+ * A test rule allowing to request peripherals during the test and disconnects them after the test.
+ *
+ * @param physicalPeripheralsController The controller to use for physical peripherals.
+ * @param simulatedPeripheralsController The controller to use for simulated peripherals.
+ */
+class PeripheralDeviceTestRule(
+    physicalPeripheralsController: PeripheralsController? = null,
+    simulatedPeripheralsController: PeripheralsController? = null,
+) : TestRule, PeripheralsController {
+
+    private val physicalController = physicalPeripheralsController ?: PhysicalDeviceController()
+    private val simulatedController = simulatedPeripheralsController ?: SimulatedDeviceController()
+
+    override fun apply(base: Statement, description: Description): Statement =
+        object : Statement() {
+            override fun evaluate() {
+                try {
+                    base.evaluate()
+                } finally {
+                    requestPeripherals(PeripheralsRequest())
+                }
+            }
+        }
+
+    fun requestPeripherals(vararg peripherals: Peripheral): PeripheralsResponse =
+        requestPeripherals(PeripheralsRequest(peripherals.toList()))
+
+    /**
+     * Tries to connect all peripherals specified in the [request]. If some peripherals are no
+     * longer requested, they are disconnected and returned by this method in [PeripheralsResponse]
+     * as disconnected PeripheralDevices.
+     *
+     * For [PeripheralType.SIMULATED] or [PeripheralType.PHYSICAL_OR_SIMULATED],
+     * [SimulatedController] sets up simulated type of peripheral If simulated peripheral fails to
+     * be set up, the test fails.
+     *
+     * For [PeripheralType.PHYSICAL] or [PeripheralType.PHYSICAL_OR_SIMULATED], [PhysicalController]
+     * connects them using a LabController then waits for them to be connected and configured. If
+     * physical peripheral fails to connect or be set up, the test is skipped.
+     */
+    override fun requestPeripherals(request: PeripheralsRequest): PeripheralsResponse {
+        val physicalOrSimulated = request.getByType(PeripheralType.PHYSICAL_OR_SIMULATED)
+        val physicalRequest = physicalOrSimulated + request.getByType(PeripheralType.PHYSICAL)
+        val physicalResponse = physicalController.requestPeripherals(physicalRequest)
+        assumePhysicalConnected(physicalRequest, physicalResponse)
+
+        val remaining = physicalOrSimulated.notConnected(physicalResponse)
+        val simulatedRequest = remaining + request.getByType(PeripheralType.SIMULATED)
+        val simulatedResponse = simulatedController.requestPeripherals(simulatedRequest)
+        assertSimulatedConnected(simulatedRequest, simulatedResponse)
+
+        return physicalResponse + simulatedResponse
+    }
+
+    private fun assumePhysicalConnected(
+        request: PeripheralsRequest,
+        response: PeripheralsResponse,
+    ) {
+        val physicalRequestedCount =
+            request.peripherals.count { it.type == PeripheralType.PHYSICAL }
+        val physicalConnectedCount =
+            response.devices.count { it.connected && it.peripheral.type == PeripheralType.PHYSICAL }
+        // Assume that all physical peripherals are connected, if not - skip the test.
+        assumeTrue(
+            "Can't connect all " +
+                "requested physical peripherals: ${request} " +
+                "response: ${response}",
+            physicalRequestedCount == physicalConnectedCount,
+        )
+    }
+
+    private fun assertSimulatedConnected(
+        request: PeripheralsRequest,
+        response: PeripheralsResponse,
+    ) {
+        assertWithMessage(
+                "Can't connect all " +
+                    "requested simulated peripherals: ${request} " +
+                    "response: ${response}"
+            )
+            .that(request.peripherals.size)
+            .isEqualTo(response.devices.count { it.connected })
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/PhysicalDeviceController.kt b/libraries/desktop-test-lib/src/platform/test/desktop/PhysicalDeviceController.kt
new file mode 100644
index 000000000..5e9fd4eeb
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/PhysicalDeviceController.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+/**
+ * A physical display device returned by a [PhysicalDeviceController].
+ *
+ * @param d The underlying [DisplayDevice].
+ */
+data class PhysicalDisplayDevice(val d: DisplayDevice) : DisplayDevice by d
+
+/** A controller for physical peripherals. */
+class PhysicalDeviceController : PeripheralsController {
+    override fun requestPeripherals(request: PeripheralsRequest): PeripheralsResponse {
+        // TODO: b/351118894 - Implement this.
+        return PeripheralsResponse()
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/ShadeDisplayGoesAroundTestRule.kt b/libraries/desktop-test-lib/src/platform/test/desktop/ShadeDisplayGoesAroundTestRule.kt
new file mode 100644
index 000000000..e06ca0d7d
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/ShadeDisplayGoesAroundTestRule.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.platform.uiautomatorhelpers.DeviceHelpers.shell
+import org.junit.rules.TestWatcher
+import org.junit.runner.Description
+
+/**
+ * Rule that sets a shade display policy.
+ *
+ * See [ShadePrimaryDisplayCommand] for possible policies.
+ */
+class ShadeDisplayGoesAroundTestRule(private val policy: String = STATUS_BAR_POLICY) :
+    TestWatcher() {
+
+    override fun starting(description: Description?) {
+        super.starting(description)
+        shell("$BASE_COMMAND $policy")
+    }
+
+    override fun finished(description: Description?) {
+        super.finished(description)
+        shell("$BASE_COMMAND reset")
+    }
+
+    private companion object {
+        const val BASE_COMMAND = "cmd statusbar shade_display_override"
+        const val STATUS_BAR_POLICY = "status_bar_latest_touch"
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedConnectedDisplayTestRule.kt b/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedConnectedDisplayTestRule.kt
new file mode 100644
index 000000000..838874578
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedConnectedDisplayTestRule.kt
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.graphics.Point
+import android.hardware.display.DisplayManager
+import android.hardware.display.DisplayManager.DisplayListener
+import android.os.Handler
+import android.os.Looper
+import android.provider.Settings
+import android.util.Log
+import android.view.Display.TYPE_OVERLAY
+import androidx.test.platform.app.InstrumentationRegistry
+import kotlin.time.Duration.Companion.seconds
+import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.callbackFlow
+import kotlinx.coroutines.flow.take
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withTimeoutOrNull
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * A [TestRule] to manage multiple simulated connected overlay displays.
+ *
+ * @param initDisplayCount the number of displays to be set up immediately. Alternatively, it's
+ *   possible to setup new displays at a later stage (on-demand) by calling [setupTestDisplay] or
+ *   [setupTestDisplays].
+ */
+class SimulatedConnectedDisplayTestRule(val initDisplayCount: Int = 0) : TestRule {
+
+    private val context = InstrumentationRegistry.getInstrumentation().targetContext
+    private val displayManager = context.getSystemService(DisplayManager::class.java)
+    var addedDisplays = listOf<Int>()
+        private set
+
+    override fun apply(base: Statement, description: Description): Statement =
+        object : Statement() {
+            override fun evaluate() {
+                try {
+                    if (initDisplayCount > 0) {
+                        setupTestDisplays(initDisplayCount)
+                    }
+                    base.evaluate()
+                } finally {
+                    teardown()
+                }
+            }
+        }
+
+    private fun teardown() {
+        cleanupTestDisplays()
+    }
+
+    /**
+     * Adds multiple overlay displays with specified dimensions. Any existing overlay displays will
+     * be removed before adding the new ones.
+     *
+     * @param displays A list of [Point] objects, where each [Point] represents the width and height
+     *   of a simulated display.
+     * @return List of displayIds of added displays.
+     */
+    fun setupTestDisplays(displays: List<Point>): List<Int> = runBlocking {
+        // Cleanup any existing overlay displays.
+        cleanupTestDisplays()
+
+        if (displays.isEmpty()) {
+            Log.w(TAG, "setupTestDisplays called with an empty list. No displays created.")
+            return@runBlocking emptyList()
+        }
+
+        val displayAddedFlow: Flow<Int> = callbackFlow {
+            val listener =
+                object : DisplayListener {
+                    override fun onDisplayAdded(displayId: Int) {
+                        trySend(displayId)
+                    }
+
+                    override fun onDisplayRemoved(displayId: Int) {}
+
+                    override fun onDisplayChanged(displayId: Int) {}
+                }
+
+            val handler = Handler(Looper.getMainLooper())
+            displayManager.registerDisplayListener(listener, handler)
+
+            // `disable_window_interaction` is used to let interaction not get obstructed by
+            // OverlayDisplayWindow and let it go through to the window or surface behind it.
+            val displaySettings =
+                displays.joinToString(separator = ";") { size ->
+                    "${size.x}x${size.y}/$DEFAULT_DENSITY,disable_window_interaction"
+                }
+
+            // Add the overlay displays
+            Settings.Global.putString(
+                context.contentResolver,
+                Settings.Global.OVERLAY_DISPLAY_DEVICES,
+                displaySettings,
+            )
+
+            awaitClose { displayManager.unregisterDisplayListener(listener) }
+        }
+
+        addedDisplays = buildList {
+            withTimeoutOrNull(TIMEOUT) {
+                displayAddedFlow.take(displays.size).collect { displayId ->
+                    this@buildList += displayId
+                }
+            } ?: error("Timed out waiting for displays to be added.")
+        }
+        addedDisplays
+    }
+
+    /**
+     * Adds multiple overlay displays with default dimensions. Any existing overlay displays will be
+     * removed before adding the new ones.
+     *
+     * @param count number of displays to add.
+     * @return List of displayIds of added displays.
+     */
+    fun setupTestDisplays(count: Int): List<Int> {
+        val displays = List(count) { Point(DEFAULT_WIDTH, DEFAULT_HEIGHT) }
+        return setupTestDisplays(displays)
+    }
+
+    /** Add a single overlay display. */
+    fun setupTestDisplay(width: Int = DEFAULT_WIDTH, height: Int = DEFAULT_HEIGHT): Int =
+        setupTestDisplays(listOf(Point(width, height)))[0]
+
+    /**
+     * Removes all overlay displays. This function is safe to call manually, as it will be a no-op
+     * if all overlay displays have already been removed.
+     */
+    fun cleanupTestDisplays() = runBlocking {
+        val existingDisplays =
+            displayManager.displays.filter { it.type == TYPE_OVERLAY }.map { it.displayId }
+        if (existingDisplays.isEmpty()) {
+            return@runBlocking
+        }
+
+        val displayRemovedFlow: Flow<Int> = callbackFlow {
+            val listener =
+                object : DisplayListener {
+                    override fun onDisplayAdded(displayId: Int) {}
+
+                    override fun onDisplayRemoved(displayId: Int) {
+                        trySend(displayId)
+                    }
+
+                    override fun onDisplayChanged(displayId: Int) {}
+                }
+            val handler = Handler(Looper.getMainLooper())
+            displayManager.registerDisplayListener(listener, handler)
+
+            // Remove overlay displays. We'll execute this regardless of addedDisplays just to
+            // ensure all overlay displays are removed before and after the test.
+            // Note: If we want to restore the original overlay display added before this test (and
+            // its topology), it will be complicated as re-adding overlay display would lead to
+            // different displayId and topology could not be restored easily.
+            Settings.Global.putString(
+                context.contentResolver,
+                Settings.Global.OVERLAY_DISPLAY_DEVICES,
+                null,
+            )
+            awaitClose { displayManager.unregisterDisplayListener(listener) }
+        }
+
+        val removedDisplays = buildList {
+            withTimeoutOrNull(TIMEOUT) {
+                displayRemovedFlow.take(existingDisplays.size).collect { displayId ->
+                    this@buildList += displayId
+                }
+            } ?: error("Timed out waiting for displays to be removed: $existingDisplays")
+        }
+        addedDisplays = existingDisplays - removedDisplays
+    }
+
+    private companion object {
+        const val DEFAULT_WIDTH = 1280
+        const val DEFAULT_HEIGHT = 720
+        const val DEFAULT_DENSITY = 160
+        const val TAG = "SimulatedConnectedDisplayTestRule"
+        val TIMEOUT = 10.seconds
+    }
+}
diff --git a/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedDeviceController.kt b/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedDeviceController.kt
new file mode 100644
index 000000000..09906d654
--- /dev/null
+++ b/libraries/desktop-test-lib/src/platform/test/desktop/SimulatedDeviceController.kt
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.graphics.Point
+import android.hardware.display.DisplayManager
+import androidx.test.platform.app.InstrumentationRegistry
+import com.google.common.truth.Truth.assertWithMessage
+
+/**
+ * A simulated display device returned by a [SimulatedDeviceController].
+ *
+ * @param d The underlying [DisplayDevice].
+ */
+data class SimulatedDisplayDevice(val d: DisplayDevice) : DisplayDevice by d
+
+/** A controller for simulated peripherals. */
+class SimulatedDeviceController : PeripheralsController {
+    private val context = InstrumentationRegistry.getInstrumentation().targetContext
+    private val displayManager = context.getSystemService(DisplayManager::class.java)
+    private val simulatedDisplayTestRule = SimulatedConnectedDisplayTestRule()
+    private var currentDisplaysPeripherals = emptyList<Pair<DisplayPeripheral, Int>>()
+
+    override fun requestPeripherals(request: PeripheralsRequest): PeripheralsResponse {
+        request.validate(PeripheralType.SIMULATED, PeripheralType.PHYSICAL_OR_SIMULATED)
+
+        val displayPeripherals = mutableListOf<DisplayPeripheral>()
+
+        request.peripherals.forEach {
+            when (it) {
+                is DisplayPeripheral -> displayPeripherals.add(it)
+            }
+        }
+
+        return setupSimulatedDisplays(displayPeripherals)
+    }
+
+    private fun setupSimulatedDisplays(peripherals: List<DisplayPeripheral>): PeripheralsResponse {
+        if (peripherals.isEmpty() && currentDisplaysPeripherals.isEmpty()) {
+            return PeripheralsResponse()
+        }
+
+        val displayConfigs: List<Point> = peripherals.map { Point(it.size.width, it.size.height) }
+        val addedDisplayIds = simulatedDisplayTestRule.setupTestDisplays(displayConfigs)
+        assertWithMessage("Failed to setup all requested simulated displays")
+            .that(addedDisplayIds.size)
+            .isEqualTo(peripherals.size)
+
+        val removedDisplays = currentDisplaysPeripherals.filter { it.first !in peripherals }
+        currentDisplaysPeripherals = peripherals.zip(addedDisplayIds)
+
+        val addedResponse =
+            PeripheralsResponse(
+                currentDisplaysPeripherals.map { (peripheral, displayId) ->
+                    SimulatedDisplayDevice(
+                        AnyDisplayDevice(
+                            peripheral,
+                            connected = true,
+                            displayId,
+                            displayManager.getDisplay(displayId),
+                        )
+                    )
+                }
+            )
+
+        val removedResponse =
+            PeripheralsResponse(
+                removedDisplays.map { (peripheral, displayId) ->
+                    SimulatedDisplayDevice(
+                        AnyDisplayDevice(
+                            peripheral,
+                            connected = false,
+                            displayId,
+                            display = null,
+                        )
+                    )
+                }
+            )
+
+        return addedResponse + removedResponse
+    }
+}
diff --git a/libraries/desktop-test-lib/tests/Android.bp b/libraries/desktop-test-lib/tests/Android.bp
new file mode 100644
index 000000000..835dde2fc
--- /dev/null
+++ b/libraries/desktop-test-lib/tests/Android.bp
@@ -0,0 +1,41 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_desktop_experiences",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "DesktopTestLibTests",
+
+    platform_apis: true,
+    test_suites: ["general-tests"],
+
+    srcs: ["src/**/*.kt"],
+
+    libs: [
+        "android.test.runner.stubs.system",
+        "android.test.base.stubs.system",
+    ],
+    static_libs: [
+        "androidx.test.rules",
+        "mockito-target-minus-junit4",
+        "platform-test-annotations",
+        "desktop-test-lib",
+        "kotlinx_coroutines",
+        "truth",
+        "kotlin-test",
+    ],
+}
diff --git a/scripts/perf-setup/tests/AndroidManifest.xml b/libraries/desktop-test-lib/tests/AndroidManifest.xml
similarity index 59%
rename from scripts/perf-setup/tests/AndroidManifest.xml
rename to libraries/desktop-test-lib/tests/AndroidManifest.xml
index 90d4e046e..e6f5c6fff 100644
--- a/scripts/perf-setup/tests/AndroidManifest.xml
+++ b/libraries/desktop-test-lib/tests/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2021 The Android Open Source Project
+<!-- Copyright (C) 2025 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -15,12 +15,15 @@
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="android.test.perfsetup" >
+        package="platform.test.desktop">
 
-    <application/>
-
-    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
-                     android:targetPackage="android.test.perfsetup"
-                     android:label="Perf Setup Test"/>
+    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
 
+    <instrumentation
+        android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="platform.test.desktop"
+        android:label="Desktop Test Library Tests" />
 </manifest>
diff --git a/libraries/desktop-test-lib/tests/src/platform/test/desktop/DesktopMouseTestRuleTest.kt b/libraries/desktop-test-lib/tests/src/platform/test/desktop/DesktopMouseTestRuleTest.kt
new file mode 100644
index 000000000..e46f23d19
--- /dev/null
+++ b/libraries/desktop-test-lib/tests/src/platform/test/desktop/DesktopMouseTestRuleTest.kt
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.desktop
+
+import android.graphics.PointF
+import android.graphics.RectF
+import android.hardware.display.DisplayTopology.TreeNode
+import android.hardware.display.DisplayTopologyGraph
+import com.google.common.truth.Truth.assertThat
+import org.junit.Assert.assertThrows
+import org.junit.Test
+import platform.test.desktop.DesktopMouseTestRule.AdjacentDisplay
+import platform.test.desktop.DesktopMouseTestRule.AdjacentDisplay.Position
+
+class DesktopMouseTestRuleTest {
+
+    @Test
+    fun testCalculateCrossingDetailsDpRight() {
+        val b1 = RectF(100f, 100f, 200f, 200f)
+        val b2 = RectF(200f, 150f, 300f, 250f)
+        val position = Position.RIGHT
+
+        val result = DesktopMouseTestRule.calculateCrossingDetailsDp(b1, b2, position)
+
+        assertThat(result.targetPointDp).isEqualTo(PointF(200f, 175f))
+        assertThat(result.toCrossDxDp).isEqualTo(DesktopMouseTestRule.MOUSE_CROSS_DISPLAY_OFFSET_DP)
+        assertThat(result.toCrossDyDp).isEqualTo(0f)
+    }
+
+    @Test
+    fun testCalculateCrossingDetailsDpLeft() {
+        val b1 = RectF(100f, 100f, 200f, 200f)
+        val b2 = RectF(0f, 120f, 100f, 180f)
+        val position = Position.LEFT
+
+        val result = DesktopMouseTestRule.calculateCrossingDetailsDp(b1, b2, position)
+
+        assertThat(result.targetPointDp).isEqualTo(PointF(100f, 150f))
+        assertThat(result.toCrossDxDp)
+            .isEqualTo(-DesktopMouseTestRule.MOUSE_CROSS_DISPLAY_OFFSET_DP)
+        assertThat(result.toCrossDyDp).isEqualTo(0f)
+    }
+
+    @Test
+    fun testCalculateCrossingDetailsDpBottom() {
+        val b1 = RectF(100f, 100f, 200f, 200f)
+        val b2 = RectF(150f, 200f, 250f, 300f)
+        val position = Position.BOTTOM
+
+        val result = DesktopMouseTestRule.calculateCrossingDetailsDp(b1, b2, position)
+
+        assertThat(result.targetPointDp).isEqualTo(PointF(175f, 200f))
+        assertThat(result.toCrossDxDp).isEqualTo(0f)
+        assertThat(result.toCrossDyDp).isEqualTo(DesktopMouseTestRule.MOUSE_CROSS_DISPLAY_OFFSET_DP)
+    }
+
+    @Test
+    fun testCalculateCrossingDetailsDpTop() {
+        val b1 = RectF(100f, 100f, 200f, 200f)
+        val b2 = RectF(120f, 0f, 180f, 100f)
+        val position = Position.TOP
+
+        val result = DesktopMouseTestRule.calculateCrossingDetailsDp(b1, b2, position)
+
+        assertThat(result.targetPointDp).isEqualTo(PointF(150f, 100f))
+        assertThat(result.toCrossDxDp).isEqualTo(0f)
+        assertThat(result.toCrossDyDp)
+            .isEqualTo(-DesktopMouseTestRule.MOUSE_CROSS_DISPLAY_OFFSET_DP)
+    }
+
+    @Test
+    fun testFindPath() {
+        // DisplayTopology representation:
+        // [4] - [2] - [3]
+        //        |
+        //       [1]
+        val node1 =
+            DisplayTopologyGraph.DisplayNode(
+                1,
+                DEFAULT_DENSITY,
+                RectF(), // unused
+                arrayOf(
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        2,
+                        TreeNode.POSITION_TOP,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    )
+                ),
+            )
+        val node2 =
+            DisplayTopologyGraph.DisplayNode(
+                2,
+                DEFAULT_DENSITY,
+                RectF(), // unused
+                arrayOf(
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        1,
+                        TreeNode.POSITION_BOTTOM,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    ),
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        3,
+                        TreeNode.POSITION_RIGHT,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    ),
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        4,
+                        TreeNode.POSITION_LEFT,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    ),
+                ),
+            )
+        val node3 =
+            DisplayTopologyGraph.DisplayNode(
+                3,
+                DEFAULT_DENSITY,
+                RectF(), // unused
+                arrayOf(
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        2,
+                        TreeNode.POSITION_LEFT,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    )
+                ),
+            )
+        val node4 =
+            DisplayTopologyGraph.DisplayNode(
+                4,
+                DEFAULT_DENSITY,
+                RectF(), // unused
+                arrayOf(
+                    DisplayTopologyGraph.AdjacentDisplay(
+                        2,
+                        TreeNode.POSITION_RIGHT,
+                        DEFAULT_DISPLAY_OFFSET_DP,
+                    )
+                ),
+            )
+        val graph = DisplayTopologyGraph(1, arrayOf(node1, node2, node3, node4))
+
+        // Path from node 1
+        assertThat(DesktopMouseTestRule.findPath(1, 1, graph)).isEmpty()
+        assertThat(DesktopMouseTestRule.findPath(1, 2, graph))
+            .containsExactly(AdjacentDisplay(2, Position.TOP))
+        assertThat(DesktopMouseTestRule.findPath(1, 3, graph))
+            .containsExactly(AdjacentDisplay(2, Position.TOP), AdjacentDisplay(3, Position.RIGHT))
+            .inOrder()
+        assertThat(DesktopMouseTestRule.findPath(1, 4, graph))
+            .containsExactly(AdjacentDisplay(2, Position.TOP), AdjacentDisplay(4, Position.LEFT))
+            .inOrder()
+
+        // Path from node 2
+        assertThat(DesktopMouseTestRule.findPath(2, 1, graph))
+            .containsExactly(AdjacentDisplay(1, Position.BOTTOM))
+
+        assertThat(DesktopMouseTestRule.findPath(2, 2, graph)).isEmpty()
+
+        assertThat(DesktopMouseTestRule.findPath(2, 3, graph))
+            .containsExactly(AdjacentDisplay(3, Position.RIGHT))
+
+        assertThat(DesktopMouseTestRule.findPath(2, 4, graph))
+            .containsExactly(AdjacentDisplay(4, Position.LEFT))
+
+        // Path from node 3
+        assertThat(DesktopMouseTestRule.findPath(3, 1, graph))
+            .containsExactly(AdjacentDisplay(2, Position.LEFT), AdjacentDisplay(1, Position.BOTTOM))
+            .inOrder()
+        assertThat(DesktopMouseTestRule.findPath(3, 2, graph))
+            .containsExactly(AdjacentDisplay(2, Position.LEFT))
+        assertThat(DesktopMouseTestRule.findPath(3, 3, graph)).isEmpty()
+        assertThat(DesktopMouseTestRule.findPath(3, 4, graph))
+            .containsExactly(AdjacentDisplay(2, Position.LEFT), AdjacentDisplay(4, Position.LEFT))
+            .inOrder()
+
+        // Path from node 4
+        assertThat(DesktopMouseTestRule.findPath(4, 1, graph))
+            .containsExactly(
+                AdjacentDisplay(2, Position.RIGHT),
+                AdjacentDisplay(1, Position.BOTTOM),
+            )
+            .inOrder()
+        assertThat(DesktopMouseTestRule.findPath(4, 2, graph))
+            .containsExactly(AdjacentDisplay(2, Position.RIGHT))
+        assertThat(DesktopMouseTestRule.findPath(4, 3, graph))
+            .containsExactly(AdjacentDisplay(2, Position.RIGHT), AdjacentDisplay(3, Position.RIGHT))
+            .inOrder()
+        assertThat(DesktopMouseTestRule.findPath(4, 4, graph)).isEmpty()
+
+        assertThrows(DesktopMouseTestRule.NoPathFoundException::class.java) {
+            DesktopMouseTestRule.findPath(1, 5, graph)
+        }
+    }
+
+    private companion object {
+        val DEFAULT_DENSITY = 160
+        val DEFAULT_DISPLAY_OFFSET_DP = 0f
+    }
+}
diff --git a/libraries/desktop-test-lib/tests/src/platform/test/desktop/PeripheralDeviceTest.kt b/libraries/desktop-test-lib/tests/src/platform/test/desktop/PeripheralDeviceTest.kt
new file mode 100644
index 000000000..c01f4e2c9
--- /dev/null
+++ b/libraries/desktop-test-lib/tests/src/platform/test/desktop/PeripheralDeviceTest.kt
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package platform.test.desktop
+
+import com.google.common.truth.Truth.assertThat
+import kotlin.test.fail
+import org.junit.Rule
+import org.junit.Test
+
+/** Tests for [PeripheralDeviceTestRule]. */
+public class PeripheralDeviceTest {
+    @get:Rule val peripheralDeviceRule = PeripheralDeviceTestRule()
+
+    @Test
+    fun testSimulatedDisplay() {
+        val response =
+            peripheralDeviceRule.requestPeripherals(
+                DisplayPeripheral(PeripheralType.SIMULATED, DisplaySize.SIZE_1080P)
+            )
+        assertThat(response.devices.filter { it.connected }).hasSize(1)
+        response.devices.forEach {
+            when (it) {
+                is SimulatedDisplayDevice -> assertThat(it.displayId).isGreaterThan(0)
+                else -> fail("Unexpected peripheral device: $it")
+            }
+        }
+    }
+
+    @Test
+    fun testPhysicalDisplay() {
+        val response =
+            peripheralDeviceRule.requestPeripherals(
+                DisplayPeripheral(PeripheralType.PHYSICAL, DisplaySize.SIZE_1080P)
+            )
+        assertThat(response.devices.filter { it.connected }).hasSize(1)
+        response.devices.forEach {
+            when (it) {
+                is PhysicalDisplayDevice -> assertThat(it.displayId).isGreaterThan(0)
+                else -> fail("Unexpected peripheral device: $it")
+            }
+        }
+    }
+
+    @Test
+    fun testPhysicalOrSimulatedDisplay() {
+        val response =
+            peripheralDeviceRule.requestPeripherals(
+                DisplayPeripheral(PeripheralType.PHYSICAL_OR_SIMULATED, DisplaySize.SIZE_1080P)
+            )
+        assertThat(response.devices.filter { it.connected }).hasSize(1)
+        response.devices.forEach {
+            when (it) {
+                is DisplayDevice -> assertThat(it.displayId).isGreaterThan(0)
+                else -> fail("Unexpected peripheral device: $it")
+            }
+        }
+    }
+}
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/BaseMetricListener.java b/libraries/device-collectors/src/main/java/android/device/collectors/BaseMetricListener.java
index 91ca9d3d2..ce08e1f4e 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/BaseMetricListener.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/BaseMetricListener.java
@@ -85,6 +85,8 @@ public class BaseMetricListener extends InstrumentationRunListener {
     public static final String EXCLUDE_FILTER_GROUP_KEY = "exclude-filter-group";
     // Argument passed to AndroidJUnitRunner to make it log-only, we shouldn't collect on log only.
     public static final String ARGUMENT_LOG_ONLY = "log";
+    // Same as log, but makes it more explicit that we are disabling metric collection.
+    public static final String ARGUMENT_DISABLE_METRIC_COLLECTION = "disable";
     // Collect metric every nth iteration of a test with the same name.
     public static final String COLLECT_ITERATION_INTERVAL = "collect_iteration_interval";
 
@@ -101,7 +103,7 @@ public class BaseMetricListener extends InstrumentationRunListener {
     private Bundle mArgsBundle = null;
     private final List<String> mIncludeFilters;
     private final List<String> mExcludeFilters;
-    private boolean mLogOnly = false;
+    private boolean mDisableMetricCollection = false;
     // Store the method name and invocation count.
     private Map<String, Integer> mTestIdInvocationCount = new HashMap<>();
     private int mCollectIterationInterval = 1;
@@ -130,7 +132,7 @@ public class BaseMetricListener extends InstrumentationRunListener {
     public final void testRunStarted(Description description) throws Exception {
         Trace.beginSection(this.getClass().getSimpleName() + ":testRunStarted");
         setUp();
-        if (!mLogOnly) {
+        if (!mDisableMetricCollection) {
             try {
                 mRunData = createDataRecord();
                 onTestRunStart(mRunData, description);
@@ -146,7 +148,7 @@ public class BaseMetricListener extends InstrumentationRunListener {
     @Override
     public final void testRunFinished(Result result) throws Exception {
         Trace.beginSection(this.getClass().getSimpleName() + ":testRunFinished");
-        if (!mLogOnly) {
+        if (!mDisableMetricCollection) {
             try {
                 onTestRunEnd(mRunData, result);
             } catch (RuntimeException e) {
@@ -475,10 +477,19 @@ public class BaseMetricListener extends InstrumentationRunListener {
             // Reset to collect for all the iterations.
             mCollectIterationInterval = 1;
         }
-        String logOnly = args.getString(ARGUMENT_LOG_ONLY);
-        if (logOnly != null) {
-            mLogOnly = Boolean.parseBoolean(logOnly);
+        final Boolean logOnly = getBooleanArg(ARGUMENT_LOG_ONLY, false);
+        final Boolean disableMetricCollection =
+                getBooleanArg(ARGUMENT_DISABLE_METRIC_COLLECTION, false);
+        mDisableMetricCollection = logOnly || disableMetricCollection;
+    }
+
+    private Boolean getBooleanArg(String key, Boolean defaultValue) {
+        Bundle args = getArgsBundle();
+        String value = args.getString(key);
+        if (value == null) {
+            return defaultValue;
         }
+        return Boolean.parseBoolean(value);
     }
 
     /**
@@ -524,7 +535,7 @@ public class BaseMetricListener extends InstrumentationRunListener {
      * @return True if the collector should run.
      */
     private boolean shouldRun(Description desc) {
-        if (mLogOnly) {
+        if (mDisableMetricCollection) {
             return false;
         }
 
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoListener.java b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoListener.java
index 680d3ae07..5538acd74 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoListener.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoListener.java
@@ -17,6 +17,7 @@ package android.device.collectors;
 
 import android.device.collectors.annotations.OptionClass;
 import android.os.Bundle;
+import android.os.Trace;
 
 import androidx.annotation.VisibleForTesting;
 
@@ -62,6 +63,11 @@ public class PerfettoListener extends BaseMetricListener {
     @Override
     public void onTestStart(DataRecord testData, Description description) {
         final int iteration = getIteration(description);
+        String sectionName = "test:" + description;
+        if (iteration > 0) {
+            sectionName += " iteration:" + iteration;
+        }
+        Trace.beginSection(sectionName);
         mTracingStrategies.forEach(strategy -> strategy.testStart(testData, description,
                 iteration));
     }
@@ -75,6 +81,7 @@ public class PerfettoListener extends BaseMetricListener {
     public void onTestEnd(DataRecord testData, Description description) {
         final int iteration = getIteration(description);
         mTracingStrategies.forEach(strategy -> strategy.testEnd(testData, description, iteration));
+        Trace.endSection();
     }
 
     @Override
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoOOMListener.java b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoOOMListener.java
new file mode 100644
index 000000000..251f167c7
--- /dev/null
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoOOMListener.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.device.collectors;
+
+import android.device.collectors.annotations.OptionClass;
+
+/**
+ * A {@link PerfettoOOMListener} that captures the perfetto trace if there is an OOM during the
+ * test.
+ */
+@OptionClass(alias = "perfetto-oom-collector")
+public class PerfettoOOMListener extends PerfettoListener {
+
+    public PerfettoOOMListener() {
+        super();
+    }
+}
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingPerClassStrategy.java b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingPerClassStrategy.java
index 3a59df931..0a667f81b 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingPerClassStrategy.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingPerClassStrategy.java
@@ -41,7 +41,17 @@ import java.util.function.Supplier;
 public class PerfettoTracingPerClassStrategy extends PerfettoTracingStrategy {
     private static final String STRATEGY_IDENTIFIER = "per_class";
 
-    private List<String> mFileList = new ArrayList<>();
+    private static final class TraceResult {
+        public final String mPath;
+        public final boolean mHasFailure;
+
+        TraceResult(String path, boolean hasFailure) {
+            mPath = path;
+            mHasFailure = hasFailure;
+        }
+    }
+
+    private final List<TraceResult> mResults = new ArrayList<>();
     private Description mLastDescription;
 
     PerfettoTracingPerClassStrategy(Instrumentation instr) {
@@ -118,7 +128,7 @@ public class PerfettoTracingPerClassStrategy extends PerfettoTracingStrategy {
                             return;
                         }
 
-                        mFileList.add(path.toString());
+                        mResults.add(new TraceResult(path.toString(), mIsTestFailed));
                         if (isTestRunEnd) {
                             uploadMetrics(dataRecord);
                         }
@@ -129,9 +139,14 @@ public class PerfettoTracingPerClassStrategy extends PerfettoTracingStrategy {
 
     private void uploadMetrics(DataRecord dataRecord) {
         int counter = 0;
-        for (String filePath : mFileList) {
-            String metricName = getFilePathKeyPrefix() + counter++;
-            dataRecord.addStringMetric(metricName, filePath);
+        for (TraceResult result : mResults) {
+            var metricName = new StringBuilder(getFilePathKeyPrefix());
+            if (result.mHasFailure) {
+                metricName.append("_FAILED");
+            }
+            metricName.append("_").append(counter++);
+
+            dataRecord.addStringMetric(metricName.toString(), result.mPath);
         }
     }
 
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
index 0c738cda3..d9de1caa3 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
@@ -68,14 +68,15 @@ public abstract class PerfettoTracingStrategy {
     public static final String SKIP_TEST_FAILURE_METRICS = "skip_test_failure_metrics";
     // Skip success metrics collection if this flag is set to true (i.e. collect only failures).
     public static final String SKIP_TEST_SUCCESS_METRICS = "skip_test_success_metrics";
+    // Skip the empty metrics storing if this flag is set to true (i.e. if the perfetto trace file
+    // is empty, then do not store the empty file).
+    public static final String SKIP_EMPTY_METRICS = "skip_empty_metrics";
     // List of test iterations to capture, capture all if empty
     public static final String ARGUMENT_ALLOW_ITERATIONS = "allow_iterations";
     // Perfetto file path key argument name
     public static final String ARGUMENT_FILE_PATH_KEY_PREFIX = "perfetto_file_path_key_prefix";
     // Perfetto file path key prefix
     protected static final String DEFAULT_FILE_PATH_KEY_PREFIX = "perfetto_file_path";
-    // Perfetto file path key prefix for failed tests
-    protected static final String FAILED_FILE_PATH_KEY_PREFIX = "perfetto_failed_file_path";
     // Argument to get custom time in millisecs to wait before dumping the trace.
     // This has to be at least the dump interval time set in the trace config file
     // or greater than that. Otherwise, we will miss trace information from the test.
@@ -133,7 +134,8 @@ public abstract class PerfettoTracingStrategy {
     private String mConfigContent;
     protected boolean mSkipTestFailureMetrics;
     private boolean mSkipTestSuccessMetrics;
-    private boolean mIsTestFailed = false;
+    private boolean mSkipEmptyMetrics;
+    protected boolean mIsTestFailed = false;
     // Store the method name and invocation count to create unique file name for each trace.
     private boolean mPerfettoStartSuccess = false;
     private String mFilePathKeyPrefix = DEFAULT_FILE_PATH_KEY_PREFIX;
@@ -322,7 +324,7 @@ public abstract class PerfettoTracingStrategy {
             String metricName) {
         if (stopPerfettoTracing(path)) {
             if (mIsTestFailed) {
-                record.addStringMetric(FAILED_FILE_PATH_KEY_PREFIX, path.toString());
+                record.addStringMetric(metricName + "_FAILED", path.toString());
             } else {
                 record.addStringMetric(metricName, path.toString());
             }
@@ -504,10 +506,15 @@ public abstract class PerfettoTracingStrategy {
         mTestOutputRoot = getArgumentValue(args, TEST_OUTPUT_ROOT, DEFAULT_OUTPUT_ROOT);
 
         // By default, this flag is set to false to collect the metrics on test failure.
-        mSkipTestFailureMetrics = Boolean.parseBoolean(getArgumentValue(args,
-                SKIP_TEST_FAILURE_METRICS, String.valueOf(false)));
+        mSkipTestFailureMetrics =
+                Boolean.parseBoolean(
+                        getArgumentValue(args, SKIP_TEST_FAILURE_METRICS, String.valueOf(false)));
         mSkipTestSuccessMetrics = Boolean.parseBoolean(getArgumentValue(args,
                 SKIP_TEST_SUCCESS_METRICS, String.valueOf(false)));
+        mSkipEmptyMetrics =
+                Boolean.parseBoolean(
+                        getArgumentValue(args, SKIP_EMPTY_METRICS, String.valueOf(false)));
+        mPerfettoHelper.setCheckEmptyMetrics(mSkipEmptyMetrics);
 
         mFilePathKeyPrefix = getArgumentValue(args, ARGUMENT_FILE_PATH_KEY_PREFIX,
                 DEFAULT_FILE_PATH_KEY_PREFIX);
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/SimpleperfListener.java b/libraries/device-collectors/src/main/java/android/device/collectors/SimpleperfListener.java
index 8ed6c7909..4def06705 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/SimpleperfListener.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/SimpleperfListener.java
@@ -47,7 +47,8 @@ public class SimpleperfListener extends BaseMetricListener {
     // Default subcommand passed to simpleperf
     private static final String DEFAULT_SUBCOMMAND = "record";
     // Default arguments passed to simpleperf command
-    private static final String DEFAULT_ARGUMENTS = "-g --post-unwind=yes -f 500 -a --exclude-perf";
+    private static final String DEFAULT_ARGUMENTS =
+            "-g --post-unwind=yes -f 500 --exclude-perf --log-to-android-buffer";
     // Destination directory to save the trace results.
     private static final String TEST_OUTPUT_ROOT = "test_output_root";
     // Simpleperf file path key.
@@ -164,6 +165,9 @@ public class SimpleperfListener extends BaseMetricListener {
                 mProcessToPid.put(process, mSimpleperfHelper.getPID(process));
             }
             mArguments += " -p " + String.join(",", mProcessToPid.values());
+        } else {
+            // Record system wide.
+            mArguments += " -a";
         }
 
         mTestIterations = Integer.parseInt(args.getString(TEST_ITERATIONS, "1"));
diff --git a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerClassStrategyTest.java b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerClassStrategyTest.java
index f0a0815e1..514e95d2c 100644
--- a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerClassStrategyTest.java
+++ b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerClassStrategyTest.java
@@ -33,11 +33,14 @@ import androidx.test.runner.AndroidJUnit4;
 
 import com.android.helpers.PerfettoHelper;
 
+import com.google.common.truth.Truth;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.RunWith;
+import org.junit.runner.notification.Failure;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.mockito.Spy;
@@ -62,6 +65,9 @@ public class PerfettoTracingPerClassStrategyTest {
     @Mock private PerfettoTracingStrategy.WakeLockAcquirer mWakelLockAcquirer;
     @Mock private PerfettoTracingStrategy.WakeLockReleaser mWakeLockReleaser;
 
+    private static final Description FAKE_TEST_DESCRIPTION =
+            Description.createTestDescription("class", "method");
+
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
@@ -213,4 +219,27 @@ public class PerfettoTracingPerClassStrategyTest {
         strategy.testRunEnd(dataRecord, new Result());
         verify(dataRecord, times(2)).addStringMetric(anyString(), anyString());
     }
+
+    @Test
+    public void testPostedFailedMetricWhenTestFails() {
+        Bundle b = new Bundle();
+        doReturn(true).when(mPerfettoHelper).startCollecting();
+        doReturn(true).when(mPerfettoHelper).stopCollecting(anyLong(), anyString());
+        PerfettoTracingStrategy strategy = initStrategy(b);
+        // Test run start behavior
+        strategy.testRunStart(mDataRecord, mRunDesc);
+        strategy.testStart(mDataRecord, mTest1Desc, /* iteration= */ 1);
+
+        strategy.setPerfettoStartSuccess(true);
+        Failure failureDesc = new Failure(FAKE_TEST_DESCRIPTION, new Exception());
+        strategy.testFail(mDataRecord, mTest1Desc, failureDesc);
+        strategy.testEnd(mDataRecord, mTest1Desc, /* iteration= */ 1);
+        strategy.testRunEnd(mDataRecord, null);
+
+        Truth.assertWithMessage("DataRecord should have metrics")
+                .that(mDataRecord.hasMetrics())
+                .isTrue();
+        var path = mDataRecord.createBundleFromMetrics().getString("perfetto_file_path_FAILED_0");
+        Truth.assertThat(path).isNotEmpty();
+    }
 }
diff --git a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerRunStrategyTest.java b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerRunStrategyTest.java
index 252a7b3f4..eb8a7ffb5 100644
--- a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerRunStrategyTest.java
+++ b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerRunStrategyTest.java
@@ -33,6 +33,8 @@ import androidx.test.runner.AndroidJUnit4;
 
 import com.android.helpers.PerfettoHelper;
 
+import com.google.common.truth.Truth;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.Description;
@@ -208,4 +210,27 @@ public class PerfettoTracingPerRunStrategyTest {
         verify(mPerfettoHelper, times(1)).startCollecting();
         verify(mPerfettoHelper, times(0)).stopCollecting(anyLong(), anyString());
     }
+
+    @Test
+    public void testPostedFailedMetricWhenTestFails() {
+        Bundle b = new Bundle();
+        doReturn(true).when(mPerfettoHelper).startCollecting();
+        doReturn(true).when(mPerfettoHelper).stopCollecting(anyLong(), anyString());
+        PerfettoTracingStrategy strategy = initStrategy(b);
+        // Test run start behavior
+        strategy.testRunStart(mDataRecord, mRunDesc);
+        strategy.testStart(mDataRecord, mTest1Desc, /* iteration= */ 1);
+
+        strategy.setPerfettoStartSuccess(true);
+        Failure failureDesc = new Failure(FAKE_TEST_DESCRIPTION, new Exception());
+        strategy.testFail(mDataRecord, mTest1Desc, failureDesc);
+        strategy.testEnd(mDataRecord, mTest1Desc, /* iteration= */ 1);
+        strategy.testRunEnd(mDataRecord, null);
+
+        Truth.assertWithMessage("DataRecord should have metrics")
+                .that(mDataRecord.hasMetrics())
+                .isTrue();
+        var path = mDataRecord.createBundleFromMetrics().getString("perfetto_file_path_FAILED");
+        Truth.assertThat(path).isNotEmpty();
+    }
 }
diff --git a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerTestStrategyTest.java b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerTestStrategyTest.java
index 59b10583c..825537255 100644
--- a/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerTestStrategyTest.java
+++ b/libraries/device-collectors/src/test/java/android/device/collectors/PerfettoTracingPerTestStrategyTest.java
@@ -33,6 +33,8 @@ import androidx.test.runner.AndroidJUnit4;
 
 import com.android.helpers.PerfettoHelper;
 
+import com.google.common.truth.Truth;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.Description;
@@ -204,4 +206,26 @@ public class PerfettoTracingPerTestStrategyTest {
         verify(mPerfettoHelper, times(1)).startCollecting();
         verify(mPerfettoHelper, times(0)).stopCollecting(anyLong(), anyString());
     }
+
+    @Test
+    public void testPostedFailedMetricWhenTestFails() {
+        Bundle b = new Bundle();
+        doReturn(true).when(mPerfettoHelper).startCollecting();
+        doReturn(true).when(mPerfettoHelper).stopCollecting(anyLong(), anyString());
+        PerfettoTracingStrategy strategy = initStrategy(b);
+        // Test run start behavior
+        strategy.testRunStart(mDataRecord, mRunDesc);
+        strategy.testStart(mDataRecord, mTest1Desc, /* iteration= */ 1);
+
+        strategy.setPerfettoStartSuccess(true);
+        Failure failureDesc = new Failure(FAKE_TEST_DESCRIPTION, new Exception());
+        strategy.testFail(mDataRecord, mTest1Desc, failureDesc);
+        strategy.testEnd(mDataRecord, mTest1Desc, /* iteration= */ 1);
+
+        Truth.assertWithMessage("DataRecord should have metrics")
+                .that(mDataRecord.hasMetrics())
+                .isTrue();
+        var path = mDataRecord.createBundleFromMetrics().getString("perfetto_file_path_FAILED");
+        Truth.assertThat(path).isNotEmpty();
+    }
 }
diff --git a/libraries/device-collectors/src/test/java/android/device/collectors/SimpleperfListenerTest.java b/libraries/device-collectors/src/test/java/android/device/collectors/SimpleperfListenerTest.java
index 4e6f238b9..4df679967 100644
--- a/libraries/device-collectors/src/test/java/android/device/collectors/SimpleperfListenerTest.java
+++ b/libraries/device-collectors/src/test/java/android/device/collectors/SimpleperfListenerTest.java
@@ -123,12 +123,13 @@ public class SimpleperfListenerTest {
                 .startCollecting(
                         eq("record"),
                         eq(
-                                "-g --post-unwind=yes -f 500 -a --exclude-perf -e"
-                                        + " instructions,cpu-cycles -p 1696,680"));
+                                "-g --post-unwind=yes -f 500 --exclude-perf --log-to-android-buffer"
+                                        + " -e instructions,cpu-cycles -p 1696,680"));
         verify(mUiDevice, times(1))
                 .executeShellCommand(
                         "simpleperf record -o /data/local/tmp/perf.data -g --post-unwind=yes -f"
-                                + " 500 -a --exclude-perf -e instructions,cpu-cycles -p 1696,680");
+                                + " 500 --exclude-perf --log-to-android-buffer"
+                                + " -e instructions,cpu-cycles -p 1696,680");
     }
 
     private void testSampleReport() {
@@ -340,6 +341,7 @@ public class SimpleperfListenerTest {
         doReturn(true)
                 .when(mSimpleperfHelperVisibleUidevice)
                 .startCollecting(anyString(), anyString());
+        doReturn(true).when(mSimpleperfHelperVisibleUidevice).stopCollecting(anyString());
 
         mListener.testRunStarted(mRunDesc);
         verify(mSimpleperfHelperVisibleUidevice, times(2)).getPID(anyString());
@@ -374,6 +376,7 @@ public class SimpleperfListenerTest {
         doReturn(true)
                 .when(mSimpleperfHelperVisibleUidevice)
                 .startCollecting(anyString(), anyString());
+        doReturn(true).when(mSimpleperfHelperVisibleUidevice).stopCollecting(anyString());
 
         mListener.testRunStarted(mRunDesc);
         mListener.testStarted(mTest1Desc);
diff --git a/libraries/flag-helpers/junit/src_base/android/platform/test/flag/junit/SetFlagsRule.java b/libraries/flag-helpers/junit/src_base/android/platform/test/flag/junit/SetFlagsRule.java
index d652c13d3..35c6cafd2 100644
--- a/libraries/flag-helpers/junit/src_base/android/platform/test/flag/junit/SetFlagsRule.java
+++ b/libraries/flag-helpers/junit/src_base/android/platform/test/flag/junit/SetFlagsRule.java
@@ -715,10 +715,12 @@ public final class SetFlagsRule implements TestRule {
                 throw new FlagSetException(
                         flag.fullFlagName(),
                         "This flag was locked when it was read outside of the test code; likely"
-                                + " during initialization of the test class. To fix this error,"
-                                + " move test fixture initialization code into your"
-                                + " @Before-annotated setup method, and ensure you are using"
-                                + " @EnableFlags() and @DisableFlags() to set flags.",
+                            + " during initialization of the test class, or due some action"
+                            + " performed in a previous tests that have repercussion in this one"
+                            + " (lack of test isolation). To fix this error, move test fixture"
+                            + " initialization code into your @Before-annotated setup method, and"
+                            + " ensure you are using @EnableFlags() and @DisableFlags() to set"
+                            + " flags.",
                         firstReadOutsideTest);
             }
             if (!isFlagsClassMonitored(flag)) {
diff --git a/libraries/flicker/TEST_MAPPING b/libraries/flicker/TEST_MAPPING
new file mode 100644
index 000000000..6b5879e6a
--- /dev/null
+++ b/libraries/flicker/TEST_MAPPING
@@ -0,0 +1,13 @@
+{
+  "wm-cf": [
+    {
+      "name": "FlickerLibTest"
+    },
+    {
+      "name": "FlickerLibTestE2e"
+    },
+    {
+      "name": "FlickerLibUtilsTest"
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
index 994c6f288..8d88bd582 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
@@ -19,10 +19,18 @@ package android.tools.device.apphelpers
 import android.app.Instrumentation
 import android.content.Intent
 import android.content.pm.PackageManager
+import android.graphics.Point
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
 import android.tools.traces.component.IComponentNameMatcher
+import android.tools.traces.parsers.WindowManagerStateHelper
+import android.tools.traces.wm.WindowingMode
+import android.util.Log
 import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiDevice
+import androidx.test.uiautomator.Until
+import java.time.Duration
 
 /**
  * Helper to launch the default browser app (compatible with AOSP)
@@ -44,7 +52,171 @@ constructor(
         pkgManager.getLaunchIntentForPackage(packageName)
             ?: error("Unable to find intent for browser")
 
+    private val device = UiDevice.getInstance(instrumentation)
+
+    fun openThreeDotsMenu() {
+        device
+            .wait(Until.findObject(By.res(packageName, "menu_button")), WAIT_TIME_IN_MILLISECONDS)
+            .click()
+    }
+
+    fun clickNewTabInTaskbarContextMenu() {
+        device
+            .wait(
+                Until.findObject(
+                    By.text("New tab")
+                        .hasAncestor(
+                            By.res(
+                                "com.google.android.apps.nexuslauncher",
+                                "deep_shortcut_material",
+                            )
+                        )
+                ),
+                WAIT_TIME_IN_MILLISECONDS,
+            )
+            .click()
+    }
+
+    fun clickNewTabInMenu() {
+        device
+            .wait(
+                Until.findObject(By.res(packageName, "new_tab_menu_id")),
+                WAIT_TIME_IN_MILLISECONDS,
+            )
+            .click()
+    }
+
+    /** Clears the Chrome application's storage and data. */
+    fun clearStorage() {
+        device.executeShellCommand("pm clear $packageName")
+    }
+
+    /**
+     * Simulates the UI action of "tearing" a tab out of its current window.
+     *
+     * This gesture is intended to trigger the tab detachment behavior in applications that support
+     * it. Note: The effectiveness of this function depends on the hardcoded start/end points
+     * aligning with the actual UI elements (tab location, drop target area) in the application
+     * under test.
+     *
+     * @param device The UiDevice instance used to perform the drag interaction on the device.
+     * @param wmHelper A helper class instance used to retrieve window and display dimension
+     *   information.
+     * @param direction A direction where the tab should be dragged to.
+     */
+    fun performTabTearing(
+        wmHelper: WindowManagerStateHelper,
+        direction: TabDraggingDirection = TabDraggingDirection.TOP_LEFT,
+    ) {
+        require(isFreeform(wmHelper)) { "Windowing mode should be WINDOWING_MODE_FREEFORM" }
+        val windowBounds = wmHelper.getWindowRegion(this).bounds
+        val windowWidthInPx = windowBounds.width()
+        val windowWidthInDp =
+            Math.round(
+                windowWidthInPx.toFloat() / context.getResources().getDisplayMetrics().density
+            )
+        require(windowWidthInDp >= MIN_WINDOW_WIDTH_FOR_TAB_TEARING_DP) {
+            "Window width is to small to drag one of its tabs"
+        }
+        // Define the drag start point. Since the tab is rendered directly on a surface, we cannot
+        // easily query its exact bounds. Instead, we use hardcoded offsets (300px right, 40px down)
+        // from the window's top-left corner, hoping to reliably land the starting point somewhere
+        // on the draggable tab area.
+        val startDraggingPoint =
+            Point(/* x= */ windowBounds.left + 300, /* y= */ windowBounds.top + 40)
+        // Define the drag end point. This point is intentionally outside the original window bounds
+        // (100px left, 100px up from the window's top-left corner) to simulate dragging the tab
+        // clear of the window, triggering the "tear" action.
+        val endDraggingPoint =
+            when (direction) {
+                TabDraggingDirection.TOP_LEFT ->
+                    Point(/* x= */ windowBounds.left - 100, /* y= */ windowBounds.top - 100)
+            }
+        device.drag(
+            startDraggingPoint.x,
+            startDraggingPoint.y,
+            endDraggingPoint.x,
+            endDraggingPoint.y,
+            /* steps= */ 100,
+        )
+    }
+
+    fun isFreeform(wmHelper: WindowManagerStateHelper): Boolean =
+        wmHelper.getWindow(this)?.windowingMode == WindowingMode.WINDOWING_MODE_FREEFORM.value
+
+    /**
+     * Closes any known pop-up dialogs that might appear during the test.
+     *
+     * This function checks for and dismisses two types of pop-ups:
+     * 1. **Notification Permission Pop-up:** If a pop-up asking for notification permissions is
+     *    present, it clicks the "No thanks" negative button to dismiss it.
+     * 2. **Ad Privacy Pop-up:** If a pop-up related to ad privacy is present, it dismisses it and
+     *    then handles a follow-up "other" ad privacy popup by clicking "More" button (if present),
+     *    and then pressing "Got it" button.
+     *
+     * The function uses `UiDevice` to interact with the device's UI and searches for specific text
+     * elements to identify the pop-ups. It also includes logging to provide information about which
+     * pop-ups were detected and dismissed.
+     *
+     * @param device The UiDevice instance used to interact with the device's UI.
+     * @return `true` if any pop-up was found and dismissed, `false` otherwise.
+     */
+    fun closePopupsIfNeeded(device: UiDevice): Boolean {
+        if (device.hasObject(By.text(NOTIFICATION_PERMISSION_TEXT))) {
+            val negativeButton = device.findObject(By.text(NEGATIVE_BUTTON_TEXT))
+            negativeButton.click()
+            Log.d(TAG, "Dismiss grant notification pop-up")
+            return true
+        }
+
+        if (device.hasObject(By.text(AD_PRIVACY_TITLE_TEXT))) {
+            val negativeButton = device.findObject(By.text(NEGATIVE_BUTTON_TEXT))
+            negativeButton.click()
+            Log.d(TAG, "Dismiss ad privacy pop-up")
+
+            // Next popup about ad privacy is showed immediately - we need to close it as well
+            device.wait(
+                Until.findObject(By.text(OTHER_AD_PRIVACY_TITLE_TEXT)),
+                WAIT_TIME_IN_MILLISECONDS,
+            )
+            if (device.hasObject(By.res(packageName, MORE_BUTTON_ID))) {
+                val moreButton = device.findObject(By.res(packageName, MORE_BUTTON_ID))
+                moreButton.click()
+                device.waitForIdle()
+                Log.d(TAG, "Click the more button")
+            }
+
+            val ackButton =
+                device.wait(
+                    Until.findObject(By.text(ACKNOWLEDGED_BUTTON_TEXT)),
+                    WAIT_TIME_IN_MILLISECONDS,
+                )
+            ackButton.click()
+            Log.d(TAG, "Dismiss other ad privacy pop-up")
+            device.waitForIdle()
+            return true
+        }
+
+        return false
+    }
+
     companion object {
+        enum class TabDraggingDirection {
+            TOP_LEFT
+        }
+
+        private const val TAG = "BrowserAppHelper"
+
+        private const val NOTIFICATION_PERMISSION_TEXT = "Chrome notifications make things easier"
+        private const val AD_PRIVACY_TITLE_TEXT = "Turn on an ad privacy feature"
+        private const val OTHER_AD_PRIVACY_TITLE_TEXT = "Other ad privacy features now available"
+        private const val NEGATIVE_BUTTON_TEXT = "No thanks"
+        private const val MORE_BUTTON_ID = "more_button"
+        private const val ACKNOWLEDGED_BUTTON_TEXT = "Got it"
+
+        private val WAIT_TIME_IN_MILLISECONDS = Duration.ofSeconds(3).toMillis()
+        private const val MIN_WINDOW_WIDTH_FOR_TAB_TEARING_DP = 600
+
         private fun getBrowserIntent(): Intent {
             val intent = Intent(Intent.ACTION_VIEW, Uri.parse("http://"))
             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
index e9a66bd84..b49fb165d 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
@@ -16,6 +16,7 @@
 
 package android.tools.device.apphelpers
 
+import android.app.ActivityOptions
 import android.content.Intent
 import android.tools.traces.ConditionsFactory
 import android.tools.traces.component.IComponentMatcher
@@ -39,6 +40,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
         expectedPackageName: String = "",
         action: String? = null,
         stringExtras: Map<String, String> = mapOf(),
+        options: ActivityOptions? = null,
     )
 
     /**
@@ -55,6 +57,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
                 .StateSyncBuilder()
                 .add(ConditionsFactory.isWMStateComplete())
                 .withAppTransitionIdle(),
+        options: ActivityOptions? = null,
     )
 
     /**
@@ -70,6 +73,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
                 .StateSyncBuilder()
                 .add(ConditionsFactory.isWMStateComplete())
                 .withAppTransitionIdle(),
+        options: ActivityOptions? = null,
     )
 
     fun isAvailable(): Boolean
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
index c771c230f..06462ebde 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
@@ -17,6 +17,7 @@
 package android.tools.device.apphelpers
 
 import android.app.ActivityManager
+import android.app.ActivityOptions
 import android.app.Instrumentation
 import android.content.ComponentName
 import android.content.Context
@@ -123,12 +124,13 @@ open class StandardAppHelper(
     private fun launchAppViaIntent(
         action: String? = null,
         stringExtras: Map<String, String> = mapOf(),
+        options: ActivityOptions? = null,
     ) {
         withTracing("${this::class.simpleName}#launchAppViaIntent") {
             val intent = openAppIntent
             intent.action = action ?: Intent.ACTION_MAIN
             stringExtras.forEach { intent.putExtra(it.key, it.value) }
-            context.startActivity(intent)
+            context.startActivity(intent, if (options != null) options.toBundle() else null)
         }
     }
 
@@ -137,8 +139,9 @@ open class StandardAppHelper(
         expectedPackageName: String,
         action: String?,
         stringExtras: Map<String, String>,
+        options: ActivityOptions?,
     ) {
-        launchAppViaIntent(action, stringExtras)
+        launchAppViaIntent(action, stringExtras, options)
         val appSelector = getAppSelector(expectedPackageName)
         uiDevice.wait(Until.hasObject(appSelector), APP_LAUNCH_WAIT_TIME_MS)
     }
@@ -150,8 +153,9 @@ open class StandardAppHelper(
         action: String?,
         stringExtras: Map<String, String>,
         waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
+        options: ActivityOptions?,
     ) {
-        launchAppViaIntent(action, stringExtras)
+        launchAppViaIntent(action, stringExtras, options)
         doWaitShown(launchedAppComponentMatcherOverride, waitConditionsBuilder)
     }
 
@@ -161,9 +165,10 @@ open class StandardAppHelper(
         intent: Intent,
         launchedAppComponentMatcherOverride: IComponentMatcher?,
         waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
+        options: ActivityOptions?,
     ) {
         withTracing("${this::class.simpleName}#launchViaIntent") {
-            context.startActivity(intent)
+            context.startActivity(intent, if (options != null) options.toBundle() else null)
             doWaitShown(launchedAppComponentMatcherOverride, waitConditionsBuilder)
         }
     }
diff --git a/libraries/flicker/collector/TEST_MAPPING b/libraries/flicker/collector/TEST_MAPPING
new file mode 100644
index 000000000..445ac65f8
--- /dev/null
+++ b/libraries/flicker/collector/TEST_MAPPING
@@ -0,0 +1,7 @@
+{
+  "wm-cf": [
+    {
+      "name": "ui-trace-collector-test"
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/flicker/src/android/tools/flicker/Utils.kt b/libraries/flicker/src/android/tools/flicker/Utils.kt
index 2e9675c27..d8f06251f 100644
--- a/libraries/flicker/src/android/tools/flicker/Utils.kt
+++ b/libraries/flicker/src/android/tools/flicker/Utils.kt
@@ -25,9 +25,6 @@ import android.tools.traces.monitors.PerfettoTraceMonitor
 import android.tools.traces.monitors.ScreenRecorder
 import android.tools.traces.monitors.TraceMonitor
 import android.tools.traces.monitors.events.EventLogMonitor
-import android.tools.traces.monitors.view.ViewTraceMonitor
-import android.tools.traces.monitors.wm.LegacyShellTransitionTraceMonitor
-import android.tools.traces.monitors.wm.LegacyWmTransitionTraceMonitor
 import android.tools.traces.monitors.wm.WindowManagerTraceMonitor
 import android.tools.traces.surfaceflinger.LayersTrace
 import android.tools.traces.wm.TransitionChange
@@ -47,20 +44,12 @@ object Utils {
             )
             .apply {
                 val perfettoMonitorBuilder = PerfettoTraceMonitor.newBuilder()
-                perfettoMonitorBuilder.enableLayersTrace().enableTransactionsTrace()
-
-                if (android.tracing.Flags.perfettoViewCaptureTracing()) {
-                    perfettoMonitorBuilder.enableViewCaptureTrace()
-                } else {
-                    this.add(ViewTraceMonitor())
-                }
-
-                if (android.tracing.Flags.perfettoTransitionTracing()) {
-                    perfettoMonitorBuilder.enableTransitionsTrace()
-                } else {
-                    this.add(LegacyWmTransitionTraceMonitor())
-                    this.add(LegacyShellTransitionTraceMonitor())
-                }
+                perfettoMonitorBuilder
+                    .enableLayersTrace()
+                    .enableTransactionsTrace()
+                    .enableProtoLog()
+                    .enableViewCaptureTrace()
+                    .enableTransitionsTrace()
 
                 if (android.tracing.Flags.perfettoWmTracing()) {
                     perfettoMonitorBuilder.enableWindowManagerTrace()
@@ -68,10 +57,6 @@ object Utils {
                     this.add(WindowManagerTraceMonitor())
                 }
 
-                if (android.tracing.Flags.perfettoProtologTracing()) {
-                    perfettoMonitorBuilder.enableProtoLog()
-                }
-
                 if (android.tracing.Flags.perfettoIme()) {
                     perfettoMonitorBuilder.enableImeTrace()
                 }
diff --git a/libraries/flicker/src/android/tools/flicker/annotation/Debug.kt b/libraries/flicker/src/android/tools/flicker/annotation/Debug.kt
new file mode 100644
index 000000000..2d43c8d95
--- /dev/null
+++ b/libraries/flicker/src/android/tools/flicker/annotation/Debug.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.flicker.annotation
+
+// TODO: Add lint rules to make sure these annotations are never merged in
+@Target(AnnotationTarget.FUNCTION)
+@Retention(AnnotationRetention.RUNTIME)
+annotation class Debug(val debugTraceFilePath: String)
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt b/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
index c24944c1c..41b6e9e78 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
@@ -53,6 +53,10 @@ open class SubjectsParser(private val resultReader: Reader) {
         }
     }
 
+    /** Gets the subject with given type [T] and [tag]. */
+    inline fun <reified T : FlickerSubject> getSubjectOfType(tag: String): T =
+        getSubjectOfType(tag, T::class) as T
+
     /** Truth subject that corresponds to a [WindowManagerTrace] */
     private val wmTraceSubject: WindowManagerTraceSubject?
         get() = doGetWmTraceSubject()
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/ResizeVeilKeepsIncreasingInSize.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/ResizeVeilKeepsIncreasingInSize.kt
index b31588ffd..c4001e0d7 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/ResizeVeilKeepsIncreasingInSize.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/ResizeVeilKeepsIncreasingInSize.kt
@@ -36,7 +36,7 @@ class ResizeVeilKeepsIncreasingInSize(private val component: ComponentTemplate)
                     it.name.contains("Resize veil")
             }
             layerList.zipWithNext { previous, current ->
-                current.visibleRegion.coversAtLeast(previous.visibleRegion.region)
+                current.visibleRegion.notSmallerThan(previous.visibleRegion.region)
             }
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt b/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
index 86d53c780..7f87d80d1 100644
--- a/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
@@ -30,13 +30,19 @@ object Components {
     val DESKTOP_MODE_CAPTION =
         ComponentTemplate("APP_HEADER") { ComponentNameMatcher(SYSTEMUI_PACKAGE, "caption_handle") }
 
+    const val DESKTOP_MODE_APP_NAME = "DESKTOP_MODE_APP"
+
     val DESKTOP_MODE_APP =
-        ComponentTemplate("DESKTOP_MODE_APP") { scenarioInstance: ScenarioInstance ->
+        ComponentTemplate(DESKTOP_MODE_APP_NAME) { scenarioInstance: ScenarioInstance ->
             val associatedTransition =
                 scenarioInstance.associatedTransition
                     ?: error("Can only extract DESKTOP_MODE_APP from scenario with transition")
 
-            getDesktopAppForScenario(scenarioInstance.type, associatedTransition)
+            getDesktopAppForScenario(
+                scenarioInstance.type,
+                associatedTransition,
+                DESKTOP_MODE_APP_NAME,
+            )
         }
 
     val SIMPLE_APP =
@@ -66,35 +72,36 @@ object Components {
     private fun getDesktopAppForScenario(
         type: ScenarioId,
         associatedTransition: Transition,
+        name: String,
     ): IComponentMatcher {
         return when (type) {
             ScenarioId("END_DRAG_TO_DESKTOP") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.CHANGE }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("CLOSE_APP"),
             ScenarioId("CLOSE_LAST_APP") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.CLOSE }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("OPEN_APP_WHEN_EXTERNAL_DISPLAY_CONNECTED"),
             ScenarioId("OPEN_UNLIMITED_APPS"),
             ScenarioId("CASCADE_APP") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.OPEN }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("MINIMIZE_APP") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.TO_BACK }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("MINIMIZE_LAST_APP") -> {
                 val change =
                     associatedTransition.changes.last { it.transitMode == TransitionType.TO_BACK }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("CORNER_RESIZE"),
             ScenarioId("CORNER_RESIZE_TO_MINIMUM_SIZE"),
@@ -112,12 +119,12 @@ object Components {
             ScenarioId("MAXIMIZE_APP_NON_RESIZABLE"),
             ScenarioId("MINIMIZE_AUTO_PIP_APP") -> {
                 val change = associatedTransition.changes.first()
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             ScenarioId("BRING_APPS_TO_FRONT") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.TO_FRONT }
-                FullComponentIdMatcher(change.windowId, change.layerId)
+                FullComponentIdMatcher(change.windowId, change.layerId, name)
             }
             else -> error("Unsupported transition type")
         }
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/Utils.kt b/libraries/flicker/src/android/tools/flicker/extractors/Utils.kt
index a45671d09..6441fa13e 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/Utils.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/Utils.kt
@@ -133,7 +133,16 @@ object Utils {
 
             sfEntryAtTransitionFinished =
                 layersTrace.entries.firstOrNull { it.timestamp.unixNanos >= unixNanos }
-                    ?: error("No SF entry for finish timestamp")
+                    ?: error("Could not find finish transaction#${transition.finishTransactionId}" +
+                        " associated with this scenario or it was not applied/merged into another" +
+                        " transaction. Falling back to using the finish time reported on the WM " +
+                        "side: $unixNanos. But no layers entry was found after this timestamp. " +
+                        "First layers trace entry at: " +
+                        "${layersTrace.entries.first().timestamp.unixNanos}, " +
+                        "Last layers trace entry at: " +
+                        "${layersTrace.entries.last().timestamp.unixNanos}, " +
+                        "${layersTrace.entries.size} entries in layers trace. " +
+                        "Debug string: $debugString")
             systemUptimeNanos = sfEntryAtTransitionFinished.timestamp.systemUptimeNanos
         } else {
             elapsedNanos =
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
index 444685d8b..d4381692a 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
@@ -25,6 +25,7 @@ import android.tools.flicker.FlickerService
 import android.tools.flicker.FlickerServiceResultsCollector.Companion.FLICKER_ASSERTIONS_COUNT_KEY
 import android.tools.flicker.ScenarioInstance
 import android.tools.flicker.Utils.captureTrace
+import android.tools.flicker.annotation.Debug
 import android.tools.flicker.annotation.ExpectedScenarios
 import android.tools.flicker.annotation.FlickerConfigProvider
 import android.tools.flicker.assertions.ScenarioAssertion
@@ -32,6 +33,7 @@ import android.tools.flicker.config.FlickerConfig
 import android.tools.flicker.config.ScenarioId
 import android.tools.io.Reader
 import android.tools.traces.getDefaultFlickerOutputDir
+import android.tools.traces.io.TraceReaderUtils.getTraceReaderFromAsset
 import android.tools.traces.now
 import androidx.test.platform.app.InstrumentationRegistry
 import com.google.common.truth.Truth
@@ -115,95 +117,50 @@ class FlickerServiceDecorator(
 
         if (shouldComputeTestMethods()) {
             for (method in innerMethods) {
-                if (!innerMethodsResults.containsKey(method)) {
+                // Check we haven't already executed the test, captured the trace, and computed the
+                // test methods to inject before executing the test, to avoid executing it multiple
+                // times.
+                if (
+                    !innerMethodsResults.containsKey(method) &&
+                        !flickerServiceMethodsFor.containsKey(method)
+                ) {
+                    val debugAnnotation =
+                        if (method.annotations.any { it is Debug }) {
+                            method.getAnnotation(Debug::class.java)
+                        } else {
+                            null
+                        }
+
                     val description = createTestDescription(testClass.javaClass.name, method.name)
-                    val statement =
-                        object : Statement() {
-                            override fun evaluate() {
-                                var methodResult: Throwable? =
-                                    null // TODO: Maybe don't use null but wrap in another object
-                                val reader =
-                                    captureTrace(testClassName, getDefaultFlickerOutputDir()) {
-                                        writer ->
-                                        try {
-                                            Utils.notifyRunnerProgress(
-                                                testClassName,
-                                                "Running setup",
-                                                instrumentation,
-                                            )
-                                            val befores =
-                                                testClass.getAnnotatedMethods(Before::class.java)
-                                            befores.forEach { it.invokeExplosively(test) }
-
-                                            Utils.notifyRunnerProgress(
-                                                testClassName,
-                                                "Running transition",
-                                                instrumentation,
-                                            )
-
-                                            val traceStartTime = now()
-                                            Utils.notifyRunnerProgress(
-                                                testClassName,
-                                                "Setting trace start time to :: $traceStartTime",
-                                                instrumentation,
-                                            )
-
-                                            writer.setTransitionStartTime(traceStartTime)
-                                            method.invokeExplosively(test)
-
-                                            val traceEndTime = now()
-                                            Utils.notifyRunnerProgress(
-                                                testClassName,
-                                                "Setting trace end time to :: $traceEndTime",
-                                                instrumentation,
-                                            )
-                                            writer.setTransitionEndTime(traceEndTime)
-
-                                            Utils.notifyRunnerProgress(
-                                                testClassName,
-                                                "Running teardown",
-                                                instrumentation,
-                                            )
-                                            val afters =
-                                                testClass.getAnnotatedMethods(After::class.java)
-                                            afters.forEach { it.invokeExplosively(test) }
-                                        } catch (e: Throwable) {
-                                            methodResult = e
-                                        } finally {
-                                            innerMethodsResults[method] = methodResult
-                                        }
-                                    }
-                                if (methodResult == null) {
-                                    Utils.notifyRunnerProgress(
-                                        testClassName,
-                                        "Computing Flicker service tests",
-                                        instrumentation,
-                                    )
-                                    try {
-                                        flickerServiceMethodsFor[method] =
-                                            computeFlickerServiceTests(
-                                                reader,
-                                                testClassName,
-                                                method,
-                                            )
-                                    } catch (e: Throwable) {
-                                        // Failed to compute flicker service methods
-                                        innerMethodsResults[method] = e
-                                    }
-                                }
+
+                    try {
+                        val reader =
+                            if (debugAnnotation != null) {
+                                getTraceReaderFromAsset(
+                                    testClassName,
+                                    debugAnnotation.debugTraceFilePath,
+                                )
+                            } else {
+                                captureTestTrace(test, method, description, ruleContainer)
                             }
-                        }
-                    ruleContainer
-                        .apply(
-                            method,
-                            description,
-                            testClass.onlyConstructor.newInstance(),
-                            statement,
+
+                        Utils.notifyRunnerProgress(
+                            testClassName,
+                            "Computing Flicker service tests",
+                            instrumentation,
                         )
-                        .evaluate()
+                        flickerServiceMethodsFor[method] =
+                            computeFlickerServiceTests(reader, testClassName, method)
+                    } catch (e: Throwable) {
+                        // Failed to execute test rules, report the error in the test method's
+                        // result instead of causing a module failure due to crashing in the
+                        // getTestMethods method.
+                        innerMethodsResults[method] = e
+                    }
                 }
 
                 if (innerMethodsResults[method] == null) {
+                    // No errors occurred, add the computed test methods
                     testMethods.addAll(flickerServiceMethodsFor[method]!!)
                 }
             }
@@ -212,6 +169,65 @@ class FlickerServiceDecorator(
         return testMethods
     }
 
+    private fun captureTestTrace(
+        test: Any,
+        method: FrameworkMethod,
+        description: Description,
+        ruleContainer: RuleContainer,
+    ): Reader {
+        // Capture the entire test, including test rules, before and after blocks. This is to ensure
+        // we have the entire trace for debugging later. We then tag the trace with a start and end
+        // time to know where the main method starts and stops to only process that data.
+        return captureTrace(testClassName, getDefaultFlickerOutputDir()) { writer ->
+            val innerStatement =
+                object : Statement() {
+                    override fun evaluate() {
+                        val befores = testClass.getAnnotatedMethods(Before::class.java)
+                        befores.forEach { it.invokeExplosively(test) }
+
+                        Utils.notifyRunnerProgress(testClassName, "Running setup", instrumentation)
+
+                        Utils.notifyRunnerProgress(
+                            testClassName,
+                            "Running transition",
+                            instrumentation,
+                        )
+
+                        val traceStartTime = now()
+                        Utils.notifyRunnerProgress(
+                            testClassName,
+                            "Setting trace start time to :: $traceStartTime",
+                            instrumentation,
+                        )
+
+                        writer.setTransitionStartTime(traceStartTime)
+                        method.invokeExplosively(test)
+
+                        val traceEndTime = now()
+                        Utils.notifyRunnerProgress(
+                            testClassName,
+                            "Setting trace end time to :: $traceEndTime",
+                            instrumentation,
+                        )
+                        writer.setTransitionEndTime(traceEndTime)
+
+                        Utils.notifyRunnerProgress(
+                            testClassName,
+                            "Running teardown",
+                            instrumentation,
+                        )
+
+                        val afters = testClass.getAnnotatedMethods(After::class.java)
+                        afters.forEach { it.invokeExplosively(test) }
+                    }
+                }
+
+            ruleContainer
+                .apply(method, description, testClass.onlyConstructor.newInstance(), innerStatement)
+                .evaluate()
+        }
+    }
+
     // TODO: Common with LegacyFlickerServiceDecorator, might be worth extracting this up
     private fun shouldComputeTestMethods(): Boolean {
         // Don't compute when called from validateInstanceMethods since this will fail
@@ -240,7 +256,13 @@ class FlickerServiceDecorator(
                     (method as InjectedTestCase).execute(description)
                 } else {
                     if (innerMethodsResults.containsKey(method)) {
+                        // Test failed to execute when computing the test methods to inject, so we
+                        // don't have a correct trace to run tests on.
+                        // Throw the execution error as the test result.
                         innerMethodsResults[method]?.let { throw it }
+                    } else if (flickerServiceMethodsFor.containsKey(method)) {
+                        // We already executed this method to capture the trace for the tests, we
+                        // don't need to execute it again, so do nothing and just pass the test.
                     } else {
                         inner?.getMethodInvoker(method, test)?.evaluate()
                     }
diff --git a/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt b/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
index c00289abc..4f9dbeb61 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
@@ -33,13 +33,14 @@ class ArtifactSaverRule : TestWatcher() {
 
         try {
             if (DeviceDumpParser.lastWmTraceData.isNotEmpty()) {
-                val fileName = getClassAndMethodName(description) + "lastWmDump.winscope"
+                val fileName = getClassAndMethodName(description) + "_winscopeLastWmDump.winscope"
                 val file = ArtifactSaver.artifactFile(fileName)
                 file.writeBytes(DeviceDumpParser.lastWmTraceData)
             }
 
             if (DeviceDumpParser.lastLayersTraceData.isNotEmpty()) {
-                val fileName = getClassAndMethodName(description) + "lastLayersDump.winscope"
+                val fileName =
+                    getClassAndMethodName(description) + "_winscopeLastLayersDump.winscope"
                 val file = ArtifactSaver.artifactFile(fileName)
                 file.writeBytes(DeviceDumpParser.lastLayersTraceData)
             }
diff --git a/libraries/flicker/src/android/tools/flicker/rules/ClearAppCacheRule.kt b/libraries/flicker/src/android/tools/flicker/rules/ClearAppCacheRule.kt
new file mode 100644
index 000000000..0573445dd
--- /dev/null
+++ b/libraries/flicker/src/android/tools/flicker/rules/ClearAppCacheRule.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.flicker.rules
+
+import android.app.Instrumentation
+import android.tools.FLICKER_TAG
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.rules.TestWatcher
+import org.junit.runner.Description
+
+class ClearAppCacheRule : TestWatcher() {
+    override fun finished(description: Description?) {
+        super.finished(description)
+
+        val instr: Instrumentation = InstrumentationRegistry.getInstrumentation()
+        val rmCommand = "rm -rf /data/user/0/${instr.targetContext.packageName}/cache/withTracing*"
+        Log.d(FLICKER_TAG, "Cleaning up cache directory with $rmCommand")
+        instr.uiAutomation.executeShellCommand(rmCommand)
+    }
+}
diff --git a/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt b/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
index 4809a57a5..8f298a134 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
@@ -16,12 +16,13 @@
 
 package android.tools.flicker.rules
 
-import android.app.ActivityTaskManager
-import android.app.WindowConfiguration
+import android.app.Instrumentation
 import android.tools.FLICKER_TAG
+import android.tools.helpers.RecentTasksUtils
 import android.tools.traces.parsers.WindowManagerStateHelper
 import android.tools.withTracing
 import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
 import org.junit.rules.TestWatcher
 import org.junit.runner.Description
 
@@ -41,17 +42,11 @@ class RemoveAllTasksButHomeRule() : TestWatcher() {
 
     companion object {
         @JvmStatic
-        fun removeAllTasksButHome() {
-            val atm = ActivityTaskManager.getService()
-            atm.removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME)
+        @JvmOverloads
+        fun removeAllTasksButHome(
+            instr: Instrumentation = InstrumentationRegistry.getInstrumentation()
+        ) {
+            RecentTasksUtils.clearAllVisibleRecentTasks(instr)
         }
-
-        private val ALL_ACTIVITY_TYPE_BUT_HOME =
-            intArrayOf(
-                WindowConfiguration.ACTIVITY_TYPE_STANDARD,
-                WindowConfiguration.ACTIVITY_TYPE_ASSISTANT,
-                WindowConfiguration.ACTIVITY_TYPE_RECENTS,
-                WindowConfiguration.ACTIVITY_TYPE_UNDEFINED,
-            )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
index 63e777e47..4450e98a2 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
@@ -344,7 +344,7 @@ constructor(val trace: LayersTrace, override val reader: Reader? = null) :
             listOf(
                 ComponentNameMatcher.SPLASH_SCREEN,
                 ComponentNameMatcher.SNAPSHOT,
-                ComponentNameMatcher.IME_SNAPSHOT,
+                ComponentNameMatcher.IME_SCREENSHOT,
                 ComponentNameMatcher.PIP_CONTENT_OVERLAY,
                 ComponentNameMatcher.EDGE_BACK_GESTURE_HANDLER,
                 ComponentNameMatcher.COLOR_FADE,
diff --git a/libraries/flicker/src/android/tools/flicker/subject/region/IRegionSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/region/IRegionSubject.kt
index 24880d351..08b48d290 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/region/IRegionSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/region/IRegionSubject.kt
@@ -77,6 +77,9 @@ interface IRegionSubject {
      */
     fun isLeftEdgeToTheRight(other: Region): IRegionSubject
 
+    /** Asserts that this region is strictly wider than [other]. */
+    fun isStrictlyWiderThan(other: Region): IRegionSubject
+
     /**
      * Asserts that the top and bottom coordinates of [other] are smaller than those of region.
      *
@@ -139,6 +142,14 @@ interface IRegionSubject {
      */
     fun notBiggerThan(other: Region): IRegionSubject
 
+    /**
+     * Asserts that region is strictly larger than [other], even if the regions don't overlap.
+     *
+     * @param other Area to compare to
+     * @throws AssertionError
+     */
+    fun isStrictlyLargerThan(other: Region): IRegionSubject
+
     /**
      * Asserts that region is not smaller than [other], even if the regions don't overlap.
      *
@@ -147,6 +158,14 @@ interface IRegionSubject {
      */
     fun notSmallerThan(other: Region): IRegionSubject
 
+    /**
+     * Asserts that region is strictly smaller than [other], even if the regions don't overlap.
+     *
+     * @param other Area to compare to
+     * @throws AssertionError
+     */
+    fun isStrictlySmallerThan(other: Region): IRegionSubject
+
     /**
      * Asserts that region is positioned to the right and bottom from [other], but the regions can
      * overlap and region can be smaller than [other]
@@ -270,4 +289,14 @@ interface IRegionSubject {
      * @throws AssertionError
      */
     fun hasSameLeftPosition(displayRect: Rect): IRegionSubject
+
+    /**
+     * Asserts that region's width and height match [testWidth] and [testHeight]
+     *
+     * @param testWidth expected width
+     * @param testHeight expected height
+     * @param diffThreshold tolerance for difference in size and width
+     * @throws AssertionError
+     */
+    fun hasSameSize(testWidth: Int, testHeight: Int, diffThreshold: Int): IRegionSubject
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
index d7c3c8fee..8aac1371e 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
@@ -197,6 +197,23 @@ constructor(
         )
     }
 
+    /** {@inheritDoc} */
+    override fun isStrictlyWiderThan(other: Region): RegionSubject = apply {
+        val otherBounds = other.bounds
+        val currentBounds = region.bounds
+        if (otherBounds.width() >= currentBounds.width()) {
+            val errorMsgBuilder =
+                ExceptionMessageBuilder()
+                    .forSubject(this)
+                    .setActual(currentBounds.width())
+                    .setExpected("Smaller than ${otherBounds.width()}")
+                    .forIncorrectRegion(
+                        "Region $otherBounds width should not be larger than Region $currentBounds width"
+                    )
+            throw IncorrectRegionException(errorMsgBuilder)
+        }
+    }
+
     /** See [isHigher] */
     fun isHigher(subject: RegionSubject): RegionSubject = isHigher(subject.region)
 
@@ -284,6 +301,24 @@ constructor(
         }
     }
 
+    /** {@inheritDoc} */
+    override fun isStrictlyLargerThan(other: Region): RegionSubject = apply {
+        val testArea = other.bounds.area
+        val area = region.bounds.area
+
+        if (area <= testArea) {
+            val errorMsgBuilder =
+                ExceptionMessageBuilder()
+                    .forSubject(this)
+                    .forIncorrectRegion("region. $region area should be larger than $testArea")
+                    .setExpected(testArea)
+                    .setActual(area)
+                    .addExtraDescription("Expected region larger than", other)
+                    .addExtraDescription("Actual region", regionEntry.region)
+            throw IncorrectRegionException(errorMsgBuilder)
+        }
+    }
+
     /** {@inheritDoc} */
     override fun notSmallerThan(other: Region): RegionSubject = apply {
         val testArea = other.bounds.area
@@ -302,6 +337,24 @@ constructor(
         }
     }
 
+    /** {@inheritDoc} */
+    override fun isStrictlySmallerThan(other: Region): RegionSubject = apply {
+        val testArea = other.bounds.area
+        val area = region.bounds.area
+
+        if (area >= testArea) {
+            val errorMsgBuilder =
+                ExceptionMessageBuilder()
+                    .forSubject(this)
+                    .forIncorrectRegion("region. $region area should be smaller than $testArea")
+                    .setExpected(testArea)
+                    .setActual(area)
+                    .addExtraDescription("Expected region smaller than", other)
+                    .addExtraDescription("Actual region", regionEntry.region)
+            throw IncorrectRegionException(errorMsgBuilder)
+        }
+    }
+
     /** {@inheritDoc} */
     override fun isToTheRightBottom(other: Region, threshold: Int): RegionSubject = apply {
         val horizontallyPositionedToTheRight = other.bounds.left - threshold <= region.bounds.left
@@ -480,6 +533,39 @@ constructor(
         assertEquals("right", Region(displayRect)) { it.right }
     }
 
+    /** {@inheritDoc) */
+    override fun hasSameSize(testWidth: Int, testHeight: Int, diffThreshold: Int): RegionSubject =
+        apply {
+            val width = region.bounds.width()
+            val height = region.bounds.height()
+
+            if (Math.abs(testWidth - width) > diffThreshold) {
+                val errorMsgBuilder =
+                    ExceptionMessageBuilder()
+                        .forSubject(this)
+                        .forIncorrectRegion(
+                            "region. $region width should be the same as $testWidth"
+                        )
+                        .setExpected(testWidth)
+                        .setActual(width)
+                        .addExtraDescription("Threshold", diffThreshold)
+                throw IncorrectRegionException(errorMsgBuilder)
+            }
+
+            if (Math.abs(testHeight - height) > diffThreshold) {
+                val errorMsgBuilder =
+                    ExceptionMessageBuilder()
+                        .forSubject(this)
+                        .forIncorrectRegion(
+                            "region. $region height should be the same as $testHeight"
+                        )
+                        .setExpected(testHeight)
+                        .setActual(height)
+                        .addExtraDescription("Threshold", diffThreshold)
+                throw IncorrectRegionException(errorMsgBuilder)
+            }
+        }
+
     fun isSameAspectRatio(other: RegionSubject, threshold: Double = 0.1): RegionSubject =
         isSameAspectRatio(other.region, threshold)
 
diff --git a/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
index ab253a0b5..ad2e26f4d 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
@@ -103,11 +103,32 @@ constructor(val trace: RegionTrace, override val reader: Reader? = null) :
         addAssertion("notBiggerThan($other, $componentsAsString)") { it.notBiggerThan(other) }
     }
 
+    /** {@inheritDoc} */
+    override fun isStrictlyLargerThan(other: Region): RegionTraceSubject = apply {
+        addAssertion("isStrictlyLargerThan($other, $componentsAsString)") {
+            it.isStrictlyLargerThan(other)
+        }
+    }
+
     /** {@inheritDoc} */
     override fun notSmallerThan(other: Region): RegionTraceSubject = apply {
         addAssertion("notSmallerThan($other, $componentsAsString)") { it.notSmallerThan(other) }
     }
 
+    /** {@inheritDoc} */
+    override fun isStrictlySmallerThan(other: Region): RegionTraceSubject = apply {
+        addAssertion("isStrictlySmallerThan($other, $componentsAsString)") {
+            it.isStrictlySmallerThan(other)
+        }
+    }
+
+    /** {@inheritDoc} */
+    override fun isStrictlyWiderThan(other: Region): RegionTraceSubject = apply {
+        addAssertion("isStrictlyWiderThan($other, $componentsAsString)") {
+            it.isStrictlyWiderThan(other)
+        }
+    }
+
     /** {@inheritDoc} */
     override fun isToTheRightBottom(other: Region, threshold: Int): RegionTraceSubject = apply {
         addAssertion("isToTheRightBottom($other, $componentsAsString)") {
@@ -184,6 +205,17 @@ constructor(val trace: RegionTrace, override val reader: Reader? = null) :
         addAssertion("hasSameTopPosition($displayRect)") { it.hasSameTopPosition(displayRect) }
     }
 
+    /** {@inheritDoc} */
+    override fun hasSameSize(
+        testWidth: Int,
+        testHeight: Int,
+        diffThreshold: Int,
+    ): RegionTraceSubject = apply {
+        addAssertion("hasSameSize($testWidth, $testHeight, $diffThreshold)") {
+            it.hasSameSize(testWidth, testHeight, diffThreshold)
+        }
+    }
+
     @JvmOverloads
     operator fun invoke(
         name: String,
diff --git a/libraries/flicker/test/assets/testdata/layers_trace_rounded_corners.perfetto-trace b/libraries/flicker/test/assets/testdata/layers_trace_rounded_corners.perfetto-trace
index d6a450224..727408f7c 100644
Binary files a/libraries/flicker/test/assets/testdata/layers_trace_rounded_corners.perfetto-trace and b/libraries/flicker/test/assets/testdata/layers_trace_rounded_corners.perfetto-trace differ
diff --git a/libraries/flicker/test/assets/testdata/layers_trace_snapshotStartingWindowLayerCoversExactlyApp.perfetto-trace b/libraries/flicker/test/assets/testdata/layers_trace_snapshotStartingWindowLayerCoversExactlyApp.perfetto-trace
index 82a7af385..165fc9824 100644
Binary files a/libraries/flicker/test/assets/testdata/layers_trace_snapshotStartingWindowLayerCoversExactlyApp.perfetto-trace and b/libraries/flicker/test/assets/testdata/layers_trace_snapshotStartingWindowLayerCoversExactlyApp.perfetto-trace differ
diff --git a/libraries/flicker/test/assets/testdata/layers_trace_visible_outside_bounds.perfetto-trace b/libraries/flicker/test/assets/testdata/layers_trace_visible_outside_bounds.perfetto-trace
index 2324b3c29..cbc4afa06 100644
Binary files a/libraries/flicker/test/assets/testdata/layers_trace_visible_outside_bounds.perfetto-trace and b/libraries/flicker/test/assets/testdata/layers_trace_visible_outside_bounds.perfetto-trace differ
diff --git a/libraries/flicker/test/assets/testdata/quickswitch.winscope.zip b/libraries/flicker/test/assets/testdata/quickswitch.winscope.zip
new file mode 100644
index 000000000..dd652ca77
Binary files /dev/null and b/libraries/flicker/test/assets/testdata/quickswitch.winscope.zip differ
diff --git a/libraries/flicker/test/assets/testdata/scenarios/AppLaunch/layers_and_transactions_trace.perfetto-trace b/libraries/flicker/test/assets/testdata/scenarios/AppLaunch/trace.perfetto-trace
similarity index 99%
rename from libraries/flicker/test/assets/testdata/scenarios/AppLaunch/layers_and_transactions_trace.perfetto-trace
rename to libraries/flicker/test/assets/testdata/scenarios/AppLaunch/trace.perfetto-trace
index 9ed140bb5..c2033ffe7 100644
Binary files a/libraries/flicker/test/assets/testdata/scenarios/AppLaunch/layers_and_transactions_trace.perfetto-trace and b/libraries/flicker/test/assets/testdata/scenarios/AppLaunch/trace.perfetto-trace differ
diff --git a/libraries/flicker/test/assets/testdata/scenarios/DebugScenario/layers_and_transactions_trace.perfetto-trace b/libraries/flicker/test/assets/testdata/scenarios/DebugScenario/trace.perfetto-trace
similarity index 100%
rename from libraries/flicker/test/assets/testdata/scenarios/DebugScenario/layers_and_transactions_trace.perfetto-trace
rename to libraries/flicker/test/assets/testdata/scenarios/DebugScenario/trace.perfetto-trace
diff --git a/libraries/flicker/test/src/android/tools/TestUtils.kt b/libraries/flicker/test/src/android/tools/TestUtils.kt
index 30b820b7e..b07ecb833 100644
--- a/libraries/flicker/test/src/android/tools/TestUtils.kt
+++ b/libraries/flicker/test/src/android/tools/TestUtils.kt
@@ -38,7 +38,7 @@ import android.tools.traces.parsers.WindowManagerStateHelper
 import android.tools.traces.parsers.perfetto.LayersTraceParser
 import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.TransactionsTraceParser
-import android.tools.traces.parsers.wm.LegacyTransitionTraceParser
+import android.tools.traces.parsers.perfetto.TransitionsTraceParser
 import android.tools.traces.parsers.wm.LegacyWindowManagerTraceParser
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.UiDevice
@@ -53,23 +53,19 @@ fun CleanFlickerEnvironmentRuleWithDataStore(): RuleChain =
 internal fun getTraceReaderFromScenario(scenario: String): Reader {
     val scenarioTraces = getScenarioTraces(scenario)
 
-    val (layersTrace, transactionsTrace) =
+    val (layersTrace, transactionsTrace, transitionsTrace) =
         TraceProcessorSession.loadPerfettoTrace(scenarioTraces.perfetto.readBytes()) { session ->
             val layersTrace = LayersTraceParser().parse(session)
             val transactionsTrace = TransactionsTraceParser().parse(session)
-            Pair(layersTrace, transactionsTrace)
+            val transitionsTrace = TransitionsTraceParser().parse(session)
+            Triple(layersTrace, transactionsTrace, transitionsTrace)
         }
 
     return ParsedTracesReader(
         artifact = TestArtifact(scenario),
         wmTrace = LegacyWindowManagerTraceParser().parse(scenarioTraces.wmTrace.readBytes()),
         layersTrace = layersTrace,
-        transitionsTrace =
-            LegacyTransitionTraceParser()
-                .parse(
-                    scenarioTraces.wmTransitions.readBytes(),
-                    scenarioTraces.shellTransitions.readBytes(),
-                ),
+        transitionsTrace = transitionsTrace,
         transactionsTrace = transactionsTrace,
         eventLog = EventLogParser().parse(scenarioTraces.eventLog.readBytes()),
     )
@@ -84,7 +80,7 @@ fun getScenarioTraces(scenario: String): FlickerBuilder.TraceFiles {
     val traces =
         mapOf<String, (File) -> Unit>(
             "wm_trace$WINSCOPE_EXT" to { wmTrace = it },
-            "layers_and_transactions_trace$PERFETTO_EXT" to { perfettoTrace = it },
+            "trace$PERFETTO_EXT" to { perfettoTrace = it },
             "wm_transition_trace$WINSCOPE_EXT" to { wmTransitionTrace = it },
             "shell_transition_trace$WINSCOPE_EXT" to { shellTransitionTrace = it },
             "eventlog$WINSCOPE_EXT" to { eventLog = it },
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
index be5ea7b92..e509c7229 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
@@ -24,6 +24,7 @@ import android.tools.device.apphelpers.BrowserAppHelper
 import android.tools.flicker.AssertionInvocationGroup
 import android.tools.flicker.FlickerConfig
 import android.tools.flicker.ScenarioInstance
+import android.tools.flicker.annotation.Debug
 import android.tools.flicker.annotation.ExpectedScenarios
 import android.tools.flicker.annotation.FlickerConfigProvider
 import android.tools.flicker.assertions.FlickerTest
@@ -37,6 +38,7 @@ import android.tools.io.Reader
 import androidx.test.platform.app.InstrumentationRegistry
 import com.google.common.truth.Truth
 import java.time.Instant
+import org.junit.Assert
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestRule
@@ -62,33 +64,20 @@ class FlickerServiceJUnit4ClassRunnerTest {
         var testRuleEndTs: Instant? = null
         var testStateTs: Instant? = null
         var testRuleExecutionCount = 0
-        onTestRuleStart =
-            object : Runnable {
-                override fun run() {
-                    testRuleExecutionCount++
-                    testRuleStartTs = Instant.now()
-                }
-            }
-        onTestRuleEnd =
-            object : Runnable {
-                override fun run() {
-                    testRuleEndTs = Instant.now()
-                }
-            }
-        onTestStart =
-            object : Runnable {
-                override fun run() {
-                    testStateTs = Instant.now()
-                }
-            }
+        onTestRuleStart = Runnable {
+            testRuleExecutionCount++
+            testRuleStartTs = Instant.now()
+        }
+        onTestRuleEnd = Runnable { testRuleEndTs = Instant.now() }
+        onTestStart = Runnable { testStateTs = Instant.now() }
 
         val runner = FlickerServiceJUnit4ClassRunner(SimpleTest::class.java)
         runner.run(RunNotifier())
 
-        Truth.assertWithMessage("Test rule start running after test block")
+        Truth.assertWithMessage("Test rule start should run before test block")
             .that(testRuleStartTs)
             .isLessThan(testStateTs)
-        Truth.assertWithMessage("Test rule end running before test block")
+        Truth.assertWithMessage("Test rule end should run after test block")
             .that(testStateTs)
             .isLessThan(testRuleEndTs)
 
@@ -135,6 +124,50 @@ class FlickerServiceJUnit4ClassRunnerTest {
             .fireTestFinished(ArgumentMatchers.argThat { it.methodName.contains("FaaS") })
     }
 
+    @Test
+    fun reportsTestRuleFailureInTest() {
+        var testRan = false
+        onTestRuleStart = Runnable { Assert.fail("Test rule failed") }
+        onTestStart = Runnable { testRan = true }
+
+        val runner = FlickerServiceJUnit4ClassRunner(SimpleTest::class.java)
+        val notifier = Mockito.mock(RunNotifier::class.java)
+        runner.run(notifier)
+
+        Truth.assertThat(testRan).isFalse()
+
+        Truth.assertThat(runner.testCount()).isEqualTo(1)
+        Mockito.verify(notifier)
+            .fireTestFailure(
+                ArgumentMatchers.argThat {
+                    it.description.methodName.equals("test") &&
+                        it.message.contains("Test rule failed")
+                }
+            )
+    }
+
+    @Test
+    fun usesLocalTraceWithDebugAnnotation() {
+        val runner = FlickerServiceJUnit4ClassRunner(DebugTest::class.java)
+        val notifier = Mockito.mock(RunNotifier::class.java)
+        runner.run(notifier)
+
+        Truth.assertThat(runner.testCount()).isEqualTo(3)
+        Mockito.verify(notifier, Mockito.never()).fireTestFailure(ArgumentMatchers.any())
+
+        for (expectedMethod in
+            listOf(
+                "test",
+                "MY_CUSTOM_SCENARIO::myBlockingAssertion",
+                "DetectedExpectedScenarios",
+            )) {
+            Mockito.verify(notifier, Mockito.times(1))
+                .fireTestStarted(
+                    ArgumentMatchers.argThat { it.methodName.contains(expectedMethod) }
+                )
+        }
+    }
+
     /** Below are all the mock test classes uses for testing purposes */
     @RunWith(FlickerServiceJUnit4ClassRunner::class)
     open class SimpleTest {
@@ -209,6 +242,59 @@ class FlickerServiceJUnit4ClassRunnerTest {
         }
     }
 
+    /** Below are all the mock test classes uses for testing purposes */
+    @RunWith(FlickerServiceJUnit4ClassRunner::class)
+    open class DebugTest {
+        val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
+        private val testApp: BrowserAppHelper = BrowserAppHelper(instrumentation)
+
+        @Test
+        @ExpectedScenarios(["MY_CUSTOM_SCENARIO"])
+        @Debug("testdata/quickswitch.winscope.zip")
+        fun test() {
+            onTestStart?.run()
+            testApp.open()
+        }
+
+        companion object {
+            @FlickerConfigProvider
+            @JvmStatic
+            fun flickerConfigProvider(): FlickerConfig {
+                return FlickerConfig()
+                    .use(
+                        FlickerConfigEntry(
+                            scenarioId = ScenarioId("MY_CUSTOM_SCENARIO"),
+                            extractor =
+                                object : ScenarioExtractor {
+                                    override fun extract(reader: Reader): List<TraceSlice> {
+                                        return listOf(
+                                            TraceSlice(Timestamps.min(), Timestamps.max())
+                                        )
+                                    }
+                                },
+                            assertions =
+                                mapOf(
+                                    object : AssertionTemplate("myBlockingAssertion") {
+                                        override fun doEvaluate(
+                                            scenarioInstance: ScenarioInstance,
+                                            flicker: FlickerTest,
+                                        ) {
+                                            // Check to make sure we are running this assertion on
+                                            // the debug trace
+                                            flicker.assertLayersStart {
+                                                Truth.assertThat(this.timestamp.unixNanos)
+                                                    .isEqualTo(1743439123983024119)
+                                            }
+                                        }
+                                    } to AssertionInvocationGroup.BLOCKING
+                                ),
+                            enabled = true,
+                        )
+                    )
+            }
+        }
+    }
+
     companion object {
         var testRuleRunCount = 0
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayerTraceEntrySubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayerTraceEntrySubjectTest.kt
index 2ca160b43..091e04ee3 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayerTraceEntrySubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayerTraceEntrySubjectTest.kt
@@ -66,7 +66,7 @@ class LayerTraceEntrySubjectTest {
         val reader = getLayerTraceReaderFromAsset("layers_trace_launch_split_screen.perfetto-trace")
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
         LayerTraceEntrySubject(trace.entries.first(), reader)
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .notContains(TestComponents.DOCKER_STACK_DIVIDER)
             .isVisible(TestComponents.LAUNCHER)
     }
@@ -76,7 +76,7 @@ class LayerTraceEntrySubjectTest {
         val reader = getLayerTraceReaderFromAsset("layers_trace_launch_split_screen.perfetto-trace")
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
         LayerTraceEntrySubject(trace.entries.last(), reader)
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isVisible(TestComponents.DOCKER_STACK_DIVIDER)
     }
 
@@ -392,9 +392,9 @@ class LayerTraceEntrySubjectTest {
         val subject =
             LayersTraceSubject(trace, reader)
                 .getEntryBySystemUpTime(1253267561044, byElapsedTimestamp = true)
-        val region = subject.visibleRegion(ComponentNameMatcher.IME_SNAPSHOT)
+        val region = subject.visibleRegion(ComponentNameMatcher.IME_SCREENSHOT)
         region.isEmpty()
-        subject.isInvisible(ComponentNameMatcher.IME_SNAPSHOT)
+        subject.isInvisible(ComponentNameMatcher.IME_SCREENSHOT)
     }
 
     @Test
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
index 1da678e19..91f4622c9 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
@@ -79,7 +79,7 @@ class LayersTraceSubjectTest {
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
         LayersTraceSubject(trace, reader)
             .first()
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .notContains(TestComponents.DOCKER_STACK_DIVIDER)
             .isVisible(TestComponents.LAUNCHER)
     }
@@ -90,7 +90,7 @@ class LayersTraceSubjectTest {
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
         LayersTraceSubject(trace, reader)
             .last()
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isVisible(TestComponents.DOCKER_STACK_DIVIDER)
     }
 
@@ -100,12 +100,12 @@ class LayersTraceSubjectTest {
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
 
         LayersTraceSubject(trace, reader)
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isInvisible(TestComponents.DOCKER_STACK_DIVIDER)
             .forSystemUpTimeRange(90480846872160L, 90480994138424L)
 
         LayersTraceSubject(trace, reader)
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isVisible(TestComponents.DOCKER_STACK_DIVIDER)
             .forSystemUpTimeRange(90491795074136L, 90493757372977L)
     }
@@ -115,13 +115,13 @@ class LayersTraceSubjectTest {
         val reader = getLayerTraceReaderFromAsset("layers_trace_launch_split_screen.perfetto-trace")
         val trace = reader.readLayersTrace() ?: error("Unable to read layers trace")
         LayersTraceSubject(trace, reader)
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .notContains(TestComponents.DOCKER_STACK_DIVIDER)
             .then()
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isInvisible(TestComponents.DOCKER_STACK_DIVIDER)
             .then()
-            .isVisible(ComponentNameMatcher.NAV_BAR)
+            .isVisible(ComponentNameMatcher.NAV_BAR_LEGACY)
             .isVisible(TestComponents.DOCKER_STACK_DIVIDER)
             .forAllEntries()
     }
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
index 8165770ab..8ac3f8615 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
@@ -79,7 +79,7 @@ class WindowManagerStateSubjectTest {
     fun canDetectAboveAppWindowVisibility_isVisible() {
         WindowManagerTraceSubject(trace, reader)
             .getEntryByElapsedTimestamp(traceFirstFrameTimestamp)
-            .containsAboveAppWindow(ComponentNameMatcher.NAV_BAR)
+            .containsAboveAppWindow(ComponentNameMatcher.NAV_BAR_LEGACY)
             .containsAboveAppWindow(TestComponents.SCREEN_DECOR_OVERLAY)
             .containsAboveAppWindow(ComponentNameMatcher.STATUS_BAR)
     }
@@ -97,8 +97,8 @@ class WindowManagerStateSubjectTest {
 
         assertFail("NavigationBar") {
             subject
-                .containsAboveAppWindow(ComponentNameMatcher.NAV_BAR)
-                .isNonAppWindowInvisible(ComponentNameMatcher.NAV_BAR)
+                .containsAboveAppWindow(ComponentNameMatcher.NAV_BAR_LEGACY)
+                .isNonAppWindowInvisible(ComponentNameMatcher.NAV_BAR_LEGACY)
         }
     }
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
index 71b109fcf..e2db55501 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
@@ -161,7 +161,7 @@ class WindowManagerTraceSubjectTest {
         WindowManagerTraceSubject(imeTrace, imeTraceReader)
             .doNotOverlap(
                 ComponentNameMatcher.IME,
-                ComponentNameMatcher.NAV_BAR,
+                ComponentNameMatcher.NAV_BAR_LEGACY,
                 TestComponents.IME_ACTIVITY,
             )
             .forAllEntries()
diff --git a/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt b/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
index 561831cce..1b0d209cd 100644
--- a/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
@@ -25,8 +25,6 @@ import android.tools.io.TraceType
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.TEST_SCENARIO
 import android.tools.testutils.assertArchiveContainsFiles
-import android.tools.testutils.getLauncherPackageName
-import android.tools.testutils.getSystemUiUidName
 import android.tools.traces.parsers.WindowManagerStateHelper
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.systemui.Flags.enableViewCaptureTracing
@@ -117,19 +115,6 @@ class FlickerServiceTracesCollectorTest {
         val EXPECTED_TRACES_LAUNCHER_ONLY =
             mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName)
                 .also {
-                    if (!android.tracing.Flags.perfettoProtologTracing()) {
-                        it.add(TraceType.PROTOLOG.fileName)
-                    }
-
-                    if (!android.tracing.Flags.perfettoTransitionTracing()) {
-                        it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
-                        it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
-                    }
-
-                    if (!android.tracing.Flags.perfettoViewCaptureTracing()) {
-                        it.add("${getLauncherPackageName()}_0.vc__view_capture_trace.winscope")
-                    }
-
                     if (!android.tracing.Flags.perfettoWmTracing()) {
                         it.add(TraceType.WM.fileName)
                     }
@@ -139,20 +124,6 @@ class FlickerServiceTracesCollectorTest {
         val EXPECTED_TRACES_LAUNCHER_FIRST =
             mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName)
                 .also {
-                    if (!android.tracing.Flags.perfettoProtologTracing()) {
-                        it.add(TraceType.PROTOLOG.fileName)
-                    }
-
-                    if (!android.tracing.Flags.perfettoTransitionTracing()) {
-                        it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
-                        it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
-                    }
-
-                    if (!android.tracing.Flags.perfettoViewCaptureTracing()) {
-                        it.add("${getLauncherPackageName()}_0.vc__view_capture_trace.winscope")
-                        it.add("${getSystemUiUidName()}_1.vc__view_capture_trace.winscope")
-                    }
-
                     if (!android.tracing.Flags.perfettoWmTracing()) {
                         it.add(TraceType.WM.fileName)
                     }
@@ -161,20 +132,6 @@ class FlickerServiceTracesCollectorTest {
 
         val EXPECTED_TRACES_SYSUI_FIRST =
             mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName).also {
-                if (!android.tracing.Flags.perfettoProtologTracing()) {
-                    it.add(TraceType.PROTOLOG.fileName)
-                }
-
-                if (!android.tracing.Flags.perfettoTransitionTracing()) {
-                    it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
-                    it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
-                }
-
-                if (!android.tracing.Flags.perfettoViewCaptureTracing()) {
-                    it.add("${getSystemUiUidName()}_0.vc__view_capture_trace.winscope")
-                    it.add("${getLauncherPackageName()}_1.vc__view_capture_trace.winscope")
-                }
-
                 if (!android.tracing.Flags.perfettoWmTracing()) {
                     it.add(TraceType.WM.fileName)
                 }
diff --git a/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt b/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
index ff1e82eac..160447ee9 100644
--- a/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
@@ -44,8 +44,11 @@ import androidx.test.platform.app.InstrumentationRegistry
 import com.google.common.truth.Truth
 import org.junit.After
 import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
+import org.junit.rules.TestRule
 import org.junit.runner.RunWith
+import org.junit.runners.model.Statement
 
 /**
  * Contains an integration test running a flicker service test using
@@ -59,6 +62,29 @@ class FullServiceRunTest {
     private val wmHelper = WindowManagerStateHelper(instrumentation)
     private val testApp = MessagingAppHelper(instrumentation)
 
+    @get:Rule
+    val myRule = TestRule { base, _ ->
+        object : Statement() {
+            @Throws(Throwable::class)
+            override fun evaluate() {
+                functionalTestRuleCalled = true
+                base.evaluate()
+            }
+        }
+    }
+
+    @Rule
+    @JvmField
+    val cleanUp = TestRule { base, _ ->
+        object : Statement() {
+            @Throws(Throwable::class)
+            override fun evaluate() {
+                fieldTestRuleCalled = true
+                base.evaluate()
+            }
+        }
+    }
+
     @Before
     fun setup() {
         // Nothing to do
@@ -67,6 +93,12 @@ class FullServiceRunTest {
     @ExpectedScenarios(["ENTIRE_TRACE"])
     @Test
     fun openApp() {
+        Truth.assertWithMessage("Functional test rule should have been called")
+            .that(functionalTestRuleCalled)
+            .isTrue()
+        Truth.assertWithMessage("Field test rule should have been called")
+            .that(fieldTestRuleCalled)
+            .isTrue()
         testApp.launchViaIntent(wmHelper)
     }
 
@@ -76,6 +108,9 @@ class FullServiceRunTest {
     }
 
     companion object {
+        private var functionalTestRuleCalled = false
+        private var fieldTestRuleCalled = false
+
         @JvmStatic
         @FlickerConfigProvider
         fun flickerConfigProvider(): FlickerConfig =
diff --git a/libraries/flicker/utils/src/android/tools/PlatformConsts.kt b/libraries/flicker/utils/src/android/tools/PlatformConsts.kt
index 6bd3a5fa2..6c5b7a4a1 100644
--- a/libraries/flicker/utils/src/android/tools/PlatformConsts.kt
+++ b/libraries/flicker/utils/src/android/tools/PlatformConsts.kt
@@ -90,8 +90,8 @@ object PlatformConsts {
     const val STATE_PAUSED = "PAUSED"
     const val STATE_STOPPED = "STOPPED"
     const val STATE_DESTROYED = "DESTROYED"
-    const val DESKTOP_MODE_MINIMUM_WINDOW_WIDTH = 386
-    const val DESKTOP_MODE_MINIMUM_WINDOW_HEIGHT = 352
+    const val DESKTOP_MODE_MINIMUM_WINDOW_WIDTH = 772
+    const val DESKTOP_MODE_MINIMUM_WINDOW_HEIGHT = 704
     internal const val APP_STATE_IDLE = "APP_STATE_IDLE"
     internal const val ACTIVITY_TYPE_UNDEFINED = 0
     internal const val ACTIVITY_TYPE_STANDARD = 1
@@ -103,6 +103,9 @@ object PlatformConsts {
     /** @see android.app.WindowConfiguration.WINDOWING_MODE_PINNED */
     internal const val WINDOWING_MODE_PINNED = 2
 
+    /** @see android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM */
+    internal const val WINDOWING_MODE_FREEFORM = 5
+
     /** @see android.view.WindowManager.LayoutParams */
     internal const val TYPE_NAVIGATION_BAR_PANEL = 2024
 
diff --git a/libraries/flicker/utils/src/android/tools/helpers/RecentTasksUtils.kt b/libraries/flicker/utils/src/android/tools/helpers/RecentTasksUtils.kt
new file mode 100644
index 000000000..f0f511ee5
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/helpers/RecentTasksUtils.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.helpers
+
+import android.app.Instrumentation
+
+object RecentTasksUtils {
+    @JvmStatic
+    fun clearAllVisibleRecentTasks(instrumentation: Instrumentation) {
+        instrumentation.uiAutomation.executeShellCommand(
+            "dumpsys activity service SystemUIService WMShell recents clearAll"
+        )
+    }
+}
diff --git a/libraries/flicker/utils/src/android/tools/rules/StopAllTracesRule.kt b/libraries/flicker/utils/src/android/tools/rules/StopAllTracesRule.kt
index fb31d5907..4a6e37654 100644
--- a/libraries/flicker/utils/src/android/tools/rules/StopAllTracesRule.kt
+++ b/libraries/flicker/utils/src/android/tools/rules/StopAllTracesRule.kt
@@ -20,7 +20,6 @@ import android.tools.ScenarioBuilder
 import android.tools.traces.io.ResultWriter
 import android.tools.traces.monitors.PerfettoTraceMonitor
 import android.tools.traces.monitors.TraceMonitor
-import android.tools.traces.monitors.view.ViewTraceMonitor
 import android.tools.traces.monitors.wm.LegacyShellTransitionTraceMonitor
 import android.tools.traces.monitors.wm.LegacyWmTransitionTraceMonitor
 import android.tools.traces.monitors.wm.WindowManagerTraceMonitor
@@ -38,7 +37,6 @@ class StopAllTracesRule : TestRule {
                 LegacyShellTransitionTraceMonitor().stopIfEnabled()
                 LegacyWmTransitionTraceMonitor().stopIfEnabled()
                 WindowManagerTraceMonitor().stopIfEnabled()
-                ViewTraceMonitor().stopIfEnabled()
 
                 base?.evaluate()
             }
diff --git a/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt b/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
index 0463d5859..7abb3703e 100644
--- a/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
@@ -24,14 +24,13 @@ import android.hardware.devicestate.feature.flags.Flags as DeviceStateManagerFla
 import android.tools.PlatformConsts
 import android.tools.Rotation
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.ComponentNameMatcher.Companion.BUBBLE
 import android.tools.traces.component.IComponentMatcher
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.surfaceflinger.Transform
 import android.tools.traces.surfaceflinger.Transform.Companion.isFlagSet
-import android.tools.traces.wm.WindowManagerState
 import android.tools.traces.wm.WindowState
 import androidx.test.platform.app.InstrumentationRegistry
-import com.android.wm.shell.Flags
 
 object ConditionsFactory {
 
@@ -59,12 +58,9 @@ object ConditionsFactory {
         return isPhone
     }
 
-    fun getNavBarComponent(wmState: WindowManagerState): IComponentMatcher {
-        var component: IComponentMatcher = ComponentNameMatcher.NAV_BAR
-        if (wmState.isTablet || !isPhoneNavBar() || Flags.enableTaskbarOnPhones()) {
-            component = component.or(ComponentNameMatcher.TASK_BAR)
-        }
-        return component
+    fun getNavBarComponentOrLegacy(): IComponentMatcher {
+        // FlickerLib tests may still use legacy navigation bar.
+        return ComponentNameMatcher.NAV_BAR_LEGACY.or(ComponentNameMatcher.NAV_BAR)
     }
 
     /**
@@ -86,7 +82,7 @@ object ConditionsFactory {
      */
     fun isNavOrTaskBarWindowVisible(): Condition<DeviceStateDump> =
         Condition("isNavBarOrTaskBarWindowVisible") {
-            val component = getNavBarComponent(it.wmState)
+            val component = getNavBarComponentOrLegacy()
             it.wmState.isWindowSurfaceShown(component)
         }
 
@@ -96,14 +92,14 @@ object ConditionsFactory {
      */
     fun isNavOrTaskBarLayerVisible(): Condition<DeviceStateDump> =
         Condition("isNavBarOrTaskBarLayerVisible") {
-            val component = getNavBarComponent(it.wmState)
+            val component = getNavBarComponentOrLegacy()
             it.layerState.isVisible(component)
         }
 
     /** Condition to check if the [ComponentNameMatcher.NAV_BAR] layer is opaque */
     fun isNavOrTaskBarLayerOpaque(): Condition<DeviceStateDump> =
         Condition("isNavOrTaskBarLayerOpaque") {
-            val component = getNavBarComponent(it.wmState)
+            val component = getNavBarComponentOrLegacy()
             it.layerState.getLayerWithBuffer(component)?.color?.alpha() == 1.0f
         }
 
@@ -113,10 +109,16 @@ object ConditionsFactory {
             listOf(isNavBarWindowVisible(), isNavBarLayerVisible(), isNavBarLayerOpaque())
         )
 
-    /** Condition to check if the [ComponentNameMatcher.NAV_BAR] window is visible */
-    fun isNavBarWindowVisible(): Condition<DeviceStateDump> =
-        Condition("isNavBarWindowVisible") {
-            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.NAV_BAR)
+    /**
+     * Condition to check if the [ComponentNameMatcher.NAV_BAR] window is visible on a specific
+     * display
+     */
+    @JvmOverloads
+    fun isNavBarWindowVisible(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("isNavBarWindowVisible[$displayId]") {
+            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.NAV_BAR, displayId)
         }
 
     /** Condition to check if the [ComponentNameMatcher.NAV_BAR] layer is visible */
@@ -135,10 +137,16 @@ object ConditionsFactory {
             listOf(isTaskBarWindowVisible(), isTaskBarLayerVisible(), isTaskBarLayerOpaque())
         )
 
-    /** Condition to check if the [ComponentNameMatcher.TASK_BAR] window is visible */
-    fun isTaskBarWindowVisible(): Condition<DeviceStateDump> =
-        Condition("isTaskBarWindowVisible") {
-            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.TASK_BAR)
+    /**
+     * Condition to check if the [ComponentNameMatcher.TASK_BAR] window is visible on a specific
+     * display
+     */
+    @JvmOverloads
+    fun isTaskBarWindowVisible(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("isTaskBarWindowVisible[$displayId]") {
+            it.wmState.isWindowSurfaceShown( ComponentNameMatcher.TASK_BAR, displayId)
         }
 
     /** Condition to check if the [ComponentNameMatcher.TASK_BAR] layer is visible */
@@ -157,10 +165,16 @@ object ConditionsFactory {
             listOf(isStatusBarWindowVisible(), isStatusBarLayerVisible(), isStatusBarLayerOpaque())
         )
 
-    /** Condition to check if the [ComponentNameMatcher.STATUS_BAR] window is visible */
-    fun isStatusBarWindowVisible(): Condition<DeviceStateDump> =
-        Condition("isStatusBarWindowVisible") {
-            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.STATUS_BAR)
+    /**
+     * Condition to check if the [ComponentNameMatcher.STATUS_BAR] window is visible on a specific
+     * display
+     */
+    @JvmOverloads
+    fun isStatusBarWindowVisible(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("isStatusBarWindowVisible[$displayId]") {
+            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.STATUS_BAR, displayId)
         }
 
     /** Condition to check if the [ComponentNameMatcher.STATUS_BAR] layer is visible */
@@ -174,8 +188,25 @@ object ConditionsFactory {
                 1.0f
         }
 
-    fun isHomeActivityVisible(): Condition<DeviceStateDump> =
-        Condition("isHomeActivityVisible") { it.wmState.isHomeActivityVisible }
+    @JvmOverloads
+    fun isHomeActivityVisible(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("isHomeActivityVisible[display=$displayId]") {
+            it.wmState.isHomeActivityVisible(displayId)
+        }
+
+    /**
+     * Condition to check if the [ComponentNameMatcher.IMAGE_WALLPAPER] window is visible on a
+     * specific display
+     */
+    @JvmOverloads
+    fun isImageWallpaperWindowVisible(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("isWallpaperWindowVisible[$displayId]") {
+            it.wmState.isWindowSurfaceShown(ComponentNameMatcher.IMAGE_WALLPAPER, displayId)
+        }
 
     fun isRecentsActivityVisible(): Condition<DeviceStateDump> =
         Condition("isRecentsActivityVisible") {
@@ -207,6 +238,15 @@ object ConditionsFactory {
             it.wmState.containsActivity(componentMatcher)
         }
 
+    /** Condition to check if a specific display contains no activity */
+    @JvmOverloads
+    fun hasNoActivityOnDisplay(
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+    ): Condition<DeviceStateDump> =
+        Condition("hasNoActivityOnDisplay[$displayId]") {
+            it.wmState.hasNoActivityOnDisplay(displayId)
+        }
+
     fun containsWindow(componentMatcher: IComponentMatcher): Condition<DeviceStateDump> =
         Condition("containsWindow[${componentMatcher.toWindowIdentifier()}]") {
             it.wmState.containsWindow(componentMatcher)
@@ -347,6 +387,10 @@ object ConditionsFactory {
     fun hasPipWindow(): Condition<DeviceStateDump> =
         Condition("hasPipWindow") { it.wmState.hasPipWindow() }
 
+    /** Checks whether the [BUBBLE] window exists. */
+    fun hasBubbleWindow(): Condition<DeviceStateDump> =
+        Condition("hasBubbleWindow") { it.wmState.containsWindow(BUBBLE) }
+
     fun isImeShown(displayId: Int): Condition<DeviceStateDump> =
         ConditionList(
             listOf(
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
index d9c7a9a28..f376e83d4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
@@ -99,13 +99,16 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
         get() = { it.contains(component.toLayerName()) }
 
     companion object {
-        @JvmField val NAV_BAR = ComponentNameMatcher("", "NavigationBar0")
+        // FlickerLibTest still need this field.
+        @JvmField val NAV_BAR_LEGACY = ComponentNameMatcher("", "NavigationBar0")
         @JvmField val TASK_BAR = ComponentNameMatcher("", "Taskbar")
+        // The navigation bar window are unified to "Taskbar".
+        @JvmField val NAV_BAR = TASK_BAR
         @JvmField val STATUS_BAR = ComponentNameMatcher("", "StatusBar")
         @JvmField val ROTATION = ComponentNameMatcher("", "RotationLayer")
         @JvmField val BACK_SURFACE = ComponentNameMatcher("", "BackColorSurface")
         @JvmField val IME = ComponentNameMatcher("", "InputMethod")
-        @JvmField val IME_SNAPSHOT = ComponentNameMatcher("", "IME-snapshot-surface")
+        @JvmField val IME_SCREENSHOT = ComponentNameMatcher("", "IME-screenshot-surface")
         @JvmField val SPLASH_SCREEN = ComponentNameMatcher("", "Splash Screen")
         @JvmField val SNAPSHOT = ComponentNameMatcher("", "SnapshotStartingWindow")
         @JvmField val SECONDARY_HOME_HANDLE = ComponentNameMatcher("", "SecondaryHomeHandle")
@@ -159,6 +162,12 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
 
         @JvmField val DEFAULT_TASK_DISPLAY_AREA = ComponentNameMatcher("", "DefaultTaskDisplayArea")
 
+        @JvmField val BUBBLE = ComponentNameMatcher("", "Bubbles!")
+
+        @JvmField
+        val IMAGE_WALLPAPER =
+            ComponentNameMatcher("","com.android.systemui.wallpapers.ImageWallpaper")
+
         /**
          * Creates a component matcher from a window or layer name.
          *
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
index eed2f9a44..e761f7c10 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
@@ -28,7 +28,8 @@ import java.util.function.Predicate
  * If you want to only match the window and layer with the specified ids then use
  * ExactComponentIdMatcher instead.
  */
-class FullComponentIdMatcher(val windowId: Int, val layerId: Int) : IComponentMatcher {
+class FullComponentIdMatcher(val windowId: Int, val layerId: Int, val name: String? = null) :
+    IComponentMatcher {
     /**
      * @param windows to search
      * @return if any of the components matches any of [windows]
@@ -74,8 +75,18 @@ class FullComponentIdMatcher(val windowId: Int, val layerId: Int) : IComponentMa
     override fun toActivityIdentifier() = toWindowIdentifier()
 
     /** {@inheritDoc} */
-    override fun toWindowIdentifier() = "Window#${windowId.toString(16)} & children"
+    override fun toWindowIdentifier() =
+        if (name == null) {
+            "Window#${windowId.toString(16)} & children"
+        } else {
+            "$name (Window#${windowId.toString(16)} & children)"
+        }
 
     /** {@inheritDoc} */
-    override fun toLayerIdentifier(): String = "Layer#$layerId & children"
+    override fun toLayerIdentifier(): String =
+        if (name == null) {
+            "Layer#$layerId & children"
+        } else {
+            "$name (Layer#$layerId & children)"
+        }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt b/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
index 6bca2049a..2eeb155a7 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
@@ -34,7 +34,6 @@ import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.TransactionsTraceParser
 import android.tools.traces.parsers.perfetto.TransitionsTraceParser
 import android.tools.traces.parsers.perfetto.WindowManagerTraceParser
-import android.tools.traces.parsers.wm.LegacyTransitionTraceParser
 import android.tools.traces.parsers.wm.LegacyWindowManagerTraceParser
 import android.tools.traces.parsers.wm.WindowManagerDumpParser
 import android.tools.traces.protolog.ProtoLogTrace
@@ -211,12 +210,7 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
     @Throws(IOException::class)
     override fun readTransitionsTrace(): TransitionsTrace? {
         return withTracing("readTransitionsTrace") {
-            val trace =
-                if (android.tracing.Flags.perfettoTransitionTracing()) {
-                    readPerfettoTransitionsTrace()
-                } else {
-                    readLegacyTransitionTrace()
-                }
+            val trace = readPerfettoTransitionsTrace()
 
             if (trace == null) {
                 return@withTracing null
@@ -290,25 +284,6 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
         }
     }
 
-    private fun readLegacyTransitionTrace(): TransitionsTrace? {
-        val wmSideTraceData =
-            artifact.readBytes(ResultArtifactDescriptor(TraceType.LEGACY_WM_TRANSITION))
-        val shellSideTraceData =
-            artifact.readBytes(ResultArtifactDescriptor(TraceType.LEGACY_SHELL_TRANSITION))
-
-        return if (wmSideTraceData == null || shellSideTraceData == null) {
-            null
-        } else {
-            LegacyTransitionTraceParser()
-                .parse(
-                    wmSideTraceData,
-                    shellSideTraceData,
-                    from = transitionTimeRange.start,
-                    to = transitionTimeRange.end,
-                )
-        }
-    }
-
     private fun minimumTraceEntriesForConfig(config: TraceConfig): Int {
         return if (config.allowNoChange) 1 else 2
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/TraceReaderUtils.kt b/libraries/flicker/utils/src/android/tools/traces/io/TraceReaderUtils.kt
new file mode 100644
index 000000000..33649c57c
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/traces/io/TraceReaderUtils.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.traces.io
+
+import android.content.Context
+import android.tools.Scenario
+import android.tools.Timestamps
+import android.tools.io.Reader
+import android.tools.io.TransitionTimeRange
+import android.tools.traces.TRACE_CONFIG_REQUIRE_CHANGES
+import androidx.test.platform.app.InstrumentationRegistry
+import java.io.File
+import java.io.IOException
+
+object TraceReaderUtils {
+    fun getTraceReaderFromAsset(scenario: Scenario, path: String): Reader {
+        val file = readAssetAsFile(path)
+
+        val artifact = FileArtifact(scenario, file, 0)
+
+        val result =
+            ResultData(
+                artifact,
+                // TODO (b/408161530): We need to somehow store this in the trace or pass it in some
+                //  way otherwise we will be analyzing too much data (the test rules, before and
+                //  after blocks included)
+                TransitionTimeRange(Timestamps.min(), Timestamps.max()),
+                null,
+            )
+
+        return ResultReaderWithLru(result, TRACE_CONFIG_REQUIRE_CHANGES)
+    }
+
+    @Throws(IOException::class)
+    fun readAssetAsFile(path: String): File {
+        val context: Context = InstrumentationRegistry.getInstrumentation().context
+        return File(context.cacheDir, path).also {
+            if (!it.exists()) {
+                it.parentFile.mkdirs()
+                it.createNewFile()
+                it.outputStream().use { cache ->
+                    context.assets.open(path).use { inputStream -> inputStream.copyTo(cache) }
+                }
+            }
+        }
+    }
+}
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
index 5596ed8a8..a6a5517a3 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
@@ -289,7 +289,7 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
 
             if (logFrom != null) {
                 protoLogConfigBuilder.setDefaultLogFromLevel(
-                    PerfettoConfig.ProtoLogLevel.forNumber(logFrom.id)
+                    PerfettoConfig.ProtoLogLevel.forNumber(logFrom.protoMessageId)
                 )
             }
 
@@ -298,7 +298,9 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
                     PerfettoConfig.ProtoLogGroup.newBuilder()
                         .setGroupName(groupOverride.groupName)
                         .setLogFrom(
-                            PerfettoConfig.ProtoLogLevel.forNumber(groupOverride.logFrom.id)
+                            PerfettoConfig.ProtoLogLevel.forNumber(
+                                groupOverride.logFrom.protoMessageId
+                            )
                         )
                         .setCollectStacktrace(groupOverride.collectStackTrace)
                 )
@@ -345,15 +347,15 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
     companion object {
         private const val TRACE_BUFFER_SIZE_KB = 1024 * 1024
 
-        private const val IME_DATA_SOURCE = "android.inputmethod"
-        private const val SF_LAYERS_DATA_SOURCE = "android.surfaceflinger.layers"
-        private const val SF_TRANSACTIONS_DATA_SOURCE = "android.surfaceflinger.transactions"
-        private const val TRANSITIONS_DATA_SOURCE = "com.android.wm.shell.transition"
-        private const val PROTOLOG_DATA_SOURCE = "android.protolog"
-        private const val VIEWCAPTURE_DATA_SOURCE = "android.viewcapture"
-        private const val WINDOWMANAGER_DATA_SOURCE = "android.windowmanager"
-        private const val PROCESS_STATS_DATA_SOURCE = "linux.process_stats"
-        private const val FTRACE_DATA_SOURCE = "linux.ftrace"
+        const val IME_DATA_SOURCE = "android.inputmethod"
+        const val SF_LAYERS_DATA_SOURCE = "android.surfaceflinger.layers"
+        const val SF_TRANSACTIONS_DATA_SOURCE = "android.surfaceflinger.transactions"
+        const val TRANSITIONS_DATA_SOURCE = "com.android.wm.shell.transition"
+        const val PROTOLOG_DATA_SOURCE = "android.protolog"
+        const val VIEWCAPTURE_DATA_SOURCE = "android.viewcapture"
+        const val WINDOWMANAGER_DATA_SOURCE = "android.windowmanager"
+        const val PROCESS_STATS_DATA_SOURCE = "linux.process_stats"
+        const val FTRACE_DATA_SOURCE = "linux.ftrace"
 
         private val allPerfettoPids = mutableListOf<Int>()
         private val allPerfettoPidsLock = ReentrantLock()
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/view/ViewTraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/view/ViewTraceMonitor.kt
deleted file mode 100644
index 0322252f2..000000000
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/view/ViewTraceMonitor.kt
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.traces.monitors.view
-
-import android.tools.io.TraceType
-import android.tools.traces.executeShellCommand
-import android.tools.traces.io.ResultWriter
-import android.tools.traces.monitors.LOG_TAG
-import android.tools.traces.monitors.TraceMonitor
-import android.util.Log
-import java.io.File
-import java.util.zip.ZipFile
-
-/** Captures View traces from Launcher. */
-open class ViewTraceMonitor : TraceMonitor() {
-    override val traceType = TraceType.VIEW
-    override val isEnabled
-        get() =
-            String(executeShellCommand("su root settings get global view_capture_enabled"))
-                .trim() == "1"
-
-    override fun doStart() {
-        doEnableDisableTrace(enable = true)
-    }
-
-    override fun doStop(): File {
-        val outputFileZip = dumpTraces()
-        doEnableDisableTrace(enable = false)
-        return outputFileZip
-    }
-
-    override fun stop(writer: ResultWriter) {
-        val viewCaptureZip = doStop()
-        writer.writeTraces(viewCaptureZip)
-    }
-
-    private fun dumpTraces(): File {
-        val outputFileZip = File.createTempFile(traceType.fileName, "")
-        val stdout = executeShellCommand("su root cmd launcherapps dump-view-hierarchies")
-        outputFileZip.writeBytes(stdout)
-        return outputFileZip
-    }
-
-    private fun ResultWriter.writeTraces(viewCaptureZip: File) {
-        Log.d(LOG_TAG, "Uncompressing $viewCaptureZip from zip")
-        ZipFile(viewCaptureZip).use { zipFile ->
-            val entries = zipFile.entries()
-            while (entries.hasMoreElements()) {
-                val entry = entries.nextElement()
-                if (!entry.isDirectory) {
-                    Log.d(LOG_TAG, "Found ${entry.name}")
-                    val fileName = entry.name.split("/").last()
-                    zipFile.getInputStream(entry).use { inputStream ->
-                        val unzippedFile = File.createTempFile(traceType.fileName, fileName)
-                        unzippedFile.writeBytes(inputStream.readAllBytes())
-
-                        addTraceResult(traceType, unzippedFile, tag = fileName)
-                    }
-                }
-            }
-        }
-    }
-
-    private fun doEnableDisableTrace(enable: Boolean) {
-        executeShellCommand(
-            "su root settings put global view_capture_enabled ${if (enable) "1" else "0"}"
-        )
-    }
-}
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/wm/WindowManagerTraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/wm/WindowManagerTraceMonitor.kt
index 4ff7e4c49..105594191 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/wm/WindowManagerTraceMonitor.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/wm/WindowManagerTraceMonitor.kt
@@ -43,11 +43,6 @@ open class WindowManagerTraceMonitor : TraceMonitor() {
 
     override fun doStopTraces(): Map<TraceType, File> {
         val result = mutableMapOf(traceType to doStop())
-        if (!android.tracing.Flags.perfettoProtologTracing()) {
-            val protologFile = TRACE_DIR.resolve(TraceType.PROTOLOG.fileName)
-            Log.d(LOG_TAG, "Adding protolog trace from $protologFile")
-            result[TraceType.PROTOLOG] = protologFile
-        }
         return result
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
index deb616266..8ae762324 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
@@ -19,7 +19,6 @@ package android.tools.traces.parsers
 import android.app.ActivityTaskManager
 import android.app.Instrumentation
 import android.app.WindowConfiguration
-import android.graphics.Rect
 import android.graphics.Region
 import android.os.SystemClock
 import android.os.Trace
@@ -30,6 +29,7 @@ import android.tools.traces.DeviceStateDump
 import android.tools.traces.LOG_TAG
 import android.tools.traces.WaitCondition
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.ComponentNameMatcher.Companion.BUBBLE
 import android.tools.traces.component.ComponentNameMatcher.Companion.IME
 import android.tools.traces.component.ComponentNameMatcher.Companion.LAUNCHER
 import android.tools.traces.component.ComponentNameMatcher.Companion.SNAPSHOT
@@ -230,6 +230,37 @@ constructor(
                 .add(ConditionsFactory.isHomeActivityVisible())
                 .add(ConditionsFactory.isLauncherLayerVisible())
 
+        /**
+         * Waits until the home activity, navigation bar and taskbar are visible, and nothing to be
+         * animating on a specific display
+         *
+         * @param displayId of the target display
+         */
+        @JvmOverloads
+        fun withDesktopModeOnDisplay(displayId: Int = Display.DEFAULT_DISPLAY) =
+            withAppTransitionIdle(displayId)
+                .add(ConditionsFactory.isHomeActivityVisible(displayId))
+                .add(ConditionsFactory.isNavBarWindowVisible(displayId))
+                .add(ConditionsFactory.isTaskBarWindowVisible(displayId))
+                .add(ConditionsFactory.isStatusBarWindowVisible(displayId))
+                .add(ConditionsFactory.isImageWallpaperWindowVisible(displayId))
+
+        /**
+         * Waits until the home activity, navigation bar and status bar are no longer visible, and
+         * nothing to be animating on a specific display
+         *
+         * @param displayId of the target display
+         */
+        @JvmOverloads
+        fun withEmptyDisplay(displayId: Int = Display.DEFAULT_DISPLAY) =
+            withAppTransitionIdle(displayId)
+                .add(ConditionsFactory.isHomeActivityVisible(displayId).negate())
+                .add(ConditionsFactory.isNavBarWindowVisible(displayId).negate())
+                .add(ConditionsFactory.isTaskBarWindowVisible(displayId).negate())
+                .add(ConditionsFactory.isStatusBarWindowVisible(displayId).negate())
+                .add(ConditionsFactory.isImageWallpaperWindowVisible(displayId).negate())
+                .add(ConditionsFactory.hasNoActivityOnDisplay(displayId))
+
         /**
          * Waits until the split-screen divider is visible and nothing to be animating
          *
@@ -370,16 +401,20 @@ constructor(
             compareFn: (Region, Region) -> Boolean = { surfaceRegion, expected ->
                 surfaceRegion == expected
             },
-        ) = add(Condition("surfaceRegion") {
-            val layer = it.layerState.visibleLayers.firstOrNull { layer ->
-                componentMatcher.layerMatchesAnyOf(layer)
-            }
-            layer?.let {
-                // TODO(pablogamito): Remove non-null assertion once visibleRegion in
-                // LayerProperties is no longer nullable.
-                compareFn(layer.visibleRegion!!, expectedRegion)
-            } ?: false
-        })
+        ) =
+            add(
+                Condition("surfaceRegion") {
+                    val layer =
+                        it.layerState.visibleLayers.firstOrNull { layer ->
+                            componentMatcher.layerMatchesAnyOf(layer)
+                        }
+                    layer?.let {
+                        // TODO(pablogamito): Remove non-null assertion once visibleRegion in
+                        // LayerProperties is no longer nullable.
+                        compareFn(layer.visibleRegion ?: Region(), expectedRegion)
+                    } ?: false
+                }
+            )
 
         /**
          * Waits until the IME window and layer are visible
@@ -416,6 +451,24 @@ constructor(
         fun withPipShown(displayId: Int = Display.DEFAULT_DISPLAY) =
             withAppTransitionIdle(displayId).add(ConditionsFactory.hasPipWindow())
 
+        /**
+         * Checks whether [BUBBLE] is shown.
+         *
+         * @param displayId of the target display
+         */
+        @JvmOverloads
+        fun withBubbleShown(displayId: Int = Display.DEFAULT_DISPLAY) =
+            withAppTransitionIdle(displayId).add(ConditionsFactory.isLayerVisible(BUBBLE))
+
+        /**
+         * Checks whether [BUBBLE] is gone.
+         *
+         * @param displayId of the target display
+         */
+        @JvmOverloads
+        fun withBubbleGone(displayId: Int = Display.DEFAULT_DISPLAY) =
+            withAppTransitionIdle(displayId).add(ConditionsFactory.hasBubbleWindow().negate())
+
         /**
          * Waits until a window is no longer in PIP mode. That is:
          * - wait until there are no pinned ([WindowManagerState.pinnedWindows])
@@ -453,6 +506,38 @@ constructor(
             }
         }
 
+        /**
+         * Adds a condition to check if the top visible application windows match the given matchers
+         * in order.
+         *
+         * This function verifies that the top visible app windows (`wmState.visibleAppWindows`)
+         * match the provided `IComponentMatcher` instances in the order they are specified. It
+         * ensures there are enough visible windows and that each window matches its corresponding
+         * matcher.
+         */
+        fun withTopVisibleApps(vararg matchers: IComponentMatcher): StateSyncBuilder {
+            return add("withTopVisibleApps") {
+                val visibleApps = it.wmState.visibleAppWindows
+
+                if (visibleApps.size < matchers.size || visibleApps !is List) {
+                    // Not enough windows in the visible list or visibleApps collection is not List
+                    return@add false
+                }
+
+                for (i in matchers.indices) {
+                    val matcher = matchers[i]
+                    val window = visibleApps[i]
+
+                    // Check if the window at this position matches the expected matcher
+                    if (!matcher.windowMatchesAnyOf(window)) {
+                        return@add false
+                    }
+                }
+
+                return@add true
+            }
+        }
+
         /**
          * Wait for the activities to appear in proper stacks and for valid state in AM and WM.
          *
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
index ea088b4d7..fb4982906 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,22 +23,16 @@ package android.tools.traces.parsers.perfetto
 
 import android.tools.io.TraceType
 import android.tools.withTracing
+import androidx.benchmark.macro.runServer
 import androidx.benchmark.traceprocessor.PerfettoTrace
 import androidx.benchmark.traceprocessor.TraceProcessor
-import androidx.benchmark.macro.runServer
 import java.io.File
 import java.io.FileOutputStream
 
 typealias Row = Map<String, Any?>
 
-class TraceProcessorSession(val session: TraceProcessor.Session) {
-
-    fun <T> query(sql: String, predicate: (List<Row>) -> T): T {
-        return withTracing("TraceProcessorSession#query") {
-            val rows = session.query(sql)
-            predicate(rows.toList())
-        }
-    }
+interface TraceProcessorSession {
+    fun <T> query(sql: String, predicate: (List<Row>) -> T): T
 
     companion object {
         @JvmStatic
@@ -49,11 +43,11 @@ class TraceProcessorSession(val session: TraceProcessor.Session) {
                 val result =
                     TraceProcessor.runServer {
                         loadTrace(PerfettoTrace(traceFile.absolutePath)) {
-                            predicate(TraceProcessorSession(this))
+                            predicate(TraceProcessorSessionImpl(this))
                         }
                     }
                 result
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSessionImpl.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSessionImpl.kt
new file mode 100644
index 000000000..0a33ce62f
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSessionImpl.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@file:OptIn(
+    androidx.benchmark.perfetto.ExperimentalPerfettoCaptureApi::class,
+    androidx.benchmark.traceprocessor.ExperimentalTraceProcessorApi::class,
+)
+
+package android.tools.traces.parsers.perfetto
+
+import android.tools.withTracing
+import androidx.benchmark.traceprocessor.TraceProcessor
+
+class TraceProcessorSessionImpl(val session: TraceProcessor.Session) : TraceProcessorSession {
+
+    override fun <T> query(sql: String, predicate: (List<Row>) -> T): T {
+        return withTracing("TraceProcessorSession#query") {
+            val rows = session.query(sql)
+            predicate(rows.toList())
+        }
+    }
+}
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
index f2de4310c..8b30494bc 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
@@ -26,7 +26,7 @@ import android.tools.traces.wm.TransitionType
 import android.tools.traces.wm.TransitionsTrace
 import android.tools.traces.wm.WmTransitionData
 
-class TransitionsTraceParser :
+open class TransitionsTraceParser :
     AbstractTraceParser<TraceProcessorSession, Transition, Transition, TransitionsTrace>() {
 
     override val traceName = "Transitions Trace"
@@ -71,6 +71,25 @@ class TransitionsTraceParser :
 
     override fun onBeforeParse(input: TraceProcessorSession) {}
 
+    override fun doParse(
+        input: TraceProcessorSession,
+        from: Timestamp,
+        to: Timestamp,
+        addInitialEntry: Boolean,
+    ): TransitionsTrace {
+        val sliceEntries =
+            getEntries(input).filter {
+                (it.wmData.sendTime ?: it.shellData.dispatchTime ?: Timestamps.min()) >= from &&
+                    (it.wmData.finishTime
+                        ?: it.wmData.abortTime
+                        ?: it.shellData.abortTime
+                        ?: it.shellData.mergeTime
+                        ?: Timestamps.max()) <= to
+            }
+
+        return createTrace(sliceEntries)
+    }
+
     override fun doParseEntry(entry: Transition) = entry
 
     companion object {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyTransitionTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyTransitionTraceParser.kt
deleted file mode 100644
index 07d6ae5bf..000000000
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyTransitionTraceParser.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.traces.parsers.wm
-
-import android.tools.Timestamp
-import android.tools.Timestamps
-import android.tools.traces.wm.TransitionsTrace
-
-class LegacyTransitionTraceParser {
-    private val wmTransitionTraceParser = WmTransitionTraceParser()
-    private val shellTransitionTraceParser = ShellTransitionTraceParser()
-
-    fun parse(
-        wmSideTraceData: ByteArray,
-        shellSideTraceData: ByteArray,
-        from: Timestamp = Timestamps.min(),
-        to: Timestamp = Timestamps.max(),
-    ): TransitionsTrace {
-        val wmTransitionTrace = wmTransitionTraceParser.parse(wmSideTraceData, from, to)
-        val shellTransitionTrace = shellTransitionTraceParser.parse(shellSideTraceData, from, to)
-
-        return TransitionsTrace(wmTransitionTrace.entries + shellTransitionTrace.entries)
-            .asCompressed()
-    }
-}
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
index 68dcebd97..4180995a4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
@@ -25,4 +25,7 @@ enum class Flag(val value: Int) {
     ENABLE_BACKPRESSURE(0x100),
     DISPLAY_DECORATION(0x200),
     IGNORE_DESTINATION_FRAME(0x400),
+    LAYER_IS_REFRESH_RATE_INDICATOR(0x800),
+    CAN_OCCLUDE_PRESENTATION(0x1000),
+    RECOVERABLE_FROM_BUFFER_STUFFING(0x2000),
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt b/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
index c473218ec..36627b9f6 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
@@ -44,6 +44,8 @@ class Transition(
         }
     }
 
+    // TODO: Rethink the timestamp assigned to transitions, conceptually these are not discrete
+    //  entries but continuous time ranges over which a transition lives.
     override val timestamp =
         wmData.createTime
             ?: wmData.sendTime
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
index cf8f94727..9abce8691 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
@@ -118,6 +118,9 @@ class WindowManagerState(
     val pinnedWindows: Collection<WindowState>
         get() = visibleWindows.filter { it.windowingMode == PlatformConsts.WINDOWING_MODE_PINNED }
 
+    val freeformWindows: Collection<WindowState>
+        get() = visibleWindows.filter { it.windowingMode == PlatformConsts.WINDOWING_MODE_FREEFORM }
+
     val pendingActivities: Collection<Activity>
         get() = _pendingActivities.mapNotNull { getActivityByName(it) }
 
@@ -236,6 +239,9 @@ class WindowManagerState(
     fun getStackByActivityType(activityType: Int): Task? =
         rootTasks.firstOrNull { it.activityType == activityType }
 
+    fun getStackByActivityType(activityType: Int, displayId: Int): Task? =
+        getDisplay(displayId)?.rootTasks?.firstOrNull { it.activityType == activityType }
+
     fun getStandardStackByWindowingMode(windowingMode: Int): Task? =
         rootTasks.firstOrNull {
             it.activityType == PlatformConsts.ACTIVITY_TYPE_STANDARD &&
@@ -316,12 +322,33 @@ class WindowManagerState(
 
     /**
      * @param componentMatcher Components to search
-     * @return the visible [WindowState]s matching [componentMatcher]
+     * @param displayId Display to search
+     * @return the visible [WindowState]s matching [componentMatcher] on the specific display
      */
+    @JvmOverloads
     fun getMatchingVisibleWindowState(
-        componentMatcher: IComponentMatcher
+        componentMatcher: IComponentMatcher,
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY,
     ): Collection<WindowState> {
-        return windowStates.filter { it.isSurfaceShown && componentMatcher.windowMatchesAnyOf(it) }
+        return windowStates.filter {
+            it.displayId == displayId &&
+                it.isSurfaceShown &&
+                componentMatcher.windowMatchesAnyOf(it)
+        }
+    }
+
+    /**
+     * @param displayId Display to search
+     * @return True if the home activity is not null and visible on the specified display, false
+     *   otherwise.
+     */
+    fun isHomeActivityVisible(displayId: Int): Boolean {
+        val homeActivityOfDisplay =
+            getStackByActivityType(PlatformConsts.ACTIVITY_TYPE_HOME, displayId)
+                ?.topTask
+                ?.activities
+                ?.lastOrNull()
+        return homeActivityOfDisplay != null && homeActivityOfDisplay.isVisible
     }
 
     /** @return the [WindowState] for the nav bar in the display with id [displayId] */
@@ -348,16 +375,28 @@ class WindowManagerState(
         componentMatcher.windowMatchesAnyOf(windowStates)
 
     /**
-     * Check if at least one [WindowState] matching [componentMatcher] is visible
+     * Check if at least one [WindowState] matching [componentMatcher] is visible on the specific
+     * display
      *
      * @param componentMatcher Components to search
+     * @param displayId Display to search
      */
-    fun isWindowSurfaceShown(componentMatcher: IComponentMatcher): Boolean =
-        getMatchingVisibleWindowState(componentMatcher).isNotEmpty()
+    @JvmOverloads
+    fun isWindowSurfaceShown(
+        componentMatcher: IComponentMatcher,
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY,
+    ): Boolean = getMatchingVisibleWindowState(componentMatcher, displayId).isNotEmpty()
+
+    @JvmOverloads
+    fun hasNoActivityOnDisplay(displayId: Int = PlatformConsts.DEFAULT_DISPLAY): Boolean =
+        getDisplay(displayId)?.rootTasks?.isEmpty() ?: true
 
     /** Checks if the state has any window in PIP mode */
     fun hasPipWindow(): Boolean = pinnedWindows.isNotEmpty()
 
+    /** Checks if the state has any window in Freeform mode */
+    fun hasFreeformWindow(): Boolean = freeformWindows.isNotEmpty()
+
     /**
      * Checks that a [WindowState] matching [componentMatcher] is in PIP mode
      *
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt
deleted file mode 100644
index 1a6b0037c..000000000
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.io
-
-import android.tools.Timestamp
-import android.tools.testutils.TestTraces
-import android.tools.testutils.readAssetAsFile
-import android.tools.traces.io.ResultReader
-import android.tools.traces.io.ResultWriter
-import org.junit.Assume.assumeFalse
-import org.junit.Before
-
-/** Tests for [ResultReader] parsing [TraceType.TRANSITION] */
-class ResultReaderParseLegacyTransitionsTest : BaseResultReaderTestParseTrace() {
-    override val assetFiles =
-        mapOf(
-            TraceType.LEGACY_WM_TRANSITION to TestTraces.LegacyTransitionTrace.WM_FILE,
-            TraceType.LEGACY_SHELL_TRANSITION to TestTraces.LegacyTransitionTrace.SHELL_FILE,
-        )
-    override val traceName = "Transitions trace"
-    override val startTimeTrace = TestTraces.LegacyTransitionTrace.START_TIME
-    override val endTimeTrace = TestTraces.LegacyTransitionTrace.END_TIME
-    override val validSliceTime = TestTraces.LegacyTransitionTrace.VALID_SLICE_TIME
-    override val invalidSliceTime = TestTraces.LegacyTransitionTrace.INVALID_SLICE_TIME
-    override val invalidSizeMessage = "Transitions trace cannot be empty"
-    override val expectedSlicedTraceSize = 10
-
-    @Before
-    fun before() {
-        assumeFalse(android.tracing.Flags.perfettoTransitionTracing())
-    }
-
-    override fun doParse(reader: ResultReader) = reader.readTransitionsTrace()
-
-    override fun getTime(traceTime: Timestamp) = traceTime.elapsedNanos
-
-    override fun setupWriter(writer: ResultWriter): ResultWriter {
-        return super.setupWriter(writer).also {
-            val wmTransitionTrace = readAssetAsFile("wm_transition_trace.winscope")
-            val shellTransitionTrace = readAssetAsFile("shell_transition_trace.winscope")
-            it.addTraceResult(TraceType.LEGACY_WM_TRANSITION, wmTransitionTrace)
-            it.addTraceResult(TraceType.LEGACY_SHELL_TRANSITION, shellTransitionTrace)
-        }
-    }
-}
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseProtoLogTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseProtoLogTest.kt
index 7388d0e18..ad87ad5d9 100644
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseProtoLogTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseProtoLogTest.kt
@@ -35,11 +35,6 @@ class ResultReaderParseProtoLogTest : BaseResultReaderTestParseTrace() {
     override val invalidSizeMessage = "ProtoLog trace cannot be empty"
     override val expectedSlicedTraceSize = 1
 
-    @Before
-    fun before() {
-        assumeTrue(android.tracing.Flags.perfettoProtologTracing())
-    }
-
     override fun doParse(reader: ResultReader) = reader.readProtoLogTrace()
 
     override fun getTime(traceTime: Timestamp) = traceTime.elapsedNanos
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseTransitionsTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseTransitionsTest.kt
index cae26bcc1..e843301ca 100644
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseTransitionsTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseTransitionsTest.kt
@@ -19,8 +19,6 @@ package android.tools.io
 import android.tools.Timestamp
 import android.tools.testutils.TestTraces
 import android.tools.traces.io.ResultReader
-import org.junit.Assume.assumeTrue
-import org.junit.Before
 
 /** Tests for [ResultReader] parsing [TraceType.TRANSITION] */
 class ResultReaderParseTransitionsTest : BaseResultReaderTestParseTrace() {
@@ -33,11 +31,6 @@ class ResultReaderParseTransitionsTest : BaseResultReaderTestParseTrace() {
     override val invalidSizeMessage = "Transitions trace cannot be empty"
     override val expectedSlicedTraceSize = 1
 
-    @Before
-    fun before() {
-        assumeTrue(android.tracing.Flags.perfettoTransitionTracing())
-    }
-
     override fun doParse(reader: ResultReader) = reader.readTransitionsTrace()
 
     override fun getTime(traceTime: Timestamp) = traceTime.elapsedNanos
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
index 2928e00a5..2ba6502ce 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
@@ -102,11 +102,6 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
 
     @Test
     fun withTransitionTracingTest() {
-        assumeTrue(
-            "PerfettoTransitionTracing flag should be enabled",
-            android.tracing.Flags.perfettoTransitionTracing(),
-        )
-
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableTransitionsTrace().build()
         val reader =
             traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
@@ -177,11 +172,6 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
 
     @Test
     fun viewCaptureTracingTest() {
-        assumeTrue(
-            "PerfettoViewCaptureTracing flag should be enabled",
-            android.tracing.Flags.perfettoViewCaptureTracing(),
-        )
-
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableViewCaptureTrace().build()
         val reader =
             traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/view/ViewTraceMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/view/ViewTraceMonitorTest.kt
deleted file mode 100644
index 99c5fce7b..000000000
--- a/libraries/flicker/utils/test/src/android/tools/monitors/view/ViewTraceMonitorTest.kt
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.monitors.view
-
-import android.tools.io.TraceType
-import android.tools.monitors.TraceMonitorTest
-import android.tools.testutils.assertArchiveContainsFiles
-import android.tools.testutils.getActualTraceFilesFromArchive
-import android.tools.testutils.getLauncherPackageName
-import android.tools.testutils.getSystemUiUidName
-import android.tools.testutils.newTestResultWriter
-import android.tools.traces.TRACE_CONFIG_REQUIRE_CHANGES
-import android.tools.traces.io.ResultReader
-import android.tools.traces.monitors.view.ViewTraceMonitor
-import android.tracing.Flags
-import com.android.systemui.Flags.enableViewCaptureTracing
-import com.google.common.truth.Truth
-import java.io.File
-import org.junit.Assume
-import org.junit.Before
-import org.junit.FixMethodOrder
-import org.junit.Test
-import org.junit.runners.MethodSorters
-
-/** Tests for [ViewTraceMonitor] */
-@FixMethodOrder(MethodSorters.NAME_ASCENDING)
-class ViewTraceMonitorTest : TraceMonitorTest<ViewTraceMonitor>() {
-    override val traceType = TraceType.VIEW
-
-    override fun getMonitor() = ViewTraceMonitor()
-
-    override fun assertTrace(traceData: ByteArray) {
-        Truth.assertThat(traceData.size).isGreaterThan(0)
-    }
-
-    @Before
-    override fun before() {
-        Assume.assumeFalse(Flags.perfettoViewCaptureTracing())
-        super.before()
-    }
-
-    @Test
-    @Throws(Exception::class)
-    override fun captureTrace() {
-        var possibleExpectedTraces = listOf(EXPECTED_TRACES_LAUNCHER_ONLY)
-        if (enableViewCaptureTracing()) {
-            possibleExpectedTraces =
-                listOf(EXPECTED_TRACES_LAUNCHER_FIRST, EXPECTED_TRACES_SYSUI_FIRST)
-        }
-
-        traceMonitor.start()
-        device.pressHome()
-        device.pressRecentApps()
-        val writer = newTestResultWriter()
-        traceMonitor.stop(writer)
-        val result = writer.write()
-        val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
-
-        val traceArtifactPath = reader.artifactPath
-        require(traceArtifactPath.isNotEmpty()) { "Artifact path missing in result" }
-        val traceArchive = File(traceArtifactPath)
-
-        assertArchiveContainsFiles(traceArchive, possibleExpectedTraces)
-        val actualTraceFiles = getActualTraceFilesFromArchive(traceArchive)
-        val tagList = getTagListFromTraces(actualTraceFiles)
-        for (tag: String in tagList) {
-            val trace =
-                reader.readBytes(traceMonitor.traceType, tag)
-                    ?: error("Missing trace file ${traceMonitor.traceType}")
-            Truth.assertWithMessage("Trace file size").that(trace.size).isGreaterThan(0)
-            assertTrace(trace)
-        }
-    }
-
-    // We override this test to create a placeholder since the [withTracing] method does not align
-    // with the implementation of multiple instances of ViewCapture.
-    @Test
-    @Throws(Exception::class)
-    override fun withTracing() {
-        Truth.assertThat(true).isTrue()
-    }
-
-    private fun getTagListFromTraces(actualTraceFiles: List<String>): List<String> {
-        var tagList: List<String> = emptyList()
-        for (traceFile: String in actualTraceFiles) {
-            tagList += traceFile.removeSuffix("__view_capture_trace.winscope")
-        }
-        return tagList
-    }
-
-    companion object {
-        val EXPECTED_TRACES_LAUNCHER_ONLY =
-            listOf("${getLauncherPackageName()}_0.vc__view_capture_trace.winscope")
-        val EXPECTED_TRACES_LAUNCHER_FIRST =
-            listOf(
-                "${getLauncherPackageName()}_0.vc__view_capture_trace.winscope",
-                "${getSystemUiUidName()}_1.vc__view_capture_trace.winscope",
-            )
-
-        val EXPECTED_TRACES_SYSUI_FIRST =
-            listOf(
-                "${getSystemUiUidName()}_0.vc__view_capture_trace.winscope",
-                "${getLauncherPackageName()}_1.vc__view_capture_trace.winscope",
-            )
-    }
-}
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/wm/WindowManagerTraceMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/wm/WindowManagerTraceMonitorTest.kt
index 9d9eaa222..f769c8de6 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/wm/WindowManagerTraceMonitorTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/wm/WindowManagerTraceMonitorTest.kt
@@ -54,21 +54,6 @@ class WindowManagerTraceMonitorTest : TraceMonitorTest<WindowManagerTraceMonitor
         Assume.assumeFalse(android.tracing.Flags.perfettoWmTracing())
     }
 
-    @Test
-    fun includesProtologTrace() {
-        Assume.assumeFalse(android.tracing.Flags.perfettoProtologTracing())
-
-        val monitor = getMonitor()
-        monitor.start()
-        val writer = newTestResultWriter()
-        monitor.stop(writer)
-        val result = writer.write()
-        val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
-        Truth.assertWithMessage("Trace file exists ${TraceType.PROTOLOG.fileName}")
-            .that(reader.hasTraceFile(TraceType.PROTOLOG))
-            .isTrue()
-    }
-
     companion object {
         @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
     }
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
index 09999eec0..5a7e659b9 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
@@ -51,7 +51,7 @@ import org.junit.runners.MethodSorters
 
 /**
  * Contains [WindowManagerStateHelper] tests. To run this test: `atest
- * FlickerLibTest:WindowManagerTraceHelperTest`
+ * FlickerLibTest:WindowManagerStateHelperTest`
  */
 @SuppressLint("VisibleForTests")
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt
deleted file mode 100644
index 0ca8bf192..000000000
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.parsers.wm
-
-import android.app.Instrumentation
-import android.tools.Cache
-import android.tools.device.apphelpers.MessagingAppHelper
-import android.tools.testutils.CleanFlickerEnvironmentRule
-import android.tools.testutils.readAsset
-import android.tools.traces.SERVICE_TRACE_CONFIG
-import android.tools.traces.io.ResultReader
-import android.tools.traces.monitors.wm.LegacyShellTransitionTraceMonitor
-import android.tools.traces.parsers.wm.ShellTransitionTraceParser
-import android.tracing.Flags
-import androidx.test.filters.FlakyTest
-import androidx.test.platform.app.InstrumentationRegistry
-import com.android.launcher3.tapl.LauncherInstrumentation
-import com.google.common.truth.Truth
-import org.junit.Assume.assumeFalse
-import org.junit.Before
-import org.junit.ClassRule
-import org.junit.Test
-
-/** Tests for [WindowManagerTraceParser] */
-class LegacyShellLegacyTransitionTraceParserTest {
-    @Before
-    fun before() {
-        assumeFalse(Flags.perfettoTransitionTracing())
-        Cache.clear()
-    }
-
-    @Test
-    fun canParseAllEntriesFromStoredTrace() {
-        val trace =
-            ShellTransitionTraceParser()
-                .parse(readAsset("shell_transition_trace.winscope"), clearCache = false)
-        val firstEntry = trace.entries.first()
-        val lastEntry = trace.entries.last()
-        Truth.assertThat(firstEntry.timestamp.elapsedNanos).isEqualTo(760760231809L)
-        Truth.assertThat(lastEntry.timestamp.elapsedNanos).isEqualTo(2770678425968L)
-    }
-
-    @FlakyTest(bugId = 318834436)
-    @Test
-    fun canParseAllEntriesFromNewTrace() {
-        val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
-        val tapl = LauncherInstrumentation()
-        val reader =
-            LegacyShellTransitionTraceMonitor().withTracing(
-                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
-            ) {
-                MessagingAppHelper(instrumentation).open()
-                tapl.goHome().switchToAllApps()
-                tapl.goHome()
-            }
-        val trace = reader.readTransitionsTrace()
-        Truth.assertThat(trace?.entries).isNotEmpty()
-    }
-
-    companion object {
-        @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
-    }
-}
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt
deleted file mode 100644
index 92ad56e62..000000000
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.parsers.wm
-
-import android.tools.Cache
-import android.tools.testutils.CleanFlickerEnvironmentRule
-import android.tools.testutils.readAsset
-import android.tools.traces.parsers.perfetto.TraceProcessorSession
-import android.tools.traces.parsers.perfetto.TransitionsTraceParser
-import android.tools.traces.parsers.wm.LegacyTransitionTraceParser
-import com.google.common.truth.Truth
-import org.junit.Before
-import org.junit.ClassRule
-import org.junit.Test
-
-class LegacyTransitionTraceParserTest {
-    @Before
-    fun before() {
-        Cache.clear()
-    }
-
-    @Test
-    fun canParseAllEntriesFromLegacyStoredTrace() {
-        val trace =
-            LegacyTransitionTraceParser()
-                .parse(
-                    wmSideTraceData = readAsset("wm_transition_trace.winscope"),
-                    shellSideTraceData = readAsset("shell_transition_trace.winscope"),
-                )
-        val firstEntry = trace.entries.first()
-        Truth.assertThat(firstEntry.timestamp.elapsedNanos).isEqualTo(760760231809L)
-        Truth.assertThat(firstEntry.id).isEqualTo(9)
-
-        val lastEntry = trace.entries.last()
-        Truth.assertThat(lastEntry.timestamp.elapsedNanos).isEqualTo(2770105426934L)
-    }
-
-    @Test
-    fun canParseAllEntriesFromStoredTrace() {
-        val trace =
-            TraceProcessorSession.loadPerfettoTrace(readAsset("transitions.perfetto-trace")) {
-                session ->
-                TransitionsTraceParser().parse(session)
-            }
-        Truth.assertWithMessage("Trace").that(trace.entries).isNotEmpty()
-        Truth.assertWithMessage("Trace contains entry")
-            .that(trace.entries.map { it.id })
-            .contains(35)
-    }
-
-    companion object {
-        @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
-    }
-}
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt
deleted file mode 100644
index 3d6d0e30d..000000000
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.tools.parsers.wm
-
-import android.app.Instrumentation
-import android.tools.Cache
-import android.tools.device.apphelpers.BrowserAppHelper
-import android.tools.testutils.CleanFlickerEnvironmentRule
-import android.tools.testutils.readAsset
-import android.tools.traces.SERVICE_TRACE_CONFIG
-import android.tools.traces.io.ResultReader
-import android.tools.traces.monitors.wm.LegacyWmTransitionTraceMonitor
-import android.tools.traces.parsers.wm.WmTransitionTraceParser
-import android.tracing.Flags
-import androidx.test.platform.app.InstrumentationRegistry
-import com.android.launcher3.tapl.LauncherInstrumentation
-import com.google.common.truth.Truth
-import org.junit.Assume.assumeFalse
-import org.junit.Before
-import org.junit.ClassRule
-import org.junit.Test
-
-/** Tests for [WindowManagerTraceParser] */
-class LegacyWmLegacyTransitionTraceParserTest {
-    @Before
-    fun before() {
-        assumeFalse(Flags.perfettoTransitionTracing())
-        Cache.clear()
-    }
-
-    @Test
-    fun canParseAllEntriesFromStoredTrace() {
-        val trace =
-            WmTransitionTraceParser()
-                .parse(readAsset("wm_transition_trace.winscope"), clearCache = false)
-        val firstEntry = trace.entries.first()
-        val lastEntry = trace.entries.last()
-        Truth.assertThat(firstEntry.timestamp.elapsedNanos).isEqualTo(2750430124061L)
-        Truth.assertThat(lastEntry.timestamp.elapsedNanos).isEqualTo(2770105426934L)
-    }
-
-    @Test
-    fun canParseAllEntriesFromNewTrace() {
-        val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
-        val tapl = LauncherInstrumentation()
-        val reader =
-            LegacyWmTransitionTraceMonitor().withTracing(
-                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
-            ) {
-                BrowserAppHelper(instrumentation).open()
-                tapl.goHome().switchToAllApps()
-                tapl.goHome()
-            }
-        val trace = reader.readTransitionsTrace()
-        Truth.assertThat(trace?.entries).isNotEmpty()
-    }
-
-    companion object {
-        @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
-    }
-}
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/TransitionsTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/TransitionsTraceParserTest.kt
index af20edce4..0fcf81ac2 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/TransitionsTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/wm/TransitionsTraceParserTest.kt
@@ -17,12 +17,17 @@
 package android.tools.parsers.wm
 
 import android.tools.Cache
+import android.tools.Timestamp
+import android.tools.Timestamps
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.readAsset
+import android.tools.traces.parsers.perfetto.Row
 import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.TransitionsTraceParser
+import android.tools.traces.wm.ShellTransitionData
+import android.tools.traces.wm.Transition
+import android.tools.traces.wm.WmTransitionData
 import com.google.common.truth.Truth
-import org.junit.Assume
 import org.junit.Before
 import org.junit.ClassRule
 import org.junit.Test
@@ -31,7 +36,6 @@ import org.junit.Test
 class TransitionsTraceParserTest {
     @Before
     fun before() {
-        Assume.assumeTrue(android.tracing.Flags.perfettoTransitionTracing())
         Cache.clear()
     }
 
@@ -64,6 +68,148 @@ class TransitionsTraceParserTest {
         }
     }
 
+    @Test
+    fun filtersTransitionWithDispatchTimeBeforeFrom() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                dispatchTime = Timestamps.from(elapsedNanos = 99), // Before 'from'
+                finishTime = Timestamps.from(elapsedNanos = 150),
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun filtersTransitionWithSendTimeBeforeFrom() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                sendTime = Timestamps.from(elapsedNanos = 99), // Before 'from'
+                finishTime = Timestamps.from(elapsedNanos = 150),
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun filtersTransitionWithFinishTimeAfterTo() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                dispatchTime = Timestamps.from(elapsedNanos = 110),
+                finishTime = Timestamps.from(elapsedNanos = 201), // After 'to'
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun filtersTransitionWithWmAbortTimeAfterTo() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                dispatchTime = Timestamps.from(elapsedNanos = 110),
+                wmAbortTime = Timestamps.from(elapsedNanos = 201), // After 'to'
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun filtersTransitionWithShellAbortTimeAfterTo() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                dispatchTime = Timestamps.from(elapsedNanos = 110),
+                shellAbortTime = Timestamps.from(elapsedNanos = 201), // After 'to'
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun filtersTransitionWithMergeTimeAfterTo() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition =
+            createMockTransition(
+                id = 1,
+                dispatchTime = Timestamps.from(elapsedNanos = 110),
+                mergeTime = Timestamps.from(elapsedNanos = 201), // After 'to'
+            )
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).isEmpty()
+    }
+
+    @Test
+    fun includesValidTransition() {
+        val from = Timestamps.from(elapsedNanos = 100)
+        val to = Timestamps.from(elapsedNanos = 200)
+        val transition = createMockTransition(id = 1, dispatchTime = from, finishTime = to)
+        val parser = MockableTransitionsTraceParser(listOf(transition))
+        val trace = parser.parse(MockTraceProcessorSession(), from, to)
+        Truth.assertThat(trace.entries).containsExactly(transition)
+    }
+
+    private class MockTraceProcessorSession : TraceProcessorSession {
+        override fun <T> query(sql: String, predicate: (List<Row>) -> T): T {
+            // Not used in tests
+            error("Not implemented")
+        }
+    }
+
+    // Simple mock implementation for testing purposes
+    private class MockableTransitionsTraceParser(private val mockEntries: List<Transition>) :
+        TransitionsTraceParser() {
+        // Override getEntries to return the mocked list directly
+        override fun getEntries(input: TraceProcessorSession): List<Transition> {
+            return mockEntries
+        }
+    }
+
+    private fun createMockTransition(
+        id: Int,
+        sendTime: Timestamp? = null,
+        dispatchTime: Timestamp? = null,
+        finishTime: Timestamp? = null,
+        wmAbortTime: Timestamp? = null,
+        shellAbortTime: Timestamp? = null,
+        mergeTime: Timestamp? = null,
+    ): Transition {
+        return Transition(
+            id = id,
+            wmData =
+                WmTransitionData(
+                    sendTime = sendTime,
+                    finishTime = finishTime,
+                    abortTime = wmAbortTime,
+                ),
+            shellData =
+                ShellTransitionData(
+                    dispatchTime = dispatchTime,
+                    abortTime = shellAbortTime,
+                    mergeTime = mergeTime,
+                ),
+        )
+    }
+
     companion object {
         @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
     }
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt b/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
index 2e57e5027..9f61c79ac 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
@@ -101,11 +101,7 @@ object TestTraces {
         val START_TIME =
             Timestamps.from(elapsedNanos = 479583450794, systemUptimeNanos = 0, unixNanos = 0)
         val VALID_SLICE_TIME =
-            Timestamps.from(
-                elapsedNanos = 479583450794 + 5000,
-                systemUptimeNanos = 0,
-                unixNanos = 0,
-            )
+            Timestamps.from(elapsedNanos = 480124777862, systemUptimeNanos = 0, unixNanos = 0)
         val INVALID_SLICE_TIME =
             Timestamps.from(elapsedNanos = 487330863192 + 1, systemUptimeNanos = 0, unixNanos = 0)
         val END_TIME =
diff --git a/libraries/health/OWNERS b/libraries/health/OWNERS
index b543fff68..e5df37955 100644
--- a/libraries/health/OWNERS
+++ b/libraries/health/OWNERS
@@ -1,11 +1,9 @@
 # If direct review needed.
 gelanchezhian@google.com
 harrytczhang@google.com
-jwg@google.com
 mrosenfeld@google.com
 allisonmt@google.com
 
 # Don't send reviews here.
 guangzhu@google.com
 jdesprez@google.com
-jwg@google.com
diff --git a/libraries/health/composers/OWNERS b/libraries/health/composers/OWNERS
index 44741843a..90fde4e5e 100644
--- a/libraries/health/composers/OWNERS
+++ b/libraries/health/composers/OWNERS
@@ -9,4 +9,3 @@ mrosenfeld@google.com
 # Don't send reviews here.
 guangzhu@google.com
 jdesprez@google.com
-jwg@google.com
diff --git a/libraries/health/rules/Android.bp b/libraries/health/rules/Android.bp
index 1bfa4cbe3..7f50408f6 100644
--- a/libraries/health/rules/Android.bp
+++ b/libraries/health/rules/Android.bp
@@ -56,9 +56,11 @@ java_library {
         "junit",
         "androidx.test.runner",
         "kotlin-reflect",
+        "launcher-aosp-tapl",
     ],
     srcs: [
         "src/android/platform/test/rule/AnnotationUtils.kt",
+        "src/android/platform/test/rule/ExtendedLongPressTimeoutRule.kt",
         "src/android/platform/test/rule/LimitDevicesRule.kt",
         "src/android/platform/test/rule/TestAnnotationScanner.kt",
     ],
diff --git a/libraries/health/rules/OWNERS b/libraries/health/rules/OWNERS
index b0777be72..8639a0e7f 100644
--- a/libraries/health/rules/OWNERS
+++ b/libraries/health/rules/OWNERS
@@ -9,7 +9,6 @@ mrosenfeld@google.com
 # Don't send reviews here.
 guangzhu@google.com
 jdesprez@google.com
-jwg@google.com
 dupin@google.com
 pixel@google.com
 nicomazz@google.com
diff --git a/libraries/health/rules/src/android/platform/test/rule/AutoRotationSettingRule.kt b/libraries/health/rules/src/android/platform/test/rule/AutoRotationSettingRule.kt
index 73b19ce91..462d89b71 100644
--- a/libraries/health/rules/src/android/platform/test/rule/AutoRotationSettingRule.kt
+++ b/libraries/health/rules/src/android/platform/test/rule/AutoRotationSettingRule.kt
@@ -12,5 +12,7 @@ class AutoRotationSettingRule(enabled: Boolean? = null) :
         initialValue = enabled,
     ) {
 
+    fun setEnabled(enabled: Boolean) = setSettingValue(enabled)
+
     fun isEnabled() = getSettingValue<Boolean>()
 }
diff --git a/libraries/health/rules/src/android/platform/test/rule/BitmapOutputCounterRule.kt b/libraries/health/rules/src/android/platform/test/rule/BitmapOutputCounterRule.kt
new file mode 100644
index 000000000..03cca909e
--- /dev/null
+++ b/libraries/health/rules/src/android/platform/test/rule/BitmapOutputCounterRule.kt
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.rule
+
+import android.graphics.Bitmap
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * This rule will allocate a dummy Bitmap before a test starts to emit the Bitmap counter metric in
+ * the perfetto traces.
+ */
+class BitmapOutputCounterRule : TestRule {
+
+    override fun apply(base: Statement, description: Description): Statement {
+        Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8)
+        return base
+    }
+}
diff --git a/libraries/health/rules/src/android/platform/test/rule/ChromeOpenTabsRule.java b/libraries/health/rules/src/android/platform/test/rule/ChromeOpenTabsRule.java
index bbddfd1f2..df8fb630c 100644
--- a/libraries/health/rules/src/android/platform/test/rule/ChromeOpenTabsRule.java
+++ b/libraries/health/rules/src/android/platform/test/rule/ChromeOpenTabsRule.java
@@ -28,30 +28,21 @@ import org.junit.runner.Description;
 public class ChromeOpenTabsRule extends TestWatcher {
 
     @VisibleForTesting static final String CHROME_TABS_COUNT = "tabs-count";
-    int tabsCount = 2;
-
-    @VisibleForTesting static final String CHROME_LINKS = "chrome-links";
-    String link = "https://www.google.com";
 
     private static HelperAccessor<IChromeHelper> sChomeHelper =
             new HelperAccessor<>(IChromeHelper.class);
 
     @Override
     protected void starting(Description description) {
-        link = getArguments().getString(CHROME_LINKS, "https://www.google.com");
-        tabsCount = Integer.valueOf(getArguments().getString(CHROME_TABS_COUNT, "2"));
-        int initialTabCount = tabsCount;
-        String[] links = link.split(",", tabsCount);
+        int tabsCounts = Integer.valueOf(getArguments().getString(CHROME_TABS_COUNT, "2"));
+        String link = "https://www.google.com";
 
         sChomeHelper.get().open();
-        for (int i = 0; i < tabsCount; i++) {
-            for (int j = 0; j < links.length; j++) {
-                sChomeHelper.get().addNewTab(links[j]);
-                SystemClock.sleep(3000);
-                tabsCount--;
-            }
+        for (int i = 0; i < tabsCounts; i++) {
+            sChomeHelper.get().addNewTab(link);
+            SystemClock.sleep(3000);
         }
-        sChomeHelper.get().tabsCount(initialTabCount);
+        sChomeHelper.get().tabsCount(tabsCounts + 1);
         sChomeHelper.get().exit();
     }
 
diff --git a/libraries/health/rules/src/android/platform/test/rule/EnsureDeviceSettingsRule.kt b/libraries/health/rules/src/android/platform/test/rule/EnsureDeviceSettingsRule.kt
index 866de41fd..e432d5a5a 100644
--- a/libraries/health/rules/src/android/platform/test/rule/EnsureDeviceSettingsRule.kt
+++ b/libraries/health/rules/src/android/platform/test/rule/EnsureDeviceSettingsRule.kt
@@ -42,6 +42,8 @@ class EnsureDeviceSettingsRule : TestWatcher() {
                     description = "Test harness' mode is required but disabled.",
                     adbCommandToFixIt =
                         "adb shell setprop $TEST_HARNESS_PROP 1; " +
+                            // Prevents device from rebooting when it has no adb in test harness
+                            "adb shell setprop persist.adb.watchdog.timeout_secs 0; " +
                             "adb shell am force-stop $LAUNCHER_PACKAGE",
                 )
             )
diff --git a/libraries/health/rules/src/android/platform/test/rule/ExtendedLongPressTimeoutRule.kt b/libraries/health/rules/src/android/platform/test/rule/ExtendedLongPressTimeoutRule.kt
new file mode 100644
index 000000000..5e39093eb
--- /dev/null
+++ b/libraries/health/rules/src/android/platform/test/rule/ExtendedLongPressTimeoutRule.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.rule
+
+import android.Manifest
+import android.provider.Settings
+import android.util.Log
+import android.view.ViewConfiguration
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.launcher3.testing.BuildConfig
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * Increases the device's long-press timeout to reduce flakiness in slow-running devices.
+ *
+ * <p>
+ * When running TAPL tests remotely in pre- and post-submit tests, the test devices (eg. cf builds)
+ * lack the resources for responsive test execution. This can cause a swipe gesture to be
+ * interpreted as a long press, which leads to flakiness.
+ *
+ * <p>
+ * Since this is not as much of an issue when running tests locally in studio, the long press
+ * timeout doesn't need to be overwritten. Additionally, if the test is cancelled manually
+ * mid-execution, the clean up will not run leaving the long press timeout overwritten.
+ */
+class ExtendedLongPressTimeoutRule : TestRule {
+
+    private val TAG = "ExtendedLongPressTimeoutRule"
+
+    private val temporaryLongPressTimeoutMs = 5000
+
+    override fun apply(base: Statement, description: Description): Statement {
+        // No-op when running in studio to prevent accidental overwrite
+        return if (BuildConfig.IS_STUDIO_BUILD) base
+        else
+            object : Statement() {
+                @Throws(Throwable::class)
+                override fun evaluate() {
+                    val contentResolver =
+                        InstrumentationRegistry.getInstrumentation().context.contentResolver
+                    val originalLongPressTimeout =
+                        Settings.Secure.getInt(
+                            contentResolver,
+                            Settings.Secure.LONG_PRESS_TIMEOUT,
+                            ViewConfiguration.getLongPressTimeout(),
+                        )
+
+                    try {
+                        Log.d(
+                            TAG,
+                            "In try-block: Setting long press timeout from " +
+                                "${originalLongPressTimeout}ms to " +
+                                "${temporaryLongPressTimeoutMs}ms",
+                        )
+                        grantWriteSecurePermission()
+                        Settings.Secure.putInt(
+                            contentResolver,
+                            Settings.Secure.LONG_PRESS_TIMEOUT,
+                            temporaryLongPressTimeoutMs,
+                        )
+
+                        base.evaluate()
+                    } catch (e: Exception) {
+                        Log.e(TAG, "Error", e)
+                        throw e
+                    } finally {
+                        Log.d(
+                            TAG,
+                            "In finally-block: resetting long press timeout to " +
+                                "${originalLongPressTimeout}ms",
+                        )
+                        grantWriteSecurePermission()
+                        Settings.Secure.putInt(
+                            contentResolver,
+                            Settings.Secure.LONG_PRESS_TIMEOUT,
+                            originalLongPressTimeout,
+                        )
+                    }
+                }
+            }
+    }
+
+    private fun grantWriteSecurePermission() {
+        InstrumentationRegistry.getInstrumentation()
+            .uiAutomation
+            .adoptShellPermissionIdentity(Manifest.permission.WRITE_SECURE_SETTINGS)
+    }
+}
diff --git a/libraries/health/rules/src/android/platform/test/rule/SetWallpaperRule.kt b/libraries/health/rules/src/android/platform/test/rule/SetWallpaperRule.kt
new file mode 100644
index 000000000..6d1b41ce9
--- /dev/null
+++ b/libraries/health/rules/src/android/platform/test/rule/SetWallpaperRule.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.rule
+
+import android.app.WallpaperManager
+import android.content.ComponentName
+import android.service.wallpaper.WallpaperService
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.runner.Description
+
+/**
+ * Sets system wallpaper to the specified WallpaperService and resets it after the test
+ */
+class SetWallpaperRule<T : WallpaperService>(wallpaperServiceClass: Class<T>) : TestWatcher() {
+
+    private val instrumentation = InstrumentationRegistry.getInstrumentation()
+    private val wallpaperManager =
+        instrumentation.context.getSystemService(WallpaperManager::class.java)
+    private val wallpaperComponentName =
+        ComponentName(instrumentation.context, wallpaperServiceClass)
+
+    override fun starting(description: Description?) {
+        wallpaperManager.setWallpaperComponent(wallpaperComponentName)
+    }
+
+    override fun finished(description: Description?) {
+        wallpaperManager.clearWallpaper()
+    }
+}
+
+inline fun <reified T : WallpaperService> setWallpaperRule(): SetWallpaperRule<T> =
+    SetWallpaperRule(T::class.java)
\ No newline at end of file
diff --git a/libraries/motion/OWNERS b/libraries/motion/OWNERS
index 9e4d6923b..3a75896a0 100644
--- a/libraries/motion/OWNERS
+++ b/libraries/motion/OWNERS
@@ -1,4 +1,5 @@
 # Owners for /libraries/motion
 
 michschn@google.com
-saff@google.com
\ No newline at end of file
+saff@google.com
+sandeepsuman@google.com
diff --git a/libraries/motion/compose/AndroidManifest.xml b/libraries/motion/compose/AndroidManifest.xml
index 70049458b..134011d98 100644
--- a/libraries/motion/compose/AndroidManifest.xml
+++ b/libraries/motion/compose/AndroidManifest.xml
@@ -16,7 +16,15 @@
   -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="platform.test.motion.compose">
 
-  <application><activity android:name="androidx.activity.ComponentActivity" /></application>
+  <application>
+    <activity
+        android:name="androidx.activity.ComponentActivity"
+        android:exported="true"
+        android:theme="@android:style/Theme.Material.Light.NoActionBar"
+        tools:replace="android:theme"
+        />
+  </application>
 </manifest>
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/ComposeFeatureCaptures.kt b/libraries/motion/compose/src/platform/test/motion/compose/ComposeFeatureCaptures.kt
index 331403279..d3e8d2446 100644
--- a/libraries/motion/compose/src/platform/test/motion/compose/ComposeFeatureCaptures.kt
+++ b/libraries/motion/compose/src/platform/test/motion/compose/ComposeFeatureCaptures.kt
@@ -69,10 +69,11 @@ fun TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.feature(
     matcher: SemanticsMatcher,
     capture: FeatureCapture<SemanticsNode, *>,
     name: String = capture.name,
+    useUnmergedTree: Boolean = false
 ) {
     on({
         try {
-            it.onNode(matcher).fetchSemanticsNode()
+            it.onNode(matcher, useUnmergedTree = useUnmergedTree).fetchSemanticsNode()
         } catch (e: AssertionError) {
             null
         }
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt b/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
index dbca5ad3f..b424ddfe9 100644
--- a/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
+++ b/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
@@ -25,10 +25,10 @@ import androidx.compose.ui.unit.DpSize
 import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.IntSize
 import androidx.compose.ui.unit.dp
-import java.lang.reflect.Array.getDouble
 import org.json.JSONObject
 import platform.test.motion.golden.DataPointType
 import platform.test.motion.golden.UnknownTypeException
+import platform.test.motion.isApproximatelyEqualTo
 
 fun Dp.asDataPoint() = DataPointTypes.dp.makeDataPoint(this)
 
@@ -54,6 +54,9 @@ object DataPointTypes {
                 }
             },
             valueToJson = { it.value },
+            isApproximateEqual = { actual, expected ->
+                actual.value.isApproximatelyEqualTo(expected.value)
+            }
         )
 
     val intSize: DataPointType<IntSize> =
@@ -85,7 +88,7 @@ object DataPointTypes {
                     put("x", it.x)
                     put("y", it.y)
                 }
-            },
+            }
         )
 
     val dpSize: DataPointType<DpSize> =
@@ -102,6 +105,10 @@ object DataPointTypes {
                     put("height", it.height.value)
                 }
             },
+             isApproximateEqual = { actual, expected ->
+                 actual.width.value.isApproximatelyEqualTo(expected.width.value) &&
+                 actual.height.value.isApproximatelyEqualTo(expected.height.value)
+            }
         )
 
     val dpOffset: DataPointType<DpOffset> =
@@ -118,6 +125,10 @@ object DataPointTypes {
                     put("y", it.y.value)
                 }
             },
+            isApproximateEqual = { actual, expected ->
+                actual.x.value.isApproximatelyEqualTo(expected.x.value) &&
+                        actual.y.value.isApproximatelyEqualTo(expected.y.value)
+            }
         )
 
     val offset: DataPointType<Offset> =
@@ -143,5 +154,14 @@ object DataPointTypes {
                         }
                 }
             },
+            isApproximateEqual = { actual, expected ->
+                when(expected){
+                    Offset.Unspecified -> actual == Offset.Unspecified
+                    Offset.Infinite -> actual == Offset.Infinite
+                    Offset.Zero -> actual.x.isApproximatelyEqualTo(0f) && actual.y.isApproximatelyEqualTo(0f)
+                    else -> actual.x.isApproximatelyEqualTo(expected.x)
+                            && actual.y.isApproximatelyEqualTo(expected.y)
+                }
+            }
         )
 }
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/RunMonotonicClockTest.kt b/libraries/motion/compose/src/platform/test/motion/compose/RunMonotonicClockTest.kt
new file mode 100644
index 000000000..62dc5e50a
--- /dev/null
+++ b/libraries/motion/compose/src/platform/test/motion/compose/RunMonotonicClockTest.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion.compose
+
+import androidx.compose.ui.test.ExperimentalTestApi
+import androidx.compose.ui.test.TestMonotonicFrameClock
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.test.TestCoroutineScheduler
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.runTest
+import kotlinx.coroutines.withContext
+
+/**
+ * This method creates a [CoroutineScope] that can be used in animations created in a composable
+ * function.
+ *
+ * The [TestCoroutineScheduler] is passed to provide the functionality to wait for idle.
+ *
+ * Note: Please refer to the documentation for [runTest], as this feature utilizes it. This will
+ * provide a comprehensive understanding of all its behaviors.
+ */
+@OptIn(ExperimentalTestApi::class)
+fun runMonotonicClockTest(block: suspend MonotonicClockTestScope.() -> Unit) = runTest {
+    val testScope: TestScope = this
+
+    withContext(TestMonotonicFrameClock(coroutineScope = testScope)) {
+        val testScopeWithMonotonicFrameClock: CoroutineScope = this
+
+        val scope =
+            MonotonicClockTestScope(
+                testScope = testScopeWithMonotonicFrameClock,
+                testScheduler = testScope.testScheduler,
+                backgroundScope = backgroundScope,
+            )
+
+        // Run the test
+        scope.block()
+    }
+}
+
+/**
+ * A coroutine scope that for launching test coroutines for Compose.
+ *
+ * @param testScheduler The delay-skipping scheduler used by the test dispatchers running the code
+ *   in this scope (see [TestScope.testScheduler]).
+ * @param backgroundScope A scope for background work (see [TestScope.backgroundScope]).
+ */
+class MonotonicClockTestScope(
+    testScope: CoroutineScope,
+    val testScheduler: TestCoroutineScheduler,
+    val backgroundScope: CoroutineScope,
+) : CoroutineScope by testScope
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
index 12204236e..d6534e531 100644
--- a/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
@@ -55,7 +55,6 @@ import androidx.compose.ui.unit.dp
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.google.common.truth.IterableSubject
 import com.google.common.truth.Truth.assertThat
-import kotlin.time.Duration.Companion.milliseconds
 import kotlinx.coroutines.launch
 import org.junit.Rule
 import org.junit.Test
@@ -69,6 +68,7 @@ import platform.test.motion.golden.DataPointTypes
 import platform.test.motion.golden.NotFoundDataPoint
 import platform.test.motion.golden.ValueDataPoint
 import platform.test.motion.testing.createGoldenPathManager
+import kotlin.time.Duration.Companion.milliseconds
 
 @RunWith(AndroidJUnit4::class)
 class ComposeToolkitTest {
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/values/MotionTestValueTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/values/MotionTestValueTest.kt
index 8d398ecdf..b2218a969 100644
--- a/libraries/motion/compose/tests/src/platform/test/motion/compose/values/MotionTestValueTest.kt
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/values/MotionTestValueTest.kt
@@ -16,10 +16,10 @@
 
 package platform.test.motion.compose.values
 
+import androidx.compose.foundation.layout.Box
 import androidx.compose.material3.Text
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.setValue
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.test.SemanticsMatcher
 import androidx.compose.ui.test.junit4.createComposeRule
 import androidx.compose.ui.test.onNodeWithText
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -55,6 +55,17 @@ class MotionTestValueTest {
         assertThat(semanticsNode.config[foo.semanticsPropertyKey]).isEqualTo(1f)
     }
 
+    @Test
+    fun modifier_whenDisabled_doesNotEvenCreateSemanticNode() {
+        composeRule.setContent { Box(Modifier.motionTestValues { fail() }) }
+
+        val allNodes =
+            composeRule.onAllNodes(SemanticsMatcher("everything") { true }).fetchSemanticsNodes()
+
+        assertThat(allNodes).hasSize(1)
+        assertThat(allNodes.first().isRoot).isTrue()
+    }
+
     companion object {
         val foo = MotionTestValueKey<Float>("foo")
     }
diff --git a/libraries/motion/compose/values/src/platform/test/motion/compose/values/MotionTestValue.kt b/libraries/motion/compose/values/src/platform/test/motion/compose/values/MotionTestValue.kt
index f862876c9..17e10b393 100644
--- a/libraries/motion/compose/values/src/platform/test/motion/compose/values/MotionTestValue.kt
+++ b/libraries/motion/compose/values/src/platform/test/motion/compose/values/MotionTestValue.kt
@@ -16,12 +16,15 @@
 
 package platform.test.motion.compose.values
 
+import android.annotation.SuppressLint
 import androidx.compose.runtime.Stable
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.node.CompositionLocalConsumerModifierNode
+import androidx.compose.ui.node.DelegatingNode
 import androidx.compose.ui.node.ModifierNodeElement
 import androidx.compose.ui.node.SemanticsModifierNode
 import androidx.compose.ui.node.currentValueOf
+import androidx.compose.ui.node.invalidateSemantics
 import androidx.compose.ui.platform.InspectorInfo
 import androidx.compose.ui.semantics.SemanticsPropertyKey
 import androidx.compose.ui.semantics.SemanticsPropertyReceiver
@@ -68,7 +71,7 @@ private data class MotionTestValuesElement(val values: MotionTestValueScope.() -
     }
 
     override fun update(node: MotionTestValuesNode) {
-        node.values = values
+        node.update(values)
     }
 
     override fun InspectorInfo.inspectableProperties() {
@@ -76,18 +79,40 @@ private data class MotionTestValuesElement(val values: MotionTestValueScope.() -
     }
 }
 
-private class MotionTestValuesNode(var values: MotionTestValueScope.() -> Unit) :
-    Modifier.Node(), SemanticsModifierNode, CompositionLocalConsumerModifierNode {
+private class MotionTestValuesNode(private var values: MotionTestValueScope.() -> Unit) :
+    DelegatingNode(), CompositionLocalConsumerModifierNode {
 
-    override fun SemanticsPropertyReceiver.applySemantics() {
+    fun update(updated: MotionTestValueScope.() -> Unit) {
+        if (values !== updated) {
+            values = updated
+            delegateProvideNode?.values = updated
+            delegateProvideNode?.invalidateSemantics()
+        }
+    }
+
+    var delegateProvideNode: MotionTestValuesProviderNode? = null
+
+    override fun onAttach() {
+        // MotionTest set LocalEnableMotionTestValueCollection only during setup, never updated.
+        // For simplicity, reading the state only during onAttach, as the "correct" solution of
+        // observing changes would not provide any benefits.
+        @SuppressLint("SuspiciousCompositionLocalModifierRead")
         if (currentValueOf(LocalEnableMotionTestValueCollection)) {
-            values.invoke(
-                object : MotionTestValueScope {
-                    override fun <T> T.exportAs(key: MotionTestValueKey<T>) {
-                        this@applySemantics[key.semanticsPropertyKey] = this
-                    }
-                }
-            )
+            delegateProvideNode = delegate(MotionTestValuesProviderNode(values))
         }
     }
 }
+
+private class MotionTestValuesProviderNode(var values: MotionTestValueScope.() -> Unit) :
+    Modifier.Node(), SemanticsModifierNode {
+
+    override fun SemanticsPropertyReceiver.applySemantics() {
+        values.invoke(
+            object : MotionTestValueScope {
+                override fun <T> T.exportAs(key: MotionTestValueKey<T>) {
+                    this@applySemantics[key.semanticsPropertyKey] = this
+                }
+            }
+        )
+    }
+}
diff --git a/libraries/motion/golden_updater/Android.bp b/libraries/motion/golden_updater/Android.bp
new file mode 100644
index 000000000..d54120bb4
--- /dev/null
+++ b/libraries/motion/golden_updater/Android.bp
@@ -0,0 +1,26 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+python_test_host {
+    name: "golden_updater_test",
+    main: "watch_local_tests_test.py",
+    srcs: [
+        "watch_local_tests_test.py",
+    ],
+    test_suites: ["general-tests"],
+    test_options: {
+        unit_test: false,
+    },
+}
diff --git a/libraries/motion/golden_updater/impl/__init__.py b/libraries/motion/golden_updater/impl/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/libraries/motion/golden_updater/impl/adb_client.py b/libraries/motion/golden_updater/impl/adb_client.py
new file mode 100644
index 000000000..ff0713b79
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/adb_client.py
@@ -0,0 +1,44 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import subprocess
+
+class AdbClient:
+    def __init__(self, adb_serial, subprocess_run_func = subprocess.run):
+        self.adb_serial = adb_serial
+        self.subprocess_run = subprocess_run_func
+
+    def run_as_root(self):
+        root_result = self.run_adb_command(["root"])
+        if "restarting adbd as root" in root_result:
+            self.wait_for_device()
+            return True
+        if "adbd is already running as root" in root_result:
+            return True
+
+        print(f"run_as_root returned [{root_result}]")
+
+        return False
+
+    def wait_for_device(self):
+        self.run_adb_command(["wait-for-device"])
+
+    def run_adb_command(self, args):
+        command = ["adb"]
+        command += ["-s", self.adb_serial]
+        command += args
+        return self.subprocess_run(command, check=True, capture_output=True).stdout.decode(
+            "utf-8"
+        )
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/argument_parser.py b/libraries/motion/golden_updater/impl/argument_parser.py
new file mode 100644
index 000000000..25e6b6f77
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/argument_parser.py
@@ -0,0 +1,65 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import argparse
+import os
+from impl.port_finder import PortFinder
+
+class ArgumentParser:
+
+    @staticmethod
+    def get_args():
+        parser = argparse.ArgumentParser(
+            "Watches a connected device for golden file updates."
+        )
+
+        parser.add_argument(
+            "--port",
+            default = PortFinder.find_free_port(),
+            type=int,
+            help="Port to run test at watcher web UI on.",
+        )
+
+        parser.add_argument(
+            "--atest",
+            default=False,
+            help="Watches atest output",
+        )
+
+        parser.add_argument(
+            "--robolectricTest",
+            default=False,
+            help="Watch for artifacs generated when a deviceless test is run via SysUi Studio",
+        )
+
+        parser.add_argument(
+            "--serial",
+            default=os.environ.get("ANDROID_SERIAL"),
+            help="The ADB device serial to pull goldens from.",
+        )
+
+        parser.add_argument(
+            "--android_build_top",
+            default=os.environ.get("ANDROID_BUILD_TOP"),
+            help="The root directory of the android checkout.",
+        )
+
+        parser.add_argument(
+            "--client_url",
+            default="http://motion.teams.x20web.corp.google.com/",
+            help="The URL where the client app is deployed.",
+        )
+
+        return parser.parse_args()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/cached_golden.py b/libraries/motion/golden_updater/impl/cached_golden.py
new file mode 100644
index 000000000..446e442fa
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/cached_golden.py
@@ -0,0 +1,49 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import hashlib
+import datetime
+import json
+
+class CachedGolden:
+
+    def __init__(self, remote_file, local_file):
+        self.id = hashlib.md5(remote_file.encode("utf-8")).hexdigest()
+        self.remote_file = remote_file
+        self.local_file = local_file
+        self.updated = False
+        self.test_time = datetime.datetime.now().isoformat()
+        # Checksum is the time the test data was loaded, forcing unique URLs
+        # every time the golden is reloaded
+        self.checksum = hashlib.md5(self.test_time.encode("utf-8")).hexdigest()
+
+        motion_golden_data = None
+        with open(local_file, "r") as json_file:
+            motion_golden_data = json.load(json_file)
+        metadata = motion_golden_data["//metadata"]
+
+        self.result = metadata["result"]
+        self.golden_repo_path = metadata["goldenRepoPath"]
+        self.golden_identifier = metadata["goldenIdentifier"]
+        self.test_class_name = metadata["testClassName"]
+        self.test_method_name = metadata["testMethodName"]
+        self.device_local_path = metadata["deviceLocalPath"]
+        self.video_location = None
+        if "videoLocation" in metadata:
+            self.video_location = metadata["videoLocation"]
+
+        with open(local_file, "w") as json_file:
+            del motion_golden_data["//metadata"]
+            json.dump(motion_golden_data, json_file, indent=2)
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/constants.py b/libraries/motion/golden_updater/impl/constants.py
new file mode 100644
index 000000000..7be25ab06
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/constants.py
@@ -0,0 +1,19 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import os
+
+GOLDEN_ACCESS_TOKEN_HEADER = "Golden-Access-Token"
+GOLDEN_ACCESS_TOKEN_LOCATION = os.path.expanduser("~/.config/motion-golden/.token")
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/atest_golden_watcher.py b/libraries/motion/golden_updater/impl/golden_watchers/atest_golden_watcher.py
new file mode 100644
index 000000000..0d00ee961
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/atest_golden_watcher.py
@@ -0,0 +1,107 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import glob
+import re
+import os
+import gzip
+import shutil
+from impl.cached_golden import CachedGolden
+from impl.golden_watchers.golden_watcher import GoldenWatcher
+import itertools
+
+
+class AtestGoldenWatcher(GoldenWatcher):
+
+    def __init__(self, temp_dir, atest_latest_dir, cached_golden_service=CachedGolden):
+        self.temp_dir = temp_dir
+        self.atest_latest_dir = atest_latest_dir
+        self.cached_golden_service = cached_golden_service
+
+        # name -> CachedGolden
+        self.cached_goldens = {}
+        self.refresh_golden_files()
+
+    def clean(self):
+        self.cached_goldens = {}
+
+    def refresh_golden_files(self):
+
+        # Atest writes the files with a wide variety of filenames. Examples
+        # log/stub/local_atest/inv_8184127433410125702/light_portrait_pagingRight.actual.json_4383267726505225616.txt.gz
+        # log/invocation_3042186109657619915/inv_5155363728971335727/recordMotion_captureCrossfade.actual_10536896158799342698.json
+        # log/stub/local_atest/inv_6860054371355660320/light_portrait_noOverscrollRight.actual_118505410949600545.json.gz
+
+        # log/stub/local_atest/inv_6860054371355660320/light_portrait_noOverscrollRight.actual_12613191689435798576.mp4
+        # log/invocation_3042186109657619915/inv_5155363728971335727/recordMotion_captureCrossfade.actual_1988198704080929506.mp4
+        # log/stub/local_atest/inv_8184127433410125702/light_portrait_pagingRight.actual.mp4_1617964025478041468.txt.gz
+
+        pattern_type = (
+            r".*/(?P<name>.*)\.actual((\.(?P<ext1>[a-zA-Z0-9]+)_(?P<hash1>\d+)\.txt)|(_(?P<hash2>\d+)\.(?P<ext2>[a-zA-Z0-9]+)))(?P<compressed>\.gz)?"
+        )
+
+        # Output from on-device runs
+        # Modifying the search regex to handle files not ending with json as given above.
+        for filename in glob.iglob(
+            f"{self.atest_latest_dir}//**/*.actual*json*", recursive=True
+        ):
+
+            match = re.search(pattern_type, filename)
+
+            if not match:
+                continue
+
+            golden_name = match.group("name")
+            ext = match.group("ext1") or match.group("ext2")
+            hash = match.group("hash1") or match.group("hash2")
+            is_compressed = match.group("compressed") == ".gz"
+
+            local_file = os.path.join(self.temp_dir, f"{golden_name}_{hash}.actual.json")
+            self.copy_file(filename, local_file, is_compressed)
+            golden = self.cached_golden_service(filename, local_file)
+
+            if golden.video_location:
+                mp4Pattern = f"{self.atest_latest_dir}/**/{golden_name}.actual*.mp4*"
+                zipPattern = f"{self.atest_latest_dir}/**/{golden_name}.actual*.zip*"
+
+                # Create iterators for each pattern
+                mp4_iterator = glob.iglob(mp4Pattern, recursive=True)
+                zip_iterator = glob.iglob(zipPattern, recursive=True)
+
+                # Chain the iterators together
+                combined_iter = itertools.chain(mp4_iterator, zip_iterator)
+                for video_filename in combined_iter:
+
+                    local_video_file = os.path.join(
+                        self.temp_dir, golden.video_location
+                    )
+                    video_is_compressed = video_filename.endswith(".gz")
+                    self.copy_file(
+                        video_filename, local_video_file, video_is_compressed
+                    )
+
+                    break
+
+            self.cached_goldens[filename] = golden
+
+    def copy_file(self, source, target, is_compressed):
+        os.makedirs(os.path.dirname(target), exist_ok=True)
+
+        if is_compressed:
+            with gzip.open(source, "rb") as f_in:
+                with open(target, "wb") as f_out:
+                    shutil.copyfileobj(f_in, f_out)
+        else:
+            shutil.copyfile(source, target)
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/golden_file_watcher.py b/libraries/motion/golden_updater/impl/golden_watchers/golden_file_watcher.py
new file mode 100644
index 000000000..ee1dc3182
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/golden_file_watcher.py
@@ -0,0 +1,67 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import os
+import hashlib
+from impl.cached_golden import CachedGolden
+from impl.golden_watchers.golden_watcher import GoldenWatcher
+
+class GoldenFileWatcher(GoldenWatcher):
+
+    def __init__(self, temp_dir, adb_client, cached_golden_service=CachedGolden):
+        self.temp_dir = temp_dir
+        self.adb_client = adb_client
+
+        # name -> CachedGolden
+        self.cached_goldens = {}
+        self.cached_golden_service=cached_golden_service
+        self.refresh_golden_files()
+
+    def clean(self):
+        self.cached_goldens = {}
+
+    def refresh_golden_files(self):
+        command = f"find /data/user/0/ -type f -name *.actual.json"
+        updated_goldens = self.run_adb_command(["shell", command]).splitlines()
+        print(f"Updating goldens - found {len(updated_goldens)} files")
+
+        for golden_remote_file in updated_goldens:
+            local_file = self.adb_pull(golden_remote_file)
+
+            golden = self.cached_golden_service(golden_remote_file, local_file)
+            if golden.video_location:
+                self.adb_pull_image(golden.device_local_path, golden.video_location)
+
+            self.cached_goldens[golden_remote_file] = golden
+
+    def adb_pull(self, remote_file):
+        baseName = os.path.basename(remote_file)
+        filename, ext = os.path.splitext(baseName)
+        remoteFilenameHash = hashlib.md5(remote_file.encode("utf-8")).hexdigest()
+        local_file = os.path.join(self.temp_dir, f'{filename}_{remoteFilenameHash}{ext}')
+        self.run_adb_command(["pull", remote_file, local_file])
+        self.run_adb_command(["shell", "rm", remote_file])
+        return local_file
+
+    def adb_pull_image(self, remote_dir, remote_file):
+        remote_path = os.path.join(remote_dir, remote_file)
+        local_path = os.path.join(self.temp_dir, remote_file)
+        os.makedirs(os.path.dirname(local_path), exist_ok=True)
+        self.run_adb_command(["pull", remote_path, local_path])
+        self.run_adb_command(["shell", "rm", remote_path])
+        return local_path
+
+    def run_adb_command(self, args):
+        return self.adb_client.run_adb_command(args)
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher.py b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher.py
new file mode 100644
index 000000000..b5d90d762
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher.py
@@ -0,0 +1,27 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from abc import ABC, abstractmethod
+
+class GoldenWatcher(ABC):
+
+    @abstractmethod
+    def clean(self):
+        pass
+
+    @abstractmethod
+    def refresh_golden_files(self):
+        pass
+
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_factory.py b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_factory.py
new file mode 100644
index 000000000..3b5c836cd
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_factory.py
@@ -0,0 +1,50 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import os
+from impl.golden_watchers.golden_watcher_types import GoldenWatcherTypes
+from impl.golden_watchers.atest_golden_watcher import AtestGoldenWatcher
+from impl.golden_watchers.robolectric_golden_watcher import RobolectricGoldenWatcher
+from impl.golden_watchers.golden_file_watcher import GoldenFileWatcher
+
+class GoldenWatcherFactory:
+
+    @staticmethod
+    def create_watcher(type: GoldenWatcherTypes, tmpdir, adb_client = None):
+
+        match type:
+            case GoldenWatcherTypes.ATEST:
+                user = os.environ.get("USER")
+                return AtestGoldenWatcher(
+                    tmpdir, f"/tmp/atest_result_{user}/LATEST/"
+                )
+
+            case GoldenWatcherTypes.ROBOLECTRIC:
+                return RobolectricGoldenWatcher(
+                    tmpdir, f"/tmp/motion/"
+                )
+
+            case GoldenWatcherTypes.FILE:
+                if not adb_client:
+                    raise ValueError("adb client not found")
+
+                return GoldenFileWatcher(tmpdir, adb_client)
+
+            case _:
+                print("No such Golden Watcher exists.")
+                raise ValueError("Imporper Golden Watcher Type.")
+
+
+
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_types.py b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_types.py
new file mode 100644
index 000000000..3cd9d96ff
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/golden_watcher_types.py
@@ -0,0 +1,21 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import enum
+
+class GoldenWatcherTypes(enum.Enum):
+    ATEST = "atest"
+    FILE = "file"
+    ROBOLECTRIC = "robolectric"
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/golden_watchers/robolectric_golden_watcher.py b/libraries/motion/golden_updater/impl/golden_watchers/robolectric_golden_watcher.py
new file mode 100644
index 000000000..f185f3866
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/golden_watchers/robolectric_golden_watcher.py
@@ -0,0 +1,60 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import glob
+import os
+import hashlib
+import datetime
+import shutil
+from impl.cached_golden import CachedGolden
+from impl.golden_watchers.golden_watcher import GoldenWatcher
+
+class RobolectricGoldenWatcher(GoldenWatcher):
+
+    def __init__(self, temp_dir, latest_dir, cached_golden_service=CachedGolden):
+        self.temp_dir = temp_dir
+        self.latest_dir = latest_dir
+        self.cached_goldens = {}
+        self.cached_golden_service = cached_golden_service
+        self.refresh_golden_files()
+
+    def refresh_golden_files(self):
+        for filename in glob.iglob(
+            f"{self.latest_dir}//**/*.actual.json", recursive=True
+        ):
+            baseName = os.path.basename(filename)
+            baseFilename, ext = os.path.splitext(baseName)
+            timeHash = hashlib.md5(datetime.datetime.now().isoformat().encode("utf-8")).hexdigest()
+            local_file = os.path.join(self.temp_dir, f'copy_{baseFilename}_{timeHash}{ext}')
+            self.copy_file(filename, local_file)
+            golden = self.cached_golden_service(filename, local_file)
+            self.cached_goldens[filename] = golden
+            if golden.video_location:
+                filepath = os.path.join(self.latest_dir,
+                                        f"{golden.test_class_name}/{baseFilename}.screenshots.zip")
+                if os.path.isfile(filepath):
+                    local_video_file = os.path.join(
+                        self.temp_dir, golden.video_location
+                    )
+                    self.copy_file(
+                        filepath, local_video_file
+                    )
+
+    def copy_file(self, source, target):
+        os.makedirs(os.path.dirname(target), exist_ok=True)
+        shutil.copyfile(source, target)
+
+    def clean(self):
+        self.cached_goldens = {}
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/port_finder.py b/libraries/motion/golden_updater/impl/port_finder.py
new file mode 100644
index 000000000..e1bac4ca4
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/port_finder.py
@@ -0,0 +1,24 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import socket
+
+class PortFinder:
+
+    @staticmethod
+    def find_free_port():
+        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
+            s.bind(("", 0))  # Bind to a random free port provided by the OS
+            return s.getsockname()[1]  # Get the port number
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/token_generator.py b/libraries/motion/golden_updater/impl/token_generator.py
new file mode 100644
index 000000000..706defeac
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/token_generator.py
@@ -0,0 +1,40 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import secrets
+import os
+from impl.constants import GOLDEN_ACCESS_TOKEN_LOCATION
+
+class TokenGenerator:
+
+    def get_token() -> str:
+        try:
+            with open(GOLDEN_ACCESS_TOKEN_LOCATION, "r") as token_file:
+                token = token_file.readline()
+                return token
+        except IOError:
+            token = secrets.token_hex(32)
+            os.makedirs(os.path.dirname(GOLDEN_ACCESS_TOKEN_LOCATION), exist_ok=True)
+            try:
+                with open(GOLDEN_ACCESS_TOKEN_LOCATION, "w") as token_file:
+                    token_file.write(token)
+                os.chmod(GOLDEN_ACCESS_TOKEN_LOCATION, 0o600)
+            except IOError:
+                print(
+                    "Unable to save persistent token {} to {}".format(
+                        token, GOLDEN_ACCESS_TOKEN_LOCATION
+                    )
+                )
+            return token
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/watch_web_app_request_handler.py b/libraries/motion/golden_updater/impl/watch_web_app_request_handler.py
new file mode 100644
index 000000000..0b9463038
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/watch_web_app_request_handler.py
@@ -0,0 +1,224 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import http.server
+import urllib.parse
+import json
+import mimetypes
+import shutil
+from os import path
+import pathlib
+import os
+from impl.constants import GOLDEN_ACCESS_TOKEN_HEADER
+from impl.zip_to_video_converter import ZipToVideoConverter
+
+class WatchWebAppRequestHandler(http.server.BaseHTTPRequestHandler):
+    secret_token = None
+    golden_watcher = None
+    android_build_top = None
+    this_server_address = None
+
+    def __init__(self, *args, **kwargs):
+        self.root_directory = path.abspath(path.dirname(__file__))
+        super().__init__(*args, **kwargs)
+
+    def verify_access_token(self):
+        token = self.headers.get(GOLDEN_ACCESS_TOKEN_HEADER)
+        if not token or token != WatchWebAppRequestHandler.secret_token:
+            self.send_response(403, "Bad authorization token!")
+            return False
+
+        return True
+
+    def do_OPTIONS(self):
+        self.send_response(200)
+        self.send_header("Allow", "GET,POST,PUT")
+        self.add_standard_headers()
+        self.end_headers()
+        self.wfile.write(b"GET,POST,PUT")
+
+    def do_GET(self):
+
+        parsed = urllib.parse.urlparse(self.path)
+
+        if parsed.path == "/service/list":
+            self.service_list_goldens()
+            return
+        elif parsed.path.startswith("/golden/"):
+            requested_file_start_index = parsed.path.find("/", len("/golden/") + 1)
+            requested_file = parsed.path[requested_file_start_index + 1 :]
+            self.serve_file(WatchWebAppRequestHandler.golden_watcher.temp_dir, requested_file)
+            return
+        elif parsed.path.startswith("/expected/"):
+            golden_id = parsed.path[len("/expected/") :]
+
+            goldens = WatchWebAppRequestHandler.golden_watcher.cached_goldens.values()
+            for golden in goldens:
+                if golden.id != golden_id:
+                    continue
+
+                self.serve_file(
+                    WatchWebAppRequestHandler.android_build_top, golden.golden_repo_path, "application/json"
+                )
+                return
+
+        self.send_error(404)
+
+    def do_POST(self):
+        if not self.verify_access_token():
+            return
+
+        content_type = self.headers.get("Content-Type")
+
+        # refuse to receive non-json content
+        if content_type != "application/json":
+            self.send_response(400)
+            return
+
+        length = int(self.headers.get("Content-Length"))
+        message = json.loads(self.rfile.read(length))
+
+        parsed = urllib.parse.urlparse(self.path)
+        if parsed.path == "/service/refresh":
+            self.service_refresh_goldens(message["clear"])
+        else:
+            self.send_error(404)
+
+    def do_PUT(self):
+        if not self.verify_access_token():
+            return
+
+        parsed = urllib.parse.urlparse(self.path)
+        query_params = urllib.parse.parse_qs(parsed.query)
+
+        if parsed.path == "/service/update":
+            self.service_update_golden(query_params["id"][0])
+        else:
+            self.send_error(404)
+
+    def serve_file(self, root_directory, file_relative_to_root, mime_type=None):
+        resolved_path = path.abspath(path.join(root_directory, file_relative_to_root))
+
+        if path.commonprefix(
+            [resolved_path, root_directory]
+        ) == root_directory and path.isfile(resolved_path):
+            self.send_response(200)
+            self.send_header(
+                "Content-type", mime_type or mimetypes.guess_type(resolved_path)[0]
+            )
+            self.add_standard_headers()
+
+            if resolved_path.endswith("screenshots.zip"):
+
+                if ZipToVideoConverter.process_single_zip(pathlib.Path(resolved_path)):
+                    video_path = resolved_path.replace("zip","mp4")
+                    if pathlib.Path(video_path).is_file() :
+                        self.send_header(
+                            "Content-type", "video/mp4"
+                        )
+                        self.end_headers()
+                        with open(video_path, "rb") as f:
+                            self.wfile.write(f.read())
+
+            else :
+                self.end_headers()
+                with open(resolved_path, "rb") as f:
+                    self.wfile.write(f.read())
+
+        else:
+            self.send_error(404)
+
+    def service_list_goldens(self):
+        if not self.verify_access_token():
+            return
+
+        goldens_list = []
+
+        for golden in WatchWebAppRequestHandler.golden_watcher.cached_goldens.values():
+
+            golden_data = {}
+            golden_data["id"] = golden.id
+            golden_data["result"] = golden.result
+            golden_data["label"] = golden.golden_identifier
+            golden_data["goldenRepoPath"] = golden.golden_repo_path
+            golden_data["updated"] = golden.updated
+            golden_data["testClassName"] = golden.test_class_name
+            golden_data["testMethodName"] = golden.test_method_name
+            golden_data["testTime"] = golden.test_time
+
+            golden_data["actualUrl"] = (
+                f"{WatchWebAppRequestHandler.this_server_address}/golden/{golden.checksum}/{golden.local_file[len(WatchWebAppRequestHandler.golden_watcher.temp_dir) + 1 :]}"
+            )
+            expected_file = path.join(WatchWebAppRequestHandler.android_build_top, golden.golden_repo_path)
+            if os.path.exists(expected_file):
+                golden_data["expectedUrl"] = (
+                    f"{WatchWebAppRequestHandler.this_server_address}/expected/{golden.id}"
+                )
+
+            golden_data["videoUrl"] = (
+                f"{WatchWebAppRequestHandler.this_server_address}/golden/{golden.checksum}/{golden.video_location}"
+            )
+
+            goldens_list.append(golden_data)
+
+        self.send_json(goldens_list)
+
+    def service_refresh_goldens(self, clear):
+        if clear:
+            WatchWebAppRequestHandler.golden_watcher.clean()
+        WatchWebAppRequestHandler.golden_watcher.refresh_golden_files()
+        self.service_list_goldens()
+
+    def service_update_golden(self, id):
+        goldens = WatchWebAppRequestHandler.golden_watcher.cached_goldens.values()
+        for golden in goldens:
+            if golden.id != id:
+                print("skip", golden.id)
+                continue
+
+            dst = path.join(WatchWebAppRequestHandler.android_build_top, golden.golden_repo_path)
+            if not path.exists(path.dirname(dst)):
+                os.makedirs(path.dirname(dst))
+
+            shutil.copyfile(golden.local_file, dst)
+
+            golden.updated = True
+            self.send_json({"result": "OK"})
+            return
+
+        self.send_error(400)
+
+    def send_json(self, data):
+        # Replace this with code that generates your JSON data
+        data_encoded = json.dumps(data).encode("utf-8")
+        self.send_response(200)
+        self.send_header("Content-type", "application/json")
+        self.add_standard_headers()
+        self.end_headers()
+        self.wfile.write(data_encoded)
+
+    def add_standard_headers(self):
+        self.send_header("Access-Control-Allow-Origin", "*")
+        self.send_header("Access-Control-Allow-Methods", "POST, PUT, GET, OPTIONS")
+        self.send_header(
+            "Access-Control-Allow-Headers",
+            GOLDEN_ACCESS_TOKEN_HEADER
+            + ", Content-Type, Content-Length, Range, Accept-ranges",
+        )
+        # Accept-ranges: bytes is needed for chrome to allow seeking the
+        # video. At this time, won't handle ranges on subsequent gets,
+        # but that is likely OK given the size of these videos and that
+        # its local only.
+        self.send_header("Accept-ranges", "bytes")
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/impl/zip_to_video_converter.py b/libraries/motion/golden_updater/impl/zip_to_video_converter.py
new file mode 100644
index 000000000..f869007d2
--- /dev/null
+++ b/libraries/motion/golden_updater/impl/zip_to_video_converter.py
@@ -0,0 +1,176 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import zipfile
+import os
+import subprocess
+import sys
+import tempfile
+import shutil
+import pathlib
+
+class ZipToVideoConverter:
+
+    FFMPEG_PATH = "ffmpeg"
+    FRAME_RATE = "62.5"
+    PNG_PATTERN = "image_%04d.png"
+
+    @staticmethod
+    def get_relative_path(path: pathlib.Path) -> pathlib.Path:
+        try:
+            return path.relative_to(pathlib.Path.cwd())
+        except ValueError:
+            return path
+
+    @staticmethod
+    def extract_pngs(zip_path: pathlib.Path, temp_dir: pathlib.Path, relative_zip_path: pathlib.Path) -> int:
+        """
+        Extracts PNG files from the ZIP to the temp directory.
+        Returns: Extracted count, 0 if no PNGs/0 extracted, -1 on fatal error.
+        """
+        extracted_png_count = 0
+        try:
+            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
+                png_files_in_zip = [
+                    item for item in zip_ref.infolist()
+                    if item.filename.lower().endswith('.png')
+                ]
+
+                if not png_files_in_zip:
+                    return 0
+
+                for item in png_files_in_zip:
+                    if ".." in item.filename or os.path.isabs(item.filename):
+                        continue
+                    try:
+                        zip_ref.extract(item, temp_dir)
+                        extracted_png_count += 1
+                    except Exception:
+                        pass
+
+                if extracted_png_count == 0:
+                    print(f"Info: Extracted 0 usable PNG files from {relative_zip_path}. Skipping video creation.", file=sys.stderr)
+                    return 0
+
+            return extracted_png_count
+
+        except zipfile.BadZipFile:
+            print(f"Error: Invalid ZIP file '{relative_zip_path}'", file=sys.stderr)
+            return -1
+        except Exception as e:
+            print(f"Error during extraction for '{relative_zip_path}': {e}", file=sys.stderr)
+            return -1
+
+    @staticmethod
+    def run_ffmpeg(temp_dir: pathlib.Path, temp_video_output_path: pathlib.Path, relative_zip_path: pathlib.Path) -> bool:
+        """
+        Runs FFmpeg in the temp directory.
+        Returns: True on success, False on failure.
+        """
+        original_cwd = os.getcwd()
+        try:
+            os.chdir(temp_dir)
+
+            ffmpeg_command = [
+                ZipToVideoConverter.FFMPEG_PATH,
+                "-r", ZipToVideoConverter.FRAME_RATE,
+                "-i", ZipToVideoConverter.PNG_PATTERN,
+                str(temp_video_output_path)
+            ]
+
+            result = subprocess.run(ffmpeg_command, capture_output=True, text=True, check=False)
+
+            if result.returncode != 0:
+                print(f"Error: FFmpeg failed for '{relative_zip_path}' (exit code {result.returncode}).", file=sys.stderr)
+                return False
+            else:
+                 if not temp_video_output_path.exists():
+                     print(f"Error: FFmpeg success, but output video not found for '{relative_zip_path}'!", file=sys.stderr)
+                     return False
+                 return True
+
+        except FileNotFoundError:
+             print(f"Error: FFmpeg executable not found: '{ZipToVideoConverter.FFMPEG_PATH}'. Check path or install FFmpeg.", file=sys.stderr)
+             return False
+        except Exception as e:
+            print(f"Error during FFmpeg processing for '{relative_zip_path}': {e}", file=sys.stderr)
+            return False
+        finally:
+            os.chdir(original_cwd)
+
+
+    @staticmethod
+    def move_video(temp_video_output_path: pathlib.Path, final_video_path: pathlib.Path, relative_zip_path: pathlib.Path) -> bool:
+        """
+        Moves the video file from temp to final destination.
+        Returns: True on success, False on failure.
+        """
+        if temp_video_output_path.exists():
+            try:
+                final_video_path.parent.mkdir(parents=True, exist_ok=True)
+                shutil.move(str(temp_video_output_path), str(final_video_path))
+                print(f"Success: Created {ZipToVideoConverter.get_relative_path(final_video_path)}", file=sys.stderr)
+                return True
+            except Exception as move_err:
+                print(f"Error: Failed to move video for '{relative_zip_path}': {move_err}", file=sys.stderr)
+                return False
+        else:
+            print(f"Error: Cannot move video for '{relative_zip_path}', temp file does not exist!", file=sys.stderr)
+            return False
+
+
+    @staticmethod
+    def process_single_zip(zip_path: pathlib.Path) -> bool:
+        """
+        Processes a single ZIP file by extracting PNGs, creating a video using ffmpeg,
+        and cleaning up temporary files. Saves the video in the same directory as the input zip.
+
+        Args:
+            zip_path: Path object pointing to the input ZIP file.
+
+        Returns:
+            True if processing was successful (or skipped safely), False otherwise.
+        """
+        output_dir = zip_path.parent
+        base_name = zip_path.stem
+        video_name = base_name + ".mp4"
+        final_video_path = output_dir / video_name
+        relative_zip_path = ZipToVideoConverter.get_relative_path(zip_path)
+
+        try:
+            with tempfile.TemporaryDirectory(prefix=f"{base_name}_ffmpeg_") as temp_dir_str:
+                temp_dir = pathlib.Path(temp_dir_str)
+
+                extracted_count = ZipToVideoConverter.extract_pngs(zip_path, temp_dir, relative_zip_path)
+                if extracted_count < 0:
+                    return False
+                if extracted_count == 0:
+                    return True
+
+                temp_video_output_path = temp_dir / video_name
+
+                if not ZipToVideoConverter.run_ffmpeg(temp_dir, temp_video_output_path, relative_zip_path):
+                    return False
+
+                if not ZipToVideoConverter.move_video(temp_video_output_path, final_video_path, relative_zip_path):
+                    return False
+
+                return True
+
+        except Exception as e:
+            print(f"Error processing '{relative_zip_path}': {e}", file=sys.stderr)
+            return False
+        finally:
+             print(f"--- Finished: {relative_zip_path} ---", file=sys.stderr)
diff --git a/libraries/motion/golden_updater/test_assets/fake_adb_client.py b/libraries/motion/golden_updater/test_assets/fake_adb_client.py
new file mode 100644
index 000000000..e55d6999b
--- /dev/null
+++ b/libraries/motion/golden_updater/test_assets/fake_adb_client.py
@@ -0,0 +1,35 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from test_assets.test_assets import returnNoneIfOverFlow
+
+class FakeADBClient:
+    def __init__(self):
+        self.run_adb_command_calls = []
+        self.run_as_root_calls = 0
+        self.wait_for_device_calls = 0
+        self.run_adb_command_result = []
+        self.run_as_root_result = []
+
+    def run_as_root(self):
+        self.run_as_root_calls += 1
+        return returnNoneIfOverFlow(self.run_as_root_result,self.run_as_root_calls-1)
+
+    def wait_for_device(self):
+        self.wait_for_device_calls += 1
+
+    def run_adb_command(self, args):
+        self.run_adb_command_calls.append(args)
+        return returnNoneIfOverFlow(self.run_adb_command_result, len(self.run_adb_command_calls) -1)
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/test_assets/fake_cached_golden.py b/libraries/motion/golden_updater/test_assets/fake_cached_golden.py
new file mode 100644
index 000000000..d1c8e3165
--- /dev/null
+++ b/libraries/motion/golden_updater/test_assets/fake_cached_golden.py
@@ -0,0 +1,25 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from test_assets.test_assets import returnNoneIfOverFlow
+
+class FakeCachedGolden:
+    def __init__(self):
+        self.calls=[]
+        self.goldens=[]
+
+    def __call__(self, remote_file, local_file):
+        self.calls.append([remote_file, local_file])
+        return returnNoneIfOverFlow(self.goldens, len(self.calls)-1)
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/test_assets/fake_golden.py b/libraries/motion/golden_updater/test_assets/fake_golden.py
new file mode 100644
index 000000000..fc86b19df
--- /dev/null
+++ b/libraries/motion/golden_updater/test_assets/fake_golden.py
@@ -0,0 +1,21 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+class FakeGolden:
+
+   def __init__(self, video_location=None, device_local_path=None, test_class_name=None):
+      self.video_location=video_location
+      self.device_local_path=device_local_path
+      self.test_class_name=test_class_name
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/test_assets/test_assets.py b/libraries/motion/golden_updater/test_assets/test_assets.py
new file mode 100644
index 000000000..a3cf18e4b
--- /dev/null
+++ b/libraries/motion/golden_updater/test_assets/test_assets.py
@@ -0,0 +1,112 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import os
+
+temp_dir = '/tmp/tmp_dir'
+atest_latest_dir = '/tmp/atest_result_user/LATEST'
+time_hash_value = "time_hash_value"
+
+filenameA = 'dir_name/test_method_1.actual.json_4383267726505225616.txt.gz'
+filenameB = 'dir_name/test_method_2.actual_10536896158799342698.json'
+filenameC = 'dir_name/test_method_3.actual_118505410949600545.json.gz'
+filenameD = 'dir_name/test_method_3.actual.screenshots.zip_48700825828765530.txt'
+filenameE = 'dir_name/test_method_2.actual_1988198704080929506.mp4.gz'
+filenameF = 'dir_name/test_method_1.actual.mp4_1617964025478041468.txt.gz'
+fileNameG = 'dir_name/test_method_3.actual.json'
+localFileA = f"{temp_dir}/test_method_1_4383267726505225616.actual.json"
+localFileB = f"{temp_dir}/test_method_2_10536896158799342698.actual.json"
+localFileC = f"{temp_dir}/test_method_3_118505410949600545.actual.json"
+localFileD = f"{temp_dir}/dir_name/test_method_3.actual.screenshots.zip"
+localFileE = f"{temp_dir}/dir_name/test_method_2.actual.mp4"
+localFileF = f"{temp_dir}/dir_name/test_method_1.actual.mp4"
+localFileG = f'{temp_dir}/copy_test_method_3.actual_time_hash_value.json'
+video_location1 = "dir_name/test_method_1.actual.mp4"
+video_location2 = "dir_name/test_method_2.actual.mp4"
+video_location3 = "dir_name/test_method_3.actual.screenshots.zip"
+test_class_name = "robo_test"
+device_local_path = "data/user/0/platform.test.motion.compose.tests/files/goldens"
+robo_video_file_path = f"{atest_latest_dir}/{test_class_name}/test_method_3.actual.screenshots.zip"
+MOCK_TOKEN_LOCATION = os.path.expanduser("~/.config/motion-golden/.mock_token")
+
+remote_file_content = """{
+  "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    64,
+    96,
+    144,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "alpha",
+      "type": "float",
+      "data_points": [
+        0,
+        0,
+        0,
+        0.12842241,
+        0.55449593,
+        0.81507283,
+        0.9581131,
+        1
+      ]
+    }
+  ],
+  "//metadata": {
+    "goldenRepoPath": "dir_name/goldens/test_method.json",
+    "goldenIdentifier": "test_method",
+    "testClassName": "test_class_name",
+    "testMethodName": "test_method",
+    "deviceLocalPath": "/data/user/0/platform.test.motion.compose.tests/files/goldens",
+    "result": "PASSED",
+    "videoLocation": "test_class_name/test_method.actual.mp4"
+  }
+}"""
+
+local_file_content = {
+    "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    64,
+    96,
+    144,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "alpha",
+      "type": "float",
+      "data_points": [
+        0,
+        0,
+        0,
+        0.12842241,
+        0.55449593,
+        0.81507283,
+        0.9581131,
+        1
+      ]
+    }
+  ]
+}
+
+def returnNoneIfOverFlow(list: list, index):
+    return list[index] if len(list) > index else None
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/adb_client_test.py b/libraries/motion/golden_updater/tests/adb_client_test.py
new file mode 100644
index 000000000..f279972ae
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/adb_client_test.py
@@ -0,0 +1,86 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+import sys
+import os
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+from impl.adb_client import AdbClient
+
+class FakeSubprocessRun:
+    def __init__(self, return_stdout=None, raise_exception=None):
+        self.return_stdout = return_stdout
+        self.raise_exception = raise_exception
+        self.calls = []
+
+    def __call__(self, command, check=True, capture_output=True):
+        self.calls.append(command)
+        if self.raise_exception:
+            raise self.raise_exception
+        else:
+            class FakeProcess:
+                stdout = self.return_stdout
+
+            return FakeProcess()
+
+fake_subprocess_run = FakeSubprocessRun(return_stdout=b"test output")
+adb_client = AdbClient("adb_serial", fake_subprocess_run)
+command_prefix = ["adb","-s","adb_serial"]
+
+class AdbClientTest(unittest.TestCase):
+
+  def test_init(self):
+    self.assertEqual(adb_client.adb_serial, "adb_serial")
+
+  def test_run_as_root_restarting_adb(self):
+    fake_subprocess_run.return_stdout = b"restarting adbd as root"
+    fake_subprocess_run.calls = []
+
+    self.assertTrue(adb_client.run_as_root())
+
+    self.assertEqual(
+       fake_subprocess_run.calls,
+        [
+          (command_prefix + ["root"]),
+          (command_prefix + ["wait-for-device"]),
+        ]
+    )
+
+  def test_run_as_root_adb_already_running(self):
+    fake_subprocess_run.return_stdout = b"adbd is already running as root"
+    fake_subprocess_run.calls = []
+
+    self.assertTrue(adb_client.run_as_root())
+    self.assertEqual(fake_subprocess_run.calls, [(command_prefix + ["root"])])
+
+  def test_run_as_root_failed(self):
+    fake_subprocess_run.return_stdout = b"permission denied"
+    fake_subprocess_run.calls = []
+
+    self.assertFalse(adb_client.run_as_root())
+    self.assertEqual(fake_subprocess_run.calls, [(command_prefix + ["root"])])
+
+  def test_run_adb_command(self):
+    fake_subprocess_run.return_stdout = b"results returned"
+    fake_subprocess_run.calls = []
+
+    result = adb_client.run_adb_command(["wait-for-device"])
+
+    self.assertEqual(fake_subprocess_run.calls, [(command_prefix + ["wait-for-device"])])
+    self.assertEqual(result, "results returned")
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/cached_golden_test.py b/libraries/motion/golden_updater/tests/cached_golden_test.py
new file mode 100644
index 000000000..312f1b6a8
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/cached_golden_test.py
@@ -0,0 +1,64 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import patch, call, mock_open
+import sys
+import os
+import json
+import hashlib
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+from impl.cached_golden import CachedGolden
+from test_assets.test_assets import *
+
+class CachedGoldenTest(unittest.TestCase):
+
+  @patch("json.dump")
+  @patch("json.load")
+  @patch("builtins.open", new_callable=mock_open)
+  def test_init(self, mock_open_func, mock_json_load, mock_json_dump):
+    remote_file = "remote_file"
+    local_file = "local_file"
+
+    mock_file = mock_open_func.return_value
+    mock_json_load.return_value = json.loads(remote_file_content)
+
+    cached_golden = CachedGolden(remote_file, local_file)
+    mock_json_load.assert_called_once()
+    mock_json_dump.assert_called_once_with(local_file_content, mock_file, indent=2)
+    mock_open_func.assert_has_calls(
+      [
+        call(local_file, "r"),
+        call(local_file, "w")
+      ],
+      any_order = True
+    )
+
+    metadata = json.loads(remote_file_content)["//metadata"]
+    self.assertEqual(
+      [cached_golden.id, cached_golden.remote_file, cached_golden.local_file,
+       cached_golden.updated, cached_golden.result, cached_golden.golden_repo_path,
+       cached_golden.golden_identifier, cached_golden.test_class_name, cached_golden.test_method_name,
+       cached_golden.device_local_path, cached_golden.video_location],
+
+      [hashlib.md5(remote_file.encode("utf-8")).hexdigest(), remote_file, local_file,
+       False, metadata["result"], metadata["goldenRepoPath"], metadata["goldenIdentifier"],
+       metadata["testClassName"], metadata["testMethodName"], metadata["deviceLocalPath"],
+       metadata["videoLocation"]]
+    )
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/test_impl/atest_golden_watcher_test.py b/libraries/motion/golden_updater/tests/test_impl/atest_golden_watcher_test.py
new file mode 100644
index 000000000..6ecb8a0d8
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/test_impl/atest_golden_watcher_test.py
@@ -0,0 +1,140 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import call, patch
+import sys
+import os
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
+from test_assets.test_assets import *
+from test_assets.fake_cached_golden import FakeCachedGolden
+from test_assets.fake_golden import FakeGolden
+from impl.golden_watchers.atest_golden_watcher import AtestGoldenWatcher
+
+class AtestGoldenWatcherTest(unittest.TestCase):
+
+  @patch.object(AtestGoldenWatcher, 'refresh_golden_files')
+  def test_init(self, _):
+    atestWatcher = AtestGoldenWatcher(temp_dir, atest_latest_dir)
+    self.assertEqual(atestWatcher.temp_dir, temp_dir)
+    self.assertEqual(atestWatcher.atest_latest_dir, atest_latest_dir)
+    self.assertEqual(atestWatcher.cached_goldens, {})
+
+  @patch.object(AtestGoldenWatcher, 'refresh_golden_files')
+  def test_clean(self, _):
+    atestWatcher = AtestGoldenWatcher(temp_dir, atest_latest_dir)
+    atestWatcher.cached_goldens = {"a": 1}
+    atestWatcher.clean()
+    self.assertEqual(atestWatcher.cached_goldens, {})
+
+  @patch('glob.iglob')
+  @patch.object(AtestGoldenWatcher, 'copy_file')
+  def test_refresh_golden_files_without_videos(self, mock_copy_file, mock_iglob):
+    mock_iglob.return_value = [filenameA, filenameB, filenameC]
+
+    fake_cached_golden = FakeCachedGolden()
+    golden = FakeGolden()
+    fake_cached_golden.goldens.append(golden)
+    fake_cached_golden.goldens.append(golden)
+    fake_cached_golden.goldens.append(golden)
+
+    atestWatcher = AtestGoldenWatcher(temp_dir, atest_latest_dir, fake_cached_golden)
+
+    mock_iglob.assert_called_once_with(f"{atestWatcher.atest_latest_dir}//**/*.actual*json*", recursive=True)
+
+    calls = [
+      call(filenameA, localFileA, True),
+      call(filenameB, localFileB, False),
+      call(filenameC, localFileC, True)
+    ]
+    mock_copy_file.assert_has_calls(calls)
+
+    self.assertEqual(
+      fake_cached_golden.calls,
+      [
+        [filenameA, localFileA],
+        [filenameB, localFileB],
+        [filenameC, localFileC]
+      ]
+    )
+
+    expected_cached_goldens = {
+      filenameA: golden,
+      filenameB: golden,
+      filenameC: golden
+    }
+    self.assertEqual(len(fake_cached_golden.calls), 3)
+    self.assertEqual(mock_copy_file.call_count, 3)
+    self.assertEqual(atestWatcher.cached_goldens, expected_cached_goldens)
+
+  @patch('glob.iglob')
+  @patch.object(AtestGoldenWatcher, 'copy_file')
+  def test_refresh_golden_files_with_videos(self, mock_copy_file, mock_iglob):
+    mock_iglob.side_effect = [[filenameA, filenameB, filenameC], [filenameF], [], [filenameE], [], [], [filenameD]]
+    golden1 = FakeGolden(video_location1)
+    golden2 = FakeGolden(video_location2)
+    golden3 = FakeGolden(video_location3)
+
+    fake_cached_golden = FakeCachedGolden()
+    fake_cached_golden.goldens.append(golden1)
+    fake_cached_golden.goldens.append(golden2)
+    fake_cached_golden.goldens.append(golden3)
+
+    atestWatcher = AtestGoldenWatcher(temp_dir, atest_latest_dir, fake_cached_golden)
+
+    calls = [
+      call(f"{atestWatcher.atest_latest_dir}//**/*.actual*json*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_1.actual*.mp4*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_1.actual*.zip*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_2.actual*.mp4*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_2.actual*.zip*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_3.actual*.mp4*", recursive=True),
+      call(f"{atestWatcher.atest_latest_dir}/**/test_method_3.actual*.zip*", recursive=True)
+    ]
+    mock_iglob.assert_has_calls(calls)
+
+    calls = [
+      call(filenameA, localFileA, True),
+      call(filenameF, localFileF, True),
+      call(filenameB, localFileB, False),
+      call(filenameE, localFileE, True),
+      call(filenameC, localFileC, True),
+      call(filenameD, localFileD, False)
+    ]
+    mock_copy_file.assert_has_calls(calls)
+
+    self.assertEqual(
+      fake_cached_golden.calls,
+      [
+        [filenameA, localFileA],
+        [filenameB, localFileB],
+        [filenameC, localFileC]
+      ]
+    )
+
+    expected_cached_goldens = {
+      filenameA: golden1,
+      filenameB: golden2,
+      filenameC: golden3
+    }
+
+    self.assertEqual(mock_iglob.call_count, 7)
+    self.assertEqual(len(fake_cached_golden.calls), 3)
+    self.assertEqual(mock_copy_file.call_count, 6)
+    self.assertEqual(atestWatcher.cached_goldens, expected_cached_goldens)
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/test_impl/golden_file_watcher_test.py b/libraries/motion/golden_updater/tests/test_impl/golden_file_watcher_test.py
new file mode 100644
index 000000000..b5c43cfbe
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/test_impl/golden_file_watcher_test.py
@@ -0,0 +1,146 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import patch, call
+import sys
+import os
+import hashlib
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
+from impl.golden_watchers.golden_file_watcher import GoldenFileWatcher
+from test_assets.test_assets import *
+from test_assets.fake_cached_golden import FakeCachedGolden
+from test_assets.fake_golden import FakeGolden
+from test_assets.fake_adb_client import FakeADBClient
+
+class GoldenFileWatcherTest(unittest.TestCase):
+
+  @patch.object(GoldenFileWatcher, 'refresh_golden_files')
+  def test_init(self, mock_refresh_golden_files):
+    fake_adb_client = FakeADBClient()
+    watcher = GoldenFileWatcher(temp_dir, fake_adb_client)
+
+    mock_refresh_golden_files.assert_called_once()
+    self.assertEqual(watcher.temp_dir, temp_dir)
+    self.assertEqual(watcher.adb_client, fake_adb_client)
+    self.assertEqual(watcher.cached_goldens, {})
+
+  @patch.object(GoldenFileWatcher, 'refresh_golden_files')
+  def test_clean(self, _):
+    fake_adb_client = FakeADBClient()
+    goldenWatcher = GoldenFileWatcher(temp_dir, fake_adb_client)
+    goldenWatcher.cached_goldens = {"a": 1}
+
+    goldenWatcher.clean()
+
+    self.assertEqual(goldenWatcher.cached_goldens, {})
+
+  @patch.object(GoldenFileWatcher, 'adb_pull')
+  @patch.object(GoldenFileWatcher, 'adb_pull_image')
+  def test_refresh_golden_files(self, mock_pull_image, mock_pull):
+    fake_adb_client = FakeADBClient()
+    fake_adb_client.run_adb_command_result.append(f'{filenameA}\n{filenameB}')
+
+    mock_pull.side_effect = [localFileA, localFileB]
+    fake_cached_golden = FakeCachedGolden()
+
+    golden1=FakeGolden(video_location1, device_local_path)
+    golden2=FakeGolden()
+    fake_cached_golden.goldens.append(golden1)
+    fake_cached_golden.goldens.append(golden2)
+
+    #Not invoking refresh_golden_files explicitly as it is being called in the constructor
+    goldenWatcher = GoldenFileWatcher(temp_dir, fake_adb_client, fake_cached_golden)
+
+    self.assertEqual(fake_adb_client.run_adb_command_calls, [["shell", f"find /data/user/0/ -type f -name *.actual.json"]])
+    mock_pull.assert_has_calls(
+      [
+        call(filenameA),
+        call(filenameB)
+      ]
+    )
+    self.assertEqual(
+        fake_cached_golden.calls,
+        [
+            [filenameA, localFileA],
+            [filenameB, localFileB]
+        ]
+    )
+    mock_pull_image.assert_called_once_with(device_local_path, video_location1)
+
+    self.assertEqual(goldenWatcher.cached_goldens, {
+      filenameA: golden1,
+      filenameB: golden2
+    })
+
+  @patch.object(GoldenFileWatcher, 'adb_pull')
+  @patch.object(GoldenFileWatcher, 'adb_pull_image')
+  def test_refresh_golden_files_no_files_found(self, mock_pull_image, mock_pull):
+    fake_adb_client = FakeADBClient()
+    fake_adb_client.run_adb_command_result.append('')
+    fake_cached_golden = FakeCachedGolden()
+
+    #Not invoking refresh_golden_files explicitly as it is being called in the constructor
+    goldenWatcher = GoldenFileWatcher(temp_dir, fake_adb_client, fake_cached_golden)
+
+    self.assertEqual(fake_adb_client.run_adb_command_calls, [["shell", f"find /data/user/0/ -type f -name *.actual.json"]])
+    mock_pull.assert_not_called()
+    self.assertEqual(fake_cached_golden.calls, [])
+    mock_pull_image.assert_not_called()
+    self.assertEqual(goldenWatcher.cached_goldens, {})
+
+  @patch.object(GoldenFileWatcher, 'refresh_golden_files')
+  def test_adb_pull(self, _):
+    remote_file = "remote_file.json"
+    remote_filename_hash = hashlib.md5(remote_file.encode("utf-8")).hexdigest()
+    local_file = f'/tmp/tmp_dir/remote_file_{remote_filename_hash}.json'
+    fake_adb_client = FakeADBClient()
+    fake_cached_golden = FakeCachedGolden()
+
+    goldenWatcher = GoldenFileWatcher(temp_dir, fake_adb_client, fake_cached_golden)
+    result = goldenWatcher.adb_pull(remote_file)
+
+    self.assertEqual(
+        fake_adb_client.run_adb_command_calls,
+        [
+            ["pull", remote_file, local_file],
+            ["shell", "rm", remote_file]
+        ]
+    )
+    self.assertEqual(result, local_file)
+
+  @patch.object(GoldenFileWatcher, 'refresh_golden_files')
+  def test_adb_pull_image(self, _):
+    fake_adb_client = FakeADBClient()
+    fake_cached_golden = FakeCachedGolden()
+    goldenWatcher = GoldenFileWatcher(temp_dir, fake_adb_client, fake_cached_golden)
+    result = goldenWatcher.adb_pull_image(device_local_path, video_location1)
+
+    remote_path = f'{device_local_path}/{video_location1}'
+    local_path = f'/tmp/tmp_dir/{video_location1}'
+
+    self.assertTrue(os.path.isdir(os.path.dirname(local_path)))
+    self.assertEqual(
+        fake_adb_client.run_adb_command_calls,
+      [
+        ["pull", remote_path, local_path],
+        ["shell", "rm", remote_path]
+      ]
+    )
+    self.assertEqual(result, local_path)
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/test_impl/golden_watcher_factory_test.py b/libraries/motion/golden_updater/tests/test_impl/golden_watcher_factory_test.py
new file mode 100644
index 000000000..94617db3b
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/test_impl/golden_watcher_factory_test.py
@@ -0,0 +1,77 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import patch
+import sys
+import os
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
+from impl.golden_watchers.golden_watcher_factory import GoldenWatcherFactory
+from impl.golden_watchers.golden_watcher_types import GoldenWatcherTypes
+from test_assets.fake_adb_client import FakeADBClient
+
+class FakeAtestGoldenWatcher:
+
+    def __init__(self, temp_dir, atest_latest_dir):
+        self.temp_dir = temp_dir
+        self.atest_latest_dir = atest_latest_dir
+
+class FakeRobolectricGoldenWatcher:
+
+    def __init__(self, temp_dir, latest_dir):
+        self.temp_dir = temp_dir
+        self.latest_dir = latest_dir
+
+class FakeGoldenFileWatcher:
+
+    def __init__(self, temp_dir, adb_client):
+        self.temp_dir = temp_dir
+        self.adb_client = adb_client
+
+class GoldenWatcherFactoryTest(unittest.TestCase):
+
+    @patch('impl.golden_watchers.golden_watcher_factory.AtestGoldenWatcher', new=FakeAtestGoldenWatcher)
+    def test_create_watcher_creates_AtestGoldenWatcher(self):
+        golden_watcher = GoldenWatcherFactory.create_watcher(GoldenWatcherTypes.ATEST, "tmp")
+        user = os.environ.get("USER")
+        self.assertEqual(golden_watcher.temp_dir, "tmp")
+        self.assertEqual(golden_watcher.atest_latest_dir, f"/tmp/atest_result_{user}/LATEST/")
+
+    @patch('impl.golden_watchers.golden_watcher_factory.RobolectricGoldenWatcher', new=FakeRobolectricGoldenWatcher)
+    def test_create_watcher_creates_RobolectricGoldenWatcher(self):
+        golden_watcher = GoldenWatcherFactory.create_watcher(GoldenWatcherTypes.ROBOLECTRIC, "tmp")
+        self.assertEqual(golden_watcher.temp_dir, "tmp")
+        self.assertEqual(golden_watcher.latest_dir, f"/tmp/motion/")
+
+    @patch('impl.golden_watchers.golden_watcher_factory.GoldenFileWatcher', new=FakeGoldenFileWatcher)
+    def test_create_watcher_creates_GoldenFileWatcher(self):
+        fake_adb_client = FakeADBClient()
+        golden_watcher = GoldenWatcherFactory.create_watcher(GoldenWatcherTypes.FILE, "tmp", fake_adb_client)
+        self.assertEqual(golden_watcher.temp_dir, "tmp")
+        self.assertEqual(golden_watcher.adb_client, fake_adb_client)
+
+    def test_create_watcher_fails_creating_GoldenFileWatcher(self):
+        with self.assertRaises(ValueError) as e:
+            GoldenWatcherFactory.create_watcher(GoldenWatcherTypes.FILE, "tmp")
+        self.assertEqual(e.exception.args[0], "adb client not found")
+
+    def test_create_watcher_fails_for_unknown_type(self):
+        with self.assertRaises(ValueError) as e:
+            GoldenWatcherFactory.create_watcher("Unknown", "tmp")
+        self.assertEqual(e.exception.args[0], "Imporper Golden Watcher Type.")
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/test_impl/robolectric_golden_watcher_test.py b/libraries/motion/golden_updater/tests/test_impl/robolectric_golden_watcher_test.py
new file mode 100644
index 000000000..703bbca3e
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/test_impl/robolectric_golden_watcher_test.py
@@ -0,0 +1,115 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import patch, Mock, call
+import sys
+import os
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
+from impl.golden_watchers.robolectric_golden_watcher import RobolectricGoldenWatcher
+from test_assets.test_assets import *
+from test_assets.fake_cached_golden import FakeCachedGolden
+from test_assets.fake_golden import FakeGolden
+
+class RobolectricGoldenWatcherTest(unittest.TestCase):
+
+  @patch.object(RobolectricGoldenWatcher, 'refresh_golden_files')
+  def test_init(self, mock_refresh_golden_files):
+    watcher = RobolectricGoldenWatcher(temp_dir, atest_latest_dir)
+    mock_refresh_golden_files.assert_called_once()
+    self.assertEqual(watcher.temp_dir, temp_dir)
+    self.assertEqual(watcher.latest_dir, atest_latest_dir)
+    self.assertEqual(watcher.cached_goldens, {})
+
+  @patch('glob.iglob')
+  @patch.object(RobolectricGoldenWatcher, 'copy_file')
+  @patch('hashlib.md5')
+  def test_refresh_golden_files(self, mock_hash_func, mock_copy_file, mock_iglob):
+    mock_iglob.return_value = [fileNameG]
+    mock_hash = Mock()
+    mock_hash_func.return_value = mock_hash
+    mock_hash.hexdigest.return_value = time_hash_value
+    fake_cached_golden = FakeCachedGolden()
+    golden=FakeGolden()
+    fake_cached_golden.goldens.append(golden)
+
+    #Not invoking refresh_golden_files explicitly as it is being called in the constructor
+    watcher = RobolectricGoldenWatcher(temp_dir, atest_latest_dir, fake_cached_golden)
+
+    mock_iglob.assert_called_once_with(f"{watcher.latest_dir}//**/*.actual.json", recursive=True)
+    mock_hash_func.assert_called_once()
+    mock_copy_file.assert_called_once_with(fileNameG, localFileG)
+    self.assertEqual(
+      fake_cached_golden.calls,
+      [[fileNameG, localFileG]]
+    )
+    self.assertEqual(watcher.cached_goldens[fileNameG], golden)
+
+  @patch('glob.iglob')
+  @patch.object(RobolectricGoldenWatcher, 'copy_file')
+  @patch('hashlib.md5')
+  @patch('os.path.isfile')
+  def test_refresh_golden_files_with_video_file(self, mock_is_file, mock_hash_func, mock_copy_file, mock_iglob):
+    mock_is_file.return_value = True
+    mock_iglob.return_value = [fileNameG]
+    mock_hash = Mock()
+    mock_hash_func.return_value = mock_hash
+    mock_hash.hexdigest.return_value = time_hash_value
+    fake_cached_golden = FakeCachedGolden()
+    golden=FakeGolden(video_location3, test_class_name=test_class_name)
+    fake_cached_golden.goldens.append(golden)
+
+    #Not invoking refresh_golden_files explicitly as it is being called in the constructor
+    watcher = RobolectricGoldenWatcher(temp_dir, atest_latest_dir, fake_cached_golden)
+
+    mock_iglob.assert_called_once_with(f"{atest_latest_dir}//**/*.actual.json", recursive=True)
+    mock_hash_func.assert_called_once()
+
+    mock_copy_file.assert_has_calls(
+      [
+        call(fileNameG, localFileG),
+        call(robo_video_file_path, f"{temp_dir}/{video_location3}")
+      ]
+    )
+    self.assertEqual(
+      fake_cached_golden.calls,
+      [[fileNameG, localFileG]]
+    )
+    self.assertEqual(watcher.cached_goldens[fileNameG], golden)
+    mock_is_file.assert_called_once_with(robo_video_file_path)
+
+
+  @patch('shutil.copyfile')
+  @patch.object(RobolectricGoldenWatcher, 'refresh_golden_files')
+  def test_copy_file(self, _, mock_copy):
+    sourceFile = 'sourceFile.json'
+    targetFile = '/tmp/LATEST/targetFile.json'
+
+    studioWatcher = RobolectricGoldenWatcher(temp_dir, atest_latest_dir)
+    studioWatcher.copy_file(sourceFile, targetFile)
+
+    self.assertTrue(os.path.isdir('/tmp/LATEST/'))
+    mock_copy.assert_called_once_with(sourceFile, targetFile)
+
+  @patch.object(RobolectricGoldenWatcher, 'refresh_golden_files')
+  def test_clean(self, _):
+    studioWatcher = RobolectricGoldenWatcher(temp_dir, atest_latest_dir)
+    studioWatcher.cached_goldens = {"a": 1}
+    studioWatcher.clean()
+    self.assertEqual(studioWatcher.cached_goldens, {})
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/test_impl/zip_to_video_converter_test.py b/libraries/motion/golden_updater/tests/test_impl/zip_to_video_converter_test.py
new file mode 100644
index 000000000..9517a5366
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/test_impl/zip_to_video_converter_test.py
@@ -0,0 +1,253 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+import os
+import shutil
+import subprocess
+import sys
+import tempfile
+import unittest
+import zipfile
+from pathlib import Path
+from unittest import mock
+from unittest.mock import patch, mock_open
+from zipfile import ZipFile
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
+from impl.zip_to_video_converter import ZipToVideoConverter
+
+
+class TestZipToVideoConverter(unittest.TestCase):
+
+    def setUp(self):
+        self.converter = ZipToVideoConverter()
+        self.temp_dir = Path(tempfile.mkdtemp())
+        self.zip_file_path = self.temp_dir / "test.zip"
+        self.final_video_path = self.temp_dir / "final_test.mp4"
+        self.video_file_path = self.temp_dir / "test.mp4"
+
+    def tearDown(self):
+        shutil.rmtree(self.temp_dir)
+
+    def create_test_zip(self, png_files, with_dotdots=False, with_absolute_paths=False):
+        with zipfile.ZipFile(self.zip_file_path, 'w') as zipf:
+            for filename in png_files:
+                file_content = b"Test file"
+                if with_dotdots:
+                    filename = f"../{filename}"
+                if with_absolute_paths:
+                    filename = f"/{filename}"
+                zipf.writestr(filename, file_content)
+
+    def test_extract_pngs_valid_zip(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        extracted_count = self.converter.extract_pngs(self.zip_file_path, self.temp_dir, self.zip_file_path)
+        self.assertEqual(extracted_count, 3)
+        for i in range(1,4):
+          self.assertTrue((self.temp_dir / f"image_{i:04d}.png").exists())
+
+    def test_extract_pngs_no_pngs(self):
+        self.create_test_zip([])
+        extracted_count = self.converter.extract_pngs(self.zip_file_path, self.temp_dir, self.zip_file_path)
+        self.assertEqual(extracted_count, 0)
+
+    def test_extract_pngs_invalid_zip(self):
+        with open(self.zip_file_path, 'w') as f:
+            f.write("This is not a valid zip file")
+        extracted_count = self.converter.extract_pngs(self.zip_file_path, self.temp_dir, self.zip_file_path)
+        self.assertEqual(extracted_count, -1)
+
+    def test_extract_pngs_ignore_dotdots(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png"], with_dotdots=True)
+        self.create_test_zip(["image_0003.png"], with_dotdots=False)
+        extracted_count = self.converter.extract_pngs(self.zip_file_path, self.temp_dir, self.zip_file_path)
+        self.assertEqual(extracted_count, 1)
+        self.assertTrue((self.temp_dir / "image_0003.png").exists())
+        self.assertFalse((self.temp_dir / "../image_0001.png").exists())
+        self.assertFalse((self.temp_dir / "../image_0002.png").exists())
+
+    def test_extract_pngs_ignore_absolute_paths(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png"], with_absolute_paths=True)
+        self.create_test_zip(["image_0003.png"], with_absolute_paths=False)
+        extracted_count = self.converter.extract_pngs(self.zip_file_path, self.temp_dir, self.zip_file_path)
+        self.assertEqual(extracted_count, 1)
+        self.assertTrue((self.temp_dir / "image_0003.png").exists())
+        self.assertFalse((self.temp_dir / "/image_0001.png").exists())
+        self.assertFalse((self.temp_dir / "/image_0002.png").exists())
+
+    @patch('subprocess.run')
+    def test_run_ffmpeg_success(self, mock_run):
+        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)
+        with open(self.temp_dir / "test.mp4", "w") as f:
+            f.write("test video")
+        result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+        self.assertTrue(result)
+
+    def create_dummy_png(self, filename):
+        # Create a simple 1x1 grayscale PNG using raw bytes
+        png_bytes = b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x00\x00\x00\x00:~\x9bU\x00\x00\x00\nIDATx\x9cc\xfc\xff\x03\x00\x00\x02\x00\x01\xd4\x00\x0c\x00\x00\x00\x00IEND\xaeB`\x82"
+        with open(self.temp_dir / filename, "wb") as f:
+            f.write(png_bytes)
+
+    @patch('subprocess.run')
+    def test_run_ffmpeg_success(self, mock_run):
+        mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)
+        with open(self.temp_dir / "test.mp4", "w") as f:
+            f.write("test video")
+        result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+        self.assertTrue(result)
+
+    def test_run_ffmpeg_success(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        for i in range(1,4):
+            self.create_dummy_png(f"image_{i:04d}.png")
+
+        try:
+            subprocess.run([ZipToVideoConverter.FFMPEG_PATH, "-version"], check=True, capture_output=True)
+        except (FileNotFoundError, subprocess.CalledProcessError):
+            self.skipTest(f"ffmpeg executable not found or not working: '{ZipToVideoConverter.FFMPEG_PATH}'. Skipping integration test.")
+            return
+
+        # Run ffmpeg and assert that it returns True
+        result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+        self.assertTrue(result)
+        self.assertTrue((self.temp_dir / "test.mp4").exists())
+
+    def test_run_ffmpeg_failure(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+
+        for i in range(1, 4):
+            self.create_dummy_png(f"image_{i:04d}.png")
+
+        try:
+            subprocess.run([ZipToVideoConverter.FFMPEG_PATH, "-version"], check=True, capture_output=True)
+        except (FileNotFoundError, subprocess.CalledProcessError):
+            self.skipTest(f"ffmpeg executable not found or not working: '{ZipToVideoConverter.FFMPEG_PATH}'. Skipping integration test.")
+            return
+
+        # Run ffmpeg with an invalid frame rate to force a failure
+        # Invalid frame rate will cause ffmpeg to fail
+        ZipToVideoConverter.FRAME_RATE = "invalid"
+
+        result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+        self.assertFalse(result)
+        self.assertFalse((self.temp_dir / "test.mp4").exists())
+        # Reset the frame rate to original value.
+        ZipToVideoConverter.FRAME_RATE = "62.5"
+
+    def test_run_ffmpeg_no_ffmpeg(self):
+        # Simulate a situation where ffmpeg is not found
+        with patch('subprocess.run', side_effect=FileNotFoundError):
+            result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+            self.assertFalse(result)
+
+    def test_run_ffmpeg_no_output(self):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+
+        for i in range(1, 4):
+            self.create_dummy_png(f"image_{i:04d}.png")
+
+        # Check if ffmpeg is available. If not, skip the test.
+        try:
+            subprocess.run([ZipToVideoConverter.FFMPEG_PATH, "-version"], check=True, capture_output=True)
+        except (FileNotFoundError, subprocess.CalledProcessError):
+            self.skipTest(f"ffmpeg executable not found or not working: '{ZipToVideoConverter.FFMPEG_PATH}'. Skipping integration test.")
+            return
+
+        # Mock subprocess.run to simulate a successful ffmpeg run, but without creating an output file
+        with patch('subprocess.run') as mock_run:
+            mock_run.return_value = subprocess.CompletedProcess(args=[], returncode=0)
+            result = self.converter.run_ffmpeg(self.temp_dir, self.temp_dir / "test.mp4", self.zip_file_path)
+        # Assert that run_ffmpeg returns False, because the output file is not present
+            self.assertFalse(result)
+
+    def test_move_video_success(self):
+        with open(self.video_file_path, "w") as f:
+            f.write("test video")
+        result = self.converter.move_video(self.video_file_path, self.final_video_path, self.zip_file_path)
+        self.assertTrue(result)
+        self.assertTrue(self.final_video_path.exists())
+        self.assertFalse((self.video_file_path).exists())
+
+    def test_move_video_no_file(self):
+        result = self.converter.move_video(self.video_file_path, self.final_video_path, self.zip_file_path)
+        self.assertFalse(result)
+
+    def test_move_video_destination_exists(self):
+        with open(self.video_file_path, "w") as f:
+            f.write("temp video")
+        final_video_path = self.final_video_path
+        with open(final_video_path, "w") as f:
+            f.write("existing video")
+
+        result = self.converter.move_video(self.video_file_path, final_video_path, self.zip_file_path)
+        self.assertTrue(result)
+        self.assertTrue(final_video_path.exists())
+        with open(final_video_path, "r") as f:
+          self.assertEqual(f.read(), "temp video")
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', return_value=3)
+    @patch.object(ZipToVideoConverter, 'run_ffmpeg', return_value=True)
+    @patch.object(ZipToVideoConverter, 'move_video', return_value=True)
+    def test_process_single_zip_success(self, mock_move_video, mock_run_ffmpeg, mock_extract_pngs):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertTrue(result)
+        mock_extract_pngs.assert_called_once()
+        mock_run_ffmpeg.assert_called_once()
+        mock_move_video.assert_called_once()
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', return_value=-1)
+    def test_process_single_zip_extract_fails(self, mock_extract_pngs):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertFalse(result)
+        mock_extract_pngs.assert_called_once()
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', return_value=3)
+    @patch.object(ZipToVideoConverter, 'run_ffmpeg', return_value=False)
+    def test_process_single_zip_ffmpeg_fails(self, mock_run_ffmpeg, mock_extract_pngs):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertFalse(result)
+        mock_extract_pngs.assert_called_once()
+        mock_run_ffmpeg.assert_called_once()
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', return_value=3)
+    @patch.object(ZipToVideoConverter, 'run_ffmpeg', return_value=True)
+    @patch.object(ZipToVideoConverter, 'move_video', return_value=False)
+    def test_process_single_zip_move_fails(self, mock_move_video, mock_run_ffmpeg, mock_extract_pngs):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertFalse(result)
+        mock_extract_pngs.assert_called_once()
+        mock_run_ffmpeg.assert_called_once()
+        mock_move_video.assert_called_once()
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', return_value=0)
+    def test_process_single_zip_no_pngs(self, mock_extract_pngs):
+        self.create_test_zip([])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertTrue(result)
+        mock_extract_pngs.assert_called_once()
+
+    @patch.object(ZipToVideoConverter, 'extract_pngs', side_effect=Exception("Test Exception"))
+    def test_process_single_zip_exception(self, mock_extract_pngs):
+        self.create_test_zip(["image_0001.png", "image_0002.png", "image_0003.png"])
+        result = self.converter.process_single_zip(self.zip_file_path)
+        self.assertFalse(result)
+        mock_extract_pngs.assert_called_once()
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/tests/token_generator_test.py b/libraries/motion/golden_updater/tests/token_generator_test.py
new file mode 100644
index 000000000..7328d41d0
--- /dev/null
+++ b/libraries/motion/golden_updater/tests/token_generator_test.py
@@ -0,0 +1,71 @@
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+from unittest.mock import patch, mock_open, call
+import sys
+import os
+
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+from test_assets.test_assets import MOCK_TOKEN_LOCATION
+from impl.token_generator import TokenGenerator
+
+class TokenGeneratorTest(unittest.TestCase):
+
+  @patch("builtins.open", new_callable=mock_open, read_data="found_token")
+  @patch('impl.token_generator.GOLDEN_ACCESS_TOKEN_LOCATION', new=MOCK_TOKEN_LOCATION)
+  def test_get_token(self, mock_open_func):
+    self.assertEqual(TokenGenerator.get_token(), "found_token")
+    mock_open_func.assert_called_once_with(MOCK_TOKEN_LOCATION, "r")
+
+  @patch("builtins.open")
+  @patch('secrets.token_hex')
+  @patch('os.chmod')
+  @patch('impl.token_generator.GOLDEN_ACCESS_TOKEN_LOCATION', new=MOCK_TOKEN_LOCATION)
+  def test_get_token_throws_error_on_reading(self, mock_chmod, mock_secret, mock_open_func):
+    mock_write_file = mock_open()
+
+    mock_open_func.side_effect = [FileNotFoundError, mock_write_file.return_value]
+    mock_secret.return_value = "super_secret_key"
+
+    token = TokenGenerator.get_token()
+    self.assertTrue(os.path.isdir(os.path.dirname(MOCK_TOKEN_LOCATION)))
+    mock_open_func.assert_has_calls(
+      [
+        call(MOCK_TOKEN_LOCATION, "r"),
+        call(MOCK_TOKEN_LOCATION, "w")
+      ]
+    )
+    mock_chmod.assert_called_once_with(MOCK_TOKEN_LOCATION, 0o600)
+    self.assertEqual(token, "super_secret_key")
+
+
+  @patch("builtins.open")
+  @patch('secrets.token_hex')
+  @patch('impl.token_generator.GOLDEN_ACCESS_TOKEN_LOCATION', new=MOCK_TOKEN_LOCATION)
+  def test_get_token_throws_error_on_reading_and_writing(self, mock_secret, mock_open_func):
+    mock_open_func.side_effect = [FileNotFoundError, PermissionError]
+    mock_secret.return_value = "super_secret_key"
+
+    self.assertEqual(TokenGenerator.get_token(), "super_secret_key")
+    mock_open_func.assert_has_calls(
+      [
+        call(MOCK_TOKEN_LOCATION, "r"),
+        call(MOCK_TOKEN_LOCATION, "w")
+      ]
+    )
+
+if __name__ == '__main__':
+  unittest.main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/watch_local_tests.py b/libraries/motion/golden_updater/watch_local_tests.py
index 8f4f17f6a..07aae370a 100755
--- a/libraries/motion/golden_updater/watch_local_tests.py
+++ b/libraries/motion/golden_updater/watch_local_tests.py
@@ -16,96 +16,41 @@
 # limitations under the License.
 #
 
-import http.server
 import socketserver
-import json
-import re
-import urllib.parse
-from os import path
-import socket
-import argparse
 import os
 import subprocess
 import sys
 import tempfile
 import webbrowser
-import mimetypes
-import hashlib
-import shutil
-import secrets
-import datetime
-import glob
-import gzip
-
-
-from collections import defaultdict
-
+from impl.golden_watchers.golden_watcher_factory import GoldenWatcherFactory
+from impl.golden_watchers.golden_watcher_types import GoldenWatcherTypes
+from impl.adb_client import AdbClient
+from impl.watch_web_app_request_handler import WatchWebAppRequestHandler
+from impl.argument_parser import ArgumentParser
+from impl.token_generator import TokenGenerator
 
 def main():
-    parser = argparse.ArgumentParser(
-        "Watches a connected device for golden file updates."
-    )
-
-    parser.add_argument(
-        "--port",
-        default=find_free_port(),
-        type=int,
-        help="Port to run test at watcher web UI on.",
-    )
-
-    parser.add_argument(
-        "--atest",
-        default=False,
-        help="Watches atest output",
-    )
-
-    parser.add_argument(
-         "--studioTest",
-         default=False,
-         help="Watch for artifacs generated when a deviceless test is run via SysUi Studio",
-    )
-
-    parser.add_argument(
-        "--serial",
-        default=os.environ.get("ANDROID_SERIAL"),
-        help="The ADB device serial to pull goldens from.",
-    )
 
-    parser.add_argument(
-        "--android_build_top",
-        default=os.environ.get("ANDROID_BUILD_TOP"),
-        help="The root directory of the android checkout.",
-    )
-
-    parser.add_argument(
-        "--client_url",
-        default="http://motion.teams.x20web.corp.google.com/",
-        help="The URL where the client app is deployed.",
-    )
-
-    args = parser.parse_args()
+    args = ArgumentParser.get_args()
 
     if args.android_build_top is None or not os.path.exists(args.android_build_top):
         print("ANDROID_BUILD_TOP not set. Have you sourced envsetup.sh?")
         sys.exit(1)
 
-    global android_build_top
     android_build_top = args.android_build_top
 
     with tempfile.TemporaryDirectory() as tmpdir:
-        global golden_watcher, this_server_address
 
         if args.atest:
             print("ATEST is running.")
-            user = os.environ.get("USER")
-            golden_watcher = AtestGoldenWatcher(
-                tmpdir, f"/tmp/atest_result_{user}/LATEST/"
+            golden_watcher = GoldenWatcherFactory.create_watcher(
+                GoldenWatcherTypes.ATEST,tmpdir
             )
 
-        elif args.studioTest:
+        elif args.robolectricTest:
             print("Running for devicess sysui studio test")
-            golden_watcher = StudioGoldenWatcher(
-                tmpdir, f"/tmp/motion/"
+            golden_watcher = GoldenWatcherFactory.create_watcher(
+                GoldenWatcherTypes.ROBOLECTRIC, tmpdir
             )
         else:
             serial = args.serial
@@ -128,10 +73,16 @@ def main():
             adb_client = AdbClient(serial)
             if not adb_client.run_as_root():
                 sys.exit(1)
-            golden_watcher = GoldenFileWatcher(tmpdir, adb_client)
+            golden_watcher = GoldenWatcherFactory.create_watcher(GoldenWatcherTypes.FILE, tmpdir, adb_client)
 
         this_server_address = f"http://localhost:{args.port}"
 
+        secret_token = TokenGenerator.get_token()
+        WatchWebAppRequestHandler.secret_token = secret_token
+        WatchWebAppRequestHandler.android_build_top = android_build_top
+        WatchWebAppRequestHandler.golden_watcher = golden_watcher
+        WatchWebAppRequestHandler.this_server_address = this_server_address
+
         with socketserver.TCPServer(
             ("localhost", args.port), WatchWebAppRequestHandler, golden_watcher
         ) as httpd:
@@ -145,435 +96,6 @@ def main():
                 print("Shutting down")
 
 
-GOLDEN_ACCESS_TOKEN_HEADER = "Golden-Access-Token"
-GOLDEN_ACCESS_TOKEN_LOCATION = os.path.expanduser("~/.config/motion-golden/.token")
-
-secret_token = None
-android_build_top = None
-golden_watcher = None
-this_server_address = None
-
-
-class WatchWebAppRequestHandler(http.server.BaseHTTPRequestHandler):
-
-    def __init__(self, *args, **kwargs):
-        self.root_directory = path.abspath(path.dirname(__file__))
-        super().__init__(*args, **kwargs)
-
-    def verify_access_token(self):
-        token = self.headers.get(GOLDEN_ACCESS_TOKEN_HEADER)
-        if not token or token != secret_token:
-            self.send_response(403, "Bad authorization token!")
-            return False
-
-        return True
-
-    def do_OPTIONS(self):
-        self.send_response(200)
-        self.send_header("Allow", "GET,POST,PUT")
-        self.add_standard_headers()
-        self.end_headers()
-        self.wfile.write(b"GET,POST,PUT")
-
-    def do_GET(self):
-
-        parsed = urllib.parse.urlparse(self.path)
-
-        if parsed.path == "/service/list":
-            self.service_list_goldens()
-            return
-        elif parsed.path.startswith("/golden/"):
-            requested_file_start_index = parsed.path.find("/", len("/golden/") + 1)
-            requested_file = parsed.path[requested_file_start_index + 1 :]
-            self.serve_file(golden_watcher.temp_dir, requested_file)
-            return
-        elif parsed.path.startswith("/expected/"):
-            golden_id = parsed.path[len("/expected/") :]
-
-            goldens = golden_watcher.cached_goldens.values()
-            for golden in goldens:
-                if golden.id != golden_id:
-                    continue
-
-                self.serve_file(
-                    android_build_top, golden.golden_repo_path, "application/json"
-                )
-                return
-
-        self.send_error(404)
-
-    def do_POST(self):
-        if not self.verify_access_token():
-            return
-
-        content_type = self.headers.get("Content-Type")
-
-        # refuse to receive non-json content
-        if content_type != "application/json":
-            self.send_response(400)
-            return
-
-        length = int(self.headers.get("Content-Length"))
-        message = json.loads(self.rfile.read(length))
-
-        parsed = urllib.parse.urlparse(self.path)
-        if parsed.path == "/service/refresh":
-            self.service_refresh_goldens(message["clear"])
-        else:
-            self.send_error(404)
-
-    def do_PUT(self):
-        if not self.verify_access_token():
-            return
-
-        parsed = urllib.parse.urlparse(self.path)
-        query_params = urllib.parse.parse_qs(parsed.query)
-
-        if parsed.path == "/service/update":
-            self.service_update_golden(query_params["id"][0])
-        else:
-            self.send_error(404)
-
-    def serve_file(self, root_directory, file_relative_to_root, mime_type=None):
-        resolved_path = path.abspath(path.join(root_directory, file_relative_to_root))
-
-        if path.commonprefix(
-            [resolved_path, root_directory]
-        ) == root_directory and path.isfile(resolved_path):
-            self.send_response(200)
-            self.send_header(
-                "Content-type", mime_type or mimetypes.guess_type(resolved_path)[0]
-            )
-            self.add_standard_headers()
-            self.end_headers()
-            with open(resolved_path, "rb") as f:
-                self.wfile.write(f.read())
-
-        else:
-            self.send_error(404)
-
-    def service_list_goldens(self):
-        if not self.verify_access_token():
-            return
-
-        goldens_list = []
-
-        for golden in golden_watcher.cached_goldens.values():
-
-            golden_data = {}
-            golden_data["id"] = golden.id
-            golden_data["result"] = golden.result
-            golden_data["label"] = golden.golden_identifier
-            golden_data["goldenRepoPath"] = golden.golden_repo_path
-            golden_data["updated"] = golden.updated
-            golden_data["testClassName"] = golden.test_class_name
-            golden_data["testMethodName"] = golden.test_method_name
-            golden_data["testTime"] = golden.test_time
-
-            golden_data["actualUrl"] = (
-                f"{this_server_address}/golden/{golden.checksum}/{golden.local_file[len(golden_watcher.temp_dir) + 1 :]}"
-            )
-            expected_file = path.join(android_build_top, golden.golden_repo_path)
-            if os.path.exists(expected_file):
-                golden_data["expectedUrl"] = (
-                    f"{this_server_address}/expected/{golden.id}"
-                )
-
-            golden_data["videoUrl"] = (
-                f"{this_server_address}/golden/{golden.checksum}/{golden.video_location}"
-            )
-
-            goldens_list.append(golden_data)
-
-        self.send_json(goldens_list)
-
-    def service_refresh_goldens(self, clear):
-        if clear:
-            golden_watcher.clean()
-        golden_watcher.refresh_golden_files()
-        self.service_list_goldens()
-
-    def service_update_golden(self, id):
-        goldens = golden_watcher.cached_goldens.values()
-        for golden in goldens:
-            if golden.id != id:
-                print("skip", golden.id)
-                continue
-
-            dst = path.join(android_build_top, golden.golden_repo_path)
-            if not path.exists(path.dirname(dst)):
-                os.makedirs(path.dirname(dst))
-
-            shutil.copyfile(golden.local_file, dst)
-
-            golden.updated = True
-            self.send_json({"result": "OK"})
-            return
-
-        self.send_error(400)
-
-    def send_json(self, data):
-        # Replace this with code that generates your JSON data
-        data_encoded = json.dumps(data).encode("utf-8")
-        self.send_response(200)
-        self.send_header("Content-type", "application/json")
-        self.add_standard_headers()
-        self.end_headers()
-        self.wfile.write(data_encoded)
-
-    def add_standard_headers(self):
-        self.send_header("Access-Control-Allow-Origin", "*")
-        self.send_header("Access-Control-Allow-Methods", "POST, PUT, GET, OPTIONS")
-        self.send_header(
-            "Access-Control-Allow-Headers",
-            GOLDEN_ACCESS_TOKEN_HEADER
-            + ", Content-Type, Content-Length, Range, Accept-ranges",
-        )
-        # Accept-ranges: bytes is needed for chrome to allow seeking the
-        # video. At this time, won't handle ranges on subsequent gets,
-        # but that is likely OK given the size of these videos and that
-        # its local only.
-        self.send_header("Accept-ranges", "bytes")
-
-
-class GoldenFileWatcher:
-
-    def __init__(self, temp_dir, adb_client):
-        self.temp_dir = temp_dir
-        self.adb_client = adb_client
-
-        # name -> CachedGolden
-        self.cached_goldens = {}
-        self.refresh_golden_files()
-
-    def clean(self):
-        self.cached_goldens = {}
-
-    def refresh_golden_files(self):
-        command = f"find /data/user/0/ -type f -name *.actual.json"
-        updated_goldens = self.run_adb_command(["shell", command]).splitlines()
-        print(f"Updating goldens - found {len(updated_goldens)} files")
-
-        for golden_remote_file in updated_goldens:
-            local_file = self.adb_pull(golden_remote_file)
-
-            golden = CachedGolden(golden_remote_file, local_file)
-            if golden.video_location:
-                self.adb_pull_image(golden.device_local_path, golden.video_location)
-
-            self.cached_goldens[golden_remote_file] = golden
-
-    def adb_pull(self, remote_file):
-        baseName = os.path.basename(remote_file)
-        filename, ext = os.path.splitext(baseName)
-        remoteFilenameHash = hashlib.md5(remote_file.encode("utf-8")).hexdigest()
-        local_file = os.path.join(self.temp_dir, f'{filename}_{remoteFilenameHash}{ext}')
-        self.run_adb_command(["pull", remote_file, local_file])
-        self.run_adb_command(["shell", "rm", remote_file])
-        return local_file
-
-    def adb_pull_image(self, remote_dir, remote_file):
-        remote_path = os.path.join(remote_dir, remote_file)
-        local_path = os.path.join(self.temp_dir, remote_file)
-        os.makedirs(os.path.dirname(local_path), exist_ok=True)
-        self.run_adb_command(["pull", remote_path, local_path])
-        self.run_adb_command(["shell", "rm", remote_path])
-        return local_path
-
-    def run_adb_command(self, args):
-        return self.adb_client.run_adb_command(args)
-
-
-class StudioGoldenWatcher:
-
-    def __init__(self, temp_dir, latest_dir):
-        self.temp_dir = temp_dir
-        self.latest_dir = latest_dir
-        self.cached_goldens = {}
-        self.refresh_golden_files()
-
-    def refresh_golden_files(self):
-        for filename in glob.iglob(
-            f"{self.latest_dir}//**/*.actual.json", recursive=True
-        ):
-            baseName = os.path.basename(filename)
-            baseFilename, ext = os.path.splitext(baseName)
-            timeHash = hashlib.md5(datetime.datetime.now().isoformat().encode("utf-8")).hexdigest()
-            local_file = os.path.join(self.temp_dir, f'copy_{baseFilename}_{timeHash}{ext}')
-            self.copy_file(filename, local_file)
-            golden = CachedGolden(filename, local_file)
-            self.cached_goldens[filename] = golden
-
-    def copy_file(self, source, target):
-        os.makedirs(os.path.dirname(target), exist_ok=True)
-        shutil.copyfile(source, target)
-
-    def clean(self):
-        self.cached_goldens = {}
-
-class AtestGoldenWatcher:
-
-    def __init__(self, temp_dir, atest_latest_dir):
-        self.temp_dir = temp_dir
-        self.atest_latest_dir = atest_latest_dir
-
-        # name -> CachedGolden
-        self.cached_goldens = {}
-        self.refresh_golden_files()
-
-    def clean(self):
-        self.cached_goldens = {}
-
-    def refresh_golden_files(self):
-
-        # Atest writes the files with a wide variety of filenames. Examples
-        # log/stub/local_atest/inv_8184127433410125702/light_portrait_pagingRight.actual.json_4383267726505225616.txt.gz
-        # log/invocation_3042186109657619915/inv_5155363728971335727/recordMotion_captureCrossfade.actual_10536896158799342698.json
-        # log/stub/local_atest/inv_6860054371355660320/light_portrait_noOverscrollRight.actual_118505410949600545.json.gz
-
-        # log/stub/local_atest/inv_6860054371355660320/light_portrait_noOverscrollRight.actual_12613191689435798576.mp4
-        # log/invocation_3042186109657619915/inv_5155363728971335727/recordMotion_captureCrossfade.actual_1988198704080929506.mp4
-        # log/stub/local_atest/inv_8184127433410125702/light_portrait_pagingRight.actual.mp4_1617964025478041468.txt.gz
-
-        pattern_type = (
-            r".*/(?P<name>.*)\.actual((\.(?P<ext1>[a-zA-Z0-9]+)_(?P<hash1>\d+)\.txt)|(_(?P<hash2>\d+)\.(?P<ext2>[a-zA-Z0-9]+)))(?P<compressed>\.gz)?"
-        )
-
-        # Output from on-device runs
-        # Modifying the search regex to handle files not ending with json as given above.
-        for filename in glob.iglob(
-            f"{self.atest_latest_dir}//**/*.actual*json*", recursive=True
-        ):
-
-            match = re.search(pattern_type, filename)
-
-            if not match:
-                continue
-
-            golden_name = match.group("name")
-            ext = match.group("ext1") or match.group("ext2")
-            hash = match.group("hash1") or match.group("hash2")
-            is_compressed = match.group("compressed") == ".gz"
-
-            local_file = os.path.join(self.temp_dir, f"{golden_name}_{hash}.actual.json")
-            self.copy_file(filename, local_file, is_compressed)
-            golden = CachedGolden(filename, local_file)
-
-            if golden.video_location:
-                for video_filename in glob.iglob(
-                    f"{self.atest_latest_dir}/**/{golden_name}.actual*.mp4*",
-                    recursive=True,
-                ):
-
-                    local_video_file = os.path.join(
-                        self.temp_dir, golden.video_location
-                    )
-                    video_is_compressed = video_filename.endswith(".gz")
-                    self.copy_file(
-                        video_filename, local_video_file, video_is_compressed
-                    )
-
-                    break
-
-            self.cached_goldens[filename] = golden
-
-    def copy_file(self, source, target, is_compressed):
-        os.makedirs(os.path.dirname(target), exist_ok=True)
-
-        if is_compressed:
-            with gzip.open(source, "rb") as f_in:
-                with open(target, "wb") as f_out:
-                    shutil.copyfileobj(f_in, f_out)
-        else:
-            shutil.copyfile(source, target)
-
-class CachedGolden:
-
-    def __init__(self, remote_file, local_file):
-        self.id = hashlib.md5(remote_file.encode("utf-8")).hexdigest()
-        self.remote_file = remote_file
-        self.local_file = local_file
-        self.updated = False
-        self.test_time = datetime.datetime.now().isoformat()
-        # Checksum is the time the test data was loaded, forcing unique URLs
-        # every time the golden is reloaded
-        self.checksum = hashlib.md5(self.test_time.encode("utf-8")).hexdigest()
-
-        motion_golden_data = None
-        with open(local_file, "r") as json_file:
-            motion_golden_data = json.load(json_file)
-        metadata = motion_golden_data["//metadata"]
-
-        self.result = metadata["result"]
-        self.golden_repo_path = metadata["goldenRepoPath"]
-        self.golden_identifier = metadata["goldenIdentifier"]
-        self.test_class_name = metadata["testClassName"]
-        self.test_method_name = metadata["testMethodName"]
-        self.device_local_path = metadata["deviceLocalPath"]
-        self.video_location = None
-        if "videoLocation" in metadata:
-            self.video_location = metadata["videoLocation"]
-
-        with open(local_file, "w") as json_file:
-            del motion_golden_data["//metadata"]
-            json.dump(motion_golden_data, json_file, indent=2)
-
-
-class AdbClient:
-    def __init__(self, adb_serial):
-        self.adb_serial = adb_serial
-
-    def run_as_root(self):
-        root_result = self.run_adb_command(["root"])
-        if "restarting adbd as root" in root_result:
-            self.wait_for_device()
-            return True
-        if "adbd is already running as root" in root_result:
-            return True
-
-        print(f"run_as_root returned [{root_result}]")
-
-        return False
-
-    def wait_for_device(self):
-        self.run_adb_command(["wait-for-device"])
-
-    def run_adb_command(self, args):
-        command = ["adb"]
-        command += ["-s", self.adb_serial]
-        command += args
-        return subprocess.run(command, check=True, capture_output=True).stdout.decode(
-            "utf-8"
-        )
-
-
-def find_free_port():
-    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-        s.bind(("", 0))  # Bind to a random free port provided by the OS
-        return s.getsockname()[1]  # Get the port number
-
-
-def get_token() -> str:
-    try:
-        with open(GOLDEN_ACCESS_TOKEN_LOCATION, "r") as token_file:
-            token = token_file.readline()
-            return token
-    except IOError:
-        token = secrets.token_hex(32)
-        os.makedirs(os.path.dirname(GOLDEN_ACCESS_TOKEN_LOCATION), exist_ok=True)
-        try:
-            with open(GOLDEN_ACCESS_TOKEN_LOCATION, "w") as token_file:
-                token_file.write(token)
-            os.chmod(GOLDEN_ACCESS_TOKEN_LOCATION, 0o600)
-        except IOError:
-            print(
-                "Unable to save persistent token {} to {}".format(
-                    token, GOLDEN_ACCESS_TOKEN_LOCATION
-                )
-            )
-        return token
-
 
 if __name__ == "__main__":
-    secret_token = get_token()
-    main()
+    main()
\ No newline at end of file
diff --git a/libraries/motion/golden_updater/watch_local_tests_test.py b/libraries/motion/golden_updater/watch_local_tests_test.py
new file mode 100755
index 000000000..1254d0ff9
--- /dev/null
+++ b/libraries/motion/golden_updater/watch_local_tests_test.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+#
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import subprocess
+import os
+import glob
+import sys
+
+base_path = os.path.dirname(__file__)
+
+def main():
+  for filename in glob.iglob(
+      f"{base_path}/tests/**/*test.py", recursive=True
+  ):
+    result = run_script(filename)
+    if result:
+        print(result.stdout)
+        print(result.stderr)
+
+def run_script(script_path, *args):
+    """Runs a Python script and returns its output."""
+    try:
+        result = subprocess.run(
+            ["python", script_path, *args],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+        return result
+    except subprocess.CalledProcessError as e:
+        print(f"Error running script: {e}")
+        print(f"Stderr: {e.stderr}")
+        sys.exit(1)
+
+if __name__ == '__main__':
+  main()
\ No newline at end of file
diff --git a/libraries/motion/src/platform/test/motion/Defaults.kt b/libraries/motion/src/platform/test/motion/Defaults.kt
index 7403e9791..c3809d37c 100644
--- a/libraries/motion/src/platform/test/motion/Defaults.kt
+++ b/libraries/motion/src/platform/test/motion/Defaults.kt
@@ -29,6 +29,7 @@ object Defaults {
      * See http://go/motion-testing#debug-video for instructions.
      */
     fun captureScreenshots(): Boolean {
-        return "true" == InstrumentationRegistry.getArguments().getString("captureScreenshots")
+        return "true" == InstrumentationRegistry.getArguments().getString("captureScreenshots") ||
+            MotionTestRule.isRobolectricRuntime()
     }
 }
diff --git a/libraries/motion/src/platform/test/motion/Extensions.kt b/libraries/motion/src/platform/test/motion/Extensions.kt
new file mode 100644
index 000000000..5efc2c4bd
--- /dev/null
+++ b/libraries/motion/src/platform/test/motion/Extensions.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion
+
+import kotlin.math.abs
+import kotlin.math.max
+
+/**
+ * Checks if this nullable Float is within the tolerance of another nullable Float value,
+ *
+ * @receiver The nullable Float value (`this`) being compared.
+ * @param expected The nullable Float value to compare against.
+ * @param acceptedDeviation The tolerance value. Defaults to `0.01f`
+ * @return `true` if the Floats are considered approximately equal
+ */
+fun Float?.isApproximatelyEqualTo(expected: Float?, acceptedDeviation: Float = 0.01f): Boolean {
+
+    if (this == null && expected == null) return true
+    if (this == null || expected == null) return false
+
+    if(this == expected) return true
+
+    if (this == 0f || expected == 0f) {
+        //Check to see if absolute difference is within threshold for near zero values
+        //This handles cases like (0, tiny) and (tiny, 0)
+        return abs(this - expected) <= acceptedDeviation
+    }
+
+    val absDiff = abs(this - expected)
+    val larger = max(abs(this), abs(expected))
+    val relativeDiff = absDiff / larger
+    return relativeDiff <= acceptedDeviation
+}
diff --git a/libraries/motion/src/platform/test/motion/MotionTestRule.kt b/libraries/motion/src/platform/test/motion/MotionTestRule.kt
index d0213048f..141b7415c 100644
--- a/libraries/motion/src/platform/test/motion/MotionTestRule.kt
+++ b/libraries/motion/src/platform/test/motion/MotionTestRule.kt
@@ -16,6 +16,7 @@
 
 package platform.test.motion
 
+import android.os.Build
 import android.util.Log
 import com.google.common.truth.FailureMetadata
 import com.google.common.truth.Subject
@@ -149,13 +150,16 @@ class MotionTestRule<Toolkit>(
         metadata.put("deviceLocalPath", goldenFilePath)
         metadata.put("result", result.name)
 
-        recordedMotion.videoRenderer?.let { videoRenderer ->
+        recordedMotion.screenshotExporter?.let { screenshotExporter ->
             try {
-                val videoFile =
-                    goldenFile.resolveSibling("${goldenFile.nameWithoutExtension}.$VIDEO_EXTENSION")
-
-                videoRenderer.renderToFile(videoFile.absolutePath)
-                metadata.put("videoLocation", videoFile.relativeTo(goldenFilePath))
+                // file name is of the form {testMethodName}.actual.{extension}
+                val file =
+                    goldenFile.resolveSibling(
+                        "${goldenFile.nameWithoutExtension}.${screenshotExporter.fileExtension}"
+                    )
+
+                screenshotExporter.exportToFile(file)
+                metadata.put("videoLocation", file.relativeTo(goldenFilePath))
             } catch (e: Exception) {
                 Log.e(TAG, "Failed to render motion test video", e)
             }
@@ -173,7 +177,7 @@ class MotionTestRule<Toolkit>(
     }
 
     private fun getGoldenFilePath(): File {
-        return if (isRobolectricRuntime()) File("/tmp/motion")
+        return if (isRobolectricRuntime() && isGradle()) File("/tmp/motion")
         else File(goldenPathManager.deviceLocalPath)
     }
 
@@ -187,14 +191,16 @@ class MotionTestRule<Toolkit>(
     companion object {
         private const val JSON_EXTENSION = "json"
         private const val JSON_ACTUAL_EXTENSION = "actual.${JSON_EXTENSION}"
-        private const val VIDEO_EXTENSION = "mp4"
         private const val JSON_INDENTATION = 2
         private val GOLDEN_IDENTIFIER_REGEX = "^[A-Za-z0-9_-]+$".toRegex()
         private const val TAG = "MotionTestRule"
 
         fun isRobolectricRuntime(): Boolean {
-            return this::class.java.getClassLoader().javaClass.getName().contains("robolectric")
+            return Build.FINGERPRINT.contains("robolectric")
         }
+
+        fun isGradle() =
+            System.getProperty("java.class.path")?.contains("gradle-worker.jar") ?: false
     }
 }
 
diff --git a/libraries/motion/src/platform/test/motion/RecordedMotion.kt b/libraries/motion/src/platform/test/motion/RecordedMotion.kt
index 08f136986..bea61bc8d 100644
--- a/libraries/motion/src/platform/test/motion/RecordedMotion.kt
+++ b/libraries/motion/src/platform/test/motion/RecordedMotion.kt
@@ -19,7 +19,9 @@ package platform.test.motion
 import android.graphics.Bitmap
 import platform.test.motion.filmstrip.Filmstrip
 import platform.test.motion.filmstrip.MotionScreenshot
-import platform.test.motion.filmstrip.VideoRenderer
+import platform.test.motion.filmstrip.Mp4VideoFileExporter
+import platform.test.motion.filmstrip.ScreenshotExporter
+import platform.test.motion.filmstrip.ScreenshotZipExporter
 import platform.test.motion.golden.TimeSeries
 
 /**
@@ -37,8 +39,8 @@ internal constructor(
 ) {
     /** Visual filmstrip of the animation. */
     val filmstrip: Filmstrip?
-    /** Renders the screenshots as an MP4 video. */
-    val videoRenderer: VideoRenderer?
+    /** Exports the screenshots as either an MP4 video or a Zip File. */
+    val screenshotExporter: ScreenshotExporter?
 
     init {
         if (screenshots != null) {
@@ -47,15 +49,15 @@ internal constructor(
                     MotionScreenshot(frameId, bitmap)
                 }
             filmstrip = Filmstrip(motionScreenshots)
-            videoRenderer =
+            screenshotExporter =
                 if (MotionTestRule.isRobolectricRuntime()) {
-                    null
+                    ScreenshotZipExporter(motionScreenshots)
                 } else {
-                    VideoRenderer(motionScreenshots)
+                    Mp4VideoFileExporter(motionScreenshots)
                 }
         } else {
             filmstrip = null
-            videoRenderer = null
+            screenshotExporter = null
         }
     }
 
diff --git a/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt b/libraries/motion/src/platform/test/motion/filmstrip/Mp4VideoFileExporter.kt
similarity index 56%
rename from libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt
rename to libraries/motion/src/platform/test/motion/filmstrip/Mp4VideoFileExporter.kt
index 1308f2e5f..eb97539c0 100644
--- a/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt
+++ b/libraries/motion/src/platform/test/motion/filmstrip/Mp4VideoFileExporter.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,23 +24,27 @@ import android.media.MediaFormat.KEY_COLOR_FORMAT
 import android.media.MediaFormat.KEY_FRAME_RATE
 import android.media.MediaMuxer
 import android.view.Surface
+import java.io.File
 import platform.test.motion.golden.TimestampFrameId
 
 /** Produces an MP4 based on the [screenshots]. */
-class VideoRenderer(private val screenshots: List<MotionScreenshot>) {
+class Mp4VideoFileExporter(private val screenshots: List<MotionScreenshot>) : ScreenshotExporter {
+
+    init {
+        require(screenshots.isNotEmpty()) { "Filmstrip must have at least one screenshot" }
+    }
 
     private var screenshotWidth = screenshots.maxOf { it.bitmap.width }.roundUpToNextMultipleOf16()
     private var screenshotHeight =
         screenshots.maxOf { it.bitmap.height }.roundUpToNextMultipleOf16()
 
-    /**
-     * Creates an MP4 file at [path], which will contain all screenshots.
-     *
-     * [bitsPerPixel] is used to estimate the bitrate needed.
-     */
-    fun renderToFile(path: String, bitsPerPixel: Float = 0.25f) {
-        require(screenshots.isNotEmpty()) { "Filmstrip must have at least one screenshot" }
-        val muxer = MediaMuxer(path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)
+    // used to estimate the bitrate needed.
+    private val bitsPerPixel: Float = 0.25f
+    override val fileExtension: String = VIDEO_EXTENSION
+
+    /** Creates an MP4 file at [file], which will contain all screenshots. */
+    override fun exportToFile(file: File) {
+        val muxer = MediaMuxer(file.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)
 
         val bitrate = (screenshotWidth * screenshotHeight * bitsPerPixel * FRAME_RATE).toInt()
         val mime = "video/avc"
@@ -56,67 +60,95 @@ class VideoRenderer(private val screenshots: List<MotionScreenshot>) {
         codec.start()
 
         encodeScreenshotsInVideo(codec, muxer, surface)
-
         codec.stop()
         codec.release()
         muxer.stop()
         muxer.release()
     }
 
+    // The encoder uses the system clock of the [unlockCanvasAndPost] call as frame time.
+    // However, this is arbitrary, as encoding happens as fast as possible. To avoid the extra
+    // complexity of video bitmap format conversion that would be required when using
+    // [queueInputBuffer] instead (which would allow specifying the presentation time), this
+    // will override the presentation time when muxing instead.
+    private fun calculateFramePresentationTimesUs(): List<Long> = buildList {
+        add(0L)
+        var presentationTimeUs = 0L
+        screenshots
+            .zipWithNext { first, second ->
+                if (first.frameId is TimestampFrameId && second.frameId is TimestampFrameId) {
+                    second.frameId.milliseconds - first.frameId.milliseconds
+                } else {
+                    // Exactly one frame for before / after
+                    FRAME_DURATION
+                }
+            }
+            .forEach { frameDurationMillis ->
+                presentationTimeUs += frameDurationMillis * 1000L
+                add(presentationTimeUs)
+            }
+    }
+
+    private fun renderNextScreenshot(
+        surface: Surface,
+        screenshotIterator: Iterator<MotionScreenshot>,
+    ) {
+        surface.lockCanvas(null).also { canvas ->
+            val screenshot = screenshotIterator.next()
+            canvas.drawBitmap(screenshot.bitmap, 0.0f, 0.0f, null)
+            surface.unlockCanvasAndPost(canvas)
+        }
+    }
+
     private fun encodeScreenshotsInVideo(encoder: MediaCodec, muxer: MediaMuxer, surface: Surface) {
         val bufferInfo = MediaCodec.BufferInfo()
         val screenshotIterator = screenshots.iterator()
         var isEndOfStream = false
         var videoTrackIndex = -1
+        val framePresentationTimesUsIterator = calculateFramePresentationTimesUs().iterator()
 
-        // The encoder uses the system clock of the [unlockCanvasAndPost] call as frame time.
-        // However, this is arbitrary, as encoding happens as fast as possible. To avoid the extra
-        // complexity of video bitmap format conversion that would be required when using
-        // [queueInputBuffer] instead (which would allow specifying the presentation time), this
-        // will override the presentation time when muxing instead.
-        val framePresentationTimesUsIterator =
-            buildList {
-                    add(0L)
-                    var presentationTimeUs = 0L
-                    screenshots
-                        .zipWithNext { first, second ->
-                            if (
-                                first.frameId is TimestampFrameId &&
-                                    second.frameId is TimestampFrameId
-                            ) {
-                                second.frameId.milliseconds - first.frameId.milliseconds
-                            } else {
-                                // Exactly one frame for before / after
-                                FRAME_DURATION
-                            }
-                        }
-                        .forEach { frameDurationMillis ->
-                            presentationTimeUs += frameDurationMillis * 1000L
-                            add(presentationTimeUs)
-                        }
-                }
-                .iterator()
-
-        while (true) {
+        // If the end-of-stream flag is set, end the loop
+        while (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM == 0) {
             if (screenshotIterator.hasNext()) {
-                surface.lockCanvas(null).also { canvas ->
-                    val screenshot = screenshotIterator.next()
-                    canvas.drawBitmap(screenshot.bitmap, 0.0f, 0.0f, null)
-                    surface.unlockCanvasAndPost(canvas)
-                }
+                renderNextScreenshot(surface, screenshotIterator)
             } else if (!isEndOfStream) {
                 encoder.signalEndOfInputStream()
                 isEndOfStream = true
             }
 
-            val outputBufferIndex = encoder.dequeueOutputBuffer(bufferInfo, DEQUEUE_TIMEOUT_US)
-            if (outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {
-                // No output available yet.
-                continue
-            } else if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-                videoTrackIndex = muxer.addTrack(encoder.outputFormat)
+            processEncoderOutput(
+                bufferInfo,
+                encoder,
+                muxer,
+                framePresentationTimesUsIterator,
+                videoTrackIndex,
+            ) { format ->
+                videoTrackIndex = muxer.addTrack(format)
                 muxer.start()
-            } else if (outputBufferIndex >= 0) {
+            }
+        }
+    }
+
+    private fun processEncoderOutput(
+        bufferInfo: MediaCodec.BufferInfo,
+        encoder: MediaCodec,
+        muxer: MediaMuxer,
+        framePresentationTimesUsIterator: Iterator<Long>,
+        videoTrackIndex: Int,
+        onOutputFormatChanged: (MediaFormat) -> Unit,
+    ) {
+
+        val outputBufferIndex = encoder.dequeueOutputBuffer(bufferInfo, DEQUEUE_TIMEOUT_US)
+        when {
+            outputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER -> {
+                // No output available yet.
+                return
+            }
+            outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
+                onOutputFormatChanged(encoder.outputFormat)
+                return
+            }
+            outputBufferIndex >= 0 -> {
                 val encodedDataBuffer =
                     encoder.getOutputBuffer(outputBufferIndex)
                         ?: throw RuntimeException("encoderOutputBuffer $outputBufferIndex was null")
@@ -141,7 +173,8 @@ class VideoRenderer(private val screenshots: List<MotionScreenshot>) {
                 if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
                     return
                 }
-            } else {
+            }
+            else -> {
                 throw AssertionError("Unexpected dequeueOutputBuffer response $outputBufferIndex")
             }
         }
@@ -152,6 +185,7 @@ class VideoRenderer(private val screenshots: List<MotionScreenshot>) {
         const val FRAME_DURATION = 16L
         const val FRAME_RATE = 1000f / FRAME_DURATION
         const val DEQUEUE_TIMEOUT_US = 10_000L
+        private const val VIDEO_EXTENSION = "mp4"
 
         private fun Int.roundUpToNextMultipleOf16(): Int = (this + 15) and 0xF.inv()
     }
diff --git a/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotExporter.kt b/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotExporter.kt
new file mode 100644
index 000000000..d45a80294
--- /dev/null
+++ b/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotExporter.kt
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion.filmstrip
+
+import java.io.File
+
+/** Contract for exporting screenshots in different formats. */
+interface ScreenshotExporter {
+    val fileExtension: String
+
+    fun exportToFile(file: File)
+}
diff --git a/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotZipExporter.kt b/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotZipExporter.kt
new file mode 100644
index 000000000..3d6c04c76
--- /dev/null
+++ b/libraries/motion/src/platform/test/motion/filmstrip/ScreenshotZipExporter.kt
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion.filmstrip
+
+import android.graphics.Bitmap
+import java.io.BufferedOutputStream
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+import java.util.zip.ZipEntry
+import java.util.zip.ZipOutputStream
+
+/** Produces a zip file of the pngs generated from [screenshots]. */
+class ScreenshotZipExporter(private val screenshots: List<MotionScreenshot>) : ScreenshotExporter {
+
+    companion object {
+        private const val FILE_EXTENSION = "screenshots.zip"
+    }
+
+    init {
+        require(screenshots.isNotEmpty())
+    }
+
+    override val fileExtension: String = FILE_EXTENSION
+
+    override fun exportToFile(file: File) {
+        exportZipFromBitmaps(file)
+    }
+
+    private fun exportZipFromBitmaps(outputZipFile: File) {
+        try {
+            FileOutputStream(outputZipFile).use { fos ->
+                BufferedOutputStream(fos).use { bos ->
+                    ZipOutputStream(bos).use { zos ->
+                        screenshots.forEachIndexed { index, motionScreenshot ->
+                            val bitmap = motionScreenshot.bitmap
+
+                            // Generate filename (padding ensures chronological order when sorted by
+                            // name)
+                            val paddedSuffix = index.toString().padStart(4, '0')
+                            val entryName = "image_$paddedSuffix.png"
+
+                            try {
+                                addBitmapEntryToZip(zos, bitmap, entryName)
+                            } catch (e: Exception) {
+                                throw IOException(
+                                    "Error adding bitmap entry '$entryName' at index $index: ${e.message}"
+                                )
+                            }
+                        }
+                        zos.finish()
+                    }
+                }
+            }
+        } catch (e: IOException) {
+            // Clean up potentially partial file
+            outputZipFile.delete()
+            throw IOException("Error during ZIP creation: ${e.message}", e)
+        } catch (e: Exception) {
+            outputZipFile.delete()
+            throw IOException("Unexpected error during ZIP creation: ${e.message}", e)
+        }
+    }
+
+    private fun addBitmapEntryToZip(
+        zos: ZipOutputStream,
+        bitmap: Bitmap,
+        entryName: String,
+        quality: Int = 100,
+    ) {
+        val zipEntry = ZipEntry(entryName)
+        zos.putNextEntry(zipEntry)
+        val success = bitmap.compress(Bitmap.CompressFormat.PNG, quality, zos)
+        if (!success) {
+            throw IOException("Failed to compress bitmap for entry $entryName")
+        }
+        zos.closeEntry()
+    }
+}
diff --git a/libraries/motion/src/platform/test/motion/golden/DataPoint.kt b/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
index 2600b96ce..63ec0464e 100644
--- a/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
+++ b/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
@@ -31,6 +31,8 @@ sealed interface DataPoint<out T> {
 
     fun asJson(): Any
 
+    fun isApproximatelyEqual(expected: DataPoint<*>): Boolean
+
     companion object {
         fun <T> of(value: T?, type: DataPointType<T>): DataPoint<T> {
             return if (value != null) {
@@ -67,6 +69,11 @@ data class ValueDataPoint<T> internal constructor(val value: T & Any, val type:
     override fun asJson() = type.toJson(this.value)
 
     override fun toString(): String = "$value (${type.typeName})"
+
+    override fun isApproximatelyEqual(expected: DataPoint<*>): Boolean =
+        if(expected is ValueDataPoint) {
+            (expected.value as? T)?.let { type.isApproximatelyEqual(value, it) } ?: false
+        } else false
 }
 
 /**
@@ -79,6 +86,9 @@ class NullDataPoint<T> private constructor() : DataPoint<T> {
 
     override fun asJson() = JSONObject.NULL
 
+    override fun isApproximatelyEqual(expected: DataPoint<*>): Boolean =
+        expected is NullDataPoint
+
     companion object {
         internal val instance = NullDataPoint<Any>()
 
@@ -102,6 +112,8 @@ class NotFoundDataPoint<T> private constructor() : DataPoint<T> {
 
     override fun asJson() = JSONObject().apply { put("type", "not_found") }
 
+    override fun isApproximatelyEqual(expected: DataPoint<*>): Boolean =  expected is NotFoundDataPoint
+
     override fun toString(): String = "{{not_found}}"
 
     companion object {
@@ -120,6 +132,9 @@ class UnknownType<T> private constructor() : DataPoint<T> {
 
     override fun asJson() = throw JSONException("Feature must not contain UnknownDataPoints")
 
+    override fun isApproximatelyEqual(expected: DataPoint<*>): Boolean =
+        throw NotImplementedError("Feature must not contain UnknownDataPoints")
+
     override fun toString(): String = "{{unknown_type}}"
 
     companion object {
diff --git a/libraries/motion/src/platform/test/motion/golden/DataPointType.kt b/libraries/motion/src/platform/test/motion/golden/DataPointType.kt
index a1bd4f2b8..942636067 100644
--- a/libraries/motion/src/platform/test/motion/golden/DataPointType.kt
+++ b/libraries/motion/src/platform/test/motion/golden/DataPointType.kt
@@ -31,6 +31,9 @@ class DataPointType<T>(
     val typeName: String,
     private val jsonToValue: (jsonValue: Any) -> T,
     private val valueToJson: (T) -> Any,
+    private val isApproximateEqual: (T, T) -> Boolean = { actual, expected ->
+        expected == actual
+    },
     internal val ensureImmutable: (T & Any) -> T & Any = { it },
 ) {
     fun makeDataPoint(nativeValue: T?): DataPoint<T> {
@@ -52,6 +55,9 @@ class DataPointType<T>(
 
     fun toJson(value: T): Any = valueToJson(value)
 
+    fun isApproximatelyEqual(actual: T, expected: T): Boolean = isApproximateEqual(actual, expected)
+
+
     override fun toString(): String {
         return typeName
     }
diff --git a/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt b/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
index bfd0ce08c..bb1be0151 100644
--- a/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
+++ b/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
@@ -17,6 +17,7 @@
 package platform.test.motion.golden
 
 import org.json.JSONArray
+import platform.test.motion.isApproximatelyEqualTo
 
 fun Float.asDataPoint() = DataPointTypes.float.makeDataPoint(this)
 
@@ -70,6 +71,14 @@ object DataPointTypes {
                     else -> it
                 }
             },
+            isApproximateEqual = { actual, expected ->
+                when{
+                    expected.isNaN() -> actual.isNaN()
+                    expected == Float.NEGATIVE_INFINITY -> actual == Float.NEGATIVE_INFINITY
+                    expected == Float.POSITIVE_INFINITY -> actual == Float.POSITIVE_INFINITY
+                    else -> actual.isApproximatelyEqualTo(expected)
+                }
+            }
         )
 
     val int: DataPointType<Int> =
@@ -87,7 +96,11 @@ object DataPointTypes {
         )
 
     val string: DataPointType<String> =
-        DataPointType("string", jsonToValue = { it.toString() }, valueToJson = { it })
+        DataPointType(
+            "string",
+            jsonToValue = { it.toString() },
+            valueToJson = { it },
+        )
 
     /**
      * Creates a [DataPointType] to serialize a list of values in an array, using [dataPointType].
@@ -110,7 +123,7 @@ object DataPointTypes {
             },
             valueToJson = {
                 JSONArray().apply { it.forEach { value -> put(dataPointType.toJson(value)) } }
-            },
+            }
         )
     }
 }
diff --git a/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt b/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
index 9df2c1cbb..9a715bcbd 100644
--- a/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
+++ b/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
@@ -23,6 +23,7 @@ import com.google.common.truth.FailureMetadata
 import com.google.common.truth.Subject
 import com.google.common.truth.Subject.Factory
 import com.google.common.truth.Truth
+import platform.test.motion.MotionTestRule
 import platform.test.motion.golden.TimeSeries
 
 /** Subject on [TimeSeries] to produce meaningful failure diffs. */
@@ -95,8 +96,14 @@ private constructor(failureMetadata: FailureMetadata, private val actual: TimeSe
 
                 val mismatchingDataPointIndices =
                     actualToExpectedDataPointIndices.filter { (actualIndex, expectedIndex) ->
-                        actualFeature.dataPoints[actualIndex] !=
-                            expectedFeature.dataPoints[expectedIndex]
+                        if(MotionTestRule.isRobolectricRuntime()){
+                            actualFeature.dataPoints[actualIndex].isApproximatelyEqual(
+                                expectedFeature.dataPoints[expectedIndex]
+                            ).not()
+                        } else {
+                            actualFeature.dataPoints[actualIndex] !=
+                                    expectedFeature.dataPoints[expectedIndex]
+                        }
                     }
 
                 if (mismatchingDataPointIndices.isNotEmpty()) {
diff --git a/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt b/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
index 0e2f66b69..39941066e 100644
--- a/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
+++ b/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
@@ -21,6 +21,7 @@ import android.graphics.Rect
 import org.json.JSONObject
 import platform.test.motion.golden.DataPointType
 import platform.test.motion.golden.UnknownTypeException
+import platform.test.motion.isApproximatelyEqualTo
 
 fun Rect.asDataPoint() = DataPointTypes.rect.makeDataPoint(this)
 
@@ -84,6 +85,13 @@ object DataPointTypes {
                     }
                 }
             },
+            isApproximateEqual = { actual, expected ->
+                var res = true
+                for(i in actual.rawValues.indices){
+                    res = res && actual.rawValues[i].isApproximatelyEqualTo(expected.rawValues[i])
+                }
+                res
+            }
         )
     // property names match order of val
     private val cornerRadiiPropertyNames =
diff --git a/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt b/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
index aa993890e..aaca59cbf 100644
--- a/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
@@ -29,6 +29,7 @@ import org.json.JSONObject
 import org.junit.Assert.assertThrows
 import org.junit.Test
 import org.junit.runner.RunWith
+import platform.test.motion.filmstrip.Mp4VideoFileExporter
 import platform.test.motion.golden.SupplementalFrameId
 import platform.test.motion.golden.TimeSeries
 import platform.test.motion.golden.TimestampFrameId
@@ -162,12 +163,19 @@ class MotionTestRuleTest {
             recordedMotion,
             TimeSeriesVerificationResult.MISSING_REFERENCE,
         )
-        if (recordedMotion.videoRenderer != null) {
-            val expectedVideo =
-                File(goldenPathManager.deviceLocalPath)
-                    .resolve("FooClass/updated_golden.actual.mp4")
-            assertThat(expectedVideo.exists()).isTrue()
-        }
+
+        // The test is run either using robolectric or on device. The behavior is
+        // different depending on the actual environment.
+        val expectedVideoLocation =
+            if (MotionTestRule.isRobolectricRuntime())
+                "FooClass/updated_golden.actual.screenshots.zip"
+            else "FooClass/updated_golden.actual.mp4"
+
+        val expectedVideoFile =
+            if (MotionTestRule.isRobolectricRuntime())
+                File("/tmp/motion").resolve(expectedVideoLocation)
+            else File(goldenPathManager.deviceLocalPath).resolve(expectedVideoLocation)
+        assertThat(expectedVideoFile.exists()).isTrue()
 
         val expectedFile = goldenExportDirectory.resolve("FooClass/updated_golden.actual.json")
         val fileContents = JSONObject(expectedFile.readText())
@@ -188,9 +196,12 @@ class MotionTestRuleTest {
                     put("testClassName", "FooClass")
                     put("testMethodName", "bar_test")
                     put("result", "MISSING_REFERENCE")
-                    if (recordedMotion.videoRenderer != null) {
-                        put("videoLocation", "FooClass/updated_golden.actual.mp4")
-                    }
+                    put(
+                        "videoLocation",
+                        if (recordedMotion.screenshotExporter is Mp4VideoFileExporter)
+                            "FooClass/updated_golden.actual.mp4"
+                        else "FooClass/updated_golden.actual.screenshots.zip",
+                    )
                 }
             )
     }
diff --git a/libraries/runner/Android.bp b/libraries/runner/Android.bp
index 269ece276..13398e9ba 100644
--- a/libraries/runner/Android.bp
+++ b/libraries/runner/Android.bp
@@ -17,11 +17,11 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
-android_library {
-    name: "platform-parametric-runner-lib",
+java_defaults {
+    name: "platform-parametric-runner-lib_defaults",
     manifest: "AndroidManifest.xml",
-    sdk_version: "test_current",
-    min_sdk_version: "Tiramisu",
+    sdk_version: "34",
+    min_sdk_version: "33",
     lint: {
         test: true,
     },
@@ -31,10 +31,32 @@ android_library {
     srcs: [
         "src/main/java/**/*.java",
     ],
+    static_libs: [],
+}
+
+// This version includes robolectric support, but it has a dependency to
+// "robolectric-all", so it's slower to build.
+// If your test doesn't use robolectric, consider using
+// "platform-parametric-runner-lib-no-robo" instead.
+android_library {
+    name: "platform-parametric-runner-lib",
+    defaults: ["platform-parametric-runner-lib_defaults"],
     libs: [
         "Robolectric_all-target",
     ],
-    static_libs: [],
+}
+
+// See above comment.
+android_library {
+    name: "platform-parametric-runner-lib-no-robo",
+    defaults: ["platform-parametric-runner-lib_defaults"],
+    static_libs: [
+        "androidx.test.runner",
+        "guava",
+    ],
+    exclude_srcs: [
+        "src/main/java/platform/test/runner/parameterized/RobolectricParameterizedRunner.java",
+    ],
 }
 
 android_test {
@@ -48,7 +70,7 @@ android_test {
         "platform-parametric-runner-lib",
     ],
 
-    sdk_version: "current",
+    sdk_version: "34",
 
     test_suites: ["general-tests"],
 }
diff --git a/libraries/screenshot/src/androidTest/java/platform/test/screenshot/GoldenPathManagerTest.kt b/libraries/screenshot/src/androidTest/java/platform/test/screenshot/GoldenPathManagerTest.kt
index b809e43d1..243eb2451 100644
--- a/libraries/screenshot/src/androidTest/java/platform/test/screenshot/GoldenPathManagerTest.kt
+++ b/libraries/screenshot/src/androidTest/java/platform/test/screenshot/GoldenPathManagerTest.kt
@@ -82,7 +82,7 @@ class GoldenPathManagerTest {
 
         val pc2 = getSimplePathConfig()
         val pcResolvedRelativePath2 = pc2.resolveRelativePath(context)
-        assertThat(pcResolvedRelativePath2).startsWith("cuttlefish")
+        assertThat(pcResolvedRelativePath2).matches("^(cuttlefish|cf_).*")
     }
 
     @Test
diff --git a/libraries/screenshot/src/androidTest/java/platform/test/screenshot/matchers/HumanEyeMatcherTest.kt b/libraries/screenshot/src/androidTest/java/platform/test/screenshot/matchers/HumanEyeMatcherTest.kt
index e0a729f2e..d8a20d2c6 100644
--- a/libraries/screenshot/src/androidTest/java/platform/test/screenshot/matchers/HumanEyeMatcherTest.kt
+++ b/libraries/screenshot/src/androidTest/java/platform/test/screenshot/matchers/HumanEyeMatcherTest.kt
@@ -344,7 +344,7 @@ class HumanEyeMatcherTest {
     @Test
     fun performDiff_forBlockOfPixels_diffsOnBigDiff() {
         val first = IntArray(16) { Color.BLACK }
-        val second = IntArray(16) { index -> if (index > 3) rgb(0, 2, 0) else Color.BLACK }
+        val second = IntArray(16) { index -> if (index > 3) rgb(0, 3, 0) else Color.BLACK }
 
         val result =
             matcher.compareBitmaps(
@@ -443,7 +443,7 @@ class HumanEyeMatcherTest {
     fun performDiff_forBlockOfPixels_whenIgnoringGrouping_diffsOnMediumDiff() {
         val matcherWithoutGrouping = HumanEyeMatcher(accountForGrouping = false)
         val first = IntArray(16) { Color.BLACK }
-        val second = IntArray(16) { index -> if (index > 3) rgb(0, 2, 0) else Color.BLACK }
+        val second = IntArray(16) { index -> if (index > 3) rgb(0, 3, 0) else Color.BLACK }
 
         val result =
             matcherWithoutGrouping.compareBitmaps(
@@ -500,7 +500,7 @@ class HumanEyeMatcherTest {
         val matcherIgnoringGrouping = HumanEyeMatcher(accountForGrouping = false)
         val first = IntArray(9) { Color.BLACK }
         val second = IntArray(9) { Color.BLACK }
-        second[4] = rgb(0, 2, 0)
+        second[4] = rgb(0, 3, 0)
 
         val result =
             matcherIgnoringGrouping.compareBitmaps(
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
index d63fd17f5..2fd4da723 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
@@ -16,15 +16,22 @@
 
 package platform.test.screenshot
 
+import android.os.Build
 import platform.test.screenshot.matchers.MSSIMMatcher
 import platform.test.screenshot.matchers.PixelPerfectMatcher
 
+val PerfectMatcher by lazy { PixelPerfectMatcher() }
+
+private val isEmulator = Build.CPU_ABI == "x86_64"
+
+private val isRobolectric = System.getProperty("java.vm.name")?.equals("Dalvik") == false
+
 /**
  * The [BitmapMatcher][platform.test.screenshot.matchers.BitmapMatcher] that should be used for
  * screenshot *unit* tests.
  */
 val UnitTestBitmapMatcher =
-    if (System.getProperty("java.vm.name")?.equals("Dalvik") == false) { // isRobolectric
+    if (isEmulator || isRobolectric) {
         // Different CPU architectures can sometimes end up rendering differently, so we can't do
         // pixel-perfect matching on different architectures using the same golden. Given that our
         // presubmits are run on cf_x86_64_phone, our goldens should be perfectly matched on the
@@ -32,7 +39,7 @@ val UnitTestBitmapMatcher =
         // TODO(b/237511747): Run our screenshot presubmit tests on arm64 instead so that we can
         // do pixel perfect matching both at presubmit time and at development time with actual
         // devices.
-        PixelPerfectMatcher()
+        PerfectMatcher
     } else {
         MSSIMMatcher()
     }
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/DefaultDeviceEmulationSpec.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/DefaultDeviceEmulationSpec.kt
index d9b93275e..87e1f05c6 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/DefaultDeviceEmulationSpec.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/DefaultDeviceEmulationSpec.kt
@@ -9,6 +9,16 @@ package platform.test.screenshot
 val DeviceEmulationSpec.Companion.PhoneAndTabletFull
     get() = PhoneAndTabletFullSpec
 
+/**
+ * The configuration to verify features on desktop.
+ */
+val DeviceEmulationSpec.Companion.DesktopMinimal
+    get() = DeviceEmulationSpec.forDisplays(
+        Displays.Desktop,
+        isDarkTheme = true,
+        isLandscape = true,
+    )
+
 private val PhoneAndTabletFullSpec =
     DeviceEmulationSpec.forDisplays(Displays.Phone, Displays.Tablet)
 
@@ -121,4 +131,12 @@ object Displays {
             height = 2160,
             densityDpi = 320,
         )
+
+    val Desktop =
+        DisplaySpec(
+            "desktop",
+            width=1920,
+            height=1080,
+            densityDpi = 320,
+        )
 }
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/DeviceEmulationRule.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/DeviceEmulationRule.kt
index 3c2996fab..fb3450dcc 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/DeviceEmulationRule.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/DeviceEmulationRule.kt
@@ -22,8 +22,11 @@ import android.content.Context
 import android.os.Build
 import android.os.UserHandle
 import android.view.Display
+import android.view.View
 import android.view.WindowManagerGlobal
+import androidx.core.text.TextUtilsCompat
 import androidx.test.platform.app.InstrumentationRegistry
+import java.util.Locale
 import org.junit.Assume
 import org.junit.rules.TestRule
 import org.junit.runner.Description
@@ -64,7 +67,7 @@ class DeviceEmulationRule(private val spec: DeviceEmulationSpec) : TestRule {
             override fun evaluate() {
                 Assume.assumeFalse(
                     "Skipping test: ${description.displayName}, because skip-dark-theme is true.",
-                    skipDarkTheme == "true" && spec.isDarkTheme
+                    skipDarkTheme == "true" && spec.isDarkTheme,
                 )
                 beforeTest()
                 base.evaluate()
@@ -86,9 +89,25 @@ class DeviceEmulationRule(private val spec: DeviceEmulationSpec) : TestRule {
                 runtimeEnvironment.getDeclaredMethod("setQualifiers", String::class.java)
             val scaledWidth = width * 160 / density
             val scaledHeight = height * 160 / density
-            val darkMode = if (spec.isDarkTheme) "night" else "notnight"
-            val qualifier = "w${scaledWidth}dp-h${scaledHeight}dp-${darkMode}-${density}dpi"
-            setQualifiers.invoke(null, qualifier)
+            setQualifiers.invoke(
+                null,
+                buildString {
+                    if (spec.locale != null) {
+                        append("${spec.localeQualifier}-")
+
+                        // Note: rtl only works is supportsRtl is specified by your test manifest
+                        when (TextUtilsCompat.getLayoutDirectionFromLocale(spec.locale)) {
+                            View.LAYOUT_DIRECTION_LTR -> append("ldltr-")
+                            View.LAYOUT_DIRECTION_RTL -> append("ldrtl-")
+                        }
+                    }
+
+                    append("w${scaledWidth}dp-")
+                    append("h${scaledHeight}dp-")
+                    append(if (spec.isDarkTheme) "night-" else "notnight-")
+                    append("${density}dpi")
+                },
+            )
         } else {
             val curNightMode =
                 if (spec.isDarkTheme) {
@@ -167,19 +186,20 @@ class DeviceEmulationRule(private val spec: DeviceEmulationSpec) : TestRule {
 }
 
 /** The specification of a device display to be used in a screenshot test. */
-data class DisplaySpec(
-    val name: String,
-    val width: Int,
-    val height: Int,
-    val densityDpi: Int,
-)
+data class DisplaySpec(val name: String, val width: Int, val height: Int, val densityDpi: Int)
 
 /** The specification of a device emulation. */
-data class DeviceEmulationSpec(
+data class DeviceEmulationSpec
+@JvmOverloads
+constructor(
     val display: DisplaySpec,
     val isDarkTheme: Boolean = false,
     val isLandscape: Boolean = false,
+    val locale: Locale? = null,
 ) {
+    val localeQualifier: String?
+        get() = locale?.run { "b+${toLanguageTag().replace("-", "+").substringBefore("+u+nu")}" }
+
     companion object {
         /**
          * Return a list of [DeviceEmulationSpec] for each of the [displays].
@@ -224,5 +244,6 @@ data class DeviceEmulationSpec(
         append(display.name)
         if (isDarkTheme) append("_dark")
         if (isLandscape) append("_landscape")
+        if (locale != null) append("_${locale.toLanguageTag()}")
     }
 }
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/GoldenPathManager.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/GoldenPathManager.kt
index 06221cd5e..2a261e89c 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/GoldenPathManager.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/GoldenPathManager.kt
@@ -29,6 +29,7 @@ private const val RESOLUTION_TAG = "resolution"
 private const val DISPLAY_TAG = "display"
 private const val THEME_TAG = "theme"
 private const val ORIENTATION_TAG = "orientation"
+private const val LOCALE_TAG = "locale"
 
 /**
  * Class to manage Directory structure of golden files.
@@ -57,7 +58,7 @@ constructor(
     val appContext: Context,
     val assetsPathRelativeToBuildRoot: String = "assets",
     var deviceLocalPath: String = getDeviceOutputDirectory(appContext),
-    val pathConfig: PathConfig = getSimplePathConfig()
+    val pathConfig: PathConfig = getSimplePathConfig(),
 ) {
 
     init {
@@ -100,7 +101,7 @@ sealed class PathElementBase {
 data class PathElementNoContext(
     override val attr: String,
     override val isDir: Boolean,
-    val func: (() -> String)
+    val func: (() -> String),
 ) : PathElementBase()
 
 /*
@@ -111,7 +112,7 @@ data class PathElementNoContext(
 data class PathElementWithContext(
     override val attr: String,
     override val isDir: Boolean,
-    val func: ((Context) -> String)
+    val func: ((Context) -> String),
 ) : PathElementBase()
 
 /*
@@ -125,10 +126,20 @@ class PathConfig(vararg elems: PathElementBase) {
     public fun resolveRelativePath(context: Context): String {
         return data
             .map {
-                when (it) {
-                    is PathElementWithContext -> it.func(context)
-                    is PathElementNoContext -> it.func()
-                } + if (it.isDir) "/" else "_"
+                val subPathString =
+                    when (it) {
+                        is PathElementWithContext -> it.func(context)
+                        is PathElementNoContext -> it.func()
+                    }
+                val separator =
+                    if (it.isDir) {
+                        "/"
+                    } else if (subPathString.isNotEmpty()) {
+                        "_"
+                    } else {
+                        ""
+                    }
+                subPathString + separator
             }
             .joinToString("")
     }
@@ -145,7 +156,7 @@ fun getDefaultPathConfig(): PathConfig {
         PathElementNoContext(MODEL_TAG, true, ::getDeviceModel),
         PathElementNoContext(API_TAG, true, ::getAPIVersion),
         PathElementWithContext(SIZE_TAG, true, ::getScreenSize),
-        PathElementWithContext(RESOLUTION_TAG, true, ::getScreenResolution)
+        PathElementWithContext(RESOLUTION_TAG, true, ::getScreenResolution),
     )
 }
 
@@ -170,7 +181,7 @@ fun getDeviceVariantPathConfig(variant: String): PathConfig {
 /** The [PathConfig] that should be used when emulating a device using the [DeviceEmulationRule]. */
 fun getEmulatedDevicePathConfig(emulationSpec: DeviceEmulationSpec): PathConfig {
     // Returns a path of the form
-    // "/display_name/(light|dark)_(portrait|landscape)_golden_identifier.png".
+    // "/display_name/(light|dark)_(portrait|landscape)(_locale-if-non-null)_{goldenIdentifier}.png".
     return PathConfig(
         PathElementNoContext(DISPLAY_TAG, isDir = true) { emulationSpec.display.name },
         PathElementNoContext(THEME_TAG, isDir = false) {
@@ -179,6 +190,13 @@ fun getEmulatedDevicePathConfig(emulationSpec: DeviceEmulationSpec): PathConfig
         PathElementNoContext(ORIENTATION_TAG, isDir = false) {
             if (emulationSpec.isLandscape) "landscape" else "portrait"
         },
+        PathElementNoContext(LOCALE_TAG, isDir = false) {
+            if (emulationSpec.locale != null) {
+                emulationSpec.locale.toLanguageTag()
+            } else {
+                ""
+            }
+        },
     )
 }
 
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotAsserter.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotAsserter.kt
index de510ace4..bc70c8187 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotAsserter.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotAsserter.kt
@@ -18,12 +18,14 @@ package platform.test.screenshot
 
 import android.graphics.Bitmap
 import android.graphics.Rect
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.runner.screenshot.Screenshot
 import platform.test.screenshot.matchers.BitmapMatcher
 import platform.test.screenshot.matchers.PixelPerfectMatcher
 
 interface ScreenshotAsserter {
     fun assertGoldenImage(goldenId: String, areas: List<Rect>)
+
     fun assertGoldenImage(goldenId: String)
 }
 
@@ -52,5 +54,31 @@ data class ScreenshotAsserterConfig(
      * The [Bitmap] produced by [captureStrategy] will be recycled immediately after assertions are
      * completed. Therefore, do not retain references to created [Bitmap]s.
      */
-    val captureStrategy: BitmapSupplier = { Screenshot.capture().bitmap }
-)
+    val captureStrategy: BitmapSupplier = DEFAULT_SCREENSHOT_CAPTURE,
+) {
+    var displayId: Int = DEFAULT_DISPLAY
+        private set(value) {
+            require(captureStrategy == DEFAULT_SCREENSHOT_CAPTURE) {
+                "display ID can only be set when default capture strategy is in use"
+            }
+            field = value
+        }
+
+    constructor(
+        matcher: BitmapMatcher = PixelPerfectMatcher(),
+        beforeScreenshot: () -> Unit = {},
+        afterScreenshot: () -> Unit = {},
+        displayId: Int,
+    ) : this(
+        matcher = matcher,
+        beforeScreenshot = beforeScreenshot,
+        afterScreenshot = afterScreenshot,
+        captureStrategy = DEFAULT_SCREENSHOT_CAPTURE,
+    ) {
+        this.displayId = displayId
+    }
+
+    companion object {
+        val DEFAULT_SCREENSHOT_CAPTURE: BitmapSupplier = { Screenshot.capture().bitmap }
+    }
+}
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotTestRule.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotTestRule.kt
index 73539a3c9..fee6d6ef5 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotTestRule.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/ScreenshotTestRule.kt
@@ -24,14 +24,16 @@ import android.graphics.Color
 import android.graphics.Rect
 import android.platform.uiautomatorhelpers.DeviceHelpers.shell
 import android.provider.Settings.System
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.annotation.VisibleForTesting
+import androidx.core.graphics.createBitmap
 import androidx.test.platform.app.InstrumentationRegistry
-import androidx.test.runner.screenshot.Screenshot
 import com.android.internal.app.SimpleIconFactory
 import java.io.FileNotFoundException
 import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
+import platform.test.screenshot.ScreenshotAsserterConfig.Companion.DEFAULT_SCREENSHOT_CAPTURE
 import platform.test.screenshot.matchers.BitmapMatcher
 import platform.test.screenshot.matchers.MSSIMMatcher
 import platform.test.screenshot.matchers.MatchResult
@@ -306,6 +308,7 @@ internal constructor(
             .setOnBeforeScreenshot(config.beforeScreenshot)
             .setOnAfterScreenshot(config.afterScreenshot)
             .setScreenshotProvider(config.captureStrategy)
+            .setDisplayId(config.displayId)
             .build()
     }
 
@@ -348,16 +351,26 @@ internal constructor(
 
 typealias BitmapSupplier = () -> Bitmap
 
-/** Implements a screenshot asserter based on the ScreenshotRule */
-class ScreenshotRuleAsserter private constructor(private val rule: ScreenshotTestRule) :
-    ScreenshotAsserter {
-    // use the most constraining matcher as default
-    private var matcher: BitmapMatcher = PixelPerfectMatcher()
-    private var beforeScreenshot: Runnable? = null
-    private var afterScreenshot: Runnable? = null
+/** Implements a screenshot asserter based on the ScreenshotRule. */
+class ScreenshotRuleAsserter
+private constructor(
+    private val rule: ScreenshotTestRule,
+    private val beforeScreenshot: Runnable?,
+    private val afterScreenshot: Runnable?,
+    private val screenShotter: BitmapSupplier,
+    private val matcher: BitmapMatcher,
+    private val targetDisplayId: Int,
+) : ScreenshotAsserter {
+    init {
+        require(screenShotter == DEFAULT_SCREENSHOT_CAPTURE || targetDisplayId == DEFAULT_DISPLAY) {
+            "DEFAULT_SCREENSHOT_CAPTURE must be used when non default display ID is set."
+        }
+    }
 
-    // use the instrumentation screenshot as default
-    private var screenShotter: BitmapSupplier = { Screenshot.capture().bitmap }
+    private val displayScreenShotter: (Int) -> Bitmap = { _displayId ->
+        InstrumentationRegistry.getInstrumentation().uiAutomation.takeScreenshot(_displayId)
+            ?: createBitmap(0, 0)
+    }
 
     private var pointerLocationSetting: Int
         get() = shell("settings get system ${System.POINTER_LOCATION}").trim().toIntOrNull() ?: 0
@@ -379,7 +392,7 @@ class ScreenshotRuleAsserter private constructor(private val rule: ScreenshotTes
         runBeforeScreenshot()
         var actual: Bitmap? = null
         try {
-            actual = screenShotter()
+            actual = captureScreenshot(targetDisplayId)
             rule.assertBitmapAgainstGolden(actual, goldenId, matcher)
         } finally {
             actual?.recycle()
@@ -392,7 +405,7 @@ class ScreenshotRuleAsserter private constructor(private val rule: ScreenshotTes
         runBeforeScreenshot()
         var actual: Bitmap? = null
         try {
-            actual = screenShotter()
+            actual = captureScreenshot(targetDisplayId)
             rule.assertBitmapAgainstGolden(actual, goldenId, matcher, areas)
         } finally {
             actual?.recycle()
@@ -400,6 +413,13 @@ class ScreenshotRuleAsserter private constructor(private val rule: ScreenshotTes
         }
     }
 
+    private fun captureScreenshot(displayId: Int): Bitmap =
+        if (screenShotter != DEFAULT_SCREENSHOT_CAPTURE) {
+            screenShotter()
+        } else {
+            displayScreenShotter(displayId)
+        }
+
     private fun runBeforeScreenshot() {
         // Disable Sensitive Content Redaction
         shell("settings put secure disable_secure_windows 1")
@@ -424,25 +444,49 @@ class ScreenshotRuleAsserter private constructor(private val rule: ScreenshotTes
 
     @Deprecated("Use ScreenshotAsserterFactory instead")
     class Builder(private val rule: ScreenshotTestRule) {
-        private var asserter = ScreenshotRuleAsserter(rule)
+        private var matcher: BitmapMatcher? = null
+        private var screenshotProvider: BitmapSupplier? = null
+        private var beforeScreenshot: Runnable? = null
+        private var afterScreenshot: Runnable? = null
+        private var displayId: Int? = null
 
-        fun withMatcher(matcher: BitmapMatcher): Builder = apply { asserter.matcher = matcher }
+        fun withMatcher(matcher: BitmapMatcher): Builder = apply { this.matcher = matcher }
 
         /**
          * The [Bitmap] produced by [screenshotProvider] will be recycled immediately after
          * assertions are completed. Therefore, do not retain references to created [Bitmap]s.
          */
         fun setScreenshotProvider(screenshotProvider: BitmapSupplier): Builder = apply {
-            asserter.screenShotter = screenshotProvider
+            require(displayId == null || displayId == DEFAULT_DISPLAY) {
+                "Custom screenshot provider is unsupported when a display ID is specified."
+            }
+            this.screenshotProvider = screenshotProvider
         }
 
-        fun setOnBeforeScreenshot(run: Runnable): Builder = apply {
-            asserter.beforeScreenshot = run
-        }
+        fun setOnBeforeScreenshot(run: Runnable): Builder = apply { this.beforeScreenshot = run }
 
-        fun setOnAfterScreenshot(run: Runnable): Builder = apply { asserter.afterScreenshot = run }
+        fun setOnAfterScreenshot(run: Runnable): Builder = apply { this.afterScreenshot = run }
 
-        fun build(): ScreenshotAsserter = asserter.also { asserter = ScreenshotRuleAsserter(rule) }
+        fun setDisplayId(displayId: Int): Builder = apply {
+            require(
+                displayId == DEFAULT_DISPLAY ||
+                    screenshotProvider == null ||
+                    screenshotProvider == DEFAULT_SCREENSHOT_CAPTURE
+            ) {
+                "Custom display ID is unsupported when a custom screenshot provider is used"
+            }
+            this.displayId = displayId
+        }
+
+        fun build(): ScreenshotAsserter =
+            ScreenshotRuleAsserter(
+                rule = rule,
+                beforeScreenshot = beforeScreenshot,
+                afterScreenshot = afterScreenshot,
+                screenShotter = screenshotProvider ?: DEFAULT_SCREENSHOT_CAPTURE,
+                matcher = matcher ?: PixelPerfectMatcher(),
+                targetDisplayId = displayId ?: DEFAULT_DISPLAY,
+            )
     }
 }
 
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/matchers/HumanEyeMatcher.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/matchers/HumanEyeMatcher.kt
index 1b1d9547f..e3a1a2f16 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/matchers/HumanEyeMatcher.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/matchers/HumanEyeMatcher.kt
@@ -217,7 +217,7 @@ class HumanEyeMatcher(
     }
 
     private companion object {
-        const val THRESHOLD_BLOCK_OF_PIXELS_SQ = 3 * 3
+        const val THRESHOLD_BLOCK_OF_PIXELS_SQ = 5 * 5
         const val THRESHOLD_2PX_LINE_OF_PIXELS_SQ = 10 * 10
         const val THRESHOLD_1PX_LINE_OF_PIXELS_SQ = 12 * 12
         const val THRESHOLD_ISOLATED_PIXEL_SQ = 40 * 40
diff --git a/libraries/screenshot/utils/compose/src/platform/test/screenshot/utils/compose/ComposeScreenshotTestRule.kt b/libraries/screenshot/utils/compose/src/platform/test/screenshot/utils/compose/ComposeScreenshotTestRule.kt
index d5fb8da99..2c368bb7a 100644
--- a/libraries/screenshot/utils/compose/src/platform/test/screenshot/utils/compose/ComposeScreenshotTestRule.kt
+++ b/libraries/screenshot/utils/compose/src/platform/test/screenshot/utils/compose/ComposeScreenshotTestRule.kt
@@ -18,18 +18,30 @@ package platform.test.screenshot.utils.compose
 
 import android.app.Activity
 import android.app.Dialog
+import android.content.res.Configuration
 import android.os.Build
+import android.os.LocaleList
+import android.view.ContextThemeWrapper
+import android.view.View
 import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.Surface
 import androidx.compose.runtime.Composable
+import androidx.compose.runtime.CompositionLocalProvider
 import androidx.compose.runtime.DisposableEffect
+import androidx.compose.runtime.remember
 import androidx.compose.ui.focus.FocusManager
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalFocusManager
+import androidx.compose.ui.platform.LocalLayoutDirection
 import androidx.compose.ui.platform.ViewRootForTest
 import androidx.compose.ui.test.SemanticsNodeInteraction
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
 import androidx.compose.ui.test.onRoot
+import androidx.compose.ui.unit.LayoutDirection
+import androidx.core.text.TextUtilsCompat
 import com.android.compose.theme.PlatformTheme
+import java.util.Locale
 import java.util.concurrent.TimeUnit
 import org.junit.rules.RuleChain
 import org.junit.rules.TestRule
@@ -42,6 +54,7 @@ import platform.test.screenshot.FontsRule
 import platform.test.screenshot.GoldenPathManager
 import platform.test.screenshot.HardwareRenderingRule
 import platform.test.screenshot.MaterialYouColorsRule
+import platform.test.screenshot.PerfectMatcher
 import platform.test.screenshot.ScreenshotActivity
 import platform.test.screenshot.ScreenshotAsserterFactory
 import platform.test.screenshot.ScreenshotTestRule
@@ -53,6 +66,7 @@ import platform.test.screenshot.dialogScreenshotTest
 class ComposeScreenshotTestRule(
     private val emulationSpec: DeviceEmulationSpec,
     pathManager: GoldenPathManager,
+    enforcePerfectPixelMatch: Boolean = false,
     private val screenshotRule: ScreenshotTestRule = ScreenshotTestRule(pathManager),
 ) : TestRule, BitmapDiffer by screenshotRule, ScreenshotAsserterFactory by screenshotRule {
     private val colorsRule = MaterialYouColorsRule()
@@ -72,7 +86,13 @@ class ComposeScreenshotTestRule(
             .around(colorsRule)
             .around(hardwareRenderingRule)
             .around(commonRule)
-    private val matcher = UnitTestBitmapMatcher
+    private val matcher =
+        if (enforcePerfectPixelMatch) {
+            PerfectMatcher
+        } else {
+            UnitTestBitmapMatcher
+        }
+
     private val isRobolectric = Build.FINGERPRINT.contains("robolectric")
 
     override fun apply(base: Statement, description: Description): Statement {
@@ -97,6 +117,8 @@ class ComposeScreenshotTestRule(
         val activity = composeRule.activity
         activity.mainExecutor.execute { activity.window.setDecorFitsSystemWindows(false) }
 
+        emulationSpec.locale?.let { Locale.setDefault(it) }
+
         // Set the content using the AndroidComposeRule to make sure that the Activity is set up
         // correctly.
         if (content != null) {
@@ -104,18 +126,20 @@ class ComposeScreenshotTestRule(
 
             composeRule.setContent {
                 val focusManager = LocalFocusManager.current.also { focusManager = it }
+                CustomLocale(locale = emulationSpec.locale) {
+                    PlatformTheme {
+                        Surface(color = MaterialTheme.colorScheme.background) {
+                            content()
 
-                PlatformTheme {
-                    Surface(color = MaterialTheme.colorScheme.background) {
-                        content()
-
-                        // Clear the focus early. This disposable effect will run after any
-                        // DisposableEffect in content() but will run before layout/drawing, so
-                        // clearing focus early here will make sure we never draw a focused effect.
-                        if (clearFocus) {
-                            DisposableEffect(Unit) {
-                                focusManager.clearFocus()
-                                onDispose {}
+                            // Clear the focus early. This disposable effect will run after any
+                            // DisposableEffect in content() but will run before layout/drawing, so
+                            // clearing focus early here will make sure we never draw a focused
+                            // effect.
+                            if (clearFocus) {
+                                DisposableEffect(Unit) {
+                                    focusManager.clearFocus()
+                                    onDispose {}
+                                }
                             }
                         }
                     }
@@ -137,6 +161,8 @@ class ComposeScreenshotTestRule(
 
     fun dialogScreenshotTest(
         goldenIdentifier: String,
+        shouldWaitForTheDialog: (Dialog) -> Boolean = { false },
+        frameLimit: Int = 10,
         waitForIdle: () -> Unit = {},
         dialogProvider: (Activity) -> Dialog,
     ) {
@@ -145,6 +171,8 @@ class ComposeScreenshotTestRule(
             bitmapDiffer = screenshotRule,
             matcher = matcher,
             goldenIdentifier = goldenIdentifier,
+            frameLimit = frameLimit,
+            checkDialog = shouldWaitForTheDialog,
             waitForIdle = {
                 composeRule.waitForIdle()
                 waitForIdle()
@@ -153,3 +181,43 @@ class ComposeScreenshotTestRule(
         )
     }
 }
+
+@Composable
+fun CustomLocale(locale: Locale?, content: @Composable () -> Unit) {
+    if (locale == null) {
+        return content()
+    }
+    // Override the local context with the locale so that string resources get translated to the
+    // right language.
+    val previousConfiguration = LocalConfiguration.current
+    val configuration =
+        remember(previousConfiguration, locale) {
+            Configuration().apply {
+                updateFrom(previousConfiguration)
+                setLocales(LocaleList(locale))
+            }
+        }
+    val previousContext = LocalContext.current
+    val context =
+        remember(previousContext, configuration) {
+            ContextThemeWrapper(previousContext, 0).apply {
+                applyOverrideConfiguration(configuration)
+            }
+        }
+
+    val direction =
+        remember(locale) {
+            if (TextUtilsCompat.getLayoutDirectionFromLocale(locale) == View.LAYOUT_DIRECTION_RTL) {
+                LayoutDirection.Rtl
+            } else {
+                LayoutDirection.Ltr
+            }
+        }
+
+    CompositionLocalProvider(
+        LocalContext provides context,
+        LocalConfiguration provides configuration,
+        LocalLayoutDirection provides direction,
+        content = content,
+    )
+}
diff --git a/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
index 8d67dd3ac..01bb24389 100644
--- a/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
@@ -33,14 +33,16 @@ import org.gradle.api.tasks.Copy
 // See "android_test_helper_app" at the "Soong reference files"
 // https://ci.android.com/builds/latest/branches/aosp-build-tools/targets/linux/view/soong_build.html
 open class AppTestExtension {
-    var minSdk: Int = 31 // oldest security-supported
-    var targetSdk: Int = 34 // newest security-supported
-    var compileSdk: Int = 34 // compile = target
+    var minSdk: Int? = null // oldest security-supported
+    var targetSdk: Int? = null // newest security-supported
+    var compileSdk: Int? = null // compile = target
+    var applicationId: String? = null
 }
 
 class AppTestPlugin : Plugin<Project> {
     override fun apply(project: Project) {
         val namespace = "com.android.security"
+        val placeholder = "_AutoReproPlaceholder"
         val appTest = project.extensions.create("appTest", AppTestExtension::class.java)
 
         val writeManifestTask =
@@ -71,20 +73,21 @@ class AppTestPlugin : Plugin<Project> {
             // Because every module must be unique, append a placeholder to find/replace on import.
             // https://source.android.com/docs/setup/reference/androidbp
             // "every module must have a name property, and the value must be unique"
-            val rename = project.name + "_AutoReproPlaceholder"
+            val rename = "${project.name}$placeholder"
 
             // Copy our restricted-scope AppTestExtension into the normal Android extension
             // BaseAppModuleExtension is internal to the AGP, but is widely used by similar
             // extensions and unlikely to break
             project.extensions.configure<BaseAppModuleExtension>("android") {
                 // Base on the Gradle project name so each APK is guaranteed to have unique id
-                it.defaultConfig.applicationId = "$namespace.$rename"
+                it.defaultConfig.applicationId =
+                    appTest.applicationId?.let { "$it$placeholder" } ?: "$namespace.$rename"
                 // Set the namespace to reduce refactoring requirements for STS integration
                 // https://developer.android.com/build/configure-app-module#set-namespace
                 it.namespace = namespace
-                it.compileSdk = appTest.compileSdk
-                it.defaultConfig.minSdk = appTest.minSdk
-                it.defaultConfig.targetSdk = appTest.targetSdk
+                it.compileSdk = appTest.compileSdk ?: 34
+                it.defaultConfig.minSdk = appTest.minSdk ?: 31
+                it.defaultConfig.targetSdk = appTest.targetSdk ?: 34
             }
 
             val implementationConfiguration = project.configurations.getByName("implementation")
diff --git a/libraries/sts-common-util/device-side/src/com/android/sts/common/DumpsysUtils.java b/libraries/sts-common-util/device-side/src/com/android/sts/common/DumpsysUtils.java
index c11c8a26b..a12699d53 100644
--- a/libraries/sts-common-util/device-side/src/com/android/sts/common/DumpsysUtils.java
+++ b/libraries/sts-common-util/device-side/src/com/android/sts/common/DumpsysUtils.java
@@ -101,11 +101,17 @@ public class DumpsysUtils {
     public static boolean isActivityResumed(String activityName) {
         // Calls 'getParsedDumpsys' method to retrieve the matcher object for the activity
         // Returns true if 'mResumed=true' is found in the dumpsys output, otherwise false
-        return getParsedDumpsys(
+        Matcher matcher =
+                getParsedDumpsys(
                         "activity" /* service */,
                         Map.of("-a", activityName) /* args */,
-                        Pattern.compile("mResumed=true" /* regex */, Pattern.CASE_INSENSITIVE))
-                .find();
+                        Pattern.compile(
+                                "mResumed=(true|false)" /* regex */, Pattern.CASE_INSENSITIVE));
+        if (!matcher.find()) {
+            throw new IllegalStateException(
+                    "Dumpsys output does not contain status for 'mResumed'");
+        }
+        return Boolean.parseBoolean(matcher.group(1));
     }
 
     /**
@@ -117,12 +123,18 @@ public class DumpsysUtils {
     public static boolean isActivityVisible(String activityName) {
         // Calls 'getParsedDumpsys' method to retrieve the matcher object for the activity
         // Returns true if 'reportedVisible=true' is found in the dumpsys output, otherwise false
-        return getParsedDumpsys(
+        Matcher matcher =
+                getParsedDumpsys(
                         "activity" /* service */,
                         Map.of("-a", activityName) /* args */,
                         Pattern.compile(
-                                "reportedVisible=true" /* regex */, Pattern.CASE_INSENSITIVE))
-                .find();
+                                "reportedVisible=(true|false)" /* regex */,
+                                Pattern.CASE_INSENSITIVE));
+        if (!matcher.find()) {
+            throw new IllegalStateException(
+                    "Dumpsys output does not contain status for 'reportedVisible'");
+        }
+        return Boolean.parseBoolean(matcher.group(1));
     }
 
     /**
diff --git a/libraries/sts-common-util/device-side/tests/AndroidManifest.xml b/libraries/sts-common-util/device-side/tests/AndroidManifest.xml
index 297d913d6..a5616a277 100644
--- a/libraries/sts-common-util/device-side/tests/AndroidManifest.xml
+++ b/libraries/sts-common-util/device-side/tests/AndroidManifest.xml
@@ -17,10 +17,10 @@
     package="com.android.sts.common.util.tests" >
     <application>
         <uses-library android:name="android.test.runner"/>
+        <activity android:name=".helperapp.PocActivity" />
     </application>
     <instrumentation
         android:name="androidx.test.runner.AndroidJUnitRunner"
         android:targetPackage="com.android.sts.common.util.tests"
         android:label="Tests for STS common device-side utils" />
 </manifest>
-
diff --git a/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/DumpsysUtilsTest.java b/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/DumpsysUtilsTest.java
index 789837888..ebf2b8a81 100644
--- a/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/DumpsysUtilsTest.java
+++ b/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/DumpsysUtilsTest.java
@@ -19,15 +19,20 @@ package com.android.sts.common.util.tests;
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
 
 import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
+import static com.android.sts.common.SystemUtil.DEFAULT_MAX_POLL_TIME_MS;
+import static com.android.sts.common.SystemUtil.DEFAULT_POLL_TIME_MS;
 import static com.android.sts.common.SystemUtil.poll;
 
 import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.common.truth.TruthJUnit.assume;
 
 import android.app.Instrumentation;
+import android.app.KeyguardManager;
+import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.provider.Settings;
+import android.content.IntentFilter;
 
 import androidx.test.uiautomator.By;
 import androidx.test.uiautomator.BySelector;
@@ -40,53 +45,122 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BooleanSupplier;
+
 /** Unit tests for {@link DumpsysUtils}. */
 public class DumpsysUtilsTest {
-    private String mActivityName;
-    private UiDevice mUiDevice;
-    private BySelector mSelector;
+    private String mActivityName = null;
+    private UiDevice mUiDevice = null;
+    private BySelector mSelector = null;
+    private Intent mIntent = null;
+    private Context mContext = null;
+    private BroadcastReceiver mBroadcastReceiver = null;
+    private Semaphore mBroadcastReceived = null;
+    private long timeout = 5_000L;
 
     @Before
-    public void setUp() {
+    public void setUp() throws Exception {
         runShellCommand("input keyevent KEYCODE_WAKEUP");
         runShellCommand("wm dismiss-keyguard");
         runShellCommand("input keyevent KEYCODE_HOME");
 
         Instrumentation instrumentation = getInstrumentation();
-        Context context = instrumentation.getContext();
+        mContext = instrumentation.getContext();
         mUiDevice = UiDevice.getInstance(instrumentation);
-        Intent intent =
-                new Intent(Settings.ACTION_SETTINGS).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        ComponentName componentName = intent.resolveActivity(context.getPackageManager());
+        ComponentName componentName =
+                ComponentName.createRelative(mContext, ".helperapp.PocActivity");
+        mIntent =
+                new Intent()
+                        .setComponent(componentName)
+                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
         mActivityName = componentName.flattenToString();
         mSelector = By.pkg(componentName.getPackageName());
-        context.startActivity(intent);
+
+        // Check if device is in locked/secured state.
+        KeyguardManager keyguardManager = mContext.getSystemService(KeyguardManager.class);
+        assume().withMessage("Device is in secured state")
+                .that(keyguardManager.isDeviceSecure() || keyguardManager.isDeviceLocked())
+                .isFalse();
+
+        // Register a broadcast receiver to detect whether the 'PocActivity' was launched.
+        mBroadcastReceiver =
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        mBroadcastReceived.release();
+                    }
+                };
+        mContext.registerReceiver(
+                mBroadcastReceiver,
+                new IntentFilter(mContext.getPackageName()),
+                Context.RECEIVER_EXPORTED);
     }
 
     @After
     public void tearDown() throws Exception {
-        mUiDevice.pressHome();
-        mUiDevice.wait(Until.gone(mSelector), 5_000L /* timeout */);
+        if (mUiDevice != null) {
+            mUiDevice.pressHome();
+
+            if (mSelector != null) {
+                mUiDevice.wait(Until.gone(mSelector), timeout);
+            }
+        }
+
+        if (mBroadcastReceived != null) {
+            mContext.unregisterReceiver(mBroadcastReceiver);
+        }
     }
 
     @Test
     public void testActivityResumed() throws Exception {
         assertWithMessage("Activity was not resumed")
-                .that(poll(() -> DumpsysUtils.isActivityResumed(mActivityName)))
+                .that(startPocActivity(() -> DumpsysUtils.isActivityResumed(mActivityName)))
                 .isTrue();
     }
 
     @Test
     public void testActivityVisible() throws Exception {
         assertWithMessage("Activity was not visible")
-                .that(poll(() -> DumpsysUtils.isActivityVisible(mActivityName)))
+                .that(startPocActivity(() -> DumpsysUtils.isActivityVisible(mActivityName)))
                 .isTrue();
     }
 
     @Test
     public void testActivityLaunched() throws Exception {
         assertWithMessage("Activity was not launched")
-                .that(poll(() -> DumpsysUtils.isActivityLaunched(mActivityName)))
+                .that(startPocActivity(() -> DumpsysUtils.isActivityLaunched(mActivityName)))
+                .isTrue();
+    }
+
+    private boolean startPocActivity(final BooleanSupplier dumpsysCommand) throws Exception {
+        // Start PocActivity and wait for broadcast from 'onResume()'.
+        mBroadcastReceived = new Semaphore(0);
+        Semaphore isPocActivityInOnResume = new Semaphore(0);
+        boolean isStatusExpected =
+                poll(
+                        () -> {
+                            try {
+                                mContext.startActivity(mIntent);
+                                isPocActivityInOnResume.tryAcquire();
+                                if (mBroadcastReceived.tryAcquire(timeout, TimeUnit.MILLISECONDS)) {
+                                    boolean result =
+                                            poll(
+                                                    () -> dumpsysCommand.getAsBoolean(),
+                                                    DEFAULT_POLL_TIME_MS,
+                                                    DEFAULT_MAX_POLL_TIME_MS / 3);
+                                    isPocActivityInOnResume.release();
+                                    return result;
+                                }
+                            } catch (Exception e) {
+                                // Ignore unexpected exceptions.
+                            }
+                            return false;
+                        });
+        assume().withMessage("PocActivity did not start")
+                .that(isPocActivityInOnResume.tryAcquire())
                 .isTrue();
+        return isStatusExpected;
     }
 }
diff --git a/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/helper-app/PocActivity.java b/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/helper-app/PocActivity.java
new file mode 100644
index 000000000..d55944a74
--- /dev/null
+++ b/libraries/sts-common-util/device-side/tests/src/com/android/sts/common/util/helper-app/PocActivity.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.sts.common.util.tests.helperapp;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.HandlerThread;
+
+public class PocActivity extends Activity {
+
+    @Override
+    public void onResume() {
+        try {
+            super.onResume();
+
+            // Create HandlerThread and post the Runnable task to send broadcast after ~2 seconds.
+            HandlerThread handlerThread = new HandlerThread(getPackageName());
+            handlerThread.start();
+            Handler handler = new Handler(handlerThread.getLooper());
+            handler.postDelayed(
+                    () -> sendBroadcast(new Intent(getPackageName())), 2_000L /* delay */);
+        } catch (Exception e) {
+            // Ignore unexpected exceptions.
+        }
+    }
+}
diff --git a/libraries/sts-common-util/util/src/com/android/sts/common/util/StsLogic.java b/libraries/sts-common-util/util/src/com/android/sts/common/util/StsLogic.java
index 38fd3df90..d81fb9dba 100644
--- a/libraries/sts-common-util/util/src/com/android/sts/common/util/StsLogic.java
+++ b/libraries/sts-common-util/util/src/com/android/sts/common/util/StsLogic.java
@@ -77,6 +77,15 @@ public interface StsLogic {
                         "mainline",
                     });
 
+    // skip all tests to ensure tests are running correctly and are compatible with STS
+    // Exceptions:
+    // * skip all tests
+    List<String> STS_EXTRA_BUSINESS_LOGIC_SKIPALL =
+            Arrays.asList(
+                    new String[] {
+                        "skipAllTests",
+                    });
+
     Description getTestDescription();
 
     LocalDate getPlatformSpl();
@@ -97,6 +106,8 @@ public interface StsLogic {
                 return STS_EXTRA_BUSINESS_LOGIC_FULL;
             case "develop":
                 return STS_EXTRA_BUSINESS_LOGIC_DEVELOP;
+            case "skipAll":
+                return STS_EXTRA_BUSINESS_LOGIC_SKIPALL;
             default:
                 throw new RuntimeException(
                         "Could not find Dynamic STS plan in InstrumentationRegistry arguments");
diff --git a/libraries/system-helpers/sysui-helper/src/android/system/helpers/QuickSettingsHelper.java b/libraries/system-helpers/sysui-helper/src/android/system/helpers/QuickSettingsHelper.java
index 6e1280bb0..58a883810 100644
--- a/libraries/system-helpers/sysui-helper/src/android/system/helpers/QuickSettingsHelper.java
+++ b/libraries/system-helpers/sysui-helper/src/android/system/helpers/QuickSettingsHelper.java
@@ -18,6 +18,9 @@ package android.system.helpers;
 
 import static android.content.Context.CONTEXT_IGNORE_SECURITY;
 
+import static com.android.systemui.Flags.qsUiRefactorComposeFragment;
+import static com.android.systemui.Flags.sceneContainer;
+
 import android.app.Instrumentation;
 import android.content.Context;
 import android.content.pm.PackageManager;
@@ -51,7 +54,10 @@ public class QuickSettingsHelper {
     private static final int LONG_TIMEOUT = 2000;
     private static final int SHORT_TIMEOUT = 500;
     private static final String SYSTEMUI_PACKAGE = "com.android.systemui";
-    private static final String QS_DEFAULT_TILES_RES = "quick_settings_tiles_default";
+    private static final String QS_DEFAULT_TILES_RES =
+            (qsUiRefactorComposeFragment() || sceneContainer())
+                    ? "quick_settings_tiles_new_default"
+                    : "quick_settings_tiles_default";
     private static final BySelector FOOTER_SELECTOR = By.res(SYSTEMUI_PACKAGE, "qs_footer");
     private static final String SYSUI_QS_TILES_SETTING = "sysui_qs_tiles";
     private static final String SET_QS_TILES_COMMAND = "cmd statusbar set-tiles ";
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java
index e071ff77b..27de1f797 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java
@@ -71,7 +71,10 @@ public class BubbleSettingsController {
     /** Disallows all bubbles. */
     public void disableBubbles() {
         setBubblesAllowed(NotificationManager.BUBBLE_PREFERENCE_NONE);
-        // Ensure any existing bubble is removed
+        // Ensure nothing is visible from bubbles
         Root.get().verifyNoBubbleIsVisible();
+        Root.get().verifyBubbleBarIsHidden();
+        Root.get().verifyStashedBubbleBarHandleIsHidden();
+        Root.get().verifyBubbleFlyoutIsHidden();
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java
index d80dfba94..2010e8ff3 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java
@@ -32,6 +32,7 @@ import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentat
 
 import android.R;
 import android.annotation.FlaggedApi;
+import android.app.Flags;
 import android.app.Notification;
 import android.app.Notification.Builder;
 import android.app.Notification.MessagingStyle;
@@ -362,6 +363,46 @@ public class NotificationController {
         return customContent;
     }
 
+    /**
+     * Posts a no style promoted ongoing notification.
+     *
+     * <p>Returns the new notification's [StatusBarNotification.getKey()].
+     */
+    @NonNull
+    public NotificationIdentity postNoStyleRON(
+            @Nullable String pkg, @Nullable String title, @Nullable String shortCriticalText) {
+        final Bitmap bitmap = Bitmap.createBitmap(400, 400, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        final Builder builder = makePromotedOngoing(getBuilder(pkg));
+        builder.setLargeIcon(bitmap);
+        builder.setContentTitle(title);
+        builder.setShortCriticalText(shortCriticalText);
+        int id = getNextNotificationId();
+        postNotificationSync(id, builder);
+        String key = getStatusBarNotificationKey(id);
+        return new NotificationIdentity(
+                NotificationIdentity.Type.BY_TITLE,
+                /* title= */ title,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ null,
+                /* hasAction= */ false,
+                /* key= */ key);
+    }
+
+    @NonNull
+    private Builder makePromotedOngoing(@NonNull Builder builder) {
+        builder.setOngoing(true);
+        if (Flags.uiRichOngoing()) {
+            builder.setRequestPromotedOngoing(true);
+        } else {
+            builder.setColorized(true).setColor(Color.GREEN);
+        }
+        return builder;
+    }
+
     /**
      * Posts a notification using {@link android.app.Notification.BigPictureStyle}.
      *
@@ -895,6 +936,16 @@ public class NotificationController {
                         .setStyle(
                                 new android.app.Notification.MessagingStyle(person)
                                         .setConversationTitle(NOTIFICATION_TITLE_TEXT)
+                                        .addMessage(
+                                                new android.app.Notification.MessagingStyle.Message(
+                                                        "Hello, nice to meet you and I am happy to"
+                                                            + " be your friend. You're welcome to"
+                                                            + " join our party tomorrow. Please"
+                                                            + " remember to invite more people and"
+                                                            + " bring some food to share with us!"
+                                                            + " Thank you",
+                                                        SystemClock.currentThreadTimeMillis(),
+                                                        person))
                                         .addMessage(
                                                 new android.app.Notification.MessagingStyle.Message(
                                                         "Message 4",
@@ -1243,6 +1294,17 @@ public class NotificationController {
         return filteredNotificationCount;
     }
 
+    @Nullable
+    private static String getStatusBarNotificationKey(int id) {
+        StatusBarNotification[] notifications = NOTIFICATION_MANAGER.getActiveNotifications();
+        for (StatusBarNotification notification : notifications) {
+            if (notification.getId() == id) {
+                return notification.getKey();
+            }
+        }
+        return null;
+    }
+
     private static boolean hasNotification(int id) {
         StatusBarNotification[] activeNotifications = NOTIFICATION_MANAGER.getActiveNotifications();
         for (StatusBarNotification notification : activeNotifications) {
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt
index 5753188fc..3bc8c7ba4 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt
@@ -19,6 +19,9 @@ package android.platform.systemui_tapl.controller
 /**
  * A way to uniquely identify a notification. It's produced by posting a notification and can be
  * passed to methods for finding a notification.
+ *
+ * @property key the [StatusBarNotification.key] (only filled in if needed for status bar
+ *   assertions)
  */
 data class NotificationIdentity
 @JvmOverloads
@@ -31,6 +34,7 @@ constructor(
     val contentIsVisibleInCollapsedState: Boolean = false,
     val pkg: String? = null,
     val hasAction: Boolean = false,
+    val key: String? = null,
 ) {
     enum class Type {
         GROUP,
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt
index 4863acf1a..1ca16644f 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt
@@ -17,10 +17,11 @@
 package android.platform.systemui_tapl.ui
 
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.view.Display.DEFAULT_DISPLAY
 
 /** System UI test automation object representing the always-on-display. */
-class Aod internal constructor() {
+class Aod internal constructor(displayId: Int = DEFAULT_DISPLAY) {
     init {
-        LockScreen.LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+        LockScreen.lockScreenSelector(displayId).assertVisible { "Lockscreen is not visible" }
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AodRON.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AodRON.kt
new file mode 100644
index 000000000..47a69ee63
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AodRON.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+
+class AodRON internal constructor() {
+    init {
+        LockScreen.RON_AOD_SKELETON.assertVisible { "RON Skeleton is not visible" }
+    }
+
+    fun title(title: String): AodRON = also {
+        waitForObj(notificationByTitleSelector(title)) { "Notification Title is not visible." }
+    }
+
+    private fun notificationByTitleSelector(title: String) =
+        By.copy(LockScreen.RON_AOD_SKELETON).hasDescendant(androidResSelector("title").text(title))
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandle.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandle.kt
new file mode 100644
index 000000000..f935d62a2
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandle.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.animation.TimeInterpolator
+import android.graphics.Point
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import android.view.Display.DEFAULT_DISPLAY
+import java.time.Duration
+
+/** System UI test automation object representing the app handle */
+class AppHandle {
+    companion object {
+        /** Clicks on the app handle to expand the menu and returns [AppHandleMenu]. */
+        @JvmStatic
+        @JvmOverloads
+        fun click(displayId: Int = DEFAULT_DISPLAY): AppHandleMenu {
+            val center = getHandleCenter(displayId)
+            DeviceHelpers.uiDevice.click(center.x, center.y)
+            return AppHandleMenu(displayId)
+        }
+
+        /** Drags from the app handle to the specified location. */
+        @JvmStatic
+        @JvmOverloads
+        fun dragTo(
+            point: Point,
+            duration: Duration = Duration.ofMillis(500),
+            interpolator: TimeInterpolator = PRECISE_GESTURE_INTERPOLATOR,
+            displayId: Int = DEFAULT_DISPLAY,
+        ) {
+            BetterSwipe.swipe(getHandleCenter(displayId), displayId) {
+                pause()
+                to(point, duration, interpolator)
+            }
+        }
+
+        private fun getHandleCenter(displayId: Int): Point {
+            // TODO(b/415121594): find handle by view id
+            val x = DeviceHelpers.uiDevice.getDisplayWidth(displayId) / 2
+            val y = 10 // A little under the top to prevent opening notification shade
+            return Point(x, y)
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandleMenu.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandleMenu.kt
new file mode 100644
index 000000000..c023ca4c9
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AppHandleMenu.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.view.Display.DEFAULT_DISPLAY
+
+/** System UI test automation object representing the app handle menu. */
+class AppHandleMenu
+@JvmOverloads
+internal constructor(private val displayId: Int = DEFAULT_DISPLAY) {
+
+    init {
+        sysuiResSelector(HANDLE_MENU_RES_ID, displayId).assertVisible {
+            "App handle menu is not visible"
+        }
+    }
+
+    fun clickFloating() {
+        sysuiResSelector(FLOATING_BUTTON_RES_ID, displayId).click()
+    }
+
+    companion object {
+        private const val HANDLE_MENU_RES_ID = "handle_menu"
+        private const val FLOATING_BUTTON_RES_ID = "floating_button"
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt
index 97d612874..e254891db 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt
@@ -18,34 +18,44 @@ package android.platform.systemui_tapl.ui
 
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.WaitResult
 import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
 import android.platform.uiautomatorhelpers.scrollUntilFound
 import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
 
 /** Wrapper representing the BluetoothDialog that opens when the QS Tile is clicked */
-class BluetoothDialog internal constructor() {
+class BluetoothDialog internal constructor(displayId: Int = DEFAULT_DISPLAY) {
+    val doneBtn = sysuiResSelector("done_button", displayId)
+
+    init {
+        doneBtn.assertVisible(errorProvider = { "Bluetooth tile dialog is dismissed" })
+    }
+
     val scrollView =
         waitForObj(
-            sysuiResSelector(SCROLL_VIEW_RES_ID)
-                .hasParent(sysuiResSelector(BLUETOOTH_TILE_DIALOG_RES_ID))
+            sysuiResSelector(SCROLL_VIEW_RES_ID, displayId)
+                .hasParent(sysuiResSelector(BLUETOOTH_TILE_DIALOG_RES_ID, displayId))
         )
 
+    fun assertDialogClosed() =
+        doneBtn.assertInvisible(errorProvider = { "Bluetooth tile dialog isn't dismissed" })
+
     /** Finds the done button, clicks on it and asserts that the dialog has closed. */
     fun clickOnDoneAndClose() {
-        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
+        val doneButton = scrollView.scrollUntilFound(doneBtn) ?: error("Done button not found")
         doneButton.click()
-        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
+        if (waitToBecomeTrue { !uiDevice.hasObject(doneBtn) }.result !is WaitResult.WaitSuccess) {
             Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
             doneButton.click()
         }
-        DONE_BTN.assertInvisible(errorProvider = { "Bluetooth tile dialog is dismissed" })
+        assertDialogClosed()
     }
 
     private companion object {
-        val DONE_BTN = sysuiResSelector("done_button")
         const val SCROLL_VIEW_RES_ID = "scroll_view"
         const val BLUETOOTH_TILE_DIALOG_RES_ID = "root"
     }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt
index 32d16f579..f2f852f78 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt
@@ -20,23 +20,25 @@ import android.graphics.Rect
 import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
 import android.platform.uiautomatorhelpers.BetterSwipe
-import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.UiObject2
 import com.android.systemui.Flags
 import com.google.common.truth.Truth.assertThat
 import java.time.Duration
 
 /** System UI test automation object representing the quick settings' brightness slider. */
-class BrightnessSlider internal constructor() {
+class BrightnessSlider internal constructor(private val displayId: Int = DEFAULT_DISPLAY) {
     private val slider: UiObject2
 
     init {
-        val selector = sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID)
+        val selector = sliderSelector(displayId)
         slider =
             waitForObj(selector, LONG_WAIT) { "$selector not found" }
-                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID))
+                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID, displayId))
     }
 
     /** Slides from left to right */
@@ -59,19 +61,20 @@ class BrightnessSlider internal constructor() {
             )
         // NOTE: This control logic is less than clean.
         if (Flags.qsUiRefactorComposeFragment()) {
-            BetterSwipe.swipe(pointFrom, pointTo, swipeDuration, PRECISE_GESTURE_INTERPOLATOR)
+            BetterSwipe.swipe(
+                pointFrom, pointTo, swipeDuration, PRECISE_GESTURE_INTERPOLATOR, displayId)
             if (Flags.qsUiRefactorComposeFragment()) {
                 // In this case, the slider is moved to an overlay, then we verify:
                 // The notification shade is not visible, but
-                assertVisibility(sysuiResSelector(UI_NOTIFICATION_SHADE_ID), visible = false)
+                sysuiResSelector(UI_NOTIFICATION_SHADE_ID, displayId).assertInvisible()
                 // The actual slider is visible, and
-                assertVisibility(sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID), visible = true)
+                sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID, displayId).assertVisible()
                 // The bounds haven't changed.
                 assertThat(slider.visibleBounds).isEqualTo(sliderBounds)
             }
         } else {
             var mirrorBounds: Rect? = null
-            BetterSwipe.swipe(pointFrom) {
+            BetterSwipe.swipe(pointFrom, displayId) {
                 to(pointTo, swipeDuration, PRECISE_GESTURE_INTERPOLATOR)
                 mirrorBounds = brightnessSliderMirror.visibleBounds
                 assertThat(sliderBounds).isEqualTo(mirrorBounds)
@@ -85,14 +88,17 @@ class BrightnessSlider internal constructor() {
         get() {
             // The Mirror slider has the same id as the original one, so we get it from the
             // container
-            return waitForObj(sysuiResSelector(UI_BRIGHTNESS_MIRROR_CONTAINER_ID))
-                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID))
+            return waitForObj(sysuiResSelector(UI_BRIGHTNESS_MIRROR_CONTAINER_ID, displayId))
+                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID, displayId))
         }
 
-    private companion object {
-        const val UI_TOGGLE_SEEKBAR_ID = "slider"
-        const val UI_BRIGHTNESS_SLIDER_ID = "brightness_slider"
-        const val UI_BRIGHTNESS_MIRROR_CONTAINER_ID = "brightness_mirror_container"
-        const val UI_NOTIFICATION_SHADE_ID = "notification_shade"
+    companion object {
+        private const val UI_TOGGLE_SEEKBAR_ID = "slider"
+        private const val UI_BRIGHTNESS_SLIDER_ID = "brightness_slider"
+        private const val UI_BRIGHTNESS_MIRROR_CONTAINER_ID = "brightness_mirror_container"
+        private const val UI_NOTIFICATION_SHADE_ID = "notification_shade"
+
+        fun sliderSelector(displayId: Int = DEFAULT_DISPLAY) =
+            sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID, displayId)
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt
index c18c69026..efef5dc3f 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt
@@ -25,6 +25,7 @@ import android.platform.uiautomatorhelpers.BetterSwipe
 import android.platform.uiautomatorhelpers.DeviceHelpers.context
 import android.platform.uiautomatorhelpers.DeviceHelpers.hasObject
 import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObj
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForPossibleEmpty
 import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
 import android.view.WindowInsets
@@ -33,7 +34,6 @@ import androidx.test.uiautomator.UiObject2
 import com.android.wm.shell.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import java.time.Duration
-import java.time.temporal.ChronoUnit
 
 /**
  * System UI test automation object representing a notification bubble, specifically the view
@@ -96,17 +96,21 @@ class Bubble internal constructor(private val bubbleView: UiObject2) {
         val insets =
             windowMetrics.windowInsets.getInsetsIgnoringVisibility(
                 WindowInsets.Type.mandatorySystemGestures() or
-                    WindowInsets.Type.navigationBars() or
-                    WindowInsets.Type.displayCutout()
+                        WindowInsets.Type.navigationBars() or
+                        WindowInsets.Type.displayCutout()
             )
         val destination =
             Point(windowMetrics.bounds.width() / 2, (windowMetrics.bounds.height() - insets.bottom))
-        BetterSwipe.swipe(
-            bubbleView.visibleCenter,
-            destination,
-            duration = Duration.of(700, ChronoUnit.MILLIS),
-            interpolator = PRECISE_GESTURE_INTERPOLATOR,
-        )
+        // drag to bottom of the screen, wait for dismiss view to appear, drag to dismiss view
+        BetterSwipe.swipe(bubbleView.visibleCenter) {
+            to(destination, interpolator = PRECISE_GESTURE_INTERPOLATOR)
+            // Make dismiss view optional in case the EDU view was shown and first swipe hid that.
+            // We will do a second swipe to actually dismiss.
+            val dismissView = waitForNullableObj(DISMISS_VIEW)
+            if (dismissView != null) {
+                to(dismissView.visibleCenter, interpolator = PRECISE_GESTURE_INTERPOLATOR)
+            }
+        }
     }
 
     override fun equals(other: Any?): Boolean {
@@ -121,6 +125,7 @@ class Bubble internal constructor(private val bubbleView: UiObject2) {
         val FIND_OBJECT_TIMEOUT = Duration.ofSeconds(20)
         val BUBBLE_VIEW = sysuiResSelector("bubble_view")
         val BUBBLE_BAR_VIEWS = launcherResSelector("bubble_view")
+        private val DISMISS_VIEW = sysuiResSelector("dismiss_view")
         private val STACK_EXPAND_TIMEOUT = Duration.ofSeconds(1)
         private val BUBBLE_STACK_EDUCATION = sysuiResSelector("stack_education_layout")
 
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarFlyout.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarFlyout.kt
index 7583d2c59..407092c8a 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarFlyout.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarFlyout.kt
@@ -38,6 +38,6 @@ class BubbleBarFlyout {
     }
 
     companion object {
-        internal val BUBBLE_BAR_FLYOUT_VIEW = launcherResSelector("bubble_bar_flyout_view")
+        val BUBBLE_BAR_FLYOUT_VIEW = launcherResSelector("bubble_bar_flyout_view")
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt
index 1db79cbe7..d4c35d435 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt
@@ -27,18 +27,18 @@ import java.time.Duration
  */
 class BubbleFlyout internal constructor() {
     init {
-        BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW.assertVisible(timeout = TIMEOUT)
+        BUBBLE_FLYOUT_TEXT_CONTAINER_VIEW.assertVisible(timeout = TIMEOUT)
     }
 
     /** Fails if the flyout doesn't auto-close */
     fun verifyAutoClosing() {
-        BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW.assertInvisible(timeout = TIMEOUT) {
+        BUBBLE_FLYOUT_TEXT_CONTAINER_VIEW.assertInvisible(timeout = TIMEOUT) {
             "Flyout didn't auto close"
         }
     }
 
-    private companion object {
-        val BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW = sysuiResSelector("bubble_flyout_text_container")
+    companion object {
+        val BUBBLE_FLYOUT_TEXT_CONTAINER_VIEW = sysuiResSelector("bubble_flyout_text_container")
         val TIMEOUT = Duration.ofSeconds(20)
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt
index ec150dc20..5235cde26 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt
@@ -82,19 +82,17 @@ class ChooseScreenLock internal constructor() {
     private companion object {
         @JvmField val LONG_WAIT_TIME: Duration = Duration.ofSeconds(15)
 
-        const val BUTTON_CLASS = "android.widget.Button"
-
         // https://hsv.googleplex.com/6685423272198144?node=7
         val CHOOSE_A_SCREEN_LOCK_SELECTOR: BySelector =
             settingsResSelector("collapsing_toolbar").desc("Choose a screen lock")
 
         val PASSWORD_ENTRY: BySelector = settingsResSelector("password_entry")
 
-        val NEXT_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Next")
+        val NEXT_BUTTON_SELECTOR: BySelector = By.text("Next")
 
-        val CONFIRM_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Confirm")
+        val CONFIRM_BUTTON_SELECTOR: BySelector = By.text("Confirm")
 
         // https://hsv.googleplex.com/5618542457126912?node=26
-        val DONE_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Done")
+        val DONE_BUTTON_SELECTOR: BySelector = By.text("Done")
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt
index 109971972..979aff822 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt
@@ -19,11 +19,12 @@ package android.platform.systemui_tapl.ui
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
 import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
 import android.platform.test.scenario.tapl_common.Gestures
-import android.platform.test.scenario.tapl_common.Gestures.click
+import android.platform.test.scenario.tapl_common.Gestures.shortClick
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import android.text.TextUtils
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.UiObject2
@@ -35,9 +36,10 @@ import kotlin.reflect.KClass
  *
  * In order to interact with the tile, [getBehavior] needs to be called, with the type of behavior
  * needed. There are also convenience methods for calling [click], [toggleAndAssertToggled], and
- * [longPress]. These methods will fail the test if the tile doesn't support that interaction.
+ * [longPressAndAssertSettings]. These methods will fail the test if the tile doesn't support that
+ * interaction.
  */
-abstract class ComposeQuickSettingsTile private constructor() {
+abstract class ComposeQuickSettingsTile private constructor(val displayId: Int = DEFAULT_DISPLAY) {
     /**
      * Representation of the tile object. This should be made to retrieve the object every time (if
      * possible) to prevent stale objects.
@@ -107,8 +109,8 @@ abstract class ComposeQuickSettingsTile private constructor() {
      *
      * See [Toggleable.toggleAndAssertToggled]
      */
-    fun toggleAndAssertToggled() {
-        getBehavior<Toggleable>()!!.toggleAndAssertToggled()
+    fun toggleAndAssertToggled(extraValidation: () -> Unit = {}) {
+        getBehavior<Toggleable>()!!.toggleAndAssertToggled(extraValidation)
     }
 
     /**
@@ -116,16 +118,29 @@ abstract class ComposeQuickSettingsTile private constructor() {
      * [SETTINGS_PACKAGE] if `null`) is visible afterwards. This will fail if the tile does not
      * support [LongPressable].
      *
-     * See [LongPressable.longPress]
+     * See [LongPressable.longPressAndAssertSettings]
      */
-    fun longPress(expectedSettingsPackage: String? = null) {
-        getBehavior<LongPressable>()!!.longPress(expectedSettingsPackage)
+    fun longPressAndAssertSettings(expectedSettingsPackage: String? = null) {
+        getBehavior<LongPressable>()!!.longPressAndAssertSettings(expectedSettingsPackage)
+    }
+
+    /**
+     * Perform a long press on the tile, without performing any validation. This will fail if the
+     * tile does not support [LongPressable].
+     *
+     * See [LongPressable.longPres]
+     */
+    fun longPress() {
+        getBehavior<LongPressable>()!!.longPress()
     }
 
     companion object {
         /** Create a [ComposeQuickSettingsTile] wrapper from a fixed [tile] ui object. */
-        fun createFrom(tile: UiObject2): ComposeQuickSettingsTile {
-            return object : ComposeQuickSettingsTile() {
+        fun createFrom(
+            tile: UiObject2,
+            displayId: Int = DEFAULT_DISPLAY,
+        ): ComposeQuickSettingsTile {
+            return object : ComposeQuickSettingsTile(displayId) {
                 override val tile: UiObject2
                     get() = tile
             }
@@ -135,21 +150,25 @@ abstract class ComposeQuickSettingsTile private constructor() {
          * Create a [ComposeQuickSettingsTile] wrapper based on a [selector]. The wrapper will
          * re-fetch the ui object every time it's needed, giving more flexibility in case of stale.
          */
-        fun createFrom(selector: BySelector): ComposeQuickSettingsTile {
-            return object : ComposeQuickSettingsTile() {
+        fun createFrom(
+            selector: BySelector,
+            displayId: Int = DEFAULT_DISPLAY,
+        ): ComposeQuickSettingsTile {
+            return object : ComposeQuickSettingsTile(displayId) {
                 override val tile: UiObject2
                     get() = waitForObj(selector)
             }
         }
 
         /** See https://hsv.googleplex.com/4910828112314368?node=37 */
-        fun smallTileSelector(description: String): BySelector {
-            return sysuiResSelector(SMALL_TILE_TAG).descStartsWith(description)
+        fun smallTileSelector(description: String, displayId: Int = DEFAULT_DISPLAY): BySelector {
+            return sysuiResSelector(SMALL_TILE_TAG, displayId).descStartsWith(description)
         }
 
         /** See https://hsv.googleplex.com/4910828112314368?node=28 */
-        fun largeTileSelector(description: String): BySelector {
-            return sysuiResSelector(LARGE_TILE_TAG).hasChild(By.textStartsWith(description))
+        fun largeTileSelector(description: String, displayId: Int = DEFAULT_DISPLAY): BySelector {
+            return sysuiResSelector(LARGE_TILE_TAG, displayId)
+                .hasChild(By.displayId(displayId).textStartsWith(description))
         }
 
         fun UiObject2.assertIsTile() {
@@ -184,7 +203,7 @@ private class ClickableImpl(private val tile: UiObject2) : Clickable {
     }
 
     override fun click() {
-        click(tile, "Tile")
+        shortClick(tile, "Tile")
     }
 }
 
@@ -196,8 +215,14 @@ interface Toggleable : TileBehavior {
     /** Whether the tile is currently in its On state */
     val isChecked: Boolean
 
-    /** Toggle the tile between On/Off. Validates that the tile has changed checked state. */
-    fun toggleAndAssertToggled()
+    /**
+     * Toggle the tile between On/Off. Validates that the tile has changed checked state.
+     *
+     * [extraValidation] can be provided and will be performed immediately after clicking on the
+     * tile, before waiting for the tile to change state. This can be used for verifying ephemeral
+     * effects.
+     */
+    fun toggleAndAssertToggled(extraValidation: () -> Unit = {})
 
     /** Asserts the current checked state with a nice message. */
     fun assertCheckedStatus(checked: Boolean)
@@ -212,9 +237,10 @@ private open class ToggleableImpl(private val tile: UiObject2) : Toggleable {
     override val isChecked: Boolean
         get() = tile.isChecked
 
-    override fun toggleAndAssertToggled() {
+    override fun toggleAndAssertToggled(extraValidation: () -> Unit) {
         val wasChecked = isChecked
-        click(tile, "Tile")
+        shortClick(tile, "Tile")
+        extraValidation()
         assertCheckedStatus(!wasChecked)
     }
 
@@ -230,7 +256,10 @@ interface LongPressable : TileBehavior {
      * Long press on the tile. Validates that a settings activity with the correct package was
      * launched.
      */
-    fun longPress(expectedSettingsPackage: String? = null)
+    fun longPressAndAssertSettings(expectedSettingsPackage: String? = null)
+
+    /** Long press on the tile. Performs no validation. */
+    fun longPress()
 }
 
 private class LongPressableImpl(private val tile: UiObject2) : LongPressable {
@@ -238,12 +267,18 @@ private class LongPressableImpl(private val tile: UiObject2) : LongPressable {
         check(tile.isLongClickable)
     }
 
-    override fun longPress(expectedSettingsPackage: String?) {
-        Gestures.longClickDownUp(tile, "Quick settings tile") {
+    override fun longPressAndAssertSettings(expectedSettingsPackage: String?) {
+        Gestures.longClickDownUp(tile, "Quick settings tile", tile.displayId) {
             val packageName = expectedSettingsPackage ?: SETTINGS_PACKAGE
-            By.pkg(packageName).assertVisible { "$packageName didn't appear" }
+            By.displayId(tile.displayId).pkg(packageName).assertVisible {
+                "$packageName didn't appear"
+            }
         }
     }
+
+    override fun longPress() {
+        Gestures.longClickDownUp(tile, "Quick settings tile", tile.displayId) {}
+    }
 }
 
 /**
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt
index e0e7a8daf..4ce4be471 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt
@@ -18,15 +18,37 @@ package android.platform.systemui_tapl.ui
 
 fun ComposeQuickSettingsTile.clickInternetTileToOpenDialog(): InternetDialog {
     click()
-    return InternetDialog()
+    return InternetDialog(displayId)
 }
 
 fun ComposeQuickSettingsTile.clickBluetoothTileToOpenDialog(): BluetoothDialog {
-    click()
-    return BluetoothDialog()
+    clickToOpenDialogOnDualTarget()
+    return BluetoothDialog(displayId)
+}
+
+fun ComposeQuickSettingsTile.clickFlashlightTileToOpenDialog(): FlashlightDialog {
+    clickToOpenDialogOnDualTarget()
+    return FlashlightDialog(displayId)
 }
 
 fun ComposeQuickSettingsTile.clickModesTileToOpenDialog(): ModesDialog {
-    click()
-    return ModesDialog()
+    clickToOpenDialogOnDualTarget()
+    return ModesDialog(displayId)
+}
+
+private fun ComposeQuickSettingsTile.clickToOpenDialogOnDualTarget() {
+    if (isSmallTile) {
+        longPress()
+    } else {
+        click()
+    }
+}
+
+/** Returns a Toggleable behavior for a dual target tile, regardless of the tile size. */
+fun ComposeQuickSettingsTile.getToggleableBehaviorForDualTarget(): Toggleable {
+    return if (isSmallTile) {
+        getBehavior<Toggleable>()!!
+    } else {
+        getBehavior<ToggleableDualTarget>()!!
+    }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt
index aade1473c..d90e97373 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt
@@ -41,10 +41,10 @@ class ExpandedBubbleBar(val selectedBubble: BubbleBarItem) {
     val expandedBubble: ExpandedBubbleBarBubble
         get() = ExpandedBubbleBarBubble()
 
-    /** Collapses the bubble bar by tapping on the selected bubble and returns [BubbleBar]. */
-    fun collapse(): BubbleBar {
+    /** Collapses the bubble bar by tapping on the selected bubble. */
+    fun collapse() {
         selectedBubble.item.click()
-        return BubbleBar()
+        Root.get().verifyNoExpandedBubbleIsVisible()
     }
 
     /**
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/FlashlightDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/FlashlightDialog.kt
new file mode 100644
index 000000000..a77435b56
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/FlashlightDialog.kt
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.WaitResult
+import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
+import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
+import androidx.test.uiautomator.By
+
+/** Wrapper representing the FlashlightDialog that opens when the QS Tile is clicked */
+class FlashlightDialog internal constructor(displayId: Int = DEFAULT_DISPLAY) {
+    private val uiDialogTitle = By.text("Flashlight Strength")
+    private val doneBtn = By.text("Done")
+
+    // TODO (b/419868372) use the dialog title since we know what it is
+
+    init {
+        uiDialogTitle.assertVisible(errorProvider = { "Flashlight dialog title is not visible" })
+        doneBtn.assertVisible(errorProvider = { "Flashlight tile done button is not visible" })
+    }
+
+    fun assertDialogClosed() =
+        uiDialogTitle.assertInvisible(errorProvider = { "Flashlight dialog title is visible" })
+
+    /** Finds the done button, clicks on it and asserts that the dialog has closed. */
+    fun clickOnDoneAndClose() {
+        doneBtn.click()
+        if (waitToBecomeTrue { !uiDevice.hasObject(doneBtn) }.result !is WaitResult.WaitSuccess) {
+            Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
+            doneBtn.click()
+        }
+        assertDialogClosed()
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt
index 1f638e546..32acf16f9 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt
@@ -24,27 +24,32 @@ import android.platform.uiautomatorhelpers.WaitResult
 import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
 import android.platform.uiautomatorhelpers.scrollUntilFound
 import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.UiObject2
 
 /** Wrapper representing the InternetDialog that opens when the QS Tile is clicked */
-class InternetDialog internal constructor() {
+class InternetDialog internal constructor(displayId: Int = DEFAULT_DISPLAY) {
     private val scrollView: UiObject2 =
-        waitForObj(sysuiResSelector(SCROLL_VIEW_RES_ID).hasParent(sysuiResSelector(DIALOG_RES_ID)))
+        waitForObj(
+            sysuiResSelector(SCROLL_VIEW_RES_ID, displayId)
+                .hasParent(sysuiResSelector(DIALOG_RES_ID, displayId))
+        )
+
+    val doneBtn = sysuiResSelector("done_button", displayId)
 
     /** Finds the done button, clicks on it and asserts that the dialog has closed. */
     fun clickOnDoneAndClose() {
-        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
+        val doneButton = scrollView.scrollUntilFound(doneBtn) ?: error("Done button not found")
         doneButton.click()
-        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
+        if (waitToBecomeTrue { !uiDevice.hasObject(doneBtn) }.result !is WaitResult.WaitSuccess) {
             Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
             doneButton.click()
         }
-        DONE_BTN.assertInvisible(errorProvider = { "Internet dialog is dismissed" })
+        doneBtn.assertInvisible(errorProvider = { "Internet dialog is dismissed" })
     }
 
     private companion object {
         const val DIALOG_RES_ID = "internet_connectivity_dialog"
         const val SCROLL_VIEW_RES_ID = "scroll_view"
-        val DONE_BTN = sysuiResSelector("done_button")
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt
index 6c51a69d9..77317a857 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt
@@ -27,16 +27,30 @@ import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
 import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
 import com.android.launcher3.tapl.LauncherInstrumentation
 import com.android.launcher3.tapl.Workspace
 import com.android.systemui.Flags.sceneContainer
 import com.google.common.truth.Truth.assertWithMessage
 
 /** System UI test automation object representing the lock screen. */
-class LockScreen internal constructor() {
+class LockScreen internal constructor(val displayId: Int = DEFAULT_DISPLAY) {
+    private val lockScreenIconSelector: BySelector =
+        sysuiResSelector("device_entry_icon_view", displayId)
+
+    private val lockScreenSelector: BySelector = lockScreenSelector(displayId)
+
+    private val swipeableArea: BySelector =
+        if (sceneContainer()) {
+            sysuiResSelector("shared_notification_container", displayId)
+        } else {
+            sysuiResSelector("notification_panel", displayId)
+        }
+
     init {
-        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+        lockScreenSelector.assertVisible { "Lockscreen is not visible on display $displayId" }
     }
 
     /**
@@ -68,7 +82,7 @@ class LockScreen internal constructor() {
     /** Swipes up to the unlocked state. */
     fun swipeUpToUnlock(): Workspace {
         swipeUp()
-        LOCKSCREEN_SELECTOR.assertInvisible { "Lockscreen still visible after swiping up." }
+        lockScreenSelector.assertInvisible { "Lockscreen still visible after swiping up." }
         assertWithMessage("Device is still locked after swiping up")
             .that(LockscreenController.get().isDeviceLocked)
             .isFalse()
@@ -78,7 +92,7 @@ class LockScreen internal constructor() {
     /** Uses home key to get to the unlocked state, skipping potentially flaky gesture. */
     fun unlockDirectly() {
         uiDevice.pressMenu()
-        LOCKSCREEN_SELECTOR.assertInvisible { "Lockscreen still visible after swiping up." }
+        lockScreenSelector.assertInvisible { "Lockscreen still visible after swiping up." }
         assertWithMessage("Device is still locked after swiping up")
             .that(LockscreenController.get().isDeviceLocked)
             .isFalse()
@@ -103,7 +117,7 @@ class LockScreen internal constructor() {
      */
     val lockIcon: LockscreenLockIcon
         get() {
-            val lockIcon = waitForObj(LOCK_ICON_SELECTOR) { "Lockscreen lock icon not found" }
+            val lockIcon = waitForObj(lockScreenIconSelector) { "Lockscreen lock icon not found" }
             return LockscreenLockIcon(/* rect= */ lockIcon.visibleBounds)
         }
 
@@ -130,42 +144,41 @@ class LockScreen internal constructor() {
     }
 
     private fun swipeUp() {
-        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
-        val swipeableArea = waitForObj(SWIPEABLE_AREA) { "Swipeable area not found" }
+        lockScreenSelector.assertVisible { "Lockscreen is not visible" }
+        val swipeableArea = waitForObj(swipeableArea) { "Swipeable area not found" }
         // shift swipe gesture over to left so we don't begin the gesture on the lock icon
         //   this can be removed if b/229696938 gets resolved to allow for swiping on the icon
         val bounds = swipeableArea.visibleBounds
         val swipeX = bounds.left + bounds.width() / 4f
-        BetterSwipe.swipe(PointF(swipeX, bounds.bottom - 1f), PointF(swipeX, bounds.top.toFloat()))
+        BetterSwipe.swipe(
+            PointF(swipeX, bounds.bottom - 1f),
+            PointF(swipeX, bounds.top.toFloat()),
+            displayId = displayId,
+        )
     }
 
     private fun swipeLeft() {
-        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
-        val swipeableArea = waitForObj(SWIPEABLE_AREA) { "Swipeable area not found" }
+        lockScreenSelector.assertVisible { "Lockscreen is not visible" }
+        val swipeableArea = waitForObj(swipeableArea) { "Swipeable area not found" }
         val bounds = swipeableArea.visibleBounds
         val swipeY = bounds.top + bounds.height() / 2f
         BetterSwipe.swipe(
             PointF(bounds.right - 1f, swipeY),
             PointF(bounds.left + bounds.width() / 2f, swipeY),
+            displayId = displayId,
         )
     }
 
     companion object {
-        private val LOCK_ICON_SELECTOR = sysuiResSelector("device_entry_icon_view")
-
         // https://hsv.googleplex.com/5130837462876160?node=117
-        val LOCKSCREEN_SELECTOR =
+        fun lockScreenSelector(displayId: Int = DEFAULT_DISPLAY): BySelector =
             if (sceneContainer()) {
-                By.res("element:lockscreen")
+                By.displayId(displayId).res("element:lockscreen")
             } else {
-
-                sysuiResSelector("keyguard_indication_area")
-            }
-        private val SWIPEABLE_AREA =
-            if (com.android.systemui.Flags.sceneContainer()) {
-                sysuiResSelector("shared_notification_container")
-            } else {
-                sysuiResSelector("notification_panel")
+                sysuiResSelector("keyguard_indication_area", displayId)
             }
+
+        // https://hsv.googleplex.com/5656353459666944
+        val RON_AOD_SKELETON = sysuiResSelector("aod_promoted_notification_frame")
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt
index 95c95acf6..01d232aa8 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt
@@ -18,23 +18,27 @@ package android.platform.systemui_tapl.ui
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.UiObject2
-import com.android.launcher3.tapl.LauncherInstrumentation
 import java.time.Duration
 
 /** System UI test automation object representing the modes list dialog. */
-class ModesDialog internal constructor() {
+class ModesDialog internal constructor(val displayId: Int = DEFAULT_DISPLAY) {
+
+    private val uiDialogTitle = By.displayId(displayId).res(UI_DIALOG_TITLE_ID)
+    private val modesStateOn = By.displayId(displayId).res("stateOn")
+    private val modesStateOff = By.displayId(displayId).res("stateOff")
 
     init {
-        UI_DIALOG_TITLE.assertVisible()
+        uiDialogTitle.assertVisible()
     }
 
     /* Dismisses the dialog by the Back gesture */
     fun dismiss() {
         // Press back to dismiss the dialog
-        LauncherInstrumentation().pressBack()
-        UI_DIALOG_TITLE.assertInvisible()
+        Root.get(displayId).pressBackOnDisplay()
+        uiDialogTitle.assertInvisible()
     }
 
     private fun getModeTile(modeName: String): UiObject2 {
@@ -48,7 +52,7 @@ class ModesDialog internal constructor() {
     fun verifyModeState(modeName: String, isOn: Boolean) {
         val modeTile = getModeTile(modeName)
         modeTile.waitForObj(
-            if (isOn) MODE_STATE_ON_SELECTOR else MODE_STATE_OFF_SELECTOR,
+            if (isOn) modesStateOn else modesStateOff,
             errorProvider = { "Tile not in correct state, wanted ${if (isOn) "On" else "Off"}" },
         )
     }
@@ -56,10 +60,7 @@ class ModesDialog internal constructor() {
     companion object {
         private const val UI_DIALOG_TITLE_ID = "modes_title"
         private const val UI_ALERT_DIALOG_NEGATIVE_BUTTON_ID = "button2"
-        private val UI_DIALOG_TITLE = By.res(UI_DIALOG_TITLE_ID)
         private val MODE_NAME_SELECTOR = By.res("name")
-        private val MODE_STATE_ON_SELECTOR = By.res("stateOn")
-        private val MODE_STATE_OFF_SELECTOR = By.res("stateOff")
         private val UI_RESPONSE_TIMEOUT = Duration.ofSeconds(3)
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt
index 8f5485354..94845648a 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt
@@ -121,9 +121,13 @@ internal constructor(
     }
 
     /**
-     * Verifies that the notification is in HUN state. HUN State: A notification that has the expand
-     * button (chevron) at the expand status, and has at least an action that is currently
-     * showing. We only allow assertion of HUN state for notifications that have action buttons.
+     * Verifies that the notification is in HUN state.
+     *
+     * HUNs are the only notification state where:
+     * 1) It's collapsed by default so it has an expand button (chevron) at the "expand status"; AND
+     * 2) It shows action buttons even in the collapsed state. Because of this, we only allow
+     *    assertion of HUN state for notifications that have action buttons.
+     *
      * Fails if the notification is not at the HUN state defined above.
      */
     fun verifyIsHunState() {
@@ -145,6 +149,25 @@ internal constructor(
         )
     }
 
+    /**
+     * Verifies that the notification is a promoted ongoing notification.
+     *
+     * Promoted notifications are the only notification state where the notification is always
+     * expanded, so there shouldn't be an expand OR collapse caret.
+     *
+     * Fails if the notification is not in the promoted state defined above.
+     */
+    fun verifyIsPromotedOngoingState() {
+        notification.assertVisibility(
+            selector = androidResSelector(EXPAND_BUTTON_ID),
+            visible = false,
+            errorProvider = {
+                "Promoted ongoing state assertion error: The notification is found, " +
+                    "but is not promoted because it has an expand button."
+            },
+        )
+    }
+
     /** Swipes on the notification but not able to dismiss the notification. */
     fun swipeButNotDismiss() {
         val rowCountBeforeSwipe = expandableNotificationRows.size
@@ -297,9 +320,10 @@ internal constructor(
     }
 
     /** Clicks the notification to open the bouncer. */
-    fun clickToBouncer(): Bouncer {
+    @JvmOverloads
+    fun clickToBouncer(fromExpandedShadeOnLockscreen: Boolean = false): Bouncer {
         assertWithMessage("The notification should be a lockscreen one")
-            .that(fromLockscreen)
+            .that(fromLockscreen || fromExpandedShadeOnLockscreen)
             .isTrue()
         Gestures.click(notification, "Notification")
         return Bouncer(/* notification= */ this)
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt
index 231c34048..0e3bbb64e 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt
@@ -16,6 +16,7 @@
 
 package android.platform.systemui_tapl.ui
 
+import android.hardware.display.DisplayManager
 import android.os.SystemClock
 import android.platform.helpers.CommonUtils
 import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
@@ -29,24 +30,28 @@ import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
 import android.platform.uiautomatorhelpers.DeviceHelpers.context
 import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
-import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.view.Display.DEFAULT_DISPLAY
 import android.view.WindowManager
+import android.view.WindowManager.LayoutParams.TYPE_APPLICATION
 import android.view.WindowMetrics
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.Direction
 import androidx.test.uiautomator.UiObject2
 import androidx.test.uiautomator.Until
+import com.android.app.tracing.traceSection
 import com.android.launcher3.tapl.LauncherInstrumentation
 import com.android.systemui.Flags
 import com.google.common.truth.StandardSubjectBuilder
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
+import java.time.Duration
 import kotlin.math.floor
 
 /** System UI test automation object representing the notification shade. */
-class NotificationShade internal constructor() {
+class NotificationShade internal constructor(val displayId: Int = DEFAULT_DISPLAY) {
     init {
         if (CommonUtils.isSplitShade()) {
             val qsBounds = quickSettingsContainer.visibleBounds
@@ -59,6 +64,17 @@ class NotificationShade internal constructor() {
         }
     }
 
+    private val displayContext by lazy {
+        if (displayId == DEFAULT_DISPLAY) return@lazy context
+
+        // We create a new window context to get accurate bounds for overlay displays
+        val displayManager =
+            context.getSystemService(DisplayManager::class.java)
+                ?: error("Couldn't get DisplayManager")
+        val display = displayManager.getDisplay(displayId)
+        return@lazy context.createWindowContext(display, TYPE_APPLICATION, null)
+    }
+
     /* fromLockscreen= */
     /** Returns the shade's notification stack. */
     val notificationStack: NotificationStack
@@ -74,13 +90,13 @@ class NotificationShade internal constructor() {
     /** Check whether QuickSettings are expanded in the NotificationShade. */
     fun assertQuickSettingsExpanded() {
         assertWithMessage("QuickQuickSettings is visible")
-            .waitUntilGone(QuickQuickSettings.UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR)
+            .waitUntilGone(QuickQuickSettings.qsContainerSelector(displayId))
     }
 
     /** Check whether QuickSettings are collapsed in the NotificationShade. */
     fun assertQuickSettingsCollapsed() {
         assertWithMessage("QuickQuickSettings not visible, shade is not collapsed")
-            .waitUntilVisible(QuickQuickSettings.UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR)
+            .waitUntilVisible(QuickQuickSettings.qsContainerSelector(displayId))
     }
 
     fun verifyIsEmpty() {
@@ -139,7 +155,7 @@ class NotificationShade internal constructor() {
                 objectName = "Clear All button",
             )
             .click()
-        waitForShadeToClose()
+        waitForShadeToClose(displayId)
         Root.get().goHomeViaKeycode()
     }
 
@@ -184,34 +200,52 @@ class NotificationShade internal constructor() {
     /** Closes the shade. */
     fun close() {
         val device = uiDevice
-        // Swipe in first quarter to avoid desktop windowing app handle interactions.
-        val swipeXCoordinate = device.displayWidth / 4
-        device.betterSwipe(
+        // Swipe in third quarter to avoid desktop windowing app handle interactions, and due to
+        // the flexiglass notification shade not always being responsive on left side (b/406203539)
+        val swipeXCoordinate = device.getDisplayWidth(displayId) * 3 / 4
+        betterSwipe(
             startX = swipeXCoordinate,
             startY = screenBottom,
             endX = swipeXCoordinate,
             endY = 0,
             interpolator = FLING_GESTURE_INTERPOLATOR,
+            displayId = displayId,
         )
-        waitForShadeToClose()
+        waitForShadeToClose(displayId)
     }
 
     /** Closes the shade with the back button. */
     fun closeWithBackButton() {
         LauncherInstrumentation().pressBack()
-        waitForShadeToClose()
+        waitForShadeToClose(displayId)
     }
 
+    private val quickSettingsContainer: UiObject2
+        get() =
+            waitForObj(
+                sysuiResSelector(UI_QS_CONTAINER_ID, displayId),
+                Duration.ofMillis(UI_RESPONSE_TIMEOUT_MSECS),
+            ) {
+                "Can't find qs container on display $displayId."
+            }
+
+    private val notificationShadeScrollContainer: UiObject2
+        get() =
+            waitForObj(
+                sysuiResSelector(UI_SCROLLABLE_ELEMENT_ID, displayId),
+                Duration.ofMillis(UI_RESPONSE_TIMEOUT_MSECS),
+            ) {
+                "Can't find notification shade scroll container on display $displayId."
+            }
+
     // UiDevice#getDisplayHeight() excludes insets.
     private val screenBottom: Int
         get() {
             val mWindowMetrics: WindowMetrics =
-                context
-                    .getSystemService<WindowManager>(WindowManager::class.java)!!
-                    .getMaximumWindowMetrics()
+                displayContext.getSystemService(WindowManager::class.java)!!.maximumWindowMetrics
 
             // UiDevice#getDisplayHeight() excludes insets.
-            return mWindowMetrics.getBounds().height() - 1
+            return mWindowMetrics.bounds.height() - 1
         }
 
     /** Scrolls the shade down. */
@@ -243,20 +277,21 @@ class NotificationShade internal constructor() {
     fun openQuickSettings(): QuickSettings {
         val device = uiDevice
         // Swipe in first quarter to avoid desktop windowing app handle interactions.
-        val swipeXCoordinate = device.displayWidth / 4
-        device.betterSwipe(
+        val swipeXCoordinate = device.getDisplayWidth(displayId) / 4
+        betterSwipe(
             startX = swipeXCoordinate,
             startY = 0,
             endX = swipeXCoordinate,
-            endY = device.displayHeight,
+            endY = device.getDisplayHeight(displayId),
+            displayId = displayId,
         )
-        SystemClock.sleep(SHORT_TIMEOUT.toLong())
-        return QuickSettings()
+        SystemClock.sleep(SHORT_TIMEOUT)
+        return QuickSettings(displayId)
     }
 
     /** Returns Quick Settings (aka expanded Quick Settings) or fails if it's not visible. */
     val quickSettings: QuickSettings
-        get() = QuickSettings()
+        get() = QuickSettings(displayId)
 
     /**
      * Returns the visible UMO, or fails if it's not visible.
@@ -276,7 +311,6 @@ class NotificationShade internal constructor() {
         get() = QSHeader()
 
     companion object {
-        private val QS_HEADER_SELECTOR = sysuiResSelector("split_shade_status_bar")
         private const val WAIT_TIME = 10_000L
         private const val UI_EMPTY_SHADE_VIEW_ID = "no_notifications"
         private val UI_SETTINGS_BUTTON_ID =
@@ -287,10 +321,11 @@ class NotificationShade internal constructor() {
         private const val SHORT_TRANSITION_WAIT: Long = 1500
         private const val UI_NOTIFICATION_LIST_ID = "notification_stack_scroller"
         private const val SCROLL_TIMES = 3
-        private const val SHORT_TIMEOUT = 500
+        private const val SHORT_TIMEOUT: Long = 500
         const val NOTIFICATION_MAX_HIERARCHY_DEPTH = 4
         const val EXPANDABLE_NOTIFICATION_ROW = "expandableNotificationRow"
         const val SHELF_ID = "notificationShelf"
+        const val SHELF_BG_ID = "backgroundNormal"
         const val UI_SCROLLABLE_ELEMENT_ID = "notification_stack_scroller"
         const val HEADER_EXPAND_BUTTON = "expand_button"
         val notificationsStack: UiObject2?
@@ -309,28 +344,17 @@ class NotificationShade internal constructor() {
         private val isShowingFooter: Boolean
             get() = uiDevice.hasObject(sysuiResSelector(UI_SETTINGS_BUTTON_ID))
 
-        private val quickSettingsContainer: UiObject2
-            get() =
-                uiDevice.wait(
-                    Until.findObject(sysuiResSelector(UI_QS_CONTAINER_ID)),
-                    UI_RESPONSE_TIMEOUT_MSECS,
-                ) ?: error("Can't find qs container.")
-
-        private val notificationShadeScrollContainer: UiObject2
-            get() =
-                uiDevice.wait(
-                    Until.findObject(sysuiResSelector(UI_SCROLLABLE_ELEMENT_ID)),
-                    UI_RESPONSE_TIMEOUT_MSECS,
-                ) ?: error("Can't find notification shade scroll container.")
-
         @JvmStatic
-        fun waitForShadeToClose() {
-            trace("waitForShadeToClose") {
+        @JvmOverloads
+        fun waitForShadeToClose(displayId: Int = DEFAULT_DISPLAY) {
+            traceSection("waitForShadeToClose") {
                 // QS header view used in all configurations of Notification shade.
-                QS_HEADER_SELECTOR.assertInvisible { "Notification shade didn't close" }
+                sysuiResSelector("split_shade_status_bar", displayId).assertInvisible {
+                    "Notification shade on dislplay $displayId didn't close"
+                }
                 // Asserts on new QS resId.
-                sysuiResSelector("shade_header_root").assertInvisible {
-                    "Notification shade didn't close"
+                sysuiResSelector("shade_header_root", displayId).assertInvisible {
+                    "Notification shade on display $displayId didn't close"
                 }
             }
         }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt
index 922e0dc6b..8c3d65c29 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt
@@ -31,6 +31,7 @@ import android.platform.systemui_tapl.controller.NotificationIdentity.Type.GROUP
 import android.platform.systemui_tapl.controller.NotificationIdentity.Type.INBOX
 import android.platform.systemui_tapl.controller.NotificationIdentity.Type.MEDIA
 import android.platform.systemui_tapl.controller.NotificationIdentity.Type.MESSAGING_STYLE
+import android.platform.systemui_tapl.ui.NotificationShade.Companion.SHELF_BG_ID
 import android.platform.systemui_tapl.ui.NotificationShade.Companion.SHELF_ID
 import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
 import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
@@ -45,6 +46,7 @@ import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObjects
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import android.platform.uiautomatorhelpers.WaitUtils.retryIfStale
+import android.platform.uiautomatorhelpers.WaitUtils.waitFor
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.Direction
@@ -132,6 +134,14 @@ open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
         return waitForObj(NOTIFICATION_SHELF_SELECTOR).visibleBounds
     }
 
+    fun getShelfBackgroundBounds(): Rect {
+        val shelf = waitForObj(NOTIFICATION_SHELF_SELECTOR)
+        return waitFor("$NOTIFICATION_SHELF_BG_SELECTOR not found") {
+                shelf.findObject(NOTIFICATION_SHELF_BG_SELECTOR)
+            }
+            .visibleBounds
+    }
+
     /** Returns the [NotificationShelf] if visible, otherwise [null]. */
     fun tryGetNotificationShelf(): NotificationShelf? {
         return retryIfStale(description = "tryGetNotificationShelf", times = 3) {
@@ -193,6 +203,8 @@ open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
          *   cannot be verified. An action button is necessary for the verification. Consider
          *   posting the HUN with NotificationController#postBigTextHeadsUpNotification if you need
          *   to assert the HUN state. Expanded HUN state cannot be asserted.
+         * @param assertIsPromotedOngoingState when true, asserts that the notification is a
+         *   promoted ongoing notification, which has different visual characteristics.
          * @param waitTimeout duration to wait for the notification to appear.
          * @return Notification (throws assertion if not found)
          */
@@ -201,16 +213,23 @@ open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
         internal fun findHeadsUpNotification(
             identity: NotificationIdentity,
             assertIsHunState: Boolean = true,
+            assertIsPromotedOngoingState: Boolean = false,
             waitTimeout: Duration = LONG_WAIT,
         ): Notification {
-            if (!assertIsHunState) {
-                return findNotificationInternal(
-                    identity = identity,
+            val notification =
+                findNotificationInternal(
+                    identity,
                     fromLockscreen = false,
                     isHeadsUpNotification = true,
                     scroll = false,
                     waitTimeout = waitTimeout,
                 )
+            if (assertIsPromotedOngoingState) {
+                notification.verifyIsPromotedOngoingState()
+            }
+
+            if (!assertIsHunState) {
+                return notification
             }
 
             assertTrue(
@@ -220,15 +239,6 @@ open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
                     "to false.",
                 identity.hasAction,
             )
-
-            val notification =
-                findNotificationInternal(
-                    identity,
-                    fromLockscreen = false,
-                    isHeadsUpNotification = true,
-                    scroll = false,
-                    waitTimeout = waitTimeout,
-                )
             notification.verifyIsHunState()
             return notification
         }
@@ -412,6 +422,9 @@ open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
         private const val MAX_FIND_NOTIFICATION_ATTEMPTS = 15
         private val NOTIFICATION_SHELF_SELECTOR =
             sysuiResSelector(SHELF_ID).maxDepth(NotificationShade.NOTIFICATION_MAX_HIERARCHY_DEPTH)
+        private val NOTIFICATION_SHELF_BG_SELECTOR =
+            sysuiResSelector(SHELF_BG_ID)
+                .maxDepth(NotificationShade.NOTIFICATION_MAX_HIERARCHY_DEPTH)
         private val NOTIFICATION_STACK_SCROLLER = sysuiResSelector("notification_stack_scroller")
         private val BIG_PICTURE_SELECTOR = androidResSelector("big_picture")
         private val MESSAGE_ICON_CONTAINER_SELECTOR = androidResSelector("message_icon_container")
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt
index 58833c1ac..f76bc411f 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt
@@ -23,6 +23,7 @@ import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.UiObject2
 import com.android.systemui.Flags
 
@@ -34,18 +35,17 @@ import com.android.systemui.Flags
  *
  * https://hsv.googleplex.com/4814389392703488?node=15#
  */
-class QuickQuickSettings internal constructor() {
+class QuickQuickSettings internal constructor(val displayId: Int = DEFAULT_DISPLAY) {
 
+    private val qsTileLayoutSelector = sysuiResSelector("qqs_tile_layout", displayId)
     private val qqsTilesContainer: UiObject2
 
     init {
-        UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR.assertVisible(timeout = LONG_WAIT) {
+        qsContainerSelector(displayId).assertVisible(timeout = LONG_WAIT) {
             "Quick quick settings not visible"
         }
         qqsTilesContainer =
-            waitForObj(UI_QQS_TILE_LAYOUT_SELECTOR) {
-                "Quick quick settings does not have a tile layout"
-            }
+            waitForObj(qsTileLayoutSelector) { "Quick quick settings does not have a tile layout" }
     }
 
     /**
@@ -58,16 +58,16 @@ class QuickQuickSettings internal constructor() {
         val uiTiles = qqsTilesContainer.children
         if (!Flags.qsUiRefactorComposeFragment()) {
             uiTiles.forEach { tile ->
-                tile.assertVisibility(UI_TILE_LABEL_SELECTOR, visible = true)
+                tile.assertVisibility(tileLabelSelector(displayId), visible = true)
             }
         }
-        return uiTiles.map { QuickQuickSettingsTile(it) }
+        return uiTiles.map { QuickQuickSettingsTile(it, displayId) }
     }
 
     fun getVisibleComposeTiles(): List<ComposeQuickSettingsTile> {
         val uiChildren = qqsTilesContainer.children
-        val largeTileSelector = sysuiResSelector(ComposeQuickSettingsTile.LARGE_TILE_TAG)
-        val smallTileSelector = sysuiResSelector(ComposeQuickSettingsTile.SMALL_TILE_TAG)
+        val largeTileSelector = sysuiResSelector(ComposeQuickSettingsTile.LARGE_TILE_TAG, displayId)
+        val smallTileSelector = sysuiResSelector(ComposeQuickSettingsTile.SMALL_TILE_TAG, displayId)
         val uiTiles =
             uiChildren.map { child ->
                 val (tile, _) =
@@ -77,16 +77,16 @@ class QuickQuickSettings internal constructor() {
                 tile.assertIsTile()
                 tile
             }
-        return uiTiles.map { ComposeQuickSettingsTile.createFrom(it) }
+        return uiTiles.map { ComposeQuickSettingsTile.createFrom(it, displayId) }
     }
 
     companion object {
-        @JvmField
-        val UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR = sysuiResSelector("quick_qs_panel")
-        // https://hsv.googleplex.com/4814389392703488?node=16#
-        private val UI_QQS_TILE_LAYOUT_SELECTOR = sysuiResSelector("qqs_tile_layout")
-        @JvmField
-        // https://hsv.googleplex.com/4814389392703488?node=22#
-        val UI_TILE_LABEL_SELECTOR = sysuiResSelector("tile_label")
+        @JvmStatic
+        fun qsContainerSelector(displayId: Int = DEFAULT_DISPLAY) =
+            sysuiResSelector("quick_qs_panel", displayId)
+
+        @JvmStatic
+        fun tileLabelSelector(displayId: Int = DEFAULT_DISPLAY) =
+            sysuiResSelector("tile_label", displayId)
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt
index 0c8881b53..e53da8182 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt
@@ -16,6 +16,7 @@
 package android.platform.systemui_tapl.ui
 
 import android.graphics.PointF
+import android.platform.systemui_tapl.utils.DeviceUtils
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
 import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
 import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
@@ -28,22 +29,28 @@ import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
 import android.platform.uiautomatorhelpers.scrollUntilFound
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.Direction
 import androidx.test.uiautomator.UiSelector
 import java.util.regex.Pattern
 
 /** System UI test automation object representing quick settings in the notification shade. */
-class QuickSettings internal constructor() {
+class QuickSettings internal constructor(val displayId: Int = DEFAULT_DISPLAY) {
     // TODO(279061302): Remove TaplUiObject after BetterSwipe has a scroll wrapper.
     private val pager: TaplUiObject
 
     private val clazzNamePattern = Pattern.compile("android\\.widget\\.((Switch)|(Button))")
 
+    private val qsContainer = sysuiResSelector("quick_settings_panel", displayId)
+    private val footerSelector = sysuiResSelector("qs_footer_actions", displayId)
+    private val pagerUISelector = sysuiResSelector(PAGER_UI_OBJECT_RES_ID, displayId)
+
     init {
-        UI_QUICK_SETTINGS_CONTAINER_ID.assertVisible { "Quick settings didn't open" }
-        FOOTER_SELECTOR.assertVisible()
-        pager = TaplUiDevice.waitForObject(PAGER_UI_OBJECT_SELECTOR, "QS pager")
+        qsContainer.assertVisible { "Quick settings didn't open" }
+        footerSelector.assertVisible()
+        pager = TaplUiDevice.waitForObject(pagerUISelector, "QS pager")
     }
 
     /** Presses Power button to open the power panel. */
@@ -54,8 +61,8 @@ class QuickSettings internal constructor() {
 
     /** Presses Settings button to open Settings. */
     fun openSettings() {
-        waitForObj(sysuiResSelector(SETTINGS_BUTTON_RES_ID)).click()
-        By.pkg(SETTINGS_PACKAGE).assertVisible()
+        waitForObj(sysuiResSelector(SETTINGS_BUTTON_RES_ID, displayId)).click()
+        By.displayId(displayId).pkg(SETTINGS_PACKAGE).assertVisible()
     }
 
     /** Opens the user selection panel by clicking User Switch button. */
@@ -68,22 +75,23 @@ class QuickSettings internal constructor() {
     /** Finds a tile by the prefix of its description */
     fun findTile(tileDesc: String): QuickSettingsTile {
         // Select by title_label https://hsv.googleplex.com/5476758214148096?node=57
-        val titleLabelSelector = sysuiResSelector("tile_label").textStartsWith(tileDesc)
-        val tileSelector = By.clazz(clazzNamePattern).hasDescendant(titleLabelSelector, 3)
+        val titleLabelSelector = sysuiResSelector("tile_label", displayId).textStartsWith(tileDesc)
+        val tileSelector =
+            By.displayId(displayId).clazz(clazzNamePattern).hasDescendant(titleLabelSelector, 3)
         waitForObj(tileSelector)
-        return QuickSettingsTile(tileSelector)
+        return QuickSettingsTile(tileSelector, displayId)
     }
 
     fun findComposeTile(tileDesc: String): ComposeQuickSettingsTile {
-        val smallTileSelector = ComposeQuickSettingsTile.smallTileSelector(tileDesc)
-        val largeTileSelector = ComposeQuickSettingsTile.largeTileSelector(tileDesc)
+        val smallTileSelector = ComposeQuickSettingsTile.smallTileSelector(tileDesc, displayId)
+        val largeTileSelector = ComposeQuickSettingsTile.largeTileSelector(tileDesc, displayId)
         val (_, selector) = waitForFirstObj(smallTileSelector, largeTileSelector)
-        return ComposeQuickSettingsTile.createFrom(selector)
+        return ComposeQuickSettingsTile.createFrom(selector, displayId)
     }
 
     /** Returns the brightness slider. */
     val brightnessSlider: BrightnessSlider
-        get() = BrightnessSlider()
+        get() = BrightnessSlider(displayId)
 
     /** Returns the QS header. */
     val header: QSHeader
@@ -110,7 +118,7 @@ class QuickSettings internal constructor() {
     /** Swipes up back to QQS or closes shade in case of split shade. */
     fun close() {
         swipeUp()
-        UI_QUICK_SETTINGS_CONTAINER_ID.assertInvisible()
+        qsContainer.assertInvisible()
     }
 
     fun swipeLeft() {
@@ -118,31 +126,35 @@ class QuickSettings internal constructor() {
     }
 
     private fun swipeUp() {
-        val displayWidth = uiDevice.displayWidth
-        val displayHeight = uiDevice.displayHeight
+        val displayWidth = uiDevice.getDisplayWidth(displayId)
+        val displayHeight = uiDevice.getDisplayHeight(displayId)
         BetterSwipe.swipe(
             PointF((displayWidth / 2).toFloat(), displayHeight.toFloat() - 1f),
             PointF((displayWidth / 2).toFloat(), 0f),
+            displayId = displayId,
         )
     }
 
-    private companion object {
-        val UI_QUICK_SETTINGS_CONTAINER_ID = sysuiResSelector("quick_settings_panel")
-        val FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
-
+    companion object {
         // https://hsv.googleplex.com/5291196806070272?node=109
-        const val POWER_BTN_RES_ID = "pm_lite"
+        private const val POWER_BTN_RES_ID = "pm_lite"
 
         // https://hsv.googleplex.com/5291196806070272?node=108
-        const val SETTINGS_BUTTON_RES_ID = "settings_button_container"
+        private const val SETTINGS_BUTTON_RES_ID = "settings_button_container"
 
         // http://go/hsv/5465641194618880?node=84
-        const val MULTI_USER_SWITCH_RES_ID = "multi_user_switch"
-        const val PAGER_CLASS_NAME = "androidx.viewpager.widget.ViewPager"
-        const val PAGER_RES_ID = "$SYSUI_PACKAGE:id/qs_pager"
-        val PAGER_SELECTOR = UiSelector().className(PAGER_CLASS_NAME).resourceId(PAGER_RES_ID)
-        const val PAGER_UI_OBJECT_RES_ID = "qs_pager"
-        val PAGER_UI_OBJECT_SELECTOR = sysuiResSelector(PAGER_UI_OBJECT_RES_ID)
+        private const val MULTI_USER_SWITCH_RES_ID = "multi_user_switch"
+        private const val PAGER_CLASS_NAME = "androidx.viewpager.widget.ViewPager"
+        private const val PAGER_RES_ID = "$SYSUI_PACKAGE:id/qs_pager"
+        private val PAGER_SELECTOR =
+            UiSelector().className(PAGER_CLASS_NAME).resourceId(PAGER_RES_ID)
+        private const val PAGER_UI_OBJECT_RES_ID = "qs_pager"
+
+        fun textFeedbackSelector(tileName: String): BySelector {
+            return DeviceUtils.sysuiResSelector("text_feedback")
+                .hasDescendant(By.textContains(tileName))
+        }
+
         private val QUICK_SETTINGS_SCROLLVIEW_SELECTOR = sysuiResSelector("expanded_qs_scroll_view")
         private val QUICK_SETTING_FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
     }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt
index b2a977f65..35622df61 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt
@@ -19,18 +19,12 @@ package android.platform.systemui_tapl.ui
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
 import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
 import android.platform.test.scenario.tapl_common.Gestures
-import android.platform.test.scenario.tapl_common.Gestures.click
-import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.test.scenario.tapl_common.Gestures.shortClick
 import android.platform.test.util.HealthTestingUtils.waitForValueCatchingStaleObjectExceptions
-import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
-import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
 import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
-import android.platform.uiautomatorhelpers.WaitResult
 import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
-import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
-import android.platform.uiautomatorhelpers.scrollUntilFound
-import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.UiObject2
@@ -38,7 +32,7 @@ import com.android.systemui.Flags
 import com.google.common.truth.Truth.assertWithMessage
 
 /** Base class for tiles in Quick Settings and Quick Quick Settings */
-sealed class QuickSettingsTileBase {
+sealed class QuickSettingsTileBase(val displayId: Int = DEFAULT_DISPLAY) {
     protected abstract val tile: UiObject2
 
     /**
@@ -50,7 +44,7 @@ sealed class QuickSettingsTileBase {
                 if (Flags.qsUiRefactorComposeFragment()) {
                     tile.contentDescription
                 } else {
-                    tile.waitForObj(QuickQuickSettings.UI_TILE_LABEL_SELECTOR).text
+                    tile.waitForObj(QuickQuickSettings.tileLabelSelector(displayId)).text
                 }
             assertWithMessage("Tile label should not be null").that(label).isNotNull()
             return label
@@ -76,7 +70,7 @@ sealed class QuickSettingsTileBase {
     /** Clicks a non-Internet tile and verifies that its checked state changes. */
     fun click() {
         val wasChecked = isChecked
-        click(tile, "Tile")
+        clickWithoutAssertions()
         assertCheckedStatus(!wasChecked)
     }
 
@@ -85,7 +79,7 @@ sealed class QuickSettingsTileBase {
      * use unless you have a very good reason to omit assertions.
      */
     fun clickWithoutAssertions() {
-        click(tile, "Tile")
+        shortClick(tile, "Tile")
     }
 
     fun assertCheckedStatus(checked: Boolean) {
@@ -95,58 +89,39 @@ sealed class QuickSettingsTileBase {
 
     /** Clicks the Internet tile and presses Done button. */
     fun clickInternetTile() {
-        click(tile, "Tile")
-        val scrollView =
-            TaplUiDevice.waitForObject(
-                    sysuiResSelector(DIALOG_RES_ID),
-                    objectName = "Internet connectivity dialog",
-                )
-                .waitForChildObject(
-                    childResourceId = SCROLL_VIEW_RES_ID,
-                    childObjectName = "Scroll view",
-                )
-                .uiObject
-        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
-        doneButton.click()
-        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
-            Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
-            doneButton.click()
-        }
-        DONE_BTN.assertInvisible(errorProvider = { "Internet dialog is dismissed" })
+        clickWithoutAssertions()
+        val internetDialog = InternetDialog(displayId)
+
+        internetDialog.clickOnDoneAndClose()
+    }
+
+    /** Clicks the Bluetooth tile and opens dialog. */
+    fun openBluetoothDialog(): BluetoothDialog {
+        clickWithoutAssertions()
+        return BluetoothDialog(displayId)
     }
 
-    /** Clicks the Bluetooth tile and presses Done button. */
+    /** Clicks the Bluetooth tile, opens dialog and presses Done button. */
     fun clickBluetoothTile() {
-        click(tile, "Tile")
-        val scrollView =
-            TaplUiDevice.waitForObject(
-                    sysuiResSelector(BLUETOOTH_TILE_DIALOG_RES_ID),
-                    objectName = "Bluetooth tile dialog",
-                )
-                .waitForChildObject(
-                    childResourceId = SCROLL_VIEW_RES_ID,
-                    childObjectName = "Scroll view",
-                )
-                .uiObject
-        scrollView.scrollUntilFound(DONE_BTN)?.click() ?: error("Done button not found")
-        DONE_BTN.assertInvisible(errorProvider = { "Bluetooth tile dialog is dismissed" })
+        val bluetoothDialog = openBluetoothDialog()
+        bluetoothDialog.clickOnDoneAndClose()
     }
 
     fun clickDnDIntoDialog(): AlertDialog {
-        click(tile, "Tile")
+        clickWithoutAssertions()
         return AlertDialog()
     }
 
     fun clickModesTile(): ModesDialog {
-        click(tile, "Tile")
-        return ModesDialog()
+        clickWithoutAssertions()
+        return ModesDialog(displayId)
     }
 
     /** Long-clicks the tile and verifies that Settings app appears, unless otherwise specified */
     fun longClick(expectedSettingsPackage: String? = null) {
-        Gestures.longClickDownUp(tile, "Quick settings tile") {
+        Gestures.longClickDownUp(tile, "Quick settings tile", displayId) {
             val packageName = expectedSettingsPackage ?: SETTINGS_PACKAGE
-            By.pkg(packageName).assertVisible { "$packageName didn't appear" }
+            By.displayId(displayId).pkg(packageName).assertVisible { "$packageName didn't appear" }
         }
     }
 
@@ -164,8 +139,9 @@ sealed class QuickSettingsTileBase {
  * It keeps track of the tile by its selector, instead of the UiObject2 in case it moves in the
  * middle of the test.
  */
-class QuickSettingsTile internal constructor(private val selector: BySelector) :
-    QuickSettingsTileBase() {
+class QuickSettingsTile
+internal constructor(private val selector: BySelector, displayId: Int = DEFAULT_DISPLAY) :
+    QuickSettingsTileBase(displayId) {
 
     override val tile: UiObject2
         get() = waitForObj(selector)
@@ -176,5 +152,6 @@ class QuickSettingsTile internal constructor(private val selector: BySelector) :
  *
  * As these are retrieved by the position, they are associated with the actual object.
  */
-class QuickQuickSettingsTile internal constructor(override val tile: UiObject2) :
-    QuickSettingsTileBase()
+class QuickQuickSettingsTile
+internal constructor(override val tile: UiObject2, displayId: Int = DEFAULT_DISPLAY) :
+    QuickSettingsTileBase(displayId)
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt
index fa11ea248..2027b8227 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt
@@ -26,12 +26,16 @@ import android.platform.systemui_tapl.controller.NotificationIdentity
 import android.platform.systemui_tapl.ui.ExpandedBubbleStack.Companion.BUBBLE_EXPANDED_VIEW
 import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
 import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.LAUNCHER_PACKAGE
 import android.platform.uiautomatorhelpers.BetterSwipe
 import android.platform.uiautomatorhelpers.DeviceHelpers
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
 import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
 import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObj
+import android.platform.uiautomatorhelpers.FailedEnsureException
+import android.view.Display.DEFAULT_DISPLAY
 import android.view.InputDevice
 import android.view.InputEvent
 import android.view.KeyCharacterMap
@@ -47,14 +51,17 @@ import com.android.app.tracing.traceSection
 import com.android.launcher3.tapl.LauncherInstrumentation
 import com.android.launcher3.tapl.Workspace
 import com.google.common.truth.Truth.assertThat
+import com.google.common.truth.Truth.assertWithMessage
 import java.time.Duration
-import org.junit.Assert
+import org.junit.Assert.assertThrows
 
 /**
  * The root class for System UI test automation objects. All System UI test automation objects are
  * produced by this class or other System UI test automation objects.
+ *
+ * @param displayId The ID of the display to interact with.
  */
-class Root private constructor() {
+class Root private constructor(val displayId: Int = DEFAULT_DISPLAY) {
 
     /**
      * Opens the notification shade. Use this if there is no need to assert the way of opening it.
@@ -72,12 +79,19 @@ class Root private constructor() {
         traceSection("Opening notification shade via global action") {
             uiDevice.openNotification()
             waitForShadeToOpen()
-            return NotificationShade()
+            return NotificationShade(displayId)
         }
     }
 
     /** Opens the notification shade via two fingers wipe. */
     fun openNotificationShadeViaTwoFingersSwipe(): NotificationShade {
+        assertWithMessage(
+            "two finger swipe is only supported on the default display, because it relies on " +
+                    "UiObject#performTwoPointerGesture, and UiObject has no concept of displayId " +
+                    "(unlike UiObject2)"
+            )
+            .that(displayId)
+            .isEqualTo(DEFAULT_DISPLAY)
         return openNotificationShadeViaTwoFingersSwipe(Duration.ofMillis(300))
     }
 
@@ -101,15 +115,15 @@ class Root private constructor() {
     ): NotificationShade {
         traceSection("Opening notification shade via swipe") {
             val device = uiDevice
-            val width = device.displayWidth.toFloat()
-            val height = device.displayHeight.toFloat()
+            val height = device.getDisplayHeight(displayId).toFloat()
             BetterSwipe.swipe(
-                PointF(width / 2, height * heightFraction),
-                PointF(width / 2, height),
+                PointF(notificationSwipeX, height * heightFraction),
+                PointF(notificationSwipeX, height),
                 swipeDuration,
+                displayId = displayId,
             )
             waitForShadeToOpen()
-            return NotificationShade()
+            return NotificationShade(displayId)
         }
     }
 
@@ -118,13 +132,14 @@ class Root private constructor() {
      * an app.
      */
     fun openNotificationShadeViaSwipeFromTop(): NotificationShade {
-        val device = uiDevice
-        // Swipe in first quarter to avoid desktop windowing app handle interactions.
-        val swipeXCoordinate = (device.displayWidth / 4).toFloat()
-        val height = device.displayHeight.toFloat()
-        BetterSwipe.swipe(PointF(swipeXCoordinate, 0f), PointF(swipeXCoordinate, height))
+        val height = uiDevice.getDisplayHeight(displayId).toFloat()
+        BetterSwipe.swipe(
+            PointF(notificationSwipeX, 0f),
+            PointF(notificationSwipeX, height),
+            displayId = displayId,
+        )
         waitForShadeToOpen()
-        return NotificationShade()
+        return NotificationShade(displayId)
     }
 
     /** Opens the notification shade via swipe. */
@@ -151,6 +166,32 @@ class Root private constructor() {
         return NotificationShade()
     }
 
+    /** Opens notification shade via 3-finger swipe on trackpad */
+    fun openNotificationShadeViaTrackpadSwipe(): NotificationShade {
+        // Swiping on horizontal center, vertically from upper quarter to 3/4 down, as to
+        // give enough space for shade to open fully, and not losing focus by touching screen edge
+        val startX = uiDevice.getDisplayWidth(displayId) / 2f
+        val startY = uiDevice.getDisplayHeight(displayId) / 4f
+        val endY = uiDevice.getDisplayHeight(displayId) * 3f / 4
+        val deltaY = endY - startY
+
+        BetterSwipe.threeFingerTrackpadSwipe(
+            start1 = PointF(startX, startY),
+            start2 = PointF(startX - TOUCHPAD_POINTER_SPACING, startY),
+            start3 = PointF(startX + TOUCHPAD_POINTER_SPACING, startY),
+            delta = PointF(0f, deltaY),
+            displayId = displayId,
+        )
+
+        waitForShadeToOpen()
+        return NotificationShade(displayId)
+    }
+
+    private val footerSelector = sysuiResSelector("qs_footer_actions", displayId)
+
+    private val notificationSwipeX: Float
+        get() = uiDevice.getDisplayWidth(displayId) / 4f
+
     /**
      * Finds a HUN by its identity. Fails if the notification can't be found.
      *
@@ -160,15 +201,18 @@ class Root private constructor() {
      *   verified. An action button is necessary for the verification. Consider posting the HUN with
      *   NotificationController#postBigTextHeadsUpNotification if you need to assert the HUN state.
      *   Expanded HUN state cannot be asserted.
+     * @param assertIsPromotedOngoingState see [NotificationStack.findHeadsUpNotification].
      */
     @JvmOverloads
     fun findHeadsUpNotification(
         identity: NotificationIdentity,
         assertIsHunState: Boolean = true,
+        assertIsPromotedOngoingState: Boolean = false,
     ): Notification {
         return NotificationStack.findHeadsUpNotification(
             identity = identity,
             assertIsHunState = assertIsHunState,
+            assertIsPromotedOngoingState = assertIsPromotedOngoingState,
         )
     }
 
@@ -176,17 +220,24 @@ class Root private constructor() {
      * Ensures there is not a HUN with this identity. Fails if the HUN is found, or the identity
      * doesn't have an action button.
      *
+     * @param assertIsHunState see [findHeadsUpNotification].
      * @param identity The NotificationIdentity used to find the HUN, an action button is necessary
      */
     // TODO(b/295209746): More robust (and more performant) assertion for "HUN does not appear"
-    fun ensureNoHeadsUpNotification(identity: NotificationIdentity) {
-        Assert.assertTrue(
-            "HUN state Assertion usage error: Notification: ${identity.title} " +
-                "| You can only assert the HUN State of a notification that has an action " +
-                "button.",
-            identity.hasAction,
-        )
-        Assert.assertThrows(IllegalStateException::class.java) {
+    fun ensureNoHeadsUpNotification(
+        identity: NotificationIdentity,
+        assertIsHunState: Boolean = true,
+    ) {
+        if (assertIsHunState) {
+            assertWithMessage(
+                "HUN state Assertion usage error: Notification: ${identity.title} " +
+                        "| You can only assert the HUN State of a notification that has an action " +
+                        "button."
+                )
+                .that(identity.hasAction)
+                .isTrue()
+        }
+        assertThrows(IllegalStateException::class.java) {
             findHeadsUpNotification(identity, assertIsHunState = false)
         }
     }
@@ -198,16 +249,16 @@ class Root private constructor() {
         // Quick Settings isn't always open when this is complete. Explicitly wait for the Quick
         // Settings footer to make sure that the buttons are accessible when the bar is open and
         // this call is complete.
-        FOOTER_SELECTOR.assertVisible()
+        footerSelector.assertVisible()
         // Wait an extra bit for the animation to complete. If we return to early, future callers
         // that are trying to find the location of the footer will get incorrect coordinates
-        device.waitForIdle(LONG_TIMEOUT.toLong())
-        return QuickSettings()
+        device.waitForIdle(LONG_TIMEOUT)
+        return QuickSettings(displayId)
     }
 
     /** Gets status bar. */
     val statusBar: StatusBar
-        get() = StatusBar()
+        get() = StatusBar(displayId)
 
     /** Gets an alert dialog. */
     val alertDialog: AlertDialog
@@ -228,7 +279,7 @@ class Root private constructor() {
 
     /** Gets lock screen. Fails if lock screen is not visible. */
     val lockScreen: LockScreen
-        get() = LockScreen()
+        get() = LockScreen(displayId)
 
     /** Gets primary bouncer. Fails if the primary bouncer is not visible. */
     val primaryBouncer: Bouncer
@@ -236,7 +287,11 @@ class Root private constructor() {
 
     /** Gets Aod. Fails if Aod is not visible. */
     val aod: Aod
-        get() = Aod()
+        get() = Aod(displayId)
+
+    /** Gets Aod RON Skeleton. Fails if Aod is not visible. */
+    val aodRON: AodRON
+        get() = AodRON()
 
     /** Gets ChooseScreenLock. Fails if ChooseScreenLock is not visible. */
     val chooseScreenLock: ChooseScreenLock
@@ -269,15 +324,51 @@ class Root private constructor() {
     val bubbleBar: BubbleBar
         get() = BubbleBar()
 
+    /** Get the stashed bubble bar handle in launcher */
+    val stashedBubbleBar: StashedBubbleBar
+        get() = StashedBubbleBar()
+
     /** Gets the bubble bar flyout in launcher. */
     val bubbleBarFlyout: BubbleBarFlyout
         get() = BubbleBarFlyout()
 
+    /**
+     * Try to expand the bubble bar by either clicking on the [BubbleBar] itself, or if it is not
+     * shown, try to click on [StashedBubbleBar] handle.
+     */
+    fun expandBubbleBar(): ExpandedBubbleBar {
+        // Perform a quick check for bubble bar and handle so we don't have to wait for them to show
+        try {
+            if (uiDevice.hasObject(BubbleBar.BUBBLE_BAR_VIEW)) {
+                return bubbleBar.expand()
+            }
+        } catch (e: FailedEnsureException) {
+            // Bubble bar may have been animating to handle. By the time we try to click, it may be
+            // gone, ignore the failure and try to click on the handle.
+        }
+        if (uiDevice.hasObject(StashedBubbleBar.HANDLE_VIEW)) {
+            return stashedBubbleBar.click()
+        }
+        // Wait for bubble bar or handle to show
+        waitForNullableObj(BubbleBar.BUBBLE_BAR_VIEW)?.let {
+            return bubbleBar.expand()
+        }
+        waitForNullableObj(StashedBubbleBar.HANDLE_VIEW)?.let {
+            return stashedBubbleBar.click()
+        }
+        throw AssertionError("Could not expand bubble bar as bar or handle is not visible")
+    }
+
     /** Verifies that the bubble bar is hidden. */
     fun verifyBubbleBarIsHidden() {
         BubbleBar.BUBBLE_BAR_VIEW.assertInvisible(LONG_WAIT)
     }
 
+    /** Verifies that the stashed bubble bar handle is hidden */
+    fun verifyStashedBubbleBarHandleIsHidden() {
+        StashedBubbleBar.HANDLE_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
+    }
+
     /** Verifies that no bubbles or an expanded bubble stack are visible. */
     fun verifyNoBubbleIsVisible() {
         Bubble.BUBBLE_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
@@ -289,14 +380,17 @@ class Root private constructor() {
         BUBBLE_EXPANDED_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
     }
 
+    /** Verifies that bubble flyout is not visible. Checks for both stack and bar flyout. */
+    fun verifyBubbleFlyoutIsHidden() {
+        BubbleBarFlyout.BUBBLE_BAR_FLYOUT_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
+        BubbleFlyout.BUBBLE_FLYOUT_TEXT_CONTAINER_VIEW.assertInvisible(
+            timeout = Bubble.FIND_OBJECT_TIMEOUT
+        )
+    }
+
     /** Verifies that status bar is hidden by checking StatusBar's clock icon whether it exists. */
     fun verifyStatusBarIsHidden() {
-        assertThat(
-                uiDevice.wait(
-                    Until.gone(sysuiResSelector(StatusBar.CLOCK_ID)),
-                    SHORT_TIMEOUT.toLong(),
-                )
-            )
+        assertThat(uiDevice.wait(Until.gone(sysuiResSelector(StatusBar.CLOCK_ID)), SHORT_TIMEOUT))
             .isTrue()
     }
 
@@ -354,13 +448,18 @@ class Root private constructor() {
 
     /** Asserts that lock screen is invisible. */
     fun assertLockScreenNotVisible() {
-        LockScreen.LOCKSCREEN_SELECTOR.assertInvisible()
+        LockScreen.lockScreenSelector(displayId).assertInvisible()
     }
 
-    // TODO (b/277105514): Determine whether this is an idiomatic method of determing visibility.
+    /** Asserts that brightness slider is not visible (i.e. when shade is on a external display.) */
+    fun assertBrightnessSliderNotVisible() {
+        BrightnessSlider.sliderSelector(displayId).assertInvisible()
+    }
+
+    // TODO (b/277105514): Determine whether this is an idiomatic method of determining visibility.
     /** Asserts that launcher is visible. */
     fun assertLauncherVisible() {
-        By.pkg("com.google.android.apps.nexuslauncher").assertVisible()
+        By.displayId(displayId).pkg(LAUNCHER_PACKAGE).assertVisible()
     }
 
     val keyboardBacklightIndicatorDialog: KeyboardBacklightIndicatorDialog
@@ -370,18 +469,67 @@ class Root private constructor() {
         KeyboardBacklightIndicatorDialog.CONTAINER_SELECTOR.assertInvisible()
     }
 
+    fun assertShadeNotVisible() {
+        qsHeaderSelector.assertInvisible { "Notification shade should not be visible" }
+    }
+
+    private val qsHeaderSelector =
+        if (com.android.systemui.Flags.sceneContainer()) {
+            sysuiResSelector("shade_header_root", displayId)
+        } else {
+            sysuiResSelector("split_shade_status_bar", displayId)
+        }
+
+    fun waitForShadeToOpen() {
+        // Note that this duplicates the tracing done by assertVisible, but with a better name.
+        traceSection("waitForShadeToOpen") {
+            qsHeaderSelector.assertVisible(
+                timeout = NOTIFICATION_SHADE_OPEN_TIMEOUT,
+                errorProvider = { "Notification shade didn't open on display $displayId" },
+            )
+        }
+    }
+
+    fun pressBackOnDisplay() {
+        if (displayId == DEFAULT_DISPLAY) {
+            LauncherInstrumentation().pressBack()
+        } else {
+            // replicate UiDevice#pressBack() for a display other than DEFAULT_DISPLAY
+            sendKey(KeyEvent.KEYCODE_BACK, 0, SystemClock.uptimeMillis())
+            uiDevice.waitForWindowUpdate(null, LONG_TIMEOUT)
+        }
+    }
+
+    fun pressHomeOnDisplay() {
+        if (displayId == DEFAULT_DISPLAY) {
+            uiDevice.pressHome()
+        } else {
+            // Check the display is available before attempting to send key events
+            By.displayId(displayId).assertVisible {
+                "Can't press home on display $displayId: display not found"
+            }
+            // replicate UiDevice#pressHome() for a display other than DEFAULT_DISPLAY
+            sendKey(KeyEvent.KEYCODE_HOME, 0, SystemClock.uptimeMillis())
+            uiDevice.waitForWindowUpdate(LAUNCHER_PACKAGE, LONG_TIMEOUT)
+        }
+    }
+
     private fun injectEventSync(event: InputEvent): Boolean {
         return InstrumentationRegistry.getInstrumentation()
             .uiAutomation
             .injectInputEvent(event, true)
     }
 
-    private fun sendKey(keyCode: Int, metaState: Int, eventTime: Long): Boolean {
-        val downEvent =
-            KeyEvent(
+    private fun createKeyEvent(
+        keyCode: Int,
+        metaState: Int,
+        eventTime: Long,
+        action: Int,
+    ): KeyEvent =
+        KeyEvent(
                 eventTime,
                 eventTime,
-                KeyEvent.ACTION_DOWN,
+                action,
                 keyCode,
                 0,
                 metaState,
@@ -390,20 +538,12 @@ class Root private constructor() {
                 0,
                 InputDevice.SOURCE_KEYBOARD,
             )
+            .apply { this.displayId = this@Root.displayId }
+
+    private fun sendKey(keyCode: Int, metaState: Int, eventTime: Long): Boolean {
+        val downEvent = createKeyEvent(keyCode, metaState, eventTime, KeyEvent.ACTION_DOWN)
         if (injectEventSync(downEvent)) {
-            val upEvent =
-                KeyEvent(
-                    eventTime,
-                    eventTime,
-                    KeyEvent.ACTION_UP,
-                    keyCode,
-                    0,
-                    metaState,
-                    KeyCharacterMap.VIRTUAL_KEYBOARD,
-                    0,
-                    0,
-                    InputDevice.SOURCE_KEYBOARD,
-                )
+            val upEvent = createKeyEvent(keyCode, metaState, eventTime, KeyEvent.ACTION_UP)
             if (injectEventSync(upEvent)) {
                 return true
             }
@@ -424,7 +564,7 @@ class Root private constructor() {
 
     /** Opens the tutorial by swiping. */
     fun openTutorialViaSwipe(): OneHandModeTutorial {
-        NotificationShade.waitForShadeToClose()
+        NotificationShade.waitForShadeToClose(displayId)
         val windowMetrics: WindowMetrics =
             DeviceHelpers.context
                 .getSystemService(WindowManager::class.java)!!
@@ -437,14 +577,14 @@ class Root private constructor() {
                     WindowInsets.Type.navigationBars() or WindowInsets.Type.displayCutout()
                 )
                 .bottom
-        NotificationShade.waitForShadeToClose()
+        NotificationShade.waitForShadeToClose(displayId)
         uiDevice.betterSwipe(
             displayBounds.width() / 2,
             displayBounds.height() - Math.round(bottomMandatoryGestureHeight * 2.5f),
             displayBounds.width() / 2,
             displayBounds.height(),
         )
-        NotificationShade.waitForShadeToClose()
+        NotificationShade.waitForShadeToClose(displayId)
         return OneHandModeTutorial()
     }
 
@@ -463,33 +603,18 @@ class Root private constructor() {
     }
 
     companion object {
-        private val QS_HEADER_SELECTOR =
-            if (com.android.systemui.Flags.sceneContainer()) {
-                sysuiResSelector("shade_header_root")
-            } else {
-                sysuiResSelector("split_shade_status_bar")
-            }
         private val NOTIFICATION_SHADE_OPEN_TIMEOUT = Duration.ofSeconds(20)
-        private const val LONG_TIMEOUT = 2000
-        private const val SHORT_TIMEOUT = 500
-        private val FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
+        private const val LONG_TIMEOUT: Long = 2000
+        private const val SHORT_TIMEOUT: Long = 500
         private const val SCREENSHOT_POST_TIMEOUT_MSEC: Long = 20000
+        private const val TOUCHPAD_POINTER_SPACING = 50
         private val GLOBAL_SCREENSHOT_SELECTOR = sysuiResSelector("screenshot_actions")
 
-        /** Returns an instance of Root. */
-        @JvmStatic
-        fun get(): Root {
-            return Root()
-        }
-
-        private fun waitForShadeToOpen() {
-            // Note that this duplicates the tracing done by assertVisible, but with a better name.
-            traceSection("waitForShadeToOpen") {
-                QS_HEADER_SELECTOR.assertVisible(
-                    timeout = NOTIFICATION_SHADE_OPEN_TIMEOUT,
-                    errorProvider = { "Notification shade didn't open" },
-                )
-            }
-        }
+        /**
+         * Returns an instance of Root.
+         *
+         * @param displayId The display ID used for UI operations. Defaults to the default display.
+         */
+        @JvmStatic @JvmOverloads fun get(displayId: Int = DEFAULT_DISPLAY): Root = Root(displayId)
     }
 }
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StashedBubbleBar.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StashedBubbleBar.kt
new file mode 100644
index 000000000..b4c2aff1d
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StashedBubbleBar.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+
+/**
+ * Provides an API to interact with the stashed bubble bar handle
+ *
+ * @see [BubbleBar] for collapsed bubble bar
+ * @see [ExpandedBubbleBar] for expanded bubble bar
+ */
+class StashedBubbleBar {
+
+    init {
+        HANDLE_VIEW.assertVisible { "Failed while waiting for bubble bar handle to become visible" }
+    }
+
+    /**
+     * Clicks on the stashed bubble bar handle to expand the bubble bar
+     *
+     * @return [ExpandedBubbleBar]
+     */
+    fun click(): ExpandedBubbleBar {
+        HANDLE_VIEW.click()
+        return ExpandedBubbleBar(BubbleBar().selectedBubble)
+    }
+
+    companion object {
+        val HANDLE_VIEW = launcherResSelector("stashed_bubble_handle")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java
index 00bed69e2..aac682aa3 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java
@@ -23,8 +23,6 @@ import static android.platform.test.util.HealthTestingUtils.waitForValueCatching
 import static android.platform.uiautomatorhelpers.DeviceHelpers.getUiDevice;
 import static android.platform.uiautomatorhelpers.WaitUtils.ensureThat;
 
-import static androidx.test.uiautomator.Until.findObject;
-
 import static com.android.settingslib.flags.Flags.newStatusBarIcons;
 import static com.android.systemui.Flags.statusBarChipsModernization;
 
@@ -33,7 +31,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 
 import static org.junit.Assume.assumeFalse;
 
-import android.app.Flags;
+import android.annotation.Nullable;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.platform.helpers.foldable.UnfoldAnimationTestingUtils;
@@ -69,9 +67,11 @@ public class StatusBar {
     private static final String DATA_SAVER_ICON_DESC = "Data Saver is on";
     // https://hsv.googleplex.com/6227911158792192?node=18
     static final String DOCK_DEFEND_ICON_SUFFIX_STRING = "charging paused for battery protection";
-    static final String DND_ICON_DESC = Flags.modesUi() ? "Do Not Disturb is on" : "Do Not Disturb";
+    static final String DND_ICON_DESC = "Do Not Disturb is on";
     private static final String WIFI_ICON_ID = "wifi_combo";
     private static final String ONGOING_ACTIVITY_CHIP_ICON_ID = "ongoing_activity_chip_primary";
+    // Corresponds with OngoingActivityChip.STATUS_BAR_CHIP_CONTENT_ID
+    private static final String STATUS_BAR_CHIP_CONTENT_ID = "ongoing_activity_chip_content";
     // Corresponds to ScreenRecordChipViewModel.KEY
     private static final String SCREEN_RECORDING_CHIP_ID = "ScreenRecord";
     static final String SCREEN_RECORD_DESC_STRING = "Recording screen";
@@ -79,11 +79,17 @@ public class StatusBar {
     static final String VIBRATE_ICON_DESC_PREFIX_STRING = "Ringer vibrate";
     private final List<String> mStatusBarViewIds =
             List.of(DATE_ID, CLOCK_ID, WIFI_ICON_ID, BATTERY_ID, BATTERY_LEVEL_TEXT_ID);
+    private final int mDisplayId;
 
-    StatusBar() {
+    StatusBar(int displayId) {
+        mDisplayId = displayId;
         verifyClockIsVisible();
     }
 
+    private BySelector statusBarSelector(String resourceId) {
+        return sysuiResSelector(resourceId, mDisplayId);
+    }
+
     private static List<UiObject2> getNotificationIconsObjects() {
         // As the container for notifications can change between the moment we get it and we get its
         // children, we retry several times in case of failure. This aims at reducing flakiness.
@@ -145,8 +151,9 @@ public class StatusBar {
         }
     }
 
-    private static UiObject2 getBatteryIndication() {
-        return getUiDevice().wait(findObject(sysuiResSelector(BATTERY_ID)), 1000);
+    public UiObject2 getBatteryIndication() {
+        return DeviceHelpers.waitForObj(
+                statusBarSelector(BATTERY_ID), LONG_WAIT, () -> "Battery should be visible.");
     }
 
     /** Assert that clock indicator is visible. */
@@ -257,14 +264,16 @@ public class StatusBar {
     }
 
     /** Returns the clock time value on StatusBar. Experimental. */
+    public UiObject2 getClock() {
+        return DeviceHelpers.INSTANCE.waitForObj(
+                /* UiDevice= */ getUiDevice(),
+                /* selector= */ statusBarSelector(CLOCK_ID),
+                /* timeout= */ SHORT_WAIT,
+                /* errorProvider= */ () -> "Clock not found.");
+    }
+
     public String getClockTime() {
-        UiObject2 clockTime =
-                DeviceHelpers.INSTANCE.waitForObj(
-                        /* UiDevice= */ getUiDevice(),
-                        /* selector= */ sysuiResSelector(CLOCK_ID),
-                        /* timeout= */ SHORT_WAIT,
-                        /* errorProvider= */ () -> "Clock not found.");
-        return clockTime.getText();
+        return getClock().getText();
     }
 
     /** Returns the position of views in StatusBar. */
@@ -342,6 +351,48 @@ public class StatusBar {
                 () -> "Recording chip should be visible in status bar.");
     }
 
+    /**
+     * Verifies that the status bar is showing a chip for the given notification.
+     *
+     * @param text If present & non-empty, verifies the given text is shown inside the chip. If
+     *     present & empty, verifies the chip is not showing any text. if null, doesn't verify
+     *     anything about text inside the chip.
+     */
+    public void verifyNotificationChipIsVisible(String notificationKey, @Nullable String text) {
+        DeviceHelpers.INSTANCE.assertVisible(
+                statusBarSelector(notificationKey),
+                LONG_WAIT,
+                () -> "Notification chip " + notificationKey + " should be visible in status bar.");
+
+        if (text == null) {
+            return;
+        }
+
+        BySelector chipTextSelector = statusBarSelector(STATUS_BAR_CHIP_CONTENT_ID);
+        if (!text.isEmpty()) {
+            UiObject2 chipText =
+                    DeviceHelpers.INSTANCE.waitForObj(
+                            /* UiDevice= */ getUiDevice(),
+                            /* selector= */ chipTextSelector,
+                            /* timeout= */ LONG_WAIT,
+                            /* errorProvider= */ () -> "Chip text not found.");
+            assertWithMessage("Status bar chip text should be " + text)
+                    .that(chipText.getText())
+                    .isEqualTo(text);
+        } else {
+            DeviceHelpers.INSTANCE.assertInvisible(
+                    chipTextSelector,
+                    LONG_WAIT,
+                    () -> "StatusBar chip is showing text when it shouldn't be");
+        }
+    }
+
+    /** Clicks the chip in the status bar associated with the given notification. */
+    public void clickNotificationChip(String notificationKey) {
+        verifyNotificationChipIsVisible(notificationKey, /* text= */ null);
+        DeviceHelpers.waitForObj(sysuiResSelector(notificationKey)).click();
+    }
+
     /** Assert there is at least one status icon visible. */
     public void verifyAtLeastOneStatusIconIsVisible() {
         UiObject2 statusBar = DeviceHelpers.waitForObj(sysuiResSelector(STATUS_ICON_CONTAINER_ID));
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt
index 007e741d4..f2cb8fa2a 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt
@@ -16,23 +16,25 @@
 
 package android.platform.systemui_tapl.utils
 
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.BySelector
 import java.time.Duration
 
 const val SYSUI_PACKAGE = "com.android.systemui"
 const val SETTINGS_PACKAGE = "com.android.settings"
-private const val LAUNCHER_PACKAGE = "com.google.android.apps.nexuslauncher"
+const val LAUNCHER_PACKAGE = "com.google.android.apps.nexuslauncher"
 private const val ANDROID_PACKAGE = "android"
 
 object DeviceUtils {
     @JvmField val SHORT_WAIT: Duration = Duration.ofMillis(1_500)
     @JvmField val LONG_WAIT: Duration = Duration.ofMillis(10_000)
 
-    /** Returns a [BySelector] of a resource in sysui package. */
+    /** Returns a [BySelector] of a resource in sysui package on a given display id. */
     @JvmStatic
-    fun sysuiResSelector(resourceId: String): BySelector =
-        By.pkg(SYSUI_PACKAGE).res(SYSUI_PACKAGE, resourceId)
+    @JvmOverloads
+    fun sysuiResSelector(resourceId: String, displayId: Int = DEFAULT_DISPLAY): BySelector =
+        By.displayId(displayId).pkg(SYSUI_PACKAGE).res(SYSUI_PACKAGE, resourceId)
 
     /** Returns a [BySelector] of a resource in settings package. */
     @JvmStatic
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt
index 3810293e1..d17ad4de1 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt
@@ -15,8 +15,9 @@
  */
 package android.platform.systemui_tapl.volume.rule
 
+import android.Manifest
 import android.media.AudioManager
-import android.platform.systemui_tapl.permissions.rule.AdoptShellPermissionsRule
+import android.platform.uiautomatorhelpers.AdoptShellPermissionsRule
 import android.util.Log
 import org.junit.rules.TestWatcher
 import org.junit.runner.Description
@@ -37,7 +38,7 @@ class SetupVolumeRule(
     ) : this(audioManager, testVolumes.toList())
 
     private val adoptShellPermissionRule =
-        AdoptShellPermissionsRule(android.Manifest.permission.MANAGE_NOTIFICATIONS)
+        AdoptShellPermissionsRule(Manifest.permission.MANAGE_NOTIFICATIONS)
 
     private lateinit var originalVolumes: Collection<Volume>
 
diff --git a/libraries/tapl-common/src/android/platform/test/scenario/tapl_common/Gestures.kt b/libraries/tapl-common/src/android/platform/test/scenario/tapl_common/Gestures.kt
index 31727c514..629fdb886 100644
--- a/libraries/tapl-common/src/android/platform/test/scenario/tapl_common/Gestures.kt
+++ b/libraries/tapl-common/src/android/platform/test/scenario/tapl_common/Gestures.kt
@@ -18,8 +18,10 @@ package android.platform.test.scenario.tapl_common
 import android.os.SystemClock.sleep
 import android.platform.uiautomatorhelpers.BetterSwipe
 import android.platform.uiautomatorhelpers.BetterSwipe.Swipe
+import android.platform.uiautomatorhelpers.LongPressTimeoutExtender
 import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import android.provider.Settings
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.StaleObjectException
 import androidx.test.uiautomator.UiObject2
@@ -81,6 +83,20 @@ object Gestures {
         }
     }
 
+    /**
+     * Wait for the object to become clickable and enabled, then performs a short click on the
+     * object, but with extended long press duration using
+     * [LongPressTimeoutExtender.executeWithExtendedLongPressTimeout] to avoid it being mistaken
+     * with a long press.
+     *
+     * @param [uiObject] The object to click
+     * @param [objectName] Name of the object for diags
+     */
+    @JvmStatic
+    fun shortClick(uiObject: UiObject2, objectName: String) {
+        LongPressTimeoutExtender.executeWithExtendedLongPressTimeout { click(uiObject, objectName) }
+    }
+
     /**
      * Waits for the object to become long-clickable and enabled, then presses the object down.
      *
@@ -92,13 +108,14 @@ object Gestures {
     fun longClickDownUp(
         uiObject: UiObject2,
         objectName: String,
+        displayId: Int = DEFAULT_DISPLAY,
         whileHoldingFn: (Swipe.() -> Unit),
     ) {
         try {
             waitForObjectEnabled(uiObject, objectName)
             waitForObjectLongClickable(uiObject, objectName)
             val context = InstrumentationRegistry.getInstrumentation().targetContext
-            BetterSwipe.swipe(uiObject.visibleCenter) {
+            BetterSwipe.swipe(uiObject.visibleCenter, displayId) {
 
                 // press for twice the long press timeout, just to make sure.
                 val longPressMsec =
@@ -123,6 +140,6 @@ object Gestures {
      * attempted.
      */
     private fun clickNow(uiObject: UiObject2) {
-        BetterSwipe.swipe(uiObject.visibleCenter)
+        BetterSwipe.swipe(uiObject.visibleCenter, uiObject.displayId)
     }
 }
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt
deleted file mode 100644
index 16100e9c2..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.platform.uiautomator_helpers
-
-import android.graphics.Rect
-import android.platform.uiautomator_helpers.DeviceHelpers.context
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.SwipeUtils.calculateStartEndPoint
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.util.TypedValue
-import androidx.test.uiautomator.Direction
-import androidx.test.uiautomator.UiObject2
-import androidx.test.uiautomator.Until
-import java.time.Duration
-import java.time.temporal.ChronoUnit
-
-/**
- * A fling utility that should be used instead of [UiObject2.fling] for more reliable flings.
- *
- * See [BetterSwipe] for more details on the problem of [UiObject2.fling].
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object BetterFling {
-    private const val DEFAULT_FLING_MARGIN_DP = 30
-    private const val DEFAULT_PERCENTAGE = 1.0f
-    private val DEFAULT_FLING_DURATION = Duration.of(100, ChronoUnit.MILLIS)
-    private val DEFAULT_WAIT_TIMEOUT = Duration.of(5, ChronoUnit.SECONDS)
-
-    /**
-     * Flings [percentage] of [rect] in the given [direction], with [marginDp] margins.
-     *
-     * Note that when direction is [Direction.DOWN], the scroll will be from the top to the bottom
-     * (to scroll down).
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun fling(
-        rect: Rect,
-        direction: Direction,
-        duration: Duration = DEFAULT_FLING_DURATION,
-        marginDp: Int = DEFAULT_FLING_MARGIN_DP,
-        percentage: Float = DEFAULT_PERCENTAGE,
-    ) {
-        val (start, stop) =
-            calculateStartEndPoint(rect, direction, percentage, marginDp.dpToPx().toInt())
-
-        trace("Fling $start -> $stop") {
-            uiDevice.performActionAndWait(
-                { BetterSwipe.from(start).to(stop, duration).release() },
-                Until.scrollFinished(Direction.reverse(direction)),
-                DEFAULT_WAIT_TIMEOUT.toMillis()
-            )
-        }
-    }
-
-    private fun Number.dpToPx(): Float {
-        return TypedValue.applyDimension(
-            TypedValue.COMPLEX_UNIT_DIP,
-            toFloat(),
-            context.resources.displayMetrics,
-        )
-    }
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt
deleted file mode 100644
index 3c199f151..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt
+++ /dev/null
@@ -1,46 +0,0 @@
-package android.platform.uiautomator_helpers
-
-import android.graphics.Rect
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.SwipeUtils.calculateStartEndPoint
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import androidx.test.uiautomator.Direction
-import androidx.test.uiautomator.UiObject2
-import androidx.test.uiautomator.Until
-import java.time.Duration
-
-
-/**
- * A scroll utility that should be used instead of [UiObject2.scroll] for more reliable scrolls.
- *
- * See [BetterSwipe] for more details on the problem of [UiObject2.scroll].
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object BetterScroll {
-    private const val DEFAULT_PERCENTAGE = 0.8f
-    private val DEFAULT_WAIT_TIMEOUT = Duration.ofSeconds(1)
-
-    /**
-     * Scrolls [percentage] of [rect] in the given [direction].
-     *
-     * Note that when direction is [Direction.DOWN], the scroll will be from the top to the bottom
-     * (to scroll down).
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun scroll(
-        rect: Rect,
-        direction: Direction,
-        percentage: Float = DEFAULT_PERCENTAGE,
-    ) {
-        val (start, stop) = calculateStartEndPoint(rect, direction, percentage)
-
-        trace("Scrolling $start -> $stop") {
-            uiDevice.performActionAndWait(
-                { BetterSwipe.from(start).to(stop).pause().release() },
-                Until.scrollFinished(Direction.reverse(direction)),
-                DEFAULT_WAIT_TIMEOUT.toMillis()
-            )
-        }
-    }
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt
deleted file mode 100644
index 440d1e3fd..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.platform.uiautomator_helpers
-
-import android.animation.TimeInterpolator
-import android.graphics.Point
-import android.graphics.PointF
-import android.hardware.display.DisplayManager
-import android.os.SystemClock
-import android.os.SystemClock.sleep
-import android.platform.uiautomator_helpers.DeviceHelpers.context
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.platform.uiautomator_helpers.WaitUtils.ensureThat
-import android.util.Log
-import android.view.Display.DEFAULT_DISPLAY
-import android.view.InputDevice
-import android.view.MotionEvent
-import android.view.MotionEvent.TOOL_TYPE_FINGER
-import android.view.animation.DecelerateInterpolator
-import android.view.animation.LinearInterpolator
-import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
-import com.google.common.truth.Truth.assertThat
-import java.time.Duration
-import java.time.temporal.ChronoUnit.MILLIS
-import java.util.concurrent.atomic.AtomicInteger
-
-private val DEFAULT_DURATION: Duration = Duration.of(500, MILLIS)
-private val PAUSE_DURATION: Duration = Duration.of(250, MILLIS)
-
-/**
- * Allows fine control of swipes on the screen.
- *
- * Guarantees that all touches are dispatched, as opposed to [UiDevice] APIs, that might lose
- * touches in case of high load.
- *
- * It is possible to perform operation before the swipe finishes. Timestamp of touch events are set
- * according to initial time and duration.
- *
- * Example usage:
- * ```
- * val swipe = BetterSwipe.from(startPoint).to(intermediatePoint)
- *
- * assertThat(someUiState).isTrue();
- *
- * swipe.to(anotherPoint).release()
- * ```
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object BetterSwipe {
-
-    private val lastPointerId = AtomicInteger(0)
-
-    /** Starts a swipe from [start] at the current time. */
-    @JvmStatic fun from(start: PointF) = Swipe(start)
-
-    /** Starts a swipe from [start] at the current time. */
-    @JvmStatic fun from(start: Point) = Swipe(PointF(start.x.toFloat(), start.y.toFloat()))
-
-    class Swipe internal constructor(start: PointF) {
-
-        private val downTime = SystemClock.uptimeMillis()
-        private val pointerId = lastPointerId.incrementAndGet()
-        private var lastPoint: PointF = start
-        private var lastTime: Long = downTime
-        private var released = false
-
-        init {
-            log("Touch $pointerId started at $start")
-            sendPointer(currentTime = downTime, action = MotionEvent.ACTION_DOWN, point = start)
-        }
-
-        /**
-         * Swipes from the current point to [end] in [duration] using [interpolator] for the gesture
-         * speed. Pass [FLING_GESTURE_INTERPOLATOR] for a fling-like gesture that may leave the
-         * surface moving by inertia. Don't use it to drag objects to a precisely specified
-         * position. [PRECISE_GESTURE_INTERPOLATOR] will result in a precise drag-like gesture not
-         * triggering inertia.
-         */
-        @JvmOverloads
-        fun to(
-            end: PointF,
-            duration: Duration = DEFAULT_DURATION,
-            interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR
-        ): Swipe {
-            throwIfReleased()
-            val stepTime = calculateStepTime()
-            log(
-                "Swiping from $lastPoint to $end in $duration " +
-                    "(step time: ${stepTime.toMillis()}ms)" +
-                    "using ${interpolator.javaClass.simpleName}"
-            )
-            lastTime =
-                movePointer(duration = duration, from = lastPoint, to = end, interpolator, stepTime)
-            lastPoint = end
-            return this
-        }
-
-        /**
-         * Swipes from the current point to [end] in [duration] using [interpolator] for the gesture
-         * speed. Pass [FLING_GESTURE_INTERPOLATOR] for a fling-like gesture that may leave the
-         * surface moving by inertia. Don't use it to drag objects to a precisely specified
-         * position. [PRECISE_GESTURE_INTERPOLATOR] will result in a precise drag-like gesture not
-         * triggering inertia.
-         */
-        @JvmOverloads
-        fun to(
-            end: Point,
-            duration: Duration = DEFAULT_DURATION,
-            interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR
-        ): Swipe {
-            return to(PointF(end.x.toFloat(), end.y.toFloat()), duration, interpolator)
-        }
-
-        /** Sends the last point, simulating a finger pause. */
-        fun pause(): Swipe {
-            return to(PointF(lastPoint.x, lastPoint.y), PAUSE_DURATION)
-        }
-
-        /** Moves the pointer up, finishing the swipe. Further calls will result in an exception. */
-        @JvmOverloads
-        fun release(sync: Boolean = true) {
-            throwIfReleased()
-            log("Touch $pointerId released at $lastPoint")
-            sendPointer(
-                currentTime = lastTime,
-                action = MotionEvent.ACTION_UP,
-                point = lastPoint,
-                sync = sync
-            )
-            lastPointerId.decrementAndGet()
-            released = true
-        }
-
-        /** Moves the pointer by [delta], sending the event at [currentTime]. */
-        internal fun moveBy(delta: PointF, currentTime: Long, sync: Boolean) {
-            val targetPoint = PointF(lastPoint.x + delta.x, lastPoint.y + delta.y)
-            sendPointer(currentTime, MotionEvent.ACTION_MOVE, targetPoint, sync)
-            lastTime = currentTime
-            lastPoint = targetPoint
-        }
-
-        private fun throwIfReleased() {
-            check(!released) { "Trying to perform a swipe operation after pointer released" }
-        }
-
-        private fun sendPointer(
-            currentTime: Long,
-            action: Int,
-            point: PointF,
-            sync: Boolean = true
-        ) {
-            val event = getMotionEvent(downTime, currentTime, action, point, pointerId)
-
-            try {
-                trySendMotionEvent(event, sync)
-            } finally {
-                event.recycle()
-            }
-        }
-
-        private fun trySendMotionEvent(event: MotionEvent, sync: Boolean) {
-            ensureThat(
-                    "Injecting motion event",
-                    /* timeout= */ Duration.ofMillis(INJECT_EVENT_TIMEOUT_MILLIS),
-                    /* errorProvider= */ {
-                        "Injecting motion event $event failed after retrying for 10 seconds, " +
-                            "see logcat for the error"
-                    }
-                )
-                /* condition= */ {
-                    try {
-                        return@ensureThat getInstrumentation()
-                            .uiAutomation
-                            .injectInputEvent(event, sync, /* waitForAnimations= */ false)
-                    } catch (t: Throwable) {
-                        throw RuntimeException(t)
-                    }
-                }
-        }
-
-        /** Returns the time when movement finished. */
-        private fun movePointer(
-            duration: Duration,
-            from: PointF,
-            to: PointF,
-            interpolator: TimeInterpolator,
-            stepTime: Duration
-        ): Long {
-            val stepTimeMs = stepTime.toMillis()
-            val durationMs = duration.toMillis()
-            val steps = durationMs / stepTimeMs
-            val startTime = lastTime
-            var currentTime = lastTime
-            val startRealTime = SystemClock.uptimeMillis()
-            for (i in 0 until steps) {
-                // The next pointer event shouldn't be dispatched before its time. However, the code
-                // below might take time. So the time to sleep is calculated dynamically, based on
-                // the expected time of this event.
-                val timeToWait = stepTimeMs * i - (SystemClock.uptimeMillis() - startRealTime)
-                if (timeToWait > 0) sleep(stepTimeMs)
-                currentTime += stepTimeMs
-                val progress = interpolator.getInterpolation(i / (steps - 1f))
-                val point = from.lerp(progress, to)
-                sendPointer(currentTime, MotionEvent.ACTION_MOVE, point)
-            }
-            assertThat(currentTime).isEqualTo(startTime + stepTimeMs * steps)
-            return currentTime
-        }
-    }
-
-    /** Collection of swipes. This can be used to simulate multitouch. */
-    class Swipes internal constructor(vararg starts: PointF) {
-
-        private var lastTime: Long = SystemClock.uptimeMillis()
-        private val swipes: List<Swipe> = starts.map { Swipe(it) }
-
-        /** Moves all the swipes by [delta], in [duration] time with constant speed. */
-        fun moveBy(delta: PointF, duration: Duration = DEFAULT_DURATION): Swipes {
-            log("Moving ${swipes.size} touches by $delta")
-
-            val stepTimeMs = calculateStepTime().toMillis()
-            val durationMs = duration.toMillis()
-            val steps = durationMs / stepTimeMs
-            val startTime = lastTime
-            var currentTime = lastTime
-            val stepDelta = PointF(delta.x / steps, delta.y / steps)
-            (1..steps).forEach { _ ->
-                sleep(stepTimeMs)
-                currentTime += stepTimeMs
-                swipes.forEach { swipe ->
-                    // Sending the move events as not "sync". Otherwise the method waits for them
-                    // to be displatched. As here we're sending many that are supposed to happen at
-                    // the same time, we don't want the method to
-                    // wait after each single injection.
-                    swipe.moveBy(stepDelta, currentTime, sync = false)
-                }
-            }
-            assertThat(currentTime).isEqualTo(startTime + stepTimeMs * steps)
-            lastTime = currentTime
-            return this
-        }
-
-        /** Moves pointers up, finishing the swipe. Further calls will result in an exception. */
-        fun release() {
-            swipes.forEach { it.release(sync = false) }
-        }
-    }
-
-    private fun log(s: String) = Log.d("BetterSwipe", s)
-}
-
-private fun getMotionEvent(
-    downTime: Long,
-    eventTime: Long,
-    action: Int,
-    p: PointF,
-    pointerId: Int,
-): MotionEvent {
-    val properties =
-        MotionEvent.PointerProperties().apply {
-            id = pointerId
-            toolType = TOOL_TYPE_FINGER
-        }
-    val coordinates =
-        MotionEvent.PointerCoords().apply {
-            pressure = 1f
-            size = 1f
-            x = p.x
-            y = p.y
-        }
-    return MotionEvent.obtain(
-        /* downTime= */ downTime,
-        /* eventTime= */ eventTime,
-        /* action= */ action,
-        /* pointerCount= */ 1,
-        /* pointerProperties= */ arrayOf(properties),
-        /* pointerCoords= */ arrayOf(coordinates),
-        /* metaState= */ 0,
-        /* buttonState= */ 0,
-        /* xPrecision= */ 1.0f,
-        /* yPrecision= */ 1.0f,
-        /* deviceId= */ 0,
-        /* edgeFlags= */ 0,
-        /* source= */ InputDevice.SOURCE_TOUCHSCREEN,
-        /* flags= */ 0
-    )
-}
-
-private fun PointF.lerp(amount: Float, b: PointF) =
-    PointF(lerp(x, b.x, amount), lerp(y, b.y, amount))
-
-private fun lerp(start: Float, stop: Float, amount: Float): Float = start + (stop - start) * amount
-
-private fun calculateStepTime(displayId: Int = DEFAULT_DISPLAY): Duration {
-    return getTimeBetweenFrames(displayId).dividedBy(2)
-}
-
-private fun getTimeBetweenFrames(displayId: Int): Duration {
-    return trace("getMillisBetweenFrames") {
-        val displayManager =
-            context.getSystemService(DisplayManager::class.java)
-                ?: error("Couldn't get DisplayManager")
-        val display = displayManager.getDisplay(displayId)
-        val framesPerSecond = display.refreshRate // Frames per second
-        val millisBetweenFrames = 1000 / framesPerSecond
-        Duration.ofMillis(millisBetweenFrames.toLong())
-    }
-}
-
-/**
- * Interpolator for a fling-like gesture that may leave the surface moving by inertia. Don't use it
- * to drag objects to a precisely specified position.
- */
-val FLING_GESTURE_INTERPOLATOR = LinearInterpolator()
-
-/** Interpolator for a precise drag-like gesture not triggering inertia. */
-val PRECISE_GESTURE_INTERPOLATOR = DecelerateInterpolator()
-
-private const val INJECT_EVENT_TIMEOUT_MILLIS = 10_000L
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt
deleted file mode 100644
index 8f2aa5747..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.platform.uiautomator_helpers
-
-import android.animation.TimeInterpolator
-import android.app.Instrumentation
-import android.content.Context
-import android.graphics.PointF
-import android.os.Bundle
-import android.os.SystemClock.uptimeMillis
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.platform.uiautomator_helpers.WaitUtils.ensureThat
-import android.platform.uiautomator_helpers.WaitUtils.waitFor
-import android.platform.uiautomator_helpers.WaitUtils.waitForNullable
-import android.platform.uiautomator_helpers.WaitUtils.waitForPossibleEmpty
-import android.platform.uiautomator_helpers.WaitUtils.waitForValueToSettle
-import android.util.Log
-import androidx.test.platform.app.InstrumentationRegistry
-import androidx.test.uiautomator.BySelector
-import androidx.test.uiautomator.UiDevice
-import androidx.test.uiautomator.UiObject2
-import java.io.IOException
-import java.time.Duration
-
-private const val TAG = "DeviceHelpers"
-
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object DeviceHelpers {
-    private val SHORT_WAIT = Duration.ofMillis(1500)
-    private val LONG_WAIT = Duration.ofSeconds(10)
-    private val DOUBLE_TAP_INTERVAL = Duration.ofMillis(100)
-
-    private val instrumentationRegistry = InstrumentationRegistry.getInstrumentation()
-
-    @JvmStatic
-    val uiDevice: UiDevice
-        get() = UiDevice.getInstance(instrumentationRegistry)
-
-    @JvmStatic
-    val context: Context
-        get() = instrumentationRegistry.targetContext
-
-    /**
-     * Waits for an object to be visible and returns it.
-     *
-     * Throws an error with message provided by [errorProvider] if the object is not found.
-     */
-    @Deprecated(
-        "Use [DeviceHelpers.waitForObj] instead.",
-        ReplaceWith("DeviceHelpers.waitForObj(selector, timeout, errorProvider)"),
-    )
-    fun UiDevice.waitForObj(
-        selector: BySelector,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: () -> String = { "Object $selector not found" },
-    ): UiObject2 = DeviceHelpers.waitForObj(selector, timeout, errorProvider)
-
-    /**
-     * Waits for an object to be visible and returns it.
-     *
-     * Throws an error with message provided by [errorProvider] if the object is not found.
-     */
-    @JvmOverloads
-    @JvmStatic
-    fun waitForObj(
-        selector: BySelector,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: () -> String = { "Object $selector not found" },
-    ): UiObject2 =
-        waitFor("$selector object", timeout, errorProvider) { uiDevice.findObject(selector) }
-
-    /**
-     * Waits for an object that satisfies on the many possible [selectors] and returns it along with
-     * the matching selector.
-     *
-     * Throws an error with message provided by [errorProvider] if the object is not found.
-     */
-    fun waitForFirstObj(
-        vararg selectors: BySelector,
-        timeout: Duration = SHORT_WAIT,
-        errorProvider: () -> String = { "No object found for any $selectors" },
-    ): Pair<UiObject2, BySelector> {
-        return waitFor("$selectors objects", timeout, errorProvider) {
-                selectors.firstNotNullOfOrNull { selector ->
-                    uiDevice.findObject(selector)?.let {
-                        it to selector
-                    }
-                }
-            }
-    }
-
-    /**
-     * Waits for an object to be visible and returns it.
-     *
-     * Throws an error with message provided by [errorProvider] if the object is not found.
-     */
-    fun UiObject2.waitForObj(
-        selector: BySelector,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: () -> String = { "Object $selector not found" },
-    ): UiObject2 = waitFor("$selector object", timeout, errorProvider) { findObject(selector) }
-
-    /**
-     * Waits for an object that satisfies on the many possible [selectors] and returns it along with
-     * the matching selector.
-     *
-     * Throws an error with message provided by [errorProvider] if the object is not found.
-     */
-    fun UiObject2.waitForFirstObj(
-        vararg selectors: BySelector,
-        timeout: Duration = SHORT_WAIT,
-        errorProvider: () -> String = { "No object found for any $selectors" },
-    ): Pair<UiObject2, BySelector> {
-        return waitFor("$selectors objects", timeout, errorProvider) {
-            selectors.firstNotNullOfOrNull { selector ->
-                findObject(selector)?.let {
-                    it to selector
-                }
-            }
-        }
-    }
-
-    /**
-     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
-     */
-    @Deprecated(
-        "Use [DeviceHelpers.waitForNullableObj] instead.",
-        ReplaceWith("DeviceHelpers.waitForNullableObj(selector, timeout)"),
-    )
-    fun UiDevice.waitForNullableObj(
-        selector: BySelector,
-        timeout: Duration = SHORT_WAIT,
-    ): UiObject2? = DeviceHelpers.waitForNullableObj(selector, timeout)
-
-    /**
-     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
-     */
-    fun waitForNullableObj(selector: BySelector, timeout: Duration = SHORT_WAIT): UiObject2? =
-        waitForNullable("nullable $selector objects", timeout) { uiDevice.findObject(selector) }
-
-    /**
-     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
-     */
-    fun UiObject2.waitForNullableObj(
-        selector: BySelector,
-        timeout: Duration = SHORT_WAIT,
-    ): UiObject2? = waitForNullable("nullable $selector objects", timeout) { findObject(selector) }
-
-    /**
-     * Waits for objects matched by [selector] to be visible and returns them. Returns `null` if no
-     * objects are found
-     */
-    @Deprecated(
-        "Use DeviceHelpers.waitForPossibleEmpty",
-        ReplaceWith(
-            "waitForPossibleEmpty(selector, timeout)",
-            "android.platform.uiautomator_helpers.DeviceHelpers.waitForPossibleEmpty",
-        ),
-    )
-    fun waitForNullableObjects(
-        selector: BySelector,
-        timeout: Duration = SHORT_WAIT,
-    ): List<UiObject2>? = waitForPossibleEmpty(selector, timeout)
-
-    /**
-     * Waits for objects matched by selector to be visible. Returns an empty list when none is
-     * visible.
-     */
-    fun waitForPossibleEmpty(
-        selector: BySelector,
-        timeout: Duration = SHORT_WAIT,
-    ): List<UiObject2> =
-        waitForPossibleEmpty("$selector objects", timeout) { uiDevice.findObjects(selector) }
-
-    /**
-     * Waits for objects matched by [selector] to be visible and returns them. Returns `null` if no
-     * objects are found
-     */
-    @Deprecated(
-        "Use DeviceHelpers.waitForNullableObjects",
-        ReplaceWith("DeviceHelpers.waitForNullableObjects(selector, timeout)"),
-    )
-    fun UiDevice.waitForNullableObjects(
-        selector: BySelector,
-        timeout: Duration = SHORT_WAIT,
-    ): List<UiObject2>? = DeviceHelpers.waitForNullableObjects(selector, timeout)
-
-    /** Returns [true] when the [selector] is visible. */
-    fun hasObject(selector: BySelector): Boolean =
-        trace("Checking if device has $selector") { uiDevice.hasObject(selector) }
-
-    /** Finds an object with this selector and clicks on it. */
-    fun BySelector.click() {
-        trace("Clicking $this") { waitForObj(this).click() }
-    }
-
-    /**
-     * Asserts visibility of a [selector], waiting for [timeout] until visibility matches the
-     * expected.
-     *
-     * If [container] is provided, the object is searched only inside of it.
-     */
-    @JvmOverloads
-    @JvmStatic
-    @Deprecated(
-        "Use DeviceHelpers.assertVisibility directly",
-        ReplaceWith("DeviceHelpers.assertVisibility(selector, visible, timeout, errorProvider)"),
-    )
-    fun UiDevice.assertVisibility(
-        selector: BySelector,
-        visible: Boolean = true,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: (() -> String)? = null,
-    ) {
-        DeviceHelpers.assertVisibility(selector, visible, timeout, errorProvider)
-    }
-
-    /**
-     * Asserts visibility of a [selector], waiting for [timeout] until visibility matches the
-     * expected.
-     *
-     * If [container] is provided, the object is searched only inside of it.
-     */
-    @JvmOverloads
-    @JvmStatic
-    fun assertVisibility(
-        selector: BySelector,
-        visible: Boolean = true,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: (() -> String)? = null,
-    ) {
-        ensureThat("$selector is ${visible.asVisibilityBoolean()}", timeout, errorProvider) {
-            uiDevice.hasObject(selector) == visible
-        }
-    }
-
-    private fun Boolean.asVisibilityBoolean(): String =
-        when (this) {
-            true -> "visible"
-            false -> "invisible"
-        }
-
-    /**
-     * Asserts visibility of a [selector] inside this [UiObject2], waiting for [timeout] until
-     * visibility matches the expected.
-     */
-    fun UiObject2.assertVisibility(
-        selector: BySelector,
-        visible: Boolean,
-        timeout: Duration = LONG_WAIT,
-        errorProvider: (() -> String)? = null,
-    ) {
-        ensureThat(
-            "$selector is ${visible.asVisibilityBoolean()} inside $this",
-            timeout,
-            errorProvider,
-        ) {
-            hasObject(selector) == visible
-        }
-    }
-
-    /** Asserts that a this selector is visible. Throws otherwise. */
-    fun BySelector.assertVisible(
-        timeout: Duration = LONG_WAIT,
-        errorProvider: (() -> String)? = null,
-    ) {
-        uiDevice.assertVisibility(
-            selector = this,
-            visible = true,
-            timeout = timeout,
-            errorProvider = errorProvider,
-        )
-    }
-
-    /** Asserts that a this selector is invisible. Throws otherwise. */
-    @JvmStatic
-    @JvmOverloads
-    fun BySelector.assertInvisible(
-        timeout: Duration = LONG_WAIT,
-        errorProvider: (() -> String)? = null,
-    ) {
-        uiDevice.assertVisibility(
-            selector = this,
-            visible = false,
-            timeout = timeout,
-            errorProvider = errorProvider,
-        )
-    }
-
-    /**
-     * Executes a shell command on the device.
-     *
-     * Adds some logging. Throws [RuntimeException] In case of failures.
-     */
-    @Deprecated("Use [DeviceHelpers.shell] directly", ReplaceWith("DeviceHelpers.shell(command)"))
-    @JvmStatic
-    fun UiDevice.shell(command: String): String = DeviceHelpers.shell(command)
-
-    /**
-     * Executes a shell command on the device, and return its output one it finishes.
-     *
-     * Adds some logging to [UiDevice.executeShellCommand]. Throws [RuntimeException] In case of
-     * failures. Blocks until the command returns.
-     *
-     * @param command Shell command to execute
-     * @return Standard output of the command.
-     */
-    @JvmStatic
-    fun shell(command: String): String {
-        trace("Executing shell command: $command") {
-            Log.d(TAG, "Executing Shell Command: $command at ${uptimeMillis()}ms")
-            return try {
-                uiDevice.executeShellCommand(command)
-            } catch (e: IOException) {
-                Log.e(TAG, "IOException Occurred.", e)
-                throw RuntimeException(e)
-            }
-        }
-    }
-
-    /** Perform double tap at specified x and y position */
-    @JvmStatic
-    fun UiDevice.doubleTapAt(x: Int, y: Int) {
-        click(x, y)
-        Thread.sleep(DOUBLE_TAP_INTERVAL.toMillis())
-        click(x, y)
-    }
-
-    /**
-     * Aims at replacing [UiDevice.swipe].
-     *
-     * This should be used instead of [UiDevice.swipe] as it causes less flakiness. See
-     * [BetterSwipe].
-     */
-    @JvmStatic
-    @Deprecated(
-        "Use DeviceHelpers.betterSwipe directly",
-        ReplaceWith("DeviceHelpers.betterSwipe(startX, startY, endX, endY, interpolator)"),
-    )
-    fun UiDevice.betterSwipe(
-        startX: Int,
-        startY: Int,
-        endX: Int,
-        endY: Int,
-        interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
-    ) {
-        DeviceHelpers.betterSwipe(startX, startY, endX, endY, interpolator)
-    }
-
-    /**
-     * Aims at replacing [UiDevice.swipe].
-     *
-     * This should be used instead of [UiDevice.swipe] as it causes less flakiness. See
-     * [BetterSwipe].
-     */
-    @JvmStatic
-    fun betterSwipe(
-        startX: Int,
-        startY: Int,
-        endX: Int,
-        endY: Int,
-        interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
-    ) {
-        trace("Swiping ($startX,$startY) -> ($endX,$endY)") {
-            BetterSwipe.from(PointF(startX.toFloat(), startY.toFloat()))
-                .to(PointF(endX.toFloat(), endY.toFloat()), interpolator = interpolator)
-                .release()
-        }
-    }
-
-    /** [message] will be visible to the terminal when using `am instrument`. */
-    fun printInstrumentationStatus(tag: String, message: String) {
-        val result =
-            Bundle().apply {
-                putString(Instrumentation.REPORT_KEY_STREAMRESULT, "[$tag]: $message")
-            }
-        instrumentationRegistry.sendStatus(/* resultCode= */ 0, result)
-    }
-
-    /**
-     * Returns whether the screen is on.
-     *
-     * As this uses [waitForValueToSettle], it is resilient to fast screen on/off happening.
-     */
-    @JvmStatic
-    val UiDevice.isScreenOnSettled: Boolean
-        get() = waitForValueToSettle("Screen on") { isScreenOn }
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt
deleted file mode 100644
index c449f15a8..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the
- * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-package android.platform.uiautomator_helpers
-
-import android.os.Build
-import java.time.Duration
-
-private const val CUTTLEFISH = "cutf_cvm"
-private const val CUTTLEFISH_FACTOR = 5L
-
-/** Platform-dependent duration utils (specifically targeting Cuttlefish)
- *  For physical (non-emulator) devices, the timeout is unchanged,
- *  the if the Build.HARDWARE is Cuttlefish, we increase the factor by 5.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object DurationUtils {
-
-    /**
-     * For non-cuttlefish platforms, leave the timeout unchanged, otherwise
-     * increase the delay to compensate for slower performance.
-     */
-    fun Duration.platformAdjust() =
-        if (Build.HARDWARE == CUTTLEFISH)
-	    this.multipliedBy(CUTTLEFISH_FACTOR)
-        else
-	    this
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt
deleted file mode 100644
index 826861109..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the
- * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-package android.platform.uiautomator_helpers
-
-import android.content.pm.PackageManager
-import androidx.test.platform.app.InstrumentationRegistry
-
-/**
- * Adopt shell permissions for the target context.
- *
- * @param[permissions] the permission to adopt. Adopt all available permission is it's empty.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-class ShellPrivilege(vararg permissions: String) : AutoCloseable {
-
-    private val instrumentation = InstrumentationRegistry.getInstrumentation()
-    private val targetContext = instrumentation.targetContext
-    private val uiAutomation = instrumentation.uiAutomation
-    private var permissionsGranted = false
-
-    init {
-        permissionsGranted = grantMissingPermissions(*permissions)
-    }
-
-    /**
-     * @return[Boolean] True is there are any missing permission and we've successfully granted all
-     * of them.
-     */
-    private fun grantMissingPermissions(vararg permissions: String): Boolean {
-        if (permissions.isEmpty()) {
-            uiAutomation.adoptShellPermissionIdentity()
-            return true
-        }
-        val missingPermissions = permissions.filter { !it.isGranted() }.toTypedArray()
-        if (missingPermissions.isEmpty()) return false
-        uiAutomation.adoptShellPermissionIdentity(*missingPermissions)
-        return true
-    }
-
-    override fun close() {
-        if (permissionsGranted) instrumentation.uiAutomation.dropShellPermissionIdentity()
-        permissionsGranted = false
-    }
-
-    private fun String.isGranted(): Boolean =
-        targetContext.checkCallingPermission(this) == PackageManager.PERMISSION_GRANTED
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt
deleted file mode 100644
index eac703868..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-package android.platform.uiautomator_helpers
-
-import android.graphics.Point
-import android.graphics.Rect
-import androidx.test.uiautomator.Direction
-import androidx.test.uiautomator.Direction.DOWN
-import androidx.test.uiautomator.Direction.LEFT
-import androidx.test.uiautomator.Direction.RIGHT
-import androidx.test.uiautomator.Direction.UP
-
-/** Common utils to perform swipes. */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-internal object SwipeUtils {
-
-    /**
-     * Calculates start and end point taking into consideration first [marginPx], then [percent].
-     */
-    fun calculateStartEndPoint(
-        rawBound: Rect,
-        direction: Direction,
-        percent: Float = 1.0f,
-        marginPx: Int = 0
-    ): Pair<Point, Point> {
-        val bounds = Rect(rawBound)
-        bounds.inset(marginPx, marginPx)
-        val centerX = bounds.centerX()
-        val centerY = bounds.centerY()
-        return when (direction) {
-            LEFT -> {
-                Point(bounds.right, centerY) to
-                    Point(bounds.right - (bounds.width() * percent).toInt(), centerY)
-            }
-            RIGHT -> {
-                Point(bounds.left, centerY) to
-                    Point(bounds.left + (bounds.width() * percent).toInt(), centerY)
-            }
-            UP -> {
-                Point(centerX, bounds.bottom) to
-                    Point(centerX, bounds.bottom - (bounds.height() * percent).toInt())
-            }
-            DOWN -> {
-                Point(centerX, bounds.top) to
-                    Point(centerX, bounds.top + (bounds.height() * percent).toInt())
-            }
-        }
-    }
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/TracingUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/TracingUtils.kt
deleted file mode 100644
index 70d6caa40..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/TracingUtils.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-package android.platform.uiautomator_helpers
-
-import android.os.Trace
-import android.util.Log
-
-/** Tracing utils until androidx tracing library is updated in the tree. */
-@Deprecated("Use com.android.app.tracing utils instead.")
-object TracingUtils {
-
-    // from frameworks/base/core/java/android/os/Trace.java MAX_SECTION_NAME_LEN.
-    private const val MAX_TRACE_NAME_LEN = 127
-    private const val TAG = "TracingUtils"
-
-    @Deprecated(
-        "Use com.android.app.tracing.traceSection instead",
-        replaceWith = ReplaceWith("com.android.app.tracing.traceSection(sectionName, block)")
-    )
-    inline fun <T> trace(sectionName: String, block: () -> T): T {
-        Trace.beginSection(sectionName.shortenedIfNeeded())
-        try {
-            return block()
-        } finally {
-            Trace.endSection()
-        }
-    }
-
-    /** Shortens the section name if it's too long. */
-    fun beginSectionSafe(sectionName: String) {
-        Trace.beginSection(sectionName.shortenedIfNeeded())
-    }
-
-    /** Shorten the length of a string to make it less than the limit for atraces. */
-    fun String.shortenedIfNeeded(): String =
-        if (length > MAX_TRACE_NAME_LEN) {
-            Log.w(TAG, "Section name too long: \"$this\" (len=$length, max=$MAX_TRACE_NAME_LEN)")
-            substring(0, MAX_TRACE_NAME_LEN)
-        } else this
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt
deleted file mode 100644
index 8f1b71ffb..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.platform.uiautomator_helpers
-
-import android.graphics.PointF
-import android.graphics.Rect
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.WaitUtils.waitForValueToSettle
-import androidx.test.uiautomator.BySelector
-import androidx.test.uiautomator.Direction
-import androidx.test.uiautomator.UiObject2
-import com.google.common.truth.Truth.assertWithMessage
-
-/** Checks the view is in the vertical (Y) centre of the screen (+- 1 px). */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertInVerticalCentre() {
-    assertWithMessage("${this.resourceName} should be vertically (Y) centred (+- 1px)")
-        .that(this.stableBounds.centerY())
-        .isIn(uiDevice.displayHeight / 2 - 1..uiDevice.displayHeight / 2 + 1)
-}
-
-/** Checks the view is in the horizontal (X) centre of the screen (+- 1 px). */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertInHorizontalCentre() {
-    assertWithMessage("${this.resourceName} should be horizontally (X) centred (+- 1px)")
-        .that(this.stableBounds.centerX())
-        .isIn(uiDevice.displayWidth / 2 - 1..uiDevice.displayWidth / 2 + 1)
-}
-
-/**
- * Checks if centre of the view is on the bottom side by checking y centre is in the bottom half of
- * the screen vertically.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertCentreOnBottomSide() {
-    assertWithMessage("${this.resourceName} centre should be on the bottom side")
-        .that(this.stableBounds.centerY() > uiDevice.displayHeight / 2)
-        .isTrue()
-}
-
-/**
- * Checks if centre of the view is on the top side by checking y centre is in the top half of the
- * screen vertically.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertCentreOnTopSide() {
-    assertWithMessage("${this.resourceName} centre should be on the top side")
-        .that(this.stableBounds.centerY() < uiDevice.displayHeight / 2)
-        .isTrue()
-}
-
-/**
- * Checks if top of the view is on the bottom side by checking top bound is in the bottom half of
- * the screen vertically.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertTopOnBottomSide() {
-    assertWithMessage("${this.resourceName} top should be on the bottom side")
-        .that(this.stableBounds.top > uiDevice.displayHeight / 2)
-        .isTrue()
-}
-
-/**
- * Checks if top of the view is on the top side by checking top bound is in the top half of the
- * screen vertically.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertTopOnTopSide() {
-    assertWithMessage("${this.resourceName} top should be on the top side")
-        .that(this.stableBounds.top < uiDevice.displayHeight / 2)
-        .isTrue()
-}
-
-/** Checks if view horizontal (X) centre is on the right side */
-fun UiObject2.assertCenterOnTheRightSide() {
-    assertWithMessage("${this.resourceName} center should be on the right side")
-        .that(this.stableBounds.centerX() > uiDevice.displayWidth / 2)
-        .isTrue()
-}
-
-/** Checks if view horizontal (X) centre is on the left side */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertCenterOnTheLeftSide() {
-    assertWithMessage("${this.resourceName} center should be on the left side")
-        .that(this.stableBounds.centerX() < uiDevice.displayWidth / 2)
-        .isTrue()
-}
-
-/**
- * Checks if view is on the right side by checking left bound is in the middle of the screen or in
- * the right half of the screen horizontally.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertOnTheRightSide() {
-    assertWithMessage("${this.resourceName} left should be on the right side")
-        .that(this.stableBounds.left >= uiDevice.displayWidth / 2)
-        .isTrue()
-}
-
-/**
- * Checks if view is on the left side by checking right bound is in the middle of the screen or in
- * the left half of the screen horizontally.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.assertOnTheLeftSide() {
-    assertWithMessage("${this.resourceName} right should be on the left side")
-        .that(this.stableBounds.right <= uiDevice.displayWidth / 2)
-        .isTrue()
-}
-
-/**
- * Settled visible bounds of the object.
- *
- * Before returning, ensures visible bounds stay the same for a few seconds or fails. Useful to get
- * bounds of objects that might be animating.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-val UiObject2.stableBounds: Rect
-    get() = waitForValueToSettle("${this.resourceName} bounds") { visibleBounds }
-
-private const val MAX_FIND_ELEMENT_ATTEMPT = 15
-
-/**
- * Scrolls [this] in [direction] ([Direction.DOWN] by default) until finding [selector]. It returns
- * the first object that matches [selector] or `null` if it's not found after
- * [MAX_FIND_ELEMENT_ATTEMPT] scrolls. Caller can also provide additional [condition] to provide
- * more complex checking on the found object.
- *
- * Uses [BetterSwipe] to perform the scroll.
- */
-@JvmOverloads
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-fun UiObject2.scrollUntilFound(
-    selector: BySelector,
-    direction: Direction = Direction.DOWN,
-    condition: (UiObject2) -> Boolean = { true }
-): UiObject2? {
-    val (from, to) = getPointsToScroll(direction)
-    (0 until MAX_FIND_ELEMENT_ATTEMPT).forEach { _ ->
-        val f = findObject(selector)
-        if (f?.let { condition(it) } == true) return f
-        BetterSwipe.from(from).to(to, interpolator = FLING_GESTURE_INTERPOLATOR).release()
-    }
-    return null
-}
-
-private data class Vector2F(val from: PointF, val to: PointF)
-
-private fun UiObject2.getPointsToScroll(direction: Direction): Vector2F {
-    return when (direction) {
-        Direction.DOWN -> {
-            Vector2F(
-                PointF(visibleBounds.exactCenterX(), visibleBounds.bottom.toFloat() - 1f),
-                PointF(visibleBounds.exactCenterX(), visibleBounds.top.toFloat() + 1f)
-            )
-        }
-        Direction.UP -> {
-            Vector2F(
-                PointF(visibleBounds.exactCenterX(), visibleBounds.top.toFloat() + 1f),
-                PointF(visibleBounds.exactCenterX(), visibleBounds.bottom.toFloat() - 1f)
-            )
-        }
-        Direction.LEFT -> {
-            Vector2F(
-                PointF(visibleBounds.left.toFloat() + 1f, visibleBounds.exactCenterY()),
-                PointF(visibleBounds.right.toFloat() - 1f, visibleBounds.exactCenterY())
-            )
-        }
-        Direction.RIGHT -> {
-            Vector2F(
-                PointF(visibleBounds.right.toFloat() - 1f, visibleBounds.exactCenterY()),
-                PointF(visibleBounds.left.toFloat() + 1f, visibleBounds.exactCenterY())
-            )
-        }
-    }
-}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt
deleted file mode 100644
index de9802142..000000000
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt
+++ /dev/null
@@ -1,372 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the
- * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-package android.platform.uiautomator_helpers
-
-import android.os.SystemClock.sleep
-import android.os.SystemClock.uptimeMillis
-import android.os.Trace
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.platform.uiautomator_helpers.WaitUtils.LoggerImpl.Companion.withEventualLogging
-import android.util.Log
-import androidx.test.uiautomator.StaleObjectException
-import java.io.Closeable
-import java.time.Duration
-import java.time.Instant.now
-
-sealed interface WaitResult {
-    data class WaitThrown(val thrown: Throwable?) : WaitResult
-    data object WaitSuccess : WaitResult
-    data object WaitFailure : WaitResult
-}
-
-data class WaitReport(val result: WaitResult, val iterations: Int)
-
-/**
- * Collection of utilities to ensure a certain conditions is met.
- *
- * Those are meant to make tests more understandable from perfetto traces, and less flaky.
- */
-@Deprecated("Use uiautomatorhelpers, b/376676853")
-object WaitUtils {
-    private val DEFAULT_DEADLINE = Duration.ofSeconds(10)
-    private val POLLING_WAIT = Duration.ofMillis(100)
-    private val DEFAULT_SETTLE_TIME = Duration.ofSeconds(3)
-    private const val TAG = "WaitUtils"
-    private const val VERBOSE = true
-
-    /**
-     * Ensures that [condition] succeeds within [timeout], or fails with [errorProvider] message.
-     *
-     * This also logs with atrace each iteration, and its entire execution. Those traces are then
-     * visible in perfetto. Note that logs are output only after the end of the method, all
-     * together.
-     *
-     * Example of usage:
-     * ```
-     * ensureThat("screen is on") { uiDevice.isScreenOn }
-     * ```
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun ensureThat(
-        description: String? = null,
-        timeout: Duration = DEFAULT_DEADLINE,
-        errorProvider: (() -> String)? = null,
-        ignoreFailure: Boolean = false,
-        ignoreException: Boolean = false,
-        condition: () -> Boolean,
-    ) {
-        val errorProvider =
-            errorProvider
-                ?: { "Error ensuring that \"$description\" within ${timeout.toMillis()}ms" }
-        waitToBecomeTrue(description, timeout, condition).run {
-            when (result) {
-                WaitResult.WaitSuccess -> return
-                WaitResult.WaitFailure -> {
-                    if (ignoreFailure) {
-                        Log.w(TAG, "Ignoring ensureThat failure: ${errorProvider()}")
-                    } else {
-                        throw FailedEnsureException(errorProvider())
-                    }
-                }
-                is WaitResult.WaitThrown -> {
-                    if (!ignoreException) {
-                        throw RuntimeException("[#$iterations] iteration failed.", result.thrown)
-                    } else {
-                        return
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Wait until [timeout] for [condition] to become true, and then return a [WaitReport] with the
-     * result.
-     *
-     * This can be a useful replacement for [ensureThat] in situations where you want to wait for
-     * the condition to become true, but want a chance to recover if it does not.
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun waitToBecomeTrue(
-        description: String? = null,
-        timeout: Duration = DEFAULT_DEADLINE,
-        condition: () -> Boolean,
-    ): WaitReport {
-        val traceName =
-            if (description != null) {
-                "Ensuring $description"
-            } else {
-                "ensure"
-            }
-        var i = 1
-        trace(traceName) {
-            val startTime = uptimeMillis()
-            val timeoutMs = timeout.toMillis()
-            Log.d(TAG, "Starting $traceName")
-            withEventualLogging(logTimeDelta = true) {
-                log(traceName)
-                while (uptimeMillis() < startTime + timeoutMs) {
-                    trace("iteration $i") {
-                        try {
-                            if (condition()) {
-                                log("[#$i] Condition true")
-                                return WaitReport(WaitResult.WaitSuccess, i)
-                            }
-                        } catch (t: Throwable) {
-                            log("[#$i] Condition failing with exception")
-                            return WaitReport(WaitResult.WaitThrown(t), i)
-                        }
-
-                        log("[#$i] Condition false, might retry.")
-                        sleep(POLLING_WAIT.toMillis())
-                        i++
-                    }
-                }
-                log("[#$i] Condition has always been false. Failing.")
-                return WaitReport(WaitResult.WaitFailure, i)
-            }
-        }
-    }
-
-    /**
-     * Same as [waitForNullableValueToSettle], but assumes that [supplier] return value is non-null.
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun <T> waitForValueToSettle(
-        description: String? = null,
-        minimumSettleTime: Duration = DEFAULT_SETTLE_TIME,
-        timeout: Duration = DEFAULT_DEADLINE,
-        errorProvider: () -> String =
-            defaultWaitForSettleError(minimumSettleTime, description, timeout),
-        supplier: () -> T,
-    ): T {
-        return waitForNullableValueToSettle(
-            description,
-            minimumSettleTime,
-            timeout,
-            errorProvider,
-            supplier
-        )
-            ?: error(errorProvider())
-    }
-
-    /**
-     * Waits for [supplier] to return the same value for at least [minimumSettleTime].
-     *
-     * If the value changes, the timer gets restarted. Fails when reaching [timeoutMs]. The minimum
-     * running time of this method is [minimumSettleTime], in case the value is stable since the
-     * beginning.
-     *
-     * Fails if [supplier] throws an exception.
-     *
-     * Outputs atraces visible with perfetto.
-     *
-     * Example of usage:
-     * ```
-     * val screenOn = waitForValueToSettle("Screen on") { uiDevice.isScreenOn }
-     * ```
-     *
-     * Note: Prefer using [waitForValueToSettle] when [supplier] doesn't return a null value.
-     *
-     * @return the settled value. Throws if it doesn't settle.
-     */
-    @JvmStatic
-    @JvmOverloads
-    fun <T> waitForNullableValueToSettle(
-        description: String? = null,
-        minimumSettleTime: Duration = DEFAULT_SETTLE_TIME,
-        timeout: Duration = DEFAULT_DEADLINE,
-        errorProvider: () -> String =
-            defaultWaitForSettleError(minimumSettleTime, description, timeout),
-        supplier: () -> T?,
-    ): T? {
-        val prefix =
-            if (description != null) {
-                "Waiting for \"$description\" to settle"
-            } else {
-                "waitForValueToSettle"
-            }
-        val traceName =
-            prefix +
-                " (settleTime=${minimumSettleTime.toMillis()}ms, deadline=${timeout.toMillis()}ms)"
-        trace(traceName) {
-            Log.d(TAG, "Starting $traceName")
-            withEventualLogging(logTimeDelta = true) {
-                log(traceName)
-
-                val startTime = now()
-                var settledSince = startTime
-                var previousValue: T? = null
-                var previousValueSet = false
-                while (now().isBefore(startTime + timeout)) {
-                    val newValue =
-                        try {
-                            supplier()
-                        } catch (t: Throwable) {
-                            if (previousValueSet) {
-                                Trace.endSection()
-                            }
-                            log("Supplier has thrown an exception")
-                            throw RuntimeException(t)
-                        }
-                    val currentTime = now()
-                    if (previousValue != newValue || !previousValueSet) {
-                        log("value changed to $newValue")
-                        settledSince = currentTime
-                        if (previousValueSet) {
-                            Trace.endSection()
-                        }
-                        TracingUtils.beginSectionSafe("New value: $newValue")
-                        previousValue = newValue
-                        previousValueSet = true
-                    } else if (now().isAfter(settledSince + minimumSettleTime)) {
-                        log("Got settled value. Returning \"$previousValue\"")
-                        Trace.endSection() // previousValue is guaranteed to be non-null.
-                        return previousValue
-                    }
-                    sleep(POLLING_WAIT.toMillis())
-                }
-                if (previousValueSet) {
-                    Trace.endSection()
-                }
-                error(errorProvider())
-            }
-        }
-    }
-
-    private fun defaultWaitForSettleError(
-        minimumSettleTime: Duration,
-        description: String?,
-        timeout: Duration
-    ): () -> String {
-        return {
-            "Error getting settled (${minimumSettleTime.toMillis()}) " +
-                "value for \"$description\" within ${timeout.toMillis()}."
-        }
-    }
-
-    /**
-     * Waits for [supplier] to return a non-null value within [timeout].
-     *
-     * Returns null after the timeout finished.
-     */
-    fun <T> waitForNullable(
-        description: String,
-        timeout: Duration = DEFAULT_DEADLINE,
-        checker: (T?) -> Boolean = { it != null },
-        supplier: () -> T?,
-    ): T? {
-        var result: T? = null
-
-        ensureThat("Waiting for \"$description\"", timeout, ignoreFailure = true) {
-            result = supplier()
-            checker(result)
-        }
-        return result
-    }
-
-    /** Wraps [waitForNullable] using the default checker, and allowing kotlin supplier syntax. */
-    fun <T> waitForNullable(
-        description: String,
-        timeout: Duration = DEFAULT_DEADLINE,
-        supplier: () -> T?,
-    ): T? = waitForNullable(description, timeout, checker = { it != null }, supplier)
-
-    /**
-     * Waits for [supplier] to return a not null and not empty list within [timeout].
-     *
-     * Returns the not-empty list as soon as it's received, or an empty list once reached the
-     * timeout.
-     */
-    fun <T> waitForPossibleEmpty(
-        description: String,
-        timeout: Duration = DEFAULT_DEADLINE,
-        supplier: () -> List<T>?
-    ): List<T> =
-        waitForNullable(description, timeout, { !it.isNullOrEmpty() }, supplier) ?: emptyList()
-
-    /**
-     * Waits for [supplier] to return a non-null value within [timeout].
-     *
-     * Throws an exception with [errorProvider] provided message if [supplier] failed to produce a
-     * non-null value within [timeout].
-     */
-    fun <T> waitFor(
-        description: String,
-        timeout: Duration = DEFAULT_DEADLINE,
-        errorProvider: () -> String = {
-            "Didn't get a non-null value for \"$description\" within ${timeout.toMillis()}ms"
-        },
-        supplier: () -> T?
-    ): T = waitForNullable(description, timeout, supplier) ?: error(errorProvider())
-
-    /**
-     * Retry a block of code [times] times, if it throws a StaleObjectException.
-     *
-     * This can be used to reduce flakiness in cases where waitForObj throws although the object
-     * does seem to be present.
-     */
-    fun <T> retryIfStale(description: String, times: Int, block: () -> T): T {
-        return trace("retryIfStale: $description") outerTrace@{
-            repeat(times) {
-                trace("attempt #$it") {
-                    try {
-                        return@outerTrace block()
-                    } catch (e: StaleObjectException) {
-                        Log.w(TAG, "Caught a StaleObjectException ($e). Retrying.")
-                    }
-                }
-            }
-            // Run the block once without catching
-            trace("final attempt") { block() }
-        }
-    }
-
-    /** Generic logging interface. */
-    private interface Logger {
-        fun log(s: String)
-    }
-
-    /** Logs all messages when closed. */
-    private class LoggerImpl private constructor(private val logTimeDelta: Boolean) :
-        Closeable, Logger {
-        private val logs = mutableListOf<String>()
-        private val startTime = uptimeMillis()
-
-        companion object {
-            /** Executes [block] and prints all logs at the end. */
-            inline fun <T> withEventualLogging(
-                logTimeDelta: Boolean = false,
-                block: Logger.() -> T
-            ): T = LoggerImpl(logTimeDelta).use { it.block() }
-        }
-
-        override fun log(s: String) {
-            logs += if (logTimeDelta) "+${uptimeMillis() - startTime}ms $s" else s
-        }
-
-        override fun close() {
-            if (VERBOSE) {
-                Log.d(TAG, logs.joinToString("\n"))
-            }
-        }
-    }
-}
-
-/** Exception thrown when [WaitUtils.ensureThat] fails. */
-class FailedEnsureException(message: String? = null) : IllegalStateException(message)
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/AdoptShellPermissionsRule.kt
similarity index 84%
rename from libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt
rename to libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/AdoptShellPermissionsRule.kt
index 78daa8104..0ad4e03b9 100644
--- a/libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/AdoptShellPermissionsRule.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package android.platform.systemui_tapl.permissions.rule
+package android.platform.uiautomatorhelpers
 
 import android.app.UiAutomation
 import android.util.Log
@@ -27,7 +27,7 @@ import org.junit.runner.Description
  *
  * @see
  *   cts/common/device-side/util-axt/src/com/android/compatibility/common/util/AdoptShellPermissionsRule.java
- * @see UiAutomation.adoptShellPermissionIdentity
+ * @see android.app.UiAutomation.adoptShellPermissionIdentity
  */
 class AdoptShellPermissionsRule(
     vararg permissions: String,
@@ -35,7 +35,7 @@ class AdoptShellPermissionsRule(
         InstrumentationRegistry.getInstrumentation().uiAutomation,
 ) : TestWatcher() {
 
-    private val permissionSet: Set<String> = permissions.toSet()
+    private val permissionSet = permissions.toSet()
 
     init {
         require(permissionSet.isNotEmpty())
@@ -43,10 +43,8 @@ class AdoptShellPermissionsRule(
 
     override fun starting(description: Description?) {
         super.starting(description)
-        for (permission in permissionSet) {
-            uiAutomation.adoptShellPermissionIdentity(permission)
-        }
-        Log.d("AdoptShellPermissionsRule", "Adopted identities=${permissionSet}")
+        uiAutomation.adoptShellPermissionIdentity(*permissionSet.toTypedArray())
+        Log.d("AdoptShellPermissionsRule", "Adopted identities=$permissionSet")
     }
 
     override fun finished(description: Description?) {
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt
index d9a879be3..199ca30c1 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt
@@ -22,12 +22,23 @@ import android.hardware.display.DisplayManager
 import android.os.SystemClock
 import android.os.SystemClock.sleep
 import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.SwipeUtils.AXIS_GESTURE_SWIPE_FINGER_COUNT
+import android.platform.uiautomatorhelpers.SwipeUtils.CLASSIFICATION_MULTI_FINGER_SWIPE
 import android.platform.uiautomatorhelpers.TracingUtils.trace
 import android.util.Log
 import android.view.Display.DEFAULT_DISPLAY
 import android.view.InputDevice
+import android.view.InputDevice.SOURCE_TOUCHSCREEN
 import android.view.MotionEvent
+import android.view.MotionEvent.ACTION_DOWN
+import android.view.MotionEvent.ACTION_MOVE
+import android.view.MotionEvent.ACTION_POINTER_DOWN
+import android.view.MotionEvent.ACTION_POINTER_INDEX_SHIFT
+import android.view.MotionEvent.ACTION_POINTER_UP
+import android.view.MotionEvent.ACTION_UP
+import android.view.MotionEvent.CLASSIFICATION_NONE
 import android.view.MotionEvent.TOOL_TYPE_FINGER
+import android.view.MotionEvent.obtain
 import android.view.animation.DecelerateInterpolator
 import android.view.animation.LinearInterpolator
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
@@ -91,6 +102,7 @@ object BetterSwipe {
      * @param [end] end of swipe
      * @param [duration] duration of swipe
      * @param [interpolator] to use (fling or scroll, usually.
+     * @param [displayId] the display to send the event to.
      * @param [swipeFn] lambda on Swipe to send from()/to(), pause(), before release() is called.
      */
     @JvmOverloads
@@ -100,11 +112,12 @@ object BetterSwipe {
         end: PointF,
         duration: Duration = DEFAULT_DURATION,
         interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
+        displayId: Int = DEFAULT_DISPLAY,
         swipeFn: (Swipe.() -> Unit) = {},
     ) {
         var swipe: Swipe? = null
         try {
-            swipe = Swipe(start)
+            swipe = Swipe(start, displayId = displayId)
             swipe.from()
             swipe.swipeFn()
             swipe.to(end, duration, interpolator)
@@ -121,15 +134,10 @@ object BetterSwipe {
         end: Point,
         duration: Duration = DEFAULT_DURATION,
         interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
+        displayId: Int = DEFAULT_DISPLAY,
         swipeFn: (Swipe.() -> Unit) = {},
     ) {
-        swipe(
-            PointF(start.x.toFloat(), start.y.toFloat()),
-            PointF(end.x.toFloat(), end.y.toFloat()),
-            duration,
-            interpolator,
-            swipeFn,
-        )
+        swipe(PointF(start), PointF(end), duration, interpolator, displayId, swipeFn)
     }
 
     /**
@@ -138,13 +146,15 @@ object BetterSwipe {
      * but before the actual swipe/slide happens.
      *
      * @param [start] starting point.
+     * @param [displayId] the display to send the event to.
      * @param [swipeFn] lambda to call after touch down, but before swipe.
      */
+    @JvmOverloads
     @JvmStatic
-    fun swipe(start: PointF, swipeFn: (Swipe.() -> Unit)) {
+    fun swipe(start: PointF, displayId: Int = DEFAULT_DISPLAY, swipeFn: (Swipe.() -> Unit)) {
         var swipe: Swipe? = null
         try {
-            swipe = Swipe(start)
+            swipe = Swipe(start, displayId = displayId)
             swipe.from()
             swipe.swipeFn()
         } finally {
@@ -155,11 +165,72 @@ object BetterSwipe {
     /** Variant which takes an integer point. */
     @JvmOverloads
     @JvmStatic
-    fun swipe(start: Point, swipeFn: (Swipe.() -> Unit) = {}) {
-        swipe(PointF(start.x.toFloat(), start.y.toFloat()), swipeFn)
+    fun swipe(start: Point, displayId: Int = DEFAULT_DISPLAY, swipeFn: (Swipe.() -> Unit) = {}) {
+        swipe(PointF(start), displayId, swipeFn)
+    }
+
+    /**
+     * Perform a three-finger trackpad swipe from [start1], [start2] and [start3] in direction of
+     * [delta] on display [displayId].
+     *
+     * @param [start1] first starting point of swipe.
+     * @param [start2] second starting point of swipe.
+     * @param [start3] third starting point of swipe.
+     * @param [delta] Movement to be followed by all pointers.
+     * @param [displayId] the display to send the events to.
+     */
+    @JvmOverloads
+    @JvmStatic
+    fun threeFingerTrackpadSwipe(
+        start1: PointF,
+        start2: PointF,
+        start3: PointF,
+        delta: PointF,
+        displayId: Int = DEFAULT_DISPLAY,
+    ) {
+        var swipes: Swipes? = null
+        try {
+            swipes =
+                Swipes(
+                    displayId = displayId,
+                    source = InputDevice.SOURCE_TOUCHPAD or InputDevice.SOURCE_CLASS_POINTER,
+                    classification = CLASSIFICATION_MULTI_FINGER_SWIPE,
+                    start1,
+                    start2,
+                    start3,
+                )
+            swipes.from()
+            swipes.moveBy(delta)
+        } finally {
+            swipes?.release()
+        }
+    }
+
+    /** Variant of above which takes an integer points for starts and delta. */
+    @JvmOverloads
+    @JvmStatic
+    fun threeFingerTrackpadSwipe(
+        start1: Point,
+        start2: Point,
+        start3: Point,
+        delta: Point,
+        displayId: Int = DEFAULT_DISPLAY,
+    ) {
+        threeFingerTrackpadSwipe(
+            PointF(start1),
+            PointF(start2),
+            PointF(start3),
+            PointF(delta),
+            displayId,
+        )
     }
 
-    class Swipe internal constructor(val start: PointF) {
+    class Swipe internal constructor(
+        private val start: PointF,
+        private val source: Int = SOURCE_TOUCHSCREEN,
+        private val displayId: Int = DEFAULT_DISPLAY,
+        private val classification: Int = CLASSIFICATION_NONE,
+    ) {
 
         private var downTime = -1L
         private val pointerId = lastPointerId.incrementAndGet()
@@ -172,10 +243,15 @@ object BetterSwipe {
             log("Touch $pointerId started at $start")
         }
 
-        internal fun from(): Swipe {
+        internal fun from(action: Int = ACTION_DOWN): Swipe {
             throwIfReleased()
             downTime = SystemClock.uptimeMillis()
-            sendPointer(currentTime = downTime, action = MotionEvent.ACTION_DOWN, point = start)
+            sendPointer(
+                currentTime = downTime,
+                action = action,
+                point = start,
+            )
+            lastTime = downTime
             return this
         }
 
@@ -194,7 +270,7 @@ object BetterSwipe {
         ): Swipe {
             throwIfNotDown()
             throwIfReleased()
-            val stepTime = calculateStepTime()
+            val stepTime = calculateStepTime(displayId)
             log(
                 "Swiping from $lastPoint to $end in $duration " +
                     "(step time: ${stepTime.toMillis()}ms)" +
@@ -229,20 +305,11 @@ object BetterSwipe {
 
         /** Moves the pointer up, finishing the swipe. Further calls will result in an exception. */
         @JvmOverloads
-        /*
-        fun release(sync: Boolean = true) {
-            currentSwipes.remove(this)
-        */
-        internal fun release(sync: Boolean = true) {
+        internal fun release(sync: Boolean = true, action: Int = ACTION_UP) {
             currentSwipes.remove(this)
             throwIfReleased()
             log("Touch $pointerId released at $lastPoint")
-            sendPointer(
-                currentTime = lastTime,
-                action = MotionEvent.ACTION_UP,
-                point = lastPoint,
-                sync = sync,
-            )
+            sendPointer(lastTime, action, lastPoint, sync)
             lastPointerId.decrementAndGet()
             released = true
         }
@@ -250,7 +317,7 @@ object BetterSwipe {
         /** Moves the pointer by [delta], sending the event at [currentTime]. */
         internal fun moveBy(delta: PointF, currentTime: Long, sync: Boolean) {
             val targetPoint = PointF(lastPoint.x + delta.x, lastPoint.y + delta.y)
-            sendPointer(currentTime, MotionEvent.ACTION_MOVE, targetPoint, sync)
+            sendPointer(currentTime, ACTION_MOVE, targetPoint, sync)
             lastTime = currentTime
             lastPoint = targetPoint
         }
@@ -271,7 +338,17 @@ object BetterSwipe {
             point: PointF,
             sync: Boolean = true,
         ) {
-            val event = getMotionEvent(downTime, currentTime, action, point, pointerId)
+            val event =
+                getMotionEvent(
+                    downTime,
+                    currentTime,
+                    action,
+                    point,
+                    pointerId,
+                    source,
+                    displayId,
+                    classification,
+                )
 
             try {
                 trySendMotionEvent(event, sync)
@@ -288,9 +365,7 @@ object BetterSwipe {
             // the event.
 
             try {
-                getInstrumentation()
-                    .uiAutomation
-                    .injectInputEvent(event, sync, /* waitForAnimations= */ false)
+                getInstrumentation().uiAutomation.injectInputEvent(event, sync)
             } catch (t: Throwable) {
                 throw RuntimeException(t)
             }
@@ -319,7 +394,7 @@ object BetterSwipe {
                 currentTime += stepTimeMs
                 val progress = interpolator.getInterpolation(i / (steps - 1f))
                 val point = from.lerp(progress, to)
-                sendPointer(currentTime, MotionEvent.ACTION_MOVE, point)
+                sendPointer(currentTime, ACTION_MOVE, point)
             }
             assertThat(currentTime).isEqualTo(startTime + stepTimeMs * steps)
             return currentTime
@@ -327,10 +402,28 @@ object BetterSwipe {
     }
 
     /** Collection of swipes. This can be used to simulate multitouch. */
-    class Swipes internal constructor(vararg starts: PointF) {
+    class Swipes
+    internal constructor(
+        val displayId: Int = DEFAULT_DISPLAY,
+        val source: Int = SOURCE_TOUCHSCREEN,
+        val classification: Int = CLASSIFICATION_NONE,
+        vararg starts: PointF,
+    ) {
 
         private var lastTime: Long = SystemClock.uptimeMillis()
-        private val swipes: List<Swipe> = starts.map { Swipe(it) }
+        private val swipes: List<Swipe> = starts.map { start ->
+            Swipe(start, source, displayId, classification)
+        }
+
+        /** Start all swipes by injecting initial position as MotionEvents */
+        fun from(): Swipes {
+            swipes.forEachIndexed { index, swipe ->
+                val action =
+                    if (index == 0) ACTION_DOWN else ACTION_POINTER_DOWN.asIndexedPointer(index)
+                swipe.from(action)
+            }
+            return this
+        }
 
         /** Moves all the swipes by [delta], in [duration] time with constant speed. */
         fun moveBy(delta: PointF, duration: Duration = DEFAULT_DURATION): Swipes {
@@ -360,50 +453,68 @@ object BetterSwipe {
 
         /** Moves pointers up, finishing the swipe. Further calls will result in an exception. */
         fun release() {
-            swipes.forEach { it.release(sync = false) }
+            for (index in swipes.indices.reversed()) {
+                val action =
+                    if (index == 0) ACTION_UP else ACTION_POINTER_UP.asIndexedPointer(index)
+                swipes[index].release(sync = false, action)
+            }
         }
     }
 
     private fun log(s: String) = Log.d("BetterSwipe", s)
-}
 
-private fun getMotionEvent(
-    downTime: Long,
-    eventTime: Long,
-    action: Int,
-    p: PointF,
-    pointerId: Int,
-): MotionEvent {
-    val properties =
-        MotionEvent.PointerProperties().apply {
-            id = pointerId
-            toolType = TOOL_TYPE_FINGER
-        }
-    val coordinates =
-        MotionEvent.PointerCoords().apply {
-            pressure = 1f
-            size = 1f
-            x = p.x
-            y = p.y
-        }
-    return MotionEvent.obtain(
-        /* downTime= */ downTime,
-        /* eventTime= */ eventTime,
-        /* action= */ action,
-        /* pointerCount= */ 1,
-        /* pointerProperties= */ arrayOf(properties),
-        /* pointerCoords= */ arrayOf(coordinates),
-        /* metaState= */ 0,
-        /* buttonState= */ 0,
-        /* xPrecision= */ 1.0f,
-        /* yPrecision= */ 1.0f,
-        /* deviceId= */ 0,
-        /* edgeFlags= */ 0,
-        /* source= */ InputDevice.SOURCE_TOUCHSCREEN,
-        /* flags= */ 0,
-    )
+    private fun getMotionEvent(
+        downTime: Long,
+        eventTime: Long,
+        action: Int,
+        p: PointF,
+        pointerId: Int,
+        source: Int,
+        displayId: Int,
+        classification: Int,
+    ): MotionEvent {
+        val properties =
+            MotionEvent.PointerProperties().apply {
+                id = pointerId
+                toolType = TOOL_TYPE_FINGER
+            }
+        val coordinates =
+            MotionEvent.PointerCoords().apply {
+                pressure = 1f
+                size = 1f
+                x = p.x
+                y = p.y
+
+                // Need to set the swipe finger count to differentiate between 3 and 4 finger swipes
+                // 2 finger swipes are identified using other classifications.
+                val pointerCount = currentSwipes.size
+                if (pointerCount >= 3) {
+                    setAxisValue(AXIS_GESTURE_SWIPE_FINGER_COUNT, pointerCount.toFloat())
+                }
+            }
+        return obtain(
+            /* downTime= */ downTime,
+            /* eventTime= */ eventTime,
+            /* action= */ action,
+            /* pointerCount= */ pointerId,
+            /* pointerProperties= */ Array(pointerId) { properties },
+            /* pointerCoords= */ Array(pointerId) { coordinates },
+            /* metaState= */ 0,
+            /* buttonState= */ 0,
+            /* xPrecision= */ 1.0f,
+            /* yPrecision= */ 1.0f,
+            /* deviceId= */ 0,
+            /* edgeFlags= */ 0,
+            /* source= */ source,
+            /* displayId= */ displayId,
+            /* flags= */ 0,
+            /* classification= */ classification,
+        )!!
+    }
 }
 
+private fun Int.asIndexedPointer(index: Int): Int = this + (index shl ACTION_POINTER_INDEX_SHIFT)
+
 private fun PointF.lerp(amount: Float, b: PointF) =
     PointF(lerp(x, b.x, amount), lerp(y, b.y, amount))
 
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt
index 0822d9c67..4bb20af12 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt
@@ -29,6 +29,7 @@ import android.platform.uiautomatorhelpers.WaitUtils.waitForNullable
 import android.platform.uiautomatorhelpers.WaitUtils.waitForPossibleEmpty
 import android.platform.uiautomatorhelpers.WaitUtils.waitForValueToSettle
 import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.BySelector
 import androidx.test.uiautomator.UiDevice
@@ -369,12 +370,14 @@ object DeviceHelpers {
         endX: Int,
         endY: Int,
         interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
+        displayId: Int = DEFAULT_DISPLAY,
     ) {
         trace("Swiping ($startX,$startY) -> ($endX,$endY)") {
             BetterSwipe.swipe(
                 PointF(startX.toFloat(), startY.toFloat()),
                 PointF(endX.toFloat(), endY.toFloat()),
                 interpolator = interpolator,
+                displayId = displayId,
             )
         }
     }
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt
index 48f91cde7..109bc5b1c 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt
@@ -26,6 +26,12 @@ import androidx.test.uiautomator.Direction.UP
 /** Common utils to perform swipes. */
 internal object SwipeUtils {
 
+    /** [MotionEvent.CLASSIFICATION_MULTI_FINGER_SWIPE] is hidden.  */
+    const val CLASSIFICATION_MULTI_FINGER_SWIPE: Int = 4
+
+    /** [MotionEvent.AXIS_GESTURE_SWIPE_FINGER_COUNT] is hidden.  */
+    const val AXIS_GESTURE_SWIPE_FINGER_COUNT: Int = 53
+
     /**
      * Calculates start and end point taking into consideration first [marginPx], then [percent].
      */
diff --git a/robolab/roboStandaloneProj/tests/Android.bp b/robolab/roboStandaloneProj/tests/Android.bp
index 1821d1881..d68950267 100644
--- a/robolab/roboStandaloneProj/tests/Android.bp
+++ b/robolab/roboStandaloneProj/tests/Android.bp
@@ -41,6 +41,15 @@ android_robolectric_test {
     instrumentation_for: "MyRoboApplication",
 
     strict_mode: false,
+
+    test_options: {
+        test_runner_options: [
+            {
+                name: "java-flags",
+                value: "-Drobolectric.a.random.property=true",
+            },
+        ],
+    },
 }
 
 android_robolectric_test {
diff --git a/robolab/roboStandaloneProj/tests/src/com/android/myroboapplication/JavaFlagsPassedToRunnerTest.java b/robolab/roboStandaloneProj/tests/src/com/android/myroboapplication/JavaFlagsPassedToRunnerTest.java
new file mode 100644
index 000000000..6a048a311
--- /dev/null
+++ b/robolab/roboStandaloneProj/tests/src/com/android/myroboapplication/JavaFlagsPassedToRunnerTest.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.myroboapplication;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+
+import android.content.Intent;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.shadows.ShadowApplication;
+
+@RunWith(RobolectricTestRunner.class)
+public class JavaFlagsPassedToRunnerTest {
+
+    @Test
+    public void systemProperty_shouldBeSet() throws Exception {
+        assertEquals("true", System.getProperty("robolectric.a.random.property"));
+    }
+}
diff --git a/scripts/perf-setup/tests/configs/perf-setup.xml b/scripts/perf-setup/tests/configs/perf-setup.xml
deleted file mode 100644
index 67f2a150d..000000000
--- a/scripts/perf-setup/tests/configs/perf-setup.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2021 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Runs sample instrumentation test.">
-    <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
-    <target_preparer class="com.android.tradefed.targetprep.TestAppInstallSetup">
-        <option name="test-file-name" value="PerfSetupTests.apk" />
-    </target_preparer>
-
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="push" value="perf-setup.sh->/data/local/tmp/perf-setup.sh" />
-        <option name="cleanup" value="true" />
-    </target_preparer>
-
-    <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
-        <option name="run-command" value="chmod 755 /data/local/tmp/perf-setup.sh" />
-        <option name="run-command" value="/data/local/tmp/perf-setup.sh" />,
-        <option name="throw-if-cmd-fail" value="true" />
-    </target_preparer>
-
-    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
-        <option name="package" value="android.test.perfsetup" />
-        <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
-    </test>
-</configuration>
diff --git a/scripts/perf-setup/tests/src/android/test/perfsetup/PerfSetupTest.java b/scripts/perf-setup/tests/src/android/test/perfsetup/PerfSetupTest.java
deleted file mode 100644
index 81e42161f..000000000
--- a/scripts/perf-setup/tests/src/android/test/perfsetup/PerfSetupTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.test.perfsetup;
-
-import android.util.Log;
-
-import androidx.test.filters.SmallTest;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class PerfSetupTest {
-
-    private static final String TAG = PerfSetupTest.class.getSimpleName();
-
-    @BeforeClass
-    public static void beforeClass() {
-        Log.d(TAG, "beforeClass()");
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        Log.d(TAG, "afterClass()");
-    }
-
-    @Before
-    public void before() {
-        Log.d(TAG, "before()");
-    }
-
-    @After
-    public void after() {
-        Log.d(TAG, "after()");
-    }
-
-    @Test
-    @SmallTest
-    public void testPerfSetup() {
-        Log.d(TAG, "testPerfSetup()");
-    }
-}
diff --git a/tests/apphealth/scenarios/OWNERS b/tests/apphealth/scenarios/OWNERS
index b7c393c6e..297e6540a 100644
--- a/tests/apphealth/scenarios/OWNERS
+++ b/tests/apphealth/scenarios/OWNERS
@@ -8,4 +8,3 @@ mrosenfeld@google.com
 # Don't send reviews here.
 guangzhu@google.com #{LAST_RESORT_SUGGESTION}
 jdesprez@google.com #{LAST_RESORT_SUGGESTION}
-jwg@google.com #{LAST_RESORT_SUGGESTION}
diff --git a/tests/automotive/OWNERS b/tests/automotive/OWNERS
index b3254c698..960bcc197 100644
--- a/tests/automotive/OWNERS
+++ b/tests/automotive/OWNERS
@@ -4,4 +4,7 @@ schinchalkar@google.com
 rrwoods@google.com
 zhaomingyin@google.com
 rustamx@google.com
+rishus@google.com
+vitalidim@google.com
+smara@google.com
 per-file health/* = ravigutala@google.com, ivankozlov@google.com
\ No newline at end of file
diff --git a/tests/automotive/functional/AdminUserGrantPermissions/src/android/platform/tests/GrantPermissionsToNonAdminUserTest.java b/tests/automotive/functional/AdminUserGrantPermissions/src/android/platform/tests/GrantPermissionsToNonAdminUserTest.java
index 840e877da..06fa56ace 100644
--- a/tests/automotive/functional/AdminUserGrantPermissions/src/android/platform/tests/GrantPermissionsToNonAdminUserTest.java
+++ b/tests/automotive/functional/AdminUserGrantPermissions/src/android/platform/tests/GrantPermissionsToNonAdminUserTest.java
@@ -27,6 +27,7 @@ import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -44,6 +45,7 @@ public class GrantPermissionsToNonAdminUserTest {
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = GrantPermissionsToNonAdminUserTest.class.getSimpleName();
 
     public GrantPermissionsToNonAdminUserTest() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
@@ -52,38 +54,47 @@ public class GrantPermissionsToNonAdminUserTest {
 
     @After
     public void goBackToHomeScreen() {
+
+        Log.i(LOG_TAG, "Act: Go back to Settings screen");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testCreateNewUser() throws Exception {
+        Log.i(LOG_TAG, "Act: Create a new user");
         // create new user
         mMultiUserHelper.createUser(USER_NAME, false);
     }
 
     @Test
     public void testOpenPermissionsPageOfNonAdmin() throws Exception {
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts Setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Open Permissions screen");
         mUsersHelper.get().openPermissionsPage(USER_NAME);
     }
 
     @Test
     public void testToggleOffAllPermissionsAndCheck() throws Exception {
+        Log.i(LOG_TAG, "Assert: Create New Profile toggle is OFF");
         assertTrue(
                 (mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.CREATE_NEW_PROFILE_SWITCH))
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.CREATE_NEW_PROFILE_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Make Phone call toggle is OFF");
         assertTrue(
                 (mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.MAKE_PHONE_CALLS_SWITCH))
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.MAKE_PHONE_CALLS_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Install New Apps toggle is OFF");
         assertTrue(
                 (mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.INSTALL_NEW_APPS_SWITCH))
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.INSTALL_NEW_APPS_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Uninstall toggle is OFF");
         assertTrue(
                 (mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.UNINSTALL_APPS_SWITCH))
                         && (mUsersHelper
@@ -93,6 +104,7 @@ public class GrantPermissionsToNonAdminUserTest {
 
     @Test
     public void testToggleOnAllPermissionsAndCheck() throws Exception {
+        Log.i(LOG_TAG, "Assert: Create New Profile toggle is ON");
         assertTrue(
                 !(mUsersHelper
                                 .get()
@@ -100,16 +112,19 @@ public class GrantPermissionsToNonAdminUserTest {
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.CREATE_NEW_PROFILE_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Make Phone call toggle is ON");
         assertTrue(
                 !(mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.MAKE_PHONE_CALLS_SWITCH))
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.MAKE_PHONE_CALLS_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Install New Apps toggle is ON");
         assertTrue(
                 !(mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.INSTALL_NEW_APPS_SWITCH))
                         && (mUsersHelper
                                 .get()
                                 .toggle(AutomotiveConfigConstants.INSTALL_NEW_APPS_SWITCH)));
+        Log.i(LOG_TAG, "Assert: Uninstall toggle is ON");
         assertTrue(
                 !(mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.UNINSTALL_APPS_SWITCH))
                         && (mUsersHelper
@@ -120,6 +135,7 @@ public class GrantPermissionsToNonAdminUserTest {
     @Test
     // @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testUnCheckCreateNewProfilesPermissionAndSwitchToNonAdminUser() throws Exception {
+        Log.i(LOG_TAG, "Assert: Create New Profile toggle is ON");
         assertTrue(
                 (mUsersHelper.get().isToggleOn(AutomotiveConfigConstants.CREATE_NEW_PROFILE_SWITCH))
                         && (mUsersHelper
@@ -127,15 +143,22 @@ public class GrantPermissionsToNonAdminUserTest {
                                 .toggle(AutomotiveConfigConstants.CREATE_NEW_PROFILE_SWITCH)));
 
         // Switches the user mode to secondary and opens it profile account settings
+        Log.i(LOG_TAG, "Act: Switch user mode to secondary");
         UserInfo targetUser = mMultiUserHelper.getUserByName(USER_NAME);
         mMultiUserHelper.switchToUserId(targetUser.id);
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
 
         // verifies the current user and the visibility of Add profile
+        Log.i(LOG_TAG, "Act: Get user info");
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        Log.i(LOG_TAG, "Assert: Login user is Seconday user");
         assertTrue(currentUser.name.equals(USER_NAME));
+        Log.i(LOG_TAG, "Assert: Add Profile is not visible");
         assertFalse(mUsersHelper.get().isVisibleAddProfile());
+        Log.i(LOG_TAG, "Assert: Switch user mode to admin user");
         mMultiUserHelper.switchToUserId(mMultiUserHelper.getInitialUser());
+        Log.i(LOG_TAG, "Act: Remove user");
         mMultiUserHelper.removeUser(targetUser);
     }
 }
diff --git a/tests/automotive/functional/appgrid/src/android/platform/tests/AppGridTest.java b/tests/automotive/functional/appgrid/src/android/platform/tests/AppGridTest.java
index e68bf687f..ae981d2be 100644
--- a/tests/automotive/functional/appgrid/src/android/platform/tests/AppGridTest.java
+++ b/tests/automotive/functional/appgrid/src/android/platform/tests/AppGridTest.java
@@ -19,18 +19,31 @@ package android.platform.tests;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
+import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoAppGridHelper;
+import android.platform.test.rules.ConditionalIgnore;
+import android.platform.test.rules.ConditionalIgnoreRule;
+import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class AppGridTest {
+    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
+
+    private static final String SMS_APP = "SMS";
+    private static final String BLUETOOTH_APP = "Bluetooth Audio";
+    private static final String PHONE_APP = "Phone";
+    private static final String NEWS_APP = "News";
 
     private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
+    private static final String LOG_TAG = AppGridTest.class.getSimpleName();
 
     public AppGridTest() {
         mAppGridHelper = new HelperAccessor<>(IAutoAppGridHelper.class);
@@ -40,35 +53,140 @@ public class AppGridTest {
     @Test
     public void testOpen() {
         // Make sure app grid is not open before testing.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
         mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Appgrid is exit");
         assertFalse("App Grid is open even after exit.", mAppGridHelper.get().isAppInForeground());
         // Test open.
+        Log.i(LOG_TAG, "Act: Open Appgrid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Assert: Appgrid is open");
         assertTrue("App Grid is not open.", mAppGridHelper.get().isAppInForeground());
     }
 
     @Test
     public void testExit() {
         // Make sure app grid has been opened before testing.
+        Log.i(LOG_TAG, "Act: Open Appgrid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Assert: Appgrid is open");
         assertTrue("App Grid is not open.", mAppGridHelper.get().isAppInForeground());
         // Test exit.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
         mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Appgrid is exit");
         assertFalse("App Grid is open even after exit.", mAppGridHelper.get().isAppInForeground());
     }
 
     @Test
     public void testScroll() {
         // Re-enter app grid.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
         mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Appgrid");
         mAppGridHelper.get().open();
 
+        Log.i(LOG_TAG, "Act: Scroll to beginning");
         mAppGridHelper.get().scrollToBeginning();
         // Test scroll only when there are more than one page in app grid.
+        Log.i(LOG_TAG, "Act: Check Scroll to beginning");
         if (!mAppGridHelper.get().isAtEnd()) {
+            Log.i(LOG_TAG, "Act: Scroll forward");
             mAppGridHelper.get().scrollForward();
+            Log.i(LOG_TAG, "Assert: Scroll is at end");
             assertFalse("Scrolling did not work.", mAppGridHelper.get().isAtBeginning());
+            Log.i(LOG_TAG, "Act: Scroll forward");
             mAppGridHelper.get().scrollBackward();
         }
     }
+
+    @Test
+    public void testLaunchBluetoothAudio() {
+        // Make sure app grid is not open before testing
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
+        mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Act: Open Bluetooth App");
+        mAppGridHelper.get().openApp(BLUETOOTH_APP);
+        Log.i(LOG_TAG, "Assert: Bluetooth App is open");
+        assertTrue(
+                "Bluetooth Audio app is not opened",
+                mAppGridHelper
+                        .get()
+                        .checkPackageInForeground(AutomotiveConfigConstants.MEDIA_CENTER_PACKAGE));
+    }
+
+    @Test
+    public void testLaunchPhone() {
+        // Make sure app grid is not open before testing.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
+        mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Act: Open Phone App");
+        mAppGridHelper.get().openApp(PHONE_APP);
+        Log.i(LOG_TAG, "Assert: Phone App is open");
+        assertTrue(
+                "Phone app is not opened",
+                mAppGridHelper
+                        .get()
+                        .checkPackageInForeground(AutomotiveConfigConstants.DIAL_PACKAGE));
+    }
+
+    @Test
+    public void testLaunchSMS() {
+        // Make sure app grid is not open before testing.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
+        mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Act: Open SMS App");
+        mAppGridHelper.get().openApp(SMS_APP);
+        Log.i(LOG_TAG, "Assert: SMS App is Open");
+        assertTrue(
+                "SMS app is not opened",
+                mAppGridHelper
+                        .get()
+                        .checkPackageInForeground(AutomotiveConfigConstants.SMS_PACKAGE));
+    }
+
+    @Test
+    public void testLaunchNews() {
+        // Make sure app grid is not open before testing.
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
+        mAppGridHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Act: Open News App");
+        mAppGridHelper.get().openApp(NEWS_APP);
+        Log.i(LOG_TAG, "Assert: News App is Open");
+        assertTrue(
+                "News app is not opened",
+                mAppGridHelper
+                        .get()
+                        .checkPackageInForeground(AutomotiveConfigConstants.MEDIA_CENTER_PACKAGE));
+    }
+
+    @Test
+    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
+    public void testRecentAppsDisplaying() {
+        Log.i(LOG_TAG, "Act: Exit Appgrid");
+        mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open News App");
+        mAppGridHelper.get().openApp(PHONE_APP);
+        Log.i(LOG_TAG, "Act: Long tap on All Apps");
+        mAppGridHelper.get().longTapAllAppsButton();
+        Log.i(LOG_TAG, "Assert: Recent App screen is launched");
+        assertTrue(
+                "Recents Screen is not launched", mAppGridHelper.get().isRecentsScreenLaunched());
+        Log.i(LOG_TAG, "Act: Long tap on All Apps");
+        mAppGridHelper.get().singleTapAllAppsButton();
+        Log.i(LOG_TAG, "Assert: Recent App screen is closed");
+        assertFalse("Recents Screen is not closed", mAppGridHelper.get().isRecentsScreenLaunched());
+    }
 }
diff --git a/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java b/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java
index 546b71ee4..94d330539 100644
--- a/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java
+++ b/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java
@@ -20,6 +20,7 @@ import static junit.framework.Assert.assertTrue;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoAppGridHelper;
 import android.platform.helpers.IAutoMediaHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -32,6 +33,7 @@ import org.junit.runner.RunWith;
 public class BluetoothMediaTest {
     private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
     private HelperAccessor<IAutoMediaHelper> mAutoMediaHelper;
+    private static final String LOG_TAG = BluetoothMediaTest.class.getSimpleName();
 
     public BluetoothMediaTest() throws Exception {
         mAppGridHelper = new HelperAccessor<>(IAutoAppGridHelper.class);
@@ -40,21 +42,26 @@ public class BluetoothMediaTest {
 
     @Before
     public void openAppGrid() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         // Open the APP Grid
         mAppGridHelper.get().open();
     }
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go to Homescreen");
         mAppGridHelper.get().goToHomePage();
     }
 
     @Test
     public void testBluetoothMediaDefaultState() {
+        Log.i(LOG_TAG, "Act: Open Bluetooth Audio App");
         mAppGridHelper.get().openApp("Bluetooth Audio");
+        Log.i(LOG_TAG, "Assert: Bluetooth audio disconnected label is present");
         assertTrue(
                 "Bluetooth audio disconnected label is not present",
                 mAutoMediaHelper.get().isBluetoothAudioDisconnectedLabelVisible());
+        Log.i(LOG_TAG, "Assert: Connect to Bluetooth label is present");
         assertTrue(
                 "Connect to Bluetooth label is not present",
                 mAutoMediaHelper.get().isConnectToBluetoothLabelVisible());
diff --git a/tests/automotive/functional/dialer/src/android/platform/tests/DialTest.java b/tests/automotive/functional/dialer/src/android/platform/tests/DialTest.java
index dfdac513e..fb9020416 100644
--- a/tests/automotive/functional/dialer/src/android/platform/tests/DialTest.java
+++ b/tests/automotive/functional/dialer/src/android/platform/tests/DialTest.java
@@ -28,6 +28,7 @@ import android.platform.helpers.IAutoDialHelper.AudioSource;
 import android.platform.helpers.IAutoDialHelper.OrderType;
 import android.platform.helpers.IAutoVehicleHardKeysHelper;
 import android.platform.test.option.StringOption;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -47,6 +48,7 @@ public class DialTest {
     private static final String LARGE_NUMBER_PARAM = "large-phone-number";
     private static final String SEARCH_CONTACT_NUMBER_PARAM = "search-contact-number";
     private static final String SEARCH_CONTACT_NAME_PARAM = "search-contact-name";
+    private static final String LOG_TAG = DialTest.class.getSimpleName();
 
     @ClassRule
     public static StringOption mSmallPhoneNumber =
@@ -76,33 +78,49 @@ public class DialTest {
 
     @After
     public void endCall() {
+        Log.i(LOG_TAG, "Act: Press End Call");
         mVehicleHardKeysHelper.get().pressEndCallKey();
     }
 
     @Test
     public void testDialSmallNumber() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call ");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: Get actual dialed number");
         String actualDialedNumber = mDialerHelper.get().getDialedNumber();
+        Log.i(LOG_TAG, "Assert: Small Phone number is same as dialed number");
         assertEquals(mSmallPhoneNumber.get(), actualDialedNumber.replaceAll("[-()\\s]", ""));
+        Log.i(LOG_TAG, "Act: End Call");
         mDialerHelper.get().endCall();
     }
 
     @Test
     public void testDialLargeNumber() {
+        Log.i(LOG_TAG, "Act: Dial large phone number");
         mDialerHelper.get().dialANumber(mLargePhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call ");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: Get actual dialed number");
         String actualDialedNumber = mDialerHelper.get().getDialedNumber();
+        Log.i(LOG_TAG, "Assert: Large Phone number is same as dialed number");
         assertEquals(mLargePhoneNumber.get(), actualDialedNumber.replaceAll("[-()\\s]", ""));
+        Log.i(LOG_TAG, "Act: End Call");
         mDialerHelper.get().endCall();
     }
 
     @Test
     public void testHistoryUpdatesCalledNumber() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call ");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: End Call");
         mDialerHelper.get().endCall();
+        Log.i(LOG_TAG, "Act: Open Call History");
         mDialerHelper.get().openCallHistory();
+        Log.i(LOG_TAG, "Act: Call History is updated");
         assertTrue(
                 "Call History did not update",
                 mDialerHelper.get().getRecentCallHistory().equals(mSmallPhoneNumber.get()));
@@ -110,11 +128,17 @@ public class DialTest {
 
     @Test
     public void testHistoryUpdatesCalledContactName() {
+        Log.i(LOG_TAG, "Act: Open Dialer app");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Get Contact name");
         String dialContactByName = mSearchContactName.get();
+        Log.i(LOG_TAG, "Act: Make a call using contact name");
         mDialerHelper.get().callContact(dialContactByName);
+        Log.i(LOG_TAG, "Act: End Call");
         mDialerHelper.get().endCall();
+        Log.i(LOG_TAG, "Act: Open Call History");
         mDialerHelper.get().openCallHistory();
+        Log.i(LOG_TAG, "Act: Call History is updated");
         assertTrue(
                 "Call History did not update",
                 mDialerHelper.get().getRecentCallHistory().equals(dialContactByName));
@@ -122,72 +146,107 @@ public class DialTest {
 
     @Test
     public void testDeleteDialedNumber() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Delete dialed number");
         mDialerHelper.get().deleteDialedNumber();
+        Log.i(LOG_TAG, "Act: Get the number in dial pad");
         String numberAfterDelete = mDialerHelper.get().getNumberInDialPad();
+        Log.i(LOG_TAG, "Assert: Dialed number is same as Deleted number");
         assertTrue(DIAL_A_NUMBER.equals(numberAfterDelete));
     }
 
     @Test
     public void testMuteUnmuteCall() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call ");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: Mute the call ");
         try {
+            Log.i(LOG_TAG, "Act: Mute the call ");
             mDialerHelper.get().muteCall();
+            Log.i(LOG_TAG, "Act: Unmute the call ");
             mDialerHelper.get().unmuteCall();
         } catch (RuntimeException e) {
             throw new RuntimeException(e);
         } finally {
+            Log.i(LOG_TAG, "Act: End call ");
             mDialerHelper.get().endCall();
         }
     }
 
     @Test
     public void testEndCallHardkey() {
+        Log.i(LOG_TAG, "Act: Dial large phone number");
         mDialerHelper.get().dialANumber(mLargePhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: Get dialed number");
         String actualDialedNumber = mDialerHelper.get().getDialedNumber();
+        Log.i(LOG_TAG, "Assert: Large Phone number is same as dialed number");
         assertEquals(mLargePhoneNumber.get(), actualDialedNumber.replaceAll("[-()\\s]", ""));
+        Log.i(LOG_TAG, "Act: End call using hardkey");
         mVehicleHardKeysHelper.get().pressEndCallKey();
     }
 
     @Test
     public void testCallAudioSourceTransfer() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: Change audio source to phone");
         mDialerHelper.get().changeAudioSource(AudioSource.PHONE);
+        Log.i(LOG_TAG, "Act: Change audio source to Car speakers");
         mDialerHelper.get().changeAudioSource(AudioSource.CAR_SPEAKERS);
+        Log.i(LOG_TAG, "Act: End call ");
         mDialerHelper.get().endCall();
     }
 
     @Test
     public void testCallFromHistory() {
+        Log.i(LOG_TAG, "Act: Dial small phone number");
         mDialerHelper.get().dialANumber(mSmallPhoneNumber.get());
+        Log.i(LOG_TAG, "Act: Make a call");
         mDialerHelper.get().makeCall();
+        Log.i(LOG_TAG, "Act: End call ");
         mDialerHelper.get().endCall();
+        Log.i(LOG_TAG, "Act: Open call history");
         mDialerHelper.get().openCallHistory();
+        Log.i(LOG_TAG, "Act: Call most recent number from call history");
         mDialerHelper.get().callMostRecentHistory();
+        Log.i(LOG_TAG, "Assert: History is same as dialed number");
         assertTrue(
                 "History is not same as dialed number.",
                 mDialerHelper.get().getDialedContactName().equals(mSmallPhoneNumber.get()));
+        Log.i(LOG_TAG, "Act: End call ");
         mDialerHelper.get().endCall();
     }
 
     @Test
     public void testDisplayedNameMatchesCalledContactName() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Get some contact name");
         String dialContactByName = mSearchContactName.get();
+        Log.i(LOG_TAG, "Act: Make a call using contact name");
         mDialerHelper.get().callContact(dialContactByName);
+        Log.i(LOG_TAG, "Assert: Contact name is same as dialed contact");
         assertTrue(
                 "Contact name is not the same",
                 mDialerHelper.get().getContactName().contains(dialContactByName));
+        Log.i(LOG_TAG, "Act: End call ");
         mDialerHelper.get().endCall();
     }
 
     @Test
     public void testDisplayedContactTypeMatchesCalledContactType() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Make a call using contact name");
         mDialerHelper.get().callContact(mSearchContactName.get());
+        Log.i(LOG_TAG, "Assert: Contact type is same as dialed contact type");
         assertTrue(
                 "Contact detail is not the same",
                 mDialerHelper.get().getContactType().equalsIgnoreCase(CONTACT_TYPE));
@@ -196,14 +255,19 @@ public class DialTest {
 
     @Test
     public void testSearchContactByName() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Search contact by name");
         mDialerHelper.get().searchContacts();
     }
 
     @Test
     public void testSearchContactByNumber() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Search contact by phone number");
         mDialerHelper.get().searchContactsByNumber(mSearchContactNumber.get());
+        Log.i(LOG_TAG, "Assert: Search contact by phone number is found");
         assertEquals(
                 "Cannot find contact",
                 mSearchContactName.get(),
@@ -212,13 +276,18 @@ public class DialTest {
 
     @Test
     public void testSortContacts() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Sort contacts by last name");
         mDialerHelper.get().sortContactListBy(OrderType.LAST_NAME);
+        Log.i(LOG_TAG, "Assert: Sorted contacts by last name is correct");
         assertEquals(
                 "Order by last name is not correct.",
                 mDialerHelper.get().getFirstContactFromContactList(),
                 DIALED_CONTACT);
+        Log.i(LOG_TAG, "Act: Sort contacts by first name");
         mDialerHelper.get().sortContactListBy(OrderType.FIRST_NAME);
+        Log.i(LOG_TAG, "Assert: Sorted contacts by first name is correct");
         assertEquals(
                 "Order is not correct.",
                 mDialerHelper.get().getFirstContactFromContactList(),
@@ -227,17 +296,27 @@ public class DialTest {
 
     @Test
     public void testAddRemoveFavoriteContact() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Get a contact name");
         String favoritesContact = mSearchContactName.get();
+        Log.i(LOG_TAG, "Act: Open contact details of the contact");
         mDialerHelper.get().openDetailsPage(favoritesContact);
+        Log.i(LOG_TAG, "Act: Add contacts to favourate list");
         mContactDetailsHelper.get().addRemoveFavoriteContact();
+        Log.i(LOG_TAG, "Act: Close Contact details screen");
         mContactDetailsHelper.get().closeDetailsPage();
+        Log.i(LOG_TAG, "Assert: Contact is added t favourate list");
         assertTrue(
                 "Contact is not added to favorites.",
                 mDialerHelper.get().isContactInFavorites(favoritesContact));
+        Log.i(LOG_TAG, "Act: Open contact details of the favourate contact");
         mDialerHelper.get().openDetailsPage(favoritesContact);
+        Log.i(LOG_TAG, "Act: Remove contact from favourate list");
         mContactDetailsHelper.get().addRemoveFavoriteContact();
+        Log.i(LOG_TAG, "Act: Close Contact details screen");
         mContactDetailsHelper.get().closeDetailsPage();
+        Log.i(LOG_TAG, "Assert: Contact is removed from favourate list");
         assertFalse(
                 "Contact is not removed from favorites.",
                 mDialerHelper.get().isContactInFavorites(favoritesContact));
@@ -245,13 +324,19 @@ public class DialTest {
 
     @Test
     public void testMakeCallFromContactDetailsPage() {
+        Log.i(LOG_TAG, "Act: Open Dialer");
         mDialerHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open Details page of a contact");
         mDialerHelper.get().openDetailsPage(DETAILED_CONTACT);
+        Log.i(LOG_TAG, "Act: Make a call to the contact of type MOBILE");
         mContactDetailsHelper.get().makeCallFromDetailsPageByType(ContactType.MOBILE);
+        Log.i(LOG_TAG, "Assert: Contact name is same as dialed contact ");
         assertTrue(
                 "Contact name is not the same",
                 mDialerHelper.get().getContactName().contains(DETAILED_CONTACT));
+        Log.i(LOG_TAG, "Act: End call");
         mDialerHelper.get().endCall();
+        Log.i(LOG_TAG, "Act: Close Contact Details Page");
         mContactDetailsHelper.get().closeDetailsPage();
     }
 }
diff --git a/tests/automotive/functional/home/src/android/platform/tests/HomeTest.java b/tests/automotive/functional/home/src/android/platform/tests/HomeTest.java
index 9530e1bd9..032aaf92d 100644
--- a/tests/automotive/functional/home/src/android/platform/tests/HomeTest.java
+++ b/tests/automotive/functional/home/src/android/platform/tests/HomeTest.java
@@ -20,6 +20,7 @@ import static junit.framework.Assert.assertTrue;
 
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoHomeHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -31,33 +32,41 @@ import org.junit.runner.RunWith;
 public class HomeTest {
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
 
+    private static final String LOG_TAG = HomeTest.class.getSimpleName();
+
     public HomeTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
     }
 
     @Before
     public void setup() {
+        Log.i(LOG_TAG, "Act: Open Home screen");
         mHomeHelper.get().open();
     }
 
     @Test
     public void testAssistantWidget() {
+        Log.i(LOG_TAG, "Assert: Assistant widget is visible");
         assertTrue(mHomeHelper.get().hasAssistantWidget());
     }
 
     @Test
     public void testMediaWidget() {
+        Log.i(LOG_TAG, "Assert: Media widget is visible");
         assertTrue(mHomeHelper.get().hasMediaWidget());
     }
 
     @Test
     public void testTempetraureWidget() {
+        Log.i(LOG_TAG, "Assert: Driver Temperature widget is visible");
         assertTrue("Driver temperature is not displayed", mHomeHelper.get().hasTemperatureWidget());
     }
 
     @Test
     public void testHvacPanel() {
+        Log.i(LOG_TAG, "Act: Open HVAC panel");
         mHomeHelper.get().openHVAC();
+        Log.i(LOG_TAG, "Assert: HVAC panel is open");
         assertTrue("HVAC panel is not opened", mHomeHelper.get().isHVACOpen());
     }
 }
diff --git a/tests/automotive/functional/home/src/android/platform/tests/SystemUiTest.java b/tests/automotive/functional/home/src/android/platform/tests/SystemUiTest.java
index bd5e12f1a..33b091749 100644
--- a/tests/automotive/functional/home/src/android/platform/tests/SystemUiTest.java
+++ b/tests/automotive/functional/home/src/android/platform/tests/SystemUiTest.java
@@ -21,6 +21,7 @@ import static junit.framework.Assert.assertTrue;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoFacetBarHelper;
 import android.platform.helpers.IAutoHomeHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -33,6 +34,7 @@ public class SystemUiTest {
 
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
     private HelperAccessor<IAutoFacetBarHelper> mFacetBarHelper;
+    private static final String LOG_TAG = SystemUiTest.class.getSimpleName();
 
     public SystemUiTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
@@ -41,15 +43,21 @@ public class SystemUiTest {
 
     @Before
     public void setup() {
+        Log.i(LOG_TAG, "Act: Open Home screen");
         mHomeHelper.get().open();
     }
 
     @Test
     public void testSystemUi() {
+        Log.i(LOG_TAG, "Act: Open System UI");
         mHomeHelper.get().openSystemUi();
+        Log.i(LOG_TAG, "Assert: Maps widget is displayed");
         assertTrue("Maps widget is not displayed", mHomeHelper.get().hasMapsWidget());
+        Log.i(LOG_TAG, "Act: Open Car Ui");
         mHomeHelper.get().openCarUi();
+        Log.i(LOG_TAG, "Act: Open Facet bar App Grid");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.APP_GRID);
+        Log.i(LOG_TAG, "Assert: App Grid is Open");
         assertTrue(
                 "App grid did not open",
                 mFacetBarHelper
diff --git a/tests/automotive/functional/locationstatusbar/src/android/platform/tests/LocationAccessTest.java b/tests/automotive/functional/locationstatusbar/src/android/platform/tests/LocationAccessTest.java
index 6b27804ca..ea79bfa9c 100644
--- a/tests/automotive/functional/locationstatusbar/src/android/platform/tests/LocationAccessTest.java
+++ b/tests/automotive/functional/locationstatusbar/src/android/platform/tests/LocationAccessTest.java
@@ -22,6 +22,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoSettingsLocationHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -34,6 +35,8 @@ public class LocationAccessTest {
 
     private HelperAccessor<IAutoSettingsLocationHelper> mSettingLocationHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private final String APP_NAME = "Google Maps";
+    private static final String LOG_TAG = LocationAccessTest.class.getSimpleName();
 
     public LocationAccessTest() {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -42,31 +45,42 @@ public class LocationAccessTest {
 
     @Before
     public void setup() {
+        Log.i(LOG_TAG, "Act: Open Location settings");
         mSettingHelper.get().openSetting(SettingsConstants.LOCATION_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Location settings is open");
         assertTrue(
                 "Location settings did not open",
                 mSettingHelper.get().checkMenuExists("Location access"));
+        Log.i(LOG_TAG, "Act: Open Location Access sub-setting");
         mSettingLocationHelper.get().locationAccess();
+        Log.i(LOG_TAG, "Act: Get Location ON status");
         boolean defaultState = mSettingLocationHelper.get().isLocationOn();
+        Log.i(LOG_TAG, "Act: Toggle Location status to ON");
         mSettingLocationHelper.get().toggleLocation(!defaultState);
         mSettingLocationHelper.get().toggleLocation(defaultState);
+        Log.i(LOG_TAG, "Act: Go back to Settings screen");
         mSettingHelper.get().pressSettingsBackNavIcon();
     }
 
     @Test
     public void testAppLevelPermission() {
+        Log.i(LOG_TAG, "Act: Open App Level permission");
         mSettingLocationHelper.get().openAppLevelPermissions();
+        Log.i(LOG_TAG, "Assert: App level permission is displayed");
         assertTrue(
                 "App level permission is not displayed",
                 mSettingHelper.get().checkMenuExists("Allowed all the time"));
+        Log.i(LOG_TAG, "Assert: Recently accessed app is displaying");
         assertTrue(
                 "Recently accessed app is not displaying",
-                mSettingHelper.get().checkMenuExists("Maps"));
+                mSettingHelper.get().checkMenuExists(APP_NAME));
     }
 
     @Test
     public void testMapsLocationPermissionPage() {
+        Log.i(LOG_TAG, "Act: Open Maps Location permission");
         mSettingLocationHelper.get().openMapsInRecentlyAccessed();
+        Log.i(LOG_TAG, "Assert: Maps location permission page in recently accessed is displayed");
         assertTrue(
                 "Maps location permission page in recently accessed is not displayed",
                 mSettingHelper.get().checkMenuExists("Location permission"));
@@ -74,12 +88,15 @@ public class LocationAccessTest {
 
     @Test
     public void testViewAll() {
+        Log.i(LOG_TAG, "Act: Open View All apps");
         mSettingLocationHelper.get().clickViewAll();
+        Log.i(LOG_TAG, "Assert: Recently accessed view all page is launched");
         assertTrue(
                 "Recently accessed view all page is not launched",
                 mSettingHelper.get().checkMenuExists("Recently accessed"));
+        Log.i(LOG_TAG, "Assert: Recently accessed app page is displayed");
         assertTrue(
                 "Recently accessed app is not displaying",
-                mSettingHelper.get().checkMenuExists("Maps"));
+                mSettingHelper.get().checkMenuExists(APP_NAME));
     }
 }
diff --git a/tests/automotive/functional/locationstatusbar/src/android/platform/tests/SettingsLocationTest.java b/tests/automotive/functional/locationstatusbar/src/android/platform/tests/SettingsLocationTest.java
index b74ffda78..c3851cd1e 100644
--- a/tests/automotive/functional/locationstatusbar/src/android/platform/tests/SettingsLocationTest.java
+++ b/tests/automotive/functional/locationstatusbar/src/android/platform/tests/SettingsLocationTest.java
@@ -27,6 +27,7 @@ import android.platform.test.flag.junit.SetFlagsRule;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -41,6 +42,7 @@ public class SettingsLocationTest {
 
     private HelperAccessor<IAutoSettingsLocationHelper> mSettingLocationHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = SettingsLocationTest.class.getSimpleName();
 
     @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
 
@@ -51,7 +53,9 @@ public class SettingsLocationTest {
 
     @Before
     public void setup() {
+        Log.i(LOG_TAG, "Act: Open Location Setting");
         mSettingHelper.get().openSetting(SettingsConstants.LOCATION_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Location setting is open");
         assertTrue(
                 "Location settings did not open", mSettingHelper.get().checkMenuExists("Location"));
     }
@@ -61,15 +65,21 @@ public class SettingsLocationTest {
     @RequiresFlagsEnabled(
             com.android.car.settings.Flags.FLAG_REQUIRED_INFOTAINMENT_APPS_SETTINGS_PAGE)
     public void testToVerifyToggleLocation() {
+        Log.i(LOG_TAG, "Act: Open Location access");
         mSettingLocationHelper.get().locationAccess();
+        Log.i(LOG_TAG, "Act: Get location ON status");
         boolean defaultState = mSettingLocationHelper.get().isLocationOn();
         String widgetShownMessage = "Location widget is displayed ";
         String widgetNotShownMessage = "Location widget is not displayed ";
+        Log.i(LOG_TAG, "Act: Toggle Off location status");
         mSettingLocationHelper.get().toggleLocation(!defaultState);
+        Log.i(LOG_TAG, "Assert: Location status is OFF");
         assertTrue(
                 defaultState ? widgetShownMessage : widgetNotShownMessage,
                 mSettingLocationHelper.get().hasMapsWidget() != defaultState);
+        Log.i(LOG_TAG, "Act: Toggle On location status");
         mSettingLocationHelper.get().toggleLocation(defaultState);
+        Log.i(LOG_TAG, "Assert: Location status is ON");
         assertTrue(
                 defaultState ? widgetShownMessage : widgetNotShownMessage,
                 mSettingLocationHelper.get().hasMapsWidget() == defaultState);
@@ -77,6 +87,7 @@ public class SettingsLocationTest {
 
     @Test
     public void testToCheckRecentlyAccessedOption() {
+        Log.i(LOG_TAG, "Assert: Recently accessed option is displayed");
         assertTrue(
                 "Recently accessed option is not displayed ",
                 mSettingLocationHelper.get().hasRecentlyAccessed());
diff --git a/tests/automotive/functional/lockscreen/src/android/platform/tests/LockScreenTest.java b/tests/automotive/functional/lockscreen/src/android/platform/tests/LockScreenTest.java
index 689b67893..4a705e736 100644
--- a/tests/automotive/functional/lockscreen/src/android/platform/tests/LockScreenTest.java
+++ b/tests/automotive/functional/lockscreen/src/android/platform/tests/LockScreenTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoSecuritySettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
 import android.provider.Settings;
+import android.util.Log;
 
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.runner.AndroidJUnit4;
@@ -46,6 +47,7 @@ public class LockScreenTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private final Context mContext;
     private int mShareProtection;
+    private static final String LOG_TAG = LockScreenTest.class.getSimpleName();
 
     public LockScreenTest() throws Exception {
         mSecuritySettingsHelper = new HelperAccessor<>(IAutoSecuritySettingsHelper.class);
@@ -56,6 +58,7 @@ public class LockScreenTest {
 
     @Before
     public void openSecuritySettingFacet() {
+        Log.i(LOG_TAG, "Act: Disable screen share protection for apps and notifications");
         mShareProtection =
                 Settings.Global.getInt(
                         mContext.getContentResolver(),
@@ -65,7 +68,9 @@ public class LockScreenTest {
                 mContext.getContentResolver(),
                 Settings.Global.DISABLE_SCREEN_SHARE_PROTECTIONS_FOR_APPS_AND_NOTIFICATIONS,
                 0);
+        Log.i(LOG_TAG, "Act: Open Security Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SECURITY_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Security Setting is open");
         assertTrue(
                 "Security settings did not open",
                 mSettingHelper.get().checkMenuExists("Profile lock"));
@@ -73,7 +78,9 @@ public class LockScreenTest {
 
     @After
     public void goBackToSettingsScreen() {
+        Log.i(LOG_TAG, "Act: Go back to Settings screen");
         mSettingHelper.get().goBackToSettingsScreen();
+        Log.i(LOG_TAG, "Act: Disable screen share protection for apps and notifications");
         Settings.Global.putInt(
                 mContext.getContentResolver(),
                 Settings.Global.DISABLE_SCREEN_SHARE_PROTECTIONS_FOR_APPS_AND_NOTIFICATIONS,
@@ -82,11 +89,17 @@ public class LockScreenTest {
 
     @Test
     public void testLockUnlockScreenByPassword() {
+        Log.i(LOG_TAG, "Act: Lock Device Screen using password");
         mLockScreenHelper.get().lockScreenBy(LockType.PASSWORD, PASSWORD);
+        Log.i(LOG_TAG, "Act: Unlock Device Screen using password");
         mLockScreenHelper.get().unlockScreenBy(LockType.PASSWORD, PASSWORD);
+        Log.i(LOG_TAG, "Assert: Device is locked");
         assertTrue("Device is not locked", mSecuritySettingsHelper.get().isDeviceLocked());
+        Log.i(LOG_TAG, "Act: Unlock Device Screen using password");
         mSecuritySettingsHelper.get().unlockByPassword(PASSWORD);
+        Log.i(LOG_TAG, "Act: Remove Device Screen Lock");
         mSecuritySettingsHelper.get().removeLock();
+        Log.i(LOG_TAG, "Assert: Device Screen Lock is removed");
         assertTrue(
                 "Password has not been removed", !mSecuritySettingsHelper.get().isDeviceLocked());
     }
diff --git a/tests/automotive/functional/mediacenter/src/android/platform/tests/BluetoothAudioTest.java b/tests/automotive/functional/mediacenter/src/android/platform/tests/BluetoothAudioTest.java
index 906bf2fa2..6ca3245a2 100644
--- a/tests/automotive/functional/mediacenter/src/android/platform/tests/BluetoothAudioTest.java
+++ b/tests/automotive/functional/mediacenter/src/android/platform/tests/BluetoothAudioTest.java
@@ -23,6 +23,7 @@ import static org.junit.Assert.assertNotEquals;
 
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoMediaHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -35,32 +36,43 @@ import org.junit.runner.RunWith;
 public class BluetoothAudioTest {
     private HelperAccessor<IAutoMediaHelper> mBluetoothAudioHelper;
 
+    private static final String LOG_TAG = BluetoothAudioTest.class.getSimpleName();
+
     public BluetoothAudioTest() throws Exception {
         mBluetoothAudioHelper = new HelperAccessor<>(IAutoMediaHelper.class);
     }
 
     @Before
     public void openMediaFacet() {
+        Log.i(LOG_TAG, "Act: Open Bluetooth Audio App");
         mBluetoothAudioHelper.get().open();
     }
 
     @After
     public void goBackToMediaFacet() {
+        Log.i(LOG_TAG, "Act: Go back to Home screen");
         mBluetoothAudioHelper.get().goBackToMediaHomePage();
     }
 
     @Test
     public void testPlayPauseMedia() {
+        Log.i(LOG_TAG, "Act: Pause Media Song");
         mBluetoothAudioHelper.get().pauseMedia();
+        Log.i(LOG_TAG, "Assert: Media Song is paused");
         assertFalse("Song not paused.", mBluetoothAudioHelper.get().isPlaying());
+        Log.i(LOG_TAG, "Act: Play Media Song");
         mBluetoothAudioHelper.get().playMedia();
+        Log.i(LOG_TAG, "Assert: Media Song is Playing");
         assertTrue("Song not playing.", mBluetoothAudioHelper.get().isPlaying());
     }
 
     @Test
     public void testNextTrack() {
+        Log.i(LOG_TAG, "Act: Get Media Song track name");
         String currentSong = mBluetoothAudioHelper.get().getMediaTrackName();
+        Log.i(LOG_TAG, "Act: Click on Next track");
         mBluetoothAudioHelper.get().clickNextTrack();
+        Log.i(LOG_TAG, "Assert: Media Song is changed");
         assertNotEquals(
                 "Song playing has not been changed",
                 currentSong,
diff --git a/tests/automotive/functional/mediacenter/src/android/platform/tests/MediaTestAppTest.java b/tests/automotive/functional/mediacenter/src/android/platform/tests/MediaTestAppTest.java
index 0270a0b3d..5a55700fc 100644
--- a/tests/automotive/functional/mediacenter/src/android/platform/tests/MediaTestAppTest.java
+++ b/tests/automotive/functional/mediacenter/src/android/platform/tests/MediaTestAppTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoHomeHelper;
 import android.platform.helpers.IAutoMediaHelper;
 import android.platform.helpers.IAutoTestMediaAppHelper;
 import android.platform.test.option.StringOption;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -37,13 +38,14 @@ import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class MediaTestAppTest {
+
     private static final String MEDIA_APP = "media-app";
     private static final String TEST_MEDIA_APP = "Test Media App";
     private static final String DEFAULT_SONG_NAME = "A normal 1H song";
+    private static final String LOG_TAG = MediaTestAppTest.class.getSimpleName();
 
     @ClassRule
-    public static StringOption mMediaTestApp =
-            new StringOption(MEDIA_APP).setRequired(false);
+    public static StringOption mMediaTestApp = new StringOption(MEDIA_APP).setRequired(false);
 
     public static String mDefaultSongName = new String(DEFAULT_SONG_NAME);
 
@@ -57,46 +59,106 @@ public class MediaTestAppTest {
     @BeforeClass
     public static void setup() {
         // Load songs on Test Media App
+        Log.i(LOG_TAG, "Act: Open Media widget");
         sAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Act: Open Media App Menu Items");
         sMediaCenterHelper.get().openMediaAppMenuItems();
+        Log.i(LOG_TAG, "Act: Get Test Media App");
         String mediaAppName = TEST_MEDIA_APP;
         if (mMediaTestApp != null
-                && mMediaTestApp.get() != null && !mMediaTestApp.get().isEmpty()) {
+                && mMediaTestApp.get() != null
+                && !mMediaTestApp.get().isEmpty()) {
             mediaAppName = mMediaTestApp.get();
         }
+        Log.i(LOG_TAG, "Act: Open Test Media App");
         sMediaCenterHelper.get().openApp(mediaAppName);
+        Log.i(LOG_TAG, "Act: Open Media App settings page");
         sMediaCenterHelper.get().openMediaAppSettingsPage();
+        Log.i(LOG_TAG, "Act: Wait for load Media on Test Media App");
         sTestMediaAppHelper.get().loadMediaInLocalMediaTestApp();
     }
 
     @After
     public void goMinimizeNowPlaying() {
+        Log.i(LOG_TAG, "Act: Minimize playing song");
         sMediaCenterHelper.get().minimizeNowPlaying();
     }
 
     @Test
     public void testPlayPauseMedia() {
+        Log.i(LOG_TAG, "Act: Play media song");
         sMediaCenterHelper.get().playMedia();
+        Log.i(LOG_TAG, "Assert: Media song is playing");
         assertTrue("Song not playing.", sMediaCenterHelper.get().isPlaying());
+        Log.i(LOG_TAG, "Act: Minimize playing song");
         sMediaCenterHelper.get().minimizeNowPlaying();
+        Log.i(LOG_TAG, "Act: Select Normal 1H track song");
         sMediaCenterHelper.get().selectMediaTrack(mDefaultSongName);
+        Log.i(LOG_TAG, "Act: Pause media song");
         sMediaCenterHelper.get().pauseMedia();
+        Log.i(LOG_TAG, "Assert: Media song is paused");
         assertFalse("Song not paused.", sMediaCenterHelper.get().isPlaying());
     }
 
     @Test
     public void testNextPreviousTrack() {
+        Log.i(LOG_TAG, "Act: Get media track name");
         String currentSong = sMediaCenterHelper.get().getMediaTrackName();
+        Log.i(LOG_TAG, "Act: Click on next track");
         sMediaCenterHelper.get().clickNextTrack();
+        Log.i(LOG_TAG, "Act: Media Song playing has changed");
         assertNotEquals(
                 "Song playing has not been changed",
                 currentSong,
                 sMediaCenterHelper.get().getMediaTrackName());
+        Log.i(LOG_TAG, "Act: Get media track name");
         currentSong = sMediaCenterHelper.get().getMediaTrackName();
+        Log.i(LOG_TAG, "Act: Click on previous track");
         sMediaCenterHelper.get().clickPreviousTrack();
+        Log.i(LOG_TAG, "Act: Media Song playing has changed");
         assertNotEquals(
                 "Song playing has not been changed",
                 currentSong,
                 sMediaCenterHelper.get().getMediaTrackName());
     }
+
+    @Test
+    public void testMediaPlayStateAfterGoingToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Play media song");
+        sMediaCenterHelper.get().playMedia();
+        Log.i(LOG_TAG, "Act: Select Normal 1H track song");
+        sMediaCenterHelper.get().selectMediaTrack(mDefaultSongName);
+        Log.i(LOG_TAG, "Assert: Media song is playing");
+        assertTrue("Song is not playing", sMediaCenterHelper.get().isPlaying());
+        Log.i(LOG_TAG, "Act: Exit Media App");
+        sMediaCenterHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Media Widget is displayed");
+        assertTrue(sAutoHomeHelper.get().hasMediaWidget());
+        Log.i(LOG_TAG, "Assert: Media song is playing");
+        assertTrue("Song is not playing", sMediaCenterHelper.get().isPlaying());
+        Log.i(LOG_TAG, "Act: Open Media widget");
+        sAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Assert: Media song is playing");
+        assertTrue("Song is not playing", sMediaCenterHelper.get().isPlaying());
+    }
+
+    @Test
+    public void testMediaPauseStateAfterGoingToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Play media song");
+        sMediaCenterHelper.get().playMedia();
+        Log.i(LOG_TAG, "Act: Pause media song");
+        sMediaCenterHelper.get().pauseMedia();
+        Log.i(LOG_TAG, "Assert: Media song is playing");
+        assertTrue("Song is playing, it should be paused", sMediaCenterHelper.get().isPaused());
+        Log.i(LOG_TAG, "Act: Exit Media App");
+        sMediaCenterHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Media Widget is displayed");
+        assertTrue(sAutoHomeHelper.get().hasMediaWidget());
+        Log.i(LOG_TAG, "Assert: Media song is playing");
+        assertTrue("Song is playing, it should be paused", sMediaCenterHelper.get().isPaused());
+        Log.i(LOG_TAG, "Act: Open Media widget");
+        sAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Assert: Media song is paused");
+        assertTrue("Song is playing, it should be paused", sMediaCenterHelper.get().isPaused());
+    }
 }
diff --git a/tests/automotive/functional/mediacenter/src/android/platform/tests/NoUserLoggedInTest.java b/tests/automotive/functional/mediacenter/src/android/platform/tests/NoUserLoggedInTest.java
index 0378535ec..41f9f539e 100644
--- a/tests/automotive/functional/mediacenter/src/android/platform/tests/NoUserLoggedInTest.java
+++ b/tests/automotive/functional/mediacenter/src/android/platform/tests/NoUserLoggedInTest.java
@@ -22,6 +22,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoHomeHelper;
 import android.platform.helpers.IAutoMediaHelper;
 import android.platform.test.option.StringOption;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -38,6 +39,8 @@ public class NoUserLoggedInTest {
     private HelperAccessor<IAutoHomeHelper> mAutoHomeHelper;
     private HelperAccessor<IAutoMediaHelper> mMediaCenterHelper;
 
+    private static final String LOG_TAG = NoUserLoggedInTest.class.getSimpleName();
+
     public NoUserLoggedInTest() throws Exception {
         mMediaCenterHelper = new HelperAccessor<>(IAutoMediaHelper.class);
         mAutoHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
@@ -46,14 +49,18 @@ public class NoUserLoggedInTest {
 
     @Test
     public void testNoUserLogInMessage() {
+        Log.i(LOG_TAG, "Act: Open Media widget");
         mAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Act: Open Media App Menu Item");
         mMediaCenterHelper.get().openMediaAppMenuItems();
+        Log.i(LOG_TAG, "Act: Open Youtube Music App");
         mMediaCenterHelper.get().openApp(mMediaApp.get());
-
+        Log.i(LOG_TAG, "Assert: Youtube Music App is a Media App");
         assertTrue("Not a media app.",
                 mMediaCenterHelper.get().getMediaAppTitle().equals(mMediaApp.get()));
-
+        Log.i(LOG_TAG, "Act: Get Media app error message");
         String noUserLoginMsg = mMediaCenterHelper.get().getMediaAppUserNotLoggedInErrorMessage();
+        Log.i(LOG_TAG, "Assert: Sign In error message is correct");
         assertTrue("Incorrect Sign in error message.",
                 noUserLoginMsg.equals("Please sign in to YouTube Music."));
     }
diff --git a/tests/automotive/functional/mediacenter/src/android/platform/tests/OpenAppFromMediaCenterTest.java b/tests/automotive/functional/mediacenter/src/android/platform/tests/OpenAppFromMediaCenterTest.java
index 873dec959..bef88818b 100644
--- a/tests/automotive/functional/mediacenter/src/android/platform/tests/OpenAppFromMediaCenterTest.java
+++ b/tests/automotive/functional/mediacenter/src/android/platform/tests/OpenAppFromMediaCenterTest.java
@@ -23,11 +23,16 @@ import android.platform.helpers.IAutoAppGridHelper;
 import android.platform.helpers.IAutoHomeHelper;
 import android.platform.helpers.IAutoMediaHelper;
 import android.platform.test.option.StringOption;
+import android.platform.test.rules.ConditionalIgnore;
+import android.platform.test.rules.ConditionalIgnoreRule;
+import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
 import org.junit.After;
 import org.junit.ClassRule;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -36,11 +41,13 @@ import java.util.List;
 
 @RunWith(AndroidJUnit4.class)
 public class OpenAppFromMediaCenterTest {
+    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
     private static final String BLUETOOTH_APP = "bluetooth-app";
     private static final String MEDIA_APPS = "media-apps";
 
     private static final String DEFAULT_MEDIA_APP = "Bluetooth Audio";
     private static final String DEFAULT_LIST_OF_MEDIA_APPS = "Bluetooth Audio, Radio";
+    private static final String LOG_TAG = OpenAppFromMediaCenterTest.class.getSimpleName();
 
     @ClassRule
     public static StringOption mMediaDefaultApp =
@@ -60,31 +67,60 @@ public class OpenAppFromMediaCenterTest {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Exit Media widget");
         mMediaCenterHelper.get().exit();
     }
 
     @Test
     public void testOpenMediaAppFromMediaWidget() {
+        Log.i(LOG_TAG, "Act: Open Media widget");
         mAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Assert: Radio App is launched");
         assertTrue("Radio app not launched", mMediaCenterHelper.get().isRadioAppLaunched());
     }
 
     @Test
     public void testOpenMediaAppFromMediaAppAppgrid() {
-        // Use preinstalled "Bluetooth Audio" app
+        Log.i(LOG_TAG, "Act: Open Media widget");
+        mAutoHomeHelper.get().openMediaWidget();
+        Log.i(LOG_TAG, "Assert: Radio App is launched");
+        assertTrue("Radio app not launched", mMediaCenterHelper.get().isRadioAppLaunched());
+        Log.i(LOG_TAG, "Act: Open Media App Menu Items");
+        mMediaCenterHelper.get().openMediaAppMenuItems();
+        Log.i(LOG_TAG, "Act: Open Bluetooth Audio App");
+        mMediaCenterHelper.get().openApp(DEFAULT_MEDIA_APP);
+        Log.i(LOG_TAG, "Assert: Bluetooth Audio App is open");
+        assertTrue(
+                "Not a media app",
+                mMediaCenterHelper.get().getMediaAppTitle().equals(getDefaultMediaAppName()));
+    }
+
+    @Test
+    public void testOpenMediaAppFromAppgrid() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAutoAppGridHelper.get().open();
-        assertTrue("AppGrid is not open", mAutoAppGridHelper.get().isAppInForeground());
+        Log.i(LOG_TAG, "Assert: App Grid is open");
+        assertTrue("App Grid is not open", mAutoAppGridHelper.get().isAppInForeground());
+        Log.i(LOG_TAG, "Act: Open Bluetooth Audio App");
         mMediaCenterHelper.get().openApp(DEFAULT_MEDIA_APP);
-        assertTrue("Not a media app",
+        Log.i(LOG_TAG, "Assert: Bluetooth Audio App is open");
+        assertTrue(
+                "Not a media app",
                 mMediaCenterHelper.get().getMediaAppTitle().equals(getDefaultMediaAppName()));
     }
 
     @Test
+    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testMediaAppPresentInMediaGrid() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAutoAppGridHelper.get().open();
-        assertTrue("AppGrid is not open", mAutoAppGridHelper.get().isAppInForeground());
+        Log.i(LOG_TAG, "Assert: App Grid is open");
+        assertTrue("App Grid is not open", mAutoAppGridHelper.get().isAppInForeground());
+        Log.i(LOG_TAG, "Act: Open Bluetooth Audio App");
         mMediaCenterHelper.get().openApp(DEFAULT_MEDIA_APP);
+        Log.i(LOG_TAG, "Act: Open Media App Menu Items");
         mMediaCenterHelper.get().openMediaAppMenuItems();
+        Log.i(LOG_TAG, "Assert: Correct Media App in App Grid");
         assertTrue("Incorrect Media apps in Grid",
                 mMediaCenterHelper.get().areMediaAppsPresent(getExpectedMediaAppNames()));
     }
@@ -93,6 +129,7 @@ public class OpenAppFromMediaCenterTest {
         String mediaAppName = DEFAULT_MEDIA_APP;
         if (mMediaDefaultApp != null
                 && mMediaDefaultApp.get() != null && !mMediaDefaultApp.get().isEmpty()) {
+            Log.i(LOG_TAG, "Act: Get Default Media App");
             mediaAppName = mMediaDefaultApp.get();
         }
         return mediaAppName;
@@ -104,6 +141,7 @@ public class OpenAppFromMediaCenterTest {
             // Get list of media apps from String options if passed.
             mediaAppNames = mMediaApps.get();
         }
+        Log.i(LOG_TAG, "Act: Get list of Default Media Apps");
         String[] mediaAppNamesList = mediaAppNames.trim().split("\\s*,\\s*");
         return Arrays.asList(mediaAppNamesList);
     }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserQuickSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserQuickSettings.java
index 23a6c0f67..81900fd01 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserQuickSettings.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserQuickSettings.java
@@ -28,6 +28,7 @@ import android.platform.helpers.SettingsConstants;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -49,6 +50,8 @@ public class AddUserQuickSettings {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = AddUserQuickSettings.class.getSimpleName();
+
     public AddUserQuickSettings() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -56,6 +59,7 @@ public class AddUserQuickSettings {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to setting");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
@@ -63,18 +67,25 @@ public class AddUserQuickSettings {
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testAddNonAdminUser() throws Exception {
         // create new user quick settings
+        Log.i(LOG_TAG, "Act: Create new user");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         mUsersHelper.get().addUserQuickSettings(initialUser.name);
         // switched to new user
+        Log.i(LOG_TAG, "Act: Switch to new user");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch from new user to initial user
+        Log.i(LOG_TAG, "Act: Switch back to initial user");
         mUsersHelper.get().switchUser(newUser.name, initialUser.name);
         // verify new user is seen in list of users
+        Log.i(LOG_TAG, "Assert: New user is listed in users list");
         assertTrue(mMultiUserHelper.getUserByName(newUser.name) != null);
         // Verify new user is non-admin Profile
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: New user does not have Admin Access");
         assertFalse("New user has Admin Access", mUsersHelper.get().isNewUserAnAdmin(newUser.name));
         // remove new user
+        Log.i(LOG_TAG, "Act: Remove created new user");
         mMultiUserHelper.removeUser(newUser);
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
index 9921894d3..dbe444e9c 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
@@ -28,6 +28,7 @@ import android.platform.helpers.SettingsConstants;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -48,6 +49,7 @@ public class AddUserSettings {
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = AddUserSettings.class.getSimpleName();
 
     public AddUserSettings() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
@@ -61,6 +63,7 @@ public class AddUserSettings {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
@@ -68,18 +71,26 @@ public class AddUserSettings {
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testAddNonAdminUser() throws Exception {
         // create new user
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        Log.i(LOG_TAG, "Act: Create a non-admin user");
         mUsersHelper.get().addUser();
         // switched to new user
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch from new user to initial user
+        Log.i(LOG_TAG, "Act: Switch to new user");
         mUsersHelper.get().switchUser(newUser.name, initialUser.name);
         // verify new user is seen in list of users
+        Log.i(LOG_TAG, "Assert: Newly created user in user ist");
         assertTrue(mMultiUserHelper.getUserByName(newUser.name) != null);
         // Verify new user is non-Admin
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Newly  created user does not have admin access");
         assertFalse("New user has Admin Access", mUsersHelper.get().isNewUserAnAdmin(newUser.name));
         // remove new user
+        Log.i(LOG_TAG, "Act: New user is deleted");
         mMultiUserHelper.removeUser(newUser);
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteAdminUser.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteAdminUser.java
index 04ab96d24..a6e448819 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteAdminUser.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteAdminUser.java
@@ -28,6 +28,7 @@ import android.platform.scenario.multiuser.MultiUserConstants;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -49,6 +50,7 @@ public class DeleteAdminUser {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private int mTargetUserId;
+    private static final String LOG_TAG = DeleteAdminUser.class.getSimpleName();
 
     public DeleteAdminUser() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
@@ -57,6 +59,7 @@ public class DeleteAdminUser {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
@@ -64,14 +67,20 @@ public class DeleteAdminUser {
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testRemoveUser() throws Exception {
         // create new user
+        Log.i(LOG_TAG, "Act: Create a non admin user");
         mTargetUserId = mMultiUserHelper.createUser(userName, false);
         SystemClock.sleep(WAIT_TIME);
         // make the new user admin and delete new user
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Mark newly created user as admin");
         mUsersHelper.get().makeUserAdmin(userName);
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Delete new user");
         mUsersHelper.get().deleteUser(userName);
         // verify new user was deleted
+        Log.i(LOG_TAG, "Assert: New user is deleted");
         assertFalse(mUsersHelper.get().isUserPresent(userName));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteCurrentNonAdminUser.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteCurrentNonAdminUser.java
index e3c7d9b5e..8c6d0b1e0 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteCurrentNonAdminUser.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteCurrentNonAdminUser.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -46,6 +47,7 @@ public class DeleteCurrentNonAdminUser {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private int mTargetUserId;
+    private static final String LOG_TAG = DeleteCurrentNonAdminUser.class.getSimpleName();
 
     public DeleteCurrentNonAdminUser() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
@@ -59,21 +61,29 @@ public class DeleteCurrentNonAdminUser {
 
     @Test
     public void testRemoveUserSelf() throws Exception {
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // add new user
+        Log.i(LOG_TAG, "Act: Create a non admin user");
         mTargetUserId = mMultiUserHelper.createUser(userName, false);
         SystemClock.sleep(WAIT_TIME);
         // switch to new user
+        Log.i(LOG_TAG, "Act: Switch to new user");
         mMultiUserHelper.switchAndWaitForStable(
             mTargetUserId, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
+        Log.i(LOG_TAG, "Act: Get new userinfo");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // user deleted self
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Delete current user");
         mUsersHelper.get().deleteCurrentUser();
         // goes to guest user, switch back to initial user
+        Log.i(LOG_TAG, "Act: Switch back to initial user");
         mMultiUserHelper.switchAndWaitForStable(
             initialUser.id, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
         // verify that user is deleted
+        Log.i(LOG_TAG, "Assert: New user is deleted");
         assertTrue(mMultiUserHelper.getUserByName(newUser.name) == null);
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
index bb533b653..043f845a6 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
@@ -23,6 +23,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -41,6 +42,8 @@ public class DeleteGuestNotAllowed {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = DeleteGuestNotAllowed.class.getSimpleName();
+
     public DeleteGuestNotAllowed() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -48,17 +51,20 @@ public class DeleteGuestNotAllowed {
 
     @Before
     public void openAccountsFacet() {
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
     }
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testDeleteGuestNotAllowed() throws Exception {
         // verify that guest user cannot be seen and deleted from list of profiles
+        Log.i(LOG_TAG, "Assert: Guest user cannot be seen and deleted from list of profiles");
         assertFalse(mUsersHelper.get().isUserPresent(guestUser));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
index b85168a8c..667db7f97 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
@@ -49,6 +49,8 @@ public class DeleteGuestSelfNotAllowed {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = DeleteGuestSelfNotAllowed.class.getSimpleName();
+
     public DeleteGuestSelfNotAllowed() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -61,15 +63,21 @@ public class DeleteGuestSelfNotAllowed {
 
     @Test
     public void testDeleteGuestNotAllowed() throws Exception {
+        Log.i(LOG_TAG, "Act: Get previous userinfo");
         UserInfo previousUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to Guest and verify the user switch
+        Log.i(LOG_TAG, "Act: Switch to guest user");
         mUsersHelper.get().switchUsingUserIcon(GUEST);
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        Log.i(LOG_TAG, "Assert: Current userinfo matches Guest userinfo ");
         assertTrue(currentUser.name.equals(guestUser));
         boolean IsDeleteAllowed = true;
         // try to delete self - runtime exception encountered
         try {
+            Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
             mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+            Log.i(LOG_TAG, "Act: Delete current user");
             mUsersHelper.get().deleteCurrentUser();
         } catch (RuntimeException err) {
             Log.v(
@@ -77,9 +85,12 @@ public class DeleteGuestSelfNotAllowed {
                 String.format("Error caught while trying to delete Guest(Self) : %s ", err));
             IsDeleteAllowed = false;
         }
+        Log.i(LOG_TAG, "Assert: Delete user is not allowed");
         assertFalse(IsDeleteAllowed);
         // switch to initial user before terminating the test
+        Log.i(LOG_TAG, "Act: Switch back to initial user");
         mUsersHelper.get().switchUsingUserIcon(DRIVER);
+        Log.i(LOG_TAG, "Assert: Current userinfo matches initial userinfo");
         assertTrue(mMultiUserHelper.getCurrentForegroundUserInfo().name.equals(previousUser.name));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteLastAdminUser.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteLastAdminUser.java
index 73b3581e3..c7cd3cdf8 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteLastAdminUser.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteLastAdminUser.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -44,6 +45,7 @@ public class DeleteLastAdminUser {
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = DeleteLastAdminUser.class.getSimpleName();
 
     public DeleteLastAdminUser() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
@@ -52,22 +54,28 @@ public class DeleteLastAdminUser {
 
     @Before
     public void openAccountsFacet() {
+        Log.i(LOG_TAG, "Act: Open  Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
     }
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to Settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testRemoveUserSelf() throws Exception {
         // add new user
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // user deleted self
+        Log.i(LOG_TAG, "Act: Delete current user");
         mUsersHelper.get().deleteCurrentUser();
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // verify that user is deleted
+        Log.i(LOG_TAG, "Assert: user is deleted");
         assertTrue((initialUser.id != newUser.id) && (initialUser.name.equals(newUser.name)));
     }
 
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteNonAdminUser.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteNonAdminUser.java
index 299188700..312bdc796 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteNonAdminUser.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteNonAdminUser.java
@@ -28,6 +28,7 @@ import android.platform.scenario.multiuser.MultiUserConstants;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -50,6 +51,8 @@ public class DeleteNonAdminUser {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private int mTargetUserId;
 
+    private static final String LOG_TAG = DeleteNonAdminUser.class.getSimpleName();
+
     public DeleteNonAdminUser() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -57,6 +60,7 @@ public class DeleteNonAdminUser {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
@@ -64,12 +68,16 @@ public class DeleteNonAdminUser {
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testRemoveUser() throws Exception {
         // create new user
+        Log.i(LOG_TAG, "Act: Create a non-admin user");
         mTargetUserId = mMultiUserHelper.createUser(userName, false);
         SystemClock.sleep(WAIT_TIME);
         // make the new user admin and delete new user
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Deete current user");
         mUsersHelper.get().deleteUser(userName);
         // verify new user was deleted
+        Log.i(LOG_TAG, "Assert: New user is deleted");
         assertFalse(mUsersHelper.get().isUserPresent(userName));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/EditAdminName.java b/tests/automotive/functional/multiuser/src/android/platform/tests/EditAdminName.java
index 839f32ce9..9406e9033 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/EditAdminName.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/EditAdminName.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -41,6 +42,8 @@ public class EditAdminName {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = EditAdminName.class.getSimpleName();
+
     public EditAdminName() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -48,21 +51,28 @@ public class EditAdminName {
 
     @Before
     public void getUserNameFromSettings() {
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         INITIAL_USERNAME = initialUser.name;
     }
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Edit initial user's name");
         mUsersHelper.get().editUserName(INITIAL_USERNAME);
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testEditAdminName() {
+        Log.i(LOG_TAG, "Act: Open Profile & Accounts setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Act: Edit initial user's name");
         mUsersHelper.get().editUserName(EDIT_USERNAME);
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        Log.i(LOG_TAG, "Assert: Current username is changed ");
         assertTrue("Username is not changed", EDIT_USERNAME.equals(newUser.name));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/GuestUserSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/GuestUserSettings.java
new file mode 100644
index 000000000..2dd3e516f
--- /dev/null
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/GuestUserSettings.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.tests;
+
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+
+import android.platform.helpers.AutomotiveConfigConstants;
+import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoSettingHelper;
+import android.platform.helpers.IAutoUISettingsHelper;
+import android.platform.helpers.IAutoUserHelper;
+import android.platform.helpers.SettingsConstants;
+import android.util.Log;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class GuestUserSettings {
+
+    private static final String GUEST = AutomotiveConfigConstants.HOME_GUEST_BUTTON;
+    private static final String DRIVER = AutomotiveConfigConstants.HOME_DRIVER_BUTTON;
+    private static final String LOG_TAG = GuestUserSettings.class.getSimpleName();
+    private HelperAccessor<IAutoUserHelper> mUsersHelper;
+    private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
+
+    public GuestUserSettings() {
+        mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
+        mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
+        mSettingsUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
+    }
+
+    @Before
+    public void switchToGuestUser() {
+        mUsersHelper.get().switchUsingUserIcon(GUEST);
+    }
+
+    @After
+    public void switchToDriver() {
+        mUsersHelper.get().switchUsingUserIcon(DRIVER);
+    }
+
+    @Test
+    public void testSecuritySettingsNotDisplayed() {
+        Log.i(LOG_TAG, "Act: Open settings");
+        mSettingHelper.get().openFullSettings();
+        Log.i(LOG_TAG, "Assert: Security settings menu is not displayed");
+        assertFalse(
+                "Security settings is displayed",
+                mSettingsUIHelper
+                        .get()
+                        .hasSettingsMenu(AutomotiveConfigConstants.SECURITY_SETTINGS_TITLE));
+    }
+
+    @Test
+    public void testAccountForGuestNotDisplayed() {
+        Log.i(LOG_TAG, "Act: Open Profile & Account settings");
+        mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Rename option is displayed");
+        assertTrue(
+                "Rename option is not displayed",
+                mSettingsUIHelper
+                        .get()
+                        .hasUIElement(AutomotiveConfigConstants.USER_SETTINGS_RENAME));
+        Log.i(LOG_TAG, "Assert: Adda a profile option is displayed");
+        assertTrue(
+                "Add a profile option is not displayed",
+                mSettingsUIHelper
+                        .get()
+                        .hasUIElement(AutomotiveConfigConstants.USER_SETTINGS_ADD_PROFILE));
+        Log.i(LOG_TAG, "Assert: Accounts for Geust option is not displayed");
+        assertFalse(
+                "Accounts for Guest is displayed",
+                mSettingHelper.get().checkMenuExists("Accounts for Guest"));
+    }
+}
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/NonAdminUserSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/NonAdminUserSettings.java
new file mode 100644
index 000000000..3d4f1bcff
--- /dev/null
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/NonAdminUserSettings.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.tests;
+
+import static junit.framework.Assert.assertFalse;
+
+import android.content.pm.UserInfo;
+import android.os.SystemClock;
+import android.platform.helpers.AutomotiveConfigConstants;
+import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoSettingHelper;
+import android.platform.helpers.IAutoUserHelper;
+import android.platform.helpers.MultiUserHelper;
+import android.platform.helpers.SettingsConstants;
+import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class NonAdminUserSettings {
+
+    private static final String USERNAME = MultiUserConstants.SECONDARY_USER_NAME;
+    private static final String DRIVER = AutomotiveConfigConstants.HOME_DRIVER_BUTTON;
+    private static final String LOG_TAG = NonAdminUserSettings.class.getSimpleName();
+    private static final int WAIT_TIME = 10000;
+    private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
+    private int mTargetUserId;
+    private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private HelperAccessor<IAutoUserHelper> mUsersHelper;
+
+    public NonAdminUserSettings() {
+        mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
+        mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
+    }
+
+    @After
+    public void removeNonAdminUser() {
+        UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        mUsersHelper.get().switchUsingUserIcon(DRIVER);
+        mMultiUserHelper.removeUser(newUser);
+    }
+
+    @Test
+    public void testSeeOtherUsersInSettings() throws Exception {
+        Log.i(LOG_TAG, "Act: Create non-admin user");
+        mTargetUserId = mMultiUserHelper.createUser(USERNAME, false);
+        Log.i(LOG_TAG, "Act: Switch to non-admin user and wait until screen is stable");
+        SystemClock.sleep(WAIT_TIME);
+        mMultiUserHelper.switchAndWaitForStable(
+                mTargetUserId, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
+        Log.i(LOG_TAG, "Act: Open Profile & Account settings");
+        mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Not able to see Manage other profiles option");
+        assertFalse(
+                "Non Admin is able to see other users",
+                mSettingHelper.get().checkMenuExists("Manage other profiles"));
+    }
+}
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
index 2b5f63f89..1f608cc05 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -49,6 +50,8 @@ public class SwitchToGuestFromNonAdmin {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private int mTargetUserId;
 
+    private static final String LOG_TAG = SwitchToGuestFromNonAdmin.class.getSimpleName();
+
     public SwitchToGuestFromNonAdmin() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -56,27 +59,37 @@ public class SwitchToGuestFromNonAdmin {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testSwitchToGuest() throws Exception {
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // add new user
+        Log.i(LOG_TAG, "Act: Create a non admin user");
         mTargetUserId = mMultiUserHelper.createUser(userName, false);
         SystemClock.sleep(WAIT_TIME);
         // switch to new user
+        Log.i(LOG_TAG, "Act: Switch to new user");
         mMultiUserHelper.switchAndWaitForStable(
             mTargetUserId, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
+        Log.i(LOG_TAG, "Act: Get new userinfo");
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to guest from new user
+        Log.i(LOG_TAG, "Act: Switch to guest user");
         mUsersHelper.get().switchUsingUserIcon(GUEST);
         // verify the user switch
+        Log.i(LOG_TAG, "Act: Get guest userinfo");
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
+        Log.i(LOG_TAG, "Assert: Current userinfo should match guest userinfo");
         assertTrue(currentUser.name.equals(guestUser));
         // switch to initial user and delete new user before terminating the test
+        Log.i(LOG_TAG, "Act: Switch back to initia user");
         mMultiUserHelper.switchAndWaitForStable(
             initialUser.id, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
+        Log.i(LOG_TAG, "Act: Delete new user");
         mMultiUserHelper.removeUser(newUser);
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
index 8a024bf4e..67aa2652d 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
@@ -25,6 +25,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -46,6 +47,8 @@ public class SwitchUserQuickSettings {
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = SwitchUserQuickSettings.class.getSimpleName();
+
     public SwitchUserQuickSettings() {
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -53,19 +56,26 @@ public class SwitchUserQuickSettings {
 
     @After
     public void goBackToHomeScreen() {
+        Log.i(LOG_TAG, "Act: Go back to settings");
         mSettingHelper.get().goBackToSettingsScreen();
     }
 
     @Test
     public void testSwitchUser() throws Exception {
+        Log.i(LOG_TAG, "Act: Get previous userinfo");
         UserInfo previousUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to Guest
+        Log.i(LOG_TAG, "Act: Get previous userinfo");
         mUsersHelper.get().switchUsingUserIcon(GUEST);
+        Log.i(LOG_TAG, "Act: Get current userinfo");
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // verify the user switch
+        Log.i(LOG_TAG, "Assert: Current userinfo matches guest userinfo");
         assertTrue(currentUser.name.equals(guestUser));
         // switch to initial user before terminating the test
+        Log.i(LOG_TAG, "Act: Switch to initial user");
         mUsersHelper.get().switchUsingUserIcon(DRIVER);
+        Log.i(LOG_TAG, "Assert: Current userinfo matches initial userinfo");
         assertTrue(
             mMultiUserHelper.getCurrentForegroundUserInfo().name.equals(previousUser.name));
     }
diff --git a/tests/automotive/functional/navigationbar/src/android/platform/tests/BrightnessPaletteTest.java b/tests/automotive/functional/navigationbar/src/android/platform/tests/BrightnessPaletteTest.java
index 661fc5992..a9baba1cd 100644
--- a/tests/automotive/functional/navigationbar/src/android/platform/tests/BrightnessPaletteTest.java
+++ b/tests/automotive/functional/navigationbar/src/android/platform/tests/BrightnessPaletteTest.java
@@ -22,6 +22,7 @@ import static junit.framework.Assert.assertTrue;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoHomeHelper;
 import android.platform.helpers.IAutoStatusBarHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -35,6 +36,7 @@ public class BrightnessPaletteTest {
 
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
+    private static final String LOG_TAG = BrightnessPaletteTest.class.getSimpleName();
 
     public BrightnessPaletteTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
@@ -43,35 +45,38 @@ public class BrightnessPaletteTest {
 
     @Before
     public void openBrightnessPalette() {
+        Log.i(LOG_TAG, "Act: Brightness palette is open");
         mHomeHelper.get().openBrightnessPalette();
     }
 
     @Test
     public void testBrightnessPaletteIsDisplayed() {
+        Log.i(LOG_TAG, "Assert: Brightness palette is open");
         assertTrue(
                 "Brightness palette did not open", mHomeHelper.get().hasDisplayBrightessPalette());
     }
 
     @Test
     public void testAdaptiveBrightnessSettingIsDisplayed() {
+        Log.i(LOG_TAG, "Assert: Adaptive brightness is open");
         assertTrue("Adaptive brightness did not open", mHomeHelper.get().hasAdaptiveBrightness());
     }
 
     @Test
     public void testAdaptiveBrightnessToggleSwitch() {
-        // Default Adaptive brightness is OFF
+        Log.i(LOG_TAG, "Assert: Default Adaptive brightness is OFF");
         assertFalse(
                 "Adaptive brightness toggle switch in ON ",
                 mStatusBarHelper.get().isAdaptiveBrightnessOn());
-        // Turn On Adaptive Brightness Toggle Switch
+        Log.i(LOG_TAG, "Act: Turn On Adaptive Brightness Toggle Switch");
         mStatusBarHelper.get().clickOnAdaptiveBrightnessToggleSwitch();
-        // Verify the Adaptive brightness Turned ON
+        Log.i(LOG_TAG, "Assert: Default Adaptive brightness is ON");
         assertTrue(
                 "Adaptive brightness toggle switch in OFF",
                 mStatusBarHelper.get().isAdaptiveBrightnessOn());
-        // return the Adaptive brightness switch to default state "OFF"
+        Log.i(LOG_TAG, "Act: Turn Off Adaptive Brightness Toggle Switch");
         mStatusBarHelper.get().clickOnAdaptiveBrightnessToggleSwitch();
-        // Verify Default Adaptive brightness state is "OFF"
+        Log.i(LOG_TAG, "Assert: Default Adaptive brightness is OFF");
         assertFalse(
                 "Adaptive brightness toggle switch in ON ",
                 mStatusBarHelper.get().isAdaptiveBrightnessOn());
diff --git a/tests/automotive/functional/navigationbar/src/android/platform/tests/NavigationBarTest.java b/tests/automotive/functional/navigationbar/src/android/platform/tests/NavigationBarTest.java
index eb5702e0e..1e9542c7a 100644
--- a/tests/automotive/functional/navigationbar/src/android/platform/tests/NavigationBarTest.java
+++ b/tests/automotive/functional/navigationbar/src/android/platform/tests/NavigationBarTest.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoFacetBarHelper;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.InstrumentationRegistry;
 import androidx.test.runner.AndroidJUnit4;
@@ -41,6 +42,7 @@ public class NavigationBarTest {
     private Instrumentation mInstrumentation;
     private UiDevice mDevice;
     private HelperAccessor<IAutoFacetBarHelper> mFacetBarHelper;
+    private static final String LOG_TAG = NavigationBarTest.class.getSimpleName();
 
     public NavigationBarTest() {
         mInstrumentation = InstrumentationRegistry.getInstrumentation();
@@ -56,7 +58,9 @@ public class NavigationBarTest {
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testHomeButton() {
+        Log.i(LOG_TAG, "Act: Click on Home button");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.HOME);
+        Log.i(LOG_TAG, "Assert: Home screen is open");
         assertTrue(
                 "Home screen did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.HOME));
@@ -65,7 +69,9 @@ public class NavigationBarTest {
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testDialButton() {
+        Log.i(LOG_TAG, "Act: Click on Phone app Button");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.PHONE);
+        Log.i(LOG_TAG, "Assert: Phone app is open");
         assertTrue(
                 "Phone app did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.PHONE));
@@ -73,7 +79,9 @@ public class NavigationBarTest {
 
     @Test
     public void testAppGridButton() {
+        Log.i(LOG_TAG, "Act: Click on Appgrid Button");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.APP_GRID);
+        Log.i(LOG_TAG, "Assert: App grid is open");
         assertTrue(
                 "App grid did not open",
                 mFacetBarHelper
@@ -83,7 +91,9 @@ public class NavigationBarTest {
 
     @Test
     public void testNotificationButton() {
+        Log.i(LOG_TAG, "Act: Click on Notification Button");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.NOTIFICATION);
+        Log.i(LOG_TAG, "Assert: Notification app is open");
         assertTrue(
                 "Notification did not open.",
                 mFacetBarHelper
@@ -93,7 +103,9 @@ public class NavigationBarTest {
 
     @Test
     public void testHVACButton() {
+        Log.i(LOG_TAG, "Act: Click on Hvac Button");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.HVAC);
+        Log.i(LOG_TAG, "Assert: Hvac is open");
         assertTrue(
                 "Hvac did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.HVAC));
diff --git a/tests/automotive/functional/notifications/src/android/platform/tests/NotificationTest.java b/tests/automotive/functional/notifications/src/android/platform/tests/NotificationTest.java
index 0c8be2128..7c7eac1b8 100644
--- a/tests/automotive/functional/notifications/src/android/platform/tests/NotificationTest.java
+++ b/tests/automotive/functional/notifications/src/android/platform/tests/NotificationTest.java
@@ -22,6 +22,7 @@ import static junit.framework.Assert.assertTrue;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoNotificationHelper;
 import android.platform.helpers.IAutoNotificationMockingHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -37,6 +38,7 @@ public class NotificationTest {
     private HelperAccessor<IAutoNotificationMockingHelper> mNotificationMockingHelper;
 
     private static String NOTIFICATION_TITLE = "AUTO TEST NOTIFICATION";
+    private static final String LOG_TAG = NotificationTest.class.getSimpleName();
 
     public NotificationTest() {
         mNotificationHelper = new HelperAccessor<>(IAutoNotificationHelper.class);
@@ -46,35 +48,49 @@ public class NotificationTest {
 
     @Before
     public void clearAllNotification() {
+        Log.i(LOG_TAG, "Act: Clear all notifications from Notification menu");
         mNotificationMockingHelper.get().clearAllNotification();
     }
 
     @After
     public void exit() {
+        Log.i(LOG_TAG, "Act: Close notification menu");
         mNotificationHelper.get().exit();
     }
 
     @Test
     public void testOpenCloseNotification() {
+        Log.i(LOG_TAG, "Act: Open notification menu");
         mNotificationHelper.get().open();
+        Log.i(LOG_TAG, "Assert: Notification menu is open");
         assertTrue("Notification did not open.", mNotificationHelper.get().isAppInForeground());
+        Log.i(LOG_TAG, "Act: Close notification menu");
         mNotificationHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Notification menu is closed");
         assertFalse("Notification did not close.", mNotificationHelper.get().isAppInForeground());
     }
 
     @Test
     public void testClearAllNotification() {
+        Log.i(LOG_TAG, "Act: Post a new notification");
         mNotificationMockingHelper.get().postNotifications(1);
+        Log.i(LOG_TAG, "Act: Clear all notifications from Notification menu");
         mNotificationHelper.get().tapClearAllBtn();
+        Log.i(LOG_TAG, "Act: Close notification menu");
         mNotificationHelper.get().exit();
+        Log.i(LOG_TAG, "Assert: Notification is cleared");
         assertFalse(
                 "Notifications were not cleared.",
-                mNotificationHelper.get().isNotificationDisplayedInCenterWithTitle(NOTIFICATION_TITLE));
+                mNotificationHelper
+                        .get()
+                        .isNotificationDisplayedInCenterWithTitle(NOTIFICATION_TITLE));
     }
 
     @Test
     public void testPostNotification() {
+        Log.i(LOG_TAG, "Act: Post a new notification");
         mNotificationMockingHelper.get().postNotifications(1);
+        Log.i(LOG_TAG, "Assert: Posted notification is displayed in Notifications");
         assertTrue(
                 "Unable to find posted notification.",
                 mNotificationHelper.get().checkNotificationExists(NOTIFICATION_TITLE));
@@ -82,21 +98,31 @@ public class NotificationTest {
 
     @Test
     public void testSwipeAwayNotification() {
+        Log.i(LOG_TAG, "Act: Clear all notifications from Notification menu");
         mNotificationHelper.get().tapClearAllBtn();
+        Log.i(LOG_TAG, "Act: Post a new notification");
         mNotificationMockingHelper.get().postNotifications(1);
+        Log.i(LOG_TAG, "Assert: Posted notification is displayed in Notifications");
         assertTrue(
                 "Unable to find posted notification.",
                 mNotificationHelper.get().checkNotificationExists(NOTIFICATION_TITLE));
+        Log.i(LOG_TAG, "Act: Removed Posted notification from Notification menu");
         mNotificationHelper.get().removeNotification(NOTIFICATION_TITLE);
+        Log.i(LOG_TAG, "Act: Posted notification from removed Notification menu");
         assertFalse(
                 "Notifications were not cleared.",
-                mNotificationHelper.get().isNotificationDisplayedInCenterWithTitle(NOTIFICATION_TITLE));
+                mNotificationHelper
+                        .get()
+                        .isNotificationDisplayedInCenterWithTitle(NOTIFICATION_TITLE));
     }
 
     @Test
     public void testManageButton() {
+        Log.i(LOG_TAG, "Act: Post a new notification");
         mNotificationMockingHelper.get().postNotifications(1);
+        Log.i(LOG_TAG, "Act: Open Notification menu and click on Manage button");
         mNotificationHelper.get().clickManageBtn();
+        Log.i(LOG_TAG, "Assert: Notification setting is open");
         assertTrue(
                 "Notification Settings did not open.",
                 mNotificationHelper.get().isNotificationSettingsOpened());
@@ -104,14 +130,21 @@ public class NotificationTest {
 
     @Test
     public void testRecentAndOlderNotifications() {
+        Log.i(LOG_TAG, "Act: Clear all notifications from Notification menu");
         mNotificationHelper.get().tapClearAllBtn();
+        Log.i(LOG_TAG, "Act: Post a new notification");
         mNotificationMockingHelper.get().postNotifications(1);
+        Log.i(LOG_TAG, "Act: Open Notification menu");
         mNotificationHelper.get().open();
+        Log.i(LOG_TAG, "Assert: Notification is present under recent category");
         assertTrue(
                 "Notification are not present under recent category",
                 mNotificationHelper.get().isRecentNotification());
+        Log.i(LOG_TAG, "Assert: Close Notification menu");
         mNotificationHelper.get().exit();
+        Log.i(LOG_TAG, "Act: Open Notification menu again");
         mNotificationHelper.get().open();
+        Log.i(LOG_TAG, "Assert: Notification is present under older category");
         assertTrue(
                 "Notification are not present under older category",
                 mNotificationHelper.get().isOlderNotification());
diff --git a/tests/automotive/functional/profileiconlist/src/android/platform/tests/ProfileIconsListTest.java b/tests/automotive/functional/profileiconlist/src/android/platform/tests/ProfileIconsListTest.java
index dc44795a8..6f79952f8 100644
--- a/tests/automotive/functional/profileiconlist/src/android/platform/tests/ProfileIconsListTest.java
+++ b/tests/automotive/functional/profileiconlist/src/android/platform/tests/ProfileIconsListTest.java
@@ -23,6 +23,7 @@ import android.platform.helpers.IAutoHomeHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.scenario.multiuser.MultiUserConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -42,6 +43,8 @@ public class ProfileIconsListTest {
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = ProfileIconsListTest.class.getSimpleName();
+
     public ProfileIconsListTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -54,12 +57,18 @@ public class ProfileIconsListTest {
      */
     @Test
     public void testListOfProfiles() throws Exception {
+        Log.i(LOG_TAG, "Act: Create non-admin user");
         mMultiUserHelper.createUser(USER_NAME, false);
+        Log.i(LOG_TAG, "Act: Open status bar profiles");
         mHomeHelper.get().openStatusBarProfiles();
+        Log.i(LOG_TAG, "Act: Get list of user profile names");
         List<String> list = mHomeHelper.get().getUserProfileNames();
+        Log.i(LOG_TAG, "Assert: New user is at first position");
         assertFalse("newUser at index first position", USER_NAME.equals(list.get(0)));
         int position = list.size() - 1;
+        Log.i(LOG_TAG, "Assert: Guest profile is at last position");
         assertTrue("Guest profile not at last position", GUEST_NAME.equals(list.get(position)));
+        Log.i(LOG_TAG, "Assert: Add a Profile option is not displayed");
         assertTrue(
                 "Add a Profile option is not displayed",
                 mSettingHelper.get().checkMenuExists("Add a profile"));
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
index d90d50be0..c581abd9f 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
@@ -1,12 +1,15 @@
 package android.platform.tests;
 
+import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoAppGridHelper;
 import android.platform.helpers.IAutoAppInfoSettingsHelper;
 import android.platform.helpers.IAutoAppInfoSettingsHelper.State;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -21,14 +24,18 @@ import java.util.List;
 public class AppInfoSettingTest {
     private HelperAccessor<IAutoAppInfoSettingsHelper> mAppInfoSettingsHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
+    private static final String LOG_TAG = AppInfoSettingTest.class.getSimpleName();
 
     private static final String CONTACTS_APP = "Contacts";
+    private static final String CALENDAR_APP = "Calendar";
     private static final String PHONE_PERMISSION = "Phone";
     private static final String CONTACT_PACKAGE = "com.android.contacts";
 
     public AppInfoSettingTest() throws Exception {
         mAppInfoSettingsHelper = new HelperAccessor<>(IAutoAppInfoSettingsHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
+        mAppGridHelper = new HelperAccessor<>(IAutoAppGridHelper.class);
     }
     @Before
     public void openAppInfoFacet() {
@@ -47,25 +54,58 @@ public class AppInfoSettingTest {
 
     @Test
     public void testDisableEnableApplication() {
-        mAppInfoSettingsHelper.get().selectApp(CONTACTS_APP);
-        mAppInfoSettingsHelper.get().enableDisableApplication(State.DISABLE);
+        // Diabale contacts app in app info settings
+        Log.i(LOG_TAG, "Act: Select Contacts App and disable it");
+        mAppInfoSettingsHelper.get().selectAppAndEnableDisableApp(CONTACTS_APP, State.DISABLE);
+
+        Log.i(LOG_TAG, "Assert: Application is disabled");
         assertTrue(
                 "Application is not disabled",
                 mAppInfoSettingsHelper.get().isApplicationDisabled(CONTACT_PACKAGE));
-        mAppInfoSettingsHelper.get().enableDisableApplication(State.ENABLE);
+
+        // Validate whether app is not visible in app grid
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Assert: Contacts app is not visible in app grid");
+        assertFalse(
+                "App is present in app grid",
+                mAppGridHelper.get().isAppPresentInAppgrid("Contacts"));
+
+        // Enable contacts app in app info settings
+        Log.i(LOG_TAG, "Act: Open app info settings");
+        openAppInfoFacet();
+        Log.i(LOG_TAG, "Act: Select Contacts App and disable it");
+        mAppInfoSettingsHelper.get().selectAppAndEnableDisableApp(CONTACTS_APP, State.ENABLE);
+
+        Log.i(LOG_TAG, "Assert: Application is enabled");
         assertTrue(
                 "Application is not enabled",
                 !mAppInfoSettingsHelper.get().isApplicationDisabled(CONTACT_PACKAGE));
+
+        // Validate whether app is not visible in app grid
+        Log.i(LOG_TAG, "Act: Open Appgrid");
+        mAppGridHelper.get().open();
+
+        Log.i(LOG_TAG, "Assert: Contacts app is visible in app grid");
+        assertTrue(
+                "App is not present in app grid",
+                mAppGridHelper.get().isAppPresentInAppgrid("Contacts"));
     }
 
     @Test
     public void testApplicationPermissions() {
+        Log.i(LOG_TAG, "Act: Open the Contacts App");
         mAppInfoSettingsHelper.get().selectApp(CONTACTS_APP);
+        Log.i(LOG_TAG, "Act: Enable the phone app permission");
         mAppInfoSettingsHelper.get().setAppPermission(PHONE_PERMISSION, State.ENABLE);
+        Log.i(LOG_TAG, "Assert: Permission is enabled");
         assertTrue(
                 "Permission is disabled",
                 mAppInfoSettingsHelper.get().getCurrentPermissions().contains(PHONE_PERMISSION));
+        Log.i(LOG_TAG, "Act: Disable the phone app permission");
         mAppInfoSettingsHelper.get().setAppPermission(PHONE_PERMISSION, State.DISABLE);
+        Log.i(LOG_TAG, "Assert: Permission is disabled");
         assertTrue(
                 "Permission is not disabled",
                 !mAppInfoSettingsHelper.get().getCurrentPermissions().contains(PHONE_PERMISSION));
@@ -73,9 +113,10 @@ public class AppInfoSettingTest {
 
     @Test
     public void testAllowedAppNumber() {
-
+        Log.i(LOG_TAG, "Act: Open the App Settings");
         // Navigate to the app permission manager.
         mSettingHelper.get().openSetting(SettingsConstants.APPS_SETTINGS);
+        Log.i(LOG_TAG, "Act: Open the Permission manager");
         mAppInfoSettingsHelper.get().openPermissionManager();
 
         // Get one specific Permission UI element (that we have not looked at before).
@@ -86,7 +127,7 @@ public class AppInfoSettingTest {
         int summaryTotal = results.get(1);
         int listedAllowed = results.get(2);
         int listedTotal = results.get(3);
-
+        Log.i(LOG_TAG, "Assert: Number of listed allowed apps matches the display");
         assertTrue(
                 String.format(
                         "Number of listed apps allowed does not match display."
@@ -95,7 +136,7 @@ public class AppInfoSettingTest {
                         summaryAllowed,
                         listedAllowed),
                 summaryAllowed == listedAllowed);
-
+        Log.i(LOG_TAG, "Assert: Number of listed not allowed apps matches the display");
         assertTrue(
                 String.format(
                         "Number of listed apps not allowed does not match display."
@@ -103,4 +144,17 @@ public class AppInfoSettingTest {
                         summaryTotal, listedTotal),
                 summaryTotal == listedTotal);
     }
+
+    @Test
+    public void testAppForceStop() {
+        Log.i(LOG_TAG, "Act: Select Calendar App");
+        mAppInfoSettingsHelper.get().selectApp(CALENDAR_APP);
+
+        Log.i(LOG_TAG, "Act: click on stop app button ");
+        mAppInfoSettingsHelper.get().forceStop();
+
+        Log.i(LOG_TAG, "Assert: stop app popup is not displaying ");
+        assertFalse(
+                "App is not force stopped", mAppInfoSettingsHelper.get().isStopappPopupDisplayed());
+    }
 }
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoVerifyUIElementsTest.java b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoVerifyUIElementsTest.java
index 5538020ad..11768c86c 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoVerifyUIElementsTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoVerifyUIElementsTest.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoAppInfoSettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -37,6 +38,7 @@ public class AppInfoVerifyUIElementsTest {
     private HelperAccessor<IAutoAppInfoSettingsHelper> mAppInfoSettingsHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
+    private static final String LOG_TAG = AppInfoVerifyUIElementsTest.class.getSimpleName();
 
     private static final String CALENDAR_APP = "Calendar";
 
@@ -48,6 +50,7 @@ public class AppInfoVerifyUIElementsTest {
 
     @Before
     public void openAppInfoFacet() {
+        Log.i(LOG_TAG, "Assert: Open the application settings");
         mSettingHelper.get().openSetting(SettingsConstants.APPS_SETTINGS);
     }
 
@@ -59,28 +62,36 @@ public class AppInfoVerifyUIElementsTest {
 
     @Test
     public void testVerifyAppsPermissionUIElements() {
+        Log.i(LOG_TAG, "Assert: App Settings is open");
         assertTrue(
                 "Apps setting did not open.",
                 mSettingsUIHelper
-                        .get()
-                        .hasUIElement(AutomotiveConfigConstants.RECENTLY_OPENED_UI_ELEMENT));
+                                .get()
+                                .hasUIElement(AutomotiveConfigConstants.RECENTLY_OPENED_UI_ELEMENT)
+                        || mSettingHelper.get().checkMenuExists("Reset app grid to A-Z order"));
+        Log.i(LOG_TAG, "Act: Show all apps");
         mAppInfoSettingsHelper.get().showAllApps();
+        Log.i(LOG_TAG, "Act: Open the Calendar app");
         mAppInfoSettingsHelper.get().selectApp(CALENDAR_APP);
+        Log.i(LOG_TAG, "Assert: Stop app button is open");
         assertTrue(
                 "Stop app Button is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.STOP_APP_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Notification Option is displayed");
         assertTrue(
                 "Notification Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.NOTIFICATIONS_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Permissions Option is displayed");
         assertTrue(
                 "Permissions Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.PERMISSIONS_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Storage and Cache is displayed");
         assertTrue(
                 "Storage and Cache Option is not displayed",
                 mSettingsUIHelper
@@ -90,27 +101,32 @@ public class AppInfoVerifyUIElementsTest {
 
     @Test
     public void testVerifyAppsInfoUIElements() {
+        Log.i(LOG_TAG, "Assert: Permissions manager Option is displayed");
         assertTrue(
                 "Permission manager Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.PERMISSION_MANAGER_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Default apps option is displayed");
         assertTrue(
                 "Default apps Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.DEFAULT_APPS_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Unused apps option is displayed");
         assertTrue(
                 "Unused apps Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.UNUSED_APPS_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Performance-impacting apps option is displayed");
         assertTrue(
                 "Performance-impacting apps Option is not displayed",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(
                                 AutomotiveConfigConstants.PERFORMANCE_IMPACTING_APPS_UI_ELEMENT));
+        Log.i(LOG_TAG, "Assert: Special apps access option is displayed");
         assertTrue(
                 "Special app access Option is not displayed",
                 mSettingsUIHelper
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/BluetoothSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/BluetoothSettingTest.java
index ed5f891e9..fe74669c5 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/BluetoothSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/BluetoothSettingTest.java
@@ -21,6 +21,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoBluetoothSettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -32,6 +33,7 @@ import org.junit.runner.RunWith;
 public class BluetoothSettingTest {
     private HelperAccessor<IAutoBluetoothSettingsHelper> mBluetoothSettingHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = BluetoothSettingTest.class.getSimpleName();
 
     public BluetoothSettingTest() throws Exception {
         mBluetoothSettingHelper = new HelperAccessor<>(IAutoBluetoothSettingsHelper.class);
@@ -45,10 +47,13 @@ public class BluetoothSettingTest {
 
     @Test
     public void testBluetoothDefaultState() {
+        Log.i(LOG_TAG, "Act: Open the Bluetooth Setting");
         mSettingHelper.get().openSetting(SettingsConstants.BLUETOOTH_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Bluetooth is turned on by default");
         assertTrue(
                 "Bluetooth default state is not turned on in the System",
                 mSettingHelper.get().isBluetoothOn());
+        Log.i(LOG_TAG, "Assert: Use Bluetooth toggle is turned on in the Settings");
         assertTrue(
                 "Use Bluetooth toggle is not turned on in the Settings",
                 mBluetoothSettingHelper.get().isUseBluetoothToggleChecked());
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/DisplaySettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/DisplaySettingTest.java
index 61da94f5f..4bc9b0559 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/DisplaySettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/DisplaySettingTest.java
@@ -23,6 +23,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoDisplaySettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import org.junit.Test;
 
@@ -30,6 +31,7 @@ public class DisplaySettingTest {
 
     private final HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoDisplaySettingsHelper> mDisplaySettingsHelper;
+    private static final String LOG_TAG = DisplaySettingTest.class.getSimpleName();
 
     public DisplaySettingTest() {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -38,6 +40,7 @@ public class DisplaySettingTest {
 
     @Test
     public void testBrightnessIncrease() {
+        Log.i(LOG_TAG, "Act: Open the Display Setting");
         mSettingHelper.get().openSetting(SettingsConstants.DISPLAY_SETTINGS);
         assertTrue(
                 "Display Setting did not open",
@@ -60,12 +63,14 @@ public class DisplaySettingTest {
 
     @Test
     public void testAdaptiveBrightnessDefaultValue() {
+        Log.i(LOG_TAG, "Act: Open the Display Setting");
         mSettingHelper.get().openSetting(SettingsConstants.DISPLAY_SETTINGS);
+        Log.i(LOG_TAG, "Act: Settings did not open");
         assertTrue(
                 "Display Setting did not open",
                 mSettingHelper.get().checkMenuExists("Adaptive brightness"));
 
-        // Verify that Adaptive Brightness is not enabled.
+        Log.i(LOG_TAG, "Assert: Adaptive brightness is disabled");
         assertFalse(
                 "Adaptive Brightness was enabled, when it should be disabled by default.",
                 mDisplaySettingsHelper.get().isAdaptiveBrightnessEnabled());
@@ -73,16 +78,20 @@ public class DisplaySettingTest {
 
     @Test
     public void testAdaptiveBrightnessToggle() {
+        Log.i(LOG_TAG, "Act: Open the Display Setting");
         mSettingHelper.get().openSetting(SettingsConstants.DISPLAY_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Display setting is opened");
         assertTrue(
                 "Display Setting did not open",
                 mSettingHelper.get().checkMenuExists("Adaptive brightness"));
 
         // Verify that Adaptive Brightness can be toggled.
         boolean startSetting = mDisplaySettingsHelper.get().isAdaptiveBrightnessEnabled();
+        Log.i(LOG_TAG, "Act: Toggle Adaptive brightness");
         mDisplaySettingsHelper.get().toggleAdaptiveBrightness();
         boolean endSetting = mDisplaySettingsHelper.get().isAdaptiveBrightnessEnabled();
 
+        Log.i(LOG_TAG, "Assert: Adaptive Brightness Value is changed after toggle");
         assertFalse(
                 String.format(
                         "Adaptive Brightness value did not change after toggle;"
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/EnableDevelopersOption.java b/tests/automotive/functional/settings/src/android/platform/tests/EnableDevelopersOption.java
index 13d5d4dfe..4df42d375 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/EnableDevelopersOption.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/EnableDevelopersOption.java
@@ -22,6 +22,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoSystemSettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -33,6 +34,7 @@ import org.junit.runner.RunWith;
 public class EnableDevelopersOption {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoSystemSettingsHelper> mSystemSettingsHelper;
+    private static final String LOG_TAG = EnableDevelopersOption.class.getSimpleName();
 
     public EnableDevelopersOption() throws Exception {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -41,8 +43,11 @@ public class EnableDevelopersOption {
 
     @Test
     public void testToVerifyDeveloperOptions() throws Exception {
+        Log.i(LOG_TAG, "Act: Open the System Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Act: Enter Developer Mode");
         mSystemSettingsHelper.get().enterDeveloperMode();
+        Log.i(LOG_TAG, "Assert: Developer Options is displayed");
         assertTrue(
                 "Developer options are not displayed",
                 mSystemSettingsHelper.get().hasDeveloperOptions());
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneRecentAppsTest.java b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneRecentAppsTest.java
index 2230a4198..69133bc06 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneRecentAppsTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneRecentAppsTest.java
@@ -23,6 +23,7 @@ import android.platform.helpers.IAutoAppGridHelper;
 import android.platform.helpers.IAutoPrivacySettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -35,6 +36,7 @@ public class MicroPhoneRecentAppsTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
     private HelperAccessor<IAutoPrivacySettingsHelper> mPrivacySettingsHelper;
+    private static final String LOG_TAG = MicroPhoneRecentAppsTest.class.getSimpleName();
 
     private static final String APP = "Google Assistant";
     private static final String APP_TXT = "Google Assistant is using the mic";
@@ -58,8 +60,11 @@ public class MicroPhoneRecentAppsTest {
 
     @Test
     public void testRecentlyAccessedApps() {
+        Log.i(LOG_TAG, "Act: Open the privacy settings");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Open MicroPhone");
         mSettingHelper.get().openMenuWith("MicroPhone");
+        Log.i(LOG_TAG, "Assert: Recent App time stamp is displayed in microphone settings page");
         assertTrue(
                 "Recent App time stamp is not displayed in microphone settings page",
                 mPrivacySettingsHelper.get().isRecentAppDisplayedWithStamp(APP));
@@ -67,9 +72,13 @@ public class MicroPhoneRecentAppsTest {
 
     @Test
     public void testViewAllLink() {
+        Log.i(LOG_TAG, "Act: Open the privacy settings");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
+        Log.i(LOG_TAG, "Act: Open MicroPhone");
         mSettingHelper.get().openMenuWith("MicroPhone");
+        Log.i(LOG_TAG, "Act: Click the View All Link");
         mPrivacySettingsHelper.get().clickViewAllLink();
+        Log.i(LOG_TAG, "Assert: Recent App time stamp is displayed in view all page");
         assertTrue(
                 "Recent App time stamp is not displayed in view all page",
                 mPrivacySettingsHelper.get().isRecentAppDisplayedWithStamp(APP));
@@ -77,7 +86,9 @@ public class MicroPhoneRecentAppsTest {
 
     @Test
     public void testMicroPhonePanelUpdatedWithCurrentAppUsage() {
+        Log.i(LOG_TAG, "Act: Click MicroPhone Status bar");
         mPrivacySettingsHelper.get().clickUnMutedMicroPhoneStatusBar();
+        Log.i(LOG_TAG, "Assert: Current App usage is displayed in the panel");
         assertTrue(
                 "Current App usage is not displayed in the panel",
                 mPrivacySettingsHelper.get().isMicroPhoneStatusMessageUpdated(APP_TXT));
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
index 0624ae353..ecb87dff7 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
@@ -27,6 +27,7 @@ import android.platform.helpers.SettingsConstants;
 import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -45,6 +46,7 @@ public class MicroPhoneSettingTest {
     private HelperAccessor<IAutoFacetBarHelper> mFacetBarHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoPrivacySettingsHelper> mPrivacySettingsHelper;
+    private static final String LOG_TAG = MicroPhoneSettingTest.class.getSimpleName();
 
     @Rule
     public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
@@ -57,15 +59,19 @@ public class MicroPhoneSettingTest {
 
     @Before
     public void openPrivacySetting() {
+        Log.i(LOG_TAG, "Act: Open the privacy settings");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Privacy Settings is open");
         assertTrue(
                 "Privacy settings did not open",
                 mSettingHelper.get().checkMenuExists("Microphone"));
         mSettingHelper.get().openMenuWith("MicroPhone");
+        Log.i(LOG_TAG, "Assert: Microphone Settings is open");
         assertTrue(
                 "MicroPhone settings did not open",
                 mSettingHelper.get().checkMenuExists("Microphone access"));
         mSettingHelper.get().openMenuWith("Microphone access");
+        Log.i(LOG_TAG, "Assert: Microphone Access is open");
         assertTrue(
                 "MicroPhone access did not open",
                 mSettingHelper.get().checkMenuExists("Infotainment apps"));
@@ -84,13 +90,15 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    public void manageMicrophonePermissions() {
+    public void testManageMicrophonePermissions() {
+        Log.i(LOG_TAG, "Act: Privacy settings is open");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
         assertTrue(
                 "Privacy settings did not open",
                 mSettingHelper.get().checkMenuExists("Microphone"));
         mSettingHelper.get().openMenuWith("MicroPhone");
         mPrivacySettingsHelper.get().clickManageMicroPhonePermissions();
+        Log.i(LOG_TAG, "Assert: Microphone Permissions page is displayed");
         assertTrue(
                 "Microphone Permissions page is not displayed",
                 mPrivacySettingsHelper.get().verifyMicrophoneManagePermissionsPage());
@@ -98,15 +106,21 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhoneToggleOff() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
+        Log.i(LOG_TAG, "Assert: Microphone is Off");
         assertFalse("MicroPhone is still on", mPrivacySettingsHelper.get().isMicroPhoneOn());
+        Log.i(LOG_TAG, "Act: Go back to settings screen");
         mSettingHelper.get().goBackToSettingsScreen();
+        Log.i(LOG_TAG, "Act: Privacy settings is open");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
+        Log.i(LOG_TAG, "Act: Open Microphone");
         mSettingHelper.get().openMenuWith("MicroPhone");
+        Log.i(LOG_TAG, "Assert: Recent apps is displayed");
         assertFalse(
                 "Recent apps is displayed",
                 mSettingHelper.get().checkMenuExists("Recently accessed"));
+        Log.i(LOG_TAG, "Assert: Micro Phone button is diplayed in the Status Bar");
         assertTrue(
                 "Micro Phone button is not diplayed in the Status Bar",
                 mPrivacySettingsHelper.get().isMutedMicChipPresentOnStatusBar());
@@ -114,13 +128,17 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhoneToggleOn() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
-        // turn on microphone
+        Log.i(LOG_TAG, "Act: Turn On the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(true);
+        Log.i(LOG_TAG, "Assert: Microphone is On");
         assertTrue("MicroPhone is still off", mPrivacySettingsHelper.get().isMicroPhoneOn());
+        Log.i(LOG_TAG, "Act: Go back to settings screen");
         mSettingHelper.get().goBackToSettingsScreen();
+        Log.i(LOG_TAG, "Act: Privacy settings is open");
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
+        Log.i(LOG_TAG, "Act: Open Microphone");
         mSettingHelper.get().openMenuWith("MicroPhone");
         assertTrue(
                 "Recently accessed is not present",
@@ -135,16 +153,19 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhonePanelStatusBar() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
-        // open microphone panel
+        Log.i(LOG_TAG, "Act: Open Microphone panel");
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
+        Log.i(LOG_TAG, "Assert: MicroPhone status is updated");
         assertTrue(
                 "MicroPhone status not updated",
                 mPrivacySettingsHelper.get().isMicroPhoneStatusMessageUpdated(MICROPHONE_OFF_TXT));
+        Log.i(LOG_TAG, "Assert: MicroPhone settings link is present");
         assertTrue(
                 "MicroPhone settings link is not present",
                 mPrivacySettingsHelper.get().isMicroPhoneSettingsLinkPresent());
+        Log.i(LOG_TAG, "Assert: MicroPhone toggle is present in status bar");
         assertTrue(
                 "MicroPhone toggle not present in status bar",
                 mPrivacySettingsHelper.get().isMicroPhoneTogglePresent());
@@ -152,14 +173,17 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhonePanelStatusBarFromHome() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
+        Log.i(LOG_TAG, "Act: Go to Homescreen");
         mFacetBarHelper.get().goToHomeScreen();
-        // open microphone panel
+        Log.i(LOG_TAG, "Act: Open Microphone panel");
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
+        Log.i(LOG_TAG, "Assert: MicroPhone settings link is present");
         assertTrue(
                 "MicroPhone settings link is not present",
                 mPrivacySettingsHelper.get().isMicroPhoneSettingsLinkPresent());
+        Log.i(LOG_TAG, "Assert: MicroPhone toggle is present in status bar");
         assertTrue(
                 "MicroPhone toggle not present in status bar",
                 mPrivacySettingsHelper.get().isMicroPhoneTogglePresent());
@@ -167,9 +191,9 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhonePanelSettingsLink() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
-        // open microphone panel
+        Log.i(LOG_TAG, "Act: Open Microphone panel");
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
         // go to privacy settings
         mPrivacySettingsHelper.get().clickMicroPhoneSettingsLink();
@@ -180,20 +204,25 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhonePanelToggle() {
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
+        Log.i(LOG_TAG, "Act: Open Microphone panel");
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
-        // turn on microphone
+        Log.i(LOG_TAG, "Act: Turn On the microphone");
         mPrivacySettingsHelper.get().clickMicroPhoneToggleStatusBar();
+        Log.i(LOG_TAG, "Assert: Microphone is On");
         assertTrue("MicroPhone is still off", mPrivacySettingsHelper.get().isMicroPhoneOn());
+        Log.i(LOG_TAG, "Assert: MicroPhone button updated in the status bar");
         assertFalse(
                 "MicroPhone button not updated in status bar",
                 mPrivacySettingsHelper.get().isMutedMicChipPresentWithMicPanel());
+        Log.i(LOG_TAG, "Assert: MicroPhone status updated in the status bar");
         assertTrue(
                 "MicroPhone status not updated",
                 mPrivacySettingsHelper.get().isMicroPhoneStatusMessageUpdated(USE_MICROPHONE_TXT));
-        // turn off microphone
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().clickMicroPhoneToggleStatusBar();
+        Log.i(LOG_TAG, "Act: MicroPhone button is muted");
         assertTrue(
                 "MicroPhone button should be muted",
                 mPrivacySettingsHelper.get().isMutedMicChipPresentWithMicPanel());
@@ -201,14 +230,19 @@ public class MicroPhoneSettingTest {
 
     @Test
     public void testMicroPhoneButtonDismiss() {
+        Log.i(LOG_TAG, "Act: Turn Off the microphone");
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
+        Log.i(LOG_TAG, "Act: Open Microphone panel");
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
-        // turn microphone on
+        Log.i(LOG_TAG, "Act: Turn On the microphone");
         mPrivacySettingsHelper.get().clickMicroPhoneToggleStatusBar();
+        Log.i(LOG_TAG, "Act: Muted MicroPhone button is displayed in status bar");
         assertFalse(
                 "Muted MicroPhone button is displayed in status bar",
                 mPrivacySettingsHelper.get().isMutedMicChipPresentWithMicPanel());
+        Log.i(LOG_TAG, "Assert: Goto Homescreen");
         mFacetBarHelper.get().goToHomeScreen();
+        Log.i(LOG_TAG, "Assert: Muted MicroPhone button is still displayed on status bar");
         assertFalse(
                 "MicroPhone button is still displayed on status bar",
                 mPrivacySettingsHelper.get().isMicChipPresentOnStatusBar());
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/SettingSearchTest.java b/tests/automotive/functional/settings/src/android/platform/tests/SettingSearchTest.java
index b796469d7..232296963 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/SettingSearchTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/SettingSearchTest.java
@@ -85,6 +85,6 @@ public class SettingSearchTest {
         mSettingHelper.get().searchAndSelect(searchSetting);
         assertTrue(
                 "Page title does not contains searched setting name",
-                mSettingHelper.get().isValidPageTitle(searchSetting));
+                searchSetting.equals(mSettingHelper.get().getSettingsPageTitleText()));
     }
 }
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/SettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/SettingTest.java
index cc6cf87da..7412b029d 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/SettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/SettingTest.java
@@ -25,6 +25,7 @@ import android.platform.helpers.IAutoAppInfoSettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -38,6 +39,7 @@ public class SettingTest {
     private HelperAccessor<IAutoAppInfoSettingsHelper> mAppInfoSettingsHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
+    private static final String LOG_TAG = SettingTest.class.getSimpleName();
 
     public SettingTest() throws Exception {
         mSettingsUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
@@ -53,7 +55,9 @@ public class SettingTest {
 
     @Test
     public void testDisplaySettings() {
+        Log.i(LOG_TAG, "Act: Open the Display Setting");
         mSettingHelper.get().openSetting(SettingsConstants.DISPLAY_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Display Setting is open");
         assertTrue(
                 "Display Setting did not open",
                 mSettingHelper.get().checkMenuExists("Brightness level"));
@@ -61,7 +65,9 @@ public class SettingTest {
 
     @Test
     public void testSoundSettings() {
+        Log.i(LOG_TAG, "Act: Open the Sound Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SOUND_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Sound Setting is open");
         assertTrue(
                 "Sound setting did not open",
                 mSettingsUIHelper
@@ -71,16 +77,21 @@ public class SettingTest {
 
     @Test
     public void testAppinfoSettings() {
+        Log.i(LOG_TAG, "Act: Open the App Setting");
         mSettingHelper.get().openSetting(SettingsConstants.APPS_SETTINGS);
+        Log.i(LOG_TAG, "Assert: App Setting is open");
         assertTrue(
                 "Apps setting did not open",
-                mSettingHelper.get().checkMenuExists("Recently opened"));
+                mSettingHelper.get().checkMenuExists("Recently opened")
+                        || mSettingHelper.get().checkMenuExists("Reset app grid to A-Z order"));
         mAppInfoSettingsHelper.get().showAllApps();
     }
 
     @Test
     public void testAccountsSettings() {
+        Log.i(LOG_TAG, "Act: Open the Account Setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Profiles and accounts settings is open");
         assertTrue(
                 "Profiles and accounts settings did not open",
                 mSettingHelper.get().checkMenuExists("Add a profile"));
@@ -88,7 +99,9 @@ public class SettingTest {
 
     @Test
     public void testSystemSettings() {
+        Log.i(LOG_TAG, "Act: Open the System Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Assert: System Setting is opened");
         assertTrue(
                 "System settings did not open",
                 mSettingHelper.get().checkMenuExists("Languages & input"));
@@ -96,12 +109,17 @@ public class SettingTest {
 
     @Test
     public void testBluetoothSettings() {
+        Log.i(LOG_TAG, "Act: Open the Bluetooth Setting");
         mSettingHelper.get().openSetting(SettingsConstants.BLUETOOTH_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Bluetooth Setting is opened");
         assertTrue(
                 "Bluetooth Setting did not open",
                 mSettingHelper.get().checkMenuExists("Pair new device"));
+        Log.i(LOG_TAG, "Act: Turn Off the Bluetooth");
         mSettingHelper.get().turnOnOffBluetooth(false);
+        Log.i(LOG_TAG, "Assert: Blue Setting is Off");
         assertFalse(mSettingHelper.get().isBluetoothOn());
+        Log.i(LOG_TAG, "Act: Turn On the Bluetooth");
         mSettingHelper.get().turnOnOffBluetooth(true);
     }
 }
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/SoundSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/SoundSettingTest.java
index c2a2f66c3..da08d0e91 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/SoundSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/SoundSettingTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoSoundsSettingHelper.SoundType;
 import android.platform.helpers.IAutoSoundsSettingHelper.VolumeType;
 import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -43,6 +44,7 @@ public class SoundSettingTest {
     private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
     private HelperAccessor<IAutoSoundsSettingHelper> mSoundsSettingHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private static final String LOG_TAG = SoundSettingTest.class.getSimpleName();
 
     public SoundSettingTest() throws Exception {
         mSoundsSettingHelper = new HelperAccessor<>(IAutoSoundsSettingHelper.class);
@@ -53,7 +55,9 @@ public class SoundSettingTest {
 
     @Before
     public void openSoundsSettingFacet() {
+        Log.i(LOG_TAG, "Act: Open the sound settings");
         mSettingHelper.get().openSetting(SettingsConstants.SOUND_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Sound settings is open");
         assertTrue(
                 "Sound setting did not open",
                 mSettingsUIHelper
@@ -70,6 +74,7 @@ public class SoundSettingTest {
     public void testChangeMediaVolume() {
         mSoundsSettingHelper.get().setVolume(VolumeType.MEDIA, INDEX);
         int volume = mSoundsSettingHelper.get().getVolume(VolumeType.MEDIA);
+        Log.i(LOG_TAG, "Assert: Media Volume is set");
         assertTrue("Volume was not set", volume == INDEX);
     }
 
@@ -77,6 +82,7 @@ public class SoundSettingTest {
     public void testChangeAlarmVolume() {
         mSoundsSettingHelper.get().setVolume(VolumeType.ALARM, INDEX);
         int volume = mSoundsSettingHelper.get().getVolume(VolumeType.ALARM);
+        Log.i(LOG_TAG, "Assert: Alarm Volume is set");
         assertTrue("Volume was not set", volume == INDEX);
     }
 
@@ -84,6 +90,7 @@ public class SoundSettingTest {
     public void testChangeNavigationVolume() {
         mSoundsSettingHelper.get().setVolume(VolumeType.NAVIGATION, INDEX);
         int volume = mSoundsSettingHelper.get().getVolume(VolumeType.NAVIGATION);
+        Log.i(LOG_TAG, "Assert: Navigation Volume is set");
         assertTrue("Volume was not set", volume == INDEX);
     }
 
@@ -98,6 +105,7 @@ public class SoundSettingTest {
     public void testChangeRingtone() {
         mSoundsSettingHelper.get().setSound(SoundType.RINGTONE, RINGTONE);
         String sound = mSoundsSettingHelper.get().getSound(SoundType.RINGTONE);
+        Log.i(LOG_TAG, "Assert: Ringtone Volume is set");
         assertTrue("Sound was not changed", sound.equals(RINGTONE));
     }
 
@@ -105,6 +113,7 @@ public class SoundSettingTest {
     public void testChangeNotificationSound() {
         mSoundsSettingHelper.get().setSound(SoundType.NOTIFICATION, NOTIFICATION_SOUND);
         String sound = mSoundsSettingHelper.get().getSound(SoundType.NOTIFICATION);
+        Log.i(LOG_TAG, "Assert: Notification Volume is set");
         assertTrue("Sound was not changed", sound.equals(NOTIFICATION_SOUND));
     }
 
@@ -112,6 +121,7 @@ public class SoundSettingTest {
     public void testChangeAlarmSound() {
         mSoundsSettingHelper.get().setSound(SoundType.ALARM, ALARM_SOUND);
         String sound = mSoundsSettingHelper.get().getSound(SoundType.ALARM);
+        Log.i(LOG_TAG, "Assert: Alarm Volume is set");
         assertTrue("Sound was not changed", sound.equals(ALARM_SOUND));
     }
 }
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/StorageSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/StorageSettingTest.java
index c9c5e5a2b..809c5cdc9 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/StorageSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/StorageSettingTest.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoSystemSettingsHelper;
 import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -37,6 +38,7 @@ public class StorageSettingTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
     private HelperAccessor<IAutoSystemSettingsHelper> mSystemSettingsHelper;
+    private static final String LOG_TAG = StorageSettingTest.class.getSimpleName();
 
     public StorageSettingTest() throws Exception {
         mSettingsUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
@@ -46,10 +48,13 @@ public class StorageSettingTest {
 
     @Before
     public void openSystemStorageFacet() {
+        Log.i(LOG_TAG, "Act: Open the system settings");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Assert: System settings is opened ");
         assertTrue(
                 "System settings did not open",
                 mSettingHelper.get().checkMenuExists("Languages & input"));
+        Log.i(LOG_TAG, "Act: Open Storage Menu ");
         mSystemSettingsHelper.get().openStorageMenu();
     }
 
@@ -60,19 +65,23 @@ public class StorageSettingTest {
 
     @Test
     public void testMusicAndAudio() {
+        Log.i(LOG_TAG, "Assert: Music and Audio and Usage are Present");
         assertTrue(
                 "Music and Audio and Usage are not Present",
                 mSystemSettingsHelper
                         .get()
                         .verifyUsageinGB(AutomotiveConfigConstants.STORAGE_MUSIC_AUDIO_SETTINGS));
+        Log.i(LOG_TAG, "Assert: Music and Audio are present");
         assertTrue(
                 "Music and Audio is not present",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.STORAGE_MUSIC_AUDIO_SETTINGS));
+        Log.i(LOG_TAG, "Act: Music Audio Settings");
         mSettingsUIHelper
                 .get()
                 .openUIOptions(AutomotiveConfigConstants.STORAGE_MUSIC_AUDIO_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Music and Audio is open");
         assertTrue(
                 "Music and Audio is not open",
                 mSettingHelper.get().checkMenuExists("Hide system apps"));
@@ -80,30 +89,36 @@ public class StorageSettingTest {
 
     @Test
     public void testOtherApps() {
+        Log.i(LOG_TAG, "Assert: Other apps Usage is Present");
         assertTrue(
                 "Other apps Usage is not Present",
                 mSystemSettingsHelper
                         .get()
                         .verifyUsageinGB(AutomotiveConfigConstants.STORAGE_OTHER_APPS_SETTINGS));
+        Log.i(LOG_TAG, "Assert: Other apps is Present");
         assertTrue(
                 "Other apps is not present",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.STORAGE_OTHER_APPS_SETTINGS));
+        Log.i(LOG_TAG, "Assert: Other apps Storage settings");
         mSettingsUIHelper
                 .get()
                 .openUIOptions(AutomotiveConfigConstants.STORAGE_OTHER_APPS_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Other apps is open");
         assertTrue(
                 "Other apps is not open", mSettingHelper.get().checkMenuExists("Hide system apps"));
     }
 
     @Test
     public void testFiles() {
+        Log.i(LOG_TAG, "Assert: Files Usage is Present in GBs");
         assertTrue(
                 "Files Usage is not Present",
                 mSystemSettingsHelper
                         .get()
                         .verifyUsageinGB(AutomotiveConfigConstants.STORAGE_FILES_SETTINGS));
+        Log.i(LOG_TAG, "Assert: Files is Present under Storage");
         assertTrue(
                 "Files Usage is not present",
                 mSettingsUIHelper
@@ -114,11 +129,13 @@ public class StorageSettingTest {
 
     @Test
     public void testSystem() {
+        Log.i(LOG_TAG, "Assert: System Usage is Present");
         assertTrue(
                 "System Usage is not Present",
                 mSystemSettingsHelper
                         .get()
                         .verifyUsageinGB(AutomotiveConfigConstants.STORAGE_SYSTEM_SETTINGS));
+        Log.i(LOG_TAG, "Assert: System is Present under Storage");
         assertTrue(
                 "System is not present",
                 mSettingsUIHelper
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingTest.java
index f73367b9d..78422a8b9 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingTest.java
@@ -22,6 +22,7 @@ import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoSystemSettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -36,6 +37,7 @@ import java.util.Date;
 public class SystemSettingTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoSystemSettingsHelper> mSystemSettingsHelper;
+    private static final String LOG_TAG = SystemSettingTest.class.getSimpleName();
 
     public SystemSettingTest() throws Exception {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -45,7 +47,9 @@ public class SystemSettingTest {
 
     @Before
     public void openSystemFacet() {
+        Log.i(LOG_TAG, "Act: Open the System Settings");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Assert: System settings is open");
         assertTrue(
                 "System settings did not open",
                 mSettingHelper.get().checkMenuExists("Languages & input"));
@@ -59,6 +63,7 @@ public class SystemSettingTest {
     @Test
     public void testDeviceModel() {
         String model = android.os.Build.MODEL;
+        Log.i(LOG_TAG, "Assert: Model from API and Model from UI are the same");
         assertTrue(
                 "Model from API and Model from UI are not the same",
                 mSystemSettingsHelper.get().getDeviceModel().endsWith(model));
@@ -68,6 +73,7 @@ public class SystemSettingTest {
     public void testAndroidVersion() {
         String androidVersion = android.os.Build.VERSION.RELEASE;
         String androidVersionCodename = android.os.Build.VERSION.RELEASE_OR_CODENAME;
+        Log.i(LOG_TAG, "Assert: Android Version from API and Android Version from UI are the same");
         assertTrue(
                 "Android Version from API and Android Version from UI are not the same",
                 mSystemSettingsHelper.get().getAndroidVersion().endsWith(androidVersion)
@@ -86,6 +92,7 @@ public class SystemSettingTest {
                         Integer.valueOf(arr[0]),
                         Integer.valueOf(arr[1]) - 1,
                         Integer.valueOf(arr[2]));
+        Log.i(LOG_TAG, "Assert: security patch from API and security patch from UI are the same");
         assertTrue(
                 "security patch from API and security patch from UI are not the same",
                 date.equals(mSystemSettingsHelper.get().getAndroidSecurityPatchLevel()));
@@ -94,6 +101,7 @@ public class SystemSettingTest {
     @Test
     public void testKernelVersion() {
         String kernelVersion = System.getProperty("os.version");
+        Log.i(LOG_TAG, "Assert: kernel version from API and kernel from UI are the same");
         assertTrue(
                 "kernel version from API and kernel from UI are not the same",
                 mSystemSettingsHelper.get().getKernelVersion().startsWith(kernelVersion));
@@ -102,6 +110,7 @@ public class SystemSettingTest {
     @Test
     public void testBuildNumber() {
         String buildNumber = android.os.Build.DISPLAY;
+        Log.i(LOG_TAG, "Assert: Build number from API and Build number from UI are the same");
         assertTrue(
                 "Build number from API and Build number from UI are not the same",
                 buildNumber.equals(mSystemSettingsHelper.get().getBuildNumber()));
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingVerifyUIElementsTest.java b/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingVerifyUIElementsTest.java
index 7059e63d4..d1529d15b 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingVerifyUIElementsTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/SystemSettingVerifyUIElementsTest.java
@@ -24,6 +24,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoSystemSettingsHelper;
 import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -36,6 +37,7 @@ import org.junit.runner.RunWith;
 public class SystemSettingVerifyUIElementsTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
+    private static final String LOG_TAG = SystemSettingVerifyUIElementsTest.class.getSimpleName();
 
     public SystemSettingVerifyUIElementsTest() throws Exception {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -44,7 +46,9 @@ public class SystemSettingVerifyUIElementsTest {
 
     @Before
     public void openSystemFacet() {
+        Log.i(LOG_TAG, "Act: Open the system settings");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Assert: System settings did not open");
         assertTrue(
                 "System settings did not open",
                 mSettingHelper.get().checkMenuExists("Languages & input"));
@@ -57,25 +61,30 @@ public class SystemSettingVerifyUIElementsTest {
 
     @Test
     public void testLanguagesinputSystemSettings() {
+        Log.i(LOG_TAG, "Act: Open Languages & Input");
         mSettingsUIHelper.get().openUIOptions(AutomotiveConfigConstants.LANGUAGES_INPUT_IN_SYSTEM);
 
+        Log.i(LOG_TAG, "Assert: Languages displayed in Languages & input");
         assertTrue(
-                "Languages displayed in Languages & input",
+                "Languages not displayed in Languages & input",
                 mSettingsUIHelper.get().hasUIElement(AutomotiveConfigConstants.LANGUAGES_MENU));
+        Log.i(LOG_TAG, "Assert: Autofill service displayed in Languages & input");
         assertTrue(
-                "Autofill service displayed in Languages & input",
+                "Autofill service not displayed in Languages & input",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(
                                 AutomotiveConfigConstants
                                         .LANGUAGE_SYSTEM_SETTINGS_AUTOFILL_SERVICE));
+        Log.i(LOG_TAG, "Assert: Keyboard service displayed in Languages & input");
         assertTrue(
-                "Keyboard service displayed in Languages & input",
+                "Keyboard service not displayed in Languages & input",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.LANGUAGE_SYSTEM_SETTINGS_KEYBOARD));
+        Log.i(LOG_TAG, "Assert: Text to speech output displayed in Languages & input");
         assertTrue(
-                "Text to speechoutput displayed in Languages & input",
+                "Text to speech output not displayed in Languages & input",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(
@@ -85,24 +94,29 @@ public class SystemSettingVerifyUIElementsTest {
 
     @Test
     public void testUnitSystemSettings() {
+        Log.i(LOG_TAG, "Act: Open Units in System Settings");
         mSettingsUIHelper.get().openUIOptions(AutomotiveConfigConstants.SYSTEM_SETTINGS_UNITS);
+        Log.i(LOG_TAG, "Assert: Speed is displayed in Units");
         assertTrue(
-                "Speed displayed in Units",
+                "Speed is not displayed in Units",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.UNIT_SYSTEM_SETTINGS_SPEED));
+        Log.i(LOG_TAG, "Assert: Distance is displayed in Units");
         assertTrue(
-                "Distance displayed in Units",
+                "Distance is not displayed in Units",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.UNIT_SYSTEM_SETTINGS_DISTANCE));
+        Log.i(LOG_TAG, "Assert: Temperature is displayed in Units");
         assertTrue(
-                "Temperature displayed in Units",
+                "Temperature is not displayed in Units",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.UNIT_SYSTEM_SETTINGS_TEMPERATURE));
+        Log.i(LOG_TAG, "Assert: Pressue is displayed in Units");
         assertTrue(
-                "Pressure displayed in Units",
+                "Pressure is not displayed in Units",
                 mSettingsUIHelper
                         .get()
                         .hasUIElement(AutomotiveConfigConstants.UNIT_SYSTEM_SETTINGS_PRESSURE));
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/WifiSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/WifiSettingTest.java
index e0ab5add2..cef451783 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/WifiSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/WifiSettingTest.java
@@ -19,9 +19,12 @@ package android.platform.tests;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
+import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
+import android.platform.helpers.IAutoUISettingsHelper;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -33,8 +36,11 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class WifiSettingTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
+    private HelperAccessor<IAutoUISettingsHelper> mSettingsUIHelper;
+    private static final String LOG_TAG = WifiSettingTest.class.getSimpleName();
 
     public WifiSettingTest() throws Exception {
+        mSettingsUIHelper = new HelperAccessor<>(IAutoUISettingsHelper.class);
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
     }
 
@@ -54,16 +60,53 @@ public class WifiSettingTest {
 
     @Test
     public void testWifiSettings() {
+        Log.i(LOG_TAG, "Act: Turn Off Wifi");
         mSettingHelper.get().turnOnOffWifi(false);
+        Log.i(LOG_TAG, "Assert: Wifi is turned off");
         assertFalse(mSettingHelper.get().isWifiOn());
+        Log.i(LOG_TAG, "Act: Turn On Wifi");
         mSettingHelper.get().turnOnOffWifi(true);
+        Log.i(LOG_TAG, "Assert: Wifi is turned on");
         assertTrue(mSettingHelper.get().isWifiOn());
     }
 
     @Test
     public void testTurnOnOffHotspot() {
+        Log.i(LOG_TAG, "Act: Turn On Hotspot");
         mSettingHelper.get().turnOnOffHotspot(true);
+        Log.i(LOG_TAG, "Assert: Hotspot is On");
         assertTrue(mSettingHelper.get().isHotspotOn());
+        Log.i(LOG_TAG, "Act: Turn Off Hotspot");
         mSettingHelper.get().turnOnOffHotspot(false);
+        Log.i(LOG_TAG, "Assert: Hotspot is Off");
+        assertFalse(mSettingHelper.get().isHotspotOn());
+    }
+
+    @Test
+    public void testWifiPreferences() {
+        Log.i(LOG_TAG, "Assert: Wi-Fi Preferences option is displayed");
+        assertTrue(
+                "Wi-Fi Preferences option is not displayed",
+                mSettingsUIHelper.get().hasUIElement(AutomotiveConfigConstants.WIFI_PREFERENCES));
+        Log.i(LOG_TAG, "Act: Open Wifi preferences");
+        mSettingHelper.get().openMenuWith("WiFi preferences");
+        Log.i(LOG_TAG, "Assert: Turn on WiFi automatically is displayed");
+        assertTrue(
+                "Turn on WiFi automatically is not displayed",
+                mSettingHelper.get().checkMenuExists("Turn on WiFi automatically"));
+        Log.i(LOG_TAG, "Assert: Turn on Wi-Fi automatically toggle is displayed");
+        assertTrue(
+                "Turn on Wi-Fi automatically toggle is not displayed",
+                mSettingsUIHelper
+                        .get()
+                        .hasUIElement(AutomotiveConfigConstants.TURN_WIFI_AUTOMATICALLY_TOGGLE));
+    }
+
+    @Test
+    public void testJoinOtherNetwork() {
+        Log.i(LOG_TAG, "Assert: Join other network option is displayed");
+        assertTrue(
+                "Join other network option is not displayed",
+                mSettingsUIHelper.get().hasUIElement(AutomotiveConfigConstants.JOIN_OTHER_NETWORK));
     }
 }
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/BluetoothPaletteTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/BluetoothPaletteTest.java
index 94fcc2952..0451ae0e5 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/BluetoothPaletteTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/BluetoothPaletteTest.java
@@ -19,6 +19,7 @@ import static junit.framework.Assert.assertTrue;
 
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoStatusBarHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -30,6 +31,7 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class BluetoothPaletteTest {
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
+    private static final String LOG_TAG = BluetoothPaletteTest.class.getSimpleName();
 
     public BluetoothPaletteTest() {
         mStatusBarHelper = new HelperAccessor<>(IAutoStatusBarHelper.class);
@@ -42,10 +44,13 @@ public class BluetoothPaletteTest {
 
     @Test
     public void testDefaultStatusOfBlueToothPalette() {
+        Log.i(LOG_TAG, "Act: Turn on Bluettooth.");
         mStatusBarHelper.get().turnOnOffBluetooth(true);
+        Log.i(LOG_TAG, "Assert: Bluetooth toggle button is displayed");
         assertTrue(
                 "Bluetooth toggle button is not displayed",
                 mStatusBarHelper.get().hasBluetoothSwitch());
+        Log.i(LOG_TAG, "Assert: Bluetooth toggle button ON message is displayed");
         assertTrue(
                 "Bluetooth toggle button ON message is not displayed",
                 mStatusBarHelper.get().hasToggleOnMessage());
@@ -55,16 +60,21 @@ public class BluetoothPaletteTest {
 
     @Test
     public void testBluetoothDisableMessage() {
+        Log.i(LOG_TAG, "Act: Turn off Bluettooth.");
         mStatusBarHelper.get().turnOnOffBluetooth(false);
+        Log.i(LOG_TAG, "Assert: Bluetooth toggle OFF message is displayed");
         assertTrue(
                 "Bluetooth toggle button OFF message is not displayed ",
                 mStatusBarHelper.get().hasToggleOffMessage());
+        Log.i(LOG_TAG, "Act: Turn ON Bluettooth.");
         mStatusBarHelper.get().turnOnOffBluetooth(true);
     }
 
     @Test
     public void testOpenBluetoothSettings() {
+        Log.i(LOG_TAG, "Act: Open Bluetooth Settings");
         mStatusBarHelper.get().openBluetoothSettings();
+        Log.i(LOG_TAG, "Assert: Bluetooth settings page title is displayed");
         assertTrue(
                 "Bluetooth settings page title is not displayed",
                 mStatusBarHelper.get().hasBluetoothSettingsPageTitle());
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java
index f8fa809ba..f07657fef 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java
@@ -23,6 +23,7 @@ import android.platform.helpers.IAutoStatusBarHelper;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -35,6 +36,7 @@ public class CurrentDateTimeTest {
     @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
+    private static final String LOG_TAG = CurrentDateTimeTest.class.getSimpleName();
 
     public CurrentDateTimeTest() {
         mStatusBarHelper = new HelperAccessor<>(IAutoStatusBarHelper.class);
@@ -43,6 +45,7 @@ public class CurrentDateTimeTest {
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testCurrentTime() {
+        Log.i(LOG_TAG, "Assert: Current local time");
         assertEquals(
                 "Current local Time",
                 mStatusBarHelper.get().getClockTime(),
@@ -53,6 +56,7 @@ public class CurrentDateTimeTest {
 
     @Test
     public void testCurrentTimeZone() {
+        Log.i(LOG_TAG, "Assert: Current local time zone");
         assertEquals(
                 "Current local Time Zone",
                 mStatusBarHelper.get().getCurrentTimeZone(),
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
index e49161e70..4c7703a8a 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
@@ -23,6 +23,7 @@ import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoStatusBarHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -38,6 +39,7 @@ public class NetworkPaletteTest {
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
     private static final String HOTSPOT = AutomotiveConfigConstants.NETWORK_PALETTE_HOTSPOT;
     private static final String WIFI = AutomotiveConfigConstants.NETWORK_PALETTE_WIFI;
+    private static final String LOG_TAG = NetworkPaletteTest.class.getSimpleName();
 
     public NetworkPaletteTest() {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
@@ -46,7 +48,9 @@ public class NetworkPaletteTest {
 
     @Before
     public void openNetworkPalette() {
+        Log.i(LOG_TAG, "Act: Open Network Palette.");
         mStatusBarHelper.get().openNetworkPalette();
+        Log.i(LOG_TAG, "Assert: Bluetooth Palette is open");
         assertTrue(
                 "Network Palette is not open",
                 mSettingHelper.get().checkMenuExists("Network & internet settings"));
@@ -59,59 +63,67 @@ public class NetworkPaletteTest {
 
     @Test
     public void testHotspotName() {
-        // check if hotspot is enabled
+        Log.i(LOG_TAG, "Act: Enable the hotspot");
         if (!mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT)) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
         }
+        Log.i(LOG_TAG, "Assert: Hotspot Name and password is displayed");
         assertTrue(
                 "Hotspot Name and password is not displayed",
                 mStatusBarHelper.get().isHotspotNameDisplayed());
-        // Turn off the Hotspot
+        Log.i(LOG_TAG, "Act: Turn Off the hotspot");
         mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
+        Log.i(LOG_TAG, "Assert: Hotspot is not enabled");
         assertFalse("Hotspot is enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
     }
 
     @Test
     public void testWifiName() {
-        // check if wifi is enabled
+        Log.i(LOG_TAG, "Act: Enable the wifi");
         if (!mSettingHelper.get().isWifiOn()) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         }
-        // Verifying Wifi is turned ON
+        Log.i(LOG_TAG, "Assert: Wifi is turned ON and Wifi name is displayed");
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue("Wi-Fi Name is not displayed", mStatusBarHelper.get().isWifiNameDisplayed());
-        // Turn off Wifi
+        Log.i(LOG_TAG, "Act: Turn Off Wifi");
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        Log.i(LOG_TAG, "Assert: Wifi is not enabled");
         assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
-        // Verifying Wifi is turned ON again
+        Log.i(LOG_TAG, "Act: Enable the wifi again");
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        Log.i(LOG_TAG, "Assert: Wifi is turned ON and Wifi name is displayed");
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue("Wi-Fi Name is not displayed", mStatusBarHelper.get().isWifiNameDisplayed());
-        // Turn off Wifi
+        Log.i(LOG_TAG, "Act: Turn Off Wifi");
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        Log.i(LOG_TAG, "Assert: Wifi is not enabled");
         assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
     }
 
     @Test
     public void testWifiAndHotspotEnabledTogether() {
-        // check if wifi and hostpot is enabled
+        Log.i(LOG_TAG, "Act: Check and Enable the wifi & hotspot");
         if (!mSettingHelper.get().isWifiOn()) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         }
         if (!mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT)) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
         }
+        Log.i(LOG_TAG, "Assert: Wifi and hotpsot are turned ON");
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue(
                 "Hotspot is not enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
-        // Turn off Wifi and Hotspot
+        Log.i(LOG_TAG, "Act: Turn Off Wifi and Hotspot");
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
+        Log.i(LOG_TAG, "Assert: Wifi and Hotsport are not enabled");
         assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
         assertFalse("Hotspot is enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
-        // Turn on Wifi and Hotspot
+        Log.i(LOG_TAG, "Act: Turn on Wifi and Hotspot");
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
+        Log.i(LOG_TAG, "Assert: Wifi and Hotsport are enabled");
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue(
                 "Hotspot is not enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
@@ -119,17 +131,22 @@ public class NetworkPaletteTest {
 
     @Test
     public void testNetworkAndinternetSettings() {
+        Log.i(LOG_TAG, "Act: Open the network settings");
         mSettingHelper.get().openMenuWith("Network & internet settings");
+        Log.i(LOG_TAG, "Act: Click on Connected Wifi");
         mStatusBarHelper.get().clickOnConnectedWifi();
+        Log.i(LOG_TAG, "Act: Forget the Wifi");
         mStatusBarHelper.get().forgetWifi();
+        Log.i(LOG_TAG, "Act: Open the Network Palette");
         openNetworkPalette();
-        // check if wifi and hostpot is enabled
+        Log.i(LOG_TAG, "Act: Check and Enable the wifi & hotspot");
         if (!mSettingHelper.get().isWifiOn()) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         }
         if (!mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT)) {
             mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
         }
+        Log.i(LOG_TAG, "Assert: Wifi and Hotsport are enabled");
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue(
                 "Hotspot is not enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/SoundPaletteTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/SoundPaletteTest.java
index e63dfa142..f19259b5e 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/SoundPaletteTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/SoundPaletteTest.java
@@ -21,6 +21,7 @@ import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoStatusBarHelper;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -34,6 +35,8 @@ public class SoundPaletteTest {
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
 
+    private static final String LOG_TAG = SoundPaletteTest.class.getSimpleName();
+
     public SoundPaletteTest() {
         mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
         mStatusBarHelper = new HelperAccessor<>(IAutoStatusBarHelper.class);
@@ -53,18 +56,26 @@ public class SoundPaletteTest {
 
     @Test
     public void testSoundPaletteOnStatusBar() {
+        Log.i(LOG_TAG, "Act: Open Sound Palette On Status Bar.");
         mStatusBarHelper.get().openSoundPaletteOnStatusBar();
+        Log.i(LOG_TAG, "Assert: In-call Volume is displayed");
         assertTrue(
                 "In-call Volume is not displayed on Sound Palette",
                 mStatusBarHelper.get().isUIButtonPresentOnSoundPalette(AutomotiveConfigConstants.SOUND_SETTING_INCALL));
+        Log.i(LOG_TAG, "Assert: Media Volume is displayed on Sound Palette");
         assertTrue(
-                "Media Voulme is not displayed on Sound Palette",
-                mStatusBarHelper.get().isUIButtonPresentOnSoundPalette(AutomotiveConfigConstants.SOUND_PALETTE_MEDIA));
+                "Media Volume is not displayed on Sound Palette",
+                mStatusBarHelper
+                        .get()
+                        .isUIButtonPresentOnSoundPalette(
+                                AutomotiveConfigConstants.SOUND_PALETTE_MEDIA));
+        Log.i(LOG_TAG, "Assert: Navigation Volume is displayed on Sound Palette");
         assertTrue(
                 "Navigation Volume is not displayed on Sound Palette",
                 mStatusBarHelper
                         .get()
                         .isUIButtonPresentOnSoundPalette(AutomotiveConfigConstants.SOUND_PALETTE_NAVIGATION));
+        Log.i(LOG_TAG, "Assert: Sound Settings Volume is displayed on Sound Palette");
         assertTrue(
                 "Sound Settings is not displayed on Sound Palette",
                 mStatusBarHelper
@@ -74,8 +85,11 @@ public class SoundPaletteTest {
 
     @Test
     public void testSoundSettingsButton() {
+        Log.i(LOG_TAG, "Act: Open Sound Palette On Status Bar.");
         mStatusBarHelper.get().openSoundPaletteOnStatusBar();
+        Log.i(LOG_TAG, "Act: Open Sound Settings");
         mStatusBarHelper.get().openSoundSettings();
+        Log.i(LOG_TAG, "Assert: Sound Settings is opened");
         assertTrue(
                 "Sound settings page is not opened",
                 mStatusBarHelper.get().hasSoundSettingsPageTitle());
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/StatusBarTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/StatusBarTest.java
index ffae0cf8c..04f19ba22 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/StatusBarTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/StatusBarTest.java
@@ -25,6 +25,7 @@ import android.platform.helpers.IAutoStatusBarHelper;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -40,6 +41,8 @@ public class StatusBarTest {
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
     private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
 
+    private static final String LOG_TAG = StatusBarTest.class.getSimpleName();
+
     public StatusBarTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
         mStatusBarHelper = new HelperAccessor<>(IAutoStatusBarHelper.class);
@@ -47,28 +50,50 @@ public class StatusBarTest {
 
     @Test
     public void testToverifyDefaultStatusbar() {
-        assertTrue("Bluetooth Button is not displayed", mHomeHelper.get().hasBluetoothButton());
-        assertTrue("Network Button is not displayed", mHomeHelper.get().hasNetworkButton());
-        assertTrue("Brightness Button is not displayed", mHomeHelper.get().hasDisplayBrightness());
+        for (int i = 0; i < 2; i++) {
+            Log.i(LOG_TAG, "Assert:  Bluetooth Button is not displayed.");
+            assertTrue("Bluetooth Button is not displayed", mHomeHelper.get().hasBluetoothButton());
+            Log.i(LOG_TAG, "Act: Open Bluetooth palette");
+            mHomeHelper.get().openBluetoothButton();
+            Log.i(LOG_TAG, "Assert:  Network Button is not displayed.");
+            assertTrue("Network Button is not displayed", mHomeHelper.get().hasNetworkButton());
+            Log.i(LOG_TAG, "Act:  Open Network palette");
+            mHomeHelper.get().openNetworkPalette();
+            Log.i(LOG_TAG, "Assert:  Brightness Button is not displayed.");
+            assertTrue(
+                    "Brightness Button is not displayed", mHomeHelper.get().hasDisplayBrightness());
+            Log.i(LOG_TAG, "Act:  Open Brightness palette");
+            mHomeHelper.get().openBrightnessPalette();
+            Log.i(LOG_TAG, "Assert:  Sound settings button is not displayed.");
+            assertTrue(
+                    "Sound settings Button is not displayed", mHomeHelper.get().hasSoundSettings());
+            Log.i(LOG_TAG, "Act:  Open Sound setting palette");
+            mHomeHelper.get().openSoundSettingsPalette();
+            Log.i(LOG_TAG, "Act: Press home screen");
+            mHomeHelper.get().open();
+        }
     }
 
     @Test
     public void testToVerifyChangeToDayMode() {
+        Log.i(LOG_TAG, "Assert: Able to change to day mode");
         assertTrue("Unable to change to day mode", mStatusBarHelper.get().changeToDayMode());
-        // Constant value is 1 for Night mode no
+        Log.i(LOG_TAG, "Assert: Constant value is 1 for Night mode no");
         assertEquals(1, mStatusBarHelper.get().getCurrentDisplayMode());
     }
 
     @Test
     public void testToVerifyChangeToNightMode() {
+        Log.i(LOG_TAG, "Assert: Able to change to night day mode");
         assertTrue("Unable to change to night mode", mStatusBarHelper.get().changeToNightMode());
-        // Constant value is 2 for Night mode yes
+        Log.i(LOG_TAG, "Assert: Constant value is 2 for Night mode yes");
         assertEquals(2, mStatusBarHelper.get().getCurrentDisplayMode());
     }
 
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testClockTime() {
+        Log.i(LOG_TAG, "Assert: Clock time is displayed on Status Bar.");
         assertEquals(
                 "Clock time in Status bar is not displayed",
                 mStatusBarHelper.get().getClockTime(),
diff --git a/tests/automotive/functional/uxrestriction/src/android/platform/tests/DrivingOptimizedAppsTest.java b/tests/automotive/functional/uxrestriction/src/android/platform/tests/DrivingOptimizedAppsTest.java
index fd1c05acf..e6c80849e 100644
--- a/tests/automotive/functional/uxrestriction/src/android/platform/tests/DrivingOptimizedAppsTest.java
+++ b/tests/automotive/functional/uxrestriction/src/android/platform/tests/DrivingOptimizedAppsTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoFacetBarHelper;
 import android.platform.helpers.IAutoNotificationHelper;
 import android.platform.helpers.IAutoVehicleHardKeysHelper;
 import android.platform.helpers.IAutoVehicleHardKeysHelper.DrivingState;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -45,6 +46,7 @@ public class DrivingOptimizedAppsTest {
     private static final String NOTIFICATION_TITLE = "Check recent permissions";
     private static final String APP_PERMISSIONS = "App permissions";
     private static final int SPEED_TWENTY = 20;
+    private static final String LOG_TAG = DrivingOptimizedAppsTest.class.getSimpleName();
 
     public DrivingOptimizedAppsTest() throws Exception {
         mAppGridHelper = new HelperAccessor<>(IAutoAppGridHelper.class);
@@ -56,20 +58,27 @@ public class DrivingOptimizedAppsTest {
 
     @Before
     public void enableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Set Driving State to Moving");
         mHardKeysHelper.get().setDrivingState(DrivingState.MOVING);
+        Log.i(LOG_TAG, "Act: Set Driving Sped to Twenty");
         mHardKeysHelper.get().setSpeed(SPEED_TWENTY);
     }
 
     @After
     public void disableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Go to Homescreen");
         mAppGridHelper.get().goToHomePage();
+        Log.i(LOG_TAG, "Act: Set Driving State to Parking");
         mHardKeysHelper.get().setDrivingState(DrivingState.PARKED);
     }
 
     @Test
     public void testOpenSettings() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open Settings");
         mAppGridHelper.get().openApp("Settings");
+        Log.i(LOG_TAG, "Assert: Settings is open");
         assertTrue(
                 "Settings app is not open",
                 mAppGridHelper
@@ -79,8 +88,11 @@ public class DrivingOptimizedAppsTest {
 
     @Test
     public void testOpenRadio() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open Radio App");
         mAppGridHelper.get().openApp("Radio");
+        Log.i(LOG_TAG, "Assert: Radio App is open");
         assertTrue(
                 "Radio app is not open",
                 mAppGridHelper
@@ -90,8 +102,11 @@ public class DrivingOptimizedAppsTest {
 
     @Test
     public void testOpenPhone() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open Radio App");
         mAppGridHelper.get().openApp("Phone");
+        Log.i(LOG_TAG, "Assert: Phone App is open");
         assertTrue(
                 "Phone is not open",
                 mAppGridHelper
@@ -106,20 +121,29 @@ public class DrivingOptimizedAppsTest {
      */
     @Test
     public void testOpenContactsAndVerifyPostDriveNotification() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Open Contacts App");
         mAppGridHelper.get().openApp("Contacts");
+        Log.i(LOG_TAG, "Act: Dismiss pop-up dialog");
         mContactHelper.get().dismissInitialDialogs();
+        Log.i(LOG_TAG, "Assert: Contacts is open");
         assertTrue(
                 "Contacts is not open",
                 mAppGridHelper
                         .get()
                         .checkPackageInForeground(AutomotiveConfigConstants.CONTACTS_PACKAGE));
+        Log.i(LOG_TAG, "Act: Disable Driving Mode");
         disableDrivingMode();
+        Log.i(LOG_TAG, "Act: Open Notifications");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.NOTIFICATION);
+        Log.i(LOG_TAG, "Assert: Recent Permission is notified");
         assertTrue(
                 "Recent Permission is not Notified",
                 mNotificationHelper.get().checkNotificationExists(NOTIFICATION_TITLE));
+        Log.i(LOG_TAG, "Act: Open Recent Permission");
         mNotificationHelper.get().clickOnCheckRecentPermissions(NOTIFICATION_TITLE);
+        Log.i(LOG_TAG, "Act: Open App Permission is launched");
         assertTrue(
                 "App Permissions page is not launched",
                 mNotificationHelper.get().checkAppPermissionsExists(APP_PERMISSIONS));
diff --git a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
index 82a3a14d7..e4d9367b8 100644
--- a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
+++ b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoVehicleHardKeysHelper.DrivingState;
 import android.platform.test.rules.ConditionalIgnore;
 import android.platform.test.rules.ConditionalIgnoreRule;
 import android.platform.test.rules.IgnoreOnPortrait;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -42,6 +43,7 @@ public class UxRestrictionFacetBarTest {
     private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
     private HelperAccessor<IAutoFacetBarHelper> mFacetBarHelper;
     private HelperAccessor<IAutoVehicleHardKeysHelper> mHardKeysHelper;
+    private static final String LOG_TAG = UxRestrictionFacetBarTest.class.getSimpleName();
 
     private static final int SPEED_TWENTY = 20;
     private static final int SPEED_ZERO = 0;
@@ -55,23 +57,32 @@ public class UxRestrictionFacetBarTest {
 
     @Before
     public void enableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Go to Home Screen");
         mFacetBarHelper.get().goToHomeScreen();
+        Log.i(LOG_TAG, "Act: Set Driving State to Moving");
         mHardKeysHelper.get().setDrivingState(DrivingState.MOVING);
+        Log.i(LOG_TAG, "Act: Set Driving Speed to Twenty");
         mHardKeysHelper.get().setSpeed(SPEED_TWENTY);
     }
 
     @After
     public void disableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Go to Homescreen");
         mFacetBarHelper.get().goToHomeScreen();
+        Log.i(LOG_TAG, "Act: Set Driving Speed to zero");
         mHardKeysHelper.get().setSpeed(SPEED_ZERO);
+        Log.i(LOG_TAG, "Act: Set Driving State to Parked");
         mHardKeysHelper.get().setDrivingState(DrivingState.PARKED);
     }
 
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testRestrictedHomeFacetBar() {
+        Log.i(LOG_TAG, "Act: Open App Grid");
         mAppGridHelper.get().open();
+        Log.i(LOG_TAG, "Act: Click on Home Facet Icon");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.HOME);
+        Log.i(LOG_TAG, "Assert: Home screen is open");
         assertTrue(
                 "Home screen did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.HOME));
@@ -80,7 +91,9 @@ public class UxRestrictionFacetBarTest {
     @Test
     @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testRestrictedPhoneFacetBar() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Phone App");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.PHONE);
+        Log.i(LOG_TAG, "Assert: Phone App is open");
         assertTrue(
                 "Phone app did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.PHONE));
@@ -88,7 +101,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedHvacFacetBar() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Hvac App");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.HVAC);
+        Log.i(LOG_TAG, "Assert: Havc app is open");
         assertTrue(
                 "Hvac did not open",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.HVAC));
@@ -96,7 +111,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedAppGridFacetBar() {
+        Log.i(LOG_TAG, "Act: Open Facetbar App Grid");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.APP_GRID);
+        Log.i(LOG_TAG, "Assert: App Grid is open");
         assertTrue(
                 "App grid did not open",
                 mFacetBarHelper
@@ -106,7 +123,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedNotificationFacetBar() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Notification");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.NOTIFICATION);
+        Log.i(LOG_TAG, "Assert: Notification is open");
         assertTrue(
                 "Notification did not open.",
                 mFacetBarHelper
@@ -116,7 +135,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedBluetoothPalette() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Bluetooth App");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.BLUETOOTH);
+        Log.i(LOG_TAG, "Assert: Bluetooth menu is open");
         assertTrue(
                 "Bluetooth palette did not open.",
                 mFacetBarHelper
@@ -126,7 +147,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedWifiPalette() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Wifi");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.WIFI);
+        Log.i(LOG_TAG, "Assert: Wifi menu is open");
         assertTrue(
                 "Wifi palette did not open.",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.WIFI));
@@ -134,7 +157,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedBrighnessPalette() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Brightness");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.BRIGHTNESS);
+        Log.i(LOG_TAG, "Assert: Brightness menu is open");
         assertTrue(
                 "Brightness palette did not open.",
                 mFacetBarHelper
@@ -144,7 +169,9 @@ public class UxRestrictionFacetBarTest {
 
     @Test
     public void testRestrictedSoundPalette() {
+        Log.i(LOG_TAG, "Act: Open Facetbar Sound");
         mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.SOUND);
+        Log.i(LOG_TAG, "Act: Facetbar Sound is open");
         assertTrue(
                 "Sound palette did not open.",
                 mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.SOUND));
diff --git a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionTest.java b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionTest.java
index 6d6177ebb..c36945e41 100644
--- a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionTest.java
+++ b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionTest.java
@@ -26,6 +26,7 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoVehicleHardKeysHelper;
 import android.platform.helpers.IAutoVehicleHardKeysHelper.DrivingState;
 import android.platform.helpers.SettingsConstants;
+import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -39,6 +40,7 @@ public class UxRestrictionTest {
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
     private HelperAccessor<IAutoVehicleHardKeysHelper> mHardKeysHelper;
+    private static final String LOG_TAG = UxRestrictionTest.class.getSimpleName();
 
     private static final int SPEED_TWENTY = 20;
     private static final int SPEED_ZERO = 0;
@@ -51,99 +53,147 @@ public class UxRestrictionTest {
 
     @Before
     public void enableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Set Driving State to Moving");
         mHardKeysHelper.get().setDrivingState(DrivingState.MOVING);
+        Log.i(LOG_TAG, "Act: Set Driving speed to twenty");
         mHardKeysHelper.get().setSpeed(SPEED_TWENTY);
     }
 
     @After
     public void disableDrivingMode() {
+        Log.i(LOG_TAG, "Act: Back to Settings");
         mSettingHelper.get().goBackToSettingsScreen();
+        Log.i(LOG_TAG, "Act: Set Driving speed to twenty");
         mHardKeysHelper.get().setSpeed(SPEED_ZERO);
+        Log.i(LOG_TAG, "Act: Set Driving State to Parking");
         mHardKeysHelper.get().setDrivingState(DrivingState.PARKED);
     }
 
     @Test
     public void testRestrictedSoundSettings() {
+        Log.i(LOG_TAG, "Act: Open Sound Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SOUND_SETTINGS);
+        Log.i(LOG_TAG, "Act: Get Page Title");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Sound Setting is open");
         assertTrue(
                 "Sound setting did not open",
                 mSettingHelper
                         .get()
                         .scrollAndCheckMenuExists(AutomotiveConfigConstants.SOUND_SETTING_INCALL));
+        Log.i(LOG_TAG, "Act: Open In call volume option");
         mSettingHelper.get().openMenuWith("In-call Volume");
+        Log.i(LOG_TAG, "Act: Get New Page Title");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Phone Ringtone Setting is disabled");
         assertTrue("Phone ringtone setting is not disabled", currentTitle.equals(newTitle));
     }
 
     @Test
     public void testRestrictedNetworkSettings() {
+        Log.i(LOG_TAG, "Act: Open Network & Internet Setting");
         mSettingHelper.get().openSetting(SettingsConstants.NETWORK_AND_INTERNET_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Network and Internet settings is Open");
         assertTrue(
                 "Network and Internet settings did not open",
                 mSettingHelper.get().checkMenuExists("Hotspot"));
+        Log.i(LOG_TAG, "Act: Get Current Hotspot State");
         Boolean currentHotspotState = mSettingHelper.get().isHotspotOn();
+        Log.i(LOG_TAG, "Act: Toggle hotspot on");
         mSettingHelper.get().toggleHotspot();
+        Log.i(LOG_TAG, "Act: Get status of Hotspot state");
         Boolean newHotspotState = mSettingHelper.get().isHotspotOn();
+        Log.i(LOG_TAG, "Act: Hotspot is working");
         assertFalse("Hotspot is not working", currentHotspotState.equals(newHotspotState));
+        Log.i(LOG_TAG, "Act: Toggle hotspot off");
         mSettingHelper.get().toggleHotspot();
     }
 
     @Test
     public void testRestrictedBluetoothSettings() {
+        Log.i(LOG_TAG, "Act: Open Bluetooth Setting");
         mSettingHelper.get().openSetting(SettingsConstants.BLUETOOTH_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Bluetooth Setting is On");
         assertTrue(
                 "Bluetooth Setting did not open",
                 mSettingHelper.get().checkMenuExists("Pair new device"));
+        Log.i(LOG_TAG, "Act: Get Page Title text");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Act: Pair new device");
         mSettingHelper.get().openMenuWith("Pair new device");
+        Log.i(LOG_TAG, "Act: Get new Page Title text");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Bluetooth Setting is disabled ");
         assertTrue("Bluetooth setting is not disabled", currentTitle.equals(newTitle));
     }
 
     @Test
     public void testRestrictedAppSettings() {
+        Log.i(LOG_TAG, "Act: Open Settings screen");
         mSettingHelper.get().openFullSettings();
+        Log.i(LOG_TAG, "Act: Get Page Title");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Act: Open Apps settings");
         mSettingHelper.get().openSetting(SettingsConstants.APPS_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Apps is disabled");
         assertFalse("Apps is not disabled", mSettingHelper.get().checkMenuExists("View all"));
+        Log.i(LOG_TAG, "Act: Get New Page Title");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Apps is disabled");
         assertTrue("Apps & notification settings is not disabled", currentTitle.equals(newTitle));
     }
 
     @Test
     public void testRestrictedProfilesAndAccountsSettings() {
+        Log.i(LOG_TAG, "Act: Open Settings");
         mSettingHelper.get().openFullSettings();
+        Log.i(LOG_TAG, "Act: Get Page Title");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Act: Open Profile Account Setting");
         mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
+        Log.i(LOG_TAG, "Assert: Profile and Accounts Setting is disabled");
         assertFalse(
                 "Profiles and accounts settings is not disabled",
                 mSettingHelper.get().checkMenuExists("Add a profile"));
+        Log.i(LOG_TAG, "Act: Get New Page Title");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Profiles and Accounts is disabled");
         assertTrue("Profiles and accounts settings is not disabled", currentTitle.equals(newTitle));
     }
 
     @Test
     public void testRestrictedSecuritySettings() {
+        Log.i(LOG_TAG, "Act: Open Settings");
         mSettingHelper.get().openFullSettings();
+        Log.i(LOG_TAG, "Act: Get Page Title");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Act: Open Security Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SECURITY_SETTINGS);
+        Log.i(LOG_TAG, "Act: Security Setting is disabled");
         assertFalse(
                 "Security settings is not disabled",
                 mSettingHelper.get().checkMenuExists("Profile lock"));
+        Log.i(LOG_TAG, "Act: Get New Page Title");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: Secutiy setting is disabled");
         assertTrue("Security settings is not disabled", currentTitle.equals(newTitle));
     }
 
     @Test
     public void testRestrictedSystemSettings() {
+        Log.i(LOG_TAG, "Act: Open Settings");
         mSettingHelper.get().openFullSettings();
+        Log.i(LOG_TAG, "Act: Get Page Title");
         String currentTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Act: Open System Setting");
         mSettingHelper.get().openSetting(SettingsConstants.SYSTEM_SETTINGS);
+        Log.i(LOG_TAG, "Assert: System Setting is disabled");
         assertFalse(
                 "System settings is not disabled",
                 mSettingHelper.get().checkMenuExists("Languages & input"));
+        Log.i(LOG_TAG, "Act: Get New Page Title");
         String newTitle = mSettingHelper.get().getSettingsPageTitleText();
+        Log.i(LOG_TAG, "Assert: System Setting is disabled");
         assertTrue("System settings is not disabled", currentTitle.equals(newTitle));
     }
 }
diff --git a/tests/automotive/health/property/Android.bp b/tests/automotive/health/property/Android.bp
index d8be9d3ed..0b770f46d 100644
--- a/tests/automotive/health/property/Android.bp
+++ b/tests/automotive/health/property/Android.bp
@@ -39,6 +39,9 @@ android_test {
 
     srcs: ["src/**/*.java"],
     host_required: ["CarPropertyManagerStressTestLogPostProcessor"],
+    host_common_data: [
+        ":CarPropertyManagerStressTestLogPostProcessor",
+    ],
     min_sdk_version: "28",
     test_suites: [
         "general-tests",
diff --git a/tests/automotive/mobly_tests/bluetooth_base_test.py b/tests/automotive/mobly_tests/bluetooth_base_test.py
index 4bcf4cec3..fe2fb01a1 100644
--- a/tests/automotive/mobly_tests/bluetooth_base_test.py
+++ b/tests/automotive/mobly_tests/bluetooth_base_test.py
@@ -56,10 +56,11 @@ class BluetoothBaseTest(base_test.BaseTestClass):
         self.call_utils.press_home()
         logging.info("Running basic test setup.")
         logging.info("\tEnabling bluetooth on Target and Discoverer.")
-        self.target.mbs.btEnable()
-        self.discoverer.mbs.btEnable()
+        self.target.mbs.btEnableWithLongerWait()
+        self.discoverer.mbs.btEnableWithLongerWait()
 
     def teardown_test(self):
+        android_device.take_bug_reports(self.ads, destination=self.log_path)
         # Turn Bluetooth off on both devices.
         logging.info("Running basic test teardown.")
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/bluetooth_sms_base_test.py b/tests/automotive/mobly_tests/bluetooth_sms_base_test.py
index 906828b21..b4854ad8a 100644
--- a/tests/automotive/mobly_tests/bluetooth_sms_base_test.py
+++ b/tests/automotive/mobly_tests/bluetooth_sms_base_test.py
@@ -49,17 +49,28 @@ class BluetoothSMSBaseTest(bluetooth_base_test.BluetoothBaseTest):
         self.target,
         self.__class__.__name__,
     )
-
-    logging.info('Enabling video recording for Discoverer device')
-    self.video_utils_service.enable_screen_recording()
-
-    logging.info('Enabling video recording for Target device')
-    self.video_utils_service_target.enable_screen_recording()
-
+    self.video_utils_service_phone_notpaired = VideoRecording(
+        self.phone_notpaired,
+        self.__class__.__name__,
+    )
     self.call_utils.press_phone_home_icon_using_adb_command(
         self.phone_notpaired
     )
 
+  def hu_recording_handler(self):
+    super().hu_recording_handler()
+    logging.info("Stopping the screen recording on phone_notpaired")
+    self.video_utils_service_phone_notpaired.stop_screen_recording()
+    logging.info("Pull the screen recording from phone_notpaired")
+    self.video_utils_service_phone_notpaired.pull_recording_file(self.log_path)
+    logging.info("delete the screen recording from phone_notpaired")
+    self.video_utils_service_phone_notpaired.delete_screen_recording_from_device()
+
+  def enable_recording(self):
+    super().enable_recording()
+    logging.info("Enabling video recording for phone_notpaired")
+    self.video_utils_service_phone_notpaired.enable_screen_recording()
+    logging.info("Video recording started on phone_notpaired")
 
 if __name__ == '__main__':
   common_main()
diff --git a/tests/automotive/mobly_tests/connectivity/Android.bp b/tests/automotive/mobly_tests/connectivity/Android.bp
index 54783264e..6aa79334a 100644
--- a/tests/automotive/mobly_tests/connectivity/Android.bp
+++ b/tests/automotive/mobly_tests/connectivity/Android.bp
@@ -105,6 +105,28 @@ python_test_host {
     ],
 }
 
+python_test_host {
+    name: "BTConnectionStatusOnSettings",
+    main: "connectivity_test_status_displayed_in_settings.py",
+    srcs: ["connectivity_test_status_displayed_in_settings.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+}
+
 python_test_host {
     name: "BTDisableMedia",
     main: "connectivity_test_disable_media.py",
@@ -127,6 +149,28 @@ python_test_host {
     ],
 }
 
+python_test_host {
+    name: "BTMediaStatusOnMediaCenter",
+    main: "connectivity_test_disable_media_displayed_in_media_center.py",
+    srcs: ["connectivity_test_disable_media_displayed_in_media_center.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+}
+
 python_test_host {
     name: "BTDisablePhone",
     main: "connectivity_test_disable_phone.py",
@@ -149,6 +193,28 @@ python_test_host {
     ],
 }
 
+python_test_host {
+    name: "BTDisableFromPhone",
+    main: "connectivity_test_disable_from_phone.py",
+    srcs: ["connectivity_test_disable_from_phone.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+}
+
 python_test_host {
     name: "BTProfilesTest",
     main: "connectivity_test_bluetooth_profile.py",
@@ -224,3 +290,30 @@ python_test_host {
         },
     },
 }
+
+python_test_host {
+    name: "BluetoothForgetDeviceFromSettingsTest",
+    main: "connectivity_test_forget_remove_device_from_settings.py",
+    srcs: ["connectivity_test_forget_remove_device_from_settings.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_from_phone.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_from_phone.py
new file mode 100644
index 000000000..452a5d085
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_from_phone.py
@@ -0,0 +1,65 @@
+"""
+  Copyright (C) 2025 The Android Open Source Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+
+
+  Test Steps:
+  (0. Flash device)
+  1. Pair Mobile device
+  2. Mobile Device:  disconnect IVI-Bluetooth Device
+  3. IVI: Go to Settings - Bluetooth
+  Verify: Paired Device connection status changed from Connected to Disconnected
+  4. Android Devices:Mobile Device:  Launch Settings - Bluetooth - Connect IVI Bluetooth Device
+  Verify:Mobile device reconnected in both Phone and  IVI. Status connected displayed in paired device
+
+"""
+
+import logging
+
+from mobly import asserts
+from utilities.main_utils import common_main
+from bluetooth_test import bluetooth_base_test
+from mobly.controllers import android_device
+from utilities import constants
+
+class BluetoothDisableFromPhone(bluetooth_base_test.BluetoothBaseTest):
+
+    def setup_test(self):
+        # Pair caller phone with automotive device
+        self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
+
+    def test_disable_from_phone(self):
+        self.discoverer = android_device.get_device(self.ads, label='auto')
+        self.target = android_device.get_device(self.ads, label='phone')
+        self.call_utils.open_bluetooth_settings()
+
+        #Disconnect seahawk device from mobile phone and verify it is reflected in seahawk device
+        self.target.mbs.btDisable()
+        self.discoverer.mbs.waitUntilConnectionStatus(constants.DISCONNECTED_SUMMARY_STATUS)
+        asserts.assert_true(
+            self.discoverer.mbs.hasUIElementWithText(constants.DISCONNECTED_SUMMARY_STATUS),
+            'Failed to disconnect from mobile device')
+
+        #Connect seahawk device from mobile phone and verify it is reflected in seahawk device
+        self.target.mbs.btEnableWithLongerWait()
+        self.discoverer.mbs.waitUntilConnectionStatus(constants.CONNECTED_SUMMARY_STATUS)
+        asserts.assert_true(
+            self.discoverer.mbs.hasUIElementWithText(constants.CONNECTED_SUMMARY_STATUS),
+            'Failed to connect from mobile device')
+
+if __name__ == '__main__':
+    # Take test args
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media.py
index 373e8b930..a5699c7f7 100644
--- a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media.py
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media.py
@@ -17,8 +17,12 @@
 
   Test Steps:
   (0. Flash device)
-  1. Verify by default BT should be ON always
-  2. BluetoothManagerService: Startup: Bluetooth persisted state is ON
+  1. Pair Bluetooth Device
+  2. Launch Settings - Bluetooth page
+  3. Tap Media button in L1
+  2. Tap Bluetooth Device name in L1
+  5. Verfy Connected (No media ) Displayed in L2
+  6. Repeat -  Disconnect - Connect Media  profile from L1 several times and verify Connected (No Media) status displayed in L2
 
 """
 
@@ -45,44 +49,43 @@ class BluetoothDisableEnableMediaTest(bluetooth_base_test.BluetoothBaseTest):
         bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
         logging.info("BT State after pairing : <%s>", bt_connection_state)
 
-        # Navigate to the bluetooth settings page
-        self.call_utils.open_bluetooth_settings()
-        # Disable media for the listed paired device via the preference button
-        self.call_utils.press_media_toggle_on_device(self.target_name)
-        # Confirm that the media button is unchecked
-        asserts.assert_false(
-            self.discoverer.mbs.isMediaPreferenceChecked(),
-            "Expected media button to be unchecked after pressing it.")
-        self.call_utils.wait_with_log(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
-
-        # Click on device and confirm that the summary says "No media"
-        self.discoverer.mbs.pressDeviceInBluetoothSettings(self.target_name)
-        self.call_utils.wait_with_log(constants.WAIT_FOR_LOAD)
-        summary = self.discoverer.mbs.getDeviceSummary()
-        asserts.assert_true(
-            self.NO_MEDIA_TAG in summary,
-            ("Expected device summary (on Level Two page) to include \'%s\'" % self.NO_MEDIA_TAG)
-        )
-        self.call_utils.wait_with_log(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
-
-        # Go back to the bluetooth settings page and enable media via the preference button
-        self.call_utils.press_home()
-        self.call_utils.open_bluetooth_settings()
-        self.call_utils.press_media_toggle_on_device(self.target_name)
-
-        # Confirm that the media button is re-enabled
-        asserts.assert_true(
-            self.discoverer.mbs.isMediaPreferenceChecked(),
-            "Expected media button to be checked after pressing it a second time.")
-
-        # Click on the device and confirm that the summary doesn't include "media"
-        self.discoverer.mbs.pressDeviceInBluetoothSettings(self.target_name)
-        self.call_utils.wait_with_log(constants.WAIT_FOR_LOAD)
-        summary = self.discoverer.mbs.getDeviceSummary()
-        asserts.assert_false(
-            self.NO_MEDIA_TAG in summary,
-        "Found unexpected \'%s\' in device summary after re-enabling media." % self.NO_MEDIA_TAG
-        )
+        for i in range(0,2):
+          # Navigate to the bluetooth settings page
+          self.call_utils.open_bluetooth_settings()
+          # Disable media for the listed paired device via the preference button
+          self.call_utils.press_media_toggle_on_device(self.target_name)
+          # Confirm that the media button is unchecked
+          asserts.assert_false(
+              self.discoverer.mbs.isMediaPreferenceChecked(),
+              "Expected media button to be unchecked after pressing it.")
+
+          # Click on device and confirm that the summary says "No media"
+          self.discoverer.mbs.pressDeviceInBluetoothSettings(self.target_name)
+          summary = self.discoverer.mbs.getDeviceSummary()
+          asserts.assert_true(
+              self.NO_MEDIA_TAG in summary,
+              ("Expected device summary (on Level Two page) to include \'%s\'" % self.NO_MEDIA_TAG)
+          )
+
+          # Go back to the bluetooth settings page and enable media via the preference button
+          self.call_utils.press_home()
+          self.call_utils.open_bluetooth_settings()
+          self.call_utils.press_media_toggle_on_device(self.target_name)
+          self.discoverer.mbs.waitUntilConnectionStatus("Connected")
+
+          # Confirm that the media button is re-enabled
+          asserts.assert_true(
+              self.discoverer.mbs.isMediaPreferenceChecked(),
+              "Expected media button to be checked after pressing it a second time.")
+
+          # Click on the device and confirm that the summary doesn't include "media"
+          self.call_utils.open_bluetooth_settings()
+          self.discoverer.mbs.pressDeviceInBluetoothSettings(self.target_name)
+          summary = self.discoverer.mbs.getDeviceSummary()
+          asserts.assert_false(
+              self.NO_MEDIA_TAG in summary,
+          "Found unexpected \'%s\' in device summary after re-enabling media." % self.NO_MEDIA_TAG
+          )
 
 
 if __name__ == '__main__':
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media_displayed_in_media_center.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media_displayed_in_media_center.py
new file mode 100644
index 000000000..70e8c0efd
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_media_displayed_in_media_center.py
@@ -0,0 +1,85 @@
+"""
+  Copyright (C) 2023 The Android Open Source Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+
+
+  Test Steps:
+  (0. Flash device)
+  1. Pair Bluetooth Device with all supported profiles
+  2. Launch Settings - Bluetooth page
+  3. Tap the Media button. Verify: Media Button turns to Grey
+  4. Launch Media Center from Media Widget and verify no media displayed
+  5. Repeat Enable-Disable Media profile multiple times via Media button
+
+"""
+
+from mobly import asserts
+from utilities.main_utils import common_main
+from utilities.common_utils import CommonUtils
+from bluetooth_test import bluetooth_base_test
+from utilities import constants
+import logging
+
+class BluetoothMediaStatusOnMediaCenter(bluetooth_base_test.BluetoothBaseTest):
+
+    def setup_class(self):
+      super().setup_class()
+      self.common_utils = CommonUtils(self.target, self.discoverer)
+      super().enable_recording()
+      self.call_utils.press_home()
+
+    def setup_test(self):
+        # Pair the devices
+        self.common_utils.grant_local_mac_address_permission()
+        self.bt_utils.pair_primary_to_secondary()
+        self.target_name = self.target.mbs.btGetName()
+
+    def test_media_status_on_media_center(self):
+        # Log BT Connection State after pairing
+        bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
+        logging.info("BT State after pairing : <%s>", bt_connection_state)
+
+        for i in range(0,2):
+          # Navigate to the bluetooth settings page
+          self.call_utils.open_bluetooth_settings()
+          # Disable media for the listed paired device via the preference button
+          self.call_utils.press_media_toggle_on_device(self.target_name)
+          # Confirm that the media button is unchecked
+          asserts.assert_false(
+              self.discoverer.mbs.isMediaPreferenceChecked(),
+              "Expected media button to be unchecked after pressing it.")
+
+          # Launch media center and check media status is disconnected
+          self.call_utils.open_bluetooth_media_app()
+          asserts.assert_true(self.call_utils.is_connect_to_bluetooth_label_visible_on_bluetooth_audio_page(), "Connect to Bluetooth Label is not visible")
+
+          # Go back to the bluetooth settings page and enable media via the preference button
+          self.call_utils.press_home()
+          self.call_utils.open_bluetooth_settings()
+          self.call_utils.press_media_toggle_on_device(self.target_name)
+          self.call_utils.open_bluetooth_settings_form_status_bar()
+
+          # Confirm that the media button is re-enabled
+          asserts.assert_true(
+              self.discoverer.mbs.isMediaPreferenceChecked(),
+              "Expected media button to be checked after pressing it a second time.")
+
+          # Launch media center and check media status is connected
+          self.call_utils.open_bluetooth_media_app()
+          asserts.assert_false(self.call_utils.is_connect_to_bluetooth_label_visible_on_bluetooth_audio_page(), "Connect to Bluetooth Label is visible")
+
+if __name__ == '__main__':
+    # Take test args
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_phone.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_phone.py
index 9c5fe49e8..756253ddf 100644
--- a/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_phone.py
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disable_phone.py
@@ -44,50 +44,52 @@ class BluetoothDisableEnablePhoneTest(bluetooth_base_test.BluetoothBaseTest):
         bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
         logging.info("BT State after pairing : <%s>", bt_connection_state)
 
-        # Navigate to the bluetooth settings page
-        self.call_utils.open_bluetooth_settings()
-        target_name = self.target.mbs.btGetName()
-        # Disable phone for the listed paired device via the preference button
-        self.call_utils.press_phone_toggle_on_device(target_name)
-
-
-        # Confirm that the phone button is unchecked
-        asserts.assert_false(
-            self.discoverer.mbs.isPhonePreferenceChecked(),
-            "Expected phone button to be unchecked after pressing it.")
-        self.call_utils.wait_with_log(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
-
-
-        # Click on device and confirm that the summary says "No phone"
-        self.discoverer.mbs.pressDeviceInBluetoothSettings(target_name)
-        self.call_utils.wait_with_log(constants.WAIT_FOR_LOAD)
-        summary = self.discoverer.mbs.getDeviceSummary()
-        asserts.assert_true(
-            self.NO_PHONE_TAG in summary,
-            ("Expected device summary (on Level Two page) to include \'%s\'"
-             % self.NO_PHONE_TAG)
-        )
-        self.call_utils.wait_with_log(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
-
-        # Go back to the bluetooth settings page and enable phone via the preference button
-        self.call_utils.press_home()
-        self.call_utils.open_bluetooth_settings()
-        self.call_utils.press_phone_toggle_on_device(target_name)
-
-        # Confirm that the phone button is re-enabled
-        asserts.assert_true(
-            self.discoverer.mbs.isPhonePreferenceChecked(),
-            "Expected phone button to be checked after pressing it a second time.")
-
-        # Click on the device and confirm that the summary doesn't include "phone"
-        self.discoverer.mbs.pressDeviceInBluetoothSettings(target_name)
-        self.call_utils.wait_with_log(constants.WAIT_FOR_LOAD)
-        summary = self.discoverer.mbs.getDeviceSummary()
-        asserts.assert_false(
-            self.NO_PHONE_TAG in summary,
-            "Found unexpected \'%s\' in device summary after re-enabling phone."
-            % self.NO_PHONE_TAG
-        ) 
+        for _ in range(2):
+          # Navigate to the bluetooth settings page
+          self.call_utils.open_bluetooth_settings()
+          target_name = self.target.mbs.btGetName()
+          # Disable phone for the listed paired device via the preference button
+          self.call_utils.press_phone_toggle_on_device(target_name)
+
+
+          # Confirm that the phone button is unchecked
+          asserts.assert_false(
+              self.discoverer.mbs.isPhonePreferenceChecked(),
+              "Expected phone button to be unchecked after pressing it.")
+
+
+          # Click on device and confirm that the summary says "No phone"
+          self.discoverer.mbs.pressDeviceInBluetoothSettings(target_name)
+          summary = self.discoverer.mbs.getDeviceSummary()
+          asserts.assert_true(
+              self.NO_PHONE_TAG in summary,
+              ("Expected device summary (on Level Two page) to include \'%s\'"
+               % self.NO_PHONE_TAG)
+          )
+          self.call_utils.open_phone_app()
+          asserts.assert_true(
+               self.discoverer.mbs.isConnectToBluetoothDisplayed(),
+               "Connect to bluetooth message is not displayed")
+
+          # Go back to the bluetooth settings page and enable phone via the preference button
+          self.call_utils.press_home()
+          self.call_utils.open_bluetooth_settings()
+          self.call_utils.press_phone_toggle_on_device(target_name)
+          self.discoverer.mbs.waitUntilConnectionStatus("Connected")
+
+          # Confirm that the phone button is re-enabled
+          asserts.assert_true(
+              self.discoverer.mbs.isPhonePreferenceChecked(),
+              "Expected phone button to be checked after pressing it a second time.")
+
+          # Click on the device and confirm that the summary doesn't include "phone"
+          self.discoverer.mbs.pressDeviceInBluetoothSettings(target_name)
+          summary = self.discoverer.mbs.getDeviceSummary()
+          asserts.assert_false(
+              self.NO_PHONE_TAG in summary,
+              "Found unexpected \'%s\' in device summary after re-enabling phone."
+              % self.NO_PHONE_TAG
+          )
 
 
 
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_forget_remove_device_from_settings.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_forget_remove_device_from_settings.py
new file mode 100644
index 000000000..6a988c546
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_forget_remove_device_from_settings.py
@@ -0,0 +1,83 @@
+"""
+  Copyright (C) 2025 The Android Open Source Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+
+
+  Test Steps:
+  (0. Flash device)
+  1. Navigate to bluetooth settings
+  2.  press Paired device (on device listing) to Forget/remove paired device.
+
+"""
+
+import logging
+from mobly import asserts
+from utilities import constants
+from utilities.main_utils import common_main
+from bluetooth_test import bluetooth_base_test
+from utilities.common_utils import CommonUtils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib.snippet_client_v2 import Config
+
+
+class BluetoothForgetDeviceFromSettingsTest(bluetooth_base_test.BluetoothBaseTest):
+
+    def setup_class(self):
+        super().setup_class()
+        self.common_utils = CommonUtils(self.target, self.discoverer)
+        super().enable_recording()
+        self.call_utils.press_home()
+
+    def setup_test(self):
+        # Pair the devices
+        self.bt_utils.pair_primary_to_secondary()
+
+    def test_forget_remove_device_from_settings(self):
+        # Log BT Connection State after pairing
+        bt_connection_state = self.call_utils.get_bt_connection_status_using_adb_command(
+            self.discoverer)
+        logging.info("BT State after pairing : <%s>", bt_connection_state)
+
+        # Allow time for connection to fully sync.
+        self.call_utils.wait_with_log(constants.WAIT_THIRTY_SECONDS)
+
+        bt_connection_state = self.call_utils.get_bt_connection_status_using_adb_command(
+            self.discoverer)
+        logging.info("BT Connection State after wait time : <%s>", bt_connection_state)
+
+        # Navigate to Bluetooth Settings
+        self.call_utils.open_bluetooth_settings_form_status_bar()
+        self.call_utils.wait_with_log(5)
+        # Press the paired target device
+        self.discoverer.mbs.waitUntilConnectionStatus("Connected")
+        self.discoverer.mbs.pressDeviceInBluetoothSettings(self.target.mbs.btGetName())
+        self.call_utils.press_forget()
+        self.call_utils.wait_with_log(5)
+        # Verify that paired device is not listed
+        asserts.assert_false(
+            self.common_utils.has_ui_element_with_text(self.target.mbs.btGetName()),
+            "Device is still paired in settings ")
+
+    def teardown_test(self):
+        discoverer_address = self.discoverer.mbs.btGetAddress()
+        self.target.mbs.btUnpairDevice(discoverer_address)
+        self.discoverer.mbs.btDisable()
+        self.target.mbs.btDisable()
+        super().hu_recording_handler()
+
+
+if __name__ == '__main__':
+    # Take test args
+    common_main()
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_status_displayed_in_settings.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_status_displayed_in_settings.py
new file mode 100644
index 000000000..2f790fbf2
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_status_displayed_in_settings.py
@@ -0,0 +1,75 @@
+"""
+ Copyright (C) 2025 The Android Open Source Project
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+
+
+
+ Test Steps:
+ (0. Flash device)
+   1. Launch Settings --> Tap on Bluetooth - Turn OFF Bluetooth using Toggle button and wait for the device to disconnect
+   Verify: Bluetooth Device disconnected
+   2. Turn On Bluetooth using toggle button and wait for the device to reconnect the paired device
+   Verify: Bluetooth Device reconnected. Device status is 'Connected'
+   3. Repeat the Step 1 and 2, two times
+   Verify:  Device reconnecting
+"""
+
+from bluetooth_test import bluetooth_base_test
+from mobly import asserts
+from utilities.main_utils import common_main
+from utilities import constants
+import logging
+
+class BluetoothConnectionStatusOnSettings(bluetooth_base_test.BluetoothBaseTest):
+
+
+   def setup_test(self):
+       # Pair the devices
+       self.bt_utils.pair_primary_to_secondary()
+       super().enable_recording()
+
+   def test_connection_status_displayed_on_device_screen(self):
+       # Log BT Connection State after pairing
+       bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
+       logging.info("BT State after pairing: <%s>", bt_connection_state)
+
+       for i in range(0, 2):
+           # Open bluetooth settings.
+           self.call_utils.open_bluetooth_settings()
+
+           # Find the target device and disconnect it on the bluetooth settings page
+           target_name = self.target.mbs.btGetName()
+           self.call_utils.press_bluetooth_toggle_on_device(target_name)
+           self.discoverer.mbs.waitUntilConnectionStatus(constants.DISCONNECTED_SUMMARY_STATUS)
+
+           #Validate whether Disconnected status is displayed or not
+           asserts.assert_true(
+              self.discoverer.mbs.hasUIElementWithText(constants.DISCONNECTED_SUMMARY_STATUS),
+              "Expected Disconnected status in Bluetooth settings")
+
+           # Connect again in bluetooth settings
+           self.call_utils.press_bluetooth_toggle_on_device(target_name)
+           self.discoverer.mbs.waitUntilConnectionStatus(constants.CONNECTED_SUMMARY_STATUS)
+
+           #Validate whether Disconnected status is displayed or not
+           asserts.assert_true(
+              self.discoverer.mbs.hasUIElementWithText(constants.CONNECTED_SUMMARY_STATUS),
+              "Expected Connected status in Bluetooth settings")
+
+           self.call_utils.press_home()
+
+
+if __name__ == '__main__':
+   # Take test args
+   common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/dialer/Android.bp b/tests/automotive/mobly_tests/dialer/Android.bp
index 7606fbe31..4050f6b37 100644
--- a/tests/automotive/mobly_tests/dialer/Android.bp
+++ b/tests/automotive/mobly_tests/dialer/Android.bp
@@ -675,3 +675,59 @@ python_test_host {
         },
     },
 }
+
+python_test_host {
+    name: "BTDialerMediaCenter",
+    main: "dialer_test_mediacenter_dialer.py",
+    srcs: ["dialer_test_mediacenter_dialer.py"],
+
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
+
+python_test_host {
+    name: "BTDialerAppSwitch",
+    main: "dialer_test_call_displayed_after_app_switch.py",
+    srcs: ["dialer_test_call_displayed_after_app_switch.py"],
+
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
diff --git a/tests/automotive/mobly_tests/dialer/dialer_hfp_error_test.py b/tests/automotive/mobly_tests/dialer/dialer_hfp_error_test.py
index 4c64e88f4..e1b67e6e0 100644
--- a/tests/automotive/mobly_tests/dialer/dialer_hfp_error_test.py
+++ b/tests/automotive/mobly_tests/dialer/dialer_hfp_error_test.py
@@ -28,7 +28,7 @@ class DialerHFPError(bluetooth_base_test.BluetoothBaseTest):
 
   def teardown_test(self):
     # enabling the Bluetooth
-    self.target.mbs.btEnable()
+    self.target.mbs.btEnableWithLongerWait()
     super().teardown_test()
 
 if __name__ == '__main__':
diff --git a/tests/automotive/mobly_tests/dialer/dialer_test_basic_calling_test_with_reject_call.py b/tests/automotive/mobly_tests/dialer/dialer_test_basic_calling_test_with_reject_call.py
index 477a367da..4128740c5 100644
--- a/tests/automotive/mobly_tests/dialer/dialer_test_basic_calling_test_with_reject_call.py
+++ b/tests/automotive/mobly_tests/dialer/dialer_test_basic_calling_test_with_reject_call.py
@@ -38,14 +38,14 @@ class CallingDeclineBtTest(bluetooth_sms_base_test.BluetoothSMSBaseTest):
         super().enable_recording()
 
     def test_basic_call(self):
-         # call the callee phone with automotive device
-        target_phone_number = self.phone_notpaired.mbs.getPhoneNumber()
+        # call the callee phone with automotive device
+        phone_notpaired_number = self.phone_notpaired.mbs.getPhoneNumber()
         logging.info(
                 'Calling from %s calling to %s',
-                self.phone_notpaired.serial,
                 self.target.serial,
+                self.phone_notpaired.serial,
             )
-        self.call_utils.dial_a_number(target_phone_number);
+        self.call_utils.dial_a_number(phone_notpaired_number)
         self.call_utils.make_call()
         self.call_utils.wait_with_log(5)
         self.call_utils.end_call()
diff --git a/tests/automotive/mobly_tests/dialer/dialer_test_call_displayed_after_app_switch.py b/tests/automotive/mobly_tests/dialer/dialer_test_call_displayed_after_app_switch.py
new file mode 100644
index 000000000..0dfd2363c
--- /dev/null
+++ b/tests/automotive/mobly_tests/dialer/dialer_test_call_displayed_after_app_switch.py
@@ -0,0 +1,78 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+"""Test of basic calling with given digits
+ Steps include:
+        1) Precall state check on IVI device and phone devices. (OK)
+        3) Make a call to any digits number using IVI device
+        4) Open the mediacenter player
+        5) End call on IVI device
+        6) Open the Phone App
+        7) Assert that call is going on
+"""
+
+from bluetooth_test import bluetooth_base_test
+import logging
+from mobly import asserts
+from utilities import constants
+from utilities.main_utils import common_main
+from utilities.media_utils import MediaUtils
+from utilities.common_utils import CommonUtils
+
+
+class BTDialerAppSwitch(bluetooth_base_test.BluetoothBaseTest):
+
+
+    def setup_class(self):
+        super().setup_class()
+        self.media_utils = MediaUtils(self.target, self.discoverer)
+        self.common_utils = CommonUtils(self.target, self.discoverer)
+
+    def setup_test(self):
+        self.common_utils.grant_local_mac_address_permission()
+        self.common_utils.enable_wifi_on_phone_device()
+        self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
+
+    def test_dialer_app_switch(self):
+
+        # Placing the phone call
+        dialer_test_phone_number = constants.INFORMATION_THREE_DIGIT_NUMBER
+        logging.info(
+            'Calling from %s calling to %s',
+            self.target.serial,dialer_test_phone_number
+        )
+        self.call_utils.wait_with_log(2)
+        self.call_utils.dial_a_number(dialer_test_phone_number);
+        self.call_utils.make_call()
+        self.call_utils.wait_with_log(5)
+        self.call_utils.verify_dialing_number(dialer_test_phone_number)
+        self.call_utils.press_home()
+
+        # Opening the mediacenter
+        self.media_utils.open_media_center_app_on_hu()
+
+        # Open the phone app and verify the ongoing call
+        self.call_utils.open_phone_app()
+        self.call_utils.verify_dialing_number(dialer_test_phone_number)
+
+
+    def teardown_test(self):
+        # End call if test failed
+        self.call_utils.end_call_using_adb_command(self.target)
+        self.call_utils.press_home()
+        super().teardown_test()
+
+if __name__ == '__main__':
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/dialer/dialer_test_mediacenter_dialer.py b/tests/automotive/mobly_tests/dialer/dialer_test_mediacenter_dialer.py
new file mode 100644
index 000000000..7e09a2639
--- /dev/null
+++ b/tests/automotive/mobly_tests/dialer/dialer_test_mediacenter_dialer.py
@@ -0,0 +1,94 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+"""Test of MediaCenter and Dialer Continuity
+ Steps include:
+        1) Precall state check on IVI device and phone devices. (OK)
+        2) Launch the media center and play a song
+        3) Open the phone app
+        4) Place a phone call
+        5) End call on IVI device
+        6) Open the mediacenter and verify the song is continued to play
+"""
+
+from bluetooth_test import bluetooth_base_test
+import logging
+from mobly import asserts
+from utilities import constants
+from utilities.main_utils import common_main
+from utilities.media_utils import MediaUtils
+from utilities.common_utils import CommonUtils
+
+
+class BTDialerMediaCenter(bluetooth_base_test.BluetoothBaseTest):
+
+
+    def setup_class(self):
+        super().setup_class()
+        self.media_utils = MediaUtils(self.target, self.discoverer)
+        self.common_utils = CommonUtils(self.target, self.discoverer)
+
+    def setup_test(self):
+        self.common_utils.grant_local_mac_address_permission()
+        self.common_utils.enable_wifi_on_phone_device()
+        self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
+
+    def test_dialer_media_center(self):
+        # Launch the mediacenter and place the song
+        self.media_utils.open_media_center_app_on_hu()
+        self.call_utils.handle_bluetooth_audio_pop_up()
+        self.call_utils.wait_with_log(2)
+        if(self.discoverer.mbs.hasUIElementWithText(constants.MEDIA_SONG)):
+           logging.info('Test Media App is already opened')
+        else:
+           logging.info('Opening the Test Media App')
+           self.media_utils.open_media_center_app_menu()
+           self.call_utils.wait_with_log(5)
+           self.media_utils.open_app(constants.TEST_MEDIA_APP)
+           asserts.assert_true(self.discoverer.mbs.hasUIElementWithText(constants.MEDIA_SONG),'Unable to open the Test Media App')
+        self.media_utils.select_media_track(constants.MEDIA_SONG)
+        self.call_utils.wait_with_log(5)
+        self.media_utils.minimize_now_playing()
+        asserts.assert_true(self.media_utils.is_song_playing_on_hu(),
+                                    'Media player should be on PLAY mode')
+
+        # Place the phone call
+        dialer_test_phone_number = constants.INFORMATION_THREE_DIGIT_NUMBER
+        # Tests the calling three digits number functionality
+        logging.info(
+            'Calling from %s calling to %s',
+            self.target.serial,dialer_test_phone_number
+        )
+        self.call_utils.wait_with_log(2)
+        self.call_utils.dial_a_number(dialer_test_phone_number);
+        self.call_utils.make_call()
+        self.call_utils.wait_with_log(5)
+        self.call_utils.verify_dialing_number(dialer_test_phone_number)
+        self.call_utils.end_call()
+
+        # Launch the mediacenter and verify the song is playing
+        self.media_utils.open_media_app_on_hu()
+        asserts.assert_true(self.media_utils.is_song_playing_on_hu(),
+                                            'Media player should be on PLAY mode')
+        self.media_utils.pause_media_on_hu()
+
+    def teardown_test(self):
+        # End call if test failed
+        self.call_utils.end_call_using_adb_command(self.target)
+        self.call_utils.press_home()
+        super().teardown_test()
+
+if __name__ == '__main__':
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/media/media_test_song_is_playing.py b/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
index 3a1885329..6abec7d68 100644
--- a/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
+++ b/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
@@ -47,13 +47,6 @@ class IsSongPlayingTest(bluetooth_base_test.BluetoothBaseTest):
                             'Invalid song titles. '
                             'Song title on phone device and HU should be the same')
 
-        # Switch to the next song on HU
-        self.media_utils.click_next_track_on_hu()
-        current_next_phone_song_title = self.media_utils.get_song_title_from_phone()
-        current_next_hu_song_title = self.media_utils.get_song_title_from_hu()
-        asserts.assert_true(current_next_phone_song_title == current_next_hu_song_title,
-                            'Invalid song titles. '
-                            'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
         self.media_utils.get_bt_dumpsys_metadata()
diff --git a/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py b/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
index 3423cf4fb..286aad114 100644
--- a/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
+++ b/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
@@ -45,7 +45,7 @@ class IsMediaStreamPairedWhenRadioLunchedTest(bluetooth_base_test.BluetoothBaseT
                             '<' + constants.RADIO_APP + '> has to be present on HU screen')
         self.media_utils.open_radio_app()
         self.media_utils.tune_fm_radio_on_hu(constants.DEFAULT_FM_FREQUENCY)
-#         self.bt_utils.pair_primary_to_secondary()
+        self.bt_utils.pair_primary_to_secondary()
         self.media_utils.open_media_app_on_hu()
         current_phone_song_title = self.media_utils.get_song_title_from_phone()
         current_hu_song_title = self.media_utils.get_song_title_from_hu()
diff --git a/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py b/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
index 7981f62c1..b3c5da184 100644
--- a/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
+++ b/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
@@ -56,11 +56,11 @@ class IsMediaSynchronizedForReconnectedDevice(bluetooth_base_test.BluetoothBaseT
         asserts.assert_true(self.call_utils.is_bluetooth_audio_disconnected_label_visible(),
                             '<Bluetooth Audio disconnected> label should be present')
         # Enable BT on HU
-        self.discoverer.mbs.btEnable()
+        self.discoverer.mbs.btEnableWithLongerWait()
         self.call_utils.wait_with_log(5)
         # Assert <Bluetooth Audio disconnected> label is NOT present
         asserts.assert_false(self.call_utils.is_bluetooth_audio_disconnected_label_visible(),
-                             '<Bluetooth Audio disconnected> label should be present')
+                             '<Bluetooth Audio disconnected> label should not be present')
         # Assert song title same on both devices after reconnect
         current_next_phone_song_title = self.media_utils.get_song_title_from_phone()
         current_next_hu_song_title = self.media_utils.get_song_title_from_hu()
diff --git a/tests/automotive/mobly_tests/notifications/Android.bp b/tests/automotive/mobly_tests/notifications/Android.bp
index ef4f8f039..7501601a4 100644
--- a/tests/automotive/mobly_tests/notifications/Android.bp
+++ b/tests/automotive/mobly_tests/notifications/Android.bp
@@ -211,3 +211,31 @@ python_test_host {
         },
     },
 }
+
+python_test_host {
+    name: "NotificationsSmsHunMultipleConversations",
+    main: "test_sms_hun_multiple_conversations.py",
+    srcs: ["test_sms_hun_multiple_conversations.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "BluetoothSMSTestLibrary",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+        "bt_notifications_config.yaml",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
diff --git a/tests/automotive/mobly_tests/notifications/test_sms_hun_multiple_conversations.py b/tests/automotive/mobly_tests/notifications/test_sms_hun_multiple_conversations.py
new file mode 100644
index 000000000..82baa8996
--- /dev/null
+++ b/tests/automotive/mobly_tests/notifications/test_sms_hun_multiple_conversations.py
@@ -0,0 +1,108 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+import logging
+
+from bluetooth_sms_test import bluetooth_sms_base_test
+from mobly.controllers import android_device
+from utilities import constants
+from utilities.common_utils import CommonUtils
+from utilities.faker import fake
+from utilities.main_utils import common_main
+
+
+class NotificationsSmsHunMultipleConversations(
+    bluetooth_sms_base_test.BluetoothSMSBaseTest
+):
+
+  def setup_class(self):
+    super().setup_class()
+    self.common_utils = CommonUtils(self.target, self.discoverer)
+
+  def setup_test(self):
+    logging.info("Pairing phone to car head unit.")
+    self.bt_utils.pair_primary_to_secondary()
+    self.call_utils.wait_with_log(constants.DEVICE_CONNECT_WAIT_TIME)
+    self.common_utils.click_on_ui_element_with_text("Allow")
+
+    logging.info("Clearing the sms from the phone.")
+    self.call_utils.clear_sms_app(self.target)
+
+    logging.info("Removing mbs snippet and rebooting the phone.")
+    self.target.unload_snippet('mbs')
+    self.target.reboot()
+    self.call_utils.wait_with_log(constants.DEVICE_CONNECT_WAIT_TIME)
+    self.target.load_snippet('mbs', android_device.MBS_PACKAGE)
+    super().enable_recording()
+
+  def test_sms_hun_multiple_conversations(self):
+    """
+    GIVEN the phone which is paired to the car,
+    WHEN multiple SMS are sent to paired phone,
+    THEN all SMS clubbed in one notification in notification center,
+    AND notification conversation collapsible and displaying all conversations.
+    """
+    receiver_phone_number = self.target.mbs.getPhoneNumber()
+    sender_phone_number = self.phone_notpaired.mbs.getPhoneNumber()
+    number_of_sms = 3
+    sms_texts = [fake.string for _ in range(number_of_sms)]
+
+    logging.info(f"Act: Sending multiple SMS to {receiver_phone_number}")
+    for sms_text in sms_texts:
+      self.phone_notpaired.mbs.sendSms(receiver_phone_number, sms_text)
+      assert self.discoverer.mbs.isSmsHunDisplayedWithTitle(sender_phone_number) is True, (
+        "New SMS is not displayed as a heads-up notification with the correct title."
+      )
+      self.discoverer.mbs.waitForHunToDisappear()
+
+    logging.info("Assert: SMS is displayed in the notification center on the car.")
+    assert self.discoverer.mbs.isNotificationDisplayedInCenterWithTitle(sender_phone_number) is True, (
+      "New SMS is not displayed in the notification center."
+    )
+
+    logging.info("Assert: SMS notification count is correct.")
+    logging.info(f"SMS notification count: {self.discoverer.mbs.getSmsNotificationCount(sender_phone_number)}")
+    assert self.discoverer.mbs.getSmsNotificationCount(sender_phone_number) == number_of_sms - 1, (
+        "New SMS notification count is not correct."
+    )
+
+    logging.info("Assert: SMS notification is collapsible.")
+    sms_content = self.discoverer.mbs.getSmsNotificationContent(sender_phone_number)
+    assert sms_content.split() == sms_texts[::-1], (
+        f"SMS notification content is not correct. Expected: {sms_texts[::-1]}, Actual: {sms_content}"
+    )
+
+  def teardown_test(self):
+    self.call_utils.press_home()
+
+    try:
+      super().teardown_test()
+    except Exception as e:  # pylint: disable=broad-except
+      logging.info("Failed to teardown test: %s", e)
+
+
+if __name__ == "__main__":
+  common_main()
diff --git a/tests/automotive/mobly_tests/pairing/bt_discovery_test.py b/tests/automotive/mobly_tests/pairing/bt_discovery_test.py
index baf07f6dd..e628f331c 100644
--- a/tests/automotive/mobly_tests/pairing/bt_discovery_test.py
+++ b/tests/automotive/mobly_tests/pairing/bt_discovery_test.py
@@ -11,11 +11,6 @@ DISCOVERABLE_TIME = 120
 
 class MultiDeviceTest(bluetooth_base_test.BluetoothBaseTest):
 
-    def setup_test(self):
-        super().setup_test()
-        # Set Bluetooth name on target device.
-        self.target.mbs.btSetName('LookForMe!')
-
     def test_bluetooth_discovery(self):
         self.bt_utils.discover_secondary_from_primary()
 
diff --git a/tests/automotive/mobly_tests/utilities/bt_utils.py b/tests/automotive/mobly_tests/utilities/bt_utils.py
index 516c10da3..becd42cf3 100644
--- a/tests/automotive/mobly_tests/utilities/bt_utils.py
+++ b/tests/automotive/mobly_tests/utilities/bt_utils.py
@@ -82,9 +82,9 @@ class BTUtils:
         logging.info('Enabling Bluetooth logs')
         self.enable_bt_logs()
         logging.info('Enabling Bluetooth on both devices')
-        self.discoverer.mbs.btEnable()
+        self.discoverer.mbs.btEnableWithLongerWait()
         self.wakeup_target_device_screen()
-        self.target.mbs.btEnable()
+        self.target.mbs.btEnableWithLongerWait()
         self.disable_android_auto_popup_on_hu()
         logging.info('Setting devices to be discoverable')
         self.target.mbs.btBecomeDiscoverable(DISCOVERABLE_TIME)
diff --git a/tests/automotive/mobly_tests/utilities/constants.py b/tests/automotive/mobly_tests/utilities/constants.py
index 7c1626419..507af9556 100644
--- a/tests/automotive/mobly_tests/utilities/constants.py
+++ b/tests/automotive/mobly_tests/utilities/constants.py
@@ -48,6 +48,8 @@ ANSWER_CALL_TEXT = "Answer"
 ACCEPT_CALL_TEXT = "Accept"
 DISABLE_ANDROID_AUTO_POP_UP = "pm disable --user 10 com.google.android.embedded.projection"
 NOT_NOW_TEXT ="Not Now"
+MEDIA_SONG = "A normal 1H song"
+TEST_MEDIA_APP = "Test Media App"
 
 BTSNOOP_LOG_PATH_ON_DEVICE = '/data/misc/bluetooth/logs/btsnoop_hci.log'
 BTSNOOP_LAST_LOG_PATH_ON_DEVICE = (
@@ -151,7 +153,9 @@ TIMEZONE_DICT = {
     "PST": "Pacific Standard Time",
     "PDT": "Pacific Daylight Time",
     "EST": "Eastern Standard Time",
-    "EDT": "Eastern Daylight Time"
+    "EDT": "Eastern Daylight Time",
+    "GMT": "Greenwich Mean Time",
+    "UTC": "Coordinated Universal Time"
 }
 CLEAR_MESSAGING_APP = 'pm clear com.google.android.apps.messaging'
 DELETE_MESSAGING_DB = 'rm /data/data/com.android.providers.telephony/databases/mmssms.db'
@@ -163,6 +167,7 @@ DIALER_RECENTS_LABEL = "Recents"
 DIALER_CONTACTS_LABEL = "Contacts"
 DIALER_FAVORITES_LABEL = "Favorites"
 DIALER_DIALPAD_LABEL = "Dialpad"
+START_DIALER_SHELL = 'am start -a android.intent.action.DIAL'
 
 # Bluetooth Logs
 BLUETOOTH_TAG="setprop persist.log.tag.bluetooth verbose"
diff --git a/tests/automotive/mobly_tests/utilities/media_utils.py b/tests/automotive/mobly_tests/utilities/media_utils.py
index 09c3b19eb..cbc2f08cc 100644
--- a/tests/automotive/mobly_tests/utilities/media_utils.py
+++ b/tests/automotive/mobly_tests/utilities/media_utils.py
@@ -157,6 +157,33 @@ class MediaUtils:
         self.discoverer.mbs.clickPreviousTrack()
         time.sleep(constants.WAIT_FOR_LOAD)
 
+    # Open Media Center app on HU
+    def open_media_center_app_on_hu(self):
+        logging.info("Open Media center app on HU")
+        self.discoverer.mbs.openMediaApp()
+
+    # Open App Menu
+    def open_media_center_app_menu(self):
+        logging.info("Open Media Center App Menu")
+        self.discoverer.mbs.openMediaAppMenuItems()
+
+    # Open Settings Page
+    def open_media_settings_page(self):
+        logging.info("Open Media Center Settings Page")
+        self.discoverer.mbs.openMediaAppSettingsPage()
+
+    # Open App
+    def open_app(self, media_app):
+        logging.info("Open Media App")
+        logging.info("Open Media App about to open the app")
+        self.discoverer.mbs.openApp(media_app)
+        logging.info("Open Media App --3")
+
+    # Select Media Track
+    def select_media_track(self, media_track):
+        logging.info("Open Media App")
+        self.discoverer.mbs.selectMediaTrack(media_track)
+
     # Open Media app on HU
     def open_media_app_on_hu(self):
         logging.info("Open Media app on HU")
diff --git a/tests/automotive/mobly_tests/utilities/phone_device_utils.py b/tests/automotive/mobly_tests/utilities/phone_device_utils.py
index 3909b1cd3..9d94ad7b0 100644
--- a/tests/automotive/mobly_tests/utilities/phone_device_utils.py
+++ b/tests/automotive/mobly_tests/utilities/phone_device_utils.py
@@ -29,9 +29,8 @@ class PhoneDeviceUtils:
         self.phone_device = phone_device
 
     def call_number_from_home_screen(self, number):
-        """Assumes the phone is on its home screen.
-        Opens the phone app, then dial pad, enters the given number, and starts a call"""
-        self.phone_device.mbs.pressPhoneIcon()
+        """Opens the phone app, then dial pad, enters the given number, and starts a call"""
+        self.phone_device.adb.shell(constants.START_DIALER_SHELL)
         logging.info("Close the video call popup on Phone")
         self.phone_device.mbs.clickUIElementWithText(constants.NOT_NOW_TEXT)
         isDialPadOpen = self.phone_device.mbs.isDialPadOpen()
diff --git a/tests/automotive/mobly_tests/utilities/spectatio_utils.py b/tests/automotive/mobly_tests/utilities/spectatio_utils.py
index 8b997c191..7fa79f403 100644
--- a/tests/automotive/mobly_tests/utilities/spectatio_utils.py
+++ b/tests/automotive/mobly_tests/utilities/spectatio_utils.py
@@ -369,10 +369,17 @@ class CallUtils:
     def is_connect_to_bluetooth_label_visible_on_bluetooth_audio_page(self):
         """Return is <Connect to Bluetooth> label present """
         logging.info('Checking is <Connect to Bluetooth> label present')
-        actual_status = self.device.mbs.isBluetoothAudioDisconnectedLabelVisible()
+        actual_status = self.device.mbs.isConnectToBluetoothLabelVisible()
         logging.info('<Connect to Bluetooth> label is present: %s',actual_status)
         return actual_status
 
+    def is_cancel_button_visible_on_bluetooth_audio_page(self):
+        """Return is <Cancel> button present """
+        logging.info('Checking is <Cancel> button present')
+        actual_status = self.device.mbs.isCancelButtonVisible()
+        logging.info('<Cancel> button is present: %s',actual_status)
+        return actual_status
+
     def click_cancel_label_visible_on_bluetooth_audio_page(self):
         """Clicks on <Cancel> label present on bluetooth Audio page"""
         self.device.mbs.cancelBluetoothAudioConncetion()
@@ -383,7 +390,8 @@ class CallUtils:
         logging.info('Adding wait to check the Bluetooth Audio popup')
         time.sleep(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
         is_bluetooth_media_popup_present = self.is_connect_to_bluetooth_label_visible_on_bluetooth_audio_page()
-        if is_bluetooth_media_popup_present:
+        is_cancel_button_visible = self.is_cancel_button_visible_on_bluetooth_audio_page()
+        if is_bluetooth_media_popup_present and is_cancel_button_visible:
           logging.info('BT Audio popup present, cancelling that.')
           self.click_cancel_label_visible_on_bluetooth_audio_page()
 
diff --git a/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_play_message_while_driving.py b/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_play_message_while_driving.py
index a25e499a4..710edd0de 100644
--- a/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_play_message_while_driving.py
+++ b/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_play_message_while_driving.py
@@ -55,7 +55,7 @@ class UxRestrictionPlayUnreadMessageWhileDrivingTest(bluetooth_sms_base_test.Blu
     self.call_utils.open_sms_app()
 
     # Verify that there is no new sms currently
-    self.call_utils.verify_sms_app_unread_message(False)
+    self.call_utils.verify_sms_app_unread_message()
 
     # Send a new sms
     target_phone_number = self.target.mbs.getPhoneNumber()
@@ -63,8 +63,8 @@ class UxRestrictionPlayUnreadMessageWhileDrivingTest(bluetooth_sms_base_test.Blu
     self.call_utils.wait_with_log(constants.BT_DEFAULT_TIMEOUT)
 
     # Perform the verifications
-    self.call_utils.verify_sms_app_unread_message(True)
-    self.call_utils.verify_sms_preview_timestamp(True)
+    self.call_utils.verify_sms_app_unread_message()
+    self.call_utils.verify_sms_preview_timestamp()
 
     # Tap on Received Text message to read it aloud
     self.call_utils.tap_to_read_aloud()
diff --git a/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_sms_db_sync.py b/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_sms_db_sync.py
index 289041d74..b793a3ee2 100644
--- a/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_sms_db_sync.py
+++ b/tests/automotive/mobly_tests/uxrestriction/uxrestriction_test_sms_db_sync.py
@@ -65,8 +65,8 @@ class UxRestrictionSMSDBTest(bluetooth_sms_base_test.BluetoothSMSBaseTest):
         self.call_utils.open_sms_app()
 
         # Perform the verifications
-        self.call_utils.verify_sms_app_unread_message(True)
-        self.call_utils.verify_sms_preview_timestamp(True)
+        self.call_utils.verify_sms_app_unread_message()
+        self.call_utils.verify_sms_preview_timestamp()
         self.call_utils.verify_sms_preview_text(True, constants.SMS_TEXT_DRIVE_MODE)
 
         # Disable driving mode
diff --git a/tests/automotive/snippets/phone/Android.bp b/tests/automotive/snippets/phone/Android.bp
index 1be15b9ff..789ac8f18 100644
--- a/tests/automotive/snippets/phone/Android.bp
+++ b/tests/automotive/snippets/phone/Android.bp
@@ -51,6 +51,7 @@ android_test {
         "src/**/PhoneSnippet.java",
         "src/**/UISnippet.java",
         "src/**/DialerSnippet.java",
+        "src/**/BluetoothAdapterSnippet.java",
     ],
     manifest: "AndroidPhoneManifest.xml",
     compile_multilib: "both",
diff --git a/tests/automotive/snippets/phone/AndroidAutomotiveManifest.xml b/tests/automotive/snippets/phone/AndroidAutomotiveManifest.xml
index f9c0c53e2..ba3511cfb 100644
--- a/tests/automotive/snippets/phone/AndroidAutomotiveManifest.xml
+++ b/tests/automotive/snippets/phone/AndroidAutomotiveManifest.xml
@@ -36,6 +36,7 @@
                        com.google.android.mobly.snippet.bundled.bluetooth.BluetoothAdapterSnippet,
                        com.google.android.mobly.snippet.bundled.bluetooth.profiles.BluetoothA2dpSnippet,
                        com.google.android.mobly.snippet.bundled.bluetooth.profiles.BluetoothHearingAidSnippet,
+                       com.google.android.mobly.snippet.bundled.BluetoothAdapterSnippet,
                        com.google.android.mobly.snippet.bundled.BluetoothLeAdvertiserSnippet,
                        com.google.android.mobly.snippet.bundled.BluetoothLeScannerSnippet,
                        com.google.android.mobly.snippet.bundled.CarSmsMessengerSnippet,
diff --git a/tests/automotive/snippets/phone/AndroidPhoneManifest.xml b/tests/automotive/snippets/phone/AndroidPhoneManifest.xml
index cb83857dc..74b71f7bd 100644
--- a/tests/automotive/snippets/phone/AndroidPhoneManifest.xml
+++ b/tests/automotive/snippets/phone/AndroidPhoneManifest.xml
@@ -37,6 +37,7 @@
                        com.google.android.mobly.snippet.bundled.bluetooth.BluetoothAdapterSnippet,
                        com.google.android.mobly.snippet.bundled.bluetooth.profiles.BluetoothA2dpSnippet,
                        com.google.android.mobly.snippet.bundled.bluetooth.profiles.BluetoothHearingAidSnippet,
+                       com.google.android.mobly.snippet.bundled.BluetoothAdapterSnippet,
                        com.google.android.mobly.snippet.bundled.BluetoothLeAdvertiserSnippet,
                        com.google.android.mobly.snippet.bundled.BluetoothLeScannerSnippet,
                        com.google.android.mobly.snippet.bundled.FileSnippet,
diff --git a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/BluetoothAdapterSnippet.java b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/BluetoothAdapterSnippet.java
new file mode 100644
index 000000000..fd18e67a4
--- /dev/null
+++ b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/BluetoothAdapterSnippet.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.mobly.snippet.bundled;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.test.uiautomator.By;
+import androidx.test.uiautomator.BySelector;
+import androidx.test.uiautomator.UiDevice;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.bundled.utils.Utils;
+import com.google.android.mobly.snippet.rpc.Rpc;
+
+import java.util.regex.Pattern;
+
+public class BluetoothAdapterSnippet implements Snippet {
+
+    private static class BluetoothAdapterSnippetException extends Exception {
+
+        BluetoothAdapterSnippetException(String msg) {
+            super(msg);
+        }
+
+        BluetoothAdapterSnippetException(String msg, Throwable err) {
+            super(msg, err);
+        }
+    }
+
+    // Timeout to measure consistent BT state.
+    private static final int BT_MATCHING_STATE_INTERVAL_SEC = 5;
+    // Default timeout in seconds.
+    private static final int TIMEOUT_TOGGLE_STATE_SEC = 30;
+    // Default timeout in seconds for UI update.
+    private static final int TIMEOUT_UI_UPDATE_SEC = 4;
+    private final Context mContext;
+    private static final BluetoothAdapter sBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+    private static final Pattern TEXT_PATTERN_ALLOW =
+            Pattern.compile("allow", Pattern.CASE_INSENSITIVE);
+
+    public BluetoothAdapterSnippet() throws Throwable {
+        mContext = InstrumentationRegistry.getInstrumentation().getContext();
+        Utils.adaptShellPermissionIfRequired(mContext);
+    }
+
+    /* Gets the UiDevice instance for UI operations. */
+    private static UiDevice getUiDevice() throws BluetoothAdapterSnippetException {
+        try {
+            return UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
+        } catch (IllegalStateException e) {
+            throw new BluetoothAdapterSnippetException(
+                    "Failed to get UiDevice. Please ensure that "
+                            + "no other UiAutomation service is running.",
+                    e);
+        }
+    }
+
+    /**
+     * Waits until the bluetooth adapter state has stabilized. We consider BT state stabilized if it
+     * hasn't changed within 5 sec.
+     */
+    private static void waitForStableBtState() throws BluetoothAdapterSnippetException {
+        long timeoutMs = System.currentTimeMillis() + TIMEOUT_TOGGLE_STATE_SEC * 1000;
+        long continuousStateIntervalMs =
+                System.currentTimeMillis() + BT_MATCHING_STATE_INTERVAL_SEC * 1000;
+        int prevState = sBluetoothAdapter.getState();
+        while (System.currentTimeMillis() < timeoutMs) {
+            // Delay.
+            Utils.waitUntil(() -> false, /* timeout= */ 1);
+
+            int currentState = sBluetoothAdapter.getState();
+            if (currentState != prevState) {
+                continuousStateIntervalMs =
+                        System.currentTimeMillis() + BT_MATCHING_STATE_INTERVAL_SEC * 1000;
+            }
+            if (continuousStateIntervalMs <= System.currentTimeMillis()) {
+                return;
+            }
+            prevState = currentState;
+        }
+        throw new BluetoothAdapterSnippetException(
+                String.format(
+                        "Failed to reach a stable Bluetooth state within %d s",
+                        TIMEOUT_TOGGLE_STATE_SEC));
+    }
+
+    /**
+     * Enable bluetooth with larger tolerance on UI update timeout than btEnable from
+     * https://github.com/google/mobly-bundled-snippets/blob/master/src/main/java/com/google/android/mobly/snippet/bundled/bluetooth/BluetoothAdapterSnippet.java.
+     */
+    @Rpc(description = "Enable bluetooth with a 30s timeout.")
+    public void btEnableWithLongerWait()
+            throws BluetoothAdapterSnippetException, InterruptedException {
+        if (sBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON) {
+            return;
+        }
+        waitForStableBtState();
+
+        if (Build.VERSION.SDK_INT >= 33) {
+            // BluetoothAdapter#enable is removed from public SDK for 33 and above, so uses an
+            // intent instead.
+            UiDevice uiDevice = getUiDevice();
+            Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+            enableIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            // Triggers the system UI popup to ask for explicit permission.
+            mContext.startActivity(enableIntent);
+            // Clicks the "ALLOW" button.
+            BySelector allowButtonSelector = By.text(TEXT_PATTERN_ALLOW).clickable(true);
+            if (!Utils.waitUntil(
+                    () -> uiDevice.findObject(allowButtonSelector) != null,
+                    TIMEOUT_UI_UPDATE_SEC)) {
+                throw new BluetoothAdapterSnippetException(
+                        String.format(
+                                "Bluetooth permission request dialog did not show up within %ss.",
+                                TIMEOUT_UI_UPDATE_SEC));
+            }
+            uiDevice.findObject(allowButtonSelector).click();
+        } else if (!sBluetoothAdapter.enable()) {
+            throw new BluetoothAdapterSnippetException("Failed to start enabling bluetooth.");
+        }
+        if (!Utils.waitUntil(
+                () -> sBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON,
+                TIMEOUT_TOGGLE_STATE_SEC)) {
+            throw new BluetoothAdapterSnippetException(
+                    String.format(
+                            "Bluetooth did not turn on within %ss.", TIMEOUT_TOGGLE_STATE_SEC));
+        }
+    }
+}
diff --git a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/DialerSnippet.java b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/DialerSnippet.java
index 7b26f2295..24caf7bb4 100644
--- a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/DialerSnippet.java
+++ b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/DialerSnippet.java
@@ -339,6 +339,12 @@ public class DialerSnippet implements Snippet {
         return mDialerHelper.get().verifyDialerSettings();
     }
 
+    /** Validates whether connect to bluetooth message in dialer is displayed or not */
+    @Rpc(description = "is connect to bluetooth message is displayed ")
+    public boolean isConnectToBluetoothDisplayed() {
+        return mDialerHelper.get().isConnectToBluetoothDisplayed();
+    }
+
     @Override
     public void shutdown() {}
 }
diff --git a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/MediaPlayerSnippet.java b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/MediaPlayerSnippet.java
index 8d7a267ae..75eb32a03 100644
--- a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/MediaPlayerSnippet.java
+++ b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/MediaPlayerSnippet.java
@@ -77,6 +77,12 @@ public class MediaPlayerSnippet implements Snippet {
         mAutoMediaHelper.get().open();
     }
 
+    /** open the given app */
+    @Rpc(description = "Open the given app")
+    public void openApp(String mediaApp) {
+        mAutoMediaHelper.get().openApp(mediaApp);
+    }
+
     @Rpc(description = "Is Bluetooth Audio disconnected label present")
     public boolean isBluetoothAudioDisconnectedLabelVisible() {
         return mAutoMediaHelper.get().isBluetoothAudioDisconnectedLabelVisible();
@@ -87,6 +93,11 @@ public class MediaPlayerSnippet implements Snippet {
         return mAutoMediaHelper.get().isConnectToBluetoothLabelVisible();
     }
 
+    @Rpc(description = "Is Cancel button present")
+    public boolean isCancelButtonVisible() {
+        return mAutoMediaHelper.get().isCancelButtonVisible();
+    }
+
     @Rpc(description = "Open Bluetooth Audio app")
     public void openBluetoothMediaApp() {
         mAutoMediaHelper.get().openBluetoothMediaApp();
@@ -107,6 +118,12 @@ public class MediaPlayerSnippet implements Snippet {
         mAutoMediaHelper.get().scrollPlayListDown();
     }
 
+    /** Select Media Track* */
+    @Rpc(description = "Select media track")
+    public void selectMediaTrack(String songName) {
+        mAutoMediaHelper.get().selectMediaTrack(songName);
+    }
+
     @Rpc(description = "Select song from playlist")
     public void clickOnSongFromPlaylist() {
         mAutoMediaHelper.get().clickOnSongFromPlaylist();
diff --git a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/NotificationSnippet.java b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/NotificationSnippet.java
index b11cbb121..278d6e84b 100644
--- a/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/NotificationSnippet.java
+++ b/tests/automotive/snippets/phone/src/com/google/android/mobly/snippet/bundled/NotificationSnippet.java
@@ -35,4 +35,19 @@ public class NotificationSnippet implements Snippet {
     public boolean isNotificationDisplayedInCenterWithTitle(String title) {
         return mNotificationHelper.get().isNotificationDisplayedInCenterWithTitle(title);
     }
+
+    @Rpc(description = "Get the content of the notification.")
+    public String getNotificationContent(String title) {
+        return mNotificationHelper.get().getNotificationContent(title);
+    }
+
+    @Rpc(description = "Get the count of SMS notifications.")
+    public int getSmsNotificationCount(String title) {
+        return mNotificationHelper.get().getSmsNotificationCount(title);
+    }
+
+    @Rpc(description = "Get the content of the SMS notification.")
+    public String getSmsNotificationContent(String title) {
+        return mNotificationHelper.get().getSmsNotificationContent(title);
+    }
 }
diff --git a/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/Android.bp b/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/Android.bp
new file mode 100644
index 000000000..a96fb506a
--- /dev/null
+++ b/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/Android.bp
@@ -0,0 +1,26 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+    default_team: "trendy_team_android_core_graphics_stack",
+}
+
+cc_test {
+    name: "Vkms2SurfaceFlingerTest",
+    defaults: ["atester_wrapper_defaults"],
+    data_bins: [
+        "//frameworks/native/services/surfaceflinger/tests:SurfaceFlinger_test",
+    ],
+}
diff --git a/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/AndroidTest.xml b/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/AndroidTest.xml
new file mode 100644
index 000000000..ab8dab37d
--- /dev/null
+++ b/tests/display/hcct/atest_wrapper/Vkms2_SurfaceFlinger_test/AndroidTest.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Config for Vkms with 2 Connectors running SurfaceFlinger_test">
+    <option name="test-suite-tag" value="apct"/>
+    <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
+
+    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+        <option name="cleanup" value="true" />
+        <option name="append-bitness" value="false"/>
+        <option name="push-file" key="SurfaceFlinger_test" value="/data/local/tmp/SurfaceFlinger_test"/>
+        <option name="push-file" key="setup_vkms_connectors_for_atest" value="/data/local/tmp/setup_vkms_connectors_for_atest"/>
+        <option name="push-file" key="teardown_vkms" value="/data/local/tmp/teardown_vkms"/>
+    </target_preparer>
+
+    <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
+        <option name="run-command" value="stop"/>
+        <option name="run-command" value="stop vendor.hwcomposer-3"/>
+        <option name="run-command" value="./data/local/tmp/setup_vkms_connectors_for_atest 2"/>
+        <option name="run-command" value="start vendor.hwcomposer-3"/>
+        <option name="run-command" value="start" />
+        <!-- Wait for UI to come up -->
+        <option name="run-command" value="sleep 5" />
+        <option name="run-command" value="mkdir -p /data/local/tmp/SurfaceFlinger_test_screenshots" />
+        <option name="teardown-command" value="rm -fr /data/local/tmp/SurfaceFlinger_test_screenshots"/>
+        <option name="teardown-command" value="./data/local/tmp/teardown_vkms"/>
+        <option name="teardown-command" value="start vendor.hwcomposer-3"/>
+        <option name="teardown-command" value="start"/>
+    </target_preparer>
+
+    <target_preparer class="com.android.tradefed.targetprep.DeviceSetup">
+        <option name="screen-always-on" value="on" />
+    </target_preparer>
+
+    <test class="com.android.tradefed.testtype.GTest" >
+        <option name="native-test-device-path" value="/data/local/tmp" />
+        <option name="module-name" value="SurfaceFlinger_test" />
+    </test>
+
+    <metrics_collector class="com.android.tradefed.device.metric.FilePullerLogCollector">
+        <option name = "pull-pattern-keys" value = ".*png" />
+        <option name = "directory-keys" value = "/data/local/tmp/SurfaceFlinger_test_screenshots" />
+    </metrics_collector>
+</configuration>
\ No newline at end of file
diff --git a/tests/display/hcct/tests/hotplugs.cpp b/tests/display/hcct/tests/hotplugs.cpp
index 7884295ef..f26d9530e 100644
--- a/tests/display/hcct/tests/hotplugs.cpp
+++ b/tests/display/hcct/tests/hotplugs.cpp
@@ -23,7 +23,7 @@
 namespace {
 
 constexpr int kMaxRetries = 5;
-constexpr int kInitialSetupConnectors = 2;
+constexpr int kInitialSetupConnectors = 3;
 
 class VkmsHotplugTest : public ::testing::Test {
 protected:
@@ -77,7 +77,7 @@ TEST_F(VkmsHotplugTest, DetectSingleHotplugs) {
       << " unique hotplug events, but got " << hotpluggedDisplays.size();
 }
 
-TEST_F(VkmsHotplugTest, DetectSingleDisconnectHotplugs) {
+TEST_F(VkmsHotplugTest, DetectSingleExternalDisconnectHotplugs) {
   std::unordered_set<int64_t> hotpluggedDisplays;
 
   for (int i = 0; i < kInitialSetupConnectors; ++i) {
@@ -97,6 +97,12 @@ TEST_F(VkmsHotplugTest, DetectSingleDisconnectHotplugs) {
     ASSERT_TRUE(mHwcTester->getAndClearLatestHotplugs().empty())
         << "Hotplugs should have been cleared";
 
+    // Do not unplug the primary display because SF expects there to always be a
+    // primary display.
+    // hhttps://source.android.com/docs/core/graphics/hotplug#handling-common-scenarios
+    if (i == 0)
+      continue;
+
     mVkmsTester->ToggleConnector(i, false);
 
     retryCount = 0;
@@ -120,8 +126,10 @@ TEST_F(VkmsHotplugTest, DetectSingleDisconnectHotplugs) {
     hotpluggedDisplays.insert(receivedHotplugs[0].first);
   }
 
-  EXPECT_EQ(kInitialSetupConnectors, hotpluggedDisplays.size())
-      << "Expected " << kInitialSetupConnectors
+  int expectedDisconnectHotplugs = kInitialSetupConnectors - 1;
+
+  EXPECT_EQ(expectedDisconnectHotplugs, hotpluggedDisplays.size())
+      << "Expected " << expectedDisconnectHotplugs
       << " unique hotplug events, but got " << hotpluggedDisplays.size();
 }
 
diff --git a/tests/display/igt/Android.bp b/tests/display/igt/Android.bp
index 5684c19cf..d349764f9 100644
--- a/tests/display/igt/Android.bp
+++ b/tests/display/igt/Android.bp
@@ -13,13 +13,14 @@ cc_defaults {
     compile_multilib: "64",
     local_include_dirs: ["include"],
     require_root: true,
-    test_suites: [
-        "device-tests",
-    ],
     shared_libs: [
         "libbase",
     ],
-}
+    test_suites: [
+        "device-tests",
+        "general-tests",
+        "dts",
+    ],}
 
 cc_test {
     name: "IgtCoreAuthTestCases",
diff --git a/tests/display/igt/src/igt_test_helper.cpp b/tests/display/igt/src/igt_test_helper.cpp
index 59bb13572..7dcd89298 100644
--- a/tests/display/igt/src/igt_test_helper.cpp
+++ b/tests/display/igt/src/igt_test_helper.cpp
@@ -117,16 +117,11 @@ std::string IgtTestHelper::generateGTestName(
     const ::testing::TestParamInfo<IgtSubtestParams> &info) {
   std::string dashedName(info.param.name);
 
-  // Many subtest names include %s and %d which are not valid GTest names.
-  size_t pos = dashedName.find("%s");
+  // Many subtest names include * which is not a valid GTest name.
+  size_t pos = dashedName.find("*");
   while (pos != std::string::npos) {
-    dashedName.erase(pos, 2);
-    pos = dashedName.find("%s", pos);
-  }
-  pos = dashedName.find("%d");
-  while (pos != std::string::npos) {
-    dashedName.erase(pos, 2);
-    pos = dashedName.find("%d", pos);
+    dashedName.erase(pos, 1);
+    pos = dashedName.find("*", pos);
   }
 
   // convert test-name to PascalCase
diff --git a/tests/display/igt/src/kms_atomic.cpp b/tests/display/igt/src/kms_atomic.cpp
index 7567ad414..2168436bc 100644
--- a/tests/display/igt/src/kms_atomic.cpp
+++ b/tests/display/igt/src/kms_atomic.cpp
@@ -67,10 +67,11 @@ IgtSubtestParams subtests[] = {
      .rationale = "important for ensuring that the planes are displayed in the "
                   "correct order"}};
 
-TEST_P(KmsAtomicTests, Run) { runSubTest(GetParam()); }
+TEST_P(KmsAtomicTests, RunSubTests) { runSubTest(GetParam()); }
 
-INSTANTIATE_TEST_SUITE_P(KmsAtomic, KmsAtomicTests,
-                         ::testing::ValuesIn(subtests));
+INSTANTIATE_TEST_SUITE_P(KmsAtomicTests, KmsAtomicTests,
+                          ::testing::ValuesIn(subtests),
+                          IgtTestHelper::generateGTestName);
 
 } // namespace
 } // namespace igt
diff --git a/tests/display/igt/src/kms_bw.cpp b/tests/display/igt/src/kms_bw.cpp
index 5ca440582..81816b49b 100644
--- a/tests/display/igt/src/kms_bw.cpp
+++ b/tests/display/igt/src/kms_bw.cpp
@@ -35,7 +35,7 @@ namespace {
 class KmsBwTests : public ::testing::TestWithParam<IgtSubtestParams>,
                    public IgtTestHelper {
 public:
-  KmsBwTests() : IgtTestHelper("kms_flip") {}
+  KmsBwTests() : IgtTestHelper("kms_bw") {}
 };
 
 constexpr std::string_view kDescription =
@@ -48,10 +48,10 @@ constexpr std::string_view kRationale =
 
 IgtSubtestParams subtests[] = {
     // Fundamental Validation tests.
-    {.name = "linear-tiling-%d-displays-%s",
+    {.name = "linear-tiling-*-displays-*",
      .desc = kDescription,
      .rationale = kRationale},
-    {.name = "connected-linear-tiling-%d-displays-%s",
+    {.name = "connected-linear-tiling-*-displays-*",
      .desc = kDescription,
      .rationale = kRationale},
 
diff --git a/tests/display/igt/src/kms_color.cpp b/tests/display/igt/src/kms_color.cpp
index a4b32be7c..ca299ab78 100644
--- a/tests/display/igt/src/kms_color.cpp
+++ b/tests/display/igt/src/kms_color.cpp
@@ -52,7 +52,7 @@ IgtSubtestParams subtests[] = {
      .desc = "Verify that gamma LUT transformation works correctly",
      .rationale =
          "checks if the gamma LUT is applied correctly by the hardware"},
-    {.name = "ctm-%s",
+    {.name = "ctm-*",
      .desc = "Check the color transformation",
      .rationale = "checks the hardware's ability to apply various color "
                   "transformations using CTMs"},
diff --git a/tests/example/perf/Android.bp b/tests/example/perf/Android.bp
index 1256468c1..c0ae7c439 100644
--- a/tests/example/perf/Android.bp
+++ b/tests/example/perf/Android.bp
@@ -22,5 +22,5 @@ java_test_host {
     srcs: ["src/**/*.java"],
 
     libs: ["tradefed"],
-    test_suites: ["general-tests"],
+    test_suites: ["performance-tests"],
 }
diff --git a/scripts/perf-setup/tests/Android.bp b/tests/perf/ShutdownPerfTest/Android.bp
similarity index 67%
rename from scripts/perf-setup/tests/Android.bp
rename to tests/perf/ShutdownPerfTest/Android.bp
index 5de8cf06e..6eda3fce3 100644
--- a/scripts/perf-setup/tests/Android.bp
+++ b/tests/perf/ShutdownPerfTest/Android.bp
@@ -1,4 +1,4 @@
-//Copyright (C) 2021 The Android Open Source Project
+// Copyright (C) 2025 The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -13,19 +13,17 @@
 // limitations under the License.
 
 package {
-    default_team: "trendy_team_performance",
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
-android_test {
-    name: "PerfSetupTests",
-
+java_test_host {
+    name: "ShutdownPerfTest",
     srcs: ["src/**/*.java"],
-    sdk_version: "test_current",
-    min_sdk_version: "21",
-
-    static_libs: ["androidx.test.runner"],
-    certificate: "platform",
 
-    test_config: "configs/perf-setup.xml",
+    libs: [
+        "tradefed",
+        "compatibility-host-util",
+    ],
+    test_config: "AndroidTest.xml",
+    test_suites: ["general-tests"],
 }
diff --git a/tests/perf/ShutdownPerfTest/AndroidTest.xml b/tests/perf/ShutdownPerfTest/AndroidTest.xml
new file mode 100644
index 000000000..cbb0605d8
--- /dev/null
+++ b/tests/perf/ShutdownPerfTest/AndroidTest.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Runs shutdown performance test.">
+    <!-- Declare as a performance test module -->
+    <option name="config-descriptor:metadata" key="test-type" value="performance" />
+    <option name="test-suite-tag" value="apct" />
+    <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
+    <test class="com.android.tradefed.testtype.HostTest" >
+        <option name="class" value="com.android.tests.ShutdownPerfTest" />
+    </test>
+    <!-- Add module-level post processor MetricFilePostProcessor -->
+    <metric_post_processor class="com.android.tradefed.postprocessor.MetricFilePostProcessor">
+        <option name="aggregate-similar-tests" value="true" />
+        <option name="enable-per-test-log" value="true" />
+        <option name="report-percentiles" value="50"/>
+        <option name="report-percentiles" value="90"/>
+    </metric_post_processor>
+</configuration>
diff --git a/tests/perf/ShutdownPerfTest/src/com/android/tests/ShutdownPerfTest.java b/tests/perf/ShutdownPerfTest/src/com/android/tests/ShutdownPerfTest.java
new file mode 100644
index 000000000..7d74f31dd
--- /dev/null
+++ b/tests/perf/ShutdownPerfTest/src/com/android/tests/ShutdownPerfTest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tests;
+
+import com.android.tradefed.config.Option;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.log.LogUtil;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Directionality;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
+import com.android.tradefed.testtype.DeviceJUnit4ClassRunner.TestMetrics;
+import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Test to reboot device for 10 times and check the shutdown time in pstore files. */
+@RunWith(DeviceJUnit4ClassRunner.class)
+public class ShutdownPerfTest extends BaseHostJUnit4Test {
+    private ITestDevice mDevice;
+
+    /** Metrics to collect. */
+    private Long[] mMilliSecondsShutdownTime;
+
+    /** Number of reboots. */
+    @Option(name = "iterations", description = "Number of times to reboot")
+    private int mIterations = 10;
+
+    @Rule public TestMetrics metrics = new TestMetrics();
+
+    @Before
+    public void setUp() throws Exception {
+        mDevice = getDevice();
+        mMilliSecondsShutdownTime = new Long[mIterations];
+    }
+
+    // possible kernel console output paths to check
+    private static final List<String> sPstorePaths =
+            Arrays.asList("/sys/fs/pstore/console-ramoops-0", "/sys/fs/pstore/console-ramoops");
+
+    @Test
+    public void shutdownPerf() throws Exception {
+        LogUtil.CLog.i("Number of iterations: " + mIterations);
+
+        if (!sysfsPstoreConsoleExists()) {
+            LogUtil.CLog.w("Skip test: pstore console log is not available");
+            return;
+        }
+
+        // Reboot mIteration times to get the shutdown time in pstore files.
+        for (int i = 0; i < mIterations; i++) {
+            mDevice.reboot("Reboot to check logs in pstore");
+            mDevice.enableAdbRoot();
+            mMilliSecondsShutdownTime[i] = tryGetShutdownTime();
+        }
+
+        // Report the shutdown time that has value.
+        for (int i = 0; i < mIterations; i++) {
+            if (mMilliSecondsShutdownTime[i] != null) {
+                long iShutdownTime = mMilliSecondsShutdownTime[i].longValue();
+                metrics.addTestMetric(
+                        "reboot_shutdown_time" + "_" + i, createMetric(iShutdownTime));
+            }
+        }
+    }
+
+    private boolean sysfsPstoreConsoleExists() throws DeviceNotAvailableException {
+        for (String pathString : sPstorePaths) {
+            // Check if the current file exists
+            if (mDevice.doesFileExist(pathString)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private Metric createMetric(long value) {
+        return Metric.newBuilder()
+                .setMeasurements(Measurements.newBuilder().setSingleInt(value))
+                .setDirection(Directionality.DOWN_BETTER)
+                .setUnit("ms")
+                .build();
+    }
+
+    private static Long extractShutdownTimeFromFile(File logFile) {
+        Long shutdownTime = null;
+        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
+            String line;
+            Pattern pattern = Pattern.compile("powerctl_shutdown_time_ms:(\\d+)");
+            while ((line = reader.readLine()) != null) {
+                Matcher matcher = pattern.matcher(line);
+                if (matcher.find()) {
+                    String shutdownTimeStr = matcher.group(1);
+                    try {
+                        shutdownTime = Long.parseLong(shutdownTimeStr);
+                        break; // Stop once shutdown time found.
+                    } catch (NumberFormatException e) {
+                        LogUtil.CLog.e("Error parsing shutdown time: " + e.getMessage());
+                        return null;
+                    }
+                }
+            }
+        } catch (IOException e) {
+            LogUtil.CLog.w("Error reading log file: " + e.getMessage());
+            return null;
+        }
+
+        return shutdownTime;
+    }
+
+    // Try to find shutdown time log in pstore files.
+    // Return the shutdown time(ms). If not found, return null.
+    private Long tryGetShutdownTime() throws Exception {
+        for (String pathString : sPstorePaths) {
+            // Check if the current file exists
+            if (mDevice.doesFileExist(pathString)) {
+                File pstoreFile = mDevice.pullFile(pathString);
+                if (pstoreFile != null) {
+                    return extractShutdownTimeFromFile(pstoreFile);
+                }
+            }
+        }
+        return null;
+    }
+}
```

