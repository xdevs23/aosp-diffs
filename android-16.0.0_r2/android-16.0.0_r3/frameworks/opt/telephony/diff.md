```diff
diff --git a/Android.bp b/Android.bp
index e667cb39e5..ca24c6e3a6 100644
--- a/Android.bp
+++ b/Android.bp
@@ -114,6 +114,9 @@ java_library {
         enabled: true,
         shrink: true,
         obfuscate: false,
+        // TODO(b/421510447): Remove compat mode override after resolving
+        // issues with API signatures in full mode.
+        proguard_compatibility: true,
         proguard_flags_files: ["proguard.flags"],
     },
     lint: {
diff --git a/flags/calling.aconfig b/flags/calling.aconfig
index 3646f73616..efe656e13a 100644
--- a/flags/calling.aconfig
+++ b/flags/calling.aconfig
@@ -10,14 +10,6 @@ flag {
   is_exported: true
 }
 
-# OWNER=yomna TARGET=24Q3
-flag {
-  name: "show_call_fail_notification_for_2g_toggle"
-  namespace: "telephony"
-  description: "Used in DisconnectCause and TelephonyConnection if a non-emergency call fails on a device with no 2G, to guard whether a user can see an updated error message reminding the 2G is disabled and potentially disrupting their call connectivity"
-  bug: "300142897"
-}
-
 # OWNER=stevestatia TARGET=24Q4
 flag {
     name: "national_country_code_formatting_for_local_calls"
diff --git a/flags/carrier.aconfig b/flags/carrier.aconfig
index 19d2145527..2eeff4e731 100644
--- a/flags/carrier.aconfig
+++ b/flags/carrier.aconfig
@@ -41,3 +41,14 @@ flag {
       purpose: PURPOSE_BUGFIX
     }
 }
+
+# OWNER=melhuishj TARGET=25Q3
+flag {
+    name: "cleanup_carrier_network_change_by_phoneid"
+    namespace: "telephony"
+    description: "use phoneId to cleanup carrierNetworkChange status when carrier app is lost"
+    bug:"333571417"
+    metadata {
+      purpose: PURPOSE_BUGFIX
+    }
+}
diff --git a/flags/data.aconfig b/flags/data.aconfig
index cdd73ac21c..8797252be3 100644
--- a/flags/data.aconfig
+++ b/flags/data.aconfig
@@ -1,12 +1,23 @@
 package: "com.android.internal.telephony.flags"
 container: "system"
 
-# OWNER=linggm TARGET=25Q2
+# OWNER=linggm TARGET=26Q2
 flag {
-  name: "auto_data_switch_enhanced"
+  name: "keep_wfc_on_apm"
   namespace: "telephony"
-  description: "Ramp up RAT signal strength based auto data switch"
-  bug: "287132491"
+  description: "Keep WFC even when turn on APM."
+  bug:"420996981"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
+
+# OWNER=linggm TARGET=25Q3
+flag {
+  name: "auto_data_prune_listener"
+  namespace: "telephony"
+  description: "Unregister listeners when user disable settings or connect to wifi."
+  bug:"389591869"
   metadata {
     purpose: PURPOSE_BUGFIX
   }
@@ -30,14 +41,6 @@ flag {
   bug:"286171724"
 }
 
-# OWNER=jackyu TARGET=24Q4
-flag {
-  name: "dds_callback"
-  namespace: "telephony"
-  description: "Adding new callback when DDS changed"
-  bug:"353723350"
-}
-
 # OWNER=jackyu TARGET=25Q2
 flag {
   name: "oem_paid_private"
@@ -68,3 +71,39 @@ flag {
     purpose: PURPOSE_BUGFIX
   }
 }
+
+# OWNER=kuenyuet TARGET=26Q2
+flag {
+  name: "data_service_user_data_toggle_notify"
+  namespace: "telephony"
+  description: "Support notify data services when user data and user data roaming is toggled."
+  bug:"389120182"
+}
+
+# OWNER=rambowang TARGET=25Q4
+flag {
+    name: "macro_based_opportunistic_networks"
+    is_exported: true
+    namespace: "telephony"
+    description: "This flag enable the macro-based opportunistic networks with auto data switch"
+    bug:"401006757"
+}
+
+# OWNER=sewookseo TARGET=25Q4
+flag {
+  name: "qos_update_network_agent"
+  namespace: "telephony"
+  description: "Update network agent in QosCallbackTracker when DN recreates network agent"
+  bug:"412542821"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
+
+# OWNER=gwenlin TARGET=26Q2
+flag {
+  name: "data_service_notify_ims_data_network"
+  namespace: "telephony"
+  description: "Support notifying IMS data network"
+  bug:"389103112"
+}
diff --git a/flags/domainselection.aconfig b/flags/domainselection.aconfig
index 88a6e9e1e6..72325fdb61 100644
--- a/flags/domainselection.aconfig
+++ b/flags/domainselection.aconfig
@@ -34,14 +34,6 @@ flag {
     bug:"258112541"
 }
 
-# OWNER=jdyou TARGET=24Q4
-flag {
-    name: "hangup_emergency_call_for_cross_sim_redialing"
-    namespace: "telephony"
-    description: "This flag controls the behavior of terminating an emergency call for cross SIM redialing."
-    bug:"336398541"
-}
-
 # OWNER=avinashmp TARGET=25Q1
 flag {
     name: "add_ims_redial_codes_for_emergency_calls"
diff --git a/flags/ims.aconfig b/flags/ims.aconfig
index 5f49c46465..03ad2ff238 100644
--- a/flags/ims.aconfig
+++ b/flags/ims.aconfig
@@ -59,14 +59,6 @@ flag {
     bug:"312101946"
 }
 
-# OWNER=apsankar TARGET=24Q3
-flag {
-    name: "call_extra_for_non_hold_supported_carriers"
-    namespace: "telephony"
-    description: "For DSDA devices, controls whether the existing call will be dropped when an incoming call on a different sub is answered, when either sub does not support hold capability."
-    bug:"315993953"
-}
-
 # OWNER=joonhunshin TARGET=24Q3
 flag {
     name: "update_roaming_state_to_set_wfc_mode"
@@ -177,3 +169,25 @@ flag {
         purpose: PURPOSE_BUGFIX
     }
 }
+
+# OWNER=grantmenke TARGET=25Q4
+flag {
+    name: "reuse_original_conn_remote_conf_behavior"
+    namespace: "telephony"
+    description: "Used to reuse the original Telephony Connection when a remotely hosted IMS conference is created."
+    bug:"391889544"
+    metadata {
+        purpose: PURPOSE_FEATURE
+    }
+}
+
+# OWNER=gwenlin TARGET=26Q2
+flag {
+    name: "allowed_services"
+    namespace: "telephony"
+    description: "Update allowed services to the modem"
+    bug:"389157806"
+    metadata {
+        purpose: PURPOSE_FEATURE
+    }
+}
diff --git a/flags/messaging.aconfig b/flags/messaging.aconfig
index 905dc946f6..c9eea5ff22 100644
--- a/flags/messaging.aconfig
+++ b/flags/messaging.aconfig
@@ -1,14 +1,6 @@
 package: "com.android.internal.telephony.flags"
 container: "system"
 
-# OWNER=hwangoo TARGET=24Q2
-flag {
-  name: "sms_domain_selection_enabled"
-  namespace: "telephony"
-  description: "This flag controls AP domain selection support for normal/emergency SMS."
-  bug: "262804071"
-}
-
 # OWNER=tnd TARGET=24Q3
 flag {
   name: "mms_disabled_error"
@@ -18,17 +10,6 @@ flag {
   bug: "305062594"
 }
 
-# OWNER=linggm TARGET=24Q4
-flag {
-  name: "mms_get_apn_from_pdsc"
-  namespace: "telephony"
-  description: "This flag controls get APN details from PDSC instead of telephony provider."
-  bug: "324280016"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
 # OWNER=stevestatia TARGET=24Q3
 flag {
     name: "unregister_sms_broadcast_receiver_from_cat_service"
diff --git a/flags/misc.aconfig b/flags/misc.aconfig
index 3641c601ed..7d115dac51 100644
--- a/flags/misc.aconfig
+++ b/flags/misc.aconfig
@@ -1,15 +1,6 @@
 package: "com.android.internal.telephony.flags"
 container: "system"
 
-# OWNER=tjstuart TARGET=24Q3
-flag {
-  name: "do_not_override_precise_label"
-  namespace: "telephony"
-  description: "When set, Telecom will not override the precise label for certain disconnect causes."
-  bug: "296968778"
-  is_fixed_read_only: true
-}
-
 # OWNER=tnd TARGET=24Q1
 flag {
   name: "log_mms_sms_database_access_info"
@@ -35,14 +26,6 @@ flag {
   bug: "304272356"
 }
 
-# OWNER=grantmenke TARGET=24Q3
-flag {
-  name: "ensure_access_to_call_settings_is_restricted"
-  namespace: "telephony"
-  description: "Check if access to mobile network configs restricted before displaying call options"
-  bug: "309655251"
-}
-
 # OWNER=rambowang TARGET=24Q3
 flag {
     name: "reset_mobile_network_settings"
@@ -87,17 +70,6 @@ flag {
     }
 }
 
-# OWNER=sasindran TARGET=24Q3
-flag {
-    name: "use_relaxed_id_match"
-    namespace: "telephony"
-    description: "This flag supports relaxed id match for radio state changes"
-    bug:"336916327"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=joonhunshin TARGET=24Q4
 flag {
     name: "use_carrier_config_for_cfnry_time_via_mmi"
@@ -109,17 +81,6 @@ flag {
     }
 }
 
-# OWNER=jackyu TARGET=25Q2
-flag {
-    name: "hsum_broadcast"
-    namespace: "telephony"
-    description: "Fixed the bug that broadcast intent is only sent to the system user."
-    bug:"362554272"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=rambowang TARGET=25Q2
 flag {
     name: "support_carrier_services_for_hsum"
@@ -131,17 +92,6 @@ flag {
     }
 }
 
-# OWNER=jackyu TARGET=25Q2
-flag {
-    name: "hsum_package_manager"
-    namespace: "telephony"
-    description: "Fixed the bug that package manager is not for the right user"
-    bug:"356827794"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=jackyu TARGET=25Q2
 flag {
     name: "power_down_race_fix"
@@ -210,12 +160,23 @@ flag {
     }
 }
 
-# OWNER=jackyu TARGET=25Q2
+# OWNER=tjstuart TARGET=25Q3
+flag {
+    name: "immediately_process_do_not_show_again_broadcast"
+    namespace: "telephony"
+    description: "Ensure the Do Not Show Again broadcast is immediately processed by receiver"
+    bug:"368690328"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+# OWNER=rmao TARGET=26Q1
 flag {
-    name: "carrier_config_changed_callback_fix"
+    name: "dynamic_modem_shutdown"
     namespace: "telephony"
-    description: "Carrier config callback race condition fix"
-    bug:"375526692"
+    description: "Allow shutdown and turn on the modem while the overall system is on"
+    bug:"416563298"
     metadata {
         purpose: PURPOSE_BUGFIX
     }
diff --git a/flags/network.aconfig b/flags/network.aconfig
index bf2dcad1dd..f0263235f5 100644
--- a/flags/network.aconfig
+++ b/flags/network.aconfig
@@ -37,21 +37,11 @@ flag {
   bug: "355062720"
 }
 
-# OWNER=jackyu TARGET=25Q3
-flag {
-    name: "ignore_mcc_mnc_from_operator_for_locale"
-    namespace: "telephony"
-    description: "Ignoring mcc/mnc from RIL indication OPERATOR but only relying MCC/MNC from registered or nearby cells."
-    bug:"374589521"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
+# OWNER=yomna TARGET=25Q4
 flag {
     name: "vendor_specific_cellular_identifier_disclosure_indications"
     is_exported: true
     namespace: "telephony"
     description: "Guard system API for vendor-specific classifications of cellular ID disclosures"
-    bug: "355062720"
+    bug: "385338654"
 }
diff --git a/flags/satellite.aconfig b/flags/satellite.aconfig
index b43303003b..e9dbe784ba 100644
--- a/flags/satellite.aconfig
+++ b/flags/satellite.aconfig
@@ -103,3 +103,26 @@ flag {
         purpose: PURPOSE_BUGFIX
     }
 }
+
+# OWNER=amallampati TARGET=25Q3
+flag {
+    name: "satellite_improve_multi_thread_design"
+    is_exported: false
+    namespace: "telephony"
+    description: "Improve multi-thread design in satellite module"
+    bug:"398227332"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+# OWNER=nagendranb TARGET=25Q3
+flag {
+  name: "satellite_data_metrics"
+  namespace: "telephony"
+  description: "Support Satellite Data metrics at satellite session"
+  bug: "405107194"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
\ No newline at end of file
diff --git a/flags/subscription.aconfig b/flags/subscription.aconfig
index ea12ce8d38..64ef4eacc0 100644
--- a/flags/subscription.aconfig
+++ b/flags/subscription.aconfig
@@ -54,3 +54,26 @@ flag {
   bug: "357272015"
   is_exported: true
 }
+
+# OWNER=melhuishj TARGET=25Q3
+flag {
+  name: "ons_thread_consolidation"
+  namespace: "telephony"
+  description: "Consolidate ONS work to a single worker thread"
+  bug: "240081918"
+  is_exported: false
+}
+
+# OWNER=jackyu TARGET=26Q2
+flag {
+  name: "update_resource_configuration"
+  namespace: "telephony"
+  description: "Update resource configuration when default sub id is changed"
+  bug: "397605393"
+  is_exported: false
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+
diff --git a/flags/uicc.aconfig b/flags/uicc.aconfig
index 8561dacb20..2fed360d4c 100644
--- a/flags/uicc.aconfig
+++ b/flags/uicc.aconfig
@@ -9,14 +9,6 @@ flag {
     bug:"298567545"
 }
 
-# OWNER=arunvoddu TARGET=24Q3
-flag {
-    name: "imsi_key_retry_download_on_phone_unlock"
-    namespace: "telephony"
-    description: "This flag controls to download the IMSI encryption keys after user unlocks the phone."
-    bug:"303780982"
-}
-
 # OWNER=arunvoddu TARGET=24Q4
 flag {
     name: "carrier_restriction_status"
@@ -26,14 +18,6 @@ flag {
     bug:"313553044"
 }
 
-# OWNER=arunvoddu TARGET=24Q3
-flag {
-    name: "carrier_restriction_rules_enhancement"
-    namespace: "telephony"
-    description: "This flag controls the new enhancements to the existing carrier restrictions rules"
-    bug:"317226653"
-}
-
 # OWNER=rafahs TARGET=24Q3
 flag {
     name: "esim_available_memory"
@@ -52,17 +36,6 @@ flag {
     is_exported: true
 }
 
-# OWNER=arunvoddu TARGET=24Q4
-flag {
-    name: "uicc_app_count_check_to_create_channel"
-    namespace: "telephony"
-    description: "This flag controls to create the open channel when uicc application count is greater than 0."
-    bug:"349966950"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=mewan TARGET=24Q4
 flag {
     name: "optimization_apdu_sender"
@@ -71,17 +44,6 @@ flag {
     bug:"335257880"
 }
 
-# OWNER=arunvoddu TARGET=24Q4
-flag {
-    name: "ignore_carrierid_reset_for_sim_removal"
-    namespace: "telephony"
-    description: "This flag controls the carrierId reset while imsi key deletion time upon sim ejection."
-    bug:"366178705"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=jhyoon TARGET=25Q2
 flag {
     name: "support_isim_record"
@@ -100,17 +62,6 @@ flag {
     is_exported: true
 }
 
-# OWNER=arunvoddu TARGET=25Q2
-flag {
-    name: "force_imsi_certificate_delete"
-    namespace: "telephony"
-    description: "This flag controls the IMSI certificate delete with out any condition."
-    bug:"235296888"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
-
 # OWNER=jinjeong TARGET=25Q2
 flag {
     name: "get_group_id_level2"
@@ -126,3 +77,27 @@ flag {
     description: "This flag controls to launch sim preference page in Setting"
     bug:"381319469"
 }
+
+# OWNER=arunvoddu TARGET=25Q3
+flag {
+    name: "sim_phonebook_cache_fix"
+    namespace: "telephony"
+    description: "This flag reset the cache if the sim phonebook is empty"
+    bug:"404094844"
+}
+
+# OWNER=arunvoddu TARGET=25Q4
+flag {
+    name: "send_imsi_key_for_duplicate_sim"
+    namespace: "telephony"
+    description: "This will make sure to send the IMSIKey to Modem in case SIM2 operator is same as SIM1"
+    bug:"400888891"
+}
+
+# OWNER=arunvoddu TARGET=25Q4
+flag {
+    name: "cat_service_creation_fix"
+    namespace: "telephony"
+    description: "Flag fix is to create the catService object with valid SIM Application"
+    bug:"417398404"
+}
\ No newline at end of file
diff --git a/proto/src/persist_atoms.proto b/proto/src/persist_atoms.proto
index d6dff87b83..27bd30448a 100644
--- a/proto/src/persist_atoms.proto
+++ b/proto/src/persist_atoms.proto
@@ -353,6 +353,7 @@ message IncomingSms {
     optional bool is_ntn = 17;
     optional bool is_emergency = 18;
     optional bool is_nb_iot_ntn = 19;
+    optional int32 pdu_length = 20;
 
     // Internal use only
     optional int32 hashCode = 10001;
@@ -381,6 +382,9 @@ message OutgoingSms {
     optional bool is_ntn = 20;
     optional bool is_mt_sms_polling = 21;
     optional bool is_nb_iot_ntn = 22;
+    optional int32 pdu_length = 23;
+    optional string calling_package_name = 24;
+    optional int32 app_uid = 25;
 
     // Internal use only
     optional int32 hashCode = 10001;
@@ -740,6 +744,8 @@ message SatelliteController {
     optional int32 count_of_outgoing_datagram_type_sms_fail = 41;
     optional int32 count_of_incoming_datagram_type_sms_success = 42;
     optional int32 count_of_incoming_datagram_type_sms_fail = 43;
+    optional int32 carrier_roaming_satellite_config_version = 44;
+    optional int32 max_allowed_data_mode = 45;
 }
 
 message SatelliteSession {
@@ -839,6 +845,19 @@ message CarrierRoamingSatelliteSession {
     optional int64 satellite_data_consumed_bytes = 19;
     optional bool is_multi_sim = 20;
     optional bool is_nb_iot_ntn = 21;
+    optional int32 count_of_data_connections = 22;
+    repeated int32 last_fail_causes = 23;
+    optional int32 count_of_data_disconnections = 24;
+    optional int32 count_of_data_stalls = 25;
+    optional int32 average_uplink_bandwidth_kbps = 26;
+    optional int32 average_downlink_bandwidth_kbps = 27;
+    optional int32 min_uplink_bandwidth_kbps = 28;
+    optional int32 max_uplink_bandwidth_kbps = 29;
+    optional int32 min_downlink_bandwidth_kbps = 30;
+    optional int32 max_downlink_bandwidth_kbps = 31;
+    repeated string satellite_supported_apps = 32;
+    repeated int32 satellite_supported_uids = 33;
+    repeated int64 per_app_satellite_data_consumed_bytes = 34;
 }
 
 message CarrierRoamingSatelliteControllerStats {
diff --git a/proto/src/telephony_config_update.proto b/proto/src/telephony_config_update.proto
index 83156ce44c..04e2ba06f0 100644
--- a/proto/src/telephony_config_update.proto
+++ b/proto/src/telephony_config_update.proto
@@ -27,6 +27,11 @@ message SatelliteConfigProto {
   optional int32 version = 1;
   repeated CarrierSupportedSatelliteServicesProto carrier_supported_satellite_services = 2;
   optional SatelliteRegionProto device_satellite_region = 3;
+  optional CarrierRoamingConfigProto carrier_roaming_config = 4;
+}
+
+message CarrierRoamingConfigProto {
+  optional int32 max_allowed_data_mode = 1;
 }
 
 message CarrierSupportedSatelliteServicesProto {
diff --git a/src/java/com/android/internal/telephony/CallManager.java b/src/java/com/android/internal/telephony/CallManager.java
index 26e107eb8c..9d19c17d69 100644
--- a/src/java/com/android/internal/telephony/CallManager.java
+++ b/src/java/com/android/internal/telephony/CallManager.java
@@ -30,8 +30,6 @@ import android.telephony.ServiceState;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.imsphone.ImsPhoneConnection;
-import com.android.server.telecom.flags.FeatureFlags;
-import com.android.server.telecom.flags.FeatureFlagsImpl;
 import com.android.telephony.Rlog;
 
 import java.util.ArrayList;
@@ -122,7 +120,6 @@ public class CallManager {
 
     private Object mRegistrantidentifier = new Object();
 
-    private FeatureFlags mTelecomFeatureFlags;
     // state registrants
     protected final RegistrantList mPreciseCallStateRegistrants
     = new RegistrantList();
@@ -199,7 +196,6 @@ public class CallManager {
         mBackgroundCalls = new ArrayList<Call>();
         mForegroundCalls = new ArrayList<Call>();
         mDefaultPhone = null;
-        mTelecomFeatureFlags = new FeatureFlagsImpl();
     }
 
     /**
@@ -2074,8 +2070,7 @@ public class CallManager {
                         incomingRejected = true;
                     }
                     if ((getActiveFgCallState(subId).isDialing() || hasMoreThanOneRingingCall())
-                            && (!incomingRejected)
-                            && !mTelecomFeatureFlags.enableCallSequencing()) {
+                            && (!incomingRejected)) {
                         try {
                             Rlog.d(LOG_TAG, "silently drop incoming call: " + c.getCall());
                             c.getCall().hangup();
diff --git a/src/java/com/android/internal/telephony/CarrierInfoManager.java b/src/java/com/android/internal/telephony/CarrierInfoManager.java
index 206770d316..896a721f3e 100644
--- a/src/java/com/android/internal/telephony/CarrierInfoManager.java
+++ b/src/java/com/android/internal/telephony/CarrierInfoManager.java
@@ -33,7 +33,6 @@ import android.text.TextUtils;
 import android.util.Log;
 import android.util.Pair;
 
-import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.metrics.TelephonyMetrics;
 
 import java.security.PublicKey;
@@ -302,12 +301,8 @@ public class CarrierInfoManager {
         final TelephonyManager telephonyManager = context.getSystemService(TelephonyManager.class)
                 .createForSubscriptionId(subId);
         int carrierId = telephonyManager.getSimCarrierId();
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            String simOperator = telephonyManager.getSimOperator();
-            deleteCarrierInfoForImsiEncryption(context, subId, carrierId, simOperator);
-        } else {
-            deleteCarrierInfoForImsiEncryption(context, subId, carrierId);
-        }
+        String simOperator = telephonyManager.getSimOperator();
+        deleteCarrierInfoForImsiEncryption(context, subId, carrierId, simOperator);
         Intent resetIntent = new Intent(TelephonyIntents.ACTION_CARRIER_CERTIFICATE_DOWNLOAD);
         SubscriptionManager.putPhoneIdAndSubIdExtra(resetIntent, mPhoneId);
         context.sendBroadcastAsUser(resetIntent, UserHandle.ALL);
diff --git a/src/java/com/android/internal/telephony/CarrierKeyDownloadManager.java b/src/java/com/android/internal/telephony/CarrierKeyDownloadManager.java
index 1667b7d616..c8cb155f8e 100644
--- a/src/java/com/android/internal/telephony/CarrierKeyDownloadManager.java
+++ b/src/java/com/android/internal/telephony/CarrierKeyDownloadManager.java
@@ -130,6 +130,8 @@ public class CarrierKeyDownloadManager extends Handler {
     private DefaultNetworkCallback mDefaultNetworkCallback;
     private ConnectivityManager mConnectivityManager;
     private KeyguardManager mKeyguardManager;
+    // This key will be used to track to send the IMSI key to modem.
+    private boolean mIsKeySent = false;
 
     public CarrierKeyDownloadManager(Phone phone) {
         mPhone = phone;
@@ -137,16 +139,12 @@ public class CarrierKeyDownloadManager extends Handler {
         IntentFilter filter = new IntentFilter();
         filter.addAction(INTENT_KEY_RENEWAL_ALARM_PREFIX);
         filter.addAction(TelephonyIntents.ACTION_CARRIER_CERTIFICATE_DOWNLOAD);
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            filter.addAction(Intent.ACTION_USER_UNLOCKED);
-        }
+        filter.addAction(Intent.ACTION_USER_UNLOCKED);
         mContext.registerReceiver(mBroadcastReceiver, filter, null, phone);
         mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);
         mTelephonyManager = mContext.getSystemService(TelephonyManager.class)
                 .createForSubscriptionId(mPhone.getSubId());
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
-        }
+        mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
         mUserManager = mContext.getSystemService(UserManager.class);
 
         CarrierConfigManager carrierConfigManager = mContext.getSystemService(
@@ -154,8 +152,12 @@ public class CarrierKeyDownloadManager extends Handler {
         // Callback which directly handle config change should be executed on handler thread
         if (carrierConfigManager != null) {
             carrierConfigManager.registerCarrierConfigChangeListener(this::post,
-                (slotIndex, subId, carrierId, specificCarrierId) -> {
-                    if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
+                    (slotIndex, subId, carrierId, specificCarrierId) -> {
+                        if (((slotIndex == mPhone.getPhoneId())
+                                && !SubscriptionManager.isValidSubscriptionId(subId))) {
+                            // Resetting the key when there is a change in carrier config.
+                            mIsKeySent = false;
+                        }
                         logd("CarrierConfig changed slotIndex = " + slotIndex + " subId = " + subId
                                 + " CarrierId = " + carrierId + " phoneId = "
                                 + mPhone.getPhoneId());
@@ -170,43 +172,21 @@ public class CarrierKeyDownloadManager extends Handler {
                                                 TelephonyManager.class)
                                         .createForSubscriptionId(subId);
                             }
-                            if (Flags.ignoreCarrieridResetForSimRemoval()) {
-                                if (carrierId > 0) {
-                                    mCarrierId = carrierId;
-                                }
-                            } else {
+                            if (carrierId > 0) {
                                 mCarrierId = carrierId;
                             }
                             updateSimOperator();
                             // If device is screen locked do not proceed to handle
                             // EVENT_ALARM_OR_CONFIG_CHANGE
                             printDeviceLockStatus();
-                            if (Flags.ignoreCarrieridResetForSimRemoval()) {
-                                if (!mUserManager.isUserUnlocked()) {
-                                    mIsRequiredToHandleUnlock = true;
-                                    return;
-                                }
-                            } else if (mKeyguardManager.isDeviceLocked()) {
+                            if (!mUserManager.isUserUnlocked()) {
                                 mIsRequiredToHandleUnlock = true;
                                 return;
                             }
                             logd("Carrier Config changed: slotIndex=" + slotIndex);
                             sendEmptyMessage(EVENT_ALARM_OR_CONFIG_CHANGE);
-
                         }
-                    } else {
-                        boolean isUserUnlocked = mUserManager.isUserUnlocked();
-
-                        if (isUserUnlocked && slotIndex == mPhone.getPhoneId()) {
-                            Log.d(LOG_TAG, "Carrier Config changed: slotIndex=" + slotIndex);
-                            handleAlarmOrConfigChange();
-                        } else {
-                            Log.d(LOG_TAG, "User is locked");
-                            mContext.registerReceiver(mUserUnlockedReceiver, new IntentFilter(
-                                    Intent.ACTION_USER_UNLOCKED));
-                        }
-                    }
-                });
+                    });
         }
         mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
     }
@@ -216,17 +196,6 @@ public class CarrierKeyDownloadManager extends Handler {
                 + "  iss User unlocked = " + mUserManager.isUserUnlocked());
     }
 
-    // TODO remove this method upon imsiKeyRetryDownloadOnPhoneUnlock enabled.
-    private final BroadcastReceiver mUserUnlockedReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (Intent.ACTION_USER_UNLOCKED.equals(intent.getAction())) {
-                Log.d(LOG_TAG, "Received UserUnlockedReceiver");
-                handleAlarmOrConfigChange();
-            }
-        }
-    };
-
     private final BroadcastReceiver mDownloadReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -251,9 +220,7 @@ public class CarrierKeyDownloadManager extends Handler {
                             -1);
                     if (slotIndexExtra == slotIndex) {
                         logd("Handling key renewal alarm: " + action);
-                        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-                            updateSimOperator();
-                        }
+                        updateSimOperator();
                         sendEmptyMessage(EVENT_ALARM_OR_CONFIG_CHANGE);
                     }
                 }
@@ -287,10 +254,8 @@ public class CarrierKeyDownloadManager extends Handler {
                     handleAlarmOrConfigChange();
             case EVENT_DOWNLOAD_COMPLETE -> {
                 long carrierKeyDownloadIdentifier = (long) msg.obj;
-                String currentMccMnc = Flags.imsiKeyRetryDownloadOnPhoneUnlock()
-                        ? mTelephonyManager.getSimOperator(mPhone.getSubId()) : getSimOperator();
-                int carrierId = Flags.imsiKeyRetryDownloadOnPhoneUnlock()
-                        ? mTelephonyManager.getSimCarrierId() : getSimCarrierId();
+                String currentMccMnc = mTelephonyManager.getSimOperator(mPhone.getSubId());
+                int carrierId = mTelephonyManager.getSimCarrierId();
                 if (isValidDownload(currentMccMnc, carrierKeyDownloadIdentifier, carrierId)) {
                     onDownloadComplete(carrierKeyDownloadIdentifier, currentMccMnc, carrierId);
                     onPostDownloadProcessing();
@@ -301,71 +266,64 @@ public class CarrierKeyDownloadManager extends Handler {
 
     private void onPostDownloadProcessing() {
         resetRenewalAlarm();
-        if(Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            mDownloadId = -1;
-        } else {
-            cleanupDownloadInfo();
-        }
+        mDownloadId = -1;
         // unregister from DOWNLOAD_COMPLETE
         mContext.unregisterReceiver(mDownloadReceiver);
     }
 
     private void handleAlarmOrConfigChange() {
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            if (carrierUsesKeys()) {
-                if (areCarrierKeysAbsentOrExpiring()) {
-                    boolean hasActiveDataNetwork =
-                            (mConnectivityManager.getActiveNetwork() != null);
-                    boolean downloadStartedSuccessfully = hasActiveDataNetwork && downloadKey();
-                    // if the download was attempted, but not started successfully, and if
-                    // carriers uses keys, we'll still want to renew the alarms, and try
-                    // downloading the key a day later.
-                    int slotIndex = SubscriptionManager.getSlotIndex(mPhone.getSubId());
-                    if (downloadStartedSuccessfully) {
-                        unregisterDefaultNetworkCb(slotIndex);
-                    } else {
-                        // If download fails due to the device user lock, we will reattempt once
-                        // the device is unlocked.
-                        if (Flags.ignoreCarrieridResetForSimRemoval()) {
-                            mIsRequiredToHandleUnlock = !mUserManager.isUserUnlocked();
-                        } else {
-                            mIsRequiredToHandleUnlock = mKeyguardManager.isDeviceLocked();
-                        }
-
-                        loge("hasActiveDataConnection = " + hasActiveDataNetwork
-                                + "    isDeviceUserLocked = " + mIsRequiredToHandleUnlock);
-                        if (!hasActiveDataNetwork) {
-                            registerDefaultNetworkCb(slotIndex);
-                        }
-                        resetRenewalAlarm();
+        if (carrierUsesKeys()) {
+            if (areCarrierKeysAbsentOrExpiring()) {
+                boolean hasActiveDataNetwork = (mConnectivityManager.getActiveNetwork() != null);
+                boolean downloadStartedSuccessfully = hasActiveDataNetwork && downloadKey();
+                logd("handleAlarmOrConfigChange :: downloadStartedSuccessfully "
+                        + downloadStartedSuccessfully);
+                // if the download was attempted, but not started successfully, and if
+                // carriers uses keys, we'll still want to renew the alarms, and try
+                // downloading the key a day later.
+                int slotIndex = SubscriptionManager.getSlotIndex(mPhone.getSubId());
+                if (downloadStartedSuccessfully) {
+                    unregisterDefaultNetworkCb(slotIndex);
+                } else {
+                    // If download fails due to the device user lock, we will reattempt once
+                    // the device is unlocked.
+                    mIsRequiredToHandleUnlock = !mUserManager.isUserUnlocked();
+                    loge("hasActiveDataConnection = " + hasActiveDataNetwork
+                            + "    isDeviceUserLocked = " + mIsRequiredToHandleUnlock);
+                    if (!hasActiveDataNetwork) {
+                        registerDefaultNetworkCb(slotIndex);
                     }
+                    resetRenewalAlarm();
                 }
-                logd("handleAlarmOrConfigChange :: areCarrierKeysAbsentOrExpiring returned false");
             } else {
-                cleanupRenewalAlarms();
-                if (!isOtherSlotHasCarrier()) {
-                    // delete any existing alarms.
-                    mPhone.deleteCarrierInfoForImsiEncryption(getSimCarrierId(), getSimOperator());
+                logd("handleAlarmOrConfigChange :: mIsKeySent " + mIsKeySent);
+                if (Flags.sendImsiKeyForDuplicateSim() && !mIsKeySent) {
+                    ImsiEncryptionInfo imsiEncryptionInfo = getExistingKey();
+                    if (imsiEncryptionInfo != null) {
+                        logd("handleAlarmOrConfigChange :: saving public key");
+                        savePublicKey(imsiEncryptionInfo);
+                    }
                 }
-                cleanupDownloadInfo();
             }
         } else {
-            if (carrierUsesKeys()) {
-                if (areCarrierKeysAbsentOrExpiring()) {
-                    boolean downloadStartedSuccessfully = downloadKey();
-                    // if the download was attempted, but not started successfully, and if
-                    // carriers uses keys, we'll still want to renew the alarms, and try
-                    // downloading the key a day later.
-                    if (!downloadStartedSuccessfully) {
-                        resetRenewalAlarm();
-                    }
-                }
-            } else {
+            cleanupRenewalAlarms();
+            if (!isOtherSlotHasCarrier()) {
                 // delete any existing alarms.
-                cleanupRenewalAlarms();
-                mPhone.deleteCarrierInfoForImsiEncryption(getSimCarrierId());
+                mPhone.deleteCarrierInfoForImsiEncryption(getSimCarrierId(), getSimOperator());
+                mIsKeySent = false;
+            }
+            cleanupDownloadInfo();
+        }
+    }
+
+    private ImsiEncryptionInfo getExistingKey() {
+        for (int type : CARRIER_KEY_TYPES) {
+            if (!isKeyEnabled(type)) {
+                continue;
             }
+            return mPhone.getCarrierInfoForImsiEncryption(type, false);
         }
+        return null;
     }
 
     private boolean isOtherSlotHasCarrier() {
@@ -390,11 +348,7 @@ public class CarrierKeyDownloadManager extends Handler {
     private void cleanupDownloadInfo() {
         logd("Cleaning up download info");
         mDownloadId = -1;
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            mMccMncForDownload = "";
-        } else {
-            mMccMncForDownload = null;
-        }
+        mMccMncForDownload = "";
         mCarrierId = TelephonyManager.UNKNOWN_CARRIER_ID;
     }
 
@@ -471,16 +425,14 @@ public class CarrierKeyDownloadManager extends Handler {
     }
 
     /**
-     * Read the store the sim operetor value and update the value in case of change in the sim
-     * operetor.
+     * Read the store the sim operator value and update the value in case of change in the sim
+     * operator.
      */
     public void updateSimOperator() {
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            String simOperator = mPhone.getOperatorNumeric();
-            if (!TextUtils.isEmpty(simOperator) && !simOperator.equals(mMccMncForDownload)) {
-                mMccMncForDownload = simOperator;
-                logd("updateSimOperator, Initialized mMccMncForDownload = " + mMccMncForDownload);
-            }
+        String simOperator = mPhone.getOperatorNumeric();
+        if (!TextUtils.isEmpty(simOperator) && !simOperator.equals(mMccMncForDownload)) {
+            mMccMncForDownload = simOperator;
+            logd("updateSimOperator, Initialized mMccMncForDownload = " + mMccMncForDownload);
         }
     }
 
@@ -489,12 +441,8 @@ public class CarrierKeyDownloadManager extends Handler {
      **/
     @VisibleForTesting
     public String getSimOperator() {
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            updateSimOperator();
-            return mMccMncForDownload;
-        } else {
-            return mTelephonyManager.getSimOperator(mPhone.getSubId());
-        }
+        updateSimOperator();
+        return mMccMncForDownload;
     }
 
     /**
@@ -502,11 +450,7 @@ public class CarrierKeyDownloadManager extends Handler {
      **/
     @VisibleForTesting
     public int getSimCarrierId() {
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            return (mCarrierId > 0) ? mCarrierId : mPhone.getCarrierId();
-        } else {
-            return mTelephonyManager.getSimCarrierId();
-        }
+        return (mCarrierId > 0) ? mCarrierId : mPhone.getCarrierId();
     }
 
     /**
@@ -709,13 +653,8 @@ public class CarrierKeyDownloadManager extends Handler {
                 Pair<PublicKey, Long> keyInfo =
                         getKeyInformation(cleanCertString(cert).getBytes());
                 if (mDeleteOldKeyAfterDownload) {
-                    if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-                        mPhone.deleteCarrierInfoForImsiEncryption(
-                                TelephonyManager.UNKNOWN_CARRIER_ID, null);
-                    } else {
-                        mPhone.deleteCarrierInfoForImsiEncryption(
-                                TelephonyManager.UNKNOWN_CARRIER_ID);
-                    }
+                    mPhone.deleteCarrierInfoForImsiEncryption(
+                            TelephonyManager.UNKNOWN_CARRIER_ID, null);
                     mDeleteOldKeyAfterDownload = false;
                 }
                 savePublicKey(keyInfo.first, type, identifier, keyInfo.second, mcc, mnc, carrierId);
@@ -781,24 +720,11 @@ public class CarrierKeyDownloadManager extends Handler {
         logd("starting download from: " + mURL);
         String mccMnc = null;
         int carrierId = -1;
-        if (Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-            if (TextUtils.isEmpty(mMccMncForDownload)
-                    || mCarrierId == TelephonyManager.UNKNOWN_CARRIER_ID) {
-                loge("mccmnc or carrierId is UnKnown");
-                return false;
-            }
-        } else {
-            mccMnc = getSimOperator();
-            carrierId = getSimCarrierId();
-            if (!TextUtils.isEmpty(mccMnc) || carrierId != TelephonyManager.UNKNOWN_CARRIER_ID) {
-                Log.d(LOG_TAG, "downloading key for mccmnc : " + mccMnc + ", carrierId : "
-                        + carrierId);
-            } else {
-                Log.e(LOG_TAG, "mccmnc or carrierId is UnKnown");
-                return false;
-            }
+        if (TextUtils.isEmpty(mMccMncForDownload)
+                || mCarrierId == TelephonyManager.UNKNOWN_CARRIER_ID) {
+            loge("mccmnc or carrierId is UnKnown");
+            return false;
         }
-
         try {
             // register the broadcast receiver to listen for download complete
             IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
@@ -813,10 +739,6 @@ public class CarrierKeyDownloadManager extends Handler {
             request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_HIDDEN);
             request.addRequestHeader("Accept-Encoding", "gzip");
             long carrierKeyDownloadRequestId = mDownloadManager.enqueue(request);
-            if (!Flags.imsiKeyRetryDownloadOnPhoneUnlock()) {
-                mMccMncForDownload = mccMnc;
-                mCarrierId = carrierId;
-            }
             mDownloadId = carrierKeyDownloadRequestId;
             logd("saving values mccmnc: " + mMccMncForDownload + ", downloadId: "
                     + carrierKeyDownloadRequestId + ", carrierId: " + mCarrierId);
@@ -858,7 +780,13 @@ public class CarrierKeyDownloadManager extends Handler {
             String mcc, String mnc, int carrierId) {
         ImsiEncryptionInfo imsiEncryptionInfo = new ImsiEncryptionInfo(mcc, mnc,
                 type, identifier, publicKey, new Date(expirationDate), carrierId);
-        mPhone.setCarrierInfoForImsiEncryption(imsiEncryptionInfo);
+        mPhone.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, true);
+        mIsKeySent = true;
+    }
+
+    public void savePublicKey(ImsiEncryptionInfo imsiEncryptionInfo) {
+        mPhone.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, false);
+        mIsKeySent = true;
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/CarrierResolver.java b/src/java/com/android/internal/telephony/CarrierResolver.java
index 829bf6c0b6..b4260fe49e 100644
--- a/src/java/com/android/internal/telephony/CarrierResolver.java
+++ b/src/java/com/android/internal/telephony/CarrierResolver.java
@@ -506,11 +506,7 @@ public class CarrierResolver extends Handler {
             intent.putExtra(TelephonyManager.EXTRA_SPECIFIC_CARRIER_ID, mSpecificCarrierId);
             intent.putExtra(TelephonyManager.EXTRA_SPECIFIC_CARRIER_NAME, mSpecificCarrierName);
             intent.putExtra(TelephonyManager.EXTRA_SUBSCRIPTION_ID, mPhone.getSubId());
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-            } else {
-                mContext.sendBroadcast(intent);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
 
             // notify content observers for specific carrier id change event.
             ContentValues cv = new ContentValues();
@@ -545,11 +541,7 @@ public class CarrierResolver extends Handler {
             intent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, mCarrierId);
             intent.putExtra(TelephonyManager.EXTRA_CARRIER_NAME, mCarrierName);
             intent.putExtra(TelephonyManager.EXTRA_SUBSCRIPTION_ID, mPhone.getSubId());
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-            } else {
-                mContext.sendBroadcast(intent);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
 
             // notify content observers for carrier id change event
             ContentValues cv = new ContentValues();
@@ -1030,7 +1022,21 @@ public class CarrierResolver extends Handler {
      * @return the best matching carrier id.
      */
     public static int getCarrierIdFromIdentifier(@NonNull Context context,
-                                                 @NonNull CarrierIdentifier carrierIdentifier) {
+            @NonNull CarrierIdentifier carrierIdentifier) {
+        return getCarrierIdFromIdentifier(context, carrierIdentifier, false);
+    }
+
+    /**
+     * a util function to convert carrierIdentifier to the best matching carrier id.
+     *
+     * @param useParentCid {@code true} to indicate that the parent carrier ID is required to be
+     *                     returned if it has valid value.
+     *
+     * @return the best matching carrier id.
+     */
+
+    public static int getCarrierIdFromIdentifier(@NonNull Context context,
+            @NonNull CarrierIdentifier carrierIdentifier, boolean useParentCid) {
         final String mccmnc = carrierIdentifier.getMcc() + carrierIdentifier.getMnc();
         final String gid1 = carrierIdentifier.getGid1();
         final String gid2 = carrierIdentifier.getGid2();
@@ -1059,7 +1065,11 @@ public class CarrierResolver extends Handler {
             rule.match(targetRule);
             if (rule.mScore > maxScore) {
                 maxScore = rule.mScore;
-                carrierId = rule.mCid;
+                if (useParentCid && rule.mParentCid != TelephonyManager.UNKNOWN_CARRIER_ID) {
+                    carrierId = rule.mParentCid;
+                } else {
+                    carrierId = rule.mCid;
+                }
             }
         }
         return carrierId;
diff --git a/src/java/com/android/internal/telephony/CarrierServiceBindHelper.java b/src/java/com/android/internal/telephony/CarrierServiceBindHelper.java
index 300ebdf624..9fb75c6fc7 100644
--- a/src/java/com/android/internal/telephony/CarrierServiceBindHelper.java
+++ b/src/java/com/android/internal/telephony/CarrierServiceBindHelper.java
@@ -445,19 +445,26 @@ public class CarrierServiceBindHelper {
         }
 
         private void maybeDisableCarrierNetworkChangeNotification() {
+            TelephonyRegistryManager telephonyRegistryManager =
+                    mContext.getSystemService(TelephonyRegistryManager.class);
+            // TODO(b/333571417): Consolidate to using the ForPhoneAndSubId variant during cleanup.
             int subscriptionId = SubscriptionManager.getSubscriptionId(mPhoneId);
-            // TODO(b/117525047): switch to phoneId-based solution when available in
-            // TelephonyRegistryManager to address SIM remove/disable case.
-            if (subscriptionId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            if (subscriptionId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                telephonyRegistryManager.notifyCarrierNetworkChange(subscriptionId, false);
+                return;
+            }
+
+            if (!Flags.cleanupCarrierNetworkChangeByPhoneid()) {
                 logdWithLocalLog(
                         "No valid subscription found when trying to disable carrierNetworkChange"
                                 + " for phoneId: "
                                 + mPhoneId);
-                return;
+            } else {
+                logdWithLocalLog(
+                        "Disabling carrierNetworkChange for phoneId: " + mPhoneId);
+                telephonyRegistryManager.notifyCarrierNetworkChange(
+                        mPhoneId, subscriptionId, false);
             }
-            TelephonyRegistryManager telephonyRegistryManager =
-                    mContext.getSystemService(TelephonyRegistryManager.class);
-            telephonyRegistryManager.notifyCarrierNetworkChange(subscriptionId, false);
         }
 
         @Override
diff --git a/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java b/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
index 1e73fbb2c0..38d336d6b8 100644
--- a/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
@@ -715,10 +715,15 @@ public class CarrierServiceStateTracker extends Handler {
          * notification
          */
         private Notification.Action createDoNotShowAgainAction(Context c) {
+            Intent broadcastIntent = new Intent(ACTION_NEVER_ASK_AGAIN);
+            if (mFeatureFlags.immediatelyProcessDoNotShowAgainBroadcast()) {
+                // Ensure immediate delivery of the broadcast to the receiver!
+                broadcastIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+            }
             final PendingIntent pendingIntent = PendingIntent.getBroadcast(
                     c,
                     0,
-                    new Intent(ACTION_NEVER_ASK_AGAIN),
+                    broadcastIntent,
                     PendingIntent.FLAG_IMMUTABLE);
             CharSequence text = "Do Not Ask Again";
             if (c != null && mFeatureFlags.dynamicDoNotAskAgainText()) {
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 1b19c99443..e8490ca288 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -27,6 +27,9 @@ import android.os.Message;
 import android.os.WorkSource;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.AccessNetworkConstants.AccessNetworkType;
+import android.telephony.AccessNetworkConstants.RadioAccessNetworkType;
+import android.telephony.AccessNetworkConstants.TransportType;
+import android.telephony.Annotation.DataState;
 import android.telephony.BarringInfo;
 import android.telephony.CarrierRestrictionRules;
 import android.telephony.ClientRequestStats;
@@ -55,6 +58,7 @@ import com.android.internal.telephony.uicc.IccCardStatus;
 import com.android.internal.telephony.uicc.SimPhonebookRecord;
 
 import java.util.List;
+import java.util.Set;
 
 /**
  * {@hide}
@@ -2587,6 +2591,28 @@ public interface CommandsInterface {
      */
     default void cancelHandover(Message result, int callId) {};
 
+    /**
+     * Tells the modem if user data setting is enabled or disabled.
+     *
+     * This API is for informational purposes. The modem must not block any subsequent setup data
+     * call requests.
+     *
+     * @param result  Message that will be sent back to handler.
+     * @param enabled Whether the user mobile data is enabled.
+     */
+    default void setUserDataEnabled(Message result, boolean enabled) {};
+
+    /**
+     * Tells the modem if user data roaming setting is enabled or disabled.
+     *
+     * This API is for informational purposes. The modem must not block any subsequent setup data
+     * call requests.
+     *
+     * @param result  Message that will be sent back to handler.
+     * @param enabled Whether the user mobile data roaming is enabled.
+     */
+    default void setUserDataRoamingEnabled(Message result, boolean enabled) {};
+
     /**
      * Control the data throttling at modem.
      *
@@ -2987,4 +3013,35 @@ public interface CommandsInterface {
      * @param result Callback message to receive the result.
      */
     default void isSatelliteEnabledForCarrier(int simSlot, Message result) {}
+
+    /**
+     * Update allowed IMS services to the modem. The modem can use the information for 3GPP
+     * specifications and carriers' requirements e.g. system determination.
+     *
+     * @param allowedImsServicesAny Which IMS services are allowed for both home and roaming state.
+     * @param allowedImsServicesHomeOnly Which IMS services are allowed for home state only.
+     * @param result Callback message to receive the result.
+     */
+    default void updateAllowedImsServices(@NonNull Set<Integer> allowedImsServicesAny,
+            @NonNull Set<Integer> allowedImsServicesHomeOnly, @Nullable Message result) {}
+
+    /**
+     * Notify IMS data network to the modem.
+     *
+     * @param accessNetwork The access network type.
+     * @param dataNetworkState The data network connection state.
+     * @param physicalTransportType The physical transport type of the data network.
+     * @param physicalNetworkSlotIndex The slot index while the physical transport type is
+     *        {@link AccessNetworkConstants#TRANSPORT_TYPE_WWAN}. If the physical transport type is
+     *        {@link AccessNetworkConstants#TRANSPORT_TYPE_WLAN}, this slot index will be
+     *        {@link SubscriptionManager#INVALID_SIM_SLOT_INDEX}.
+     * @param result Callback message to receive the result.
+     *
+     * Response function is IRadioDataResponse.notifyImsDataNetworkResponse()
+     *
+     * This is available when android.hardware.telephony.data is defined.
+     */
+    default void notifyImsDataNetwork(@RadioAccessNetworkType int accessNetwork,
+            @DataState int dataNetworkState, @TransportType int physicalTransportType,
+            int physicalNetworkSlotIndex, @Nullable Message result) {}
 }
diff --git a/src/java/com/android/internal/telephony/DataResponse.java b/src/java/com/android/internal/telephony/DataResponse.java
index bef1da7317..963e358fb3 100644
--- a/src/java/com/android/internal/telephony/DataResponse.java
+++ b/src/java/com/android/internal/telephony/DataResponse.java
@@ -230,6 +230,27 @@ public class DataResponse extends IRadioDataResponse.Stub {
         }
     }
 
+    /**
+     * @param responseInfo Response info struct containing response type, serial no. and error
+     */
+    public void setUserDataEnabledResponse(RadioResponseInfo responseInfo) {
+        RadioResponse.responseVoid(HAL_SERVICE_DATA, mRil, responseInfo);
+    }
+
+    /**
+     * @param responseInfo Response info struct containing response type, serial no. and error
+     */
+    public void setUserDataRoamingEnabledResponse(RadioResponseInfo responseInfo) {
+        RadioResponse.responseVoid(HAL_SERVICE_DATA, mRil, responseInfo);
+    }
+
+    /**
+     * @param responseInfo Response info struct containing response type, serial no. and error
+     */
+    public void notifyImsDataNetworkResponse(RadioResponseInfo responseInfo) {
+        RadioResponse.responseVoid(HAL_SERVICE_DATA, mRil, responseInfo);
+    }
+
     @Override
     public String getInterfaceHash() {
         return IRadioDataResponse.HASH;
diff --git a/src/java/com/android/internal/telephony/GsmCdmaPhone.java b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
index f08e237317..8d25354824 100644
--- a/src/java/com/android/internal/telephony/GsmCdmaPhone.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
@@ -91,6 +91,7 @@ import android.telephony.TelephonyManager;
 import android.telephony.UiccAccessRule;
 import android.telephony.UssdResponse;
 import android.telephony.ims.ImsCallProfile;
+import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.Log;
@@ -453,7 +454,8 @@ public class GsmCdmaPhone extends Phone {
                 int newPreferredTtyMode = intent.getIntExtra(
                         TelecomManager.EXTRA_TTY_PREFERRED_MODE, TelecomManager.TTY_MODE_OFF);
                 updateUiTtyMode(newPreferredTtyMode);
-            } else if (TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED.equals(action)) {
+            } else if (TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED.equals(action)
+                           || TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED.equals(action)) {
                 if (mPhoneId == intent.getIntExtra(
                         SubscriptionManager.EXTRA_SLOT_INDEX,
                         SubscriptionManager.INVALID_SIM_SLOT_INDEX)) {
@@ -462,6 +464,11 @@ public class GsmCdmaPhone extends Phone {
                     if (mSimState == TelephonyManager.SIM_STATE_LOADED
                             && currentSlotSubIdChanged()) {
                         setNetworkSelectionModeAutomatic(null);
+                    } else if (mSimState == TelephonyManager.SIM_STATE_ABSENT
+                            || mSimState == TelephonyManager.SIM_STATE_UNKNOWN) {
+                        // Clear allowed services while SIM is absent or unknown e.g. modem crash.
+                        // Telephony will update allowed services after SIM is loaded.
+                        clearAllowedImsServices();
                     }
                 }
             }
@@ -529,6 +536,9 @@ public class GsmCdmaPhone extends Phone {
         filter.addAction(TelecomManager.ACTION_CURRENT_TTY_MODE_CHANGED);
         filter.addAction(TelecomManager.ACTION_TTY_PREFERRED_MODE_CHANGED);
         filter.addAction(TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED);
+        if (mFeatureFlags.allowedServices()) {
+            filter.addAction(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
+        }
         mContext.registerReceiver(mBroadcastReceiver, filter,
                 android.Manifest.permission.MODIFY_PHONE_STATE, null, Context.RECEIVER_EXPORTED);
 
@@ -2121,8 +2131,12 @@ public class GsmCdmaPhone extends Phone {
     }
 
     @Override
-    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
-        CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext, mPhoneId);
+    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo,
+            boolean saveToDb) {
+        if (saveToDb) {
+            CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext,
+                    mPhoneId);
+        }
         mCi.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, null);
     }
 
@@ -5325,6 +5339,7 @@ public class GsmCdmaPhone extends Phone {
         boolean enbleVonr = mIsVonrEnabledByCarrier
                 && (setting == 1 || (setting == -1 && mDefaultVonr));
         mCi.setVoNrEnabled(enbleVonr, obtainMessage(EVENT_SET_VONR_ENABLED_DONE), null);
+        super.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_NR, enbleVonr);
     }
 
     private void updateCdmaRoamingSettingsAfterCarrierConfigChanged(
diff --git a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
index 4a3e7b0e00..bd537c36b3 100644
--- a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
@@ -409,14 +409,14 @@ public class IccSmsInterfaceManager {
      */
     public void sendDataWithSelfPermissions(String callingPackage, int callingUser,
             String callingAttributionTag, String destAddr, String scAddr, int destPort, byte[] data,
-            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean isForVvm) {
+            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean isForVvm, int uid) {
         if (!mSmsPermissions.checkCallingOrSelfCanSendSms(callingPackage, callingAttributionTag,
                 "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntent);
             return;
         }
         sendDataInternal(callingPackage, callingUser, destAddr, scAddr, destPort, data, sentIntent,
-                deliveryIntent, isForVvm);
+                deliveryIntent, isForVvm, uid);
     }
 
     /**
@@ -428,7 +428,7 @@ public class IccSmsInterfaceManager {
     public void sendData(String callingPackage, int callingUser, String destAddr, String scAddr,
             int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
         sendData(callingPackage, callingUser, null, destAddr, scAddr, destPort, data,
-                sentIntent, deliveryIntent);
+                sentIntent, deliveryIntent, android.os.Process.INVALID_UID);
     }
 
     /**
@@ -437,14 +437,14 @@ public class IccSmsInterfaceManager {
      */
     public void sendData(String callingPackage, int callingUser, String callingAttributionTag,
             String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent,
-            PendingIntent deliveryIntent) {
+            PendingIntent deliveryIntent, int uid) {
         if (!mSmsPermissions.checkCallingCanSendSms(callingPackage, callingAttributionTag,
                 "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntent);
             return;
         }
         sendDataInternal(callingPackage, callingUser, destAddr, scAddr, destPort, data, sentIntent,
-                deliveryIntent, false /* isForVvm */);
+                deliveryIntent, false /* isForVvm */, uid);
     }
 
     /**
@@ -476,7 +476,7 @@ public class IccSmsInterfaceManager {
 
     private void sendDataInternal(String callingPackage, int callinUser, String destAddr,
             String scAddr, int destPort, byte[] data, PendingIntent sentIntent,
-            PendingIntent deliveryIntent, boolean isForVvm) {
+            PendingIntent deliveryIntent, boolean isForVvm, int uid) {
         if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
             log("sendData: destAddr=" + destAddr + " scAddr=" + scAddr + " destPort="
                     + destPort + " data='" + HexDump.toHexString(data)  + "' sentIntent="
@@ -484,7 +484,7 @@ public class IccSmsInterfaceManager {
         }
         destAddr = filterDestAddress(destAddr);
         mDispatchersController.sendData(callingPackage, callinUser, destAddr, scAddr,
-                destPort, data, sentIntent, deliveryIntent, isForVvm);
+                destPort, data, sentIntent, deliveryIntent, isForVvm, uid);
     }
 
     /**
@@ -494,12 +494,13 @@ public class IccSmsInterfaceManager {
      */
     public void sendText(String callingPackage, int callingUser, String destAddr, String scAddr,
             String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean persistMessageForNonDefaultSmsApp, long messageId, boolean skipShortCodeCheck) {
+            boolean persistMessageForNonDefaultSmsApp, long messageId, boolean skipShortCodeCheck,
+            int uid) {
         sendTextInternal(callingPackage, callingUser, destAddr, scAddr, text, sentIntent,
                 deliveryIntent, persistMessageForNonDefaultSmsApp,
                 SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false /* expectMore */,
                 SMS_MESSAGE_PERIOD_NOT_SPECIFIED, false /* isForVvm */,
-                messageId, skipShortCodeCheck);
+                messageId, skipShortCodeCheck, uid);
     }
 
     /**
@@ -509,7 +510,7 @@ public class IccSmsInterfaceManager {
     public void sendTextWithSelfPermissions(String callingPackage, int callingUser,
             String callingAttributeTag, String destAddr, String scAddr, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage,
-            boolean isForVvm) {
+            boolean isForVvm, int uid) {
         if (!mSmsPermissions.checkCallingOrSelfCanSendSms(callingPackage, callingAttributeTag,
                 "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntent);
@@ -518,17 +519,17 @@ public class IccSmsInterfaceManager {
         sendTextInternal(callingPackage, callingUser, destAddr, scAddr, text, sentIntent,
                 deliveryIntent, persistMessage, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                 false /* expectMore */, SMS_MESSAGE_PERIOD_NOT_SPECIFIED,
-                isForVvm, 0L /* messageId */);
+                isForVvm, 0L /* messageId */, uid);
     }
 
 
     private void sendTextInternal(String callingPackage, int callingUser, String destAddr,
             String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
             boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore,
-            int validityPeriod, boolean isForVvm, long messageId) {
+            int validityPeriod, boolean isForVvm, long messageId, int uid) {
         sendTextInternal(callingPackage, callingUser, destAddr, scAddr, text, sentIntent,
                 deliveryIntent, persistMessageForNonDefaultSmsApp, priority, expectMore,
-                validityPeriod, isForVvm, messageId, false);
+                validityPeriod, isForVvm, messageId, false, uid);
     }
 
     /**
@@ -583,7 +584,8 @@ public class IccSmsInterfaceManager {
     private void sendTextInternal(String callingPackage, int callingUser, String destAddr,
             String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
             boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore,
-            int validityPeriod, boolean isForVvm, long messageId, boolean skipShortCodeCheck) {
+            int validityPeriod, boolean isForVvm, long messageId, boolean skipShortCodeCheck,
+            int uid) {
         if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
             log("sendText: destAddr=" + destAddr + " scAddr=" + scAddr
                     + " text='" + text + "' sentIntent=" + sentIntent + " deliveryIntent="
@@ -595,7 +597,7 @@ public class IccSmsInterfaceManager {
         destAddr = filterDestAddress(destAddr);
         mDispatchersController.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent,
                 null/*messageUri*/, callingPackage, callingUser, persistMessageForNonDefaultSmsApp,
-                priority, expectMore, validityPeriod, isForVvm, messageId, skipShortCodeCheck);
+                priority, expectMore, validityPeriod, isForVvm, messageId, skipShortCodeCheck, uid);
     }
 
     /**
@@ -648,7 +650,7 @@ public class IccSmsInterfaceManager {
             String callingAttributionTag, String destAddr, String scAddr, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent,
             boolean persistMessageForNonDefaultSmsApp, int priority,
-            boolean expectMore, int validityPeriod) {
+            boolean expectMore, int validityPeriod, int uid) {
         if (!mSmsPermissions.checkCallingCanSendText(persistMessageForNonDefaultSmsApp,
                     callingPackage, callingAttributionTag, "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntent);
@@ -656,7 +658,7 @@ public class IccSmsInterfaceManager {
         }
         sendTextInternal(callingPackage, callingUser, destAddr, scAddr, text, sentIntent,
                 deliveryIntent, persistMessageForNonDefaultSmsApp, priority, expectMore,
-                validityPeriod, false /* isForVvm */, 0L /* messageId */);
+                validityPeriod, false /* isForVvm */, 0L /* messageId */, uid);
     }
 
     /**
@@ -725,12 +727,12 @@ public class IccSmsInterfaceManager {
     public void sendMultipartText(String callingPackage, int callingUser,
             String callingAttributionTag, String destAddr, String scAddr, List<String> parts,
             List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents,
-            boolean persistMessageForNonDefaultSmsApp, long messageId) {
+            boolean persistMessageForNonDefaultSmsApp, long messageId, int uid) {
         sendMultipartTextWithOptions(callingPackage, callingUser, callingAttributionTag, destAddr,
                 scAddr, parts, sentIntents, deliveryIntents, persistMessageForNonDefaultSmsApp,
                 SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false /* expectMore */,
                 SMS_MESSAGE_PERIOD_NOT_SPECIFIED,
-                messageId);
+                messageId, uid);
     }
 
     /**
@@ -786,7 +788,7 @@ public class IccSmsInterfaceManager {
             String callingAttributionTag, String destAddr, String scAddr, List<String> parts,
             List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents,
             boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore,
-            int validityPeriod, long messageId) {
+            int validityPeriod, long messageId, int uid) {
         if (!mSmsPermissions.checkCallingCanSendText(persistMessageForNonDefaultSmsApp,
                 callingPackage, callingAttributionTag, "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntents);
@@ -828,7 +830,7 @@ public class IccSmsInterfaceManager {
                 mDispatchersController.sendText(destAddr, scAddr, singlePart, singleSentIntent,
                         singleDeliveryIntent, null /* messageUri */, callingPackage, callingUser,
                         persistMessageForNonDefaultSmsApp, priority, expectMore, validityPeriod,
-                        false /* isForVvm */, messageId);
+                        false /* isForVvm */, messageId, uid);
             }
             return;
         }
@@ -839,7 +841,7 @@ public class IccSmsInterfaceManager {
                 (ArrayList<PendingIntent>) sentIntents,
                 (ArrayList<PendingIntent>) deliveryIntents,
                 null, callingPackage, callingUser, persistMessageForNonDefaultSmsApp,
-                priority, expectMore, validityPeriod, messageId);
+                priority, expectMore, validityPeriod, messageId, uid);
 
     }
 
@@ -1292,12 +1294,12 @@ public class IccSmsInterfaceManager {
     public void sendStoredText(String callingPkg, int callingUser, Uri messageUri, String scAddress,
             PendingIntent sentIntent, PendingIntent deliveryIntent) {
         sendStoredText(callingPkg, callingUser, null, messageUri,
-                scAddress, sentIntent, deliveryIntent);
+                scAddress, sentIntent, deliveryIntent, android.os.Process.INVALID_UID);
     }
 
     public void sendStoredText(String callingPkg, int callingUser, String callingAttributionTag,
             Uri messageUri, String scAddress, PendingIntent sentIntent,
-            PendingIntent deliveryIntent) {
+            PendingIntent deliveryIntent, int uid) {
         if (!mSmsPermissions.checkCallingCanSendSms(callingPkg, callingAttributionTag,
                 "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntent);
@@ -1325,7 +1327,7 @@ public class IccSmsInterfaceManager {
                 sentIntent, deliveryIntent, messageUri, callingPkg, callingUser,
                 true /* persistMessageForNonDefaultSmsApp */, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                 false /* expectMore */, SMS_MESSAGE_PERIOD_NOT_SPECIFIED, false /* isForVvm */,
-                0L /* messageId */);
+                0L /* messageId */, uid);
     }
 
     /**
@@ -1338,12 +1340,13 @@ public class IccSmsInterfaceManager {
             Uri messageUri, String scAddress, List<PendingIntent> sentIntents,
             List<PendingIntent> deliveryIntents) {
         sendStoredMultipartText(callingPkg, callingUser, null,
-                messageUri, scAddress, sentIntents, deliveryIntents);
+                messageUri, scAddress, sentIntents, deliveryIntents,
+                android.os.Process.INVALID_UID);
     }
 
     public void sendStoredMultipartText(String callingPkg, int callingUser,
             String callingAttributionTag, Uri messageUri, String scAddress,
-            List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
+            List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, int uid) {
         if (!mSmsPermissions.checkCallingCanSendSms(callingPkg, callingAttributionTag,
                 "Sending SMS message")) {
             returnUnspecifiedFailure(sentIntents);
@@ -1397,7 +1400,7 @@ public class IccSmsInterfaceManager {
                         callingUser, true  /* persistMessageForNonDefaultSmsApp */,
                         SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                         false /* expectMore */, SMS_MESSAGE_PERIOD_NOT_SPECIFIED,
-                        false /* isForVvm */, 0L /* messageId */);
+                        false /* isForVvm */, 0L /* messageId */, uid);
             }
             return;
         }
@@ -1414,7 +1417,8 @@ public class IccSmsInterfaceManager {
                 SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                 false /* expectMore */,
                 SMS_MESSAGE_PERIOD_NOT_SPECIFIED,
-                0L /* messageId */);
+                0L /* messageId */,
+                uid);
     }
 
     public int getSmsCapacityOnIcc(String callingPackage, String callingFeatureId) {
diff --git a/src/java/com/android/internal/telephony/ImsResponse.java b/src/java/com/android/internal/telephony/ImsResponse.java
index 1adc000063..31f383dfa9 100644
--- a/src/java/com/android/internal/telephony/ImsResponse.java
+++ b/src/java/com/android/internal/telephony/ImsResponse.java
@@ -107,4 +107,11 @@ public class ImsResponse extends IRadioImsResponse.Stub {
     public void updateImsCallStatusResponse(RadioResponseInfo info) {
         RadioResponse.responseVoid(HAL_SERVICE_IMS, mRil, info);
     }
+
+    /**
+     * @param info Response info struct containing response type, serial no. and error.
+     */
+    public void updateAllowedServicesResponse(RadioResponseInfo info) {
+        RadioResponse.responseVoid(HAL_SERVICE_IMS, mRil, info);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ImsSmsDispatcher.java b/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
index 76b3a17015..e2ee18872d 100644
--- a/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
+++ b/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
@@ -16,6 +16,7 @@
 
 package com.android.internal.telephony;
 
+import android.annotation.NonNull;
 import android.app.Activity;
 import android.content.Context;
 import android.os.Binder;
@@ -41,6 +42,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.GsmAlphabet.TextEncodingDetails;
 import com.android.internal.telephony.analytics.TelephonyAnalytics;
 import com.android.internal.telephony.analytics.TelephonyAnalytics.SmsMmsAnalytics;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.metrics.TelephonyMetrics;
 import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.telephony.util.SMSDispatcherUtil;
@@ -249,7 +251,10 @@ public class ImsSmsDispatcher extends SMSDispatcher {
                         tracker.isFromDefaultSmsApplication(mContext),
                         tracker.getInterval(),
                         mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                        tracker.isMtSmsPollingMessage(mContext));
+                        tracker.isMtSmsPollingMessage(mContext),
+                        tracker.getPduLength(),
+                        tracker.getAppPackageName(),
+                        tracker.getAppUid());
                 if (mPhone != null) {
                     TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
                     if (telephonyAnalytics != null) {
@@ -362,8 +367,8 @@ public class ImsSmsDispatcher extends SMSDispatcher {
     }
 
     public ImsSmsDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
-            FeatureConnectorFactory factory) {
-        super(phone, smsDispatchersController);
+            FeatureConnectorFactory factory, @NonNull FeatureFlags featureFlags) {
+        super(phone, smsDispatchersController, featureFlags);
         mConnectorFactory = factory;
 
         mImsManagerConnector = mConnectorFactory.create(mContext, mPhone.getPhoneId(), TAG,
@@ -668,7 +673,10 @@ public class ImsSmsDispatcher extends SMSDispatcher {
                     tracker.isFromDefaultSmsApplication(mContext),
                     tracker.getInterval(),
                     mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                    tracker.isMtSmsPollingMessage(mContext));
+                    tracker.isMtSmsPollingMessage(mContext),
+                    tracker.getPduLength(),
+                    tracker.getAppPackageName(),
+                    tracker.getAppUid());
             if (mPhone != null) {
                 TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
                 if (telephonyAnalytics != null) {
diff --git a/src/java/com/android/internal/telephony/InboundSmsHandler.java b/src/java/com/android/internal/telephony/InboundSmsHandler.java
index 52ceda57c7..e9dfff8acb 100644
--- a/src/java/com/android/internal/telephony/InboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/InboundSmsHandler.java
@@ -76,7 +76,6 @@ import com.android.internal.telephony.SmsConstants.MessageClass;
 import com.android.internal.telephony.analytics.TelephonyAnalytics;
 import com.android.internal.telephony.analytics.TelephonyAnalytics.SmsMmsAnalytics;
 import com.android.internal.telephony.flags.FeatureFlags;
-import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.metrics.TelephonyMetrics;
 import com.android.internal.telephony.satellite.SatelliteController;
 import com.android.internal.telephony.satellite.metrics.CarrierRoamingSatelliteSessionStats;
@@ -780,7 +779,7 @@ public abstract class InboundSmsHandler extends StateMachine {
         if (result != Intents.RESULT_SMS_HANDLED && result != Activity.RESULT_OK) {
             mMetrics.writeIncomingSmsError(mPhone.getPhoneId(), is3gpp2(), smsSource, result);
             mPhone.getSmsStats().onIncomingSmsError(is3gpp2(), smsSource, result,
-                    isEmergencyNumber(smsb.getOriginatingAddress()));
+                    isEmergencyNumber(smsb.getOriginatingAddress()), 0);
             if (mPhone != null) {
                 TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
                 if (telephonyAnalytics != null) {
@@ -832,12 +831,8 @@ public abstract class InboundSmsHandler extends StateMachine {
             Intent intent = new Intent(Intents.SMS_REJECTED_ACTION);
             intent.putExtra("result", result);
             intent.putExtra("subId", mPhone.getSubId());
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                        android.Manifest.permission.RECEIVE_SMS);
-            } else {
-                mContext.sendBroadcast(intent, android.Manifest.permission.RECEIVE_SMS);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                    android.Manifest.permission.RECEIVE_SMS);
         }
         acknowledgeLastIncomingSms(success, result, response);
     }
@@ -1059,7 +1054,7 @@ public abstract class InboundSmsHandler extends StateMachine {
             logeWithLocalLog(errorMsg, tracker.getMessageId());
             mPhone.getSmsStats().onIncomingSmsError(
                     is3gpp2(), tracker.getSource(), RESULT_SMS_NULL_PDU,
-                    isEmergencyNumber(tracker.getAddress()));
+                    isEmergencyNumber(tracker.getAddress()), 0);
             if (mPhone != null) {
                 TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
                 if (telephonyAnalytics != null) {
@@ -1089,7 +1084,7 @@ public abstract class InboundSmsHandler extends StateMachine {
                                 tracker.getMessageId());
                         mPhone.getSmsStats().onIncomingSmsWapPush(tracker.getSource(),
                                 messageCount, RESULT_SMS_NULL_MESSAGE, tracker.getMessageId(),
-                                isEmergencyNumber(tracker.getAddress()));
+                                isEmergencyNumber(tracker.getAddress()), 0);
                         return false;
                     }
                 }
@@ -1121,10 +1116,12 @@ public abstract class InboundSmsHandler extends StateMachine {
             // needs to be ignored, so treating it as a success case.
             boolean wapPushResult =
                     result == Activity.RESULT_OK || result == Intents.RESULT_SMS_HANDLED;
+            int pduLength = wapPushResult ? output.size() : 0;
             mMetrics.writeIncomingWapPush(mPhone.getPhoneId(), tracker.getSource(),
                     format, timestamps, wapPushResult, tracker.getMessageId());
             mPhone.getSmsStats().onIncomingSmsWapPush(tracker.getSource(), messageCount,
-                    result, tracker.getMessageId(), isEmergencyNumber(tracker.getAddress()));
+                    result, tracker.getMessageId(), isEmergencyNumber(tracker.getAddress()),
+                    pduLength);
             // result is Activity.RESULT_OK if an ordered broadcast was sent
             if (result == Activity.RESULT_OK) {
                 return true;
@@ -1145,7 +1142,7 @@ public abstract class InboundSmsHandler extends StateMachine {
                 format, timestamps, block, tracker.getMessageId());
         mPhone.getSmsStats().onIncomingSmsSuccess(is3gpp2(), tracker.getSource(),
                 messageCount, block, tracker.getMessageId(),
-                isEmergencyNumber(tracker.getAddress()));
+                isEmergencyNumber(tracker.getAddress()), getTotalPduLength(pdus));
         CarrierRoamingSatelliteSessionStats sessionStats =
                 CarrierRoamingSatelliteSessionStats.getInstance(mPhone.getSubId());
         sessionStats.onIncomingSms(mPhone.getSubId());
@@ -2020,6 +2017,24 @@ public abstract class InboundSmsHandler extends StateMachine {
             & RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE) > 0;
     }
 
+    /** Determines pdu length in bytes from the given SmsMessageBase. */
+    public static int getPduLength(SmsMessageBase sms) {
+        byte[] pduBytes = sms != null ? sms.getPdu() : null;
+        return (pduBytes != null) ? pduBytes.length : 0;
+    }
+
+    private int getTotalPduLength(byte[][] pdus) {
+        int totalPduLength = 0;
+        if (pdus != null) {
+            for (byte[] p : pdus) {
+                if (p != null) {
+                    totalPduLength += p.length;
+                }
+            }
+        }
+        return totalPduLength;
+    }
+
     /**
      * Log with debug level in logcat and LocalLog
      * @param logMsg msg to log
@@ -2196,9 +2211,7 @@ public abstract class InboundSmsHandler extends StateMachine {
                 UserManager userManager =
                         (UserManager) context.getSystemService(Context.USER_SERVICE);
                 PackageManager pm = context.getPackageManager();
-                if (Flags.hsumPackageManager()) {
-                    pm = context.createContextAsUser(UserHandle.CURRENT, 0).getPackageManager();
-                }
+                pm = context.createContextAsUser(UserHandle.CURRENT, 0).getPackageManager();
                 if (userManager.isUserUnlocked()) {
                     context.startActivityAsUser(pm.getLaunchIntentForPackage(
                             Telephony.Sms.getDefaultSmsPackage(context)), UserHandle.CURRENT);
diff --git a/src/java/com/android/internal/telephony/MccTable.java b/src/java/com/android/internal/telephony/MccTable.java
index 211c88b6b0..4e46a0fb1a 100644
--- a/src/java/com/android/internal/telephony/MccTable.java
+++ b/src/java/com/android/internal/telephony/MccTable.java
@@ -336,8 +336,7 @@ public final class MccTable {
     public static final Map<Locale, Locale> FALLBACKS = new HashMap<Locale, Locale>();
 
     public static boolean isNewMccTableEnabled() {
-        return com.android.icu.Flags.telephonyLookupMccExtension()
-                && com.android.internal.telephony.flags.Flags.useI18nForMccMapping();
+        return com.android.internal.telephony.flags.Flags.useI18nForMccMapping();
     }
 
     static {
diff --git a/src/java/com/android/internal/telephony/MultiSimSettingController.java b/src/java/com/android/internal/telephony/MultiSimSettingController.java
index bdde74d622..7e1d11813c 100644
--- a/src/java/com/android/internal/telephony/MultiSimSettingController.java
+++ b/src/java/com/android/internal/telephony/MultiSimSettingController.java
@@ -790,11 +790,7 @@ public class MultiSimSettingController extends Handler {
         intent.putExtra(EXTRA_DEFAULT_SUBSCRIPTION_SELECT_TYPE, type);
         intent.putExtra(EXTRA_SUBSCRIPTION_ID, defaultSubId);
 
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } else {
-            mContext.sendBroadcast(intent);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
     }
 
     private void sendSubChangeNotificationIfNeeded(int change, boolean dataSelected,
@@ -832,11 +828,7 @@ public class MultiSimSettingController extends Handler {
             if (simCombinationParams.mWarningType == EXTRA_SIM_COMBINATION_WARNING_TYPE_DUAL_CDMA) {
                 intent.putExtra(EXTRA_SIM_COMBINATION_NAMES, simCombinationParams.mSimNames);
             }
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-            } else {
-                mContext.sendBroadcast(intent);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/NetworkIndication.java b/src/java/com/android/internal/telephony/NetworkIndication.java
index 5c492349cd..52ed46cf1f 100644
--- a/src/java/com/android/internal/telephony/NetworkIndication.java
+++ b/src/java/com/android/internal/telephony/NetworkIndication.java
@@ -330,9 +330,10 @@ public class NetworkIndication extends IRadioNetworkIndication.Stub {
             reportAnomaly(UUID.fromString("f16e5703-6105-4341-9eb3-e68189156eb5"),
                     "Invalid registrationFailed indication");
 
-            mRil.riljLoge("Invalid registrationFailed indication (ci is null)=" + (ci == null)
+            mRil.riljLoge("Invalid registrationFailed indication ci =" + ci
                     + " (chosenPlmn is empty)=" + TextUtils.isEmpty(chosenPlmn)
-                    + " (is CS/PS)=" + ((domain & NetworkRegistrationInfo.DOMAIN_CS_PS) == 0)
+                    + " (domain)=" + domain
+                    + " (neither CS/PS)=" + ((domain & NetworkRegistrationInfo.DOMAIN_CS_PS) == 0)
                     + " (only CS/PS)=" + ((domain & ~NetworkRegistrationInfo.DOMAIN_CS_PS) != 0)
                     + " (causeCode)=" + causeCode
                     + " (additionalCauseCode)=" + additionalCauseCode);
diff --git a/src/java/com/android/internal/telephony/NetworkTypeController.java b/src/java/com/android/internal/telephony/NetworkTypeController.java
index f05e002550..65339b17a5 100644
--- a/src/java/com/android/internal/telephony/NetworkTypeController.java
+++ b/src/java/com/android/internal/telephony/NetworkTypeController.java
@@ -209,6 +209,7 @@ public class NetworkTypeController extends StateMachine {
     private int mLtePlusThresholdBandwidth;
     private int mNrAdvancedThresholdBandwidth;
     private boolean mIncludeLteForNrAdvancedThresholdBandwidth;
+    private boolean mNrAdvancedRequiresSingleCcAboveBandwidthThreshold;
     private boolean mRatchetPccFieldsForSameAnchorNrCell;
     @NonNull private final Set<Integer> mAdditionalNrAdvancedBands = new HashSet<>();
     @NonNull private String mPrimaryTimerState;
@@ -235,7 +236,7 @@ public class NetworkTypeController extends StateMachine {
     @NonNull private Set<Integer> mRatchetedNrBands = new HashSet<>();
     // TODO(b/316425811 remove the workaround)
     private boolean mLastShownNrDueToAdvancedBand = false;
-    private int mRatchetedNrBandwidths = 0;
+    private List<Integer> mRatchetedNrBandwidths = new ArrayList<>();
     private int mLastAnchorNrCellId = PhysicalChannelConfig.PHYSICAL_CELL_ID_UNKNOWN;
     private boolean mDoesPccListIndicateIdle = false;
 
@@ -247,37 +248,27 @@ public class NetworkTypeController extends StateMachine {
     private final ConnectivityManager.NetworkCallback mNetworkCallback =
             new ConnectivityManager.NetworkCallback() {
                 @Override
-                public void onAvailable(Network network) {
-                    log("On Available: " + network);
-                    if (network != null) {
-                        if (mConnectivityManager != null) {
-                            NetworkCapabilities capabilities =
-                                    mConnectivityManager.getNetworkCapabilities(network);
-                            updateBandwidthConstrainedStatus(capabilities);
-                        } else {
-                            log("network is null");
+                public void onAvailable(@NonNull Network network) {
+                    if (mConnectivityManager != null) {
+                        NetworkCapabilities capabilities =
+                                mConnectivityManager.getNetworkCapabilities(network);
+                        if (capabilities != null) {
+                            updateBandwidthConstrainedStatus(
+                                    isBandwidthConstrainedCapabilitySupported(capabilities));
                         }
                     }
                 }
 
                 @Override
-                public void onCapabilitiesChanged(Network network,
-                        NetworkCapabilities networkCapabilities) {
-                    log("onCapabilitiesChanged: " + network);
-                    if (network != null) {
-                        updateBandwidthConstrainedStatus(networkCapabilities);
-                    } else {
-                        log("network is null");
-                    }
+                public void onCapabilitiesChanged(@NonNull Network network,
+                        @NonNull NetworkCapabilities networkCapabilities) {
+                    updateBandwidthConstrainedStatus(
+                            isBandwidthConstrainedCapabilitySupported(networkCapabilities));
                 }
 
                 @Override
-                public void onLost(Network network) {
-                    log("Network Lost");
-                    if (mIsSatelliteConstrainedData) {
-                        mIsSatelliteConstrainedData = false;
-                        mDisplayInfoController.updateTelephonyDisplayInfo();
-                    }
+                public void onLost(@NonNull Network network) {
+                    updateBandwidthConstrainedStatus(false);
                 }
             };
 
@@ -296,14 +287,13 @@ public class NetworkTypeController extends StateMachine {
         }
     }
 
-    private void updateBandwidthConstrainedStatus(NetworkCapabilities capabilities) {
-        if (capabilities != null) {
-            mIsSatelliteConstrainedData
-                    = isBandwidthConstrainedCapabilitySupported(capabilities);
-            log("satellite constrained data status : " + mIsSatelliteConstrainedData);
-            mDisplayInfoController.updateTelephonyDisplayInfo();
-        } else {
-            log("capabilities is null");
+    private void updateBandwidthConstrainedStatus(boolean isConstrained) {
+        if (isConstrained != mIsSatelliteConstrainedData) {
+            mIsSatelliteConstrainedData = isConstrained;
+            log("Reset timers because satellite constrained data status changed to "
+                    + mIsSatelliteConstrainedData);
+            resetAllTimers();
+            transitionToCurrentState();
         }
     }
 
@@ -468,6 +458,8 @@ public class NetworkTypeController extends StateMachine {
                 CarrierConfigManager.KEY_LTE_PLUS_THRESHOLD_BANDWIDTH_KHZ_INT);
         mNrAdvancedThresholdBandwidth = config.getInt(
                 CarrierConfigManager.KEY_NR_ADVANCED_THRESHOLD_BANDWIDTH_KHZ_INT);
+        mNrAdvancedRequiresSingleCcAboveBandwidthThreshold = config.getBoolean(CarrierConfigManager
+                .KEY_NR_ADVANCED_REQUIRES_SINGLE_CC_ABOVE_BANDWIDTH_THRESHOLD_BOOL);
         mIncludeLteForNrAdvancedThresholdBandwidth = config.getBoolean(
                 CarrierConfigManager.KEY_INCLUDE_LTE_FOR_NR_ADVANCED_THRESHOLD_BANDWIDTH_BOOL);
         mRatchetPccFieldsForSameAnchorNrCell = config.getBoolean(
@@ -776,7 +768,7 @@ public class NetworkTypeController extends StateMachine {
                     if (DBG) log("Reset timers since radio is off or unavailable.");
                     resetAllTimers();
                     mRatchetedNrBands.clear();
-                    mRatchetedNrBandwidths = 0;
+                    mRatchetedNrBandwidths.clear();
                     mLastAnchorNrCellId = PhysicalChannelConfig.PHYSICAL_CELL_ID_UNKNOWN;
                     mDoesPccListIndicateIdle = false;
                     mIsNrAdvancedAllowedByPco = false;
@@ -1366,7 +1358,7 @@ public class NetworkTypeController extends StateMachine {
 
         int anchorNrCellId = PhysicalChannelConfig.PHYSICAL_CELL_ID_UNKNOWN;
         int anchorLteCellId = PhysicalChannelConfig.PHYSICAL_CELL_ID_UNKNOWN;
-        int nrBandwidths = 0;
+        List<Integer> nrBandwidths = new ArrayList<>();
         Set<Integer> nrBands = new HashSet<>();
         if (physicalChannelConfigs != null) {
             for (PhysicalChannelConfig config : physicalChannelConfigs) {
@@ -1375,7 +1367,7 @@ public class NetworkTypeController extends StateMachine {
                             && anchorNrCellId == PhysicalChannelConfig.PHYSICAL_CELL_ID_UNKNOWN) {
                         anchorNrCellId = config.getPhysicalCellId();
                     }
-                    nrBandwidths += config.getCellBandwidthDownlinkKhz();
+                    nrBandwidths.add(config.getCellBandwidthDownlinkKhz());
                     nrBands.add(config.getBand());
                 } else if (config.getNetworkType() == TelephonyManager.NETWORK_TYPE_LTE) {
                     if (config.getConnectionStatus() == CellInfo.CONNECTION_PRIMARY_SERVING
@@ -1383,7 +1375,7 @@ public class NetworkTypeController extends StateMachine {
                         anchorLteCellId = config.getPhysicalCellId();
                     }
                     if (mIncludeLteForNrAdvancedThresholdBandwidth) {
-                        nrBandwidths += config.getCellBandwidthDownlinkKhz();
+                        nrBandwidths.add(config.getCellBandwidthDownlinkKhz());
                     }
                 }
             }
@@ -1400,11 +1392,13 @@ public class NetworkTypeController extends StateMachine {
                 log("Ignoring physical channel config fields without an anchor NR cell, "
                         + "either due to LTE-only configs or an unspecified cell ID.");
             }
-            mRatchetedNrBandwidths = 0;
+            mRatchetedNrBandwidths.clear();
             mRatchetedNrBands.clear();
         } else if (anchorNrCellId == mLastAnchorNrCellId && mRatchetPccFieldsForSameAnchorNrCell) {
             log("Ratchet physical channel config fields since anchor NR cell is the same.");
-            mRatchetedNrBandwidths = Math.max(mRatchetedNrBandwidths, nrBandwidths);
+            mRatchetedNrBandwidths =
+                    getNrBandwidth(nrBandwidths) > getNrBandwidth(mRatchetedNrBandwidths)
+                    ? nrBandwidths : mRatchetedNrBandwidths;
             mRatchetedNrBands.addAll(nrBands);
         } else {
             mRatchetedNrBandwidths = nrBandwidths;
@@ -1427,10 +1421,11 @@ public class NetworkTypeController extends StateMachine {
             }
         }
 
+        mPciChangedDuringPrimaryTimer = (mLastAnchorNrCellId != anchorNrCellId)
+                && mIsPrimaryTimerActive;
         mLastAnchorNrCellId = anchorNrCellId;
         mPhysicalChannelConfigs = physicalChannelConfigs;
         mDoesPccListIndicateIdle = false;
-        mPciChangedDuringPrimaryTimer = mIsPrimaryTimerActive;
         if (DBG) {
             log("Physical channel configs updated: anchorNrCell=" + mLastAnchorNrCellId
                     + ", nrBandwidths=" + mRatchetedNrBandwidths + ", nrBands=" +  mRatchetedNrBands
@@ -1733,7 +1728,7 @@ public class NetworkTypeController extends StateMachine {
         return isNrAdvancedForPccFields(mRatchetedNrBandwidths, mRatchetedNrBands);
     }
 
-    private boolean isNrAdvancedForPccFields(int bandwidths, Set<Integer> bands) {
+    private boolean isNrAdvancedForPccFields(List<Integer> bandwidths, Set<Integer> bands) {
         // Check PCO requirement. For carriers using PCO to indicate whether the data connection is
         // NR advanced capable, mNrAdvancedCapablePcoId should be configured to non-zero.
         if (mNrAdvancedCapablePcoId > 0 && !mIsNrAdvancedAllowedByPco) {
@@ -1748,9 +1743,11 @@ public class NetworkTypeController extends StateMachine {
             return false;
         }
 
+
         // Check if meeting minimum bandwidth requirement. For most carriers, there is no minimum
         // bandwidth requirement and mNrAdvancedThresholdBandwidth is 0.
-        if (mNrAdvancedThresholdBandwidth > 0 && bandwidths < mNrAdvancedThresholdBandwidth) {
+        if (mNrAdvancedThresholdBandwidth > 0
+                && getNrBandwidth(bandwidths) < mNrAdvancedThresholdBandwidth) {
             if (DBG) {
                 log("isNrAdvanced: false because bandwidths=" + bandwidths
                         + " does not meet the threshold=" + mNrAdvancedThresholdBandwidth);
@@ -1767,6 +1764,16 @@ public class NetworkTypeController extends StateMachine {
         return mServiceState.getNrFrequencyRange() == ServiceState.FREQUENCY_RANGE_MMWAVE;
     }
 
+    private int getNrBandwidth(@NonNull List<Integer> bandwidths) {
+        if (mNrAdvancedRequiresSingleCcAboveBandwidthThreshold) {
+            // Returns the max bandwidth if wide single CC is required for NR Advanced.
+            return bandwidths.stream().max(Integer::compare).orElse(0);
+        } else {
+            // Returns the sum of bandwidths, typically for aggregated NR carriers.
+            return bandwidths.stream().mapToInt(Integer::intValue).sum();
+        }
+    }
+
     private boolean isAdditionalNrAdvancedBand(Set<Integer> bands) {
         if (mAdditionalNrAdvancedBands.isEmpty() || bands.isEmpty()) {
             if (DBG && !mAdditionalNrAdvancedBands.isEmpty()) {
diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index e136e5a0e4..dbf4ed205b 100644
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -392,6 +392,8 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     private int mUsageSettingFromModem = SubscriptionManager.USAGE_SETTING_UNKNOWN;
     private boolean mIsUsageSettingSupported = true;
     private boolean mIsNetworkScanStarted = false;
+    private Set<Integer> mAllowedImsServicesAny = new HashSet<>();
+    private Set<Integer> mAllowedImsServicesHomeOnly = new HashSet<>();
 
     //IMS
     /**
@@ -3200,11 +3202,7 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
             Intent intent = new Intent(TelephonyIntents.SECRET_CODE_ACTION,
                     Uri.parse("android_secret_code://" + code));
             intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL, null, options.toBundle());
-            } else {
-                mContext.sendBroadcast(intent, null, options.toBundle());
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, null, options.toBundle());
 
             // {@link TelephonyManager.ACTION_SECRET_CODE} will replace {@link
             // TelephonyIntents#SECRET_CODE_ACTION} in the next Android version. Before
@@ -3212,12 +3210,8 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
             Intent secrectCodeIntent = new Intent(TelephonyManager.ACTION_SECRET_CODE,
                     Uri.parse("android_secret_code://" + code));
             secrectCodeIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(secrectCodeIntent, UserHandle.ALL, null,
-                        options.toBundle());
-            } else {
-                mContext.sendBroadcast(secrectCodeIntent, null, options.toBundle());
-            }
+            mContext.sendBroadcastAsUser(secrectCodeIntent, UserHandle.ALL, null,
+                    options.toBundle());
         }
     }
 
@@ -4034,7 +4028,8 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
      *        IMSI and IMPI. This includes the Key type, the Public key
      *        {@link java.security.PublicKey} and the Key identifier.
      */
-    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
+    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo,
+            boolean saveToDb) {
         return;
     }
 
@@ -4768,6 +4763,7 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
      **/
     public void setVoNrEnabled(boolean enabled, Message result, WorkSource workSource) {
         mCi.setVoNrEnabled(enabled, result, workSource);
+        setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_NR, enabled);
     }
 
     /**
@@ -5498,6 +5494,63 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
         mCi.isSatelliteEnabledForCarrier(simSlot, result);
     }
 
+    /**
+     * Update allowed IMS services for home network only.
+     *
+     * @param regTech Which technology is associated with this capability.
+     * @param enabled Whether this capability is enabled.
+     */
+    public void setAllowedImsServicesForHomeOnly(
+            @ImsRegistrationImplBase.ImsRegistrationTech int regTech,
+            boolean enabled) {
+        if (!mFeatureFlags.allowedServices()) return;
+        Set<Integer> oldAllowedImsServicesAny = new HashSet<>(mAllowedImsServicesAny);
+        Set<Integer> oldAllowedImsServicesHomeOnly = new HashSet<>(mAllowedImsServicesHomeOnly);
+        if (enabled) {
+            mAllowedImsServicesHomeOnly.add(regTech);
+        } else {
+            mAllowedImsServicesHomeOnly.remove(regTech);
+        }
+        mAllowedImsServicesAny.remove(regTech);
+        if (!oldAllowedImsServicesAny.equals(mAllowedImsServicesAny)
+                || !oldAllowedImsServicesHomeOnly.equals(mAllowedImsServicesHomeOnly)) {
+            mCi.updateAllowedImsServices(mAllowedImsServicesAny, mAllowedImsServicesHomeOnly, null);
+        }
+    }
+
+    /**
+     * Update allowed IMS services for home and roaming networks.
+     *
+     * @param regTech Which technology is associated with this capability.
+     * @param enabled Whether this capability is enabled.
+     */
+    public void setAllowedImsServicesForAny(
+            @ImsRegistrationImplBase.ImsRegistrationTech int regTech,
+            boolean enabled) {
+        if (!mFeatureFlags.allowedServices()) return;
+        Set<Integer> oldAllowedImsServicesAny = new HashSet<>(mAllowedImsServicesAny);
+        Set<Integer> oldAllowedImsServicesHomeOnly = new HashSet<>(mAllowedImsServicesHomeOnly);
+        if (enabled) {
+            mAllowedImsServicesAny.add(regTech);
+        } else {
+            mAllowedImsServicesAny.remove(regTech);
+        }
+        mAllowedImsServicesHomeOnly.remove(regTech);
+        if (!oldAllowedImsServicesAny.equals(mAllowedImsServicesAny)
+                || !oldAllowedImsServicesHomeOnly.equals(mAllowedImsServicesHomeOnly)) {
+            mCi.updateAllowedImsServices(mAllowedImsServicesAny, mAllowedImsServicesHomeOnly, null);
+        }
+    }
+
+    /**
+     * Clear allowed IMS services.
+     */
+    public void clearAllowedImsServices() {
+        Rlog.d(mLogTag, "clearAllowedImsServices");
+        mAllowedImsServicesAny.clear();
+        mAllowedImsServicesHomeOnly.clear();
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("Phone: subId=" + getSubId());
         pw.println(" mPhoneId=" + mPhoneId);
diff --git a/src/java/com/android/internal/telephony/PhoneConfigurationManager.java b/src/java/com/android/internal/telephony/PhoneConfigurationManager.java
index 1e69e16925..fc1d91c74c 100644
--- a/src/java/com/android/internal/telephony/PhoneConfigurationManager.java
+++ b/src/java/com/android/internal/telephony/PhoneConfigurationManager.java
@@ -782,11 +782,7 @@ public class PhoneConfigurationManager {
 
         Intent intent = new Intent(ACTION_MULTI_SIM_CONFIG_CHANGED);
         intent.putExtra(EXTRA_ACTIVE_SIM_SUPPORTED_COUNT, numOfActiveModems);
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } else {
-            mContext.sendBroadcast(intent);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
     }
     /**
      * This is invoked from shell commands during CTS testing only.
diff --git a/src/java/com/android/internal/telephony/PhoneInternalInterface.java b/src/java/com/android/internal/telephony/PhoneInternalInterface.java
index 32c0c73f9b..b60ff3eed1 100644
--- a/src/java/com/android/internal/telephony/PhoneInternalInterface.java
+++ b/src/java/com/android/internal/telephony/PhoneInternalInterface.java
@@ -1077,7 +1077,8 @@ public interface PhoneInternalInterface {
     *        IMSI and IMPI. This includes the Key type, the Public key
     *        {@link java.security.PublicKey} and the Key identifier.
     */
-    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo);
+    public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo,
+            boolean saveToDb);
 
     /**
      * Returns Carrier specific information that will be used to encrypt the IMSI and IMPI.
diff --git a/src/java/com/android/internal/telephony/PhoneSubInfoController.java b/src/java/com/android/internal/telephony/PhoneSubInfoController.java
index c8cd242f6b..4b8a751420 100644
--- a/src/java/com/android/internal/telephony/PhoneSubInfoController.java
+++ b/src/java/com/android/internal/telephony/PhoneSubInfoController.java
@@ -140,7 +140,7 @@ public class PhoneSubInfoController extends IPhoneSubInfo.Stub {
         callPhoneMethodForSubIdWithModifyCheck(subId, callingPackage,
                 "setCarrierInfoForImsiEncryption",
                 (phone)-> {
-                    phone.setCarrierInfoForImsiEncryption(imsiEncryptionInfo);
+                    phone.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, true);
                     return null;
                 });
     }
@@ -838,15 +838,10 @@ public class PhoneSubInfoController extends IPhoneSubInfo.Stub {
      */
     @Nullable
     private String getCurrentPackageName() {
-        if (mFeatureFlags.hsumPackageManager()) {
-            PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
-                    .getPackageManager();
-            if (pm == null) return null;
-            String[] callingPackageNames = pm.getPackagesForUid(Binder.getCallingUid());
-            return (callingPackageNames == null) ? null : callingPackageNames[0];
-        }
-        if (mPackageManager == null) return null;
-        String[] callingPackageNames = mPackageManager.getPackagesForUid(Binder.getCallingUid());
+        PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
+                .getPackageManager();
+        if (pm == null) return null;
+        String[] callingPackageNames = pm.getPackagesForUid(Binder.getCallingUid());
         return (callingPackageNames == null) ? null : callingPackageNames[0];
     }
 
diff --git a/src/java/com/android/internal/telephony/ProxyController.java b/src/java/com/android/internal/telephony/ProxyController.java
index 3b30d2f03b..e2738350ea 100644
--- a/src/java/com/android/internal/telephony/ProxyController.java
+++ b/src/java/com/android/internal/telephony/ProxyController.java
@@ -365,11 +365,7 @@ public class ProxyController {
                     logd("onStartRadioCapabilityResponse got exception=" + ar.exception);
                     mRadioCapabilitySessionId = mUniqueIdGenerator.getAndIncrement();
                     Intent intent = new Intent(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_FAILED);
-                    if (mFlags.hsumBroadcast()) {
-                        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-                    } else {
-                        mContext.sendBroadcast(intent);
-                    }
+                    mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
                     clearTransaction();
                     return;
                 }
@@ -616,12 +612,8 @@ public class ProxyController {
         }
 
         // Broadcast that we're done
-        if (mFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                    android.Manifest.permission.READ_PHONE_STATE);
-        } else {
-            mContext.sendBroadcast(intent, android.Manifest.permission.READ_PHONE_STATE);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                android.Manifest.permission.READ_PHONE_STATE);
     }
 
     // Clear this transaction
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index f5d06dbe76..387b43620c 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -58,6 +58,9 @@ import android.provider.Settings;
 import android.sysprop.TelephonyProperties;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.AccessNetworkConstants.AccessNetworkType;
+import android.telephony.AccessNetworkConstants.RadioAccessNetworkType;
+import android.telephony.AccessNetworkConstants.TransportType;
+import android.telephony.Annotation.DataState;
 import android.telephony.BarringInfo;
 import android.telephony.CarrierRestrictionRules;
 import android.telephony.ClientRequestStats;
@@ -2159,7 +2162,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 riljLog(rr.serialString() + "> iccIO: " + RILUtils.requestToString(rr.mRequest)
                         + " command = 0x" + Integer.toHexString(command) + " fileId = 0x"
                         + Integer.toHexString(fileId) + " path = " + path + " p1 = " + p1
-                        + " p2 = " + p2 + " p3 = " + " data = " + data + " aid = " + aid);
+                        + " p2 = " + p2 + " p3 = " + p3 + " data = " + data + " aid = " + aid);
             } else {
                 riljLog(rr.serialString() + "> iccIO: "
                         + RILUtils.requestToString(rr.mRequest));
@@ -4764,6 +4767,87 @@ public class RIL extends BaseCommands implements CommandsInterface {
         });
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setUserDataEnabled(Message result, boolean enabled) {
+        RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
+        if (!canMakeRequest("setUserDataEnabled", dataProxy, result, RADIO_HAL_VERSION_2_4)) {
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_SET_USER_DATA_ENABLED, result,
+                mRILDefaultWorkSource);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest) + " enabled="
+                    + enabled);
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setUserDataEnabled", () -> {
+            dataProxy.setUserDataEnabled(rr.mSerial, enabled);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setUserDataRoamingEnabled(Message result, boolean enabled) {
+        RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
+        if (!canMakeRequest("setUserDataRoamingEnabled", dataProxy, result,
+                RADIO_HAL_VERSION_2_4)) {
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_SET_USER_DATA_ROAMING_ENABLED, result,
+                mRILDefaultWorkSource);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + RILUtils.requestToString(rr.mRequest) + " enabled="
+                    + enabled);
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "setUserDataRoamingEnabled", () -> {
+            dataProxy.setUserDataRoamingEnabled(rr.mSerial, enabled);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void notifyImsDataNetwork(@RadioAccessNetworkType int accessNetwork,
+            @DataState int dataNetworkState, @TransportType int physicalTransportType,
+            int physicalNetworkSlotIndex, @Nullable Message result) {
+        RadioDataProxy dataProxy = getRadioServiceProxy(RadioDataProxy.class);
+        if (!canMakeRequest("notifyImsDataNetwork", dataProxy, result, RADIO_HAL_VERSION_2_4)) {
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_NOTIFY_IMS_DATA_NETWORK, result,
+                mRILDefaultWorkSource);
+        if (RILJ_LOGD) {
+            riljLog(
+                    rr.serialString()
+                            + "> "
+                            + RILUtils.requestToString(rr.mRequest)
+                            + " accessNetwork="
+                            + AccessNetworkConstants.AccessNetworkType.toString(accessNetwork)
+                            + " dataNetworkState="
+                            + TelephonyUtils.dataStateToString(dataNetworkState)
+                            + " physicalTransportType="
+                            + AccessNetworkConstants.transportTypeToString(physicalTransportType)
+                            + " physicalNetworkSlotIndex="
+                            + physicalNetworkSlotIndex);
+        }
+
+        radioServiceInvokeHelper(HAL_SERVICE_DATA, rr, "notifyImsDataNetwork", () -> {
+            dataProxy.notifyImsDataNetwork(rr.mSerial, accessNetwork,
+                    RILUtils.convertToHalDataNetworkState(dataNetworkState),
+                    physicalTransportType, physicalNetworkSlotIndex);
+        });
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -5446,6 +5530,39 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 });
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void updateAllowedImsServices(@NonNull Set<Integer> allowedImsServicesAny,
+            @NonNull Set<Integer> allowedImsServicesHomeOnly,
+            @Nullable Message result) {
+        RadioImsProxy imsProxy = getRadioServiceProxy(RadioImsProxy.class);
+        if (!canMakeRequest("updateAllowedImsServices", imsProxy, result, RADIO_HAL_VERSION_2_4)) {
+            return;
+        }
+
+        RILRequest rr = obtainRequest(RIL_REQUEST_UPDATE_ALLOWED_IMS_SERVICES, result,
+                mRILDefaultWorkSource);
+
+        if (RILJ_LOGD) {
+            riljLog(
+                    rr.serialString()
+                            + "> "
+                            + RILUtils.requestToString(rr.mRequest)
+                            + " allowedImsServicesAny="
+                            + allowedImsServicesAny
+                            + " allowedImsServicesHomeOnly="
+                            + allowedImsServicesHomeOnly);
+        }
+        radioServiceInvokeHelper(
+                HAL_SERVICE_IMS,
+                rr,
+                "updateAllowedImsServices",
+                () -> {
+                    imsProxy.updateAllowedServices(rr.mSerial,
+                            RILUtils.convertImsServices(allowedImsServicesAny,
+                                    allowedImsServicesHomeOnly));
+                });
+    }
 
     //***** Private Methods
     /**
diff --git a/src/java/com/android/internal/telephony/RILUtils.java b/src/java/com/android/internal/telephony/RILUtils.java
index fb07fb3fa0..b2302a08c1 100644
--- a/src/java/com/android/internal/telephony/RILUtils.java
+++ b/src/java/com/android/internal/telephony/RILUtils.java
@@ -126,6 +126,7 @@ import static com.android.internal.telephony.RILConstants.RIL_REQUEST_IS_SECURIT
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_IS_VONR_ENABLED;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_LAST_CALL_FAIL_CAUSE;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_NOTIFY_IMS_DATA_NETWORK;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_NV_READ_ITEM;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_NV_RESET_CONFIG;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_NV_WRITE_CDMA_PRL;
@@ -195,6 +196,8 @@ import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_UICC_S
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_USAGE_SETTING;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_USER_DATA_ENABLED;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_USER_DATA_ROAMING_ENABLED;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SHUTDOWN;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SIGNAL_STRENGTH;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SIM_AUTHENTICATION;
@@ -224,6 +227,7 @@ import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SWITCH_WAI
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_TRIGGER_EMERGENCY_NETWORK_SCAN;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_TRIGGER_EPS_FALLBACK;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_UDUB;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_UPDATE_ALLOWED_IMS_SERVICES;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_UPDATE_IMS_CALL_STATUS;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_UPDATE_IMS_REGISTRATION_INFO;
 import static com.android.internal.telephony.RILConstants.RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORD;
@@ -310,6 +314,7 @@ import android.os.SystemClock;
 import android.service.carrier.CarrierIdentifier;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.Annotation;
+import android.telephony.Annotation.DataState;
 import android.telephony.BarringInfo;
 import android.telephony.CarrierInfo;
 import android.telephony.CarrierRestrictionRules;
@@ -374,6 +379,7 @@ import android.telephony.ims.feature.ConnectionFailureInfo;
 import android.telephony.ims.feature.MmTelFeature;
 import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.telephony.ims.stub.ImsRegistrationImplBase.ImsDeregistrationReason;
+import android.telephony.ims.stub.ImsRegistrationImplBase.ImsRegistrationTech;
 import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.SparseArray;
@@ -1506,28 +1512,6 @@ public class RILUtils {
         if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.EDGE) != 0) {
             networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_EDGE;
         }
-        // convert both IS95A/IS95B to CDMA as network mode doesn't support CDMA
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.IS95A) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.IS95B) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.ONE_X_RTT) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.EVDO_0) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.EVDO_A) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.EVDO_B) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B;
-        }
-        if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.EHRPD) != 0) {
-            networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD;
-        }
         if ((raf & android.hardware.radio.V1_0.RadioAccessFamily.HSUPA) != 0) {
             networkTypeRaf |= TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA;
         }
@@ -1580,25 +1564,6 @@ public class RILUtils {
         if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EDGE) != 0) {
             raf |= android.hardware.radio.V1_0.RadioAccessFamily.EDGE;
         }
-        // convert CDMA to IS95A, consistent with ServiceState.networkTypeToRilRadioTechnology
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_CDMA) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.IS95A;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.ONE_X_RTT;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.EVDO_0;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.EVDO_A;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.EVDO_B;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD) != 0) {
-            raf |= android.hardware.radio.V1_0.RadioAccessFamily.EHRPD;
-        }
         if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA) != 0) {
             raf |= android.hardware.radio.V1_0.RadioAccessFamily.HSUPA;
         }
@@ -1651,25 +1616,6 @@ public class RILUtils {
         if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EDGE) != 0) {
             raf |= android.hardware.radio.RadioAccessFamily.EDGE;
         }
-        // convert CDMA to IS95A, consistent with ServiceState.networkTypeToRilRadioTechnology
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_CDMA) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.IS95A;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.ONE_X_RTT;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.EVDO_0;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.EVDO_A;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.EVDO_B;
-        }
-        if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD) != 0) {
-            raf |= android.hardware.radio.RadioAccessFamily.EHRPD;
-        }
         if ((networkTypeBitmask & TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA) != 0) {
             raf |= android.hardware.radio.RadioAccessFamily.HSUPA;
         }
@@ -3506,6 +3452,9 @@ public class RILUtils {
             }
         }
 
+        result.mtuV4 = normalizeMtu(result.mtuV4);
+        result.mtuV6 = normalizeMtu(result.mtuV6);
+
         return new DataCallResponse.Builder()
                 .setCause(result.cause)
                 .setRetryDurationMillis(result.suggestedRetryTime)
@@ -3530,6 +3479,13 @@ public class RILUtils {
                 .build();
     }
 
+    private static int normalizeMtu(int rawMtu) {
+        // Ensure it's within unsigned 16-bit range.
+        int mtu = Math.min(rawMtu, 65535);
+        // Ensure even number, otherwise round down.
+        return mtu & ~1;
+    }
+
     private static NetworkSliceInfo convertHalSliceInfo(android.hardware.radio.V1_6.SliceInfo si) {
         NetworkSliceInfo.Builder builder = new NetworkSliceInfo.Builder()
                 .setSliceServiceType(si.sst)
@@ -4817,6 +4773,80 @@ public class RILUtils {
         return ConnectionFailureInfo.REASON_UNSPECIFIED;
     }
 
+    /**
+     * Convert to an array of HAL IMS service.
+     *
+     * @param allowedImsServicesAny Which allowed services for both home and roaming state.
+     * @param allowedImsServicesHomeOnly Which allowed services for home state only.
+     * @return The array of HAL IMS service.
+     */
+    public static android.hardware.radio.ims.ImsService[] convertImsServices(
+            @NonNull Set<Integer> allowedImsServicesAny,
+            @NonNull Set<Integer> allowedImsServicesHomeOnly) {
+        int length = allowedImsServicesAny.size() + allowedImsServicesHomeOnly.size();
+        if (length == 0) {
+            return new android.hardware.radio.ims.ImsService[0];
+        }
+        android.hardware.radio.ims.ImsService[] imsServices =
+                new android.hardware.radio.ims.ImsService[length];
+        int index = 0;
+        for (Integer regTech : allowedImsServicesAny) {
+            imsServices[index] = new android.hardware.radio.ims.ImsService();
+            imsServices[index].serviceType = convertToImsServiceTypeAidl(regTech);
+            imsServices[index].roamingType = android.hardware.radio.ims.ImsService.RoamingType.ANY;
+            index++;
+        }
+        for (Integer regTech : allowedImsServicesHomeOnly) {
+            imsServices[index] = new android.hardware.radio.ims.ImsService();
+            imsServices[index].serviceType = convertToImsServiceTypeAidl(regTech);
+            imsServices[index].roamingType =
+                    android.hardware.radio.ims.ImsService.RoamingType.HOME_ONLY;
+            index++;
+        }
+        return imsServices;
+    }
+
+    /**
+     * Convert to HAL IMS service type.
+     *
+     * @param regTech The IMS service radio technology.
+     * @return The HAL IMS service type.
+     */
+    private static int convertToImsServiceTypeAidl(@ImsRegistrationTech int regTech) {
+        return switch (regTech) {
+            case ImsRegistrationImplBase.REGISTRATION_TECH_LTE ->
+                    android.hardware.radio.ims.ImsServiceType.VOLTE;
+            case ImsRegistrationImplBase.REGISTRATION_TECH_NR ->
+                    android.hardware.radio.ims.ImsServiceType.VONR;
+            case ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN ->
+                    android.hardware.radio.ims.ImsServiceType.VOWIFI;
+            default -> android.hardware.radio.ims.ImsServiceType.INVALID;
+        };
+    }
+
+    /**
+     * Convert to HAL data network state.
+     * @param state Telephony data state.
+     * @return The converted HAL data network state.
+     */
+    public static int convertToHalDataNetworkState(@DataState int state) {
+        return switch (state) {
+            case TelephonyManager.DATA_UNKNOWN ->
+                    android.hardware.radio.data.DataNetworkState.UNKNOWN;
+            case TelephonyManager.DATA_DISCONNECTED ->
+                    android.hardware.radio.data.DataNetworkState.DISCONNECTED;
+            case TelephonyManager.DATA_CONNECTING ->
+                    android.hardware.radio.data.DataNetworkState.CONNECTING;
+            case TelephonyManager.DATA_CONNECTED ->
+                    android.hardware.radio.data.DataNetworkState.CONNECTED;
+            case TelephonyManager.DATA_DISCONNECTING ->
+                    android.hardware.radio.data.DataNetworkState.DISCONNECTING;
+            default ->
+                    // Throw an exception for any unsupported state.
+                    throw new IllegalArgumentException("Unsupported data state: " + state);
+        };
+    }
+
     /** Append the data to the end of an ArrayList */
     public static void appendPrimitiveArrayToArrayList(byte[] src, ArrayList<Byte> dst) {
         for (byte b : src) {
@@ -5321,6 +5351,14 @@ public class RILUtils {
                 return "SET_SATELLITE_ENABLED_FOR_CARRIER";
             case RIL_REQUEST_IS_SATELLITE_ENABLED_FOR_CARRIER:
                 return "IS_SATELLITE_ENABLED_FOR_CARRIER";
+            case RIL_REQUEST_SET_USER_DATA_ENABLED:
+                return "SET_USER_DATA_ENABLED";
+            case RIL_REQUEST_SET_USER_DATA_ROAMING_ENABLED:
+                return "SET_USER_DATA_ROAMING_ENABLED";
+            case RIL_REQUEST_UPDATE_ALLOWED_IMS_SERVICES:
+                return "UPDATE_ALLOWED_IMS_SERVICES";
+            case RIL_REQUEST_NOTIFY_IMS_DATA_NETWORK:
+                return "NOTIFY_IMS_DATA_NETWORK";
             default:
                 return "<unknown request " + request + ">";
         }
@@ -5781,6 +5819,7 @@ public class RILUtils {
             case ImsRegistrationImplBase.REGISTRATION_TECH_LTE:
                 return android.hardware.radio.AccessNetwork.EUTRAN;
             case ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN:
+            case ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM:
                 return android.hardware.radio.AccessNetwork.IWLAN;
             case ImsRegistrationImplBase.REGISTRATION_TECH_NR:
                 return android.hardware.radio.AccessNetwork.NGRAN;
diff --git a/src/java/com/android/internal/telephony/RadioDataProxy.java b/src/java/com/android/internal/telephony/RadioDataProxy.java
index 40db9e5b3d..2b0c90c695 100644
--- a/src/java/com/android/internal/telephony/RadioDataProxy.java
+++ b/src/java/com/android/internal/telephony/RadioDataProxy.java
@@ -448,4 +448,50 @@ public class RadioDataProxy extends RadioServiceProxy {
             mRadioProxy.stopKeepalive(serial, sessionHandle);
         }
     }
+
+    /**
+     * Call IRadioData#setUserDataEnabled
+     * @param serial Serial number of request
+     * @param enabled Whether the user mobile data is enabled
+     * @throws RemoteException
+     */
+    public void setUserDataEnabled(int serial, boolean enabled) throws RemoteException {
+        if (isEmpty()) return;
+        if (isAidl()) {
+            mDataProxy.setUserDataEnabled(serial, enabled);
+        }
+    }
+
+    /**
+     * Call IRadioData#setUserDataRoamingEnabled
+     * @param serial Serial number of request
+     * @param enabled Whether the user mobile data roaming is enabled
+     * @throws RemoteException
+     */
+    public void setUserDataRoamingEnabled(int serial, boolean enabled) throws RemoteException {
+        if (isEmpty()) return;
+        if (isAidl()) {
+            mDataProxy.setUserDataRoamingEnabled(serial, enabled);
+        }
+    }
+
+    /**
+     * Call IRadioData#notifyImsDataNetwork
+     *
+     * @param serial Serial number of request
+     * @param accessNetwork The access network type.
+     * @param dataNetworkState The data network connection state.
+     * @param physicalTransportType The physical transport type of the data network.
+     * @param physicalNetworkModemId The logic modem ID while the physical transport type is WWAN.
+     *        If the physical transport type is WLAN, this modem ID will be -1.
+     * @throws RemoteException if error occurs
+     */
+    public void notifyImsDataNetwork(int serial, int accessNetwork, int dataNetworkState,
+            int physicalTransportType, int physicalNetworkModemId) throws RemoteException {
+        if (isEmpty()) return;
+        if (isAidl()) {
+            mDataProxy.notifyImsDataNetwork(serial, accessNetwork, dataNetworkState,
+                    physicalTransportType, physicalNetworkModemId);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/RadioImsProxy.java b/src/java/com/android/internal/telephony/RadioImsProxy.java
index cde2e06859..b921357b34 100644
--- a/src/java/com/android/internal/telephony/RadioImsProxy.java
+++ b/src/java/com/android/internal/telephony/RadioImsProxy.java
@@ -191,4 +191,19 @@ public class RadioImsProxy extends RadioServiceProxy {
             mImsProxy.updateImsCallStatus(serial, imsCalls);
         }
     }
+
+    /**
+     * Call IRadioIms#updateAllowedServices
+     *
+     * @param serial Serial number of request.
+     * @param imsServices The list of allowed services.
+     * @throws RemoteException.
+     */
+    public void updateAllowedServices(int serial,
+            android.hardware.radio.ims.ImsService[] imsServices) throws RemoteException {
+        if (isEmpty()) return;
+        if (isAidl()) {
+            mImsProxy.updateAllowedServices(serial, imsServices);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index fd72c88d79..c72ca8c6c2 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -23,6 +23,7 @@ import static com.android.internal.telephony.IccSmsInterfaceManager.SMS_MESSAGE_
 import static com.android.internal.telephony.SmsDispatchersController.PendingRequest;
 import static com.android.internal.telephony.SmsResponse.NO_ERROR_CODE;
 
+import android.annotation.NonNull;
 import android.annotation.UserIdInt;
 import android.app.Activity;
 import android.app.AlertDialog;
@@ -53,6 +54,7 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.PersistableBundle;
+import android.os.Process;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.provider.Settings;
@@ -90,6 +92,7 @@ import com.android.internal.telephony.GsmAlphabet.TextEncodingDetails;
 import com.android.internal.telephony.analytics.TelephonyAnalytics;
 import com.android.internal.telephony.analytics.TelephonyAnalytics.SmsMmsAnalytics;
 import com.android.internal.telephony.cdma.sms.UserData;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.satellite.SatelliteController;
 import com.android.internal.telephony.subscription.SubscriptionInfoInternal;
@@ -122,7 +125,6 @@ public abstract class SMSDispatcher extends Handler {
     protected static final String MAP_KEY_DEST_PORT = "destPort";
     protected static final String MAP_KEY_DATA = "data";
     protected static final String MAP_KEY_TEXT = "text";
-
     private static final int PREMIUM_RULE_USE_SIM = 1;
     private static final int PREMIUM_RULE_USE_NETWORK = 2;
     private static final int PREMIUM_RULE_USE_BOTH = 3;
@@ -184,6 +186,7 @@ public abstract class SMSDispatcher extends Handler {
     protected Phone mPhone;
     @UnsupportedAppUsage
     protected final Context mContext;
+    private final @NonNull FeatureFlags mFeatureFlags;
     @UnsupportedAppUsage
     protected final ContentResolver mResolver;
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
@@ -235,9 +238,6 @@ public abstract class SMSDispatcher extends Handler {
     @VisibleForTesting
     public int mCarrierMessagingTimeout = 10 * 60 * 1000; //10 minutes
 
-    /** Used for storing last TP - Message Reference used*/
-    private int mMessageRef = -1;
-
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     protected static int getNextConcatenatedRef() {
         sConcatenatedRef += 1;
@@ -248,7 +248,8 @@ public abstract class SMSDispatcher extends Handler {
      * Create a new SMS dispatcher.
      * @param phone the Phone to use
      */
-    protected SMSDispatcher(Phone phone, SmsDispatchersController smsDispatchersController) {
+    protected SMSDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
+            @NonNull FeatureFlags featureFlags) {
         mPhone = phone;
         mSmsDispatchersController = smsDispatchersController;
         mContext = phone.getContext();
@@ -265,6 +266,7 @@ public abstract class SMSDispatcher extends Handler {
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(Intent.ACTION_SIM_STATE_CHANGED);
         mContext.registerReceiver(mBroadcastReceiver, intentFilter);
+        mFeatureFlags = featureFlags;
         Rlog.d(TAG, "SMSDispatcher: ctor mSmsCapable=" + mSmsCapable + " format=" + getFormat()
                 + " mSmsSendDisabled=" + mSmsSendDisabled);
     }
@@ -450,12 +452,13 @@ public abstract class SMSDispatcher extends Handler {
                    if sim was used on another device and inserted in a new device,
                    that device will start sending the next TPMR after reading from the SIM.
                  */
-                mMessageRef = getTpmrValueFromSIM();
-                if (mMessageRef == -1) {
+                mSmsDispatchersController.setMessageReference(getTpmrValueFromSIM());
+                if (mSmsDispatchersController.getMessageReference() == -1) {
                     SubscriptionInfoInternal subInfo = SubscriptionManagerService.getInstance()
                             .getSubscriptionInfoInternal(msg.arg1);
                     if (subInfo != null) {
-                        mMessageRef = subInfo.getLastUsedTPMessageReference();
+                        mSmsDispatchersController.setMessageReference(
+                                subInfo.getLastUsedTPMessageReference());
                     }
                 }
                 break;
@@ -475,11 +478,12 @@ public abstract class SMSDispatcher extends Handler {
     }
 
     private void updateTPMessageReference() {
-        updateSIMLastTPMRValue(mMessageRef);
+        updateSIMLastTPMRValue(mSmsDispatchersController.getMessageReference());
         final long identity = Binder.clearCallingIdentity();
         try {
             SubscriptionManagerService.getInstance()
-                    .setLastUsedTPMessageReference(getSubId(), mMessageRef);
+                    .setLastUsedTPMessageReference(getSubId(),
+                    mSmsDispatchersController.getMessageReference());
         } catch (SecurityException e) {
             Rlog.e(TAG, "Security Exception caused on messageRef updation to DB " + e.getMessage());
         } finally {
@@ -521,9 +525,10 @@ public abstract class SMSDispatcher extends Handler {
             return 0;
         }
 
-        mMessageRef = (mMessageRef + 1) % 256;
+        int messageRef = mSmsDispatchersController.incrementMessageReference();
+        Rlog.d(TAG, "nextMessageRef: " + messageRef);
         updateTPMessageReference();
-        return mMessageRef;
+        return messageRef;
     }
 
     /**
@@ -878,17 +883,32 @@ public abstract class SMSDispatcher extends Handler {
                 Rlog.d(TAG, "processSendSmsResponse: Sending SMS by CarrierMessagingService failed."
                         + " Retry on carrier network. "
                         + SmsController.formatCrossStackMessageId(tracker.mMessageId));
+                // Reset the result code from carrier messaging service so that result code from
+                // RIL will be used.
+                resetResultCodeFromCarrierMessagingService(tracker);
                 sendSubmitPdu(tracker);
                 break;
             default:
                 Rlog.d(TAG, "processSendSmsResponse: Unknown result " + result + " Retry on carrier"
                         + " network. "
                         + SmsController.formatCrossStackMessageId(tracker.mMessageId));
+                // Reset the result code from carrier messaging service so that result code from
+                // RIL will be used.
+                resetResultCodeFromCarrierMessagingService(tracker);
                 sendSubmitPdu(tracker);
         }
     }
 
+    private void resetResultCodeFromCarrierMessagingService(SmsTracker tracker) {
+        if (Flags.temporaryFailuresInCarrierMessagingService()) {
+            tracker.mResultCodeFromCarrierMessagingService =
+                    CarrierMessagingService.SEND_STATUS_OK;
+        }
+    }
+
     private int toSmsManagerResultForSendSms(int carrierMessagingServiceResult) {
+        Rlog.d(TAG, "toSmsManagerResultForSendSms: carrierMessagingServiceResult="
+                + carrierMessagingServiceResult);
         switch (carrierMessagingServiceResult) {
             case CarrierMessagingService.SEND_STATUS_OK:
                 return Activity.RESULT_OK;
@@ -1134,30 +1154,7 @@ public abstract class SMSDispatcher extends Handler {
             mPhone.notifySmsSent(tracker.mDestAddress);
             mSmsDispatchersController.notifySmsSent(tracker, false,
                 tracker.isSinglePartOrLastPart(), true /*success*/);
-
-            mPhone.getSmsStats().onOutgoingSms(
-                    tracker.mImsRetry > 0 /* isOverIms */,
-                    SmsConstants.FORMAT_3GPP2.equals(getFormat()),
-                    false /* fallbackToCs */,
-                    SmsManager.RESULT_ERROR_NONE,
-                    tracker.mMessageId,
-                    tracker.isFromDefaultSmsApplication(mContext),
-                    tracker.getInterval(),
-                    mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                    tracker.isMtSmsPollingMessage(mContext));
-            if (mPhone != null) {
-                TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
-                if (telephonyAnalytics != null) {
-                    SmsMmsAnalytics smsMmsAnalytics = telephonyAnalytics.getSmsMmsAnalytics();
-                    if (smsMmsAnalytics != null) {
-                        smsMmsAnalytics.onOutgoingSms(
-                                tracker.mImsRetry > 0 /* isOverIms */,
-                                SmsManager.RESULT_ERROR_NONE
-                        );
-                    }
-                }
-            }
-
+            reportOutgoingSmsMetrics(tracker, SmsManager.RESULT_ERROR_NONE, NO_ERROR_CODE);
         } else {
             if (DBG) {
                 Rlog.d(TAG, "SMS send failed "
@@ -1197,29 +1194,7 @@ public abstract class SMSDispatcher extends Handler {
             if (!isIms() && ss != ServiceState.STATE_IN_SERVICE) {
                 tracker.onFailed(mContext, getNotInServiceError(ss), NO_ERROR_CODE);
                 notifySmsSentFailedToEmergencyStateTracker(tracker, false);
-                mPhone.getSmsStats().onOutgoingSms(
-                        tracker.mImsRetry > 0 /* isOverIms */,
-                        SmsConstants.FORMAT_3GPP2.equals(getFormat()),
-                        false /* fallbackToCs */,
-                        getNotInServiceError(ss),
-                        tracker.mMessageId,
-                        tracker.isFromDefaultSmsApplication(mContext),
-                        tracker.getInterval(),
-                        mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                        tracker.isMtSmsPollingMessage(mContext));
-                if (mPhone != null) {
-                    TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
-                    if (telephonyAnalytics != null) {
-                        SmsMmsAnalytics smsMmsAnalytics = telephonyAnalytics.getSmsMmsAnalytics();
-                        if (smsMmsAnalytics != null) {
-                            smsMmsAnalytics.onOutgoingSms(
-                                    tracker.mImsRetry > 0 /* isOverIms */,
-                                    getNotInServiceError(ss)
-                            );
-                        }
-                    }
-                }
-
+                reportOutgoingSmsMetrics(tracker, getNotInServiceError(ss), NO_ERROR_CODE);
             } else if (error == SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY
                     && tracker.mRetryCount < getMaxSmsRetryCount()) {
                 // Retry after a delay if needed.
@@ -1234,56 +1209,13 @@ public abstract class SMSDispatcher extends Handler {
                 int errorCode = (smsResponse != null) ? smsResponse.mErrorCode : NO_ERROR_CODE;
                 Message retryMsg = obtainMessage(EVENT_SEND_RETRY, tracker);
                 sendMessageDelayed(retryMsg, getSmsRetryDelayValue());
-                mPhone.getSmsStats().onOutgoingSms(
-                        tracker.mImsRetry > 0 /* isOverIms */,
-                        SmsConstants.FORMAT_3GPP2.equals(getFormat()),
-                        false /* fallbackToCs */,
-                        SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY,
-                        errorCode,
-                        tracker.mMessageId,
-                        tracker.isFromDefaultSmsApplication(mContext),
-                        tracker.getInterval(),
-                        mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                        tracker.isMtSmsPollingMessage(mContext));
-                if (mPhone != null) {
-                    TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
-                    if (telephonyAnalytics != null) {
-                        SmsMmsAnalytics smsMmsAnalytics = telephonyAnalytics.getSmsMmsAnalytics();
-                        if (smsMmsAnalytics != null) {
-                            smsMmsAnalytics.onOutgoingSms(
-                                    tracker.mImsRetry > 0 /* isOverIms */,
-                                    SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY
-                            );
-                        }
-                    }
-                }
-
+                reportOutgoingSmsMetrics(tracker, SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY,
+                        errorCode);
             } else {
                 int errorCode = (smsResponse != null) ? smsResponse.mErrorCode : NO_ERROR_CODE;
                 tracker.onFailed(mContext, error, errorCode);
                 notifySmsSentFailedToEmergencyStateTracker(tracker, false);
-                mPhone.getSmsStats().onOutgoingSms(
-                        tracker.mImsRetry > 0 /* isOverIms */,
-                        SmsConstants.FORMAT_3GPP2.equals(getFormat()),
-                        false /* fallbackToCs */,
-                        error,
-                        errorCode,
-                        tracker.mMessageId,
-                        tracker.isFromDefaultSmsApplication(mContext),
-                        tracker.getInterval(),
-                        mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
-                        tracker.isMtSmsPollingMessage(mContext));
-                if (mPhone != null) {
-                    TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
-                    if (telephonyAnalytics != null) {
-                        SmsMmsAnalytics smsMmsAnalytics = telephonyAnalytics.getSmsMmsAnalytics();
-                        if (smsMmsAnalytics != null) {
-                            smsMmsAnalytics.onOutgoingSms(
-                                    tracker.mImsRetry > 0 /* isOverIms */,
-                                    error);
-                        }
-                    }
-                }
+                reportOutgoingSmsMetrics(tracker, error, errorCode);
             }
         }
     }
@@ -1291,6 +1223,7 @@ public abstract class SMSDispatcher extends Handler {
     @SmsManager.Result
     private int rilErrorToSmsManagerResult(CommandException.Error rilError,
             SmsTracker tracker) {
+        Rlog.d(TAG, "rilErrorToSmsManagerResult: rilError=" + rilError + ", tracker=" + tracker);
         mSmsOutgoingErrorCodes.log("rilError: " + rilError
                 + ", MessageId: " + SmsController.formatCrossStackMessageId(tracker.mMessageId));
 
@@ -1492,7 +1425,7 @@ public abstract class SMSDispatcher extends Handler {
     @UnsupportedAppUsage
     protected void sendData(String callingPackage, int callingUser, String destAddr, String scAddr,
             int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean isForVvm, long uniqueMessageId) {
+            boolean isForVvm, long uniqueMessageId, int uid) {
         int messageRef = nextMessageRef();
         SmsMessageBase.SubmitPduBase pdu = getSubmitPdu(
                 scAddr, destAddr, destPort, data, (deliveryIntent != null), messageRef);
@@ -1502,7 +1435,7 @@ public abstract class SMSDispatcher extends Handler {
                     deliveryIntent, getFormat(), null /*messageUri*/, false /*expectMore*/,
                     null /*fullMessageText*/, false /*isText*/,
                     true /*persistMessage*/, isForVvm, 0L /* messageId */, messageRef,
-                    uniqueMessageId);
+                    uniqueMessageId, uid);
 
             if (!sendSmsByCarrierApp(true /* isDataSms */, tracker)) {
                 sendSubmitPdu(tracker);
@@ -1617,10 +1550,10 @@ public abstract class SMSDispatcher extends Handler {
             PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri,
             String callingPkg, int callingUser, boolean persistMessage, int priority,
             boolean expectMore, int validityPeriod, boolean isForVvm,
-            long messageId) {
+            long messageId, int uid) {
         sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg,
                 callingUser, persistMessage, priority, expectMore, validityPeriod, isForVvm,
-                messageId, false, PendingRequest.getNextUniqueMessageId());
+                messageId, false, PendingRequest.getNextUniqueMessageId(), uid);
     }
 
     /**
@@ -1728,7 +1661,7 @@ public abstract class SMSDispatcher extends Handler {
             PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri,
             String callingPkg, int callingUser, boolean persistMessage, int priority,
             boolean expectMore, int validityPeriod, boolean isForVvm,
-            long messageId, boolean skipShortCodeCheck, long uniqueMessageId) {
+            long messageId, boolean skipShortCodeCheck, long uniqueMessageId, int uid) {
         Rlog.d(TAG, "sendText id: " + SmsController.formatCrossStackMessageId(messageId));
         int messageRef = nextMessageRef();
         SmsMessageBase.SubmitPduBase pdu = getSubmitPdu(
@@ -1739,7 +1672,7 @@ public abstract class SMSDispatcher extends Handler {
             SmsTracker tracker = getSmsTracker(callingPkg, callingUser, map, sentIntent,
                     deliveryIntent, getFormat(), messageUri, expectMore, text, true /*isText*/,
                     persistMessage, priority, validityPeriod, isForVvm, messageId, messageRef,
-                    skipShortCodeCheck, uniqueMessageId);
+                    skipShortCodeCheck, uniqueMessageId, uid);
 
             if (!sendSmsByCarrierApp(false /* isDataSms */, tracker)) {
                 sendSubmitPdu(tracker);
@@ -1921,7 +1854,7 @@ public abstract class SMSDispatcher extends Handler {
             ArrayList<String> parts, ArrayList<PendingIntent> sentIntents,
             ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg,
             int callingUser, boolean persistMessage, int priority, boolean expectMore,
-            int validityPeriod, long messageId, long uniqueMessageId) {
+            int validityPeriod, long messageId, long uniqueMessageId, int uid) {
         final String fullMessageText = getMultipartMessageText(parts);
         int refNumber = getNextConcatenatedRef() & 0x00FF;
         int encoding = SmsConstants.ENCODING_UNKNOWN;
@@ -1984,7 +1917,7 @@ public abstract class SMSDispatcher extends Handler {
                         smsHeader, encoding, sentIntent, deliveryIntent, (i == (msgCount - 1)),
                         unsentPartCount, anyPartFailed, messageUri,
                         fullMessageText, priority, expectMore, validityPeriod, messageId,
-                        messageRef, uniqueMessageId);
+                        messageRef, uniqueMessageId, uid);
             if (trackers[i] == null) {
                 triggerSentIntentForFailure(sentIntents);
                 return;
@@ -2020,7 +1953,7 @@ public abstract class SMSDispatcher extends Handler {
             int encoding, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart,
             AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri,
             String fullMessageText, int priority, boolean expectMore, int validityPeriod,
-            long messageId, int messageRef, long uniqueMessageId) {
+            long messageId, int messageRef, long uniqueMessageId, int uid) {
         if (isCdmaMo()) {
             UserData uData = new UserData();
             uData.payloadStr = message;
@@ -2050,7 +1983,7 @@ public abstract class SMSDispatcher extends Handler {
                         deliveryIntent, getFormat(), unsentPartCount, anyPartFailed, messageUri,
                         smsHeader, (!lastPart || expectMore), fullMessageText,  /*isText*/
                         true,  /*persistMessage*/ true, priority, validityPeriod,  /* isForVvm */
-                        false, messageId, messageRef, false, uniqueMessageId);
+                        false, messageId, messageRef, false, uniqueMessageId, uid);
             } else {
                 Rlog.e(TAG, "CdmaSMSDispatcher.getNewSubmitPduTracker(): getSubmitPdu() returned "
                         + "null " + SmsController.formatCrossStackMessageId(messageId));
@@ -2069,7 +2002,7 @@ public abstract class SMSDispatcher extends Handler {
                         messageUri, smsHeader, (!lastPart || expectMore),
                         fullMessageText,  /*isText*/
                         true,  /*persistMessage*/ false, priority, validityPeriod,  /* isForVvm */
-                        false, messageId, messageRef, false, uniqueMessageId);
+                        false, messageId, messageRef, false, uniqueMessageId, uid);
             } else {
                 Rlog.e(TAG, "GsmSMSDispatcher.getNewSubmitPduTracker(): getSubmitPdu() returned "
                         + "null " + SmsController.formatCrossStackMessageId(messageId));
@@ -2544,7 +2477,10 @@ public abstract class SMSDispatcher extends Handler {
                     trackers[0].isFromDefaultSmsApplication(mContext),
                     trackers[0].getInterval(),
                     mTelephonyManager.isEmergencyNumber(trackers[0].mDestAddress),
-                    trackers[0].isMtSmsPollingMessage(mContext));
+                    trackers[0].isMtSmsPollingMessage(mContext),
+                    trackers[0].getPduLength(),
+                    trackers[0].getAppPackageName(),
+                    trackers[0].getAppUid());
             if (mPhone != null) {
                 TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
                 if (telephonyAnalytics != null) {
@@ -2633,6 +2569,8 @@ public abstract class SMSDispatcher extends Handler {
         private final UUID mAnomalyUnexpectedErrorFromRilUUID =
                 UUID.fromString("43043600-ea7a-44d2-9ae6-a58567ac7886");
 
+        private final int mAppUid;
+
         private SmsTracker(HashMap<String, Object> data, PendingIntent sentIntent,
                 PendingIntent deliveryIntent, PackageInfo appInfo, String destAddr, String format,
                 AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri,
@@ -2640,7 +2578,7 @@ public abstract class SMSDispatcher extends Handler {
                 boolean isText, boolean persistMessage, int userId, int priority,
                 int validityPeriod, boolean isForVvm, long messageId, int carrierId,
                 int messageRef, boolean skipShortCodeDestAddrCheck,
-                long uniqueMessageId) {
+                long uniqueMessageId, int uid) {
             mData = data;
             mSentIntent = sentIntent;
             mDeliveryIntent = deliveryIntent;
@@ -2669,6 +2607,7 @@ public abstract class SMSDispatcher extends Handler {
             mSkipShortCodeDestAddrCheck = skipShortCodeDestAddrCheck;
             mUniqueMessageId = uniqueMessageId;
             mResultCodeFromCarrierMessagingService = CarrierMessagingService.SEND_STATUS_OK;
+            mAppUid = uid;
         }
 
         @VisibleForTesting
@@ -2690,6 +2629,44 @@ public abstract class SMSDispatcher extends Handler {
             mUniqueMessageId = 0;
             mResultCodeFromCarrierMessagingService = CarrierMessagingService.SEND_STATUS_OK;
             mFullMessageText = messageText;
+            mAppUid = android.os.Process.INVALID_UID;
+        }
+
+        @VisibleForTesting
+        public SmsTracker(
+                HashMap<String, Object> data,
+                String destAddr,
+                String format,
+                long messageId,
+                int initialRetryCount,
+                String fullMessageText
+        ) {
+            this.mData = data;
+            this.mDestAddress = destAddr;
+            this.mFormat = format;
+            this.mMessageId = messageId;
+            this.mRetryCount = initialRetryCount;
+            this.mFullMessageText = fullMessageText;
+
+            this.mAppInfo = null;
+            this.mSentIntent = null;
+            this.mDeliveryIntent = null;
+            this.mSmsHeader = null;
+            this.mExpectMore = false;
+            this.mUsesImsServiceForIms = false;
+            this.mMessageRef = 0;
+            this.mValidityPeriod = -1;
+            this.mPriority = 0;
+            this.mIsText = true;
+            this.mPersistMessage = false;
+            this.mUserId = 0;
+            this.mSubId = 0;
+            this.mIsForVvm = false;
+            this.mCarrierId = 0;
+            this.mSkipShortCodeDestAddrCheck = false;
+            this.mUniqueMessageId = messageId;
+            this.mResultCodeFromCarrierMessagingService = CarrierMessagingService.SEND_STATUS_OK;
+            this.mAppUid = Process.INVALID_UID;
         }
 
         public HashMap<String, Object> getData() {
@@ -2708,7 +2685,7 @@ public abstract class SMSDispatcher extends Handler {
          * Get the calling Application Info
          * @return Application Info
          */
-        public ApplicationInfo getAppInfo() {
+        ApplicationInfo getAppInfo() {
             return mAppInfo == null ? null : mAppInfo.applicationInfo;
         }
 
@@ -2745,6 +2722,24 @@ public abstract class SMSDispatcher extends Handler {
             return mFullMessageText.equals(mtSmsPollingText);
         }
 
+        /**
+         * Returns the length of the PDU in bytes for this tracker, if available.
+         * This value is expected to be populated in the {@code mData} map during tracker creation
+         * after the PDU has been generated.
+         *
+         * @return The PDU length in bytes, or 0 if the length is not available or invalid.
+         */
+        public int getPduLength() {
+            if (mData == null) {
+                return 0;
+            }
+            byte[] encodedPdu =  (byte[]) mData.get(MAP_KEY_PDU);
+            if (encodedPdu == null) {
+                return 0;
+            }
+            return encodedPdu.length;
+        }
+
         /**
          * Update the status of this message if we persisted it
          */
@@ -2997,6 +2992,13 @@ public abstract class SMSDispatcher extends Handler {
                 }
             }
         }
+
+        /**
+         * Returns the application uid for this tracker.
+         */
+        public int getAppUid() {
+            return mAppUid;
+        }
     }
 
     protected SmsTracker getSmsTracker(String callingPackage, int callingUser,
@@ -3006,7 +3008,7 @@ public abstract class SMSDispatcher extends Handler {
             SmsHeader smsHeader, boolean expectMore, String fullMessageText, boolean isText,
             boolean persistMessage, int priority, int validityPeriod, boolean isForVvm,
             long messageId, int messageRef, boolean skipShortCodeCheck,
-            long uniqueMessageId) {
+            long uniqueMessageId, int uid) {
         if (!Flags.smsMmsDeliverBroadcastsRedirectToMainUser()) {
             callingUser = UserHandle.getUserHandleForUid(Binder.getCallingUid()).getIdentifier();
         }
@@ -3027,20 +3029,20 @@ public abstract class SMSDispatcher extends Handler {
                 unsentPartCount, anyPartFailed, messageUri, smsHeader, expectMore,
                 fullMessageText, getSubId(), isText, persistMessage, callingUser, priority,
                 validityPeriod, isForVvm, messageId, mPhone.getCarrierId(), messageRef,
-                skipShortCodeCheck, uniqueMessageId);
+                skipShortCodeCheck, uniqueMessageId, uid);
     }
 
     protected SmsTracker getSmsTracker(String callingPackage, int callingUser,
             HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent,
             String format, Uri messageUri, boolean expectMore, String fullMessageText,
             boolean isText, boolean persistMessage, boolean isForVvm,
-            long messageId, int messageRef, long uniqueMessageId) {
+            long messageId, int messageRef, long uniqueMessageId, int uid) {
         return getSmsTracker(callingPackage, callingUser , data, sentIntent, deliveryIntent,
                 format, /*unsentPartCount*/ null, /*anyPartFailed*/ null, messageUri, /*smsHeader*/
                 null, expectMore, fullMessageText, isText,
                 persistMessage, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                 SMS_MESSAGE_PERIOD_NOT_SPECIFIED,
-                isForVvm, messageId, messageRef, false, uniqueMessageId);
+                isForVvm, messageId, messageRef, false, uniqueMessageId, uid);
     }
 
     protected SmsTracker getSmsTracker(String callingPackage, int callingUser,
@@ -3048,12 +3050,12 @@ public abstract class SMSDispatcher extends Handler {
             String format, Uri messageUri, boolean expectMore, String fullMessageText,
             boolean isText, boolean persistMessage, int priority, int validityPeriod,
             boolean isForVvm, long messageId, int messageRef, boolean skipShortCodeCheck,
-            long uniqueMessageId) {
+            long uniqueMessageId, int uid) {
         return getSmsTracker(callingPackage, callingUser, data, sentIntent, deliveryIntent,
                 format, /*unsentPartCount*/ null, /*anyPartFailed*/ null, messageUri, /*smsHeader*/
                 null, expectMore, fullMessageText, isText, persistMessage, priority,
                 validityPeriod, isForVvm, messageId, messageRef, skipShortCodeCheck,
-                uniqueMessageId);
+                uniqueMessageId, uid);
     }
 
     protected HashMap<String, Object> getSmsTrackerMap(String destAddr, String scAddr,
@@ -3247,6 +3249,41 @@ public abstract class SMSDispatcher extends Handler {
         }
     }
 
+    private void reportOutgoingSmsMetrics(SmsTracker tracker, int result, int errorCode) {
+        if (mPhone != null) {
+            int resultForMetrics = result;
+            if (mFeatureFlags.satellite25q4Apis()
+                    && result == SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY
+                    && tracker.mRetryCount >= getMaxSmsRetryCount()) {
+                resultForMetrics = SmsManager.RESULT_SMS_SEND_FAIL_AFTER_MAX_RETRY;
+            }
+
+            mPhone.getSmsStats().onOutgoingSms(
+                    tracker.mImsRetry > 0 /* isOverIms */,
+                    SmsConstants.FORMAT_3GPP2.equals(getFormat()),
+                    false /* fallbackToCs */,
+                    resultForMetrics,
+                    errorCode,
+                    tracker.mMessageId,
+                    tracker.isFromDefaultSmsApplication(mContext),
+                    tracker.getInterval(),
+                    mTelephonyManager.isEmergencyNumber(tracker.mDestAddress),
+                    tracker.isMtSmsPollingMessage(mContext),
+                    tracker.getPduLength(),
+                    tracker.getAppPackageName(),
+                    tracker.getAppUid());
+            TelephonyAnalytics telephonyAnalytics = mPhone.getTelephonyAnalytics();
+            if (telephonyAnalytics != null) {
+                SmsMmsAnalytics smsMmsAnalytics = telephonyAnalytics.getSmsMmsAnalytics();
+                if (smsMmsAnalytics != null) {
+                    smsMmsAnalytics.onOutgoingSms(
+                            tracker.mImsRetry > 0 /* isOverIms */,
+                            result);
+                }
+            }
+        }
+    }
+
     /**
      * Dump local logs
      */
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index 7ca291fbc3..5f37c73b4b 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -230,6 +230,8 @@ public class ServiceStateTracker extends Handler {
 
     /* Radio power off pending flag */
     private volatile boolean mPendingRadioPowerOffAfterDataOff = false;
+    private volatile @DataNetwork.TearDownReason int mPendingRadioPowerOffReason =
+            DataNetwork.TEAR_DOWN_REASON_NONE;
 
     /** Waiting period before recheck gprs and voice registration. */
     public static final int DEFAULT_GPRS_CHECK_PERIOD_MILLIS = 60 * 1000;
@@ -357,7 +359,7 @@ public class ServiceStateTracker extends Handler {
     private final LocalLog mRadioPowerLog = new LocalLog(16);
     private final LocalLog mCdnrLogs = new LocalLog(64);
 
-    private Pattern mOperatorNameStringPattern;
+    @Nullable private Pattern mOperatorNameStringPattern;
     private PersistableBundle mCarrierConfig;
 
     @NonNull
@@ -806,9 +808,13 @@ public class ServiceStateTracker extends Handler {
 
         mDataDisconnectedCallback = new DataNetworkControllerCallback(this::post) {
             @Override
-            public void onAnyDataNetworkExistingChanged(boolean anyDataExisting) {
-                log("onAnyDataNetworkExistingChanged: anyDataExisting=" + anyDataExisting);
-                if (!anyDataExisting) {
+            public void onAnyDataNetworkExistingChanged(boolean anyDataExisting,
+                    boolean anyCellularDataExisting) {
+                log("onAnyDataNetworkExistingChanged: anyData=" + anyDataExisting
+                        + " anyCellularData=" + anyCellularDataExisting);
+                if (!anyDataExisting
+                        || mFeatureFlags.keepWfcOnApm()
+                        && !mDeviceShuttingDown && !anyCellularDataExisting) {
                     sendEmptyMessage(EVENT_ALL_DATA_DISCONNECTED);
                 }
             }
@@ -1302,8 +1308,14 @@ public class ServiceStateTracker extends Handler {
         switch (msg.what) {
             case EVENT_SET_RADIO_POWER_OFF:
                 synchronized(this) {
-                    mPendingRadioPowerOffAfterDataOff = false;
-                    log("Wait for all data networks torn down timed out. Power off now.");
+                    if (mFeatureFlags.keepWfcOnApm()) {
+                        mPendingRadioPowerOffReason = DataNetwork.TEAR_DOWN_REASON_NONE;
+                    } else {
+                        mPendingRadioPowerOffAfterDataOff = false;
+                    }
+                    log("Wait for all data networks due to "
+                            + DataNetwork.tearDownReasonToString(mPendingRadioPowerOffReason)
+                            + " torn down timed out. Power off now.");
                     hangupAndPowerOff();
                 }
                 break;
@@ -1584,21 +1596,32 @@ public class ServiceStateTracker extends Handler {
             case EVENT_ALL_DATA_DISCONNECTED:
                 log("EVENT_ALL_DATA_DISCONNECTED");
                 synchronized (this) {
-                    if (!mPendingRadioPowerOffAfterDataOff) return;
+                    if (mFeatureFlags.keepWfcOnApm()) {
+                        if (mPendingRadioPowerOffReason == DataNetwork.TEAR_DOWN_REASON_NONE) {
+                            return;
+                        }
+                    } else if (!mPendingRadioPowerOffAfterDataOff) {
+                        return;
+                    }
                     boolean areAllDataDisconnectedOnAllPhones = true;
                     for (Phone phone : PhoneFactory.getPhones()) {
-                        if (phone.getDataNetworkController().areAllDataDisconnected()) {
+                        if (phone.getDataNetworkController()
+                                .areAllDataDisconnected(!mDeviceShuttingDown/*cellularOnly*/)) {
                             phone.getDataNetworkController()
                                 .unregisterDataNetworkControllerCallback(
                                         mDataDisconnectedCallback);
                         } else {
                             log("Still waiting for all data disconnected on phone: "
-                                    + phone.getSubId());
+                                    + phone.getPhoneId());
                             areAllDataDisconnectedOnAllPhones = false;
                         }
                     }
                     if (areAllDataDisconnectedOnAllPhones) {
-                        mPendingRadioPowerOffAfterDataOff = false;
+                        if (mFeatureFlags.keepWfcOnApm()) {
+                            mPendingRadioPowerOffReason = DataNetwork.TEAR_DOWN_REASON_NONE;
+                        } else {
+                            mPendingRadioPowerOffAfterDataOff = false;
+                        }
                         removeMessages(EVENT_SET_RADIO_POWER_OFF);
                         if (DBG) log("Data disconnected for all phones, turn radio off now.");
                         hangupAndPowerOff();
@@ -2929,7 +2952,12 @@ public class ServiceStateTracker extends Handler {
         String wfcDataSpnFormat = null;
         String wfcFlightSpnFormat = null;
         int combinedRegState = getCombinedRegState(mSS);
-        if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()
+        boolean isWifiCallingEnabled = mPhone.getImsPhone() != null
+                && mPhone.getImsPhone().isWifiCallingEnabled();
+        log("updateCarrierDisplayName: isWifiCallingEnabled=" + isWifiCallingEnabled
+                        + " combinedRegState=" + ServiceState.rilServiceStateToString(
+                                combinedRegState) + " " + mSS);
+        if (isWifiCallingEnabled
                 && mPhone.isImsRegistered()
                 && (combinedRegState == ServiceState.STATE_IN_SERVICE
                 && mSS.getDataNetworkType() == TelephonyManager.NETWORK_TYPE_IWLAN)) {
@@ -3265,13 +3293,18 @@ public class ServiceStateTracker extends Handler {
 
         if (mDesiredPowerState && mDeviceShuttingDown) {
             log("setPowerStateToDesired powering on of radio failed because the device is " +
-                    "powering off");
+                    "shutting down");
             return;
         }
 
         // If we want it on and it's off, turn it on
         if (mDesiredPowerState && mRadioPowerOffReasons.isEmpty()
-                && (forceApply || mCi.getRadioState() == TelephonyManager.RADIO_POWER_OFF)) {
+                && (forceApply || mCi.getRadioState() == TelephonyManager.RADIO_POWER_OFF
+                  // When dynamic_modem_shutdown feature is enabled, allow turn on the modem at
+                  // RADIO_POWER_UNAVAILABLE state.
+                     || (mFeatureFlags.dynamicModemShutdown()
+                             && mCi.getRadioState()
+                                     == TelephonyManager.RADIO_POWER_UNAVAILABLE))) {
             mCi.setRadioPower(true, forEmergencyCall, isSelectedPhoneForEmergencyCall, null);
         } else if ((!mDesiredPowerState || !mRadioPowerOffReasons.isEmpty()) && mCi.getRadioState()
                 == TelephonyManager.RADIO_POWER_ON) {
@@ -3360,7 +3393,7 @@ public class ServiceStateTracker extends Handler {
 
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     protected final void log(String s) {
-        Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + s);
+        Rlog.d(LOG_TAG, "-" + mPhone.getPhoneId() + s);
     }
 
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
@@ -3466,6 +3499,9 @@ public class ServiceStateTracker extends Handler {
         switch (mCi.getRadioState()) {
             case TelephonyManager.RADIO_POWER_UNAVAILABLE:
                 handlePollStateInternalForRadioOffOrUnavailable(false);
+                if (mFeatureFlags.dynamicModemShutdown()) {
+                    mDeviceShuttingDown = false;
+                }
                 pollStateDone();
                 break;
 
@@ -3888,26 +3924,6 @@ public class ServiceStateTracker extends Handler {
             tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
 
             String localeOperator = null;
-            if (!mFeatureFlags.ignoreMccMncFromOperatorForLocale()) {
-                // If the OPERATOR command hasn't returned a valid operator or the device is on
-                // IWLAN (because operatorNumeric would be SIM's mcc/mnc when device is on IWLAN),
-                // but if the device has camped on a cell either to attempt registration or for
-                // emergency services, then for purposes of setting the locale, we don't care if
-                // registration fails or is incomplete. Additionally, if there is no cellular
-                // service and ims is registered over the IWLAN, the locale will not be updated.
-                // CellIdentity can return a null MCC and MNC in CDMA
-                localeOperator = operatorNumeric;
-                int dataNetworkType = mSS.getDataNetworkType();
-                if (dataNetworkType == TelephonyManager.NETWORK_TYPE_IWLAN
-                        || (dataNetworkType == TelephonyManager.NETWORK_TYPE_UNKNOWN
-                        && getImsRegistrationTech()
-                        == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN)) {
-                    // TODO(b/333346537#comment10): Complete solution would be ignore mcc/mnc
-                    //  reported by the unsolicited indication OPERATOR from RIL, but only relies on
-                    //  MCC/MNC from data registration or voice registration.
-                    localeOperator = null;
-                }
-            }
             if (isInvalidOperatorNumeric(localeOperator)) {
                 for (CellIdentity cid : prioritizedCids) {
                     if (!TextUtils.isEmpty(cid.getPlmn())) {
@@ -5148,34 +5164,78 @@ public class ServiceStateTracker extends Handler {
             if (DomainSelectionResolver.getInstance().isDomainSelectionSupported()) {
                 EmergencyStateTracker.getInstance().onCellularRadioPowerOffRequested();
             }
-            if (!mPendingRadioPowerOffAfterDataOff) {
-                // hang up all active voice calls first
-                if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
-                    mPhone.mCT.mRingingCall.hangupIfAlive();
-                    mPhone.mCT.mBackgroundCall.hangupIfAlive();
-                    mPhone.mCT.mForegroundCall.hangupIfAlive();
-                }
+            if (mFeatureFlags.keepWfcOnApm()) {
+                int reason = mDeviceShuttingDown
+                        ? DataNetwork.TEAR_DOWN_REASON_DEVICE_SHUT_DOWN
+                        : DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON;
+                if (reason != mPendingRadioPowerOffReason) {
+                    if (mPendingRadioPowerOffReason == DataNetwork
+                            .TEAR_DOWN_REASON_DEVICE_SHUT_DOWN) {
+                        log("powerOffRadioSafely: Ignore because device is shutting down.");
+                        return;
+                    }
+                    log("powerOffRadioSafely: due to "
+                            + DataNetwork.tearDownReasonToString(reason));
+                    // hang up all active voice calls first
+                    if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
+                        mPhone.mCT.mRingingCall.hangupIfAlive();
+                        mPhone.mCT.mBackgroundCall.hangupIfAlive();
+                        mPhone.mCT.mForegroundCall.hangupIfAlive();
+                    }
 
-                for (Phone phone : PhoneFactory.getPhones()) {
-                    if (!phone.getDataNetworkController().areAllDataDisconnected()) {
-                        log("powerOffRadioSafely: Data is active on phone " + phone.getSubId()
-                                + ". Wait for all data disconnect.");
-                        mPendingRadioPowerOffAfterDataOff = true;
-                        phone.getDataNetworkController().registerDataNetworkControllerCallback(
-                                mDataDisconnectedCallback);
+                    for (Phone phone : PhoneFactory.getPhones()) {
+                        if (!phone.getDataNetworkController().areAllDataDisconnected(
+                                !mDeviceShuttingDown/*cellularOnly*/)) {
+                            log("powerOffRadioSafely: Data is active on phone " + phone.getSubId()
+                                    + ". Wait for all data disconnect.");
+                            mPendingRadioPowerOffReason = reason;
+                            phone.getDataNetworkController().registerDataNetworkControllerCallback(
+                                    mDataDisconnectedCallback);
+                        }
+                    }
+
+                    // Tear down outside of the disconnected check to prevent race conditions.
+                    mPhone.getDataNetworkController().tearDownAllDataNetworks(reason);
+
+                    if (mPendingRadioPowerOffReason == DataNetwork.TEAR_DOWN_REASON_NONE) {
+                        log("powerOffRadioSafely: No data is connected, turn off radio now.");
+                        hangupAndPowerOff();
+                    } else if (!hasMessages(EVENT_SET_RADIO_POWER_OFF)) {
+                        sendEmptyMessageDelayed(EVENT_SET_RADIO_POWER_OFF,
+                                POWER_OFF_ALL_DATA_NETWORKS_DISCONNECTED_TIMEOUT);
                     }
                 }
+            } else {
+                if (!mPendingRadioPowerOffAfterDataOff) {
+                    // hang up all active voice calls first
+                    if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
+                        mPhone.mCT.mRingingCall.hangupIfAlive();
+                        mPhone.mCT.mBackgroundCall.hangupIfAlive();
+                        mPhone.mCT.mForegroundCall.hangupIfAlive();
+                    }
 
-                // Tear down outside of the disconnected check to prevent race conditions.
-                mPhone.getDataNetworkController().tearDownAllDataNetworks(
-                        DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+                    for (Phone phone : PhoneFactory.getPhones()) {
+                        if (!phone.getDataNetworkController()
+                                .areAllDataDisconnected(false/*placeholder*/)) {
+                            log("powerOffRadioSafely: Data is active on phone " + phone.getSubId()
+                                    + ". Wait for all data disconnect.");
+                            mPendingRadioPowerOffAfterDataOff = true;
+                            phone.getDataNetworkController().registerDataNetworkControllerCallback(
+                                    mDataDisconnectedCallback);
+                        }
+                    }
 
-                if (mPendingRadioPowerOffAfterDataOff) {
-                    sendEmptyMessageDelayed(EVENT_SET_RADIO_POWER_OFF,
-                            POWER_OFF_ALL_DATA_NETWORKS_DISCONNECTED_TIMEOUT);
-                } else {
-                    log("powerOffRadioSafely: No data is connected, turn off radio now.");
-                    hangupAndPowerOff();
+                    // Tear down outside of the disconnected check to prevent race conditions.
+                    mPhone.getDataNetworkController().tearDownAllDataNetworks(
+                            DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+
+                    if (mPendingRadioPowerOffAfterDataOff) {
+                        sendEmptyMessageDelayed(EVENT_SET_RADIO_POWER_OFF,
+                                POWER_OFF_ALL_DATA_NETWORKS_DISCONNECTED_TIMEOUT);
+                    } else {
+                        log("powerOffRadioSafely: No data is connected, turn off radio now.");
+                        hangupAndPowerOff();
+                    }
                 }
             }
         }
@@ -5185,6 +5245,9 @@ public class ServiceStateTracker extends Handler {
      * return true if there is pending disconnect data request to process; false otherwise.
      */
     public boolean isPendingRadioPowerOffAfterDataOff() {
+        if (mFeatureFlags.keepWfcOnApm()) {
+            return mPendingRadioPowerOffReason != DataNetwork.TEAR_DOWN_REASON_NONE;
+        }
         return mPendingRadioPowerOffAfterDataOff;
     }
 
@@ -5415,6 +5478,8 @@ public class ServiceStateTracker extends Handler {
         pw.println(" mDesiredPowerState=" + mDesiredPowerState);
         pw.println(" mRestrictedState=" + mRestrictedState);
         pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
+        pw.println(" mPendingRadioPowerOffReason=" + DataNetwork.tearDownReasonToString(
+                mPendingRadioPowerOffReason));
         pw.println(" mCellIdentity=" + Rlog.pii(VDBG, mCellIdentity));
         pw.println(" mLastCellInfoReqTime=" + mLastCellInfoReqTime);
         dumpCellInfoList(pw);
@@ -5842,8 +5907,10 @@ public class ServiceStateTracker extends Handler {
         if (!TextUtils.isEmpty(operatorNamePattern)) {
             mOperatorNameStringPattern = Pattern.compile(operatorNamePattern);
             if (DBG) {
-                log("mOperatorNameStringPattern: " + mOperatorNameStringPattern.toString());
+                log("mOperatorNameStringPattern: " + mOperatorNameStringPattern);
             }
+        } else {
+            mOperatorNameStringPattern = null;
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/SignalStrengthController.java b/src/java/com/android/internal/telephony/SignalStrengthController.java
index 31e195050f..52e80dc2f8 100644
--- a/src/java/com/android/internal/telephony/SignalStrengthController.java
+++ b/src/java/com/android/internal/telephony/SignalStrengthController.java
@@ -1356,6 +1356,7 @@ public class SignalStrengthController extends Handler {
 
     private void onServiceStateChanged(ServiceState state) {
         if (state.getState() != ServiceState.STATE_IN_SERVICE) {
+            mNTNConnected.set(false);
             return;
         }
 
diff --git a/src/java/com/android/internal/telephony/SmsBroadcastUndelivered.java b/src/java/com/android/internal/telephony/SmsBroadcastUndelivered.java
index 8c9a820ef1..8ed89ae86b 100644
--- a/src/java/com/android/internal/telephony/SmsBroadcastUndelivered.java
+++ b/src/java/com/android/internal/telephony/SmsBroadcastUndelivered.java
@@ -275,7 +275,7 @@ public class SmsBroadcastUndelivered {
                     if (phone != null) {
                         phone.getSmsStats().onDroppedIncomingMultipartSms(message.mIs3gpp2, rows,
                                 message.mMessageCount, TelephonyManager.from(context)
-                                        .isEmergencyNumber(message.mAddress));
+                                        .isEmergencyNumber(message.mAddress), 0);
                         TelephonyAnalytics telephonyAnalytics = phone.getTelephonyAnalytics();
                         if (telephonyAnalytics != null) {
                             SmsMmsAnalytics smsMmsAnalytics =
diff --git a/src/java/com/android/internal/telephony/SmsController.java b/src/java/com/android/internal/telephony/SmsController.java
index ab1eb318ac..518cfe1c95 100644
--- a/src/java/com/android/internal/telephony/SmsController.java
+++ b/src/java/com/android/internal/telephony/SmsController.java
@@ -177,6 +177,7 @@ public class SmsController extends ISmsImplBase {
             callingPackage = getCallingPackage();
         }
         UserHandle callingUser = Binder.getCallingUserHandle();
+        int uid = Binder.getCallingUid();
 
         Rlog.d(LOG_TAG, "sendDataForSubscriber caller=" + callingPackage);
 
@@ -184,7 +185,7 @@ public class SmsController extends ISmsImplBase {
         if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(mContext, subId,
                 callingUser, destAddr)) {
             TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(mContext, subId,
-                    Binder.getCallingUid(), callingPackage);
+                    uid, callingPackage);
             sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_USER_NOT_ALLOWED);
             return;
         }
@@ -199,7 +200,7 @@ public class SmsController extends ISmsImplBase {
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendData(callingPackage, callingUser.getIdentifier(),
                     callingAttributionTag, destAddr, scAddr, destPort,
-                    data, sentIntent, deliveryIntent);
+                    data, sentIntent, deliveryIntent, uid);
         } else {
             Rlog.e(LOG_TAG, "sendDataForSubscriber iccSmsIntMgr is null for"
                     + " Subscription: " + subId);
@@ -211,12 +212,12 @@ public class SmsController extends ISmsImplBase {
     private void sendDataForSubscriberWithSelfPermissionsInternal(int subId, String callingPackage,
             int callingUser, String callingAttributionTag, String destAddr, String scAddr,
             int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean isForVvm) {
+            boolean isForVvm, int uid) {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendDataWithSelfPermissions(callingPackage, callingUser,
                     callingAttributionTag, destAddr, scAddr, destPort, data, sentIntent,
-                    deliveryIntent, isForVvm);
+                    deliveryIntent, isForVvm, uid);
         } else {
             Rlog.e(LOG_TAG, "sendText iccSmsIntMgr is null for"
                     + " Subscription: " + subId);
@@ -226,14 +227,11 @@ public class SmsController extends ISmsImplBase {
 
     @NonNull
     private String getCallingPackage() {
-        if (mFlags.hsumPackageManager()) {
-            PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
-                    .getPackageManager();
-            String[] packages = pm.getPackagesForUid(Binder.getCallingUid());
-            if (packages == null || packages.length == 0) return "";
-            return packages[0];
-        }
-        return mContext.getPackageManager().getPackagesForUid(Binder.getCallingUid())[0];
+        PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
+                .getPackageManager();
+        String[] packages = pm.getPackagesForUid(Binder.getCallingUid());
+        if (packages == null || packages.length == 0) return "";
+        return packages[0];
     }
 
     @Override
@@ -275,7 +273,7 @@ public class SmsController extends ISmsImplBase {
             callingPackage = getCallingPackage();
         }
         UserHandle callingUser = Binder.getCallingUserHandle();
-
+        int uid = Binder.getCallingUid();
 
         Rlog.d(LOG_TAG, "sendTextForSubscriber caller=" + callingPackage);
 
@@ -324,7 +322,7 @@ public class SmsController extends ISmsImplBase {
             } else {
                 sendIccText(subId, callingPackage, callingUser.getIdentifier(), destAddr, scAddr,
                         text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp,
-                        messageId, skipShortCodeCheck);
+                        messageId, skipShortCodeCheck, uid);
             }
         } finally {
             Binder.restoreCallingIdentity(token);
@@ -344,14 +342,15 @@ public class SmsController extends ISmsImplBase {
 
     private void sendIccText(int subId, String callingPackage, int callingUser, String destAddr,
             String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean persistMessageForNonDefaultSmsApp, long messageId, boolean skipShortCodeCheck) {
+            boolean persistMessageForNonDefaultSmsApp, long messageId, boolean skipShortCodeCheck,
+            int uid) {
         Rlog.d(LOG_TAG, "sendTextForSubscriber iccSmsIntMgr"
                 + " Subscription: " + subId + " " + formatCrossStackMessageId(messageId));
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendText(callingPackage, callingUser, destAddr, scAddr, text, sentIntent,
                     deliveryIntent, persistMessageForNonDefaultSmsApp, messageId,
-                    skipShortCodeCheck);
+                    skipShortCodeCheck, uid);
         } else {
             Rlog.e(LOG_TAG, "sendTextForSubscriber iccSmsIntMgr is null for"
                     + " Subscription: " + subId + " " + formatCrossStackMessageId(messageId));
@@ -362,12 +361,12 @@ public class SmsController extends ISmsImplBase {
     private void sendTextForSubscriberWithSelfPermissionsInternal(int subId, String callingPackage,
             int callingUser, String callingAttributeTag, String destAddr, String scAddr,
             String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean persistMessage, boolean isForVvm) {
+            boolean persistMessage, boolean isForVvm, int uid) {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendTextWithSelfPermissions(callingPackage, callingUser,
                     callingAttributeTag, destAddr, scAddr, text, sentIntent, deliveryIntent,
-                    persistMessage, isForVvm);
+                    persistMessage, isForVvm, uid);
         } else {
             Rlog.e(LOG_TAG, "sendText iccSmsIntMgr is null for"
                     + " Subscription: " + subId);
@@ -384,6 +383,7 @@ public class SmsController extends ISmsImplBase {
             callingPackage = getCallingPackage();
         }
         UserHandle callingUser = Binder.getCallingUserHandle();
+        int uid = Binder.getCallingUid();
 
         Rlog.d(LOG_TAG, "sendTextForSubscriberWithOptions caller=" + callingPackage);
 
@@ -391,7 +391,7 @@ public class SmsController extends ISmsImplBase {
         if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(mContext, subId,
                 Binder.getCallingUserHandle(), destAddr)) {
             TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(mContext, subId,
-                    Binder.getCallingUid(), callingPackage);
+                    uid, callingPackage);
             sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_USER_NOT_ALLOWED);
             return;
         }
@@ -406,7 +406,7 @@ public class SmsController extends ISmsImplBase {
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendTextWithOptions(callingPackage, callingUser.getIdentifier(),
                     callingAttributionTag, destAddr, scAddr, parts, sentIntent, deliveryIntent,
-                    persistMessage, priority, expectMore, validityPeriod);
+                    persistMessage, priority, expectMore, validityPeriod, uid);
         } else {
             Rlog.e(LOG_TAG, "sendTextWithOptions iccSmsIntMgr is null for"
                     + " Subscription: " + subId);
@@ -423,6 +423,7 @@ public class SmsController extends ISmsImplBase {
         // returned by getCallPackage() for backward-compatibility.
         callingPackage = getCallingPackage();
         UserHandle callingUser = Binder.getCallingUserHandle();
+        int uid = Binder.getCallingUid();
 
         Rlog.d(LOG_TAG, "sendMultipartTextForSubscriber caller=" + callingPackage);
 
@@ -430,7 +431,7 @@ public class SmsController extends ISmsImplBase {
         if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(mContext, subId,
                 Binder.getCallingUserHandle(), destAddr)) {
             TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(mContext, subId,
-                    Binder.getCallingUid(), callingPackage);
+                    uid, callingPackage);
             sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_USER_NOT_ALLOWED);
             return;
         }
@@ -447,7 +448,7 @@ public class SmsController extends ISmsImplBase {
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendMultipartText(callingPackage, callingUser.getIdentifier(),
                     callingAttributionTag, destAddr, scAddr, parts, sentIntents, deliveryIntents,
-                    persistMessageForNonDefaultSmsApp, messageId);
+                    persistMessageForNonDefaultSmsApp, messageId, uid);
         } else {
             Rlog.e(LOG_TAG, "sendMultipartTextForSubscriber iccSmsIntMgr is null for"
                     + " Subscription: " + subId + " " + formatCrossStackMessageId(messageId));
@@ -464,6 +465,7 @@ public class SmsController extends ISmsImplBase {
             callingPackage = getCallingPackage();
         }
         UserHandle callingUser = Binder.getCallingUserHandle();
+        int uid = Binder.getCallingUid();
 
         Rlog.d(LOG_TAG, "sendMultipartTextForSubscriberWithOptions caller=" + callingPackage);
 
@@ -471,7 +473,7 @@ public class SmsController extends ISmsImplBase {
         if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(mContext, subId,
                 Binder.getCallingUserHandle(), destAddr)) {
             TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(mContext, subId,
-                    Binder.getCallingUid(), callingPackage);
+                    uid, callingPackage);
             sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_USER_NOT_ALLOWED);
             return;
         }
@@ -486,7 +488,7 @@ public class SmsController extends ISmsImplBase {
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, callingUser.getIdentifier(),
                     callingAttributionTag, destAddr, scAddr, parts, sentIntents, deliveryIntents,
-                    persistMessage, priority, expectMore, validityPeriod, 0L /* messageId */);
+                    persistMessage, priority, expectMore, validityPeriod, 0L /* messageId */, uid);
         } else {
             Rlog.e(LOG_TAG, "sendMultipartTextWithOptions iccSmsIntMgr is null for"
                     + " Subscription: " + subId);
@@ -739,15 +741,16 @@ public class SmsController extends ISmsImplBase {
             PendingIntent deliveryIntent) {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         UserHandle callingUser = Binder.getCallingUserHandle();
+        final int uid = Binder.getCallingUid();
         if (!getCallingPackage().equals(callingPkg)) {
             throw new SecurityException("sendStoredText: Package " + callingPkg
-                    + "does not belong to " + Binder.getCallingUid());
+                    + "does not belong to " + uid);
         }
         Rlog.d(LOG_TAG, "sendStoredText caller=" + callingPkg);
 
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendStoredText(callingPkg, callingUser.getIdentifier(),
-                    callingAttributionTag, messageUri, scAddress, sentIntent, deliveryIntent);
+                    callingAttributionTag, messageUri, scAddress, sentIntent, deliveryIntent, uid);
         } else {
             Rlog.e(LOG_TAG, "sendStoredText iccSmsIntMgr is null for subscription: " + subId);
             sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
@@ -760,16 +763,18 @@ public class SmsController extends ISmsImplBase {
             List<PendingIntent> deliveryIntents) {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         UserHandle callingUser = Binder.getCallingUserHandle();
+        final int uid = Binder.getCallingUid();
 
         if (!getCallingPackage().equals(callingPkg)) {
             throw new SecurityException("sendStoredMultipartText: Package " + callingPkg
-                    + " does not belong to " + Binder.getCallingUid());
+                    + " does not belong to " + uid);
         }
         Rlog.d(LOG_TAG, "sendStoredMultipartText caller=" + callingPkg);
 
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendStoredMultipartText(callingPkg, callingUser.getIdentifier(),
-                    callingAttributionTag, messageUri, scAddress, sentIntents, deliveryIntents);
+                    callingAttributionTag, messageUri, scAddress, sentIntents, deliveryIntents,
+                    uid);
         } else {
             Rlog.e(LOG_TAG, "sendStoredMultipartText iccSmsIntMgr is null for subscription: "
                     + subId);
@@ -1015,11 +1020,12 @@ public class SmsController extends ISmsImplBase {
             return;
         }
 
+        int uid = Binder.getCallingUid();
         // Check if user is associated with the subscription
         if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(mContext, subId,
                 Binder.getCallingUserHandle(), number)) {
             TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(mContext, subId,
-                    Binder.getCallingUid(), callingPackage);
+                    uid, callingPackage);
             sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_USER_NOT_ALLOWED);
             return;
         }
@@ -1027,12 +1033,12 @@ public class SmsController extends ISmsImplBase {
         if (port == 0) {
             sendTextForSubscriberWithSelfPermissionsInternal(subId, callingPackage, callingUser,
                     callingAttributionTag, number, null, text, sentIntent, null, false,
-                    true /* isForVvm */);
+                    true /* isForVvm */, uid);
         } else {
             byte[] data = text.getBytes(StandardCharsets.UTF_8);
             sendDataForSubscriberWithSelfPermissionsInternal(subId, callingPackage, callingUser,
                     callingAttributionTag, number, null, (short) port, data, sentIntent, null,
-                    true /* isForVvm */);
+                    true /* isForVvm */, uid);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/SmsDispatchersController.java b/src/java/com/android/internal/telephony/SmsDispatchersController.java
index 43d7eda4e1..6a9c1567ec 100644
--- a/src/java/com/android/internal/telephony/SmsDispatchersController.java
+++ b/src/java/com/android/internal/telephony/SmsDispatchersController.java
@@ -144,6 +144,9 @@ public class SmsDispatchersController extends Handler {
     private SMSDispatcher mGsmDispatcher;
     private ImsSmsDispatcher mImsSmsDispatcher;
 
+    /** Used for storing last TP - Message Reference used.*/
+    private int mMessageRef = -1;
+
     private GsmInboundSmsHandler mGsmInboundSmsHandler;
     private CdmaInboundSmsHandler mCdmaInboundSmsHandler = null;
 
@@ -249,6 +252,7 @@ public class SmsDispatchersController extends Handler {
         public final boolean skipShortCodeCheck;
         public final long uniqueMessageId;
         public final boolean isMtSmsPolling;
+        public final int mApplicationUid;
 
         public PendingRequest(int type, SMSDispatcher.SmsTracker tracker, String callingPackage,
                 int callingUser, String destAddr, String scAddr,
@@ -256,7 +260,7 @@ public class SmsDispatchersController extends Handler {
                 boolean isForVvm, byte[] data, int destPort, ArrayList<String> texts,
                 Uri messageUri, boolean persistMessage, int priority, boolean expectMore,
                 int validityPeriod, long messageId, boolean skipShortCodeCheck,
-                boolean isMtSmsPolling) {
+                boolean isMtSmsPolling, int uid) {
             this.type = type;
             this.tracker = tracker;
             this.callingPackage = callingPackage;
@@ -284,6 +288,7 @@ public class SmsDispatchersController extends Handler {
                 this.uniqueMessageId = getNextUniqueMessageId();
             }
             this.isMtSmsPolling = isMtSmsPolling;
+            this.mApplicationUid = uid;
         }
 
         public static long getNextUniqueMessageId() {
@@ -409,16 +414,17 @@ public class SmsDispatchersController extends Handler {
 
         // Create dispatchers, inbound SMS handlers and
         // broadcast undelivered messages in raw table.
-        mImsSmsDispatcher = new ImsSmsDispatcher(phone, this, ImsManager::getConnector);
+        mImsSmsDispatcher = new ImsSmsDispatcher(phone, this, ImsManager::getConnector,
+                mFeatureFlags);
         mGsmInboundSmsHandler = GsmInboundSmsHandler.makeInboundSmsHandler(phone.getContext(),
                 storageMonitor, phone, looper, mFeatureFlags);
         if (ENABLE_CDMA_DISPATCHER) {
-            mCdmaDispatcher = new CdmaSMSDispatcher(phone, this);
+            mCdmaDispatcher = new CdmaSMSDispatcher(phone, this, mFeatureFlags);
             mCdmaInboundSmsHandler = CdmaInboundSmsHandler.makeInboundSmsHandler(phone.getContext(),
                     storageMonitor, phone, (CdmaSMSDispatcher) mCdmaDispatcher, looper,
                     mFeatureFlags);
         }
-        mGsmDispatcher = new GsmSMSDispatcher(phone, this, mGsmInboundSmsHandler);
+        mGsmDispatcher = new GsmSMSDispatcher(phone, this, mGsmInboundSmsHandler, mFeatureFlags);
         SmsBroadcastUndelivered.initialize(phone.getContext(),
                 mGsmInboundSmsHandler, mCdmaInboundSmsHandler, mFeatureFlags);
         InboundSmsHandler.registerNewMessageNotificationActionHandler(phone.getContext());
@@ -843,7 +849,7 @@ public class SmsDispatchersController extends Handler {
                         null, UserHandle.USER_NULL, null, null,
                         null, null, false, null, 0,
                         null, null, false,
-                        0, false, 0, 0L, false, false);
+                        0, false, 0, 0L, false, false, tracker.getAppUid());
                 args.arg3 = "sendRetrySms";
                 sendMessage(obtainMessage(EVENT_REQUEST_DOMAIN_SELECTION, args));
                 return;
@@ -1035,8 +1041,7 @@ public class SmsDispatchersController extends Handler {
      * @return {@code true} if the SMS domain selection is enabled, {@code false} otherwise.
      */
     private boolean isSmsDomainSelectionEnabled() {
-        return mFeatureFlags.smsDomainSelectionEnabled()
-                && mDomainSelectionResolverProxy.isDomainSelectionSupported();
+        return mDomainSelectionResolverProxy.isDomainSelectionSupported();
     }
 
     /**
@@ -1431,17 +1436,17 @@ public class SmsDispatchersController extends Handler {
             mImsSmsDispatcher.sendData(request.callingPackage, request.callingUser,
                     request.destAddr, request.scAddr, request.destPort, request.data,
                     request.sentIntents.get(0), request.deliveryIntents.get(0), request.isForVvm,
-                    request.uniqueMessageId);
+                    request.uniqueMessageId, request.mApplicationUid);
         } else if (isCdmaMo(domain)) {
             mCdmaDispatcher.sendData(request.callingPackage, request.callingUser, request.destAddr,
                     request.scAddr, request.destPort, request.data,
                     request.sentIntents.get(0), request.deliveryIntents.get(0), request.isForVvm,
-                    request.uniqueMessageId);
+                    request.uniqueMessageId, request.mApplicationUid);
         } else {
             mGsmDispatcher.sendData(request.callingPackage, request.callingUser, request.destAddr,
                     request.scAddr, request.destPort, request.data,
                     request.sentIntents.get(0), request.deliveryIntents.get(0), request.isForVvm,
-                    request.uniqueMessageId);
+                    request.uniqueMessageId, request.mApplicationUid);
         }
     }
 
@@ -1461,7 +1466,7 @@ public class SmsDispatchersController extends Handler {
                     request.messageUri, request.callingPackage, request.callingUser,
                     request.persistMessage, request.priority,  /*request.expectMore*/ false,
                     request.validityPeriod, request.isForVvm, request.messageId,
-                    request.skipShortCodeCheck, request.uniqueMessageId);
+                    request.skipShortCodeCheck, request.uniqueMessageId, request.mApplicationUid);
         } else {
             if (isCdmaMo(domain)) {
                 mCdmaDispatcher.sendText(request.destAddr, request.scAddr, request.texts.get(0),
@@ -1469,14 +1474,16 @@ public class SmsDispatchersController extends Handler {
                         request.messageUri, request.callingPackage, request.callingUser,
                         request.persistMessage, request.priority, request.expectMore,
                         request.validityPeriod, request.isForVvm, request.messageId,
-                        request.skipShortCodeCheck, request.uniqueMessageId);
+                        request.skipShortCodeCheck, request.uniqueMessageId,
+                        request.mApplicationUid);
             } else {
                 mGsmDispatcher.sendText(request.destAddr, request.scAddr, request.texts.get(0),
                         request.sentIntents.get(0), request.deliveryIntents.get(0),
                         request.messageUri, request.callingPackage, request.callingUser,
                         request.persistMessage, request.priority, request.expectMore,
                         request.validityPeriod, request.isForVvm, request.messageId,
-                        request.skipShortCodeCheck, request.uniqueMessageId);
+                        request.skipShortCodeCheck, request.uniqueMessageId,
+                        request.mApplicationUid);
             }
         }
     }
@@ -1496,20 +1503,20 @@ public class SmsDispatchersController extends Handler {
                     request.sentIntents, request.deliveryIntents, request.messageUri,
                     request.callingPackage, request.callingUser, request.persistMessage,
                     request.priority, false /*request.expectMore*/, request.validityPeriod,
-                    request.messageId, request.uniqueMessageId);
+                    request.messageId, request.uniqueMessageId, request.mApplicationUid);
         } else {
             if (isCdmaMo(domain)) {
                 mCdmaDispatcher.sendMultipartText(request.destAddr, request.scAddr, request.texts,
                         request.sentIntents, request.deliveryIntents, request.messageUri,
                         request.callingPackage, request.callingUser, request.persistMessage,
                         request.priority, request.expectMore, request.validityPeriod,
-                        request.messageId, request.uniqueMessageId);
+                        request.messageId, request.uniqueMessageId, request.mApplicationUid);
             } else {
                 mGsmDispatcher.sendMultipartText(request.destAddr, request.scAddr, request.texts,
                         request.sentIntents, request.deliveryIntents, request.messageUri,
                         request.callingPackage, request.callingUser, request.persistMessage,
                         request.priority, request.expectMore, request.validityPeriod,
-                        request.messageId, request.uniqueMessageId);
+                        request.messageId, request.uniqueMessageId, request.mApplicationUid);
             }
         }
     }
@@ -1626,7 +1633,7 @@ public class SmsDispatchersController extends Handler {
      */
     protected void sendData(String callingPackage, int callingUser, String destAddr, String scAddr,
             int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean isForVvm) {
+            boolean isForVvm, int uid) {
         if (TextUtils.isEmpty(scAddr)) {
             scAddr = getSmscAddressFromUSIMWithPhoneIdentity(callingPackage);
         }
@@ -1637,7 +1644,7 @@ public class SmsDispatchersController extends Handler {
                             destAddr, scAddr, asArrayList(sentIntent),
                             asArrayList(deliveryIntent), isForVvm, data, destPort, null,
                             null, false, 0, false, 0,
-                            0L, false, false),
+                            0L, false, false, uid),
                     "sendData");
             return;
         }
@@ -1645,15 +1652,15 @@ public class SmsDispatchersController extends Handler {
         if (mImsSmsDispatcher.isAvailable()) {
             mImsSmsDispatcher.sendData(callingPackage, callingUser, destAddr, scAddr, destPort,
                     data, sentIntent, deliveryIntent, isForVvm,
-                    PendingRequest.getNextUniqueMessageId());
+                    PendingRequest.getNextUniqueMessageId(), uid);
         } else if (isCdmaMo()) {
             mCdmaDispatcher.sendData(callingPackage, callingUser, destAddr, scAddr, destPort, data,
                     sentIntent, deliveryIntent, isForVvm,
-                    PendingRequest.getNextUniqueMessageId());
+                    PendingRequest.getNextUniqueMessageId(), uid);
         } else {
             mGsmDispatcher.sendData(callingPackage, callingUser, destAddr, scAddr, destPort, data,
                     sentIntent, deliveryIntent, isForVvm,
-                    PendingRequest.getNextUniqueMessageId());
+                    PendingRequest.getNextUniqueMessageId(), uid);
         }
     }
 
@@ -1757,10 +1764,10 @@ public class SmsDispatchersController extends Handler {
     public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent,
             PendingIntent deliveryIntent, Uri messageUri, String callingPkg, int callingUser,
             boolean persistMessage, int priority, boolean expectMore, int validityPeriod,
-            boolean isForVvm, long messageId) {
+            boolean isForVvm, long messageId, int uid) {
         sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg,
                 callingUser, persistMessage, priority, expectMore, validityPeriod, isForVvm,
-                messageId, false);
+                messageId, false, uid);
     }
 
     /**
@@ -1864,7 +1871,7 @@ public class SmsDispatchersController extends Handler {
     public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent,
             PendingIntent deliveryIntent, Uri messageUri, String callingPkg, int callingUser,
             boolean persistMessage, int priority, boolean expectMore, int validityPeriod,
-            boolean isForVvm, long messageId, boolean skipShortCodeCheck) {
+            boolean isForVvm, long messageId, boolean skipShortCodeCheck, int uid) {
         if (TextUtils.isEmpty(scAddr)) {
             scAddr = getSmscAddressFromUSIMWithPhoneIdentity(callingPkg);
         }
@@ -1873,7 +1880,7 @@ public class SmsDispatchersController extends Handler {
                 callingPkg, callingUser, destAddr, scAddr, asArrayList(sentIntent),
                 asArrayList(deliveryIntent), isForVvm, null, 0, asArrayList(text),
                 messageUri, persistMessage, priority, expectMore, validityPeriod, messageId,
-                skipShortCodeCheck, false);
+                skipShortCodeCheck, false, uid);
 
         if (SatelliteController.getInstance().shouldSendSmsToDatagramDispatcher(mPhone)) {
             // Send P2P SMS using carrier roaming NB IOT NTN
@@ -1906,7 +1913,7 @@ public class SmsDispatchersController extends Handler {
                     request.messageUri, request.callingPackage, request.callingUser,
                     request.persistMessage, request.priority, false /*expectMore*/,
                     request.validityPeriod, request.isForVvm, request.messageId,
-                    request.skipShortCodeCheck, request.uniqueMessageId);
+                    request.skipShortCodeCheck, request.uniqueMessageId, request.mApplicationUid);
         } else {
             if (isCdmaMo()) {
                 mCdmaDispatcher.sendText(request.destAddr, request.scAddr, request.texts.get(0),
@@ -1914,14 +1921,16 @@ public class SmsDispatchersController extends Handler {
                         request.messageUri, request.callingPackage, request.callingUser,
                         request.persistMessage, request.priority, request.expectMore,
                         request.validityPeriod, request.isForVvm, request.messageId,
-                        request.skipShortCodeCheck, request.uniqueMessageId);
+                        request.skipShortCodeCheck, request.uniqueMessageId,
+                        request.mApplicationUid);
             } else {
                 mGsmDispatcher.sendText(request.destAddr, request.scAddr, request.texts.get(0),
                         request.sentIntents.get(0), request.deliveryIntents.get(0),
                         request.messageUri, request.callingPackage, request.callingUser,
                         request.persistMessage, request.priority, request.expectMore,
                         request.validityPeriod, request.isForVvm, request.messageId,
-                        request.skipShortCodeCheck, request.uniqueMessageId);
+                        request.skipShortCodeCheck, request.uniqueMessageId,
+                        request.mApplicationUid);
             }
         }
     }
@@ -2034,7 +2043,7 @@ public class SmsDispatchersController extends Handler {
             ArrayList<String> parts, ArrayList<PendingIntent> sentIntents,
             ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg,
             int callingUser, boolean persistMessage, int priority, boolean expectMore,
-            int validityPeriod, long messageId) {
+            int validityPeriod, long messageId, int uid) {
         if (TextUtils.isEmpty(scAddr)) {
             scAddr = getSmscAddressFromUSIMWithPhoneIdentity(callingPkg);
         }
@@ -2042,7 +2051,7 @@ public class SmsDispatchersController extends Handler {
         PendingRequest pendingRequest = new PendingRequest(PendingRequest.TYPE_MULTIPART_TEXT, null,
                 callingPkg, callingUser, destAddr, scAddr, sentIntents, deliveryIntents, false,
                 null, 0, parts, messageUri, persistMessage, priority, expectMore,
-                validityPeriod, messageId, false, false);
+                validityPeriod, messageId, false, false, uid);
 
         if (SatelliteController.getInstance().shouldSendSmsToDatagramDispatcher(mPhone)) {
             // Send multipart P2P SMS using carrier roaming NB IOT NTN
@@ -2079,20 +2088,20 @@ public class SmsDispatchersController extends Handler {
                     request.sentIntents, request.deliveryIntents, request.messageUri,
                     request.callingPackage, request.callingUser, request.persistMessage,
                     request.priority, false /*expectMore*/, request.validityPeriod,
-                    request.messageId, request.uniqueMessageId);
+                    request.messageId, request.uniqueMessageId, request.mApplicationUid);
         } else {
             if (isCdmaMo()) {
                 mCdmaDispatcher.sendMultipartText(request.destAddr, request.scAddr, request.texts,
                         request.sentIntents, request.deliveryIntents, request.messageUri,
                         request.callingPackage, request.callingUser, request.persistMessage,
                         request.priority, request.expectMore, request.validityPeriod,
-                        request.messageId, request.uniqueMessageId);
+                        request.messageId, request.uniqueMessageId, request.mApplicationUid);
             } else {
                 mGsmDispatcher.sendMultipartText(request.destAddr, request.scAddr, request.texts,
                         request.sentIntents, request.deliveryIntents, request.messageUri,
                         request.callingPackage, request.callingUser, request.persistMessage,
                         request.priority, request.expectMore, request.validityPeriod,
-                        request.messageId, request.uniqueMessageId);
+                        request.messageId, request.uniqueMessageId, request.mApplicationUid);
             }
         }
     }
@@ -2290,13 +2299,31 @@ public class SmsDispatchersController extends Handler {
                 callingPackage, Binder.getCallingUserHandle().getIdentifier(), destAddr,
                 getSmscAddressFromUSIMWithPhoneIdentity(callingPackage), asArrayList(null),
                 asArrayList(null), false, null, 0, asArrayList(mtSmsPollingText), null, false, 0,
-                false, 5, 0L, true, true);
+                false, 5, 0L, true, true, Binder.getCallingUid());
 
         if (SatelliteController.getInstance().shouldSendSmsToDatagramDispatcher(mPhone)) {
             DatagramDispatcher.getInstance().sendSms(pendingRequest);
         }
     }
 
+    public int getMessageReference() {
+        return mMessageRef;
+    }
+
+    public void setMessageReference(int messageReference) {
+        mMessageRef = messageReference;
+    }
+
+    /**
+     * Increment the value of the message reference by 1.
+     *
+     * @return The new value of the message reference.
+     */
+    public int incrementMessageReference() {
+        mMessageRef = (mMessageRef + 1) % 256;
+        return mMessageRef;
+    }
+
     public interface SmsInjectionCallback {
         void onSmsInjectedResult(int result);
     }
diff --git a/src/java/com/android/internal/telephony/SmsStorageMonitor.java b/src/java/com/android/internal/telephony/SmsStorageMonitor.java
index 07b7a18891..d0871f5565 100644
--- a/src/java/com/android/internal/telephony/SmsStorageMonitor.java
+++ b/src/java/com/android/internal/telephony/SmsStorageMonitor.java
@@ -257,7 +257,6 @@ public class SmsStorageMonitor extends Handler {
                 if (smsIfcMngr.mDispatchersController.isIms() && isAvailable) {
                     smsIfcMngr.mDispatchersController.reportSmsMemoryStatus(
                             obtainMessage(EVENT_REPORT_MEMORY_STATUS_DONE));
-                    return;
                 }
             }
         }
@@ -285,12 +284,8 @@ public class SmsStorageMonitor extends Handler {
         intent.setComponent(componentName);
         mWakeLock.acquire(WAKE_LOCK_TIMEOUT);
         SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                    android.Manifest.permission.RECEIVE_SMS);
-        } else {
-            mContext.sendBroadcast(intent, android.Manifest.permission.RECEIVE_SMS);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                android.Manifest.permission.RECEIVE_SMS);
     }
 
     /** Returns whether or not there is storage available for an incoming SMS. */
diff --git a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
index b4a3ee67e2..c01d6a98b1 100644
--- a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
+++ b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
@@ -28,6 +28,7 @@ import android.system.Os;
 import android.system.OsConstants;
 import android.system.StructStatVfs;
 import android.text.TextUtils;
+import android.util.SparseArray;
 
 import com.android.ims.ImsManager;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
@@ -583,6 +584,7 @@ public class TelephonyComponentFactory {
      *
      * @param phone The phone instance.
      * @param dataNetworkController Data network controller instance.
+     * @param dataServiceManagers Data service manager instances.
      * @param looper The looper to be used by the handler. Currently the handler thread is the phone
      * process's main thread.
      * @param callback Callback for passing events back to data network controller.
@@ -590,9 +592,11 @@ public class TelephonyComponentFactory {
      */
     public @NonNull DataSettingsManager makeDataSettingsManager(@NonNull Phone phone,
             @NonNull DataNetworkController dataNetworkController,
+            @NonNull SparseArray<DataServiceManager> dataServiceManagers,
             @NonNull FeatureFlags featureFlags, @NonNull Looper looper,
             @NonNull DataSettingsManager.DataSettingsManagerCallback callback) {
-        return new DataSettingsManager(phone, dataNetworkController, featureFlags, looper,
+        return new DataSettingsManager(phone, dataNetworkController, dataServiceManagers,
+                featureFlags, looper,
                 callback);
     }
 
diff --git a/src/java/com/android/internal/telephony/TelephonyCountryDetector.java b/src/java/com/android/internal/telephony/TelephonyCountryDetector.java
index 542964c32e..02c06dca1f 100644
--- a/src/java/com/android/internal/telephony/TelephonyCountryDetector.java
+++ b/src/java/com/android/internal/telephony/TelephonyCountryDetector.java
@@ -236,7 +236,15 @@ public class TelephonyCountryDetector extends Handler {
         }
 
         List<String> result = new ArrayList<>();
-        for (Phone phone : PhoneFactory.getPhones()) {
+        Phone[] phones;
+        try {
+            phones = PhoneFactory.getPhones();
+        } catch (IllegalStateException e) {
+            logd("getCurrentNetworkCountryIso: PhoneFactory.getPhones() failed, e=" + e);
+            return result;
+        }
+
+        for (Phone phone : phones) {
             String countryIso = getNetworkCountryIsoForPhone(phone);
             if (isValid(countryIso)) {
                 String countryIsoInUpperCase = countryIso.toUpperCase(Locale.US);
diff --git a/src/java/com/android/internal/telephony/VisualVoicemailSmsFilter.java b/src/java/com/android/internal/telephony/VisualVoicemailSmsFilter.java
index 64ecdc987c..1b277b724d 100644
--- a/src/java/com/android/internal/telephony/VisualVoicemailSmsFilter.java
+++ b/src/java/com/android/internal/telephony/VisualVoicemailSmsFilter.java
@@ -35,7 +35,6 @@ import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.VisualVoicemailSmsParser.WrappedMessageData;
-import com.android.internal.telephony.flags.Flags;
 
 import java.nio.ByteBuffer;
 import java.nio.charset.CharacterCodingException;
@@ -287,11 +286,7 @@ public class VisualVoicemailSmsFilter {
         intent.putExtra(VoicemailContract.EXTRA_VOICEMAIL_SMS, builder.build());
         intent.putExtra(VoicemailContract.EXTRA_TARGET_PACKAGE, filterSettings.packageName);
         intent.setPackage(TELEPHONY_SERVICE_PACKAGE);
-        if (Flags.hsumBroadcast()) {
-            context.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } else {
-            context.sendBroadcast(intent);
-        }
+        context.sendBroadcastAsUser(intent, UserHandle.ALL);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index 569a9c364f..56ba4000cc 100644
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -19,6 +19,7 @@ package com.android.internal.telephony.cat;
 import static com.android.internal.telephony.cat.CatCmdMessage.SetupEventListConstants.IDLE_SCREEN_AVAILABLE_EVENT;
 import static com.android.internal.telephony.cat.CatCmdMessage.SetupEventListConstants.LANGUAGE_SELECTION_EVENT;
 import static com.android.internal.telephony.cat.CatCmdMessage.SetupEventListConstants.USER_ACTIVITY_EVENT;
+import static com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType.APPTYPE_UNKNOWN;
 
 import android.app.Activity;
 import android.app.ActivityManager;
@@ -52,6 +53,7 @@ import com.android.internal.telephony.ProxyController;
 import com.android.internal.telephony.SmsController;
 import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.flags.FeatureFlagsImpl;
+import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import com.android.internal.telephony.uicc.IccCardStatus.CardState;
 import com.android.internal.telephony.uicc.IccFileHandler;
@@ -218,6 +220,34 @@ public class CatService extends Handler implements AppInterface {
         mContext.registerReceiver(mSmsBroadcastReceiver, new IntentFilter(SMS_SENT_ACTION));
     }
 
+    private static UiccCardApplication getValidUiccApplication(UiccProfile uiccProfile) {
+        UiccCardApplication ca = null;
+        if (uiccProfile != null) {
+            /* Since Cat is not tied to any application, but rather is Uicc application
+             * in itself - just get first FileHandler and IccRecords object
+             */
+            ca = uiccProfile.getApplicationIndex(0);
+
+            /**
+             * Case where the SIMs reporting "UNKNOWN" application type.
+             * If an "UNKNOWN" application is detected, its file handler won't be initialized
+             * correctly.
+             * To avoid issues, always use the file handler from a known, valid SIM application.
+             */
+            if (Flags.catServiceCreationFix() && ca.getType() == APPTYPE_UNKNOWN
+                    && uiccProfile.getNumApplications() > 1) {
+                for (int i = 1; i < uiccProfile.getNumApplications(); i++) {
+                    UiccCardApplication tmpCa = uiccProfile.getApplicationIndex(i);
+                    if (tmpCa.getType() != APPTYPE_UNKNOWN) {
+                        ca = tmpCa;
+                        break;
+                    }
+                }
+            }
+        }
+        return ca;
+    }
+
     /**
      * Used for instantiating the Service from the Card.
      *
@@ -238,15 +268,10 @@ public class CatService extends Handler implements AppInterface {
         UiccCardApplication ca = null;
         IccFileHandler fh = null;
         IccRecords ir = null;
-        if (uiccProfile != null) {
-            /* Since Cat is not tied to any application, but rather is Uicc application
-             * in itself - just get first FileHandler and IccRecords object
-             */
-            ca = uiccProfile.getApplicationIndex(0);
-            if (ca != null) {
-                fh = ca.getIccFileHandler();
-                ir = ca.getIccRecords();
-            }
+        ca = getValidUiccApplication(uiccProfile);
+        if (ca != null) {
+            fh = ca.getIccFileHandler();
+            ir = ca.getIccRecords();
         }
 
         synchronized (sInstanceLock) {
@@ -722,11 +747,7 @@ public class CatService extends Handler implements AppInterface {
         intent.setComponent(AppInterface.getDefaultSTKApplication());
         CatLog.d(this, "Sending CmdMsg: " + cmdMsg+ " on slotid:" + mSlotId);
 
-        if (sFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
-        } else {
-            mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
     }
 
     /**
@@ -740,11 +761,7 @@ public class CatService extends Handler implements AppInterface {
         Intent intent = new Intent(AppInterface.CAT_SESSION_END_ACTION);
         intent.putExtra("SLOT_ID", mSlotId);
         intent.setComponent(AppInterface.getDefaultSTKApplication());
-        if (sFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
-        } else {
-            mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
     }
 
 
@@ -1108,11 +1125,7 @@ public class CatService extends Handler implements AppInterface {
         intent.putExtra("SLOT_ID", mSlotId);
         CatLog.d(this, "Sending Card Status: "
                 + cardState + " " + "cardPresent: " + cardPresent +  "SLOT_ID: " +  mSlotId);
-        if (sFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
-        } else {
-            mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
     }
 
     private void broadcastAlphaMessage(String alphaString) {
@@ -1122,11 +1135,7 @@ public class CatService extends Handler implements AppInterface {
         intent.putExtra(AppInterface.ALPHA_STRING, alphaString);
         intent.putExtra("SLOT_ID", mSlotId);
         intent.setComponent(AppInterface.getDefaultSTKApplication());
-        if (sFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
-        } else {
-            mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, AppInterface.STK_PERMISSION);
     }
 
     @Override
@@ -1318,15 +1327,9 @@ public class CatService extends Handler implements AppInterface {
             Context context, UiccProfile uiccProfile) {
         UiccCardApplication ca = null;
         IccRecords ir = null;
-
-        if (uiccProfile != null) {
-            /* Since Cat is not tied to any application, but rather is Uicc application
-             * in itself - just get first FileHandler and IccRecords object
-             */
-            ca = uiccProfile.getApplicationIndex(0);
-            if (ca != null) {
-                ir = ca.getIccRecords();
-            }
+        ca = getValidUiccApplication(uiccProfile);
+        if (ca != null) {
+            ir = ca.getIccRecords();
         }
 
         synchronized (sInstanceLock) {
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
index 9a853298ba..f9202339d3 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
@@ -332,7 +332,7 @@ public class CdmaInboundSmsHandler extends InboundSmsHandler {
         // update voice mail count in phone
         mPhone.setVoiceMessageCount(voicemailCount);
         // update metrics
-        addVoicemailSmsToMetrics(smsSource);
+        addVoicemailSmsToMetrics(smsSource, getPduLength(sms));
     }
 
     /**
@@ -440,10 +440,10 @@ public class CdmaInboundSmsHandler extends InboundSmsHandler {
     /**
      * Add voicemail indication SMS 0 to metrics.
      */
-    private void addVoicemailSmsToMetrics(@SmsSource int smsSource) {
+    private void addVoicemailSmsToMetrics(@SmsSource int smsSource, int pduLength) {
         mMetrics.writeIncomingVoiceMailSms(mPhone.getPhoneId(),
                 android.telephony.SmsMessage.FORMAT_3GPP2);
-        mPhone.getSmsStats().onIncomingSmsVoicemail(true /* is3gpp2 */, smsSource);
+        mPhone.getSmsStats().onIncomingSmsVoicemail(true /* is3gpp2 */, smsSource, pduLength);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java b/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
index f40b6d6c0a..a17b2e2392 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
@@ -18,6 +18,7 @@ package com.android.internal.telephony.cdma;
 
 import static com.android.internal.telephony.SmsResponse.NO_ERROR_CODE;
 
+import android.annotation.NonNull;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.Build;
 import android.os.Message;
@@ -34,6 +35,7 @@ import com.android.internal.telephony.SmsController;
 import com.android.internal.telephony.SmsDispatchersController;
 import com.android.internal.telephony.SmsHeader;
 import com.android.internal.telephony.SmsMessageBase;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.util.SMSDispatcherUtil;
 import com.android.telephony.Rlog;
 
@@ -41,8 +43,9 @@ public class CdmaSMSDispatcher extends SMSDispatcher {
     private static final String TAG = "CdmaSMSDispatcher";
     private static final boolean VDBG = false;
 
-    public CdmaSMSDispatcher(Phone phone, SmsDispatchersController smsDispatchersController) {
-        super(phone, smsDispatchersController);
+    public CdmaSMSDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
+            @NonNull FeatureFlags featureFlags) {
+        super(phone, smsDispatchersController, featureFlags);
         Rlog.d(TAG, "CdmaSMSDispatcher created");
     }
 
diff --git a/src/java/com/android/internal/telephony/cdnr/CarrierDisplayNameResolver.java b/src/java/com/android/internal/telephony/cdnr/CarrierDisplayNameResolver.java
index 86469816e2..8728ebb9d6 100644
--- a/src/java/com/android/internal/telephony/cdnr/CarrierDisplayNameResolver.java
+++ b/src/java/com/android/internal/telephony/cdnr/CarrierDisplayNameResolver.java
@@ -476,7 +476,14 @@ public class CarrierDisplayNameResolver {
 
     private void resolveCarrierDisplayName() {
         CarrierDisplayNameData data = getCarrierDisplayNameFromEf();
-        if (DBG) Rlog.d(TAG, "CarrierName from EF: " + data);
+        ServiceState ss = getServiceState();
+        int combinedRegState = mPhone.getServiceStateTracker().getCombinedRegState(ss);
+        boolean isWifiCallingEnabled = mPhone.isWifiCallingEnabled();
+        if (DBG) {
+            Rlog.d(TAG, "CarrierName from EF: " + data
+                    + " combinedRegState: " + ServiceState.rilServiceStateToString(combinedRegState)
+                    + " isWifiCallingEnabled: " + isWifiCallingEnabled + ss);
+        }
         if ((mPhone.getImsPhone() != null) && (mPhone.getImsPhone().getImsRegistrationTech()
                 == ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM
                 && mPhone.isImsRegistered())) {
@@ -484,9 +491,8 @@ public class CarrierDisplayNameResolver {
             if (DBG) {
                 Rlog.d(TAG, "CarrierName override by Cross-SIM Calling " + data);
             }
-        } else if (mPhone.getServiceStateTracker().getCombinedRegState(getServiceState())
-                == ServiceState.STATE_IN_SERVICE) {
-            if (mPhone.isWifiCallingEnabled() && mPhone.isImsRegistered()) {
+        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
+            if (isWifiCallingEnabled && mPhone.isImsRegistered()) {
                 data = getCarrierDisplayNameFromWifiCallingOverride(data);
                 if (DBG) {
                     Rlog.d(TAG, "CarrierName override by wifi-calling " + data);
diff --git a/src/java/com/android/internal/telephony/configupdate/ConfigParser.java b/src/java/com/android/internal/telephony/configupdate/ConfigParser.java
index f7691da908..00115cbf54 100644
--- a/src/java/com/android/internal/telephony/configupdate/ConfigParser.java
+++ b/src/java/com/android/internal/telephony/configupdate/ConfigParser.java
@@ -108,4 +108,14 @@ public abstract class ConfigParser<T> {
         mVersion = version;
         Log.d(TAG, "overrideVersion: mVersion=" + mVersion);
     }
+
+    /**
+     * Overrides the config
+     *
+     * @param config the config that should be overrided with
+     */
+    public void overrideConfig(T config) {
+        Log.d(TAG, "overrideConfig: overriding config to " + config);
+        mConfig = config;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiver.java b/src/java/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiver.java
index 8a34ec10cc..b62524d0c3 100644
--- a/src/java/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiver.java
+++ b/src/java/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiver.java
@@ -25,6 +25,7 @@ import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.data.DataUtils;
 import com.android.internal.telephony.satellite.SatelliteConfig;
 import com.android.internal.telephony.satellite.SatelliteConfigParser;
 import com.android.internal.telephony.satellite.SatelliteConstants;
@@ -140,6 +141,37 @@ public class TelephonyConfigUpdateInstallReceiver extends ConfigUpdateInstallRec
         return true;
     }
 
+    /**
+     * Validates if the max allowed datamode is valid
+     *
+     * @param parser target of validation.
+     * @return {@code true} if max allowed datamode is valid, {@code false} otherwise.
+     */
+    public boolean isValidMaxAllowedDataMode(@NonNull ConfigParser parser) {
+        SatelliteConfig satelliteConfig = (SatelliteConfig) parser.getConfig();
+        if (satelliteConfig == null) {
+            Log.e(TAG, "satelliteConfig is null");
+            mConfigUpdaterMetricsStats.reportOemAndCarrierConfigError(
+                    SatelliteConstants.CONFIG_UPDATE_RESULT_NO_SATELLITE_DATA);
+            return false;
+        }
+
+        Integer maxAllowedDataMode = satelliteConfig.getSatelliteMaxAllowedDataMode();
+        if (maxAllowedDataMode == null) {
+            Log.d(TAG, "maxAllowedDataMode is not set");
+            return true;
+        }
+
+        if (!DataUtils.isValidDataMode(maxAllowedDataMode)) {
+            Log.e(TAG, "found invalid maxAllowedDataMode : " + maxAllowedDataMode);
+            mConfigUpdaterMetricsStats.reportCarrierConfigError(
+                    SatelliteConstants
+                            .CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_MAX_ALLOWED_DATA_MODE);
+            return false;
+        }
+        Log.d(TAG, "maxAllowedDataMode is valid");
+        return true;
+    }
 
     @Override
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PROTECTED)
@@ -163,6 +195,11 @@ public class TelephonyConfigUpdateInstallReceiver extends ConfigUpdateInstallRec
             return;
         }
 
+        if (!isValidMaxAllowedDataMode(newConfigParser)) {
+            Log.e(TAG, "received config data has invalid max allowed data mode");
+            return;
+        }
+
         synchronized (getInstance().mConfigParserLock) {
             if (getInstance().mConfigParser != null) {
                 int updatedVersion = newConfigParser.mVersion;
@@ -212,6 +249,18 @@ public class TelephonyConfigUpdateInstallReceiver extends ConfigUpdateInstallRec
         }
     }
 
+    /**
+     * Overrides the config parser. Should be used only in tests.
+     *
+     * @param configParser the config parser that we have to override
+     */
+    public void overrideConfigParser(ConfigParser configParser) {
+        Log.d(TAG, "overrideConfigParser");
+        synchronized (getInstance().mConfigParserLock) {
+            getInstance().mConfigParser = configParser;
+        }
+    }
+
     @Override
     public void registerCallback(@NonNull Executor executor, @NonNull Callback callback) {
         mCallbackHashMap.put(executor, callback);
diff --git a/src/java/com/android/internal/telephony/data/AutoDataSwitchController.java b/src/java/com/android/internal/telephony/data/AutoDataSwitchController.java
index 9c224dcbc5..b2bd506f43 100644
--- a/src/java/com/android/internal/telephony/data/AutoDataSwitchController.java
+++ b/src/java/com/android/internal/telephony/data/AutoDataSwitchController.java
@@ -422,26 +422,104 @@ public class AutoDataSwitchController extends Handler {
      * sub to reduce unnecessary tracking.
      */
     private void onSubscriptionsChanged() {
-        Set<Integer> activePhoneIds = Arrays.stream(mSubscriptionManagerService
-                .getActiveSubIdList(true /*visibleOnly*/))
-                .map(mSubscriptionManagerService::getPhoneId)
-                .boxed()
-                .collect(Collectors.toSet());
-        // Track events only if there are at least two active visible subscriptions.
-        if (activePhoneIds.size() < 2) activePhoneIds.clear();
+        if (sFeatureFlags.autoDataPruneListener()) {
+            boolean changed = updateListenerRegistrations();
+            if (changed) logl("onSubscriptionChanged: " + Arrays.toString(mPhonesSignalStatus));
+        } else {
+            Set<Integer> activePhoneIds = Arrays.stream(mSubscriptionManagerService
+                            .getActiveSubIdList(true /*visibleOnly*/))
+                    .map(mSubscriptionManagerService::getPhoneId)
+                    .boxed()
+                    .collect(Collectors.toSet());
+            // Track events only if there are at least two active visible subscriptions.
+            if (activePhoneIds.size() < 2) activePhoneIds.clear();
+            boolean changed = false;
+            for (int phoneId = 0; phoneId < mPhonesSignalStatus.length; phoneId++) {
+                if (activePhoneIds.contains(phoneId)
+                        && !mPhonesSignalStatus[phoneId].mListeningForEvents) {
+                    registerAllEventsForPhone(phoneId);
+                    changed = true;
+                } else if (!activePhoneIds.contains(phoneId)
+                        && mPhonesSignalStatus[phoneId].mListeningForEvents) {
+                    unregisterAllEventsForPhone(phoneId);
+                    changed = true;
+                }
+            }
+            if (changed) logl("onSubscriptionChanged: " + Arrays.toString(mPhonesSignalStatus));
+        }
+    }
+
+    /**
+     * Updates network event listener registrations based on conditions.
+     *
+     * Unregisters listeners for *all* phones if:
+     * 1. <2 active subscriptions (auto-switching requires 2+).
+     * 2. Non-cellular default network (auto-switching not relevant).
+     * 3. Default data disabled (no need to monitor for switching).
+     * 4. No eligible auto-switch candidates (all other phones' data
+     *    disabled, preventing switching).
+     *
+     * Registers listeners if none of the above apply and a phone's
+     * listeners are currently unregistered.
+     *
+     * @return `true` if any registration changed; `false` otherwise.
+     */
+    private boolean updateListenerRegistrations() {
+        if (!sFeatureFlags.autoDataPruneListener()) {
+            return false;
+        }
+        boolean shouldUnregister = false;
+        String reason = "";
+
+        if (mSubscriptionManagerService.getActiveSubIdList(true).length < 2) {
+            shouldUnregister = true;
+            reason = "only have one active subscription";
+        } else if (mDefaultNetworkIsOnNonCellular) {
+            shouldUnregister = true;
+            reason = "default network is on non-cellular network";
+        } else {
+            int defaultDataPhoneId = mSubscriptionManagerService.getPhoneId(
+                    mSubscriptionManagerService.getDefaultDataSubId());
+            Phone defaultDataPhone = PhoneFactory.getPhone(defaultDataPhoneId);
+
+            if (defaultDataPhone != null && !defaultDataPhone.isUserDataEnabled()) {
+                shouldUnregister = true;
+                reason = "default data is disabled";
+            } else {
+                boolean anyCandidateEnabled = false;
+                for (int phoneId = 0; phoneId < mPhonesSignalStatus.length; phoneId++) {
+                    if (phoneId != defaultDataPhoneId) {
+                        Phone phone = PhoneFactory.getPhone(phoneId);
+                        if (phone != null && phone.getDataSettingsManager().isDataEnabled()) {
+                            anyCandidateEnabled = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (!anyCandidateEnabled) {
+                    shouldUnregister = true;
+                    reason = "no candidate enabled auto data switch feature";
+                }
+            }
+        }
+
+        if (shouldUnregister) {
+            log("updateListenerRegistrations: " + reason);
+        }
+
+        // Register or unregister as needed
         boolean changed = false;
         for (int phoneId = 0; phoneId < mPhonesSignalStatus.length; phoneId++) {
-            if (activePhoneIds.contains(phoneId)
-                    && !mPhonesSignalStatus[phoneId].mListeningForEvents) {
-                registerAllEventsForPhone(phoneId);
-                changed = true;
-            } else if (!activePhoneIds.contains(phoneId)
-                    && mPhonesSignalStatus[phoneId].mListeningForEvents) {
+            if (shouldUnregister && mPhonesSignalStatus[phoneId].mListeningForEvents) {
                 unregisterAllEventsForPhone(phoneId);
                 changed = true;
+            } else if (!shouldUnregister && !mPhonesSignalStatus[phoneId].mListeningForEvents) {
+                registerAllEventsForPhone(phoneId);
+                changed = true;
             }
         }
-        if (changed) logl("onSubscriptionChanged: " + Arrays.toString(mPhonesSignalStatus));
+        return changed;
     }
 
     /**
@@ -459,6 +537,7 @@ public class AutoDataSwitchController extends Handler {
             phone.getServiceStateTracker().registerForServiceStateChanged(this,
                     EVENT_SERVICE_STATE_CHANGED, phoneId);
             mPhonesSignalStatus[phoneId].mListeningForEvents = true;
+            log("registerAllEventsForPhone: registered listeners for phone " + phoneId);
         } else {
             loge("Unexpected null phone " + phoneId + " when register all events");
         }
@@ -475,6 +554,7 @@ public class AutoDataSwitchController extends Handler {
             phone.getSignalStrengthController().unregisterForSignalStrengthChanged(this);
             phone.getServiceStateTracker().unregisterForServiceStateChanged(this);
             mPhonesSignalStatus[phoneId].mListeningForEvents = false;
+            log("unregisterAllEventsForPhone: unregistered listeners for phone " + phoneId);
         } else {
             loge("Unexpected out of bound phone " + phoneId + " when unregister all events");
         }
@@ -497,8 +577,7 @@ public class AutoDataSwitchController extends Handler {
                 dataConfig.getAutoDataSwitchAvailabilitySwitchbackStabilityTimeThreshold() >= 0
                         ? dataConfig.getAutoDataSwitchAvailabilitySwitchbackStabilityTimeThreshold()
                         : dataConfig.getAutoDataSwitchAvailabilityStabilityTimeThreshold());
-        mAutoDataSwitchValidationMaxRetry =
-                dataConfig.getAutoDataSwitchValidationMaxRetry();
+        mAutoDataSwitchValidationMaxRetry = dataConfig.getAutoDataSwitchValidationMaxRetry();
     }
 
     @Override
@@ -595,7 +674,7 @@ public class AutoDataSwitchController extends Handler {
             TelephonyDisplayInfo displayInfo = phone.getDisplayInfoController()
                     .getTelephonyDisplayInfo();
             mPhonesSignalStatus[phoneId].mDisplayInfo = displayInfo;
-            if (getHigherScoreCandidatePhoneId() != mSelectedTargetPhoneId) {
+            if (getBetterCandidatePhoneIdBasedOnScore() != mSelectedTargetPhoneId) {
                 log("onDisplayInfoChanged: phone " + phoneId + " " + displayInfo);
                 evaluateAutoDataSwitch(EVALUATION_REASON_DISPLAY_INFO_CHANGED);
             }
@@ -615,7 +694,7 @@ public class AutoDataSwitchController extends Handler {
             SignalStrength oldSignalStrength = mPhonesSignalStatus[phoneId].mSignalStrength;
             if (oldSignalStrength.getLevel() != newSignalStrength.getLevel()) {
                 mPhonesSignalStatus[phoneId].mSignalStrength = newSignalStrength;
-                if (getHigherScoreCandidatePhoneId() != mSelectedTargetPhoneId) {
+                if (getBetterCandidatePhoneIdBasedOnScore() != mSelectedTargetPhoneId) {
                     log("onSignalStrengthChanged: phone " + phoneId + " "
                             + oldSignalStrength.getLevel() + "->" + newSignalStrength.getLevel());
                     evaluateAutoDataSwitch(EVALUATION_REASON_SIGNAL_STRENGTH_CHANGED);
@@ -627,31 +706,45 @@ public class AutoDataSwitchController extends Handler {
     }
 
     /**
-     * Called as a preliminary check for the frequent signal/display info change.
-     * @return The phone Id if found a candidate phone with higher signal score, or the DDS has
-     * an equal score.
+     * Checks for a better data phone candidate based on signal strength.Compares the preferred data
+     * phone and DDS, potentially switching to another active phone with a significantly better
+     * signal or reverting to DDS if the preferred phone isn't significantly better.
+     *
+     * @return A better candidate phone ID, the DDS phone ID,
+     * or {@link android.telephony.SubscriptionManager#INVALID_PHONE_INDEX}.
      */
-    private int getHigherScoreCandidatePhoneId() {
+    private int getBetterCandidatePhoneIdBasedOnScore() {
         int preferredPhoneId = mPhoneSwitcher.getPreferredDataPhoneId();
         int ddsPhoneId = mSubscriptionManagerService.getPhoneId(
                 mSubscriptionManagerService.getDefaultDataSubId());
-        if (isActiveModemPhone(preferredPhoneId) && isActiveModemPhone(ddsPhoneId)) {
-            int currentScore = mPhonesSignalStatus[preferredPhoneId].getRatSignalScore();
-            for (int phoneId = 0; phoneId < mPhonesSignalStatus.length; phoneId++) {
-                if (phoneId == preferredPhoneId) continue;
-                PhoneSignalStatus candidateStatus = mPhonesSignalStatus[phoneId];
-                // Ignore non-home phone.
-                if (candidateStatus.getUsableState() != PhoneSignalStatus.UsableState.HOME) {
+
+        if (!isActiveModemPhone(preferredPhoneId) || !isActiveModemPhone(ddsPhoneId)) {
+            return INVALID_PHONE_INDEX;
+        }
+
+        int defaultScore = mPhonesSignalStatus[ddsPhoneId].getRatSignalScore();
+        int preferredScore = mPhonesSignalStatus[preferredPhoneId].getRatSignalScore();
+
+        // Currently on default data subscription
+        if (ddsPhoneId == preferredPhoneId) {
+            // Find any candidate with significantly better score
+            for (int backupId = 0; backupId < mPhonesSignalStatus.length; backupId++) {
+                // Skip current phone and non-home phones
+                if (backupId == preferredPhoneId
+                        || !isHomeService(mPhonesSignalStatus[backupId].mDataRegState)) {
                     continue;
                 }
-                int candidateScore = candidateStatus.getRatSignalScore();
-                if ((candidateScore - currentScore) > mScoreTolerance
-                        // Also reevaluate if DDS has the same score as the current phone.
-                        || (candidateScore >= currentScore && phoneId == ddsPhoneId)) {
-                    return phoneId;
+
+                int candidateScore = mPhonesSignalStatus[backupId].getRatSignalScore();
+                if (candidateScore - defaultScore > mScoreTolerance) {
+                    return backupId;
                 }
             }
+        } else if (preferredScore - defaultScore <= mScoreTolerance) { // Currently on backup
+            // Switch back to dds if preferred isn't significantly better
+            return ddsPhoneId;
         }
+
         return INVALID_PHONE_INDEX;
     }
 
@@ -664,7 +757,14 @@ public class AutoDataSwitchController extends Handler {
                 ? STABILITY_CHECK_TIMER_MAP.get(STABILITY_CHECK_AVAILABILITY_SWITCH)
                 << mAutoSwitchValidationFailedCount
                 : 0;
-        if (!mScheduledEventsToExtras.containsKey(EVENT_EVALUATE_AUTO_SWITCH)) {
+        if (reason == EVALUATION_REASON_DATA_SETTINGS_CHANGED
+                || reason == EVALUATION_REASON_DEFAULT_NETWORK_CHANGED) {
+            // In some conditions, listeners are paused to reduce unnecessary tracking.
+            updateListenerRegistrations();
+            // Always reevaluate with those critical condition change.
+            scheduleEventWithTimer(EVENT_EVALUATE_AUTO_SWITCH, new EvaluateEventExtra(reason),
+                    delayMs);
+        } else if (!mScheduledEventsToExtras.containsKey(EVENT_EVALUATE_AUTO_SWITCH)) {
             scheduleEventWithTimer(EVENT_EVALUATE_AUTO_SWITCH, new EvaluateEventExtra(reason),
                     delayMs);
         }
@@ -776,14 +876,18 @@ public class AutoDataSwitchController extends Handler {
                                     .getRatSignalScore();
                             int currentScore = mPhonesSignalStatus[preferredPhoneId]
                                     .getRatSignalScore();
-                            if (defaultScore >= currentScore) {
+                            if ((currentScore - defaultScore) <= mScoreTolerance) {
                                 debugMessage
-                                        .append(", back to default for higher or equal score ")
+                                        .append(", back to default for score ")
                                         .append(defaultScore).append(" versus current ")
                                         .append(currentScore);
                                 backToDefault = true;
                                 switchType = STABILITY_CHECK_PERFORMANCE_SWITCH;
                                 needValidation = mRequirePingTestBeforeSwitch;
+                            } else {
+                                debugMessage.append(", default's score ").append(defaultScore)
+                                        .append(" doesn't justify the switch given the current ")
+                                        .append(currentScore);
                             }
                         } else {
                             // Only OOS/in service switch is enabled, switch back.
@@ -800,8 +904,8 @@ public class AutoDataSwitchController extends Handler {
                 }
             }
 
+            log(debugMessage.toString());
             if (backToDefault) {
-                log(debugMessage.toString());
                 mSelectedTargetPhoneId = defaultDataPhoneId;
                 startStabilityCheck(DEFAULT_PHONE_INDEX, switchType, needValidation);
             } else {
@@ -922,8 +1026,7 @@ public class AutoDataSwitchController extends Handler {
      */
     private boolean isRatSignalStrengthBasedSwitchEnabled() {
         return mScoreTolerance >= 0
-                && STABILITY_CHECK_TIMER_MAP.get(STABILITY_CHECK_PERFORMANCE_SWITCH) >= 0
-                && sFeatureFlags.autoDataSwitchEnhanced();
+                && STABILITY_CHECK_TIMER_MAP.get(STABILITY_CHECK_PERFORMANCE_SWITCH) >= 0;
     }
 
     /**
@@ -1085,7 +1188,7 @@ public class AutoDataSwitchController extends Handler {
         int subId = subInfo.getSubscriptionId();
         logl("displayAutoDataSwitchNotification: display for subId=" + subId);
         // "Mobile network settings" screen / dialog
-        Intent intent = new Intent(Settings.ACTION_NETWORK_OPERATOR_SETTINGS);
+        Intent intent = new Intent(Settings.ACTION_MANAGE_ALL_SIM_PROFILES_SETTINGS);
         final Bundle fragmentArgs = new Bundle();
         // Special contract for Settings to highlight permission row
         fragmentArgs.putString(SETTINGS_EXTRA_FRAGMENT_ARG_KEY, AUTO_DATA_SWITCH_SETTING_R_ID);
diff --git a/src/java/com/android/internal/telephony/data/CellularDataService.java b/src/java/com/android/internal/telephony/data/CellularDataService.java
index a75d4df460..fbdc1cfdbf 100644
--- a/src/java/com/android/internal/telephony/data/CellularDataService.java
+++ b/src/java/com/android/internal/telephony/data/CellularDataService.java
@@ -18,6 +18,7 @@ package com.android.internal.telephony.data;
 
 import static android.telephony.data.DataServiceCallback.RESULT_SUCCESS;
 
+import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.net.LinkProperties;
@@ -25,6 +26,9 @@ import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.telephony.AccessNetworkConstants.RadioAccessNetworkType;
+import android.telephony.AccessNetworkConstants.TransportType;
+import android.telephony.Annotation.DataState;
 import android.telephony.SubscriptionManager;
 import android.telephony.data.DataCallResponse;
 import android.telephony.data.DataProfile;
@@ -43,6 +47,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.Executor;
+import java.util.function.Consumer;
 
 /**
  * This class represents cellular data service which handles telephony data requests and response
@@ -62,11 +68,26 @@ public class CellularDataService extends DataService {
     private static final int START_HANDOVER                         = 7;
     private static final int CANCEL_HANDOVER                        = 8;
     private static final int APN_UNTHROTTLED                        = 9;
+    private static final int SET_USER_DATA_ENABLED_COMPLETED        = 10;
+    private static final int SET_USER_DATA_ROAMING_ENABLED_COMPLETED = 11;
+    private static final int NOTIFY_IMS_DATA_NETWORK_COMPLETED        = 12;
 
     @SuppressWarnings("unchecked")
     private class CellularDataServiceProvider extends DataService.DataServiceProvider {
+        /**
+         * Pair of the {@link Executor} and {@link Consumer} of the request response result code.
+         * @param executor the callback executor for the response.
+         * @param callback listener for the {@link DataServiceCallback.ResultCode}.
+         */
+        private record ResultCodeCallback(Executor executor,
+                @DataServiceCallback.ResultCode Consumer<Integer> callback) {
+            private void accept(@DataServiceCallback.ResultCode int resultCode) {
+                executor.execute(() -> callback.accept(resultCode));
+            }
+        }
 
         private final Map<Message, DataServiceCallback> mCallbackMap = new HashMap<>();
+        private final Map<Message, ResultCodeCallback> mResultCodeCallbackMap = new HashMap<>();
 
         private final Handler mHandler;
 
@@ -82,6 +103,7 @@ public class CellularDataService extends DataService {
                 @Override
                 public void handleMessage(@NonNull Message message) {
                     DataServiceCallback callback = mCallbackMap.remove(message);
+                    ResultCodeCallback resultCodeCallback = mResultCodeCallbackMap.remove(message);
 
                     AsyncResult ar = (AsyncResult) message.obj;
                     switch (message.what) {
@@ -132,6 +154,15 @@ public class CellularDataService extends DataService {
                                 notifyApnUnthrottled((String) ar.result);
                             }
                             break;
+                        case SET_USER_DATA_ENABLED_COMPLETED:
+                            resultCodeCallback.accept(toResultCode(ar.exception));
+                            break;
+                        case SET_USER_DATA_ROAMING_ENABLED_COMPLETED:
+                            resultCodeCallback.accept(toResultCode(ar.exception));
+                            break;
+                        case NOTIFY_IMS_DATA_NETWORK_COMPLETED:
+                            resultCodeCallback.accept(toResultCode(ar.exception));
+                            break;
                         default:
                             loge("Unexpected event: " + message.what);
                     }
@@ -274,6 +305,47 @@ public class CellularDataService extends DataService {
             mPhone.mCi.cancelHandover(message, cid);
         }
 
+        @Override
+        public void notifyUserDataEnabled(boolean enabled,
+                @NonNull @CallbackExecutor Executor executor,
+                @NonNull @DataServiceCallback.ResultCode Consumer<Integer> resultCodeCallback) {
+            Objects.requireNonNull(executor, "executor cannot be null");
+            Objects.requireNonNull(resultCodeCallback, "resultCodeCallback cannot be null");
+            if (DBG) log("notifyUserDataEnabled " + getSlotIndex());
+            Message message = Message.obtain(mHandler, SET_USER_DATA_ENABLED_COMPLETED);
+            mResultCodeCallbackMap.put(message,
+                    new ResultCodeCallback(executor, resultCodeCallback));
+            mPhone.mCi.setUserDataEnabled(message, enabled);
+        }
+
+        @Override
+        public void notifyUserDataRoamingEnabled(boolean enabled,
+                @NonNull @CallbackExecutor Executor executor,
+                @NonNull @DataServiceCallback.ResultCode Consumer<Integer> resultCodeCallback) {
+            Objects.requireNonNull(executor, "executor cannot be null");
+            Objects.requireNonNull(resultCodeCallback, "resultCodeCallback cannot be null");
+            if (DBG) log("notifyUserDataRoamingEnabled " + getSlotIndex());
+            Message message = Message.obtain(mHandler, SET_USER_DATA_ROAMING_ENABLED_COMPLETED);
+            mResultCodeCallbackMap.put(message,
+                    new ResultCodeCallback(executor, resultCodeCallback));
+            mPhone.mCi.setUserDataRoamingEnabled(message, enabled);
+        }
+
+        @Override
+        public void notifyImsDataNetwork(@RadioAccessNetworkType int accessNetwork,
+                @DataState int dataNetworkState, @TransportType int physicalTransportType,
+                int physicalNetworkSlotIndex, @NonNull @CallbackExecutor Executor executor,
+                @NonNull @DataServiceCallback.ResultCode Consumer<Integer> resultCodeCallback) {
+            Objects.requireNonNull(executor, "executor cannot be null");
+            Objects.requireNonNull(resultCodeCallback, "resultCodeCallback cannot be null");
+            if (DBG) log("notifyImsDataNetwork " + getSlotIndex());
+            Message message = Message.obtain(mHandler, NOTIFY_IMS_DATA_NETWORK_COMPLETED);
+            mResultCodeCallbackMap.put(message,
+                    new ResultCodeCallback(executor, resultCodeCallback));
+            mPhone.mCi.notifyImsDataNetwork(accessNetwork, dataNetworkState, physicalTransportType,
+                    physicalNetworkSlotIndex, message);
+        }
+
         @Override
         public void close() {
             mPhone.mCi.unregisterForDataCallListChanged(mHandler);
diff --git a/src/java/com/android/internal/telephony/data/DataNetwork.java b/src/java/com/android/internal/telephony/data/DataNetwork.java
index d8e6f6afef..9b68a65d15 100644
--- a/src/java/com/android/internal/telephony/data/DataNetwork.java
+++ b/src/java/com/android/internal/telephony/data/DataNetwork.java
@@ -47,6 +47,7 @@ import android.os.SystemClock;
 import android.provider.Telephony;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.AccessNetworkConstants.AccessNetworkType;
+import android.telephony.AccessNetworkConstants.RadioAccessNetworkType;
 import android.telephony.AccessNetworkConstants.TransportType;
 import android.telephony.Annotation.DataFailureCause;
 import android.telephony.Annotation.DataState;
@@ -313,6 +314,7 @@ public class DataNetwork extends StateMachine {
                     TEAR_DOWN_REASON_PREFERRED_DATA_SWITCHED,
                     TEAR_DOWN_REASON_DATA_LIMIT_REACHED,
                     TEAR_DOWN_REASON_DATA_NETWORK_TRANSPORT_NOT_ALLOWED,
+                    TEAR_DOWN_REASON_DEVICE_SHUT_DOWN,
             })
     public @interface TearDownReason {}
 
@@ -415,6 +417,9 @@ public class DataNetwork extends StateMachine {
     /** Data network tear down due to current data network transport mismatch. */
     public static final int TEAR_DOWN_REASON_DATA_NETWORK_TRANSPORT_NOT_ALLOWED = 32;
 
+    /** Data network tear down due to device shut down. */
+    public static final int TEAR_DOWN_REASON_DEVICE_SHUT_DOWN = 33;
+
     //********************************************************************************************//
     // WHENEVER ADD A NEW TEAR DOWN REASON, PLEASE UPDATE DataDeactivateReasonEnum in enums.proto //
     //********************************************************************************************//
@@ -580,6 +585,17 @@ public class DataNetwork extends StateMachine {
     /** PDU session id. */
     private int mPduSessionId = DataCallResponse.PDU_SESSION_ID_NOT_SET;
 
+    /** Physical network transport type. */
+    @TransportType
+    private int mPhysicalNetworkTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
+
+    /** Physical network slot index. */
+    private int mPhysicalNetworkSlotIndex = SubscriptionManager.INVALID_SIM_SLOT_INDEX;
+
+    /** Last notified access network. */
+    @RadioAccessNetworkType
+    private int mLastNotifiedAccessNetwork = AccessNetworkType.UNKNOWN;
+
     /**
      * Data service managers for accessing {@link AccessNetworkConstants#TRANSPORT_TYPE_WWAN} and
      * {@link AccessNetworkConstants#TRANSPORT_TYPE_WLAN} data services.
@@ -1070,6 +1086,10 @@ public class DataNetwork extends StateMachine {
             mTrafficDescriptors.add(dataProfile.getTrafficDescriptor());
         }
         mTransport = transport;
+        mPhysicalNetworkTransportType = transport;
+        if (mPhysicalNetworkTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
+            mPhysicalNetworkSlotIndex = mPhone.getPhoneId();
+        }
         mLastKnownDataNetworkType = getDataNetworkType();
         mLastKnownRoamingState = mPhone.getServiceState().getDataRoamingFromRegistration();
         mIsSatellite = mPhone.getServiceState().isUsingNonTerrestrialNetwork()
@@ -1383,6 +1403,11 @@ public class DataNetwork extends StateMachine {
                     }
                     updateSuspendState();
                     updateNetworkCapabilities();
+                    int accessNetwork = DataUtils.networkTypeToAccessNetworkType(networkType);
+                    if (accessNetwork != AccessNetworkType.UNKNOWN
+                            && (mLastNotifiedAccessNetwork != accessNetwork)) {
+                        notifyImsDataNetwork();
+                    }
                     break;
                 }
                 case EVENT_ATTACH_NETWORK_REQUEST: {
@@ -1513,6 +1538,7 @@ public class DataNetwork extends StateMachine {
                     .getCarrierServicePackageUid();
 
             notifyPreciseDataConnectionState();
+            notifyImsDataNetwork();
             if (mTransport == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
                 // Defer setupData until we get the PDU session ID response
                 allocatePduSessionId();
@@ -1752,6 +1778,7 @@ public class DataNetwork extends StateMachine {
             mDataNetworkCallback.invokeFromExecutor(
                     () -> mDataNetworkCallback.onLinkStatusChanged(DataNetwork.this, mLinkStatus));
             notifyPreciseDataConnectionState();
+            notifyImsDataNetwork();
             updateSuspendState();
         }
 
@@ -1949,6 +1976,7 @@ public class DataNetwork extends StateMachine {
             sendMessageDelayed(EVENT_STUCK_IN_TRANSIENT_STATE,
                     mDataConfigManager.getAnomalyNetworkDisconnectingTimeoutMs());
             notifyPreciseDataConnectionState();
+            notifyImsDataNetwork();
         }
 
         @Override
@@ -2048,6 +2076,7 @@ public class DataNetwork extends StateMachine {
                                 requestList, mFailCause, mRetryDelayMillis));
             }
             notifyPreciseDataConnectionState();
+            notifyImsDataNetwork();
             mNetworkAgent.unregister();
             mDataNetworkController.unregisterDataNetworkControllerCallback(
                     mDataNetworkControllerCallback);
@@ -2340,6 +2369,11 @@ public class DataNetwork extends StateMachine {
         // will always be registered with NOT_SUSPENDED capability.
         mNetworkAgent = createNetworkAgent();
         mNetworkAgent.markConnected();
+        // Update NetworkAgent in QosCallbackTracker so that QoS callbacks on the new network agent
+        // properly reach to the callback tracker.
+        if (mFlags.qosUpdateNetworkAgent() && mQosCallbackTracker != null) {
+            mQosCallbackTracker.updateNetworkAgent(mNetworkAgent);
+        }
         notifyPreciseDataConnectionState();
         // Because network agent is always created with NOT_SUSPENDED, we need to update
         // the suspended if it's was in suspended state.
@@ -2365,6 +2399,7 @@ public class DataNetwork extends StateMachine {
 
         if (mIsSatellite && mDataConfigManager.getForcedCellularTransportCapabilities().stream()
                 .noneMatch(this::hasNetworkCapabilityInNetworkRequests)) {
+            logd("transport satellite is set");
             builder.addTransportType(NetworkCapabilities.TRANSPORT_SATELLITE);
         } else {
             builder.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
@@ -2551,8 +2586,9 @@ public class DataNetwork extends StateMachine {
                 // the MMS capability from this cellular network. This will allow IWLAN to be
                 // brought up for MMS later.
                 if (dataProfile != null && !dataProfile.getApn().equals(mDataProfile.getApn())) {
-                    log("Found a different apn name " + mDataProfile.getApn()
-                            + " that can serve MMS on IWLAN.");
+                    log("Found a different apn name " + dataProfile.getApn()
+                            + " that can serve MMS on IWLAN. Current data profile "
+                            + mDataProfile.getApn());
                     builder.removeCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
                 }
             }
@@ -2883,6 +2919,31 @@ public class DataNetwork extends StateMachine {
             mQosCallbackTracker.updateSessions(mQosBearerSessions);
         }
 
+        if (mFlags.dataServiceNotifyImsDataNetwork()) {
+            // If physical network transport type is
+            // {@link AccessNetworkConstants#TRANSPORT_TYPE_INVALID} use the transport type of
+            // this data network by default.
+            int newPhysicalNetworkTransportType = response.getPhysicalNetworkTransportType()
+                    == AccessNetworkConstants.TRANSPORT_TYPE_INVALID
+                    ? mTransport : response.getPhysicalNetworkTransportType();
+
+            int newPhysicalNetworkSlotIndex = response.getPhysicalNetworkSlotIndex();
+            if (newPhysicalNetworkTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                    && newPhysicalNetworkSlotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
+                // If physical network transport type is
+                // {@link AccessNetworkConstants#TRANSPORT_TYPE_WWAN} and physical network slot id
+                // is {@link SubscriptionManager#INVALID_SIM_SLOT_INDEX}, use the phone id of
+                // this data network by default.
+                newPhysicalNetworkSlotIndex = mPhone.getPhoneId();
+            }
+            if (mPhysicalNetworkTransportType != newPhysicalNetworkTransportType
+                    || (mPhysicalNetworkSlotIndex != newPhysicalNetworkSlotIndex)) {
+                mPhysicalNetworkTransportType = newPhysicalNetworkTransportType;
+                mPhysicalNetworkSlotIndex = newPhysicalNetworkSlotIndex;
+                notifyImsDataNetwork();
+            }
+        }
+
         if (!linkProperties.equals(mLinkProperties)) {
             // If the new link properties is not compatible (e.g. IP changes, interface changes),
             // then we should de-register the network agent and re-create a new one.
@@ -3593,6 +3654,40 @@ public class DataNetwork extends StateMachine {
         }
     }
 
+    /**
+     * Send the IMS data network to the data service.
+     *
+     * <p>
+     * Note that notify only when {@link DataState} or {@link RadioAccessNetworkType} or
+     * mPhysicalNetworkTransportType or mPhysicalNetworkSlotIndex changes. Also, no notification
+     * when data state is {@link TelephonyManager#DATA_HANDOVER_IN_PROGRESS} or
+     * {@link TelephonyManager#DATA_SUSPENDED} or {@link TelephonyManager#DATA_UNKNOWN} since
+     * {@link android.hardware.radio.data.DataNetworkState} does not support these states.
+     */
+    private void notifyImsDataNetwork() {
+        if (!mFlags.dataServiceNotifyImsDataNetwork() || !mNetworkCapabilities.hasCapability(
+                NetworkCapabilities.NET_CAPABILITY_IMS)) {
+            return;
+        }
+        int dataState = getState();
+        if (dataState == TelephonyManager.DATA_HANDOVER_IN_PROGRESS
+                || (dataState == TelephonyManager.DATA_SUSPENDED)
+                || (dataState == TelephonyManager.DATA_UNKNOWN)) {
+            return;
+        }
+        int dataNetwork = getDataNetworkType();
+        if (dataNetwork == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
+            dataNetwork = getLastKnownDataNetworkType();
+        }
+        int accessNetwork = DataUtils.networkTypeToAccessNetworkType(dataNetwork);
+        for (int transport : mAccessNetworksManager.getAvailableTransports()) {
+            mDataServiceManagers.get(transport).notifyImsDataNetwork(
+                    accessNetwork, dataState, mPhysicalNetworkTransportType,
+                    mPhysicalNetworkSlotIndex, null);
+        }
+        mLastNotifiedAccessNetwork = accessNetwork;
+    }
+
     /**
      * Request the data network to handover to the target transport.
      * <p>
@@ -3945,44 +4040,43 @@ public class DataNetwork extends StateMachine {
             case TEAR_DOWN_REASON_SIM_REMOVAL -> "SIM_REMOVAL";
             case TEAR_DOWN_REASON_AIRPLANE_MODE_ON -> "AIRPLANE_MODE_ON";
             case TEAR_DOWN_REASON_DATA_DISABLED -> "DATA_DISABLED";
-            case TEAR_DOWN_REASON_NO_LIVE_REQUEST -> "TEAR_DOWN_REASON_NO_LIVE_REQUEST";
-            case TEAR_DOWN_REASON_RAT_NOT_ALLOWED -> "TEAR_DOWN_REASON_RAT_NOT_ALLOWED";
-            case TEAR_DOWN_REASON_ROAMING_DISABLED -> "TEAR_DOWN_REASON_ROAMING_DISABLED";
+            case TEAR_DOWN_REASON_NO_LIVE_REQUEST -> "NO_LIVE_REQUEST";
+            case TEAR_DOWN_REASON_RAT_NOT_ALLOWED -> "RAT_NOT_ALLOWED";
+            case TEAR_DOWN_REASON_ROAMING_DISABLED -> "ROAMING_DISABLED";
             case TEAR_DOWN_REASON_CONCURRENT_VOICE_DATA_NOT_ALLOWED ->
-                    "TEAR_DOWN_REASON_CONCURRENT_VOICE_DATA_NOT_ALLOWED";
+                    "CONCURRENT_VOICE_DATA_NOT_ALLOWED";
             case TEAR_DOWN_REASON_SERVICE_OPTION_NOT_SUPPORTED ->
-                    "TEAR_DOWN_REASON_SERVICE_OPTION_NOT_SUPPORTED";
+                    "SERVICE_OPTION_NOT_SUPPORTED";
             case TEAR_DOWN_REASON_DATA_SERVICE_NOT_READY ->
-                    "TEAR_DOWN_REASON_DATA_SERVICE_NOT_READY";
-            case TEAR_DOWN_REASON_POWER_OFF_BY_CARRIER -> "TEAR_DOWN_REASON_POWER_OFF_BY_CARRIER";
-            case TEAR_DOWN_REASON_DATA_STALL -> "TEAR_DOWN_REASON_DATA_STALL";
-            case TEAR_DOWN_REASON_HANDOVER_FAILED -> "TEAR_DOWN_REASON_HANDOVER_FAILED";
-            case TEAR_DOWN_REASON_HANDOVER_NOT_ALLOWED -> "TEAR_DOWN_REASON_HANDOVER_NOT_ALLOWED";
-            case TEAR_DOWN_REASON_VCN_REQUESTED -> "TEAR_DOWN_REASON_VCN_REQUESTED";
-            case TEAR_DOWN_REASON_VOPS_NOT_SUPPORTED -> "TEAR_DOWN_REASON_VOPS_NOT_SUPPORTED";
-            case TEAR_DOWN_REASON_DEFAULT_DATA_UNSELECTED ->
-                    "TEAR_DOWN_REASON_DEFAULT_DATA_UNSELECTED";
-            case TEAR_DOWN_REASON_NOT_IN_SERVICE -> "TEAR_DOWN_REASON_NOT_IN_SERVICE";
-            case TEAR_DOWN_REASON_DATA_CONFIG_NOT_READY -> "TEAR_DOWN_REASON_DATA_CONFIG_NOT_READY";
-            case TEAR_DOWN_REASON_PENDING_TEAR_DOWN_ALL -> "TEAR_DOWN_REASON_PENDING_TEAR_DOWN_ALL";
-            case TEAR_DOWN_REASON_NO_SUITABLE_DATA_PROFILE ->
-                    "TEAR_DOWN_REASON_NO_SUITABLE_DATA_PROFILE";
-            case TEAR_DOWN_REASON_CDMA_EMERGENCY_CALLBACK_MODE ->
-                    "TEAR_DOWN_REASON_CDMA_EMERGENCY_CALLBACK_MODE";
-            case TEAR_DOWN_REASON_RETRY_SCHEDULED -> "TEAR_DOWN_REASON_RETRY_SCHEDULED";
-            case TEAR_DOWN_REASON_DATA_THROTTLED -> "TEAR_DOWN_REASON_DATA_THROTTLED";
-            case TEAR_DOWN_REASON_DATA_PROFILE_INVALID -> "TEAR_DOWN_REASON_DATA_PROFILE_INVALID";
+                    "DATA_SERVICE_NOT_READY";
+            case TEAR_DOWN_REASON_POWER_OFF_BY_CARRIER -> "POWER_OFF_BY_CARRIER";
+            case TEAR_DOWN_REASON_DATA_STALL -> "DATA_STALL";
+            case TEAR_DOWN_REASON_HANDOVER_FAILED -> "HANDOVER_FAILED";
+            case TEAR_DOWN_REASON_HANDOVER_NOT_ALLOWED -> "HANDOVER_NOT_ALLOWED";
+            case TEAR_DOWN_REASON_VCN_REQUESTED -> "VCN_REQUESTED";
+            case TEAR_DOWN_REASON_VOPS_NOT_SUPPORTED -> "VOPS_NOT_SUPPORTED";
+            case TEAR_DOWN_REASON_DEFAULT_DATA_UNSELECTED -> "DEFAULT_DATA_UNSELECTED";
+            case TEAR_DOWN_REASON_NOT_IN_SERVICE -> "NOT_IN_SERVICE";
+            case TEAR_DOWN_REASON_DATA_CONFIG_NOT_READY -> "DATA_CONFIG_NOT_READY";
+            case TEAR_DOWN_REASON_PENDING_TEAR_DOWN_ALL -> "PENDING_TEAR_DOWN_ALL";
+            case TEAR_DOWN_REASON_NO_SUITABLE_DATA_PROFILE -> "NO_SUITABLE_DATA_PROFILE";
+            case TEAR_DOWN_REASON_CDMA_EMERGENCY_CALLBACK_MODE -> "CDMA_EMERGENCY_CALLBACK_MODE";
+            case TEAR_DOWN_REASON_RETRY_SCHEDULED -> "RETRY_SCHEDULED";
+            case TEAR_DOWN_REASON_DATA_THROTTLED -> "DATA_THROTTLED";
+            case TEAR_DOWN_REASON_DATA_PROFILE_INVALID -> "DATA_PROFILE_INVALID";
             case TEAR_DOWN_REASON_DATA_PROFILE_NOT_PREFERRED ->
-                    "TEAR_DOWN_REASON_DATA_PROFILE_NOT_PREFERRED";
-            case TEAR_DOWN_REASON_NOT_ALLOWED_BY_POLICY -> "TEAR_DOWN_REASON_NOT_ALLOWED_BY_POLICY";
-            case TEAR_DOWN_REASON_ILLEGAL_STATE -> "TEAR_DOWN_REASON_ILLEGAL_STATE";
+                    "DATA_PROFILE_NOT_PREFERRED";
+            case TEAR_DOWN_REASON_NOT_ALLOWED_BY_POLICY -> "NOT_ALLOWED_BY_POLICY";
+            case TEAR_DOWN_REASON_ILLEGAL_STATE -> "ILLEGAL_STATE";
             case TEAR_DOWN_REASON_ONLY_ALLOWED_SINGLE_NETWORK ->
-                    "TEAR_DOWN_REASON_ONLY_ALLOWED_SINGLE_NETWORK";
+                    "ONLY_ALLOWED_SINGLE_NETWORK";
             case TEAR_DOWN_REASON_PREFERRED_DATA_SWITCHED ->
-                    "TEAR_DOWN_REASON_PREFERRED_DATA_SWITCHED";
-            case TEAR_DOWN_REASON_DATA_LIMIT_REACHED -> "TEAR_DOWN_REASON_DATA_LIMIT_REACHED";
+                    "PREFERRED_DATA_SWITCHED";
+            case TEAR_DOWN_REASON_DATA_LIMIT_REACHED -> "DATA_LIMIT_REACHED";
             case TEAR_DOWN_REASON_DATA_NETWORK_TRANSPORT_NOT_ALLOWED ->
-                    "TEAR_DOWN_REASON_DATA_NETWORK_TRANSPORT_NOT_ALLOWED";
+                    "TRANSPORT_NOT_ALLOWED";
+            case TEAR_DOWN_REASON_DEVICE_SHUT_DOWN ->
+                    "DEVICE_SHUT_DOWN";
             default -> "UNKNOWN(" + reason + ")";
         };
     }
diff --git a/src/java/com/android/internal/telephony/data/DataNetworkController.java b/src/java/com/android/internal/telephony/data/DataNetworkController.java
index 6b916f2c7a..240e79c3a1 100644
--- a/src/java/com/android/internal/telephony/data/DataNetworkController.java
+++ b/src/java/com/android/internal/telephony/data/DataNetworkController.java
@@ -87,6 +87,7 @@ import android.util.IndentingPrintWriter;
 import android.util.LocalLog;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+import android.util.SparseIntArray;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.Phone;
@@ -333,6 +334,8 @@ public class DataNetworkController extends Handler {
 
     /** {@code true} indicating at least one data network exists. */
     private boolean mAnyDataNetworkExisting;
+    /** {@code true} indicating at least one cellular data network exists. */
+    private boolean mAnyCellularDataNetworkExisting;
 
     /**
      * Contain the last 10 data networks that were connected. This is for debugging purposes only.
@@ -396,9 +399,12 @@ public class DataNetworkController extends Handler {
     @NonNull
     private final SparseArray<ImsStateCallback> mImsStateCallbacks = new SparseArray<>();
 
-    /** Registered IMS features. Unregistered IMS features are removed from the set. */
-    @NonNull
-    private final Set<Integer> mRegisteredImsFeatures = new ArraySet<>();
+
+    /**
+     * The transport on which IMS features are registered. Key is the IMS feature, value is the
+     * transport. Unregistered IMS features are removed from the set.
+     */
+    private final @NonNull SparseIntArray mRegisteredImsFeaturesTransport = new SparseIntArray(2);
 
     /** IMS feature package names. Key is the IMS feature, value is the package name. */
     @NonNull
@@ -666,7 +672,8 @@ public class DataNetworkController extends Handler {
          * existing regardless of its state. {@code false} indicating all data networks are
          * disconnected.
          */
-        public void onAnyDataNetworkExistingChanged(boolean anyDataExisting) {}
+        public void onAnyDataNetworkExistingChanged(boolean anyDataExisting,
+                boolean anyCellularDataExisting) {}
 
         /**
          * Called when {@link SubscriptionPlan}s change or an unmetered or congested subscription
@@ -702,6 +709,13 @@ public class DataNetworkController extends Handler {
          * @param qosBearerSessions The latest QOS bearer sessions.
          */
         public void onQosSessionsChanged(@NonNull List<QosBearerSession> qosBearerSessions) {}
+
+        /**
+         * Called when the SIM state changed.
+         *
+         * @param simState The SIM state.
+         */
+        public void onSimStateChanged(@SimState int simState) {}
     }
 
     /**
@@ -905,7 +919,8 @@ public class DataNetworkController extends Handler {
 
         mAccessNetworksManager = phone.getAccessNetworksManager();
         for (int transport : mAccessNetworksManager.getAvailableTransports()) {
-            mDataServiceManagers.put(transport, new DataServiceManager(mPhone, looper, transport));
+            mDataServiceManagers.put(transport,
+                    new DataServiceManager(mPhone, looper, transport, featureFlags));
         }
 
         mDataConfigManager = new DataConfigManager(mPhone, looper, featureFlags);
@@ -927,7 +942,7 @@ public class DataNetworkController extends Handler {
 
         mDataSettingsManager = TelephonyComponentFactory.getInstance().inject(
                 DataSettingsManager.class.getName())
-                .makeDataSettingsManager(mPhone, this, mFeatureFlags, looper,
+                .makeDataSettingsManager(mPhone, this, mDataServiceManagers, mFeatureFlags, looper,
                         new DataSettingsManagerCallback(this::post) {
                             @Override
                             public void onDataEnabledChanged(boolean enabled,
@@ -1211,10 +1226,18 @@ public class DataNetworkController extends Handler {
             case EVENT_REGISTER_DATA_NETWORK_CONTROLLER_CALLBACK:
                 DataNetworkControllerCallback callback = (DataNetworkControllerCallback) msg.obj;
                 mDataNetworkControllerCallbacks.add(callback);
-                // Notify upon registering if no data networks currently exist.
-                if (mDataNetworkList.isEmpty()) {
-                    callback.invokeFromExecutor(
-                            () -> callback.onAnyDataNetworkExistingChanged(false));
+                if (mFeatureFlags.keepWfcOnApm()) {
+                    // Notify upon registering if no data networks currently exist.
+                    if (!mAnyDataNetworkExisting || !mAnyCellularDataNetworkExisting) {
+                        callback.onAnyDataNetworkExistingChanged(mAnyDataNetworkExisting,
+                                mAnyCellularDataNetworkExisting);
+                    }
+                } else {
+                    // Notify upon registering if no data networks currently exist.
+                    if (mDataNetworkList.isEmpty()) {
+                        callback.invokeFromExecutor(
+                                () -> callback.onAnyDataNetworkExistingChanged(false, false));
+                    }
                 }
                 break;
             case EVENT_UNREGISTER_DATA_NETWORK_CONTROLLER_CALLBACK:
@@ -1554,12 +1577,53 @@ public class DataNetworkController extends Handler {
     /**
      * @return {@code true} if all data networks are disconnected.
      */
-    public boolean areAllDataDisconnected() {
-        if (!mDataNetworkList.isEmpty()) {
-            log("areAllDataDisconnected false due to: " + mDataNetworkList.stream()
-                    .map(DataNetwork::name).collect(Collectors.joining(", ")));
+    public boolean areAllDataDisconnected(boolean cellularOnly) {
+        if (mFeatureFlags.keepWfcOnApm() && cellularOnly) {
+            List<DataNetwork> cellularNetworks = getCellularDataNetworks();
+            if (!cellularNetworks.isEmpty()) {
+                log("areAllCellular DataDisconnected false due to: " + cellularNetworks.stream()
+                        .map(DataNetwork::name).collect(Collectors.joining(", ")));
+            }
+            return cellularNetworks.isEmpty();
+        } else {
+            if (!mDataNetworkList.isEmpty()) {
+                log("areAllDataDisconnected false due to: " + mDataNetworkList.stream()
+                        .map(DataNetwork::name).collect(Collectors.joining(", ")));
+            }
+            return mDataNetworkList.isEmpty();
         }
-        return mDataNetworkList.isEmpty();
+    }
+
+    /**
+     * Notify the first cellular sustained data network came into existence, or the last cellular
+     * data network disconnected.
+     * @param anyCellularNetworkExists Whether exists any cellular data networks.
+     */
+    private void updateCellularDataNetworkExistence(boolean anyDataNetworkExisting,
+            boolean anyCellularNetworkExists) {
+        if (anyDataNetworkExisting != mAnyDataNetworkExisting
+                || anyCellularNetworkExists != mAnyCellularDataNetworkExisting) {
+            mAnyDataNetworkExisting = anyDataNetworkExisting;
+            mAnyCellularDataNetworkExisting = anyCellularNetworkExists;
+            mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                    () -> callback.onAnyDataNetworkExistingChanged(mAnyDataNetworkExisting,
+                            mAnyCellularDataNetworkExisting)));
+        }
+    }
+
+
+    /**
+     * @return A list of existing data networks that are/will be sustained by cellular transport.
+     */
+    private @NonNull List<DataNetwork> getCellularDataNetworks() {
+        return mDataNetworkList.stream().filter(dataNetwork ->
+                        // WWAN networks that don't intend to handover.
+                (dataNetwork.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                                && !dataNetwork.isHandoverInProgress())
+                        // WLAN networks that intend to handover.
+                        || (dataNetwork.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
+                        && dataNetwork.isHandoverInProgress()))
+                .toList();
     }
 
     /**
@@ -2087,6 +2151,16 @@ public class DataNetworkController extends Handler {
             }
         }
 
+        // Check if the request is preferred on cellular and radio is/will be turned off.
+        // Using getDesiredPowerState() instead of isRadioOn() because we want to
+        // tear down the network if it was temporarily exempted due to handover.
+        if (mFeatureFlags.keepWfcOnApm()
+                && dataNetwork.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                && (!mPhone.getServiceStateTracker().getDesiredPowerState()
+                || !mPhone.getServiceStateTracker().isRadioOn())) {
+            evaluation.addDataDisallowedReason(DataDisallowedReason.RADIO_POWER_OFF);
+        }
+
         // Check if data is disabled
         boolean dataDisabled = !mDataSettingsManager.isDataEnabled();
 
@@ -2650,14 +2724,15 @@ public class DataNetworkController extends Handler {
                     public void onRegistered(@NonNull ImsRegistrationAttributes attributes) {
                         log("IMS " + DataUtils.imsFeatureToString(imsFeature)
                                 + " registered. Attributes=" + attributes);
-                        mRegisteredImsFeatures.add(imsFeature);
+                        mRegisteredImsFeaturesTransport.put(
+                                imsFeature, attributes.getTransportType());
                     }
 
                     @Override
                     public void onUnregistered(@NonNull ImsReasonInfo info) {
                         log("IMS " + DataUtils.imsFeatureToString(imsFeature)
                                 + " deregistered. Info=" + info);
-                        mRegisteredImsFeatures.remove(imsFeature);
+                        mRegisteredImsFeaturesTransport.delete(imsFeature);
                         evaluatePendingImsDeregDataNetworks();
                     }
                 };
@@ -3033,10 +3108,17 @@ public class DataNetworkController extends Handler {
                     }
                 }
         ));
-        if (!mAnyDataNetworkExisting) {
-            mAnyDataNetworkExisting = true;
-            mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
-                    () -> callback.onAnyDataNetworkExistingChanged(mAnyDataNetworkExisting)));
+        if (mFeatureFlags.keepWfcOnApm()) {
+            updateCellularDataNetworkExistence(true/*any data network*/,
+                    transport == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                            || mAnyCellularDataNetworkExisting/*any cellular network*/);
+        } else {
+            if (!mAnyDataNetworkExisting) {
+                mAnyDataNetworkExisting = true;
+                mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                        () -> callback.onAnyDataNetworkExistingChanged(
+                                mAnyDataNetworkExisting, false)));
+            }
         }
     }
 
@@ -3055,10 +3137,16 @@ public class DataNetworkController extends Handler {
                 + DataFailCause.toString(cause) + ", retryDelayMillis=" + retryDelayMillis + "ms.");
         mDataNetworkList.remove(dataNetwork);
         trackSetupDataCallFailure(dataNetwork.getTransport(), cause);
-        if (mAnyDataNetworkExisting && mDataNetworkList.isEmpty()) {
-            mAnyDataNetworkExisting = false;
-            mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
-                    () -> callback.onAnyDataNetworkExistingChanged(mAnyDataNetworkExisting)));
+        if (mFeatureFlags.keepWfcOnApm()) {
+            updateCellularDataNetworkExistence(!mDataNetworkList.isEmpty(),
+                    !getCellularDataNetworks().isEmpty());
+        } else {
+            if (mAnyDataNetworkExisting && mDataNetworkList.isEmpty()) {
+                mAnyDataNetworkExisting = false;
+                mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                        () -> callback.onAnyDataNetworkExistingChanged(
+                                mAnyDataNetworkExisting, false/*placeholder*/)));
+            }
         }
 
         requestList.removeIf(request -> !mAllNetworkRequestList.contains(request));
@@ -3396,11 +3484,17 @@ public class DataNetworkController extends Handler {
             mImsDataNetworkState = TelephonyManager.DATA_DISCONNECTED;
         }
 
-        if (mAnyDataNetworkExisting && mDataNetworkList.isEmpty()) {
-            log("All data networks disconnected now.");
-            mAnyDataNetworkExisting = false;
-            mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
-                    () -> callback.onAnyDataNetworkExistingChanged(mAnyDataNetworkExisting)));
+        if (mFeatureFlags.keepWfcOnApm()) {
+            updateCellularDataNetworkExistence(!mDataNetworkList.isEmpty(),
+                    !getCellularDataNetworks().isEmpty());
+        } else {
+            if (mAnyDataNetworkExisting && mDataNetworkList.isEmpty()) {
+                log("All data networks disconnected now.");
+                mAnyDataNetworkExisting = false;
+                mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                        () -> callback.onAnyDataNetworkExistingChanged(
+                                mAnyDataNetworkExisting, false/*placeholder*/)));
+            }
         }
 
         // Immediately reestablish on target transport if network was torn down due to policy
@@ -3420,6 +3514,11 @@ public class DataNetworkController extends Handler {
     private void onDataNetworkHandoverSucceeded(@NonNull DataNetwork dataNetwork) {
         logl("Handover successfully. " + dataNetwork + " to " + AccessNetworkConstants
                 .transportTypeToString(dataNetwork.getTransport()));
+        if (mFeatureFlags.keepWfcOnApm()) {
+            updateCellularDataNetworkExistence(mAnyDataNetworkExisting,
+                    dataNetwork.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                            || mAnyCellularDataNetworkExisting);
+        }
         // The preferred transport might be changed when handover was in progress. We need to
         // evaluate again to make sure we are not out-of-sync with the input from access network
         // manager.
@@ -3450,6 +3549,11 @@ public class DataNetworkController extends Handler {
         logl("Handover failed. " + dataNetwork + ", cause=" + DataFailCause.toString(cause)
                 + ", retryDelayMillis=" + retryDelayMillis + "ms, handoverFailureMode="
                 + DataCallResponse.failureModeToString(handoverFailureMode));
+        if (mFeatureFlags.keepWfcOnApm()) {
+            updateCellularDataNetworkExistence(mAnyDataNetworkExisting,
+                    dataNetwork.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
+                            || mAnyCellularDataNetworkExisting);
+        }
         // There might be network we didn't tear down in the last evaluation due to handover in
         // progress. We should evaluate again.
         sendMessage(obtainMessage(EVENT_REEVALUATE_EXISTING_DATA_NETWORKS,
@@ -3591,9 +3695,13 @@ public class DataNetworkController extends Handler {
             mSimState = simState;
             if (simState == TelephonyManager.SIM_STATE_ABSENT) {
                 onSimAbsent();
+                mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                        () -> callback.onSimStateChanged(simState)));
             } else if (simState == TelephonyManager.SIM_STATE_LOADED) {
                 sendMessage(obtainMessage(EVENT_REEVALUATE_UNSATISFIED_NETWORK_REQUESTS,
                         DataEvaluationReason.SIM_LOADED));
+                mDataNetworkControllerCallbacks.forEach(callback -> callback.invokeFromExecutor(
+                        () -> callback.onSimStateChanged(simState)));
             }
         }
     }
@@ -3879,10 +3987,6 @@ public class DataNetworkController extends Handler {
             return false;
         }
 
-        if (areNetworkAvailableServicesChanged(oldPsNri, newPsNri)) {
-            return true;
-        }
-
         if (oldPsNri == null
                 || oldPsNri.getAccessNetworkTechnology() != newPsNri.getAccessNetworkTechnology()
                 || (!oldPsNri.isInService() && newPsNri.isInService())
@@ -3891,6 +3995,10 @@ public class DataNetworkController extends Handler {
             return true;
         }
 
+        if (areNetworkAvailableServicesChanged(oldPsNri, newPsNri)) {
+            return true;
+        }
+
         // If CS connection is back to service on non-DDS, reevaluate for potential PS
         if (!serviceStateAllowsPSAttach(oldSS, transport)
                 && serviceStateAllowsPSAttach(newSS, transport)) {
@@ -4162,7 +4270,11 @@ public class DataNetworkController extends Handler {
             return;
         }
 
-        for (DataNetwork dataNetwork : mDataNetworkList) {
+        // If airplane mode is on, tear down only cellular data networks.
+        List<DataNetwork> dataNetworks = mFeatureFlags.keepWfcOnApm()
+                && reason == DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON
+                ? getCellularDataNetworks() : mDataNetworkList;
+        for (DataNetwork dataNetwork : dataNetworks) {
             if (!dataNetwork.isDisconnecting()) {
                 tearDownGracefully(dataNetwork, reason);
             }
@@ -4204,13 +4316,13 @@ public class DataNetworkController extends Handler {
             return true;
         }
         for (int imsFeature : SUPPORTED_IMS_FEATURES) {
-            String imsFeaturePackage = mImsFeaturePackageName.get(imsFeature);
-            if (imsFeaturePackage != null) {
-                if (dataNetwork.getAttachedNetworkRequestList()
+            int registeredOnTransport = mRegisteredImsFeaturesTransport.get(imsFeature,
+                    AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
+            if (dataNetwork.getTransport() == registeredOnTransport) {
+                String imsFeaturePackage = mImsFeaturePackageName.get(imsFeature);
+                if (imsFeaturePackage != null && dataNetwork.getAttachedNetworkRequestList()
                         .hasNetworkRequestsFromPackage(imsFeaturePackage)) {
-                    if (mRegisteredImsFeatures.contains(imsFeature)) {
-                        return false;
-                    }
+                    return false;
                 }
             }
         }
@@ -4234,13 +4346,19 @@ public class DataNetworkController extends Handler {
     private void tearDownGracefully(@NonNull DataNetwork dataNetwork, @TearDownReason int reason) {
         long deregDelay = mDataConfigManager.getImsDeregistrationDelay();
         if (isImsGracefulTearDownSupported() && !isSafeToTearDown(dataNetwork)) {
+            int mmtelTransport = mRegisteredImsFeaturesTransport.get(ImsFeature.FEATURE_MMTEL,
+                    AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
+            int rcsTransport = mRegisteredImsFeaturesTransport.get(ImsFeature.FEATURE_RCS,
+                    AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
             log("tearDownGracefully: Not safe to tear down " + dataNetwork
                     + " at this point. Wait for IMS de-registration or timeout. MMTEL="
-                    + (mRegisteredImsFeatures.contains(ImsFeature.FEATURE_MMTEL)
-                    ? "registered" : "not registered")
+                    + (mmtelTransport != AccessNetworkConstants.TRANSPORT_TYPE_INVALID
+                    ? "registered on " + AccessNetworkConstants.transportTypeToString(
+                    mmtelTransport) : "not registered")
                     + ", RCS="
-                    + (mRegisteredImsFeatures.contains(ImsFeature.FEATURE_RCS)
-                    ? "registered" : "not registered")
+                    + (rcsTransport != AccessNetworkConstants.TRANSPORT_TYPE_INVALID
+                    ? "registered on " + AccessNetworkConstants.transportTypeToString(
+                    rcsTransport) : "not registered")
             );
             Runnable runnable = dataNetwork.tearDownWhenConditionMet(reason, deregDelay);
             if (runnable != null) {
@@ -4393,15 +4511,22 @@ public class DataNetworkController extends Handler {
         }
         pw.decreaseIndent();
 
+        int mmtelTransport = mRegisteredImsFeaturesTransport.get(ImsFeature.FEATURE_MMTEL,
+                AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
+        int rcsTransport = mRegisteredImsFeaturesTransport.get(ImsFeature.FEATURE_RCS,
+                AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
         pw.println("IMS features registration state: MMTEL="
-                + (mRegisteredImsFeatures.contains(ImsFeature.FEATURE_MMTEL)
-                ? "registered" : "not registered")
+                + (mmtelTransport != AccessNetworkConstants.TRANSPORT_TYPE_INVALID
+                ? "registered on " + AccessNetworkConstants.transportTypeToString(
+                mmtelTransport) : "not registered")
                 + ", RCS="
-                + (mRegisteredImsFeatures.contains(ImsFeature.FEATURE_RCS)
-                ? "registered" : "not registered"));
+                + (rcsTransport != AccessNetworkConstants.TRANSPORT_TYPE_INVALID
+                ? "registered on " + AccessNetworkConstants.transportTypeToString(
+                rcsTransport) : "not registered"));
         pw.println("mServiceState=" + mServiceState);
         pw.println("mPsRestricted=" + mPsRestricted);
         pw.println("mAnyDataNetworkExisting=" + mAnyDataNetworkExisting);
+        pw.println("mAnyCellularDataNetworkExisting=" + mAnyCellularDataNetworkExisting);
         pw.println("mInternetDataNetworkState="
                 + TelephonyUtils.dataStateToString(mInternetDataNetworkState));
         pw.println("mImsDataNetworkState="
diff --git a/src/java/com/android/internal/telephony/data/DataServiceManager.java b/src/java/com/android/internal/telephony/data/DataServiceManager.java
index a71bd102c9..2629bd8652 100644
--- a/src/java/com/android/internal/telephony/data/DataServiceManager.java
+++ b/src/java/com/android/internal/telephony/data/DataServiceManager.java
@@ -40,7 +40,9 @@ import android.os.RemoteException;
 import android.os.UserHandle;
 import android.permission.LegacyPermissionManager;
 import android.telephony.AccessNetworkConstants;
+import android.telephony.AccessNetworkConstants.RadioAccessNetworkType;
 import android.telephony.AccessNetworkConstants.TransportType;
+import android.telephony.Annotation.DataState;
 import android.telephony.AnomalyReporter;
 import android.telephony.CarrierConfigManager;
 import android.telephony.SubscriptionManager;
@@ -57,6 +59,7 @@ import android.text.TextUtils;
 import com.android.internal.telephony.IIntegerConsumer;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConfigurationManager;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.util.TelephonyUtils;
 import com.android.telephony.Rlog;
 
@@ -93,6 +96,8 @@ public class DataServiceManager extends Handler {
 
     private final int mTransportType;
 
+    private final FeatureFlags mFeatureFlags;
+
     private boolean mBound;
 
     private IDataService mIDataService;
@@ -360,12 +365,14 @@ public class DataServiceManager extends Handler {
      * @param phone The phone instance
      * @param looper Looper for the handler
      * @param transportType The transport type
+     * @param featureFlags The feature flags
      */
     public DataServiceManager(@NonNull Phone phone, @NonNull Looper looper,
-            @TransportType int transportType) {
+            @TransportType int transportType, @NonNull FeatureFlags featureFlags) {
         super(looper);
         mPhone = phone;
         mTransportType = transportType;
+        mFeatureFlags = featureFlags;
         mTag = "DSM-" + (mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN ? "C-"
                 : "I-") + mPhone.getPhoneId();
         mBound = false;
@@ -947,6 +954,135 @@ public class DataServiceManager extends Handler {
         }
     }
 
+    /**
+     * Notify {@link DataService} the user data setting.
+     *
+     * @param enabled Whether the user mobile data is enabled.
+     * @param onCompleteMessage The result message for this request. Null if the client does not
+     * care about the result.
+     */
+    public void notifyUserDataEnabled(boolean enabled, Message onCompleteMessage) {
+        if (DBG) log("notifyUserDataEnabled");
+        if (!mFeatureFlags.dataServiceUserDataToggleNotify()) {
+            if (DBG) log("Data service user data toggle notification is not enabled.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+            return;
+        }
+        if (!mBound) {
+            loge("Data service not bound.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+            return;
+        }
+
+        IIntegerConsumer callback = new IIntegerConsumer.Stub() {
+            @Override
+            public void accept(int result) {
+                if (DBG) log("notifyUserDataEnabledComplete. result = " + result);
+                mMessageMap.remove(asBinder());
+                sendCompleteMessage(onCompleteMessage, result);
+            }
+        };
+        if (onCompleteMessage != null) {
+            mMessageMap.put(callback.asBinder(), onCompleteMessage);
+        }
+        try {
+            mIDataService.notifyUserDataEnabled(mPhone.getPhoneId(), enabled, callback);
+        } catch (RemoteException e) {
+            loge("Cannot invoke notifyUserDataEnabled on data service.");
+            mMessageMap.remove(callback.asBinder());
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        }
+    }
+
+    /**
+     * Notify {@link DataService} the user data roaming setting.
+     *
+     * @param enabled Whether the user mobile data roaming is enabled.
+     * @param onCompleteMessage The result message for this request. Null if the client does not
+     * care about the result.
+     */
+    public void notifyUserDataRoamingEnabled(boolean enabled, Message onCompleteMessage) {
+        if (DBG) log("notifyUserDataRoamingEnabled");
+        if (!mFeatureFlags.dataServiceUserDataToggleNotify()) {
+            if (DBG) log("Data service user data toggle notification is not enabled.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+            return;
+        }
+        if (!mBound) {
+            loge("Data service not bound.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+            return;
+        }
+
+        IIntegerConsumer callback = new IIntegerConsumer.Stub() {
+            @Override
+            public void accept(int result) {
+                if (DBG) log("notifyUserDataRoamingEnabledComplete. result = " + result);
+                mMessageMap.remove(asBinder());
+                sendCompleteMessage(onCompleteMessage, result);
+            }
+        };
+        if (onCompleteMessage != null) {
+            mMessageMap.put(callback.asBinder(), onCompleteMessage);
+        }
+        try {
+            mIDataService.notifyUserDataRoamingEnabled(mPhone.getPhoneId(), enabled, callback);
+        } catch (RemoteException e) {
+            loge("Cannot invoke notifyUserDataRoamingEnabled on data service.");
+            mMessageMap.remove(callback.asBinder());
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        }
+    }
+
+
+    /**
+     * Notify the underlying data service with the current IMS data network state.
+     *
+     * @param accessNetwork The access network type.
+     * @param dataNetworkState The data network connection state.
+     * @param physicalTransportType The physical transport type of the data network.
+     * @param physicalNetworkSlotIndex The slot index while the physical transport type is
+     *        {@link TRANSPORT_TYPE_WWAN}; otherwise, this slot index will be
+     *        {@link SubscriptionManager#INVALID_SIM_SLOT_INDEX}.
+     * @param onCompleteMessage The result message for this request. {@code null} if the client
+     *        does not care about the result.
+     */
+    public void notifyImsDataNetwork(@RadioAccessNetworkType int accessNetwork,
+            @DataState int dataNetworkState, @TransportType int physicalTransportType,
+            int physicalNetworkSlotIndex, @Nullable Message onCompleteMessage) {
+        if (DBG) log("notifyImsDataNetwork");
+        if (!mFeatureFlags.dataServiceNotifyImsDataNetwork()) {
+            if (DBG) log("Data service IMS data network notification is not enabled.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+            return;
+        }
+        if (!mBound) {
+            loge("Data service not bound.");
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+            return;
+        }
+
+        IIntegerConsumer callback = new IIntegerConsumer.Stub() {
+            @Override
+            public void accept(int result) {
+                if (DBG) log("notifyImsDataNetworkComplete. result = " + result);
+                mMessageMap.remove(asBinder());
+                sendCompleteMessage(onCompleteMessage, result);
+            }
+        };
+        if (onCompleteMessage != null) {
+            mMessageMap.put(callback.asBinder(), onCompleteMessage);
+        }
+        try {
+            mIDataService.notifyImsDataNetwork(mPhone.getPhoneId(), accessNetwork,
+                    dataNetworkState, physicalTransportType, physicalNetworkSlotIndex, callback);
+        } catch (RemoteException e) {
+            loge("Cannot invoke notifyImsDataNetwork on data service.");
+            mMessageMap.remove(callback.asBinder());
+            sendCompleteMessage(onCompleteMessage, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        }
+    }
+
     private void log(String s) {
         Rlog.d(mTag, s);
     }
diff --git a/src/java/com/android/internal/telephony/data/DataSettingsManager.java b/src/java/com/android/internal/telephony/data/DataSettingsManager.java
index cf748ffe9a..dee2352f4f 100644
--- a/src/java/com/android/internal/telephony/data/DataSettingsManager.java
+++ b/src/java/com/android/internal/telephony/data/DataSettingsManager.java
@@ -41,6 +41,7 @@ import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.IndentingPrintWriter;
 import android.util.LocalLog;
+import android.util.SparseArray;
 
 import com.android.internal.telephony.GlobalSettingsHelper;
 import com.android.internal.telephony.Phone;
@@ -105,6 +106,14 @@ public class DataSettingsManager extends Handler {
     @NonNull
     private final DataConfigManager mDataConfigManager;
 
+    /** Data Network Controller */
+    @NonNull
+    private final DataNetworkController mDataNetworkController;
+
+    /** Data service managers. */
+    @NonNull
+    private final SparseArray<DataServiceManager> mDataServiceManagers;
+
     /** Data settings manager callbacks. */
     @NonNull
     private final Set<DataSettingsManagerCallback> mDataSettingsManagerCallbacks = new ArraySet<>();
@@ -180,12 +189,14 @@ public class DataSettingsManager extends Handler {
      *
      * @param phone The phone instance.
      * @param dataNetworkController Data network controller.
+     * @param dataServiceManagers Data service managers indexed by transport type.
      * @param looper The looper to be used by the handler. Currently the handler thread is the
      * phone process's main thread.
      * @param callback Data settings manager callback.
      */
     public DataSettingsManager(@NonNull Phone phone,
             @NonNull DataNetworkController dataNetworkController,
+            @NonNull SparseArray<DataServiceManager> dataServiceManagers,
             @NonNull FeatureFlags featureFlags, @NonNull Looper looper,
             @NonNull DataSettingsManagerCallback callback) {
         super(looper);
@@ -196,7 +207,9 @@ public class DataSettingsManager extends Handler {
         mSubId = mPhone.getSubId();
         mResolver = mPhone.getContext().getContentResolver();
         registerCallback(callback);
+        mDataNetworkController = dataNetworkController;
         mDataConfigManager = dataNetworkController.getDataConfigManager();
+        mDataServiceManagers = dataServiceManagers;
         refreshEnabledMobileDataPolicy();
         mSettingsObserver = new SettingsObserver(mPhone.getContext(), this);
         mDataEnabledSettings.put(TelephonyManager.DATA_ENABLED_REASON_POLICY, true);
@@ -346,6 +359,37 @@ public class DataSettingsManager extends Handler {
                     }
                 });
         updateDataEnabledAndNotify(TelephonyManager.DATA_ENABLED_REASON_UNKNOWN);
+        // Notify DataService the initial user data enabled and user data roaming enabled state.
+        // This is to ensure that DataService which bound to DataServiceManager before
+        // DataSettingsManager initialized can receive the initial state.
+        notifyDataServiceUserDataEnabled(isUserDataEnabled());
+        notifyDataServiceUserDataRoamingEnabled(isDataRoamingEnabled());
+        mDataNetworkController.registerDataNetworkControllerCallback(
+                new DataNetworkController.DataNetworkControllerCallback(this::post) {
+                    @Override
+                    public void onSimStateChanged(int simState) {
+                        // When the sim is loaded (e.g. modem restarted), notify all data service
+                        // the current user data and user data roaming enabled state
+                        if (simState == TelephonyManager.SIM_STATE_LOADED) {
+                            notifyDataServiceUserDataEnabled(isUserDataEnabled());
+                            notifyDataServiceUserDataRoamingEnabled(isDataRoamingEnabled());
+                        }
+                    }
+
+                    @Override
+                    public void onDataServiceBound(int transport) {
+                        // Sometime the DataService bounding may happens after the
+                        // DataSettingsManager initialized (e.g. DataService initialize late, or
+                        // DataService restarted). In this case, the DataService may not know the
+                        // user data enabled value until the value is updated. Therefore,
+                        // notifying the DataService in the onDataServiceBound callback ensures
+                        // that the DataService will receive the current value once bound.
+                        DataServiceManager dataServiceManager = mDataServiceManagers.get(transport);
+                        dataServiceManager.notifyUserDataEnabled(isUserDataEnabled(), null);
+                        dataServiceManager.notifyUserDataRoamingEnabled(isDataRoamingEnabled(),
+                                null);
+                    }
+                });
     }
 
     /**
@@ -387,6 +431,36 @@ public class DataSettingsManager extends Handler {
         }
     }
 
+    /**
+     * Notify all data service the user data enabled state is changed, by calling
+     * {@link DataServiceManager#notifyUserDataEnabled}.
+     * @param isEnabled {@code true} if user data is enabled and {@code false} otherwise.
+     */
+    private void notifyDataServiceUserDataEnabled(boolean isEnabled) {
+        if (mFeatureFlags.dataServiceUserDataToggleNotify()) {
+            log("notifyDataServiceUserDataEnabled: enabled=" + isEnabled);
+            for (int i = 0; i < mDataServiceManagers.size(); i++) {
+                mDataServiceManagers.valueAt(i).notifyUserDataEnabled(isEnabled,
+                        null);
+            }
+        }
+    }
+
+    /**
+     * Notify all data service the user data roaming enabled state is changed, by calling
+     * {@link DataServiceManager#notifyUserDataRoamingEnabled}.
+     * @param isEnabled {@code true} if user data roaming is enabled and {@code false} otherwise.
+     */
+    private void notifyDataServiceUserDataRoamingEnabled(boolean isEnabled) {
+        if (mFeatureFlags.dataServiceUserDataToggleNotify()) {
+            log("notifyDataServiceUserDataRoamingEnabled: enabled=" + isEnabled);
+            for (int i = 0; i < mDataServiceManagers.size(); i++) {
+                mDataServiceManagers.valueAt(i).notifyUserDataRoamingEnabled(isEnabled,
+                        null);
+            }
+        }
+    }
+
     /**
      * Check whether the user data is enabled when the device is in the provisioning stage.
      * In provisioning, we might want to enable mobile data depending on the value of
@@ -476,6 +550,8 @@ public class DataSettingsManager extends Handler {
                     () -> callback.onUserDataEnabledChanged(enabled, callingPackage)));
             updateDataEnabledAndNotify(TelephonyManager.DATA_ENABLED_REASON_USER,
                     callingPackage, false);
+            // notify data service after user toggled the user data toggle
+            notifyDataServiceUserDataEnabled(enabled);
         }
     }
 
@@ -560,6 +636,8 @@ public class DataSettingsManager extends Handler {
         if (changed) {
             mDataSettingsManagerCallbacks.forEach(callback -> callback.invokeFromExecutor(
                     () -> callback.onDataRoamingEnabledChanged(enabled)));
+            // notify data service after user toggled the user data roaming toggle
+            notifyDataServiceUserDataRoamingEnabled(enabled);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/data/DataStallRecoveryManager.java b/src/java/com/android/internal/telephony/data/DataStallRecoveryManager.java
index e3060e5334..45395cb732 100644
--- a/src/java/com/android/internal/telephony/data/DataStallRecoveryManager.java
+++ b/src/java/com/android/internal/telephony/data/DataStallRecoveryManager.java
@@ -34,6 +34,7 @@ import android.os.Message;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.provider.Settings;
+import android.telecom.TelecomManager;
 import android.telephony.Annotation.RadioPowerState;
 import android.telephony.Annotation.ValidationStatus;
 import android.telephony.CellSignalStrength;
@@ -344,6 +345,13 @@ public class DataStallRecoveryManager extends Handler {
                                     : "All InternetDataNetwork Disconnected");
                         }
                     }
+                    @Override
+                    public void onSimStateChanged(int simState) {
+                        if (simState == TelephonyManager.SIM_STATE_ABSENT) {
+                            log("SIM state is ABSENT, reset DSRM.");
+                            reset(true);
+                        }
+                    }
                 });
         mPhone.mCi.registerForRadioStateChanged(this, EVENT_RADIO_STATE_CHANGED, null);
 
@@ -549,8 +557,13 @@ public class DataStallRecoveryManager extends Handler {
     /**
      * Called when internet validation status passed. We will initialize all parameters.
      */
-    private void reset() {
-        mIsValidNetwork = true;
+    private void reset(boolean isSimAbsent) {
+        if (isSimAbsent) {
+            // state set to never passed due to SIM absent
+            mIsValidNetwork = false;
+        } else {
+            mIsValidNetwork = true;
+        }
         mRecoveryTriggered = false;
         mIsAttemptedAllSteps = false;
         mRadioStateChangedDuringDataStall = false;
@@ -578,7 +591,7 @@ public class DataStallRecoveryManager extends Handler {
         if (isValid) {
             // Broadcast intent that data stall recovered.
             broadcastDataStallDetected(mLastAction);
-            reset();
+            reset(false);
         } else if (isRecoveryNeeded(true)) {
             // Set the network as invalid, because recovery is needed
             mIsValidNetwork = false;
@@ -616,6 +629,12 @@ public class DataStallRecoveryManager extends Handler {
      */
     @VisibleForTesting
     public void setRecoveryAction(@RecoveryAction int action) {
+        if (!mIsValidNetwork && !isRecoveryAlreadyStarted()) {
+            log(
+                    "Skip set recovery action because the network still remains invalid and"
+                    + " recovery was not started yet.");
+            return;
+        }
         // Reset the validation count for action change
         if (mRecoveryAction != action) {
             mActionValidationCount = 0;
@@ -710,12 +729,8 @@ public class DataStallRecoveryManager extends Handler {
         // Put the bundled stats extras on the intent.
         intent.putExtra("EXTRA_DSRS_STATS_BUNDLE", bundle);
 
-        if (mFeatureFlags.hsumBroadcast()) {
-            mPhone.getContext().sendBroadcastAsUser(intent, UserHandle.ALL,
-                    READ_PRIVILEGED_PHONE_STATE);
-        } else {
-            mPhone.getContext().sendBroadcast(intent, READ_PRIVILEGED_PHONE_STATE);
-        }
+        mPhone.getContext().sendBroadcastAsUser(intent, UserHandle.ALL,
+                READ_PRIVILEGED_PHONE_STATE);
     }
 
     /** Recovery Action: RECOVERY_ACTION_GET_DATA_CALL_LIST */
@@ -800,6 +815,12 @@ public class DataStallRecoveryManager extends Handler {
             return false;
         }
 
+        // Skip recovery if it can cause an emergrncy call to drop
+        if (isInEmergencyCall()) {
+            logl("skip data stall recovery as there is in an emergency call");
+            return false;
+        }
+
         // Skip recovery if it can cause a call to drop
         if (!isPhoneStateIdle() && getRecoveryAction() > RECOVERY_ACTION_CLEANUP) {
             logl("skip data stall recovery as there is an active call");
@@ -862,6 +883,31 @@ public class DataStallRecoveryManager extends Handler {
         return true;
     }
 
+    /**
+     * Checks if any of the available phones are currently in an emergency call
+     * or in Emergency Callback Mode (ECM).
+     *
+     * @return {@code true} if the device is currently in an emergency call
+     * or if at least one of the available phones is in ECM;
+     * {@code false} otherwise.
+     */
+    private boolean isInEmergencyCall() {
+        TelecomManager mTelecomManager = mPhone
+                .getContext().getSystemService(TelecomManager.class);
+        if (mTelecomManager != null && mTelecomManager.isInEmergencyCall()) {
+            logl("Emergency call detected on the device");
+            return true;
+        }
+
+        for (Phone phone : PhoneFactory.getPhones()) {
+            if (phone.isInEcm()) {
+                logl("ECM detected on phone" + phone.getPhoneId());
+                return true;
+            }
+        }
+        return false;
+    }
+
     /**
      * Set the validation status into metrics.
      *
diff --git a/src/java/com/android/internal/telephony/data/DataUtils.java b/src/java/com/android/internal/telephony/data/DataUtils.java
index c26642869c..d4a81ffc57 100644
--- a/src/java/com/android/internal/telephony/data/DataUtils.java
+++ b/src/java/com/android/internal/telephony/data/DataUtils.java
@@ -32,6 +32,7 @@ import android.telephony.Annotation.DataActivityType;
 import android.telephony.Annotation.NetCapability;
 import android.telephony.Annotation.NetworkType;
 import android.telephony.Annotation.ValidationStatus;
+import android.telephony.CarrierConfigManager;
 import android.telephony.TelephonyManager;
 import android.telephony.data.ApnSetting;
 import android.telephony.data.ApnSetting.ApnType;
@@ -502,4 +503,25 @@ public class DataUtils {
     private static void loge(String msg) {
         Rlog.e(TAG, msg);
     }
+
+    /**
+     * Checks if a given dataMode is valid or not.
+     *
+     * @param dataMode the data mode that needs to be validated.
+     * @return {@code true} if data mode is valid, {@code false} otherwise.
+     */
+    public static boolean isValidDataMode(int dataMode) {
+        if (dataMode < CarrierConfigManager.SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED
+                || CarrierConfigManager.SATELLITE_DATA_SUPPORT_ALL < dataMode) {
+            loge(
+                    "Invalid data mode: "
+                            + dataMode
+                            + ". It's not within the allowed range of data mode: "
+                            + CarrierConfigManager.SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED
+                            + " - "
+                            + CarrierConfigManager.SATELLITE_DATA_SUPPORT_ALL);
+            return false;
+        }
+        return true;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/data/PhoneSwitcher.java b/src/java/com/android/internal/telephony/data/PhoneSwitcher.java
index f76db08be5..2627c8faa3 100644
--- a/src/java/com/android/internal/telephony/data/PhoneSwitcher.java
+++ b/src/java/com/android/internal/telephony/data/PhoneSwitcher.java
@@ -77,7 +77,6 @@ import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConfigurationManager;
 import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.RadioConfig;
-import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.data.DataNetworkController.NetworkRequestList;
 import com.android.internal.telephony.data.DataSettingsManager.DataSettingsManagerCallback;
 import com.android.internal.telephony.flags.FeatureFlags;
@@ -627,19 +626,14 @@ public class PhoneSwitcher extends Handler {
         };
         mAutoDataSwitchController = new AutoDataSwitchController(context, looper, this,
                 mFlags, mAutoDataSwitchCallback);
-        if (!mFlags.ddsCallback()) {
-            mContext.registerReceiver(mDefaultDataChangedReceiver,
-                    new IntentFilter(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED));
-        } else {
-            mSubscriptionManagerService.registerCallback(new SubscriptionManagerServiceCallback(
-                    this::post) {
-                @Override
-                public void onDefaultDataSubscriptionChanged(int subId) {
-                    evaluateIfImmediateDataSwitchIsNeeded("default data sub changed to " + subId,
-                            DataSwitch.Reason.DATA_SWITCH_REASON_MANUAL);
-                }
-            });
-        }
+        mSubscriptionManagerService.registerCallback(new SubscriptionManagerServiceCallback(
+                this::post) {
+            @Override
+            public void onDefaultDataSubscriptionChanged(int subId) {
+                evaluateIfImmediateDataSwitchIsNeeded("default data sub changed to " + subId,
+                        DataSwitch.Reason.DATA_SWITCH_REASON_MANUAL);
+            }
+        });
 
         PhoneConfigurationManager.registerForMultiSimConfigChange(
                 this, EVENT_MULTI_SIM_CONFIG_CHANGED, null);
diff --git a/src/java/com/android/internal/telephony/data/QosCallbackTracker.java b/src/java/com/android/internal/telephony/data/QosCallbackTracker.java
index a1ac379037..05cb366e2e 100644
--- a/src/java/com/android/internal/telephony/data/QosCallbackTracker.java
+++ b/src/java/com/android/internal/telephony/data/QosCallbackTracker.java
@@ -56,7 +56,7 @@ public class QosCallbackTracker extends Handler {
     @NonNull
     private final String mLogTag;
     @NonNull
-    private final TelephonyNetworkAgent mNetworkAgent;
+    private TelephonyNetworkAgent mNetworkAgent;
     @NonNull
     private final Map<Integer, QosBearerSession> mQosBearerSessions;
     @NonNull
@@ -115,6 +115,27 @@ public class QosCallbackTracker extends Handler {
         mRcsStats = RcsStats.getInstance();
         mLogTag = "QOSCT" + "-" + ((NetworkAgent) mNetworkAgent).getNetwork().getNetId();
 
+        registerTelephonyNetworkAgentCallback(mNetworkAgent);
+    }
+
+    /**
+     * Update to the new NetworkAgent in this QosCallbackTracker
+     *
+     * @param networkAgent new network agent supposed to be used.
+     */
+    public void updateNetworkAgent(TelephonyNetworkAgent networkAgent) {
+        post(() -> {
+            // Clear mCallbacksToFilter entries that were come from the previous NetworkAgent. The
+            // actual QoS callback at client side will receive QosCallbackException
+            // #EX_TYPE_FILTER_NETWORK_RELEASED through the Connectivity service and unregistered.
+            mCallbacksToFilter.clear();
+            mNetworkAgent = networkAgent;
+            registerTelephonyNetworkAgentCallback(mNetworkAgent);
+            log("updateNetworkAgent done netId:" + (mNetworkAgent).getNetwork().getNetId());
+        });
+    }
+
+    private void registerTelephonyNetworkAgentCallback(TelephonyNetworkAgent networkAgent) {
         networkAgent.registerCallback(
                 new TelephonyNetworkAgent.TelephonyNetworkAgentCallback(this::post) {
                     @Override
diff --git a/src/java/com/android/internal/telephony/domainselection/DomainSelectionConnection.java b/src/java/com/android/internal/telephony/domainselection/DomainSelectionConnection.java
index 681ca129ea..91ffdf87f0 100644
--- a/src/java/com/android/internal/telephony/domainselection/DomainSelectionConnection.java
+++ b/src/java/com/android/internal/telephony/domainselection/DomainSelectionConnection.java
@@ -51,7 +51,6 @@ import com.android.internal.telephony.IWwanSelectorCallback;
 import com.android.internal.telephony.IWwanSelectorResultCallback;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.data.AccessNetworksManager.QualifiedNetworks;
-import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.util.TelephonyUtils;
 
 import java.io.PrintWriter;
@@ -189,8 +188,7 @@ public class DomainSelectionConnection {
                     return;
                 }
                 DomainSelectionConnection.this.onSelectionTerminated(cause);
-                if (!Flags.hangupEmergencyCallForCrossSimRedialing()
-                        || !mIsEmergency || !checkState(STATUS_DOMAIN_SELECTED)) {
+                if (!mIsEmergency || !checkState(STATUS_DOMAIN_SELECTED)) {
                     dispose();
                 }
             }
diff --git a/src/java/com/android/internal/telephony/domainselection/EmergencyCallDomainSelectionConnection.java b/src/java/com/android/internal/telephony/domainselection/EmergencyCallDomainSelectionConnection.java
index 4153c932a7..8113fd0a07 100644
--- a/src/java/com/android/internal/telephony/domainselection/EmergencyCallDomainSelectionConnection.java
+++ b/src/java/com/android/internal/telephony/domainselection/EmergencyCallDomainSelectionConnection.java
@@ -47,7 +47,6 @@ import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.data.AccessNetworksManager;
 import com.android.internal.telephony.data.AccessNetworksManager.QualifiedNetworks;
 import com.android.internal.telephony.emergency.EmergencyStateTracker;
-import com.android.internal.telephony.flags.Flags;
 
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
@@ -202,25 +201,23 @@ public class EmergencyCallDomainSelectionConnection extends DomainSelectionConne
     @Override
     public @NonNull CompletableFuture<Integer> reselectDomain(
         @NonNull DomainSelectionService.SelectionAttributes attr) {
-        if (Flags.hangupEmergencyCallForCrossSimRedialing()) {
-            int disconnectCause = getDisconnectCause();
-            int preciseDisconnectCause = attr.getCsDisconnectCause();
-            if (disconnectCause == android.telephony.DisconnectCause.EMERGENCY_TEMP_FAILURE) {
-                preciseDisconnectCause = PreciseDisconnectCause.EMERGENCY_TEMP_FAILURE;
-            } else if (disconnectCause
-                    == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE) {
-                preciseDisconnectCause = PreciseDisconnectCause.EMERGENCY_PERM_FAILURE;
-            }
-            if (preciseDisconnectCause != attr.getCsDisconnectCause()) {
-                attr = EmergencyCallDomainSelectionConnection.getSelectionAttributes(
-                        attr.getSlotIndex(), attr.getSubscriptionId(),
-                        attr.isExitedFromAirplaneMode(), attr.getCallId(),
-                        (attr.getAddress() != null)
-                        ? attr.getAddress().getSchemeSpecificPart() : "",
-                        attr.isTestEmergencyNumber(), preciseDisconnectCause,
-                        attr.getPsDisconnectCause(),
-                        attr.getEmergencyRegistrationResult());
-            }
+        int disconnectCause = getDisconnectCause();
+        int preciseDisconnectCause = attr.getCsDisconnectCause();
+        if (disconnectCause == android.telephony.DisconnectCause.EMERGENCY_TEMP_FAILURE) {
+            preciseDisconnectCause = PreciseDisconnectCause.EMERGENCY_TEMP_FAILURE;
+        } else if (disconnectCause
+                == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE) {
+            preciseDisconnectCause = PreciseDisconnectCause.EMERGENCY_PERM_FAILURE;
+        }
+        if (preciseDisconnectCause != attr.getCsDisconnectCause()) {
+            attr = EmergencyCallDomainSelectionConnection.getSelectionAttributes(
+                    attr.getSlotIndex(), attr.getSubscriptionId(),
+                    attr.isExitedFromAirplaneMode(), attr.getCallId(),
+                    (attr.getAddress() != null)
+                    ? attr.getAddress().getSchemeSpecificPart() : "",
+                    attr.isTestEmergencyNumber(), preciseDisconnectCause,
+                    attr.getPsDisconnectCause(),
+                    attr.getEmergencyRegistrationResult());
         }
         return super.reselectDomain(attr);
     }
diff --git a/src/java/com/android/internal/telephony/emergency/EmergencyStateTracker.java b/src/java/com/android/internal/telephony/emergency/EmergencyStateTracker.java
index 4a3ab21c55..d4b1b8198a 100644
--- a/src/java/com/android/internal/telephony/emergency/EmergencyStateTracker.java
+++ b/src/java/com/android/internal/telephony/emergency/EmergencyStateTracker.java
@@ -1492,6 +1492,18 @@ public class EmergencyStateTracker {
             return CompletableFuture.completedFuture(DisconnectCause.ERROR_UNSPECIFIED);
         }
 
+        // If the radio is/will be turned off when an emergency SMS is being sent,
+        // the SMS is not allowed and will follow the SMS retry logic on failure.
+        //
+        // This can occur when an emergency SMS is sent by ELS(Emergency Location System)
+        // while the radio is turned on by making an emergency call in airplane mode.
+        // NOTE: ELS uses AML(Advanced Mobile Location) protocol to transfer data from mobile
+        // to emergency call centre using either SMS or HTTP.
+        if (!phone.isRadioOn() || !phone.getServiceStateTracker().getDesiredPowerState()) {
+            Rlog.e(TAG, "Emergency SMS is not allowed while radio is/will be turned off.");
+            return CompletableFuture.completedFuture(DisconnectCause.POWER_OFF);
+        }
+
         mSmsPhone = phone;
         mIsTestEmergencyNumberForSms = isTestEmergencyNumber;
         mOngoingEmergencySmsIds.add(smsId);
diff --git a/src/java/com/android/internal/telephony/euicc/EuiccController.java b/src/java/com/android/internal/telephony/euicc/EuiccController.java
index 58eb4f23b2..8d3f352a58 100644
--- a/src/java/com/android/internal/telephony/euicc/EuiccController.java
+++ b/src/java/com/android/internal/telephony/euicc/EuiccController.java
@@ -71,7 +71,6 @@ import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.euicc.EuiccConnector.OtaStatusChangedCallback;
 import com.android.internal.telephony.flags.FeatureFlags;
-import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.telephony.uicc.UiccController;
@@ -625,6 +624,7 @@ public class EuiccController extends IEuiccController.Stub {
 
         boolean callerHasAdminPrivileges =
                 callerCanManageDevicePolicyManagedSubscriptions(callingPackage);
+
         if (callerHasAdminPrivileges && (switchAfterDownload && !shouldAllowSwitchAfterDownload(
                 callingPackage))) {
             // Throw error if calling admin does not have privileges to enable
@@ -739,16 +739,24 @@ public class EuiccController extends IEuiccController.Stub {
                     super.onGetMetadataComplete(cardId, result);
                     return;
                 }
+                boolean callerHasAdminPrivileges =
+                callerCanManageDevicePolicyManagedSubscriptions(mCallingPackage, mCallingToken);
+                // At this point, we already have the user's consent.
+                // So the following operations can be done with maximum privileges.
 
-                if (checkCarrierPrivilegeInMetadata(subscription, mCallingPackage)) {
+                if (checkCarrierPrivilegeInMetadata(subscription, mCallingPackage)
+                        || callerHasAdminPrivileges) {
                     // Caller can download this profile. Since we already have the user's consent,
                     // proceed to download.
-                    downloadSubscriptionPrivileged(cardId, mPortIndex,
-                            mCallingToken, subscription, mSwitchAfterDownload,  mForceDeactivateSim,
-                            mCallingPackage, null /* resolvedBundle */,
-                            mCallbackIntent);
+                  downloadSubscriptionPrivileged(cardId, mPortIndex,
+                            mCallingToken, subscription, mSwitchAfterDownload,
+                            mForceDeactivateSim, mCallingPackage, null /* resolvedBundle */,
+                            mCallbackIntent, callerHasAdminPrivileges,
+                      getCurrentEmbeddedSubscriptionIds(cardId));
                 } else {
-                    Log.e(TAG, "Caller does not have carrier privilege in metadata.");
+                    Log.e(TAG,
+                            "Caller does not have carrier privilege in metadata and is does not "
+                                    + "have admin privileges, mCallingPackage=" + mCallingPackage);
                     sendResult(mCallbackIntent, ERROR, null /* extrasIntent */);
                 }
             } else { // !mWithUserConsent
@@ -1075,7 +1083,6 @@ public class EuiccController extends IEuiccController.Stub {
     public void deleteSubscription(int cardId, int subscriptionId, String callingPackage,
             PendingIntent callbackIntent) {
         boolean callerCanWriteEmbeddedSubscriptions = callerCanWriteEmbeddedSubscriptions();
-        boolean callerIsAdmin = callerCanManageDevicePolicyManagedSubscriptions(callingPackage);
         mAppOpsManager.checkPackage(Binder.getCallingUid(), callingPackage);
 
         long token = Binder.clearCallingIdentity();
@@ -1086,14 +1093,17 @@ public class EuiccController extends IEuiccController.Stub {
                 sendResult(callbackIntent, ERROR, null /* extrasIntent */);
                 return;
             }
-            boolean adminOwned = callerIsAdmin && sub.getGroupOwner().equals(callingPackage);
+            boolean managedByCallingAdminPackage =
+                    callerCanManageDevicePolicyManagedSubscriptions(callingPackage)
+                            && isSubscriptionDevicePolicyManaged(
+                            sub, callingPackage);
             // For both single active SIM device and multi-active SIM device, if the caller is
             // system or the caller manage the target subscription, we let it continue. This is
             // because deleting subscription won't change status of any other subscriptions.
             if (!callerCanWriteEmbeddedSubscriptions
                     && !canManageSubscription(sub, callingPackage)
-                    && !adminOwned) {
-                Log.e(TAG, "No permissions: " + subscriptionId + " adminOwned=" + adminOwned);
+                    && !managedByCallingAdminPackage) {
+                Log.e(TAG, "No permissions to delete subscription: " + subscriptionId);
                 sendResult(callbackIntent, ERROR, null /* extrasIntent */);
                 return;
             }
@@ -1857,12 +1867,8 @@ public class EuiccController extends IEuiccController.Stub {
         if (bestComponent != null) {
             intent.setPackage(bestComponent.packageName);
         }
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                    permission.WRITE_EMBEDDED_SUBSCRIPTIONS);
-        } else {
-            mContext.sendBroadcast(intent, permission.WRITE_EMBEDDED_SUBSCRIPTIONS);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                permission.WRITE_EMBEDDED_SUBSCRIPTIONS);
     }
 
     @Nullable
@@ -2197,6 +2203,13 @@ public class EuiccController extends IEuiccController.Stub {
         return userContext.getSystemService(DevicePolicyManager.class);
     }
 
+    private boolean isSubscriptionDevicePolicyManaged(@NonNull SubscriptionInfo info,
+            @NonNull String callingPackage) {
+        DevicePolicyManager devicePolicyManager = getDevicePolicyManager();
+        return devicePolicyManager != null && devicePolicyManager.isSubscriptionEnterpriseManaged(
+                info, callingPackage);
+    }
+
     private boolean callerCanManageDevicePolicyManagedSubscriptions(String callingPackage) {
         DevicePolicyManager devicePolicyManager = getDevicePolicyManager();
         boolean isAdmin =
@@ -2208,6 +2221,19 @@ public class EuiccController extends IEuiccController.Stub {
                 == PackageManager.PERMISSION_GRANTED;
     }
 
+    // Does the same thing as callerCanManageDevicePolicyManagedSubscriptions
+    //but restores the calling identity before checking permissions.
+    private boolean callerCanManageDevicePolicyManagedSubscriptions(String callingPackage,
+      long callingToken) {
+        long previousCallingIdentity = Binder.clearCallingIdentity();
+        try {
+            Binder.restoreCallingIdentity(callingToken);
+            return callerCanManageDevicePolicyManagedSubscriptions(callingPackage);
+        } finally {
+            Binder.restoreCallingIdentity(previousCallingIdentity);
+        }
+    }
+
     private boolean shouldAllowSwitchAfterDownload(String callingPackage) {
         DevicePolicyManager devicePolicyManager = getDevicePolicyManager();
         return devicePolicyManager != null && (devicePolicyManager.isDeviceOwnerApp(callingPackage)
@@ -2393,7 +2419,7 @@ public class EuiccController extends IEuiccController.Stub {
     }
 
     private boolean canManageSubscription(SubscriptionInfo subInfo, String packageName) {
-        if (Flags.hsumPackageManager() && UserManager.isHeadlessSystemUserMode()) {
+        if (UserManager.isHeadlessSystemUserMode()) {
             return mSubscriptionManager.canManageSubscriptionAsUser(subInfo, packageName,
                     UserHandle.of(ActivityManager.getCurrentUser()));
         } else {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmInboundSmsHandler.java b/src/java/com/android/internal/telephony/gsm/GsmInboundSmsHandler.java
index bf8098f859..3745fec692 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmInboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmInboundSmsHandler.java
@@ -176,7 +176,7 @@ public class GsmInboundSmsHandler extends InboundSmsHandler {
             // As per 3GPP TS 23.040 9.2.3.9, Type Zero messages should not be
             // Displayed/Stored/Notified. They should only be acknowledged.
             log("Received short message type 0, Don't display or store it. Send Ack");
-            addSmsTypeZeroToMetrics(smsSource);
+            addSmsTypeZeroToMetrics(smsSource, getPduLength(sms));
             return Intents.RESULT_SMS_HANDLED;
         }
 
@@ -197,7 +197,7 @@ public class GsmInboundSmsHandler extends InboundSmsHandler {
             if (DBG) log("Received voice mail indicator clear SMS shouldStore=" + !handled);
         }
         if (handled) {
-            addVoicemailSmsToMetrics(smsSource);
+            addVoicemailSmsToMetrics(smsSource, getPduLength(sms));
             return Intents.RESULT_SMS_HANDLED;
         }
 
@@ -260,19 +260,19 @@ public class GsmInboundSmsHandler extends InboundSmsHandler {
     /**
      * Add SMS of type 0 to metrics.
      */
-    private void addSmsTypeZeroToMetrics(@SmsSource int smsSource) {
+    private void addSmsTypeZeroToMetrics(@SmsSource int smsSource, int pduLength) {
         mMetrics.writeIncomingSmsTypeZero(mPhone.getPhoneId(),
                 android.telephony.SmsMessage.FORMAT_3GPP);
-        mPhone.getSmsStats().onIncomingSmsTypeZero(smsSource);
+        mPhone.getSmsStats().onIncomingSmsTypeZero(smsSource, pduLength);
     }
 
     /**
      * Add voicemail indication SMS 0 to metrics.
      */
-    private void addVoicemailSmsToMetrics(@SmsSource int smsSource) {
+    private void addVoicemailSmsToMetrics(@SmsSource int smsSource, int pduLength) {
         mMetrics.writeIncomingVoiceMailSms(mPhone.getPhoneId(),
                 android.telephony.SmsMessage.FORMAT_3GPP);
-        mPhone.getSmsStats().onIncomingSmsVoicemail(false /* is3gpp2 */, smsSource);
+        mPhone.getSmsStats().onIncomingSmsVoicemail(false /* is3gpp2 */, smsSource, pduLength);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/gsm/GsmSMSDispatcher.java b/src/java/com/android/internal/telephony/gsm/GsmSMSDispatcher.java
index 25a83bd8d7..3c4b5111f2 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmSMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmSMSDispatcher.java
@@ -18,6 +18,7 @@ package com.android.internal.telephony.gsm;
 
 import static com.android.internal.telephony.SmsResponse.NO_ERROR_CODE;
 
+import android.annotation.NonNull;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.AsyncResult;
 import android.os.Build;
@@ -34,6 +35,7 @@ import com.android.internal.telephony.SmsController;
 import com.android.internal.telephony.SmsDispatchersController;
 import com.android.internal.telephony.SmsHeader;
 import com.android.internal.telephony.SmsMessageBase;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.telephony.uicc.UiccCardApplication;
@@ -54,8 +56,8 @@ public final class GsmSMSDispatcher extends SMSDispatcher {
     private GsmInboundSmsHandler mGsmInboundSmsHandler;
 
     public GsmSMSDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
-            GsmInboundSmsHandler gsmInboundSmsHandler) {
-        super(phone, smsDispatchersController);
+            GsmInboundSmsHandler gsmInboundSmsHandler, @NonNull FeatureFlags featureFlags) {
+        super(phone, smsDispatchersController, featureFlags);
         mCi.setOnSmsStatus(this, EVENT_NEW_SMS_STATUS_REPORT, null);
         mGsmInboundSmsHandler = gsmInboundSmsHandler;
         mUiccController = UiccController.getInstance();
diff --git a/src/java/com/android/internal/telephony/gsm/UsimDataDownloadHandler.java b/src/java/com/android/internal/telephony/gsm/UsimDataDownloadHandler.java
index bae56d127c..46ba584168 100644
--- a/src/java/com/android/internal/telephony/gsm/UsimDataDownloadHandler.java
+++ b/src/java/com/android/internal/telephony/gsm/UsimDataDownloadHandler.java
@@ -107,7 +107,8 @@ public class UsimDataDownloadHandler extends Handler {
                     IccUtils.bytesToHexString(smsMessage.getPdu()),
                     obtainMessage(EVENT_WRITE_SMS_COMPLETE,
                             new int[]{ smsSource, smsMessage.mMessageRef, token }));
-            addUsimDataDownloadToMetrics(false, smsSource);
+            addUsimDataDownloadToMetrics(false, smsSource,
+                    InboundSmsHandler.getPduLength(smsMessage));
             return Activity.RESULT_OK;  // acknowledge after response from write to USIM
         }
 
@@ -187,7 +188,7 @@ public class UsimDataDownloadHandler extends Handler {
             Rlog.e(TAG, "startDataDownload() calculated incorrect envelope length, aborting.");
             acknowledgeSmsWithError(CommandsInterface.GSM_SMS_FAIL_CAUSE_UNSPECIFIED_ERROR,
                     smsSource, token, smsMessage.mMessageRef);
-            addUsimDataDownloadToMetrics(false, smsSource);
+            addUsimDataDownloadToMetrics(false, smsSource, 0);
             return;
         }
 
@@ -195,8 +196,7 @@ public class UsimDataDownloadHandler extends Handler {
         mCi.sendEnvelopeWithStatus(encodedEnvelope, obtainMessage(
                 EVENT_SEND_ENVELOPE_RESPONSE, new int[]{ dcs, pid, smsSource,
                     smsMessage.mMessageRef, token }));
-
-        addUsimDataDownloadToMetrics(true, smsSource);
+        addUsimDataDownloadToMetrics(true, smsSource, InboundSmsHandler.getPduLength(smsMessage));
     }
 
     /**
@@ -330,10 +330,10 @@ public class UsimDataDownloadHandler extends Handler {
      * by the USIM itself.
      */
     private void addUsimDataDownloadToMetrics(boolean result,
-            @InboundSmsHandler.SmsSource int smsSource) {
+            @InboundSmsHandler.SmsSource int smsSource, int pduLength) {
         TelephonyMetrics metrics = TelephonyMetrics.getInstance();
         metrics.writeIncomingSMSPP(mPhoneId, android.telephony.SmsMessage.FORMAT_3GPP, result);
-        PhoneFactory.getPhone(mPhoneId).getSmsStats().onIncomingSmsPP(smsSource, result);
+        PhoneFactory.getPhone(mPhoneId).getSmsStats().onIncomingSmsPP(smsSource, result, pduLength);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/ims/ImsResolver.java b/src/java/com/android/internal/telephony/ims/ImsResolver.java
index 73ea1901e9..b40af63cbd 100644
--- a/src/java/com/android/internal/telephony/ims/ImsResolver.java
+++ b/src/java/com/android/internal/telephony/ims/ImsResolver.java
@@ -140,6 +140,8 @@ public class ImsResolver implements ImsServiceController.ImsServiceControllerCal
     // Delay between dynamic ImsService queries.
     private static final int DELAY_DYNAMIC_QUERY_MS = 5000;
 
+    // Compile-time debug flag for controlling worker thread behavior
+    private static final boolean USE_WORKER_THREAD = false;
     private static HandlerThread sHandlerThread;
 
     private static ImsResolver sInstance;
@@ -151,7 +153,7 @@ public class ImsResolver implements ImsServiceController.ImsServiceControllerCal
             String defaultRcsPackageName, int numSlots, ImsFeatureBinderRepository repo,
             FeatureFlags featureFlags) {
         if (sInstance == null) {
-            if (featureFlags.threadShred()) {
+            if (featureFlags.threadShred() && USE_WORKER_THREAD) {
                 sInstance = new ImsResolver(context, defaultMmTelPackageName, defaultRcsPackageName,
                         numSlots, repo, WorkerThread.get().getLooper(), featureFlags);
             } else {
diff --git a/src/java/com/android/internal/telephony/ims/ImsServiceController.java b/src/java/com/android/internal/telephony/ims/ImsServiceController.java
index c61c7eb37b..0baabad516 100644
--- a/src/java/com/android/internal/telephony/ims/ImsServiceController.java
+++ b/src/java/com/android/internal/telephony/ims/ImsServiceController.java
@@ -266,7 +266,11 @@ public class ImsServiceController {
     // Enable ImsServiceControllerTest and SipDelegateManagerTest cases if this is re-enabled.
     private static final boolean ENFORCE_SINGLE_SERVICE_FOR_SIP_TRANSPORT = false;
     private final ComponentName mComponentName;
+
+    // Compile-time debug flag for controlling worker thread behavior
+    private static final boolean USE_WORKER_THREAD = false;
     private final HandlerThread mHandlerThread;
+
     private final Handler mHandler;
     private final LegacyPermissionManager mPermissionManager;
     private final FeatureFlags mFeatureFlags;
@@ -365,7 +369,7 @@ public class ImsServiceController {
         mComponentName = componentName;
         mCallbacks = callbacks;
         Looper looper;
-        if (featureFlags.threadShred()) {
+        if (featureFlags.threadShred() && USE_WORKER_THREAD) {
             mHandlerThread = null;
             mHandler = new Handler(WorkerThread.get().getLooper());
             looper = WorkerThread.get().getLooper();
@@ -1000,13 +1004,11 @@ public class ImsServiceController {
 
     @Override
     public String toString() {
-        synchronized (mLock) {
-            return "[ImsServiceController: componentName=" + getComponentName() + ", boundUser="
-                    + mBoundUser + ", features=" + mImsFeatures + ", isBinding=" + mIsBinding
-                    + ", isBound=" + mIsBound + ", serviceController=" + getImsServiceController()
-                    + ", rebindDelay=" + getRebindDelay() + ", slotToSubIdMap=" + mSlotIdToSubIdMap
-                    + "]";
-        }
+        return "[ImsServiceController: componentName=" + getComponentName() + ", boundUser="
+                + mBoundUser + ", features=" + mImsFeatures + ", isBinding=" + mIsBinding
+                + ", isBound=" + mIsBound + ", serviceController=" + getImsServiceController()
+                + ", rebindDelay=" + getRebindDelay() + ", slotToSubIdMap=" + mSlotIdToSubIdMap
+                + "]";
     }
 
     public void dump(PrintWriter printWriter) {
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index ca1809879b..1357cbd1f9 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -2919,6 +2919,23 @@ public class ImsPhone extends ImsPhoneBase {
                 == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
     }
 
+    /**
+     * Update allowed IMS services.
+     *
+     * @param regTech Which technology is associated with this capability.
+     * @param enabled Whether this capability is enabled.
+     * @param isHomeOnly Whether this capability change is for home network only.
+     */
+    public void setAllowedImsServices(
+            @ImsRegistrationImplBase.ImsRegistrationTech int regTech,
+            boolean enabled, boolean isHomeOnly) {
+        if (isHomeOnly) {
+            mDefaultPhone.setAllowedImsServicesForHomeOnly(regTech, enabled);
+        } else {
+            mDefaultPhone.setAllowedImsServicesForAny(regTech, enabled);
+        }
+    }
+
     @Override
     public void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {
         IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, "  ");
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index f4475b55bd..adfb06adbb 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -115,6 +115,7 @@ import android.util.ArraySet;
 import android.util.LocalLog;
 import android.util.Log;
 import android.util.Pair;
+import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 
 import com.android.ims.FeatureConnector;
@@ -803,6 +804,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private boolean mSupportCepOnPeer = true;
     private boolean mSupportD2DUsingRtp = false;
     private boolean mSupportSdpForRtpHeaderExtensions = false;
+    private boolean mVolteRoamingSupported = false;
     private int mThresholdRtpPacketLoss;
     private int mThresholdRtpJitter;
     private long mThresholdRtpInactivityTime;
@@ -812,6 +814,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     // in progress. Values listed above.
     private HoldSwapState mHoldSwitchingState = HoldSwapState.INACTIVE;
     private MediaThreshold mMediaThreshold;
+    private SparseBooleanArray mImsCapability = new SparseBooleanArray();
 
     private String mLastDialString = null;
     private ImsDialArgs mLastDialArgs = null;
@@ -1482,6 +1485,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
         mCurrentlyConnectedSubId = Optional.empty();
         mMediaThreshold = null;
+        clearAllowedServices();
         resetImsCapabilities();
         hangupAllOrphanedConnections(DisconnectCause.LOST_SIGNAL);
         // For compatibility with apps that still use deprecated intent
@@ -1543,11 +1547,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         Intent intent = new Intent(intentAction);
         intent.putExtra(ImsManager.EXTRA_PHONE_ID, mPhone.getPhoneId());
         if (mPhone != null && mPhone.getContext() != null) {
-            if (mFeatureFlags.hsumBroadcast()) {
-                mPhone.getContext().sendBroadcastAsUser(intent, UserHandle.ALL);
-            } else {
-                mPhone.getContext().sendBroadcast(intent);
-            }
+            mPhone.getContext().sendBroadcastAsUser(intent, UserHandle.ALL);
         }
     }
 
@@ -1923,6 +1923,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         updateImsServiceConfig();
         updateMediaThreshold(
                 mThresholdRtpPacketLoss, mThresholdRtpJitter, mThresholdRtpInactivityTime);
+        updateAllowedServices(ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
+        updateAllowedServices(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
     }
 
     /**
@@ -1971,6 +1973,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         mSupportSdpForRtpHeaderExtensions = carrierConfig.getBoolean(
                 CarrierConfigManager
                         .KEY_SUPPORTS_SDP_NEGOTIATION_OF_D2D_RTP_HEADER_EXTENSIONS_BOOL);
+        mVolteRoamingSupported =
+                carrierConfig.getBoolean(
+                        CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL);
         mThresholdRtpPacketLoss = carrierConfig.getInt(
                 CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_PACKET_LOSS_RATE_THRESHOLD_INT);
         mThresholdRtpInactivityTime = carrierConfig.getLong(
@@ -2061,6 +2066,45 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
     }
 
+    /**
+     * Update allowed services to the modem.
+     *
+     * @param regTech Which technology is associated with this capability.
+     */
+    private void updateAllowedServices(@ImsRegistrationImplBase.ImsRegistrationTech int regTech) {
+        if (!mFeatureFlags.allowedServices()) return;
+        if (mImsCapability.indexOfKey(regTech) < 0) {
+            // Update allowed services until this capability is initialized.
+            return;
+        }
+        boolean enabled = mImsCapability.get(regTech);
+        boolean enabledForRoaming;
+        switch(regTech) {
+            case ImsRegistrationImplBase.REGISTRATION_TECH_LTE:
+                enabledForRoaming = enabled && mVolteRoamingSupported;
+                break;
+            case ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN:
+                boolean wfcRoamingEnabledByUser = mImsManager.isWfcRoamingEnabledByUser();
+                enabledForRoaming = enabled && wfcRoamingEnabledByUser;
+                break;
+            default:
+                logw("Unhandled registration technology = " + regTech);
+                return;
+        }
+        log("updateAllowedServices for RAT = " + regTech + ", enabled = " + enabled
+                + ", enabledForRoaming = " + enabledForRoaming);
+        mPhone.setAllowedImsServices(regTech, enabled, !enabledForRoaming);
+    }
+
+    /**
+     * Clear cached allowed services.
+     */
+    private void clearAllowedServices() {
+        log("clearAllowedServices");
+        mImsCapability.clear();
+        mVolteRoamingSupported = false;
+    }
+
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     private void handleEcmTimer(int action) {
         mPhone.handleTimerInEmergencyCallbackMode(action);
@@ -2886,7 +2930,11 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         if (mFeatureFlags.preventHangupDuringCallMerge()) {
             if (imsCall != null && imsCall.isCallSessionMergePending()) {
                 if (DBG) log("hangup call failed during call merge");
-
+                // Notify Telecom that the disconnect failed due to an ongoing call merge.
+                if (conn != null && mTelecomFlags.revertDisconnectingDuringMerge()) {
+                    conn.onConnectionEvent(android.telecom.Connection.EVENT_DISCONNECT_FAILED,
+                            null);
+                }
                 throw new CallStateException("can not hangup during call merge");
             }
         }
@@ -4638,17 +4686,34 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
             };
 
+
     private final ImsManager.ImsStatsCallback mImsStatsCallback =
             new ImsManager.ImsStatsCallback() {
-        @Override
-        public void onEnabledMmTelCapabilitiesChanged(int capability, int regTech,
-                boolean isEnabled) {
-            int enabledVal = isEnabled ? ProvisioningManager.PROVISIONING_VALUE_ENABLED
-                    : ProvisioningManager.PROVISIONING_VALUE_DISABLED;
-            mMetrics.writeImsSetFeatureValue(mPhone.getPhoneId(), capability, regTech, enabledVal);
-            mPhone.getImsStats().onSetFeatureResponse(capability, regTech, enabledVal);
-        }
-    };
+                @Override
+                public void onEnabledMmTelCapabilitiesChanged(
+                        int capability, int regTech, boolean isEnabled) {
+                    int enabledVal =
+                            isEnabled
+                                    ? ProvisioningManager.PROVISIONING_VALUE_ENABLED
+                                    : ProvisioningManager.PROVISIONING_VALUE_DISABLED;
+                    mMetrics.writeImsSetFeatureValue(
+                            mPhone.getPhoneId(), capability, regTech, enabledVal);
+                    mPhone.getImsStats().onSetFeatureResponse(capability, regTech, enabledVal);
+                    if (mFeatureFlags.allowedServices()
+                            && capability == MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE) {
+                        switch (regTech) {
+                            case (ImsRegistrationImplBase.REGISTRATION_TECH_LTE):
+                            case (ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN):
+                                if (mImsCapability.indexOfKey(regTech) < 0
+                                        || mImsCapability.get(regTech) != isEnabled) {
+                                    mImsCapability.put(regTech, isEnabled);
+                                    updateAllowedServices(regTech);
+                                }
+                                break;
+                        }
+                    }
+                }
+            };
 
     private final ProvisioningManager.Callback mConfigCallback =
             new ProvisioningManager.Callback() {
@@ -4694,14 +4759,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                     configChangedIntent.putExtra(ImsConfig.EXTRA_CHANGED_ITEM, item);
                     configChangedIntent.putExtra(ImsConfig.EXTRA_NEW_VALUE, value);
                     if (mPhone != null && mPhone.getContext() != null) {
-                        if (mFeatureFlags.hsumBroadcast()) {
-                            mPhone.getContext().sendBroadcastAsUser(configChangedIntent,
-                                    UserHandle.ALL,
-                                    Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-                        } else {
-                            mPhone.getContext().sendBroadcast(configChangedIntent,
-                                    Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-                        }
+                        mPhone.getContext().sendBroadcastAsUser(configChangedIntent,
+                                UserHandle.ALL,
+                                Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
                     }
                 }
 
@@ -5177,6 +5237,11 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         return NetworkStats.IFACE_VT + mPhone.getSubId();
     }
 
+    @VisibleForTesting(visibility = PRIVATE)
+    public ImsManager.ImsStatsCallback getImsStatsCallback() {
+        return mImsStatsCallback;
+    }
+
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     @Override
     protected void log(String msg) {
@@ -6352,13 +6417,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         configChangedIntent.putExtra(ImsConfig.EXTRA_CHANGED_ITEM, item);
         configChangedIntent.putExtra(ImsConfig.EXTRA_NEW_VALUE, value);
         if (mPhone != null && mPhone.getContext() != null) {
-            if (mFeatureFlags.hsumBroadcast()) {
-                mPhone.getContext().sendBroadcastAsUser(configChangedIntent, UserHandle.ALL,
-                        Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            } else {
-                mPhone.getContext().sendBroadcast(
-                        configChangedIntent, Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            }
+            mPhone.getContext().sendBroadcastAsUser(configChangedIntent, UserHandle.ALL,
+                    Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
         }
     }
 }
diff --git a/src/java/com/android/internal/telephony/metrics/MetricsCollector.java b/src/java/com/android/internal/telephony/metrics/MetricsCollector.java
index 1bbfddb4ca..8cbea80859 100644
--- a/src/java/com/android/internal/telephony/metrics/MetricsCollector.java
+++ b/src/java/com/android/internal/telephony/metrics/MetricsCollector.java
@@ -1176,7 +1176,8 @@ public class MetricsCollector implements StatsManager.StatsPullAtomCallback {
                 sms.isManagedProfile,
                 sms.isNtn,
                 sms.isEmergency,
-                sms.isNbIotNtn);
+                sms.isNbIotNtn,
+                sms.pduLength);
     }
 
     private static StatsEvent buildStatsEvent(OutgoingSms sms) {
@@ -1203,7 +1204,10 @@ public class MetricsCollector implements StatsManager.StatsPullAtomCallback {
                 sms.isEmergency,
                 sms.isNtn,
                 sms.isMtSmsPolling,
-                sms.isNbIotNtn);
+                sms.isNbIotNtn,
+                sms.pduLength,
+                sms.callingPackageName,
+                sms.appUid);
     }
 
     private static StatsEvent buildStatsEvent(DataCallSession dataCallSession) {
@@ -1497,7 +1501,9 @@ public class MetricsCollector implements StatsManager.StatsPullAtomCallback {
                 satelliteController.countOfOutgoingDatagramTypeSmsSuccess,
                 satelliteController.countOfOutgoingDatagramTypeSmsFail,
                 satelliteController.countOfIncomingDatagramTypeSmsSuccess,
-                satelliteController.countOfIncomingDatagramTypeSmsFail);
+                satelliteController.countOfIncomingDatagramTypeSmsFail,
+                satelliteController.carrierRoamingSatelliteConfigVersion,
+                satelliteController.maxAllowedDataMode);
     }
 
     private static StatsEvent buildStatsEvent(SatelliteSession satelliteSession) {
@@ -1610,7 +1616,20 @@ public class MetricsCollector implements StatsManager.StatsPullAtomCallback {
                 stats.serviceDataPolicy,
                 stats.satelliteDataConsumedBytes,
                 stats.isMultiSim,
-                stats.isNbIotNtn);
+                stats.isNbIotNtn,
+                stats.countOfDataConnections,
+                stats.lastFailCauses,
+                stats.countOfDataDisconnections,
+                stats.countOfDataStalls,
+                stats.averageUplinkBandwidthKbps,
+                stats.averageDownlinkBandwidthKbps,
+                stats.minUplinkBandwidthKbps,
+                stats.maxUplinkBandwidthKbps,
+                stats.minDownlinkBandwidthKbps,
+                stats.maxDownlinkBandwidthKbps,
+                stats.satelliteSupportedApps,
+                stats.satelliteSupportedUids,
+                stats.perAppSatelliteDataConsumedBytes);
     }
 
     private static StatsEvent buildStatsEvent(CarrierRoamingSatelliteControllerStats stats) {
diff --git a/src/java/com/android/internal/telephony/metrics/PersistAtomsStorage.java b/src/java/com/android/internal/telephony/metrics/PersistAtomsStorage.java
index b3530789dd..5a09f62129 100644
--- a/src/java/com/android/internal/telephony/metrics/PersistAtomsStorage.java
+++ b/src/java/com/android/internal/telephony/metrics/PersistAtomsStorage.java
@@ -798,6 +798,9 @@ public class PersistAtomsStorage {
                     += stats.countOfIncomingDatagramTypeSmsSuccess;
             existingStats.countOfIncomingDatagramTypeSmsFail
                     += stats.countOfIncomingDatagramTypeSmsFail;
+            existingStats.carrierRoamingSatelliteConfigVersion =
+                    stats.carrierRoamingSatelliteConfigVersion;
+            existingStats.maxAllowedDataMode = stats.maxAllowedDataMode;
         } else {
             mAtoms.satelliteController = insertAtRandomPlace(mAtoms.satelliteController, stats,
                     mMaxNumSatelliteStats);
diff --git a/src/java/com/android/internal/telephony/metrics/SatelliteStats.java b/src/java/com/android/internal/telephony/metrics/SatelliteStats.java
index 2ccd8b5259..d399a393ba 100644
--- a/src/java/com/android/internal/telephony/metrics/SatelliteStats.java
+++ b/src/java/com/android/internal/telephony/metrics/SatelliteStats.java
@@ -112,6 +112,8 @@ public class SatelliteStats {
         private final int mCountOfOutgoingDatagramTypeSmsFail;
         private final int mCountOfIncomingDatagramTypeSmsSuccess;
         private final int mCountOfIncomingDatagramTypeSmsFail;
+        private static int sCarrierRoamingSatelliteConfigVersion;
+        private static int sMaxAllowedDataMode;
 
         private SatelliteControllerParams(Builder builder) {
             this.mCountOfSatelliteServiceEnablementsSuccess =
@@ -199,6 +201,16 @@ public class SatelliteStats {
             this.mCountOfIncomingDatagramTypeSmsSuccess =
                     builder.mCountOfIncomingDatagramTypeSmsSuccess;
             this.mCountOfIncomingDatagramTypeSmsFail = builder.mCountOfIncomingDatagramTypeSmsFail;
+
+            // carrier roaming satellite config version should be updated only when it's meaningful.
+            if (builder.mCarrierRoamingSatelliteConfigVersion.isPresent()) {
+                this.sCarrierRoamingSatelliteConfigVersion =
+                        builder.mCarrierRoamingSatelliteConfigVersion.get();
+            }
+            // max allowed data mode value should be updated only when it is meaningful.
+            if (builder.mMaxAllowedDataMode.isPresent()) {
+                this.sMaxAllowedDataMode = builder.mMaxAllowedDataMode.get();
+            }
         }
 
         public int getCountOfSatelliteServiceEnablementsSuccess() {
@@ -373,6 +385,14 @@ public class SatelliteStats {
             return mCountOfIncomingDatagramTypeSmsFail;
         }
 
+        public static int getCarrierRoamingSatelliteConfigVersion() {
+            return sCarrierRoamingSatelliteConfigVersion;
+        }
+
+        public static int getMaxAllowedDataMode() {
+            return sMaxAllowedDataMode;
+        }
+
         /**
          * A builder class to create {@link SatelliteControllerParams} data structure class
          */
@@ -420,6 +440,9 @@ public class SatelliteStats {
             private int mCountOfOutgoingDatagramTypeSmsFail;
             private int mCountOfIncomingDatagramTypeSmsSuccess;
             private int mCountOfIncomingDatagramTypeSmsFail;
+            private Optional<Integer> mCarrierRoamingSatelliteConfigVersion = Optional.empty();
+            private Optional<Integer> mMaxAllowedDataMode = Optional.empty();
+
 
             /**
              * Sets countOfSatelliteServiceEnablementsSuccess value of {@link SatelliteController}
@@ -848,6 +871,26 @@ public class SatelliteStats {
                 return this;
             }
 
+            /**
+             * Sets carrier roaming satellite config version of {@link SatelliteController} atom
+             * then returns Builder class
+             */
+            public Builder setCarrierRoamingSatelliteConfigVersion(
+                    int carrierRoamingSatelliteConfigVersion) {
+                this.mCarrierRoamingSatelliteConfigVersion =
+                        Optional.of(carrierRoamingSatelliteConfigVersion);
+                return this;
+            }
+
+            /**
+             * Sets max allowed data mode value of {@link SatelliteController} atom
+             * then returns Builder class
+             */
+            public Builder setMaxAllowedDataMode(int maxAllowedDataMode) {
+                this.mMaxAllowedDataMode = Optional.of(maxAllowedDataMode);
+                return this;
+            }
+
             /**
              * Returns ControllerParams, which contains whole component of
              * {@link SatelliteController} atom
@@ -918,6 +961,9 @@ public class SatelliteStats {
                     + ", countOfIncomingDatagramTypeSmsSuccess="
                     + mCountOfIncomingDatagramTypeSmsSuccess
                     + ", countOfIncomingDatagramTypeSmsFail=" + mCountOfIncomingDatagramTypeSmsFail
+                    + ", carrierRoamingSatelliteConfigVersion="
+                    + sCarrierRoamingSatelliteConfigVersion
+                    + ", maxAllowedDataMode=" + sMaxAllowedDataMode
                     + ")";
         }
     }
@@ -1887,6 +1933,19 @@ public class SatelliteStats {
         private final long mSatelliteDataConsumedBytes;
         private final boolean mIsMultiSim;
         private final boolean mIsNbIotNtn;
+        private final int mCountOfDataConnections;
+        private final int[] mLastFailCauses;
+        private final int mCountOfDataDisconnections;
+        private final int mCountOfDataStalls;
+        private final int mAverageUplinkBandwidthKbps;
+        private final int mAverageDownlinkBandwidthKbps;
+        private final int mMinUplinkBandwidthKbps;
+        private final int mMaxUplinkBandwidthKbps;
+        private final int mMinDownlinkBandwidthKbps;
+        private final int mMaxDownlinkBandwidthKbps;
+        private final String[] mSatelliteSupportedApps;
+        private final int[] mSatelliteSupportedUids;
+        private final long[] mPerAppSatelliteDataConsumedBytes;
 
         private CarrierRoamingSatelliteSessionParams(Builder builder) {
             this.mCarrierId = builder.mCarrierId;
@@ -1912,6 +1971,19 @@ public class SatelliteStats {
                     builder.mSatelliteDataConsumedBytes;
             this.mIsMultiSim = builder.mIsMultiSim;
             this.mIsNbIotNtn = builder.mIsNbIotNtn;
+            this.mCountOfDataConnections = builder.mCountOfDataConnections;
+            this.mLastFailCauses = builder.mLastFailCauses;
+            this.mCountOfDataDisconnections = builder.mCountOfDataDisconnections;
+            this.mCountOfDataStalls = builder.mCountOfDataStalls;
+            this.mAverageUplinkBandwidthKbps =  builder.mAverageUplinkBandwidthKbps;
+            this.mAverageDownlinkBandwidthKbps = builder.mAverageDownlinkBandwidthKbps;
+            this.mMinUplinkBandwidthKbps = builder.mMinUplinkBandwidthKbps;
+            this.mMaxUplinkBandwidthKbps = builder.mMaxUplinkBandwidthKbps;
+            this.mMinDownlinkBandwidthKbps = builder.mMinDownlinkBandwidthKbps;
+            this.mMaxDownlinkBandwidthKbps = builder.mMaxDownlinkBandwidthKbps;
+            this.mSatelliteSupportedApps = builder.mSatelliteSupportedApps;
+            this.mSatelliteSupportedUids = builder.mSatelliteSupportedUids;
+            this.mPerAppSatelliteDataConsumedBytes = builder.mPerAppSatelliteDataConsumedBytes;
         }
 
         public int getCarrierId() {
@@ -1998,6 +2070,58 @@ public class SatelliteStats {
             return mIsNbIotNtn;
         }
 
+        public int getCountOfDataConnections() {
+            return mCountOfDataConnections;
+        }
+
+        public int[] getLastFailCauses() {
+            return mLastFailCauses;
+        }
+
+        public int getCountOfDataDisconnections() {
+            return mCountOfDataDisconnections;
+        }
+
+        public int getCountOfDataStalls() {
+            return mCountOfDataStalls;
+        }
+
+        public int getAverageUplinkBandwidthKbps() {
+            return mAverageUplinkBandwidthKbps;
+        }
+
+        public int getAverageDownlinkBandwidthKbps() {
+            return mAverageDownlinkBandwidthKbps;
+        }
+
+        public int getMinimumUplinkBandwidthKbps() {
+            return mMinUplinkBandwidthKbps;
+        }
+
+        public int getMaximumUplinkBandwidthKbps() {
+            return mMaxUplinkBandwidthKbps;
+        }
+
+        public int getMinimumDownlinkBandwidthKbps() {
+            return mMinDownlinkBandwidthKbps;
+        }
+
+        public int getMaximumDownlinkBandwidthKbps() {
+            return mMaxDownlinkBandwidthKbps;
+        }
+
+        public String[] getSatelliteSupportedApps() {
+            return mSatelliteSupportedApps;
+        }
+
+        public int[] getSatelliteSupportedUids() {
+            return mSatelliteSupportedUids;
+        }
+
+        public long[] getPerAppSatelliteDataConsumedBytes() {
+            return mPerAppSatelliteDataConsumedBytes;
+        }
+
         /**
          * A builder class to create {@link CarrierRoamingSatelliteSessionParams} data structure
          * class
@@ -2025,6 +2149,20 @@ public class SatelliteStats {
             long mSatelliteDataConsumedBytes = 0L;
             private boolean mIsMultiSim = false;
             private boolean mIsNbIotNtn = false;
+            private int mCountOfDataConnections = 0;
+            private int[] mLastFailCauses = new int[5];
+            private int mCountOfDataDisconnections = 0;
+            private int mCountOfDataStalls = 0;
+            private int mAverageUplinkBandwidthKbps = 0;
+            private int mAverageDownlinkBandwidthKbps = 0;
+            private int mMinUplinkBandwidthKbps = Integer.MAX_VALUE;
+            private int mMaxUplinkBandwidthKbps = 0;
+            private int mMinDownlinkBandwidthKbps = Integer.MAX_VALUE;
+            private int mMaxDownlinkBandwidthKbps = 0;
+            private String[] mSatelliteSupportedApps = null;
+            private int[] mSatelliteSupportedUids = new int[5];
+            private long[] mPerAppSatelliteDataConsumedBytes = new long[]{0L};
+
 
             /**
              * Sets carrierId value of {@link CarrierRoamingSatelliteSession} atom
@@ -2228,6 +2366,125 @@ public class SatelliteStats {
                 this.mIsNbIotNtn = isNbIotNtn;
                 return this;
             }
+
+            /**
+             * Sets countOfDataConnections value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setCountOfDataConnections(int countOfDataConnections) {
+                this.mCountOfDataConnections = countOfDataConnections;
+                return this;
+            }
+
+            /**
+             * Sets lastFailCauses value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setLastFailCauses(int[] lastFailCauses) {
+                this.mLastFailCauses = lastFailCauses;
+                Arrays.sort(this.mLastFailCauses);
+                return this;
+            }
+
+            /**
+             * Sets countOfDataDisconnections value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setCountOfDataDisconnections(int countOfDataDisconnections) {
+                this.mCountOfDataDisconnections = countOfDataDisconnections;
+                return this;
+            }
+
+            /**
+             * Sets countOfDataStalls value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setCountOfDataStalls(int countOfDataStalls) {
+                this.mCountOfDataStalls = countOfDataStalls;
+                return this;
+            }
+
+            /**
+             * Sets averageUplinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setAverageUplinkBandwidthKbps(int averageUplinkBandwidthKbps) {
+                this.mAverageUplinkBandwidthKbps = averageUplinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets averageDownlinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setAverageDownlinkBandwidthKbps(int averageDownlinkBandwidthKbps) {
+                this.mAverageDownlinkBandwidthKbps = averageDownlinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets minUplinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setMinimumUplinkBandwidthKbps(int minUplinkBandwidthKbps) {
+                this.mMinUplinkBandwidthKbps = minUplinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets maxUplinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setMaximumUplinkBandwidthKbps(int maxUplinkBandwidthKbps) {
+                this.mMaxUplinkBandwidthKbps = maxUplinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets minDownlinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setMinimumDownlinkBandwidthKbps(int minDownlinkBandwidthKbps) {
+                this.mMinDownlinkBandwidthKbps = minDownlinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets maxUplinkBandwidth value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setMaximumDownlinkBandwidthKbps(int maxDownlinkBandwidthKbps) {
+                this.mMaxDownlinkBandwidthKbps = maxDownlinkBandwidthKbps;
+                return this;
+            }
+
+            /**
+             * Sets satelliteSupportedApps value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setSatelliteSupportedApps(String[] satelliteSupportedApps) {
+                this.mSatelliteSupportedApps = satelliteSupportedApps;
+                return this;
+            }
+
+            /**
+             * Sets satelliteSupportedUids value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setSatelliteSupportedUids(int[] satelliteSupportedUids) {
+                this.mSatelliteSupportedUids = satelliteSupportedUids;
+                return this;
+            }
+
+            /**
+             * Sets perAppSatelliteDataConsumedBytes value of {@link CarrierRoamingSatelliteSession}
+             * atom then returns Builder class
+             */
+            public Builder setPerAppSatelliteDataConsumedBytes(
+                    long[] perAppSatelliteDataConsumedBytes) {
+                this.mPerAppSatelliteDataConsumedBytes = perAppSatelliteDataConsumedBytes;
+                return this;
+            }
         }
 
         @Override
@@ -2255,6 +2512,20 @@ public class SatelliteStats {
                     + ", SatelliteDataConsumedBytes=" + mSatelliteDataConsumedBytes
                     + ", isMultiSim=" + mIsMultiSim
                     + ", isNbIotNtn=" + mIsNbIotNtn
+                    + ", countOfDataConnections=" + mCountOfDataConnections
+                    + ", lastFailCauses=" +  Arrays.toString(mLastFailCauses)
+                    + ", countOfDataDisconnections=" + mCountOfDataDisconnections
+                    + ", countOfDataStalls=" + mCountOfDataStalls
+                    + ", averageUplinkBandwidthKbps=" + mAverageUplinkBandwidthKbps
+                    + ", averageDownlinkBandwidthKbps=" + mAverageDownlinkBandwidthKbps
+                    + ", minUplinkBandwidthKbps=" + mMinUplinkBandwidthKbps
+                    + ", maxUplinkBandwidthKbps=" + mMaxUplinkBandwidthKbps
+                    + ", minDownlinkBandwidthKbps=" + mMinDownlinkBandwidthKbps
+                    + ", maxDownlinkBandwidthKbps=" + mMaxDownlinkBandwidthKbps
+                    + ", satelliteSupportedApps=" + Arrays.toString(mSatelliteSupportedApps)
+                    + ", satelliteSupportedUids=" + Arrays.toString(mSatelliteSupportedUids)
+                    + ", perAppSatelliteDataConsumedBytes=" + Arrays.toString(
+                    mPerAppSatelliteDataConsumedBytes)
                     + ")";
         }
     }
@@ -3087,6 +3358,10 @@ public class SatelliteStats {
         proto.countOfIncomingDatagramTypeSmsSuccess =
                 param.getCountOfIncomingDatagramTypeSmsSuccess();
         proto.countOfIncomingDatagramTypeSmsFail = param.getCountOfIncomingDatagramTypeSmsFail();
+        proto.carrierRoamingSatelliteConfigVersion =
+                param.getCarrierRoamingSatelliteConfigVersion();
+        proto.maxAllowedDataMode = param.getMaxAllowedDataMode();
+
         if (DBG) logd("onSatelliteControllerMetrics" + param);
         mAtomsStorage.addSatelliteControllerStats(proto);
     }
@@ -3206,6 +3481,19 @@ public class SatelliteStats {
         proto.satelliteDataConsumedBytes = param.mSatelliteDataConsumedBytes;
         proto.isMultiSim = param.isMultiSim();
         proto.isNbIotNtn = param.isNbIotNtn();
+        proto.countOfDataConnections = param.mCountOfDataConnections;
+        proto.lastFailCauses = param.mLastFailCauses;
+        proto.countOfDataDisconnections = param.mCountOfDataDisconnections;
+        proto.countOfDataStalls = param.mCountOfDataStalls;
+        proto.averageUplinkBandwidthKbps = param.mAverageUplinkBandwidthKbps;
+        proto.averageDownlinkBandwidthKbps = param.mAverageDownlinkBandwidthKbps;
+        proto.minUplinkBandwidthKbps = param.mMinUplinkBandwidthKbps;
+        proto.maxUplinkBandwidthKbps = param.mMaxUplinkBandwidthKbps;
+        proto.minDownlinkBandwidthKbps = param.mMinDownlinkBandwidthKbps;
+        proto.maxDownlinkBandwidthKbps = param.mMaxDownlinkBandwidthKbps;
+        proto.satelliteSupportedApps = param.mSatelliteSupportedApps;
+        proto.satelliteSupportedUids = param.mSatelliteSupportedUids;
+        proto.perAppSatelliteDataConsumedBytes = param.mPerAppSatelliteDataConsumedBytes;
         if (DBG) logd("onCarrierRoamingSatelliteSessionMetrics: " + param);
         mAtomsStorage.addCarrierRoamingSatelliteSessionStats(proto);
     }
diff --git a/src/java/com/android/internal/telephony/metrics/SmsStats.java b/src/java/com/android/internal/telephony/metrics/SmsStats.java
index fdbb20b25f..71de4a51d4 100644
--- a/src/java/com/android/internal/telephony/metrics/SmsStats.java
+++ b/src/java/com/android/internal/telephony/metrics/SmsStats.java
@@ -35,16 +35,21 @@ import static com.android.internal.telephony.TelephonyStatsLog.INCOMING_SMS__SMS
 import static com.android.internal.telephony.TelephonyStatsLog.INCOMING_SMS__SMS_TYPE__SMS_TYPE_VOICEMAIL_INDICATION;
 import static com.android.internal.telephony.TelephonyStatsLog.INCOMING_SMS__SMS_TYPE__SMS_TYPE_WAP_PUSH;
 import static com.android.internal.telephony.TelephonyStatsLog.INCOMING_SMS__SMS_TYPE__SMS_TYPE_ZERO;
+import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_GENERIC_FAILURE;
+import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_NETWORK_ERROR;
+import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_NONE;
 import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_ERROR;
 import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_ERROR_FALLBACK;
 import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_ERROR_RETRY;
 import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_SUCCESS;
 import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_UNKNOWN;
+import static com.android.internal.telephony.TelephonyStatsLog.OUTGOING_SMS__SMS_TECH__SMS_TECH_UNKNOWN;
 
 import android.annotation.Nullable;
 import android.app.Activity;
 import android.provider.Telephony.Sms.Intents;
 import android.telephony.Annotation.NetworkType;
+import android.telephony.AnomalyReporter;
 import android.telephony.ServiceState;
 import android.telephony.SmsManager;
 import android.telephony.TelephonyManager;
@@ -66,6 +71,7 @@ import com.android.telephony.Rlog;
 
 import java.util.Objects;
 import java.util.Random;
+import java.util.UUID;
 
 /** Collects sms events per phone ID for the pulled atom. */
 public class SmsStats {
@@ -76,6 +82,8 @@ public class SmsStats {
 
     /** 3GPP2 error for out of service: "Other radio interface problem" in N.S0005 Table 171 */
     private static final int NO_NETWORK_ERROR_3GPP2 = 66;
+    public static final UUID NTN_OUTGOING_SMS_ERROR_ANOMALY_UUID = UUID.fromString(
+            "bfd2a3d9-9f2c-4070-b9df-bdbb7f9c645a");
 
     private final Phone mPhone;
 
@@ -84,14 +92,16 @@ public class SmsStats {
 
     private static final Random RANDOM = new Random();
 
+
     public SmsStats(Phone phone) {
         mPhone = phone;
     }
 
     /** Create a new atom when multi-part incoming SMS is dropped due to missing parts. */
     public void onDroppedIncomingMultipartSms(boolean is3gpp2, int receivedCount, int totalCount,
-            boolean isEmergency) {
-        IncomingSms proto = getIncomingDefaultProto(is3gpp2, SOURCE_NOT_INJECTED, isEmergency);
+            boolean isEmergency, int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(is3gpp2, SOURCE_NOT_INJECTED, isEmergency,
+                pduLength);
         // Keep SMS tech as unknown because it's possible that it changed overtime and is not
         // necessarily the current one. Similarly mark the RAT as unknown.
         proto.smsTech = INCOMING_SMS__SMS_TECH__SMS_TECH_UNKNOWN;
@@ -104,22 +114,25 @@ public class SmsStats {
 
     /** Create a new atom when an SMS for the voicemail indicator is received. */
     public void onIncomingSmsVoicemail(boolean is3gpp2,
-            @InboundSmsHandler.SmsSource int smsSource) {
-        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, false);
+            @InboundSmsHandler.SmsSource int smsSource, int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, false, pduLength);
         proto.smsType = INCOMING_SMS__SMS_TYPE__SMS_TYPE_VOICEMAIL_INDICATION;
         mAtomsStorage.addIncomingSms(proto);
     }
 
     /** Create a new atom when an SMS of type zero is received. */
-    public void onIncomingSmsTypeZero(@InboundSmsHandler.SmsSource int smsSource) {
-        IncomingSms proto = getIncomingDefaultProto(false /* is3gpp2 */, smsSource, false);
+    public void onIncomingSmsTypeZero(@InboundSmsHandler.SmsSource int smsSource, int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(false /* is3gpp2 */, smsSource, false,
+                pduLength);
         proto.smsType = INCOMING_SMS__SMS_TYPE__SMS_TYPE_ZERO;
         mAtomsStorage.addIncomingSms(proto);
     }
 
     /** Create a new atom when an SMS-PP for the SIM card is received. */
-    public void onIncomingSmsPP(@InboundSmsHandler.SmsSource int smsSource, boolean success) {
-        IncomingSms proto = getIncomingDefaultProto(false /* is3gpp2 */, smsSource, false);
+    public void onIncomingSmsPP(@InboundSmsHandler.SmsSource int smsSource, boolean success,
+            int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(false /* is3gpp2 */, smsSource, false,
+                pduLength);
         proto.smsType = INCOMING_SMS__SMS_TYPE__SMS_TYPE_SMS_PP;
         proto.error = getIncomingSmsError(success);
         mAtomsStorage.addIncomingSms(proto);
@@ -128,8 +141,8 @@ public class SmsStats {
     /** Create a new atom when an SMS is received successfully. */
     public void onIncomingSmsSuccess(boolean is3gpp2,
             @InboundSmsHandler.SmsSource int smsSource, int messageCount,
-            boolean blocked, long messageId, boolean isEmergency) {
-        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, isEmergency);
+            boolean blocked, long messageId, boolean isEmergency, int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, isEmergency, pduLength);
         proto.totalParts = messageCount;
         proto.receivedParts = messageCount;
         proto.blocked = blocked;
@@ -139,16 +152,17 @@ public class SmsStats {
 
     /** Create a new atom when an incoming SMS has an error. */
     public void onIncomingSmsError(boolean is3gpp2,
-            @InboundSmsHandler.SmsSource int smsSource, int result, boolean isEmergency) {
-        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, isEmergency);
+            @InboundSmsHandler.SmsSource int smsSource, int result, boolean isEmergency,
+            int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(is3gpp2, smsSource, isEmergency, pduLength);
         proto.error = getIncomingSmsError(result);
         mAtomsStorage.addIncomingSms(proto);
     }
 
     /** Create a new atom when an incoming WAP_PUSH SMS is received. */
     public void onIncomingSmsWapPush(@InboundSmsHandler.SmsSource int smsSource,
-            int messageCount, int result, long messageId, boolean isEmergency) {
-        IncomingSms proto = getIncomingDefaultProto(false, smsSource, isEmergency);
+            int messageCount, int result, long messageId, boolean isEmergency, int pduLength) {
+        IncomingSms proto = getIncomingDefaultProto(false, smsSource, isEmergency, pduLength);
         proto.smsType = INCOMING_SMS__SMS_TYPE__SMS_TYPE_WAP_PUSH;
         proto.totalParts = messageCount;
         proto.receivedParts = messageCount;
@@ -160,19 +174,22 @@ public class SmsStats {
     /** Create a new atom when an outgoing SMS is sent. */
     public void onOutgoingSms(boolean isOverIms, boolean is3gpp2, boolean fallbackToCs,
             @SmsManager.Result int sendErrorCode, long messageId, boolean isFromDefaultApp,
-            long intervalMillis, boolean isEmergency, boolean isMtSmsPolling) {
+            long intervalMillis, boolean isEmergency, boolean isMtSmsPolling, int pduLength,
+            @Nullable String callingPackageName, int uid) {
         onOutgoingSms(isOverIms, is3gpp2, fallbackToCs, sendErrorCode, NO_ERROR_CODE,
-                messageId, isFromDefaultApp, intervalMillis, isEmergency, isMtSmsPolling);
+                messageId, isFromDefaultApp, intervalMillis, isEmergency, isMtSmsPolling,
+                pduLength, callingPackageName, uid);
     }
 
     /** Create a new atom when an outgoing SMS is sent. */
     public void onOutgoingSms(boolean isOverIms, boolean is3gpp2, boolean fallbackToCs,
             @SmsManager.Result int sendErrorCode, int networkErrorCode, long messageId,
             boolean isFromDefaultApp, long intervalMillis, boolean isEmergency,
-            boolean isMtSmsPolling) {
+            boolean isMtSmsPolling, int pduLength, @Nullable String callingPackageName, int uid) {
         OutgoingSms proto =
                 getOutgoingDefaultProto(is3gpp2, isOverIms, messageId, isFromDefaultApp,
-                        intervalMillis, isEmergency, isMtSmsPolling);
+                        intervalMillis, isEmergency, isMtSmsPolling, pduLength, callingPackageName,
+                        uid);
 
         // The field errorCode is used for up-to-Android-13 devices. From Android 14, sendErrorCode
         // and networkErrorCode will be used. The field errorCode will be deprecated when most
@@ -205,6 +222,7 @@ public class SmsStats {
         proto.networkErrorCode = networkErrorCode;
 
         mAtomsStorage.addOutgoingSms(proto);
+        reportNtnOutgoingSmsAnomaly(proto);
         CarrierRoamingSatelliteSessionStats sessionStats =
                 CarrierRoamingSatelliteSessionStats.getInstance(mPhone.getSubId());
         sessionStats.onOutgoingSms(mPhone.getSubId());
@@ -221,7 +239,7 @@ public class SmsStats {
 
     /** Creates a proto for a normal single-part {@code IncomingSms} with default values. */
     private IncomingSms getIncomingDefaultProto(boolean is3gpp2,
-            @InboundSmsHandler.SmsSource int smsSource, boolean isEmergency) {
+            @InboundSmsHandler.SmsSource int smsSource, boolean isEmergency, int pduLength) {
         IncomingSms proto = new IncomingSms();
         proto.smsFormat = getSmsFormat(is3gpp2);
         proto.smsTech = getSmsTech(smsSource, is3gpp2);
@@ -241,16 +259,17 @@ public class SmsStats {
         proto.messageId = RANDOM.nextLong();
         proto.count = 1;
         proto.isManagedProfile = mPhone.isManagedProfile();
-        proto.isNtn = isNonTerrestrialNetwork();
+        proto.isNtn = isInSatelliteModeForCarrierRoaming(mPhone);
         proto.isEmergency = isEmergency;
         proto.isNbIotNtn = isNbIotNtn(mPhone);
+        proto.pduLength = pduLength;
         return proto;
     }
 
     /** Create a proto for a normal {@code OutgoingSms} with default values. */
     private OutgoingSms getOutgoingDefaultProto(boolean is3gpp2, boolean isOverIms,
             long messageId, boolean isFromDefaultApp, long intervalMillis, boolean isEmergency,
-            boolean isMtSmsPolling) {
+            boolean isMtSmsPolling, int pduLength, @Nullable String callingPackageName, int uid) {
         OutgoingSms proto = new OutgoingSms();
         proto.smsFormat = getSmsFormat(is3gpp2);
         proto.smsTech = getSmsTech(isOverIms, is3gpp2);
@@ -272,9 +291,14 @@ public class SmsStats {
         proto.count = 1;
         proto.isManagedProfile = mPhone.isManagedProfile();
         proto.isEmergency = isEmergency;
-        proto.isNtn = isNonTerrestrialNetwork();
+        proto.isNtn = isInSatelliteModeForCarrierRoaming(mPhone);
         proto.isMtSmsPolling = isMtSmsPolling;
         proto.isNbIotNtn = isNbIotNtn(mPhone);
+        proto.pduLength = pduLength;
+        // package name will be reported only when the sms is sent via non-terrestrial network.
+        proto.callingPackageName = (isInSatelliteModeForCarrierRoaming(mPhone)
+                && callingPackageName != null) ? callingPackageName : "";
+        proto.appUid = uid;
         return proto;
     }
 
@@ -348,7 +372,8 @@ public class SmsStats {
     static int getSmsHashCode(OutgoingSms sms) {
         return Objects.hash(sms.smsFormat, sms.smsTech, sms.rat, sms.sendResult, sms.errorCode,
                 sms.isRoaming, sms.isFromDefaultApp, sms.simSlotIndex, sms.isMultiSim, sms.isEsim,
-                sms.carrierId, sms.isEmergency, sms.isNtn, sms.isMtSmsPolling, sms.isNbIotNtn);
+                sms.carrierId, sms.isEmergency, sms.isNtn, sms.isMtSmsPolling, sms.isNbIotNtn,
+                sms.pduLength, sms.callingPackageName, sms.appUid);
     }
 
     /**
@@ -359,7 +384,7 @@ public class SmsStats {
         return Objects.hash(sms.smsFormat, sms.smsTech, sms.rat, sms.smsType,
             sms.totalParts, sms.receivedParts, sms.blocked, sms.error,
                 sms.isRoaming, sms.simSlotIndex, sms.isMultiSim, sms.isEsim, sms.carrierId,
-                sms.isNtn, sms.isNbIotNtn);
+                sms.isNtn, sms.isNbIotNtn, sms.pduLength);
     }
 
     private int getPhoneId() {
@@ -413,20 +438,53 @@ public class SmsStats {
         return phone.getCarrierId();
     }
 
-    private boolean isNonTerrestrialNetwork() {
-        ServiceState ss = getServiceState();
-        if (ss != null) {
-            return ss.isUsingNonTerrestrialNetwork();
-        } else {
-            Rlog.e(TAG, "isNonTerrestrialNetwork(), ServiceState is null");
-            return false;
+    private void reportNtnOutgoingSmsAnomaly(OutgoingSms proto) {
+        if (!proto.isNtn && !proto.isNbIotNtn) {
+            return;
+        }
+
+        if (proto.sendResult == OUTGOING_SMS__SEND_RESULT__SMS_SEND_RESULT_SUCCESS) {
+            // Do not report anomaly if sendResult is success
+            return;
+        }
+
+        if (proto.errorCode == OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_NONE
+                && proto.smsTech != OUTGOING_SMS__SMS_TECH__SMS_TECH_UNKNOWN) {
+            // Only report anomaly for errorCode==ERROR_NONE when sms_tech is unknown.
+            return;
         }
+
+        // For NTN outgoing SMS, proto.errorCode == proto.networkErrorCode
+        switch (proto.errorCode) {
+            case OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_NONE:
+            case OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_NETWORK_ERROR:
+            case OUTGOING_SMS__SEND_ERROR_CODE__SMS_SEND_ERROR_GENERIC_FAILURE:
+            case SmsManager.SMS_RP_CAUSE_CONGESTION:
+            case SmsManager.SMS_RP_CAUSE_PROTOCOL_ERROR:
+                String message = "NTN Outgoing SMS failed";
+                Rlog.d(TAG, message + " with errorCode=" + proto.errorCode
+                        + " with sendResult=" + proto.sendResult + " smsTech=" + proto.smsTech);
+                AnomalyReporter.reportAnomaly(generateUUID(proto.errorCode, proto.sendResult),
+                        message, proto.carrierId);
+        }
+    }
+
+    private UUID generateUUID(int errorCode, int sendResult) {
+        long lerrorCode = errorCode;
+        long lsendResult = sendResult;
+        return new UUID(NTN_OUTGOING_SMS_ERROR_ANOMALY_UUID.getMostSignificantBits(),
+                NTN_OUTGOING_SMS_ERROR_ANOMALY_UUID.getLeastSignificantBits()
+                        + ((lsendResult << 32) + lerrorCode));
     }
 
     private boolean isNbIotNtn(Phone phone) {
         return SatelliteController.getInstance().isInCarrierRoamingNbIotNtn(phone);
     }
 
+    private boolean isInSatelliteModeForCarrierRoaming(Phone phone) {
+        return SatelliteController.getInstance().isInSatelliteModeForCarrierRoaming(phone);
+    }
+
     private void loge(String format, Object... args) {
         Rlog.e(TAG, "[" + mPhone.getPhoneId() + "]" + String.format(format, args));
     }
diff --git a/src/java/com/android/internal/telephony/satellite/DatagramController.java b/src/java/com/android/internal/telephony/satellite/DatagramController.java
index 05aef83188..9234a30c01 100644
--- a/src/java/com/android/internal/telephony/satellite/DatagramController.java
+++ b/src/java/com/android/internal/telephony/satellite/DatagramController.java
@@ -48,6 +48,9 @@ import com.android.internal.telephony.flags.FeatureFlags;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 
 /**
@@ -62,6 +65,7 @@ public class DatagramController {
     @NonNull private final PointingAppController mPointingAppController;
     @NonNull private final DatagramDispatcher mDatagramDispatcher;
     @NonNull private final DatagramReceiver mDatagramReceiver;
+    @Nullable private PersistentLogger mPersistentLogger = null;
 
     public static final long MAX_DATAGRAM_ID = (long) Math.pow(2, 16);
     public static final int ROUNDING_UNIT = 10;
@@ -79,47 +83,43 @@ public class DatagramController {
     private static final String ALLOW_MOCK_MODEM_PROPERTY = "persist.radio.allow_mock_modem";
     private static final boolean DEBUG = !"user".equals(Build.TYPE);
 
+    /** All the atomic variables are declared here. */
     /** Variables used to update onSendDatagramStateChanged(). */
-    private final Object mLock = new Object();
-    @GuardedBy("mLock")
-    private int mSendSubId;
-    @GuardedBy("mLock")
-    private @SatelliteManager.DatagramType int mDatagramType = DATAGRAM_TYPE_UNKNOWN;
-    @GuardedBy("mLock")
-    private @SatelliteManager.SatelliteDatagramTransferState int mSendDatagramTransferState =
-            SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE;
-    @GuardedBy("mLock")
-    private int mSendPendingCount = 0;
-    @GuardedBy("mLock")
-    private int mSendErrorCode = SatelliteManager.SATELLITE_RESULT_SUCCESS;
+    private AtomicInteger mSendSubId = new AtomicInteger(0);
+    private @SatelliteManager.DatagramType AtomicInteger mDatagramType =
+            new AtomicInteger(DATAGRAM_TYPE_UNKNOWN);
+    private @SatelliteManager.SatelliteDatagramTransferState AtomicInteger
+            mSendDatagramTransferState = new AtomicInteger(SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE);
+    private AtomicInteger mSendPendingCount = new AtomicInteger(0);
+    private AtomicInteger mSendErrorCode =
+            new AtomicInteger(SatelliteManager.SATELLITE_RESULT_SUCCESS);
     /** Variables used to update onReceiveDatagramStateChanged(). */
-    @GuardedBy("mLock")
-    private int mReceiveSubId;
-    @GuardedBy("mLock")
-    private @SatelliteManager.SatelliteDatagramTransferState int mReceiveDatagramTransferState =
-            SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE;
-    @GuardedBy("mLock")
-    private int mReceivePendingCount = 0;
-    @GuardedBy("mLock")
-    private int mReceiveErrorCode = SatelliteManager.SATELLITE_RESULT_SUCCESS;
+    private AtomicInteger mReceiveSubId = new AtomicInteger(0);
+    private @SatelliteManager.SatelliteDatagramTransferState AtomicInteger
+            mReceiveDatagramTransferState = new AtomicInteger(
+                    SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE);
+    private AtomicInteger mReceivePendingCount = new AtomicInteger(0);
+    private AtomicInteger mReceiveErrorCode =
+            new AtomicInteger(SatelliteManager.SATELLITE_RESULT_SUCCESS);
+    private AtomicBoolean mIsDemoMode = new AtomicBoolean(false);
+    private AtomicLong mAlignTimeoutDuration = new AtomicLong(SATELLITE_ALIGN_TIMEOUT);
+    private AtomicLong mDatagramWaitTimeForConnectedState = new AtomicLong(0);
+    private AtomicLong mModemImageSwitchingDuration = new AtomicLong(0);
+    private AtomicBoolean mWaitForDeviceAlignmentInDemoDatagram = new AtomicBoolean(false);
+    private AtomicLong mDatagramWaitTimeForConnectedStateForLastMessage = new AtomicLong(0);
+    @SatelliteManager.SatelliteModemState
+    private AtomicInteger mSatelltieModemState =
+            new AtomicInteger(SatelliteManager.SATELLITE_MODEM_STATE_UNKNOWN);
+
+    /** All the variables protected by lock are declared here. */
+    private final Object mLock = new Object();
     @GuardedBy("mLock")
     private final List<SatelliteDatagram> mDemoModeDatagramList;
-    private boolean mIsDemoMode = false;
-    private long mAlignTimeoutDuration = SATELLITE_ALIGN_TIMEOUT;
-    private long mDatagramWaitTimeForConnectedState;
-    private long mModemImageSwitchingDuration;
-    private boolean mWaitForDeviceAlignmentInDemoDatagram;
-    private long mDatagramWaitTimeForConnectedStateForLastMessage;
-    @GuardedBy("mLock")
-    @SatelliteManager.SatelliteModemState
-    private int mSatelltieModemState = SatelliteManager.SATELLITE_MODEM_STATE_UNKNOWN;
-    @Nullable
-    private PersistentLogger mPersistentLogger = null;
 
     /**
      * @return The singleton instance of DatagramController.
      */
-    public static DatagramController getInstance() {
+    static DatagramController getInstance() {
         if (sInstance == null) {
             loge("DatagramController was not yet initialized.");
         }
@@ -135,7 +135,7 @@ public class DatagramController {
      *                              PointingApp about datagram transfer state changes.
      * @return The singleton instance of DatagramController.
      */
-    public static DatagramController make(@NonNull Context context, @NonNull Looper looper,
+    static DatagramController make(@NonNull Context context, @NonNull Looper looper,
             @NonNull FeatureFlags featureFlags,
             @NonNull PointingAppController pointingAppController) {
         if (sInstance == null) {
@@ -155,7 +155,7 @@ public class DatagramController {
      *                              about datagram transfer state changes.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    public DatagramController(@NonNull Context context, @NonNull Looper  looper,
+    protected DatagramController(@NonNull Context context, @NonNull Looper  looper,
             @NonNull FeatureFlags featureFlags,
             @NonNull PointingAppController pointingAppController) {
         mContext = context;
@@ -172,12 +172,12 @@ public class DatagramController {
         mDatagramReceiver = DatagramReceiver.make(
                 mContext, looper, mFeatureFlags, this);
 
-        mDatagramWaitTimeForConnectedState = getDatagramWaitForConnectedStateTimeoutMillis();
-        mModemImageSwitchingDuration = getSatelliteModemImageSwitchingDurationMillis();
-        mWaitForDeviceAlignmentInDemoDatagram =
-                getWaitForDeviceAlignmentInDemoDatagramFromResources();
-        mDatagramWaitTimeForConnectedStateForLastMessage =
-                getDatagramWaitForConnectedStateForLastMessageTimeoutMillis();
+        mDatagramWaitTimeForConnectedState.set(getDatagramWaitForConnectedStateTimeoutMillis());
+        mModemImageSwitchingDuration.set(getSatelliteModemImageSwitchingDurationMillis());
+        mWaitForDeviceAlignmentInDemoDatagram.set(
+                getWaitForDeviceAlignmentInDemoDatagramFromResources());
+        mDatagramWaitTimeForConnectedStateForLastMessage.set(
+                getDatagramWaitForConnectedStateForLastMessageTimeoutMillis());
         mDemoModeDatagramList = new ArrayList<>();
         mPersistentLogger = SatelliteServiceUtils.getPersistentLogger(context);
     }
@@ -190,7 +190,8 @@ public class DatagramController {
      *
      * @return The {@link SatelliteManager.SatelliteResult} result of the operation.
      */
-    @SatelliteManager.SatelliteResult public int registerForSatelliteDatagram(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    @SatelliteManager.SatelliteResult protected int registerForSatelliteDatagram(int subId,
             @NonNull ISatelliteDatagramCallback callback) {
         return mDatagramReceiver.registerForSatelliteDatagram(subId, callback);
     }
@@ -203,7 +204,8 @@ public class DatagramController {
      * @param callback The callback that was passed to
      *                 {@link #registerForSatelliteDatagram(int, ISatelliteDatagramCallback)}.
      */
-    public void unregisterForSatelliteDatagram(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void unregisterForSatelliteDatagram(int subId,
             @NonNull ISatelliteDatagramCallback callback) {
         mDatagramReceiver.unregisterForSatelliteDatagram(subId, callback);
     }
@@ -219,7 +221,8 @@ public class DatagramController {
      * @param subId The subId of the subscription used for receiving datagrams.
      * @param callback The callback to get {@link SatelliteManager.SatelliteResult} of the request.
      */
-    public void pollPendingSatelliteDatagrams(int subId, @NonNull Consumer<Integer> callback) {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void pollPendingSatelliteDatagrams(int subId, @NonNull Consumer<Integer> callback) {
         plogd("pollPendingSatelliteDatagrams");
         mDatagramReceiver.pollPendingSatelliteDatagrams(subId, callback);
     }
@@ -243,7 +246,8 @@ public class DatagramController {
      *                                 full screen mode.
      * @param callback The callback to get {@link SatelliteManager.SatelliteResult} of the request.
      */
-    public void sendSatelliteDatagram(int subId, @SatelliteManager.DatagramType int datagramType,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void sendSatelliteDatagram(int subId, @SatelliteManager.DatagramType int datagramType,
             @NonNull SatelliteDatagram datagram, boolean needFullScreenPointingUI,
             @NonNull Consumer<Integer> callback) {
         mDatagramDispatcher.sendSatelliteDatagram(subId, datagramType, datagram,
@@ -258,45 +262,44 @@ public class DatagramController {
      * @param datagramTransferState The new send datagram transfer state.
      * @param sendPendingCount number of datagrams that are currently being sent
      * @param errorCode If datagram transfer failed, the reason for failure.
+     *
+     * This method is only used by {@link DatagramDispatcher}.
      */
-    public void updateSendStatus(int subId, @SatelliteManager.DatagramType int datagramType,
+    @VisibleForTesting(visibility =  VisibleForTesting.Visibility.PACKAGE)
+    protected void updateSendStatus(int subId, @SatelliteManager.DatagramType int datagramType,
             @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
             int sendPendingCount, int errorCode) {
-        synchronized (mLock) {
-            plogd("updateSendStatus"
-                    + " subId: " + subId
-                    + " datagramType: " + datagramType
-                    + " datagramTransferState: " + datagramTransferState
-                    + " sendPendingCount: " + sendPendingCount + " errorCode: " + errorCode);
-            if (shouldSuppressDatagramTransferStateUpdate(datagramType)) {
-                plogd("Ignore the request to update send status");
-                return;
-            }
-
-            mSendSubId = subId;
-            mDatagramType = datagramType;
-            mSendDatagramTransferState = datagramTransferState;
-            mSendPendingCount = sendPendingCount;
-            mSendErrorCode = errorCode;
-            notifyDatagramTransferStateChangedToSessionController(mDatagramType);
-            mPointingAppController.updateSendDatagramTransferState(mSendSubId, mDatagramType,
-                    mSendDatagramTransferState, mSendPendingCount, mSendErrorCode);
-            retryPollPendingDatagramsInDemoMode();
+        plogd("updateSendStatus"
+                + " subId: " + subId
+                + " datagramType: " + datagramType
+                + " datagramTransferState: " + datagramTransferState
+                + " sendPendingCount: " + sendPendingCount + " errorCode: " + errorCode);
+        if (shouldSuppressDatagramTransferStateUpdate(datagramType)) {
+            plogd("Ignore the request to update send status");
+            return;
         }
+
+        mSendSubId.set(subId);
+        mDatagramType.set(datagramType);
+        mSendDatagramTransferState.set(datagramTransferState);
+        mSendPendingCount.set(sendPendingCount);
+        mSendErrorCode.set(errorCode);
+        notifyDatagramTransferStateChangedToSessionController(datagramType);
+        mPointingAppController.updateSendDatagramTransferState(subId, datagramType,
+                datagramTransferState, sendPendingCount, errorCode);
+        retryPollPendingDatagramsInDemoMode();
     }
 
     private boolean shouldSuppressDatagramTransferStateUpdate(
             @SatelliteManager.DatagramType int datagramType) {
-        synchronized (mLock) {
-            if (!SatelliteController.getInstance().isSatelliteAttachRequired()) {
-                return false;
-            }
-            if (datagramType == DATAGRAM_TYPE_KEEP_ALIVE
-                    && mSatelltieModemState == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
-                return true;
-            }
+        if (!SatelliteController.getInstance().isSatelliteAttachRequired()) {
             return false;
         }
+        if (datagramType == DATAGRAM_TYPE_KEEP_ALIVE
+                && mSatelltieModemState.get() == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
+            return true;
+        }
+        return false;
     }
 
     /**
@@ -306,28 +309,29 @@ public class DatagramController {
      * @param datagramTransferState The new receive datagram transfer state.
      * @param receivePendingCount The number of datagrams that are currently pending to be received.
      * @param errorCode If datagram transfer failed, the reason for failure.
+     *
+     * This method is only used by {@link DatagramReceiver}.
      */
-    public void updateReceiveStatus(int subId, @SatelliteManager.DatagramType int datagramType,
+    @VisibleForTesting(visibility =  VisibleForTesting.Visibility.PACKAGE)
+    protected void updateReceiveStatus(int subId, @SatelliteManager.DatagramType int datagramType,
             @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
             int receivePendingCount, int errorCode) {
-        synchronized (mLock) {
-            plogd("updateReceiveStatus"
-                    + " subId: " + subId
-                    + " datagramType: " + datagramType
-                    + " datagramTransferState: " + datagramTransferState
-                    + " receivePendingCount: " + receivePendingCount + " errorCode: " + errorCode);
-
-            mReceiveSubId = subId;
-            mDatagramType = datagramType;
-            mReceiveDatagramTransferState = datagramTransferState;
-            mReceivePendingCount = receivePendingCount;
-            mReceiveErrorCode = errorCode;
-
-            notifyDatagramTransferStateChangedToSessionController(mDatagramType);
-            mPointingAppController.updateReceiveDatagramTransferState(mReceiveSubId,
-                    mReceiveDatagramTransferState, mReceivePendingCount, mReceiveErrorCode);
-            retryPollPendingDatagramsInDemoMode();
-        }
+        plogd("updateReceiveStatus"
+                + " subId: " + subId
+                + " datagramType: " + datagramType
+                + " datagramTransferState: " + datagramTransferState
+                + " receivePendingCount: " + receivePendingCount + " errorCode: " + errorCode);
+
+        mReceiveSubId.set(subId);
+        mDatagramType.set(datagramType);
+        mReceiveDatagramTransferState.set(datagramTransferState);
+        mReceivePendingCount.set(receivePendingCount);
+        mReceiveErrorCode.set(errorCode);
+
+        notifyDatagramTransferStateChangedToSessionController(datagramType);
+        mPointingAppController.updateReceiveDatagramTransferState(subId,
+                datagramTransferState, receivePendingCount, errorCode);
+        retryPollPendingDatagramsInDemoMode();
 
         if (isPollingInIdleState()) {
             mDatagramDispatcher.retrySendingDatagrams();
@@ -338,13 +342,15 @@ public class DatagramController {
      * Return receive pending datagram count
      * @return receive pending datagram count.
      */
-    public int getReceivePendingCount() {
-        return mReceivePendingCount;
+    @VisibleForTesting(visibility =  VisibleForTesting.Visibility.PACKAGE)
+    protected int getReceivePendingCount() {
+        return mReceivePendingCount.get();
     }
 
 
     /** @return {@code true} if already sent an emergency datagram during a session. */
-    public boolean isEmergencyCommunicationEstablished() {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected boolean isEmergencyCommunicationEstablished() {
         return mDatagramDispatcher.isEmergencyCommunicationEstablished();
     }
 
@@ -354,10 +360,9 @@ public class DatagramController {
      *
      * @param state Current satellite modem state.
      */
-    public void onSatelliteModemStateChanged(@SatelliteManager.SatelliteModemState int state) {
-        synchronized (mLock) {
-            mSatelltieModemState = state;
-        }
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void onSatelliteModemStateChanged(@SatelliteManager.SatelliteModemState int state) {
+        mSatelltieModemState.set(state);
         mDatagramDispatcher.onSatelliteModemStateChanged(state);
         mDatagramReceiver.onSatelliteModemStateChanged(state);
     }
@@ -367,7 +372,7 @@ public class DatagramController {
      *
      * @param subId The subId of the subscription used to receive SMS
      */
-    public void onSmsReceived(int subId) {
+    void onSmsReceived(int subId) {
         // To keep exist notification flow, need to call with each state.
         updateReceiveStatus(subId, SatelliteManager.DATAGRAM_TYPE_SMS,
                 SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVING,
@@ -384,7 +389,7 @@ public class DatagramController {
      * Set whether the device is aligned with the satellite.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public void setDeviceAlignedWithSatellite(boolean isAligned) {
+    protected void setDeviceAlignedWithSatellite(boolean isAligned) {
         mDatagramDispatcher.setDeviceAlignedWithSatellite(isAligned);
         mDatagramReceiver.setDeviceAlignedWithSatellite(isAligned);
         if (isAligned) {
@@ -392,12 +397,10 @@ public class DatagramController {
         }
     }
 
-    @VisibleForTesting
-    public boolean isReceivingDatagrams() {
-        synchronized (mLock) {
-            return (mReceiveDatagramTransferState
-                    == SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVING);
-        }
+    @VisibleForTesting(visibility =  VisibleForTesting.Visibility.PACKAGE)
+    protected boolean isReceivingDatagrams() {
+        return mReceiveDatagramTransferState.get()
+                == SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVING;
     }
 
     /**
@@ -405,45 +408,44 @@ public class DatagramController {
      * before transferring datagrams via satellite.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public boolean needsWaitingForSatelliteConnected(
+    protected boolean needsWaitingForSatelliteConnected(
             @SatelliteManager.DatagramType int datagramType) {
-        synchronized (mLock) {
-            if (!SatelliteController.getInstance().isSatelliteAttachRequired()) {
-                return false;
-            }
-            if (datagramType == DATAGRAM_TYPE_KEEP_ALIVE
-                    && mSatelltieModemState == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
-                return false;
-            }
-            boolean allowCheckMessageInNotConnected =
-                    mContext.getResources().getBoolean(
-                            R.bool.config_satellite_allow_check_message_in_not_connected);
-            if (datagramType == DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS
-                    && mSatelltieModemState == SATELLITE_MODEM_STATE_NOT_CONNECTED
-                    && allowCheckMessageInNotConnected
-                    && mFeatureFlags.carrierRoamingNbIotNtn()) {
-                return false;
-            }
-            if (mSatelltieModemState != SATELLITE_MODEM_STATE_CONNECTED
-                    && mSatelltieModemState != SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING) {
-                return true;
-            }
+        if (!SatelliteController.getInstance().isSatelliteAttachRequired()) {
             return false;
         }
-    }
 
-    public boolean isSendingInIdleState() {
-        synchronized (mLock) {
-            return (mSendDatagramTransferState
-                    == SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE);
+        int satelliteModemState = mSatelltieModemState.get();
+        plogd("needsWaitingForSatelliteConnected: datagramType=" + datagramType
+                + " satelliteModemState=" + satelliteModemState);
+
+        if (datagramType == DATAGRAM_TYPE_KEEP_ALIVE
+                && satelliteModemState == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
+            return false;
+        }
+        boolean allowCheckMessageInNotConnected =
+                mContext.getResources().getBoolean(
+                        R.bool.config_satellite_allow_check_message_in_not_connected);
+        if (datagramType == DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS
+                && satelliteModemState == SATELLITE_MODEM_STATE_NOT_CONNECTED
+                && allowCheckMessageInNotConnected
+                && mFeatureFlags.carrierRoamingNbIotNtn()) {
+            return false;
         }
+        if (satelliteModemState != SATELLITE_MODEM_STATE_CONNECTED
+                && satelliteModemState != SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING) {
+            return true;
+        }
+        return false;
     }
 
-    public boolean isPollingInIdleState() {
-        synchronized (mLock) {
-            return (mReceiveDatagramTransferState
-                    == SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE);
-        }
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected boolean isSendingInIdleState() {
+        return mSendDatagramTransferState.get() == SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE;
+    }
+
+    @VisibleForTesting(visibility =  VisibleForTesting.Visibility.PACKAGE)
+    protected boolean isPollingInIdleState() {
+        return mReceiveDatagramTransferState.get() == SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE;
     }
 
     /**
@@ -451,8 +453,8 @@ public class DatagramController {
      * @param isDemoMode {@code true} means demo mode is on, {@code false} otherwise.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public void setDemoMode(boolean isDemoMode) {
-        mIsDemoMode = isDemoMode;
+    protected void setDemoMode(boolean isDemoMode) {
+        mIsDemoMode.set(isDemoMode);
         mDatagramDispatcher.setDemoMode(isDemoMode);
         mDatagramReceiver.setDemoMode(isDemoMode);
 
@@ -462,13 +464,13 @@ public class DatagramController {
             }
             setDeviceAlignedWithSatellite(false);
         }
-        plogd("setDemoMode: mIsDemoMode=" + mIsDemoMode);
+        plogd("setDemoMode: mIsDemoMode=" + isDemoMode);
     }
 
     /** Get the last sent datagram for demo mode */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public SatelliteDatagram popDemoModeDatagram() {
-        if (!mIsDemoMode) {
+    protected SatelliteDatagram popDemoModeDatagram() {
+        if (!mIsDemoMode.get()) {
             return null;
         }
 
@@ -486,9 +488,9 @@ public class DatagramController {
      * @param datagram datagram The last datagram saved when sendSatelliteDatagramForDemo is called
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public void pushDemoModeDatagram(@SatelliteManager.DatagramType int datagramType,
+    protected void pushDemoModeDatagram(@SatelliteManager.DatagramType int datagramType,
             SatelliteDatagram datagram) {
-        if (mIsDemoMode && SatelliteServiceUtils.isSosMessage(datagramType)) {
+        if (mIsDemoMode.get() && SatelliteServiceUtils.isSosMessage(datagramType)) {
             synchronized (mLock) {
                 mDemoModeDatagramList.add(datagram);
                 plogd("pushDemoModeDatagram size=" + mDemoModeDatagramList.size());
@@ -497,22 +499,22 @@ public class DatagramController {
     }
 
     long getSatelliteAlignedTimeoutDuration() {
-        return mAlignTimeoutDuration;
+        return mAlignTimeoutDuration.get();
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public long getDatagramWaitTimeForConnectedState(boolean isLastSosMessage) {
-        synchronized (mLock) {
-            long timeout = isLastSosMessage ? mDatagramWaitTimeForConnectedStateForLastMessage :
-                    mDatagramWaitTimeForConnectedState;
-            logd("getDatagramWaitTimeForConnectedState: isLastSosMessage=" + isLastSosMessage
-                    + ", timeout=" + timeout + ", modemState=" + mSatelltieModemState);
-            if (mSatelltieModemState == SATELLITE_MODEM_STATE_OFF
-                    || mSatelltieModemState == SATELLITE_MODEM_STATE_IDLE) {
-                return (timeout + mModemImageSwitchingDuration);
-            }
-            return timeout;
+    protected long getDatagramWaitTimeForConnectedState(boolean isLastSosMessage) {
+        long timeout = isLastSosMessage
+                ? mDatagramWaitTimeForConnectedStateForLastMessage.get()
+                : mDatagramWaitTimeForConnectedState.get();
+        int satelliteModemState = mSatelltieModemState.get();
+        logd("getDatagramWaitTimeForConnectedState: isLastSosMessage=" + isLastSosMessage
+                + ", timeout=" + timeout + ", modemState=" + satelliteModemState);
+        if (satelliteModemState == SATELLITE_MODEM_STATE_OFF
+                || satelliteModemState == SATELLITE_MODEM_STATE_IDLE) {
+            return (timeout + mModemImageSwitchingDuration.get());
         }
+        return timeout;
     }
 
     /**
@@ -532,18 +534,18 @@ public class DatagramController {
                 + ", reset=" + reset + ", timeoutType=" + timeoutType);
         if (timeoutType == TIMEOUT_TYPE_ALIGN) {
             if (reset) {
-                mAlignTimeoutDuration = SATELLITE_ALIGN_TIMEOUT;
+                mAlignTimeoutDuration.set(SATELLITE_ALIGN_TIMEOUT);
             } else {
-                mAlignTimeoutDuration = timeoutMillis;
+                mAlignTimeoutDuration.set(timeoutMillis);
             }
         } else if (timeoutType == TIMEOUT_TYPE_DATAGRAM_WAIT_FOR_CONNECTED_STATE) {
             if (reset) {
-                mDatagramWaitTimeForConnectedState =
-                        getDatagramWaitForConnectedStateTimeoutMillis();
-                mModemImageSwitchingDuration = getSatelliteModemImageSwitchingDurationMillis();
+                mDatagramWaitTimeForConnectedState.set(
+                        getDatagramWaitForConnectedStateTimeoutMillis());
+                mModemImageSwitchingDuration.set(getSatelliteModemImageSwitchingDurationMillis());
             } else {
-                mDatagramWaitTimeForConnectedState = timeoutMillis;
-                mModemImageSwitchingDuration = 0;
+                mDatagramWaitTimeForConnectedState.set(timeoutMillis);
+                mModemImageSwitchingDuration.set(0);
             }
         } else if (timeoutType == TIMEOUT_TYPE_WAIT_FOR_DATAGRAM_SENDING_RESPONSE) {
             mDatagramDispatcher.setWaitTimeForDatagramSendingResponse(reset, timeoutMillis);
@@ -574,10 +576,10 @@ public class DatagramController {
                 + ", reset=" + reset + ", enable=" + enable);
         if (booleanType == BOOLEAN_TYPE_WAIT_FOR_DEVICE_ALIGNMENT_IN_DEMO_DATAGRAM) {
             if (reset) {
-                mWaitForDeviceAlignmentInDemoDatagram =
-                        getWaitForDeviceAlignmentInDemoDatagramFromResources();
+                mWaitForDeviceAlignmentInDemoDatagram.set(
+                        getWaitForDeviceAlignmentInDemoDatagramFromResources());
             } else {
-                mWaitForDeviceAlignmentInDemoDatagram = enable;
+                mWaitForDeviceAlignmentInDemoDatagram.set(enable);
             }
         } else {
             loge("Invalid boolean type " + booleanType);
@@ -596,10 +598,8 @@ public class DatagramController {
             ploge("notifyDatagramTransferStateChangeToSessionController: SatelliteSessionController"
                     + " is not initialized yet");
         } else {
-            synchronized (mLock) {
-                sessionController.onDatagramTransferStateChanged(
-                        mSendDatagramTransferState, mReceiveDatagramTransferState, datagramType);
-            }
+            sessionController.onDatagramTransferStateChanged(mSendDatagramTransferState.get(),
+                    mReceiveDatagramTransferState.get(), datagramType);
         }
     }
 
@@ -631,21 +631,25 @@ public class DatagramController {
     }
 
     private void retryPollPendingDatagramsInDemoMode() {
-        synchronized (mLock) {
-            if (mIsDemoMode && isSendingInIdleState() && isPollingInIdleState()
-                    && !mDemoModeDatagramList.isEmpty()) {
-                Consumer<Integer> internalCallback = new Consumer<Integer>() {
-                    @Override
-                    public void accept(Integer result) {
-                        if (result != SATELLITE_RESULT_SUCCESS) {
-                            plogd("retryPollPendingDatagramsInDemoMode result: " + result);
-                        }
+        if (mIsDemoMode.get() && isSendingInIdleState() && isPollingInIdleState()
+                && !isDemoModeDatagramListEmpty()) {
+            Consumer<Integer> internalCallback = new Consumer<Integer>() {
+                @Override
+                public void accept(Integer result) {
+                    if (result != SATELLITE_RESULT_SUCCESS) {
+                        plogd("retryPollPendingDatagramsInDemoMode result: " + result);
                     }
-                };
-                pollPendingSatelliteDatagrams(
-                        SatelliteController.getInstance().getSelectedSatelliteSubId(),
-                        internalCallback);
-            }
+                }
+            };
+            pollPendingSatelliteDatagrams(
+                    SatelliteController.getInstance().getSelectedSatelliteSubId(),
+                    internalCallback);
+        }
+    }
+
+    private boolean isDemoModeDatagramListEmpty() {
+        synchronized (mLock) {
+            return mDemoModeDatagramList.isEmpty();
         }
     }
 
@@ -657,7 +661,7 @@ public class DatagramController {
      * and it is required to wait for alignment else {@code false}
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public boolean waitForAligningToSatellite(boolean isAligned) {
+    protected boolean waitForAligningToSatellite(boolean isAligned) {
         if (isAligned) {
             return false;
         }
@@ -666,7 +670,7 @@ public class DatagramController {
     }
 
     private boolean getWaitForDeviceAlignmentInDemoDatagram() {
-        return mWaitForDeviceAlignmentInDemoDatagram;
+        return mWaitForDeviceAlignmentInDemoDatagram.get();
     }
 
     private boolean getWaitForDeviceAlignmentInDemoDatagramFromResources() {
diff --git a/src/java/com/android/internal/telephony/satellite/DatagramDispatcher.java b/src/java/com/android/internal/telephony/satellite/DatagramDispatcher.java
index dc6be3a5d5..e6507eea85 100644
--- a/src/java/com/android/internal/telephony/satellite/DatagramDispatcher.java
+++ b/src/java/com/android/internal/telephony/satellite/DatagramDispatcher.java
@@ -61,6 +61,7 @@ import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 
@@ -81,33 +82,47 @@ public class DatagramDispatcher extends Handler {
     private static final int EVENT_SEND_SMS_DONE = 9;
     private static final int EVENT_MT_SMS_POLLING_THROTTLE_TIMED_OUT = 10;
     private static final int CMD_SEND_MT_SMS_POLLING_MESSAGE = 11;
+    private static final int EVENT_SATELLITE_MODEM_STATE_CHANGED = 12;
 
     private static final Long TIMEOUT_DATAGRAM_DELAY_IN_DEMO_MODE = TimeUnit.SECONDS.toMillis(10);
+
+    /** All the variables initialized inside the constructor are declared here. */
     @NonNull private static DatagramDispatcher sInstance;
     @NonNull private final Context mContext;
     @NonNull private final DatagramController mDatagramController;
     @NonNull private final ControllerMetricsStats mControllerMetricsStats;
     @NonNull private final SessionMetricsStats mSessionMetricsStats;
     @NonNull private final FeatureFlags mFeatureFlags;
+    @Nullable private PersistentLogger mPersistentLogger = null;
 
-    private boolean mIsDemoMode = false;
-    private boolean mIsAligned = false;
-    private DatagramDispatcherHandlerRequest mSendSatelliteDatagramRequest = null;
-
+    /** All the atomic variables are declared here. */
+    private AtomicBoolean mIsDemoMode = new AtomicBoolean(false);
+    private AtomicBoolean mIsAligned = new AtomicBoolean(false);
     private static AtomicLong mNextDatagramId = new AtomicLong(0);
-
     private AtomicBoolean mShouldSendDatagramToModemInDemoMode = null;
-
-    private final Object mLock = new Object();
-    private long mDemoTimeoutDuration = TIMEOUT_DATAGRAM_DELAY_IN_DEMO_MODE;
-
+    private AtomicLong mDemoTimeoutDuration = new AtomicLong(TIMEOUT_DATAGRAM_DELAY_IN_DEMO_MODE);
     /** {@code true} if already sent an emergency datagram during a session */
-    @GuardedBy("mLock")
-    private boolean mIsEmergencyCommunicationEstablished = false;
+    private AtomicBoolean mIsEmergencyCommunicationEstablished = new AtomicBoolean(false);
+    private AtomicBoolean mSendingInProgress = new AtomicBoolean(false);
+    private AtomicLong mWaitTimeForDatagramSendingResponse = new AtomicLong(0);
+    private AtomicLong mWaitTimeForDatagramSendingForLastMessageResponse = new AtomicLong(0);
+    @SatelliteManager.DatagramType
+    private AtomicInteger mLastSendRequestDatagramType = new AtomicInteger(DATAGRAM_TYPE_UNKNOWN);
+    private AtomicInteger mModemState = new AtomicInteger(SATELLITE_MODEM_STATE_UNKNOWN);
+    private AtomicBoolean mHasEnteredConnectedState = new AtomicBoolean(false);
+    private AtomicBoolean mShouldPollMtSms = new AtomicBoolean(false);
+    private AtomicBoolean mIsMtSmsPollingThrottled = new AtomicBoolean(false);
+    private AtomicInteger mConnectedStateCounter = new AtomicInteger(0);
+    private AtomicLong mSmsTransmissionStartTime = new AtomicLong(0);
 
-    @GuardedBy("mLock")
-    private boolean mSendingInProgress;
+    /**
+     * All the variables declared here should only be accessed by methods that run inside the
+     * handler thread.
+     */
+    private DatagramDispatcherHandlerRequest mSendSatelliteDatagramRequest = null;
 
+    /** All the variables that require lock are declared here. */
+    private final Object mLock = new Object();
     /**
      * Map key: datagramId, value: SendSatelliteDatagramArgument to retry sending emergency
      * datagrams.
@@ -115,7 +130,6 @@ public class DatagramDispatcher extends Handler {
     @GuardedBy("mLock")
     private final LinkedHashMap<Long, SendSatelliteDatagramArgument>
             mPendingEmergencyDatagramsMap = new LinkedHashMap<>();
-
     /**
      * Map key: datagramId, value: SendSatelliteDatagramArgument to retry sending non-emergency
      * datagrams.
@@ -123,7 +137,6 @@ public class DatagramDispatcher extends Handler {
     @GuardedBy("mLock")
     private final LinkedHashMap<Long, SendSatelliteDatagramArgument>
             mPendingNonEmergencyDatagramsMap = new LinkedHashMap<>();
-
     /**
      * Map key: messageId, value: {@link PendingRequest} which contains all the information to send
      * carrier roaming nb iot ntn SMS.
@@ -131,24 +144,6 @@ public class DatagramDispatcher extends Handler {
     @GuardedBy("mLock")
     private final LinkedHashMap<Long, PendingRequest> mPendingSmsMap = new LinkedHashMap<>();
 
-    private long mWaitTimeForDatagramSendingResponse;
-    private long mWaitTimeForDatagramSendingForLastMessageResponse;
-    @SatelliteManager.DatagramType
-    private int mLastSendRequestDatagramType = DATAGRAM_TYPE_UNKNOWN;
-    @Nullable private PersistentLogger mPersistentLogger = null;
-
-    @GuardedBy("mLock")
-    private int mModemState = SATELLITE_MODEM_STATE_UNKNOWN;
-    @GuardedBy("mLock")
-    private boolean mHasEnteredConnectedState = false;
-    @GuardedBy("mLock")
-    private boolean mShouldPollMtSms = false;
-    @GuardedBy("mLock")
-    private boolean mIsMtSmsPollingThrottled = false;
-    @GuardedBy("mLock")
-    private int mConnectedStateCounter = 0;
-    private long mSmsTransmissionStartTime = 0;
-
     /**
      * Create the DatagramDispatcher singleton instance.
      * @param context The Context to use to create the DatagramDispatcher.
@@ -196,12 +191,10 @@ public class DatagramDispatcher extends Handler {
         mSessionMetricsStats = SessionMetricsStats.getInstance();
         mPersistentLogger = SatelliteServiceUtils.getPersistentLogger(context);
 
-        synchronized (mLock) {
-            mSendingInProgress = false;
-        }
-        mWaitTimeForDatagramSendingResponse = getWaitForDatagramSendingResponseTimeoutMillis();
-        mWaitTimeForDatagramSendingForLastMessageResponse =
-                getWaitForDatagramSendingResponseForLastMessageTimeoutMillis();
+        mSendingInProgress.set(false);
+        mWaitTimeForDatagramSendingResponse.set(getWaitForDatagramSendingResponseTimeoutMillis());
+        mWaitTimeForDatagramSendingForLastMessageResponse.set(
+                getWaitForDatagramSendingResponseForLastMessageTimeoutMillis());
     }
 
     private static final class DatagramDispatcherHandlerRequest {
@@ -266,7 +259,7 @@ public class DatagramDispatcher extends Handler {
 
         switch(msg.what) {
             case CMD_SEND_SATELLITE_DATAGRAM: {
-                plogd("CMD_SEND_SATELLITE_DATAGRAM mIsDemoMode=" + mIsDemoMode
+                plogd("CMD_SEND_SATELLITE_DATAGRAM mIsDemoMode=" + mIsDemoMode.get()
                         + ", shouldSendDatagramToModemInDemoMode="
                         + shouldSendDatagramToModemInDemoMode());
                 request = (DatagramDispatcherHandlerRequest) msg.obj;
@@ -275,17 +268,15 @@ public class DatagramDispatcher extends Handler {
                 argument.setDatagramStartTime();
                 onCompleted = obtainMessage(EVENT_SEND_SATELLITE_DATAGRAM_DONE, request);
 
-                synchronized (mLock) {
-                    if (mIsDemoMode && !shouldSendDatagramToModemInDemoMode()) {
-                        AsyncResult.forMessage(onCompleted, SATELLITE_RESULT_SUCCESS, null);
-                        sendMessageDelayed(onCompleted, getDemoTimeoutDuration());
-                    } else {
-                        SatelliteModemInterface.getInstance().sendSatelliteDatagram(
-                                argument.datagram,
-                                SatelliteServiceUtils.isSosMessage(argument.datagramType),
-                                argument.needFullScreenPointingUI, onCompleted);
-                        startWaitForDatagramSendingResponseTimer(argument);
-                    }
+                if (mIsDemoMode.get() && !shouldSendDatagramToModemInDemoMode()) {
+                    AsyncResult.forMessage(onCompleted, SATELLITE_RESULT_SUCCESS, null);
+                    sendMessageDelayed(onCompleted, getDemoTimeoutDuration());
+                } else {
+                    SatelliteModemInterface.getInstance().sendSatelliteDatagram(
+                            argument.datagram,
+                            SatelliteServiceUtils.isSosMessage(argument.datagramType),
+                            argument.needFullScreenPointingUI, onCompleted);
+                    startWaitForDatagramSendingResponseTimer(argument);
                 }
                 break;
             }
@@ -296,73 +287,74 @@ public class DatagramDispatcher extends Handler {
                 SendSatelliteDatagramArgument argument =
                         (SendSatelliteDatagramArgument) request.argument;
 
-                synchronized (mLock) {
-                    if (mIsDemoMode && (error == SatelliteManager.SATELLITE_RESULT_SUCCESS)) {
-                        if (argument.skipCheckingSatelliteAligned) {
-                            plogd("Satellite was already aligned. "
+                if (mIsDemoMode.get() && (error == SatelliteManager.SATELLITE_RESULT_SUCCESS)) {
+                    if (argument.skipCheckingSatelliteAligned) {
+                        plogd("Satellite was already aligned. "
                                 + "No need to check alignment again");
-                        } else if (mDatagramController.waitForAligningToSatellite(mIsAligned)) {
-                            plogd("Satellite is not aligned in demo mode, wait for the alignment.");
-                            startSatelliteAlignedTimer(request);
-                            break;
-                        }
-                    }
-                    plogd("EVENT_SEND_SATELLITE_DATAGRAM_DONE error: " + error
-                            + ", mIsDemoMode=" + mIsDemoMode);
-
-                    /*
-                     * The response should be ignored if either of the following hold
-                     * 1) Framework has already received this response from the vendor service.
-                     * 2) Framework has timed out to wait for the response from vendor service for
-                     *    the send request.
-                     * 3) All pending send requests have been aborted due to some error.
-                     */
-                    if (!shouldProcessEventSendSatelliteDatagramDone(argument)) {
-                        plogw("The message " + argument.datagramId + " was already processed");
+                    } else if (mDatagramController.waitForAligningToSatellite(
+                            mIsAligned.get())) {
+                        plogd("Satellite is not aligned in demo mode, wait for the alignment.");
+                        startSatelliteAlignedTimer(request);
                         break;
                     }
+                }
+                plogd("EVENT_SEND_SATELLITE_DATAGRAM_DONE error: " + error
+                        + ", mIsDemoMode=" + mIsDemoMode.get());
+
+                /*
+                 * The response should be ignored if either of the following hold
+                 * 1) Framework has already received this response from the vendor service.
+                 * 2) Framework has timed out to wait for the response from vendor service for
+                 *    the send request.
+                 * 3) All pending send requests have been aborted due to some error.
+                 */
+                if (!shouldProcessEventSendSatelliteDatagramDone(argument)) {
+                    plogw("The message " + argument.datagramId + " was already processed");
+                    break;
+                }
 
-                    stopWaitForDatagramSendingResponseTimer();
-                    mSendingInProgress = false;
+                stopWaitForDatagramSendingResponseTimer();
+                mSendingInProgress.set(false);
 
-                    // Log metrics about the outgoing datagram
-                    reportSendDatagramCompleted(argument, error);
+                // Log metrics about the outgoing datagram
+                reportSendDatagramCompleted(argument, error);
+                synchronized (mLock) {
                     // Remove current datagram from pending map.
                     if (SatelliteServiceUtils.isSosMessage(argument.datagramType)) {
                         mPendingEmergencyDatagramsMap.remove(argument.datagramId);
                         if (error == SATELLITE_RESULT_SUCCESS) {
-                            mIsEmergencyCommunicationEstablished = true;
+                            mIsEmergencyCommunicationEstablished.set(true);
                         }
                     } else {
                         mPendingNonEmergencyDatagramsMap.remove(argument.datagramId);
                     }
+                }
 
-                    if (error == SATELLITE_RESULT_SUCCESS) {
-                        // Update send status for current datagram
-                        mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
-                                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_SUCCESS,
-                                getPendingMessagesCount(), error);
-                        startWaitForSimulatedPollDatagramsDelayTimer(request);
-                    } else {
-                        // Update send status
-                        mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
-                                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
-                                getPendingMessagesCount(), error);
-                    }
+                if (error == SATELLITE_RESULT_SUCCESS) {
+                    // Update send status for current datagram
+                    mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
+                            SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_SUCCESS,
+                            getPendingMessagesCount(), error);
+                    startWaitForSimulatedPollDatagramsDelayTimer(request);
+                } else {
+                    // Update send status
+                    mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
+                            SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
+                            getPendingMessagesCount(), error);
+                }
 
-                    if (getPendingMessagesCount() > 0) {
-                        // Send response for current datagram
-                        argument.callback.accept(error);
-                        // Send pending datagrams
-                        sendPendingMessages();
-                    } else {
-                        mDatagramController.updateSendStatus(argument.subId,
-                                argument.datagramType,
-                                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE, 0,
-                                SatelliteManager.SATELLITE_RESULT_SUCCESS);
-                        // Send response for current datagram
-                        argument.callback.accept(error);
-                    }
+                if (getPendingMessagesCount() > 0) {
+                    // Send response for current datagram
+                    argument.callback.accept(error);
+                    // Send pending datagrams
+                    sendPendingMessages();
+                } else {
+                    mDatagramController.updateSendStatus(argument.subId,
+                            argument.datagramType,
+                            SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE, 0,
+                            SatelliteManager.SATELLITE_RESULT_SUCCESS);
+                    // Send response for current datagram
+                    argument.callback.accept(error);
                 }
                 break;
             }
@@ -402,7 +394,7 @@ public class DatagramDispatcher extends Handler {
                     return;
                 }
 
-                mSmsTransmissionStartTime = System.currentTimeMillis();
+                mSmsTransmissionStartTime.set(System.currentTimeMillis());
                 smsDispatchersController.sendCarrierRoamingNbIotNtnText(pendingRequest);
                 break;
             }
@@ -421,9 +413,7 @@ public class DatagramDispatcher extends Handler {
             }
 
             case EVENT_MT_SMS_POLLING_THROTTLE_TIMED_OUT: {
-                synchronized (mLock) {
-                    mIsMtSmsPollingThrottled = false;
-                }
+                mIsMtSmsPollingThrottled.set(false);
                 if (allowMtSmsPolling()) {
                     sendMessage(obtainMessage(CMD_SEND_MT_SMS_POLLING_MESSAGE));
                 }
@@ -436,6 +426,18 @@ public class DatagramDispatcher extends Handler {
                 break;
             }
 
+            case EVENT_SATELLITE_MODEM_STATE_CHANGED: {
+                plogd("EVENT_SATELLITE_MODEM_STATE_CHANGED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int state = (int) args.arg1;
+                try {
+                    handleEventSatelliteModemStateChanged(state);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
             default:
                 plogw("DatagramDispatcherHandler: unexpected message code: " + msg.what);
                 break;
@@ -468,7 +470,7 @@ public class DatagramDispatcher extends Handler {
         SendSatelliteDatagramArgument datagramArgs =
                 new SendSatelliteDatagramArgument(subId, datagramId, datagramType, datagram,
                         needFullScreenPointingUI, callback);
-        mLastSendRequestDatagramType = datagramType;
+        mLastSendRequestDatagramType.set(datagramType);
 
         synchronized (mLock) {
             // Add datagram to pending datagram map
@@ -477,32 +479,30 @@ public class DatagramDispatcher extends Handler {
             } else {
                 mPendingNonEmergencyDatagramsMap.put(datagramId, datagramArgs);
             }
+        }
 
-            if (mDatagramController.needsWaitingForSatelliteConnected(datagramType)) {
-                plogd("sendDatagram: wait for satellite connected");
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
-                        getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
-                startDatagramWaitForConnectedStateTimer(datagramArgs.datagramType);
-            } else if (!mSendingInProgress && mDatagramController.isPollingInIdleState()) {
-                // Modem can be busy receiving datagrams, so send datagram only when modem is
-                // not busy.
-                mSendingInProgress = true;
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
-                        getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
-                sendRequestAsync(CMD_SEND_SATELLITE_DATAGRAM, datagramArgs, phone);
-            } else {
-                plogd("sendDatagram: mSendingInProgress=" + mSendingInProgress
-                        + ", isPollingInIdleState=" + mDatagramController.isPollingInIdleState());
-            }
+        if (mDatagramController.needsWaitingForSatelliteConnected(datagramType)) {
+            plogd("sendDatagram: wait for satellite connected");
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
+                    getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
+            startDatagramWaitForConnectedStateTimer(datagramArgs.datagramType);
+        } else if (!mSendingInProgress.get() && mDatagramController.isPollingInIdleState()) {
+            // Modem can be busy receiving datagrams, so send datagram only when modem is
+            // not busy.
+            mSendingInProgress.set(true);
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
+                    getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
+            sendRequestAsync(CMD_SEND_SATELLITE_DATAGRAM, datagramArgs, phone);
+        } else {
+            plogd("sendDatagram: mSendingInProgress=" + mSendingInProgress.get()
+                    + ", isPollingInIdleState=" + mDatagramController.isPollingInIdleState());
         }
     }
 
     public void retrySendingDatagrams() {
-        synchronized (mLock) {
-            sendPendingMessages();
-        }
+        sendPendingMessages();
     }
 
     /** Set demo mode
@@ -511,8 +511,8 @@ public class DatagramDispatcher extends Handler {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     protected void setDemoMode(boolean isDemoMode) {
-        mIsDemoMode = isDemoMode;
-        plogd("setDemoMode: mIsDemoMode=" + mIsDemoMode);
+        mIsDemoMode.set(isDemoMode);
+        plogd("setDemoMode: mIsDemoMode=" + isDemoMode);
     }
 
     /**
@@ -520,11 +520,10 @@ public class DatagramDispatcher extends Handler {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public void setDeviceAlignedWithSatellite(boolean isAligned) {
-        synchronized (mLock) {
-            mIsAligned = isAligned;
-            plogd("setDeviceAlignedWithSatellite: " + mIsAligned);
-            if (isAligned && mIsDemoMode) handleEventSatelliteAligned();
-        }
+        mIsAligned.set(isAligned);
+        plogd("setDeviceAlignedWithSatellite: " + isAligned);
+        if (isAligned && mIsDemoMode.get()) handleEventSatelliteAligned();
+
         if (allowMtSmsPolling()) {
             sendMessage(obtainMessage(CMD_SEND_MT_SMS_POLLING_MESSAGE));
         }
@@ -586,7 +585,6 @@ public class DatagramDispatcher extends Handler {
         removeMessages(EVENT_WAIT_FOR_DEVICE_ALIGNMENT_IN_DEMO_MODE_TIMED_OUT);
     }
 
-    @GuardedBy("mLock")
     private void sendPendingMessages() {
         plogd("sendPendingMessages");
 
@@ -607,7 +605,6 @@ public class DatagramDispatcher extends Handler {
      * Send pending satellite datagrams. Emergency datagrams are given priority over
      * non-emergency datagrams.
      */
-    @GuardedBy("mLock")
     private void sendPendingDatagrams() {
         plogd("sendPendingDatagrams()");
         if (!mDatagramController.isPollingInIdleState()) {
@@ -623,10 +620,12 @@ public class DatagramDispatcher extends Handler {
 
         Phone phone = SatelliteServiceUtils.getPhone();
         Set<Entry<Long, SendSatelliteDatagramArgument>> pendingDatagram = null;
-        if (!mSendingInProgress && !mPendingEmergencyDatagramsMap.isEmpty()) {
-            pendingDatagram = mPendingEmergencyDatagramsMap.entrySet();
-        } else if (!mSendingInProgress && !mPendingNonEmergencyDatagramsMap.isEmpty()) {
-            pendingDatagram = mPendingNonEmergencyDatagramsMap.entrySet();
+        synchronized (mLock) {
+            if (!mSendingInProgress.get() && !mPendingEmergencyDatagramsMap.isEmpty()) {
+                pendingDatagram = mPendingEmergencyDatagramsMap.entrySet();
+            } else if (!mSendingInProgress.get() && !mPendingNonEmergencyDatagramsMap.isEmpty()) {
+                pendingDatagram = mPendingNonEmergencyDatagramsMap.entrySet();
+            }
         }
 
         if ((pendingDatagram != null) && pendingDatagram.iterator().hasNext()) {
@@ -644,7 +643,7 @@ public class DatagramDispatcher extends Handler {
                 return;
             }
 
-            mSendingInProgress = true;
+            mSendingInProgress.set(true);
             // Sets the trigger time for getting pending datagrams
             mDatagramController.updateSendStatus(datagramArg.subId, datagramArg.datagramType,
                     SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
@@ -659,25 +658,26 @@ public class DatagramDispatcher extends Handler {
      * @param pendingDatagramsMap The pending datagrams map to be cleaned up.
      * @param errorCode error code to be returned.
      */
-    @GuardedBy("mLock")
     private void sendErrorCodeAndCleanupPendingDatagrams(
             LinkedHashMap<Long, SendSatelliteDatagramArgument> pendingDatagramsMap,
             @SatelliteManager.SatelliteResult int errorCode) {
-        if (pendingDatagramsMap.size() == 0) {
-            return;
-        }
-        ploge("sendErrorCodeAndCleanupPendingDatagrams: cleaning up resources");
+        synchronized (mLock) {
+            if (pendingDatagramsMap.size() == 0) {
+                return;
+            }
+            ploge("sendErrorCodeAndCleanupPendingDatagrams: cleaning up resources");
 
-        // Send error code to all the pending datagrams
-        for (Entry<Long, SendSatelliteDatagramArgument> entry :
-                pendingDatagramsMap.entrySet()) {
-            SendSatelliteDatagramArgument argument = entry.getValue();
-            reportSendDatagramCompleted(argument, errorCode);
-            argument.callback.accept(errorCode);
-        }
+            // Send error code to all the pending datagrams
+            for (Entry<Long, SendSatelliteDatagramArgument> entry :
+                    pendingDatagramsMap.entrySet()) {
+                SendSatelliteDatagramArgument argument = entry.getValue();
+                reportSendDatagramCompleted(argument, errorCode);
+                argument.callback.accept(errorCode);
+            }
 
-        // Clear pending datagram maps
-        pendingDatagramsMap.clear();
+            // Clear pending datagram maps
+            pendingDatagramsMap.clear();
+        }
     }
 
     /**
@@ -686,13 +686,14 @@ public class DatagramDispatcher extends Handler {
      * @param subId The subId of the subscription used to send datagram
      * @param errorCode The error code that resulted in abort.
      */
-    @GuardedBy("mLock")
     private void abortSendingPendingDatagrams(int subId,
             @SatelliteManager.SatelliteResult int errorCode) {
         plogd("abortSendingPendingDatagrams()");
-        sendErrorCodeAndCleanupPendingDatagrams(mPendingEmergencyDatagramsMap, errorCode);
-        sendErrorCodeAndCleanupPendingDatagrams(mPendingNonEmergencyDatagramsMap, errorCode);
-        sendErrorCodeAndCleanupPendingSms(mPendingSmsMap, errorCode);
+        synchronized (mLock) {
+            sendErrorCodeAndCleanupPendingDatagrams(mPendingEmergencyDatagramsMap, errorCode);
+            sendErrorCodeAndCleanupPendingDatagrams(mPendingNonEmergencyDatagramsMap, errorCode);
+            sendErrorCodeAndCleanupPendingSms(mPendingSmsMap, errorCode);
+        }
     }
 
     /**
@@ -700,12 +701,10 @@ public class DatagramDispatcher extends Handler {
      * @return pending messages count
      */
     public int getPendingMessagesCount() {
-        synchronized (mLock) {
-            if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-                return getPendingDatagramCount() + getPendingSmsCount();
-            } else {
-                return getPendingDatagramCount();
-            }
+        if (mFeatureFlags.carrierRoamingNbIotNtn()) {
+            return getPendingDatagramCount() + getPendingSmsCount();
+        } else {
+            return getPendingDatagramCount();
         }
     }
 
@@ -764,8 +763,8 @@ public class DatagramDispatcher extends Handler {
         int datagramType = pendingRequest.isMtSmsPolling
                 ? DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS : DATAGRAM_TYPE_SMS;
         if (resultCode == SATELLITE_RESULT_SUCCESS) {
-            long smsTransmissionTime = mSmsTransmissionStartTime > 0
-                    ? (System.currentTimeMillis() - mSmsTransmissionStartTime) : 0;
+            long smsTransmissionTime = mSmsTransmissionStartTime.get() > 0
+                    ? (System.currentTimeMillis() - mSmsTransmissionStartTime.get()) : 0;
             mControllerMetricsStats.reportOutgoingDatagramSuccessCount(datagramType, false);
             mSessionMetricsStats.addCountOfSuccessfulOutgoingDatagram(
                     datagramType, smsTransmissionTime);
@@ -780,6 +779,7 @@ public class DatagramDispatcher extends Handler {
             @NonNull @SatelliteManager.SatelliteResult int resultCode) {
         long datagramTransmissionTime = argument.datagramStartTime > 0
                 ? (System.currentTimeMillis() - argument.datagramStartTime) : 0;
+        boolean isDemoMode = mIsDemoMode.get();
         SatelliteStats.getInstance().onSatelliteOutgoingDatagramMetrics(
                 new SatelliteStats.SatelliteOutgoingDatagramParams.Builder()
                         .setDatagramType(argument.datagramType)
@@ -788,18 +788,18 @@ public class DatagramDispatcher extends Handler {
                         /* In case pending datagram has not been attempted to send to modem
                         interface. transfer time will be 0. */
                         .setDatagramTransferTimeMillis(datagramTransmissionTime)
-                        .setIsDemoMode(mIsDemoMode)
+                        .setIsDemoMode(isDemoMode)
                         .setCarrierId(SatelliteController.getInstance().getSatelliteCarrierId())
                         .setIsNtnOnlyCarrier(SatelliteController.getInstance().isNtnOnlyCarrier())
                         .build());
         if (resultCode == SatelliteManager.SATELLITE_RESULT_SUCCESS) {
             mControllerMetricsStats.reportOutgoingDatagramSuccessCount(argument.datagramType,
-                    mIsDemoMode);
+                    isDemoMode);
             mSessionMetricsStats.addCountOfSuccessfulOutgoingDatagram(argument.datagramType,
                     datagramTransmissionTime);
         } else {
             mControllerMetricsStats.reportOutgoingDatagramFailCount(argument.datagramType,
-                    mIsDemoMode);
+                    isDemoMode);
             mSessionMetricsStats.addCountOfFailedOutgoingDatagram(argument.datagramType,
                     resultCode);
         }
@@ -820,37 +820,49 @@ public class DatagramDispatcher extends Handler {
      * @param state Current satellite modem state.
      */
     public void onSatelliteModemStateChanged(@SatelliteManager.SatelliteModemState int state) {
-        synchronized (mLock) {
-            mModemState = state;
-            if (state == SatelliteManager.SATELLITE_MODEM_STATE_OFF
-                    || state == SatelliteManager.SATELLITE_MODEM_STATE_UNAVAILABLE) {
-                plogd("onSatelliteModemStateChanged: cleaning up resources");
-                cleanUpResources();
-            } else if (state == SatelliteManager.SATELLITE_MODEM_STATE_IDLE) {
-                sendPendingMessages();
-            }
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = state;
+            sendMessage(obtainMessage(EVENT_SATELLITE_MODEM_STATE_CHANGED, args));
+            return;
+        }
 
-            if (state == SATELLITE_MODEM_STATE_CONNECTED) {
-                mHasEnteredConnectedState = true;
+        handleEventSatelliteModemStateChanged(state);
+    }
 
-                mConnectedStateCounter++;
-                if (isFirstConnected()) {
-                    mShouldPollMtSms = shouldPollMtSms();
-                }
+    private void handleEventSatelliteModemStateChanged(
+            @SatelliteManager.SatelliteModemState int state) {
+        plogd("handleEventSatelliteModemStateChanged: state = " + state);
+        mModemState.set(state);
+        if (state == SatelliteManager.SATELLITE_MODEM_STATE_OFF
+                || state == SatelliteManager.SATELLITE_MODEM_STATE_UNAVAILABLE) {
+            plogd("onSatelliteModemStateChanged: cleaning up resources");
+            cleanUpResources();
+        } else if (state == SatelliteManager.SATELLITE_MODEM_STATE_IDLE) {
+            sendPendingMessages();
+        }
 
-                if (isDatagramWaitForConnectedStateTimerStarted()) {
-                    stopDatagramWaitForConnectedStateTimer();
-                    sendPendingMessages();
-                }
+        if (state == SATELLITE_MODEM_STATE_CONNECTED) {
+            mHasEnteredConnectedState.set(true);
+
+            mConnectedStateCounter.incrementAndGet();
+            if (isFirstConnected()) {
+                mShouldPollMtSms.set(shouldPollMtSms());
             }
 
-            if (state == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
-                if (mHasEnteredConnectedState) {
-                    mHasEnteredConnectedState = false;
-                    mShouldPollMtSms = shouldPollMtSms();
-                }
+            if (isDatagramWaitForConnectedStateTimerStarted()) {
+                stopDatagramWaitForConnectedStateTimer();
+                sendPendingMessages();
+            }
+        }
+
+        if (state == SATELLITE_MODEM_STATE_NOT_CONNECTED) {
+            if (mHasEnteredConnectedState.get()) {
+                mHasEnteredConnectedState.set(false);
+                mShouldPollMtSms.set(shouldPollMtSms());
             }
         }
+
         if (allowMtSmsPolling()) {
             sendMessage(obtainMessage(CMD_SEND_MT_SMS_POLLING_MESSAGE));
         }
@@ -858,24 +870,23 @@ public class DatagramDispatcher extends Handler {
 
     /** Returns true if this is the first time the satellite modem is connected. */
     private boolean isFirstConnected() {
-        return mConnectedStateCounter == 1;
+        return mConnectedStateCounter.get() == 1;
     }
 
-    @GuardedBy("mLock")
     private void cleanUpResources() {
         plogd("cleanUpResources");
-        mSendingInProgress = false;
-        mIsEmergencyCommunicationEstablished = false;
+        mSendingInProgress.set(false);
+        mIsEmergencyCommunicationEstablished.set(false);
 
         int subId = SatelliteController.getInstance().getSelectedSatelliteSubId();
         if (getPendingMessagesCount() > 0) {
             mDatagramController.updateSendStatus(subId,
-                    mLastSendRequestDatagramType,
+                    mLastSendRequestDatagramType.get(),
                     SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
                     getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_REQUEST_ABORTED);
         }
         mDatagramController.updateSendStatus(subId,
-                mLastSendRequestDatagramType,
+                mLastSendRequestDatagramType.get(),
                 SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
                 0, SatelliteManager.SATELLITE_RESULT_SUCCESS);
         abortSendingPendingDatagrams(subId,
@@ -885,22 +896,21 @@ public class DatagramDispatcher extends Handler {
         stopDatagramWaitForConnectedStateTimer();
         stopWaitForDatagramSendingResponseTimer();
         stopWaitForSimulatedPollDatagramsDelayTimer();
-        mIsDemoMode = false;
+        mIsDemoMode.set(false);
         mSendSatelliteDatagramRequest = null;
-        mIsAligned = false;
-        mLastSendRequestDatagramType = DATAGRAM_TYPE_UNKNOWN;
-        mModemState = SATELLITE_MODEM_STATE_UNKNOWN;
-        mHasEnteredConnectedState = false;
-        mShouldPollMtSms = false;
-        mConnectedStateCounter = 0;
+        mIsAligned.set(false);
+        mLastSendRequestDatagramType.set(DATAGRAM_TYPE_UNKNOWN);
+        mModemState.set(SATELLITE_MODEM_STATE_UNKNOWN);
+        mHasEnteredConnectedState.set(false);
+        mShouldPollMtSms.set(false);
+        mConnectedStateCounter.set(0);
         stopMtSmsPollingThrottle();
     }
 
     /** @return {@code true} if already sent an emergency datagram during a session. */
-    public boolean isEmergencyCommunicationEstablished() {
-        synchronized (mLock) {
-            return mIsEmergencyCommunicationEstablished;
-        }
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected boolean isEmergencyCommunicationEstablished() {
+        return mIsEmergencyCommunicationEstablished.get();
     }
 
     private void startDatagramWaitForConnectedStateTimer(
@@ -929,9 +939,10 @@ public class DatagramDispatcher extends Handler {
      */
     void setWaitTimeForDatagramSendingResponse(boolean reset, long timeoutMillis) {
         if (reset) {
-            mWaitTimeForDatagramSendingResponse = getWaitForDatagramSendingResponseTimeoutMillis();
+            mWaitTimeForDatagramSendingResponse.set(
+                    getWaitForDatagramSendingResponseTimeoutMillis());
         } else {
-            mWaitTimeForDatagramSendingResponse = timeoutMillis;
+            mWaitTimeForDatagramSendingResponse.set(timeoutMillis);
         }
     }
 
@@ -942,8 +953,8 @@ public class DatagramDispatcher extends Handler {
             return;
         }
         long waitTime = SatelliteServiceUtils.isLastSosMessage(argument.datagramType)
-                ? mWaitTimeForDatagramSendingForLastMessageResponse
-                : mWaitTimeForDatagramSendingResponse;
+                ? mWaitTimeForDatagramSendingForLastMessageResponse.get()
+                : mWaitTimeForDatagramSendingResponse.get();
         logd("startWaitForDatagramSendingResponseTimer: datagramType=" + argument.datagramType
                 + ", waitTime=" + waitTime);
         sendMessageDelayed(obtainMessage(
@@ -957,21 +968,18 @@ public class DatagramDispatcher extends Handler {
     private void handleEventDatagramWaitForConnectedStateTimedOut(
             @SatelliteManager.DatagramType int datagramType) {
         plogw("Timed out to wait for satellite connected before sending datagrams");
-        synchronized (mLock) {
-            int subId = SatelliteController.getInstance().getSelectedSatelliteSubId();
-            // Update send status
-            mDatagramController.updateSendStatus(subId,
-                    datagramType,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
-                    getPendingMessagesCount(),
-                    SATELLITE_RESULT_NOT_REACHABLE);
-            mDatagramController.updateSendStatus(subId,
-                    datagramType,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
-                    0, SatelliteManager.SATELLITE_RESULT_SUCCESS);
-            abortSendingPendingDatagrams(subId,
-                    SATELLITE_RESULT_NOT_REACHABLE);
-        }
+        int subId = SatelliteController.getInstance().getSelectedSatelliteSubId();
+        // Update send status
+        mDatagramController.updateSendStatus(subId,
+                datagramType,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
+                getPendingMessagesCount(),
+                SATELLITE_RESULT_NOT_REACHABLE);
+        mDatagramController.updateSendStatus(subId,
+                datagramType,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
+                0, SatelliteManager.SATELLITE_RESULT_SUCCESS);
+        abortSendingPendingDatagrams(subId, SATELLITE_RESULT_NOT_REACHABLE);
     }
 
     private boolean shouldSendDatagramToModemInDemoMode() {
@@ -1015,39 +1023,39 @@ public class DatagramDispatcher extends Handler {
 
     private void handleEventWaitForDatagramSendingResponseTimedOut(
             @NonNull SendSatelliteDatagramArgument argument) {
-        synchronized (mLock) {
-            plogw("Timed out to wait for the response of the request to send the datagram "
-                    + argument.datagramId);
+        plogw("Timed out to wait for the response of the request to send the datagram "
+                + argument.datagramId);
+
+        // Ask vendor service to abort all datagram-sending requests
+        SatelliteModemInterface.getInstance().abortSendingSatelliteDatagrams(
+                obtainMessage(EVENT_ABORT_SENDING_SATELLITE_DATAGRAMS_DONE, argument));
+        mSendingInProgress.set(false);
+
+        // Update send status
+        mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
+                getPendingMessagesCount(), SATELLITE_RESULT_MODEM_TIMEOUT);
+        mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
+                0, SatelliteManager.SATELLITE_RESULT_SUCCESS);
 
-            // Ask vendor service to abort all datagram-sending requests
-            SatelliteModemInterface.getInstance().abortSendingSatelliteDatagrams(
-                    obtainMessage(EVENT_ABORT_SENDING_SATELLITE_DATAGRAMS_DONE, argument));
-            mSendingInProgress = false;
+        // Send response for current datagram after updating datagram transfer state
+        // internally.
+        argument.callback.accept(SATELLITE_RESULT_MODEM_TIMEOUT);
 
-            // Update send status
-            mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
-                    getPendingMessagesCount(), SATELLITE_RESULT_MODEM_TIMEOUT);
-            mDatagramController.updateSendStatus(argument.subId, argument.datagramType,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
-                    0, SatelliteManager.SATELLITE_RESULT_SUCCESS);
-
-            // Send response for current datagram after updating datagram transfer state
-            // internally.
-            argument.callback.accept(SATELLITE_RESULT_MODEM_TIMEOUT);
-
-            // Log metrics about the outgoing datagram
-            reportSendDatagramCompleted(argument, SATELLITE_RESULT_MODEM_TIMEOUT);
-            // Remove current datagram from pending map.
+        // Log metrics about the outgoing datagram
+        reportSendDatagramCompleted(argument, SATELLITE_RESULT_MODEM_TIMEOUT);
+        // Remove current datagram from pending map.
+        synchronized (mLock) {
             if (SatelliteServiceUtils.isSosMessage(argument.datagramType)) {
                 mPendingEmergencyDatagramsMap.remove(argument.datagramId);
             } else {
                 mPendingNonEmergencyDatagramsMap.remove(argument.datagramId);
             }
-
-            // Abort sending all the pending datagrams
-            abortSendingPendingDatagrams(argument.subId, SATELLITE_RESULT_MODEM_TIMEOUT);
         }
+
+        // Abort sending all the pending datagrams
+        abortSendingPendingDatagrams(argument.subId, SATELLITE_RESULT_MODEM_TIMEOUT);
     }
 
     /**
@@ -1078,7 +1086,7 @@ public class DatagramDispatcher extends Handler {
 
     private void startWaitForSimulatedPollDatagramsDelayTimer(
             @NonNull DatagramDispatcherHandlerRequest request) {
-        if (mIsDemoMode) {
+        if (mIsDemoMode.get()) {
             plogd("startWaitForSimulatedPollDatagramsDelayTimer");
             sendMessageDelayed(
                     obtainMessage(EVENT_WAIT_FOR_SIMULATED_POLL_DATAGRAMS_DELAY_TIMED_OUT, request),
@@ -1094,7 +1102,7 @@ public class DatagramDispatcher extends Handler {
 
     private void handleEventWaitForSimulatedPollDatagramsDelayTimedOut(
             @NonNull SendSatelliteDatagramArgument argument) {
-        if (mIsDemoMode) {
+        if (mIsDemoMode.get()) {
             plogd("handleEventWaitForSimulatedPollDatagramsDelayTimedOut");
             mDatagramController.pushDemoModeDatagram(argument.datagramType, argument.datagram);
             Consumer<Integer> internalCallback = new Consumer<Integer>() {
@@ -1111,22 +1119,23 @@ public class DatagramDispatcher extends Handler {
     }
 
     long getDemoTimeoutDuration() {
-        return mDemoTimeoutDuration;
+        return mDemoTimeoutDuration.get();
     }
 
     /**
      * This API is used by CTS tests to override the mDemoTimeoutDuration.
      */
     void setTimeoutDatagramDelayInDemoMode(boolean reset, long timeoutMillis) {
-        if (!mIsDemoMode) {
+        if (!mIsDemoMode.get()) {
             return;
         }
         if (reset) {
-            mDemoTimeoutDuration = TIMEOUT_DATAGRAM_DELAY_IN_DEMO_MODE;
+            mDemoTimeoutDuration.set(TIMEOUT_DATAGRAM_DELAY_IN_DEMO_MODE);
         } else {
-            mDemoTimeoutDuration = timeoutMillis;
+            mDemoTimeoutDuration.set(timeoutMillis);
         }
-        plogd("setTimeoutDatagramDelayInDemoMode " + mDemoTimeoutDuration + " reset=" + reset);
+        plogd("setTimeoutDatagramDelayInDemoMode " + mDemoTimeoutDuration.get()
+                + " reset=" + reset);
     }
 
     /**
@@ -1151,31 +1160,31 @@ public class DatagramDispatcher extends Handler {
         synchronized (mLock) {
             // Add SMS to pending list
             mPendingSmsMap.put(messageId, pendingSms);
-            int datagramType = pendingSms.isMtSmsPolling ?
-                    DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS : DATAGRAM_TYPE_SMS;
-            mLastSendRequestDatagramType = datagramType;
+        }
 
-            if (mDatagramController.needsWaitingForSatelliteConnected(datagramType)) {
-                plogd("sendSms: wait for satellite connected");
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
-                        getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
-                startDatagramWaitForConnectedStateTimer(datagramType);
-            } else if (!mSendingInProgress && mDatagramController.isPollingInIdleState()) {
-                mSendingInProgress = true;
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
-                        getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
+        int datagramType = pendingSms.isMtSmsPolling
+                ? DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS : DATAGRAM_TYPE_SMS;
+        mLastSendRequestDatagramType.set(datagramType);
 
-                sendMessage(obtainMessage(CMD_SEND_SMS, pendingSms));
-            } else {
-                plogd("sendSms: mSendingInProgress=" + mSendingInProgress
-                        + ", isPollingInIdleState=" + mDatagramController.isPollingInIdleState());
-            }
+        if (mDatagramController.needsWaitingForSatelliteConnected(datagramType)) {
+            plogd("sendSms: wait for satellite connected");
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
+                    getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
+            startDatagramWaitForConnectedStateTimer(datagramType);
+        } else if (!mSendingInProgress.get() && mDatagramController.isPollingInIdleState()) {
+            mSendingInProgress.set(true);
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
+                    getPendingMessagesCount(), SatelliteManager.SATELLITE_RESULT_SUCCESS);
+
+            sendMessage(obtainMessage(CMD_SEND_SMS, pendingSms));
+        } else {
+            plogd("sendSms: mSendingInProgress=" + mSendingInProgress.get()
+                    + ", isPollingInIdleState=" + mDatagramController.isPollingInIdleState());
         }
     }
 
-    @GuardedBy("mLock")
     private void sendPendingSms() {
         plogd("sendPendingSms");
         if (!mDatagramController.isPollingInIdleState()) {
@@ -1186,8 +1195,10 @@ public class DatagramDispatcher extends Handler {
 
         int subId = SatelliteController.getInstance().getSelectedSatelliteSubId();
         Set<Entry<Long, PendingRequest>> pendingSms = null;
-        if (!mSendingInProgress) {
-            pendingSms = mPendingSmsMap.entrySet();
+        synchronized (mLock) {
+            if (!mSendingInProgress.get()) {
+                pendingSms = mPendingSmsMap.entrySet();
+            }
         }
 
         if (pendingSms != null && pendingSms.iterator().hasNext()) {
@@ -1205,14 +1216,14 @@ public class DatagramDispatcher extends Handler {
                 return;
             }
 
-            mSendingInProgress = true;
+            mSendingInProgress.set(true);
             mDatagramController.updateSendStatus(subId,
                     datagramType,
                     SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING,
                     getPendingMessagesCount(), SATELLITE_RESULT_SUCCESS);
             sendMessage(obtainMessage(CMD_SEND_SMS, pendingRequest));
         } else {
-            plogd("sendPendingSms: mSendingInProgress=" + mSendingInProgress
+            plogd("sendPendingSms: mSendingInProgress=" + mSendingInProgress.get()
                     + " pendingSmsCount=" + getPendingSmsCount());
         }
     }
@@ -1231,85 +1242,88 @@ public class DatagramDispatcher extends Handler {
         sendMessage(obtainMessage(EVENT_SEND_SMS_DONE, args));
     }
 
-    @GuardedBy("mLock")
     private void sendErrorCodeAndCleanupPendingSms(
             LinkedHashMap<Long, PendingRequest> pendingSmsMap,
             @SatelliteManager.SatelliteResult int errorCode) {
-        if (pendingSmsMap.size() == 0) {
-            plogd("sendErrorCodeAndCleanupPendingSms: pendingSmsMap is empty.");
-            return;
-        }
-        ploge("sendErrorCodeAndCleanupPendingSms: cleaning up resources. "
-                + "pendingSmsMap size=" + getPendingSmsCount());
+        synchronized (mLock) {
+            if (pendingSmsMap.size() == 0) {
+                plogd("sendErrorCodeAndCleanupPendingSms: pendingSmsMap is empty.");
+                return;
+            }
+            ploge("sendErrorCodeAndCleanupPendingSms: cleaning up resources. "
+                    + "pendingSmsMap size=" + getPendingSmsCount());
 
-        Phone satellitePhone = SatelliteController.getInstance().getSatellitePhone();
-        if (satellitePhone == null) {
-            ploge("sendErrorCodeAndCleanupPendingSms: satellitePhone is null.");
+            Phone satellitePhone = SatelliteController.getInstance().getSatellitePhone();
+            if (satellitePhone == null) {
+                ploge("sendErrorCodeAndCleanupPendingSms: satellitePhone is null.");
+                pendingSmsMap.clear();
+                return;
+            }
+
+            SmsDispatchersController smsDispatchersController =
+                    satellitePhone.getSmsDispatchersController();
+            if (smsDispatchersController == null) {
+                ploge("sendErrorCodeAndCleanupPendingSms: smsDispatchersController is null.");
+                pendingSmsMap.clear();
+                return;
+            }
+
+            // Send error code to all the pending text
+            for (Entry<Long, PendingRequest> entry : pendingSmsMap.entrySet()) {
+                PendingRequest pendingRequest = entry.getValue();
+                smsDispatchersController.onSendCarrierRoamingNbIotNtnTextError(
+                        pendingRequest, errorCode);
+                reportSendSmsCompleted(pendingRequest, errorCode);
+            }
+
+            // Clear pending text map
             pendingSmsMap.clear();
-            return;
         }
+    }
 
-        SmsDispatchersController smsDispatchersController =
-                satellitePhone.getSmsDispatchersController();
-        if (smsDispatchersController == null) {
-            ploge("sendErrorCodeAndCleanupPendingSms: smsDispatchersController is null.");
-            pendingSmsMap.clear();
-            return;
+    private void handleEventSendSmsDone(int subId, long messageId, boolean success) {
+        PendingRequest pendingSms = null;
+        synchronized (mLock) {
+            pendingSms = mPendingSmsMap.remove(messageId);
         }
 
-        // Send error code to all the pending text
-        for (Entry<Long, PendingRequest> entry : pendingSmsMap.entrySet()) {
-            PendingRequest pendingRequest = entry.getValue();
-            smsDispatchersController.onSendCarrierRoamingNbIotNtnTextError(
-                    pendingRequest, errorCode);
-            reportSendSmsCompleted(pendingRequest, errorCode);
+        if (pendingSms == null) {
+            // Just return, the SMS is not sent by DatagramDispatcher such as Data SMS
+            plogd("handleEventSendSmsDone there is no pendingSms for messageId=" + messageId);
+            return;
         }
 
-        // Clear pending text map
-        pendingSmsMap.clear();
-    }
+        mSendingInProgress.set(false);
+        int datagramType = pendingSms.isMtSmsPolling
+                ? DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS  : DATAGRAM_TYPE_SMS;
 
-    private void handleEventSendSmsDone(int subId, long messageId, boolean success) {
-        synchronized (mLock) {
-            PendingRequest pendingSms = mPendingSmsMap.remove(messageId);
-            if (pendingSms == null) {
-                // Just return, the SMS is not sent by DatagramDispatcher such as Data SMS
-                plogd("handleEventSendSmsDone there is no pendingSms for messageId=" + messageId);
-                return;
-            }
+        plogd("handleEventSendSmsDone subId=" + subId + " messageId=" + messageId
+                + " success=" + success + " datagramType=" + datagramType);
 
-            mSendingInProgress = false;
-            int datagramType = pendingSms.isMtSmsPolling
-                    ? DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS  : DATAGRAM_TYPE_SMS;
-
-            plogd("handleEventSendSmsDone subId=" + subId + " messageId=" + messageId
-                    + " success=" + success + " datagramType=" + datagramType);
-
-            if (success) {
-                // Update send status
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_SUCCESS,
-                        getPendingMessagesCount(), SATELLITE_RESULT_SUCCESS);
-                reportSendSmsCompleted(pendingSms, SATELLITE_RESULT_SUCCESS);
-                if (datagramType == DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS) {
-                    startMtSmsPollingThrottle();
-                    mShouldPollMtSms = false;
-                }
-            } else {
-                // Update send status
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
-                        getPendingMessagesCount(), SATELLITE_RESULT_NETWORK_ERROR);
-                reportSendSmsCompleted(pendingSms, SATELLITE_RESULT_NETWORK_ERROR);
+        if (success) {
+            // Update send status
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_SUCCESS,
+                    getPendingMessagesCount(), SATELLITE_RESULT_SUCCESS);
+            reportSendSmsCompleted(pendingSms, SATELLITE_RESULT_SUCCESS);
+            if (datagramType == DATAGRAM_TYPE_CHECK_PENDING_INCOMING_SMS) {
+                startMtSmsPollingThrottle();
+                mShouldPollMtSms.set(false);
             }
+        } else {
+            // Update send status
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SEND_FAILED,
+                    getPendingMessagesCount(), SATELLITE_RESULT_NETWORK_ERROR);
+            reportSendSmsCompleted(pendingSms, SATELLITE_RESULT_NETWORK_ERROR);
+        }
 
-            if (getPendingMessagesCount() > 0) {
-                sendPendingMessages();
-            } else {
-                mDatagramController.updateSendStatus(subId, datagramType,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE, 0,
-                        SatelliteManager.SATELLITE_RESULT_SUCCESS);
-            }
+        if (getPendingMessagesCount() > 0) {
+            sendPendingMessages();
+        } else {
+            mDatagramController.updateSendStatus(subId, datagramType,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE, 0,
+                    SatelliteManager.SATELLITE_RESULT_SUCCESS);
         }
     }
 
@@ -1330,17 +1344,17 @@ public class DatagramDispatcher extends Handler {
     }
 
     private void handleCmdSendMtSmsPollingMessage() {
-        synchronized (mLock) {
-            if (!mShouldPollMtSms) {
-                plogd("sendMtSmsPollingMessage: mShouldPollMtSms=" + mShouldPollMtSms);
-                return;
-            }
+        if (!mShouldPollMtSms.get()) {
+            plogd("sendMtSmsPollingMessage: mShouldPollMtSms=" + mShouldPollMtSms.get());
+            return;
+        }
 
-            plogd("sendMtSmsPollingMessage");
-            if (!allowCheckMessageInNotConnected()) {
-                mShouldPollMtSms = false;
-            }
+        plogd("sendMtSmsPollingMessage");
+        if (!allowCheckMessageInNotConnected()) {
+            mShouldPollMtSms.set(false);
+        }
 
+        synchronized (mLock) {
             for (Entry<Long, PendingRequest> entry : mPendingSmsMap.entrySet()) {
                 PendingRequest pendingRequest = entry.getValue();
                 if (pendingRequest.isMtSmsPolling) {
@@ -1367,17 +1381,15 @@ public class DatagramDispatcher extends Handler {
         smsDispatchersController.sendMtSmsPollingMessage();
     }
 
-    @GuardedBy("mLock")
     private void startMtSmsPollingThrottle() {
         plogd("startMtSmsPollingThrottle");
-        mIsMtSmsPollingThrottled = true;
+        mIsMtSmsPollingThrottled.set(true);
         sendMessageDelayed(obtainMessage(EVENT_MT_SMS_POLLING_THROTTLE_TIMED_OUT),
                 getMtSmsPollingThrottleMillis());
     }
 
-    @GuardedBy("mLock")
     private void stopMtSmsPollingThrottle() {
-        mIsMtSmsPollingThrottled = false;
+        mIsMtSmsPollingThrottled.set(false);
         removeMessages(EVENT_MT_SMS_POLLING_THROTTLE_TIMED_OUT);
     }
 
@@ -1391,23 +1403,16 @@ public class DatagramDispatcher extends Handler {
             return false;
         }
 
-        boolean isModemStateConnectedOrTransferring;
-        boolean isAligned;
-        boolean isMtSmsPollingThrottled;
-        synchronized (mLock) {
-            isMtSmsPollingThrottled = mIsMtSmsPollingThrottled;
-            isAligned = mIsAligned;
-            isModemStateConnectedOrTransferring =
-                    mModemState == SATELLITE_MODEM_STATE_CONNECTED
-                            || mModemState == SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING;
-        }
+        boolean isModemStateConnectedOrTransferring =
+                mModemState.get() == SATELLITE_MODEM_STATE_CONNECTED
+                        || mModemState.get() == SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING;
 
-        if (isMtSmsPollingThrottled) {
+        if (mIsMtSmsPollingThrottled.get()) {
             plogd("allowMtSmsPolling: polling is throttled");
             return false;
         }
 
-        if (!isAligned) {
+        if (!mIsAligned.get()) {
             plogd("allowMtSmsPolling: not aligned");
             return false;
         }
diff --git a/src/java/com/android/internal/telephony/satellite/DatagramReceiver.java b/src/java/com/android/internal/telephony/satellite/DatagramReceiver.java
index 26d456bcd3..eb14947b2b 100644
--- a/src/java/com/android/internal/telephony/satellite/DatagramReceiver.java
+++ b/src/java/com/android/internal/telephony/satellite/DatagramReceiver.java
@@ -46,8 +46,8 @@ import android.util.Log;
 import android.util.Pair;
 
 import com.android.internal.R;
-import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.os.SomeArgs;
 import com.android.internal.telephony.IIntegerConsumer;
 import com.android.internal.telephony.IVoidConsumer;
 import com.android.internal.telephony.Phone;
@@ -58,6 +58,7 @@ import com.android.internal.telephony.satellite.metrics.SessionMetricsStats;
 import com.android.internal.util.FunctionalUtils;
 
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 
@@ -72,11 +73,14 @@ public class DatagramReceiver extends Handler {
     private static final int EVENT_POLL_PENDING_SATELLITE_DATAGRAMS_DONE = 2;
     private static final int EVENT_WAIT_FOR_DEVICE_ALIGNMENT_IN_DEMO_MODE_TIMED_OUT = 3;
     private static final int EVENT_DATAGRAM_WAIT_FOR_CONNECTED_STATE_TIMED_OUT = 4;
+    private static final int REQUEST_POLL_PENDING_SATELLITE_DATAGRAMS = 5;
+    private static final int EVENT_SATELLITE_MODEM_STATE_CHANGED = 6;
+    private static final int REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE = 7;
 
     /** Key used to read/write satellite datagramId in shared preferences. */
     private static final String SATELLITE_DATAGRAM_ID_KEY = "satellite_datagram_id_key";
-    private static AtomicLong mNextDatagramId = new AtomicLong(0);
 
+    /** All the variables initialized inside the constructor are declared here. */
     @NonNull private static DatagramReceiver sInstance;
     @NonNull private final Context mContext;
     @NonNull private final ContentResolver mContentResolver;
@@ -86,25 +90,18 @@ public class DatagramReceiver extends Handler {
     @NonNull private final SessionMetricsStats mSessionMetricsStats;
     @NonNull private final Looper mLooper;
     @NonNull private final FeatureFlags mFeatureFlags;
+    @Nullable private PersistentLogger mPersistentLogger = null;
 
-    private long mDatagramTransferStartTime = 0;
-    private boolean mIsDemoMode = false;
-    @GuardedBy("mLock")
-    private boolean mIsAligned = false;
-    @Nullable
-    private DatagramReceiverHandlerRequest mDemoPollPendingSatelliteDatagramsRequest = null;
-    @Nullable
-    private DatagramReceiverHandlerRequest mPendingPollSatelliteDatagramsRequest = null;
-    private final Object mLock = new Object();
-    @Nullable
-    private PersistentLogger mPersistentLogger = null;
-
+    /** All the atomic variables are declared here. */
+    private static AtomicLong mNextDatagramId = new AtomicLong(0);
+    private AtomicLong mDatagramTransferStartTime = new AtomicLong(0);
+    private AtomicBoolean mIsDemoMode = new AtomicBoolean(false);
+    private AtomicBoolean mIsAligned = new AtomicBoolean(false);
     /**
      * Map key: subId, value: SatelliteDatagramListenerHandler to notify registrants.
      */
     private final ConcurrentHashMap<Integer, SatelliteDatagramListenerHandler>
             mSatelliteDatagramListenerHandlers = new ConcurrentHashMap<>();
-
     /**
      * Map key: DatagramId, value: pendingAckCount
      * This map is used to track number of listeners that are yet to send ack for a particular
@@ -113,6 +110,15 @@ public class DatagramReceiver extends Handler {
     private final ConcurrentHashMap<Long, Integer>
             mPendingAckCountHashMap = new ConcurrentHashMap<>();
 
+    /**
+     * All the variables declared here should only be accessed by methods that run inside the
+     * handler thread.
+     */
+    @Nullable
+    private DatagramReceiverHandlerRequest mDemoPollPendingSatelliteDatagramsRequest = null;
+    @Nullable
+    private DatagramReceiverHandlerRequest mPendingPollSatelliteDatagramsRequest = null;
+
     /**
      * Create the DatagramReceiver singleton instance.
      * @param context The Context to use to create the DatagramReceiver.
@@ -121,6 +127,7 @@ public class DatagramReceiver extends Handler {
      * @param datagramController DatagramController which is used to update datagram transfer state.
      * @return The singleton instance of DatagramReceiver.
      */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public static DatagramReceiver make(@NonNull Context context, @NonNull Looper looper,
             @NonNull FeatureFlags featureFlags,
             @NonNull DatagramController datagramController) {
@@ -139,7 +146,7 @@ public class DatagramReceiver extends Handler {
      * @param featureFlags The telephony feature flags.
      * @param datagramController DatagramController which is used to update datagram transfer state.
      */
-    @VisibleForTesting
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected DatagramReceiver(@NonNull Context context, @NonNull Looper looper,
             @NonNull FeatureFlags featureFlags,
             @NonNull DatagramController datagramController) {
@@ -452,7 +459,7 @@ public class DatagramReceiver extends Handler {
                 int error = SatelliteServiceUtils.getSatelliteError(ar,
                         "pollPendingSatelliteDatagrams");
 
-                if (mIsDemoMode && error == SatelliteManager.SATELLITE_RESULT_SUCCESS) {
+                if (mIsDemoMode.get() && error == SatelliteManager.SATELLITE_RESULT_SUCCESS) {
                     SatelliteDatagram datagram = mDatagramController.popDemoModeDatagram();
                     final int validSubId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
                     SatelliteDatagramListenerHandler listenerHandler =
@@ -498,6 +505,43 @@ public class DatagramReceiver extends Handler {
                 handleEventDatagramWaitForConnectedStateTimedOut();
                 break;
 
+            case REQUEST_POLL_PENDING_SATELLITE_DATAGRAMS: {
+                plogd("REQUEST_POLL_PENDING_SATELLITE_DATAGRAMS");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int subId = (int) args.arg1;
+                Consumer<Integer> callback = (Consumer<Integer>) args.arg2;
+                try {
+                    handleRequestPollPendingSatelliteDatagrams(subId, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case EVENT_SATELLITE_MODEM_STATE_CHANGED: {
+                plogd("EVENT_SATELLITE_MODEM_STATE_CHANGED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int state = (int) args.arg1;
+                try {
+                    handleEventSatelliteModemStateChanged(state);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE: {
+                plogd("REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE");
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean isAligned = (boolean) args.arg1;
+                try {
+                    handleRequestSetDeviceAlignedWithSatellite(isAligned);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
             default:
                 plogw("DatagramDispatcherHandler: unexpected message code: " + msg.what);
                 break;
@@ -512,7 +556,8 @@ public class DatagramReceiver extends Handler {
      *
      * @return The {@link SatelliteManager.SatelliteResult} result of the operation.
      */
-    @SatelliteManager.SatelliteResult public int registerForSatelliteDatagram(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    @SatelliteManager.SatelliteResult protected int registerForSatelliteDatagram(int subId,
             @NonNull ISatelliteDatagramCallback callback) {
         if (!SatelliteController.getInstance().isSatelliteSupportedViaOem()) {
             return SatelliteManager.SATELLITE_RESULT_NOT_SUPPORTED;
@@ -542,8 +587,7 @@ public class DatagramReceiver extends Handler {
      * @param callback The callback that was passed to
      *                 {@link #registerForSatelliteDatagram(int, ISatelliteDatagramCallback)}.
      */
-    public void unregisterForSatelliteDatagram(int subId,
-            @NonNull ISatelliteDatagramCallback callback) {
+    void unregisterForSatelliteDatagram(int subId, @NonNull ISatelliteDatagramCallback callback) {
         final int validSubId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         SatelliteDatagramListenerHandler handler =
                 mSatelliteDatagramListenerHandlers.get(validSubId);
@@ -569,7 +613,22 @@ public class DatagramReceiver extends Handler {
      * @param subId The subId of the subscription used for receiving datagrams.
      * @param callback The callback to get {@link SatelliteManager.SatelliteResult} of the request.
      */
-    public void pollPendingSatelliteDatagrams(int subId, @NonNull Consumer<Integer> callback) {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void pollPendingSatelliteDatagrams(int subId, @NonNull Consumer<Integer> callback) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = subId;
+            args.arg2 = callback;
+            sendMessage(obtainMessage(REQUEST_POLL_PENDING_SATELLITE_DATAGRAMS, args));
+            return;
+        }
+
+        handleRequestPollPendingSatelliteDatagrams(subId, callback);
+    }
+
+    private void handleRequestPollPendingSatelliteDatagrams(int subId,
+            @NonNull Consumer<Integer> callback) {
+        plogd("handleRequestPollPendingSatelliteDatagrams");
         if (!mDatagramController.isPollingInIdleState()) {
             // Poll request should be sent to satellite modem only when it is free.
             plogd("pollPendingSatelliteDatagrams: satellite modem is busy receiving datagrams.");
@@ -581,21 +640,19 @@ public class DatagramReceiver extends Handler {
     }
 
     private void handleSatelliteConnectedEvent() {
-        synchronized (mLock) {
-            if (isDatagramWaitForConnectedStateTimerStarted()) {
-                stopDatagramWaitForConnectedStateTimer();
-                if (mPendingPollSatelliteDatagramsRequest == null) {
-                    ploge("handleSatelliteConnectedEvent: mPendingPollSatelliteDatagramsRequest is"
-                            + " null");
-                    return;
-                }
-
-                Consumer<Integer> callback =
-                        (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
-                pollPendingSatelliteDatagramsInternal(
-                        mPendingPollSatelliteDatagramsRequest.subId, callback);
-                mPendingPollSatelliteDatagramsRequest = null;
+        if (isDatagramWaitForConnectedStateTimerStarted()) {
+            stopDatagramWaitForConnectedStateTimer();
+            if (mPendingPollSatelliteDatagramsRequest == null) {
+                ploge("handleSatelliteConnectedEvent: mPendingPollSatelliteDatagramsRequest is"
+                        + " null");
+                return;
             }
+
+            Consumer<Integer> callback =
+                    (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
+            pollPendingSatelliteDatagramsInternal(
+                    mPendingPollSatelliteDatagramsRequest.subId, callback);
+            mPendingPollSatelliteDatagramsRequest = null;
         }
     }
 
@@ -612,16 +669,14 @@ public class DatagramReceiver extends Handler {
         if (mDatagramController.needsWaitingForSatelliteConnected(
                 SatelliteManager.DATAGRAM_TYPE_UNKNOWN)) {
             plogd("pollPendingSatelliteDatagramsInternal: wait for satellite connected");
-            synchronized (mLock) {
-                mPendingPollSatelliteDatagramsRequest = new DatagramReceiverHandlerRequest(
-                        callback, SatelliteServiceUtils.getPhone(), subId);
-                mDatagramController.updateReceiveStatus(subId,
-                        SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
-                        SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
-                        mDatagramController.getReceivePendingCount(),
-                        SatelliteManager.SATELLITE_RESULT_SUCCESS);
-                startDatagramWaitForConnectedStateTimer();
-            }
+            mPendingPollSatelliteDatagramsRequest = new DatagramReceiverHandlerRequest(
+                    callback, SatelliteServiceUtils.getPhone(), subId);
+            mDatagramController.updateReceiveStatus(subId,
+                    SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
+                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_WAITING_TO_CONNECT,
+                    mDatagramController.getReceivePendingCount(),
+                    SatelliteManager.SATELLITE_RESULT_SUCCESS);
+            startDatagramWaitForConnectedStateTimer();
             return;
         }
 
@@ -630,21 +685,19 @@ public class DatagramReceiver extends Handler {
                 SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVING,
                 mDatagramController.getReceivePendingCount(),
                 SatelliteManager.SATELLITE_RESULT_SUCCESS);
-        mDatagramTransferStartTime = System.currentTimeMillis();
+        mDatagramTransferStartTime.set(System.currentTimeMillis());
         Phone phone = SatelliteServiceUtils.getPhone();
 
-        if (mIsDemoMode) {
+        if (mIsDemoMode.get()) {
             DatagramReceiverHandlerRequest request = new DatagramReceiverHandlerRequest(
                     callback, phone, subId);
-            synchronized (mLock) {
-                if (!mDatagramController.waitForAligningToSatellite(mIsAligned)) {
-                    Message msg = obtainMessage(EVENT_POLL_PENDING_SATELLITE_DATAGRAMS_DONE,
-                            request);
-                    AsyncResult.forMessage(msg, null, null);
-                    msg.sendToTarget();
-                } else {
-                    startSatelliteAlignedTimer(request);
-                }
+            if (!mDatagramController.waitForAligningToSatellite(mIsAligned.get())) {
+                Message msg = obtainMessage(EVENT_POLL_PENDING_SATELLITE_DATAGRAMS_DONE,
+                        request);
+                AsyncResult.forMessage(msg, null, null);
+                msg.sendToTarget();
+            } else {
+                startSatelliteAlignedTimer(request);
             }
         } else {
             sendRequestAsync(CMD_POLL_PENDING_SATELLITE_DATAGRAMS, callback, phone, subId);
@@ -657,19 +710,30 @@ public class DatagramReceiver extends Handler {
      *
      * @param state Current satellite modem state.
      */
-    public void onSatelliteModemStateChanged(@SatelliteManager.SatelliteModemState int state) {
-        synchronized (mLock) {
-            if (state == SatelliteManager.SATELLITE_MODEM_STATE_OFF
-                    || state == SatelliteManager.SATELLITE_MODEM_STATE_UNAVAILABLE) {
-                plogd("onSatelliteModemStateChanged: cleaning up resources");
-                cleanUpResources();
-            } else if (state == SATELLITE_MODEM_STATE_CONNECTED) {
-                handleSatelliteConnectedEvent();
-            }
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void onSatelliteModemStateChanged(@SatelliteManager.SatelliteModemState int state) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = state;
+            sendMessage(obtainMessage(EVENT_SATELLITE_MODEM_STATE_CHANGED, args));
+            return;
+        }
+
+        handleEventSatelliteModemStateChanged(state);
+    }
+
+    private void handleEventSatelliteModemStateChanged(
+            @SatelliteManager.SatelliteModemState int state) {
+        plogd("handleEventSatelliteModemStateChanged: state = " + state);
+        if (state == SatelliteManager.SATELLITE_MODEM_STATE_OFF
+                || state == SatelliteManager.SATELLITE_MODEM_STATE_UNAVAILABLE) {
+            plogd("onSatelliteModemStateChanged: cleaning up resources");
+            cleanUpResources();
+        } else if (state == SATELLITE_MODEM_STATE_CONNECTED) {
+            handleSatelliteConnectedEvent();
         }
     }
 
-    @GuardedBy("mLock")
     private void cleanupDemoModeResources() {
         if (isSatelliteAlignedTimerStarted()) {
             stopSatelliteAlignedTimer();
@@ -682,22 +746,19 @@ public class DatagramReceiver extends Handler {
                 callback.accept(SatelliteManager.SATELLITE_RESULT_REQUEST_ABORTED);
             }
         }
-        mIsDemoMode = false;
+        mIsDemoMode.set(false);
         mDemoPollPendingSatelliteDatagramsRequest = null;
-        mIsAligned = false;
+        mIsAligned.set(false);
     }
 
-    @GuardedBy("mLock")
     private void cleanUpResources() {
-        synchronized (mLock) {
-            if (mPendingPollSatelliteDatagramsRequest != null) {
-                Consumer<Integer> callback =
-                        (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
-                callback.accept(SatelliteManager.SATELLITE_RESULT_REQUEST_ABORTED);
-                mPendingPollSatelliteDatagramsRequest = null;
-            }
-            stopDatagramWaitForConnectedStateTimer();
+        if (mPendingPollSatelliteDatagramsRequest != null) {
+            Consumer<Integer> callback =
+                    (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
+            callback.accept(SatelliteManager.SATELLITE_RESULT_REQUEST_ABORTED);
+            mPendingPollSatelliteDatagramsRequest = null;
         }
+        stopDatagramWaitForConnectedStateTimer();
 
         int subId = SatelliteController.getInstance().getSelectedSatelliteSubId();
         if (mDatagramController.isReceivingDatagrams()) {
@@ -743,21 +804,21 @@ public class DatagramReceiver extends Handler {
                 datagramSizeRoundedBytes =
                         (int) (Math.round((double) sizeBytes / ROUNDING_UNIT) * ROUNDING_UNIT);
             }
-            datagramTransferTime = (System.currentTimeMillis() - mDatagramTransferStartTime);
+            datagramTransferTime = (System.currentTimeMillis() - mDatagramTransferStartTime.get());
         }
-        mDatagramTransferStartTime = 0;
+        mDatagramTransferStartTime.set(0);
 
         SatelliteStats.getInstance().onSatelliteIncomingDatagramMetrics(
                 new SatelliteStats.SatelliteIncomingDatagramParams.Builder()
                         .setResultCode(resultCode)
                         .setDatagramSizeBytes(datagramSizeRoundedBytes)
                         .setDatagramTransferTimeMillis(datagramTransferTime)
-                        .setIsDemoMode(mIsDemoMode)
+                        .setIsDemoMode(mIsDemoMode.get())
                         .setCarrierId(SatelliteController.getInstance().getSatelliteCarrierId())
                         .setIsNtnOnlyCarrier(SatelliteController.getInstance().isNtnOnlyCarrier())
                         .build());
 
-        mControllerMetricsStats.reportIncomingDatagramCount(resultCode, mIsDemoMode);
+        mControllerMetricsStats.reportIncomingDatagramCount(resultCode, mIsDemoMode.get());
         if (resultCode == SATELLITE_RESULT_SUCCESS) {
             mSessionMetricsStats.addCountOfSuccessfulIncomingDatagram();
         } else {
@@ -771,16 +832,25 @@ public class DatagramReceiver extends Handler {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     protected void setDemoMode(boolean isDemoMode) {
-        mIsDemoMode = isDemoMode;
+        mIsDemoMode.set(isDemoMode);
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public void setDeviceAlignedWithSatellite(boolean isAligned) {
-        synchronized (mLock) {
-            mIsAligned = isAligned;
-            plogd("setDeviceAlignedWithSatellite: " + mIsAligned);
-            if (isAligned && mIsDemoMode) handleEventSatelliteAligned();
+    protected void setDeviceAlignedWithSatellite(boolean isAligned) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = isAligned;
+            sendMessage(obtainMessage(REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE, args));
+            return;
         }
+
+        handleRequestSetDeviceAlignedWithSatellite(isAligned);
+    }
+
+    private void handleRequestSetDeviceAlignedWithSatellite(boolean isAligned) {
+        mIsAligned.set(isAligned);
+        plogd("setDeviceAlignedWithSatellite: " + isAligned);
+        if (isAligned && mIsDemoMode.get()) handleEventSatelliteAligned();
     }
 
     private void startSatelliteAlignedTimer(DatagramReceiverHandlerRequest request) {
@@ -849,38 +919,36 @@ public class DatagramReceiver extends Handler {
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    public boolean isDatagramWaitForConnectedStateTimerStarted() {
+    protected boolean isDatagramWaitForConnectedStateTimerStarted() {
         return hasMessages(EVENT_DATAGRAM_WAIT_FOR_CONNECTED_STATE_TIMED_OUT);
     }
 
     private void handleEventDatagramWaitForConnectedStateTimedOut() {
-        synchronized (mLock) {
-            if (mPendingPollSatelliteDatagramsRequest == null) {
-                plogw("handleEventDatagramWaitForConnectedStateTimedOut: "
-                        + "mPendingPollSatelliteDatagramsRequest is null");
-                return;
-            }
+        if (mPendingPollSatelliteDatagramsRequest == null) {
+            plogw("handleEventDatagramWaitForConnectedStateTimedOut: "
+                    + "mPendingPollSatelliteDatagramsRequest is null");
+            return;
+        }
 
-            plogw("Timed out to wait for satellite connected before polling datagrams");
-            mDatagramController.updateReceiveStatus(mPendingPollSatelliteDatagramsRequest.subId,
-                    SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVE_FAILED,
-                    mDatagramController.getReceivePendingCount(),
-                    SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
+        plogw("Timed out to wait for satellite connected before polling datagrams");
+        mDatagramController.updateReceiveStatus(mPendingPollSatelliteDatagramsRequest.subId,
+                SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_RECEIVE_FAILED,
+                mDatagramController.getReceivePendingCount(),
+                SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
 
-            mDatagramController.updateReceiveStatus(mPendingPollSatelliteDatagramsRequest.subId,
-                    SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
-                    SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
-                    mDatagramController.getReceivePendingCount(),
-                    SatelliteManager.SATELLITE_RESULT_SUCCESS);
+        mDatagramController.updateReceiveStatus(mPendingPollSatelliteDatagramsRequest.subId,
+                SatelliteManager.DATAGRAM_TYPE_SOS_MESSAGE,
+                SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_IDLE,
+                mDatagramController.getReceivePendingCount(),
+                SatelliteManager.SATELLITE_RESULT_SUCCESS);
 
-            reportMetrics(null, SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
+        reportMetrics(null, SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
 
-            Consumer<Integer> callback =
-                    (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
-            callback.accept(SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
-            mPendingPollSatelliteDatagramsRequest = null;
-        }
+        Consumer<Integer> callback =
+                (Consumer<Integer>) mPendingPollSatelliteDatagramsRequest.argument;
+        callback.accept(SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
+        mPendingPollSatelliteDatagramsRequest = null;
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/satellite/DemoSimulator.java b/src/java/com/android/internal/telephony/satellite/DemoSimulator.java
index d908597439..feb42c96d1 100644
--- a/src/java/com/android/internal/telephony/satellite/DemoSimulator.java
+++ b/src/java/com/android/internal/telephony/satellite/DemoSimulator.java
@@ -28,11 +28,12 @@ import android.telephony.satellite.stub.SatelliteModemState;
 import android.telephony.satellite.stub.SatelliteResult;
 import android.util.Log;
 
-import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 public class DemoSimulator extends StateMachine {
     private static final String TAG = "DemoSimulator";
     private static final boolean DBG = true;
@@ -50,11 +51,10 @@ public class DemoSimulator extends StateMachine {
     @NonNull private final PowerOffState mPowerOffState = new PowerOffState();
     @NonNull private final NotConnectedState mNotConnectedState = new NotConnectedState();
     @NonNull private final ConnectedState mConnectedState = new ConnectedState();
-    @NonNull private final Object mLock = new Object();
-    @GuardedBy("mLock")
-    private boolean mIsAligned = false;
     private ISatelliteListener mISatelliteListener;
 
+    private AtomicBoolean mIsAligned = new AtomicBoolean(false);
+
     /**
      * @return The singleton instance of DemoSimulator.
      */
@@ -134,10 +134,8 @@ public class DemoSimulator extends StateMachine {
                         SatelliteModemState.SATELLITE_MODEM_STATE_OUT_OF_SERVICE);
                 mISatelliteListener.onNtnSignalStrengthChanged(ntnSignalStrength);
 
-                synchronized (mLock) {
-                    if (mIsAligned) {
-                        handleEventDeviceAlignedWithSatellite(true);
-                    }
+                if (mIsAligned.get()) {
+                    handleEventDeviceAlignedWithSatellite(true);
                 }
             } catch (RemoteException e) {
                 loge("NotConnectedState: RemoteException " + e);
@@ -194,10 +192,8 @@ public class DemoSimulator extends StateMachine {
                         SatelliteModemState.SATELLITE_MODEM_STATE_IN_SERVICE);
                 mISatelliteListener.onNtnSignalStrengthChanged(ntnSignalStrength);
 
-                synchronized (mLock) {
-                    if (!mIsAligned) {
-                        handleEventDeviceAlignedWithSatellite(false);
-                    }
+                if (!mIsAligned.get()) {
+                    handleEventDeviceAlignedWithSatellite(false);
                 }
             } catch (RemoteException e) {
                 loge("ConnectedState: RemoteException " + e);
@@ -318,12 +314,10 @@ public class DemoSimulator extends StateMachine {
      * Set whether the device is aligned with the satellite.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    public void setDeviceAlignedWithSatellite(boolean isAligned) {
-        synchronized (mLock) {
-            if (mSatelliteController.isDemoModeEnabled()) {
-                mIsAligned = isAligned;
-                sendMessage(EVENT_DEVICE_ALIGNED_WITH_SATELLITE, isAligned);
-            }
+    protected void setDeviceAlignedWithSatellite(boolean isAligned) {
+        if (mSatelliteController.isDemoModeEnabled()) {
+            mIsAligned.set(isAligned);
+            sendMessage(EVENT_DEVICE_ALIGNED_WITH_SATELLITE, isAligned);
         }
     }
 }
diff --git a/src/java/com/android/internal/telephony/satellite/PointingAppController.java b/src/java/com/android/internal/telephony/satellite/PointingAppController.java
index 484632356f..cf9ca2841d 100644
--- a/src/java/com/android/internal/telephony/satellite/PointingAppController.java
+++ b/src/java/com/android/internal/telephony/satellite/PointingAppController.java
@@ -44,51 +44,63 @@ import android.text.TextUtils;
 import android.util.Log;
 
 import com.android.internal.R;
-import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.os.SomeArgs;
 import com.android.internal.telephony.flags.FeatureFlags;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 /**
  * PointingApp controller to manage interactions with PointingUI app.
  */
-public class PointingAppController {
+public class PointingAppController extends Handler {
     private static final String TAG = "PointingAppController";
     private static final String ALLOW_MOCK_MODEM_PROPERTY = "persist.radio.allow_mock_modem";
     private static final boolean DEBUG = !"user".equals(Build.TYPE);
 
+    private static final int REQUEST_START_POINTING_UI = 1;
+    private static final int REQUEST_REMOVE_LISTENER_FOR_POINTING_UI = 2;
+
+    /** All the variables initialized inside the constructor are declared here. */
     @NonNull
     private static PointingAppController sInstance;
     @NonNull private final Context mContext;
     @NonNull private final FeatureFlags mFeatureFlags;
-    private boolean mStartedSatelliteTransmissionUpdates;
-    private boolean mLastNeedFullScreenPointingUI;
-    private boolean mLastIsDemoMode;
-    private boolean mLastIsEmergency;
-
-    private final Object mListenerForPointingUIRegisteredLock = new Object();
-    @GuardedBy("mListenerForPointingUIRegisteredLock")
-    private boolean mListenerForPointingUIRegistered;
-    @NonNull private String mPointingUiPackageName = "";
-    @NonNull private String mPointingUiClassName = "";
     @NonNull private ActivityManager mActivityManager;
-    @NonNull public UidImportanceListener mUidImportanceListener = new UidImportanceListener();
+    @Nullable private PersistentLogger mPersistentLogger = null;
+
+    /** All the variables initialized inside the constructor are declared here. */
+    private AtomicBoolean mStartedSatelliteTransmissionUpdates = new AtomicBoolean(false);
+    private AtomicBoolean mLastNeedFullScreenPointingUI = new AtomicBoolean(false);
+    private AtomicBoolean mLastIsDemoMode = new AtomicBoolean(false);
+    private AtomicBoolean mLastIsEmergency = new AtomicBoolean(false);
+    private AtomicBoolean mListenerForPointingUIRegistered = new AtomicBoolean(false);
+
     /**
      * Map key: subId, value: SatelliteTransmissionUpdateHandler to notify registrants.
      */
     private final ConcurrentHashMap<Integer, SatelliteTransmissionUpdateHandler>
             mSatelliteTransmissionUpdateHandlers = new ConcurrentHashMap<>();
-    @Nullable private PersistentLogger mPersistentLogger = null;
+
+
+    /**
+     * All the variables declared here should only be accessed by methods that run inside the
+     * handler thread.
+     */
+    @NonNull private String mPointingUiPackageName = "";
+    @NonNull private String mPointingUiClassName = "";
+    @NonNull public UidImportanceListener mUidImportanceListener = new UidImportanceListener();
+
 
     /**
      * @return The singleton instance of PointingAppController.
      */
-    public static PointingAppController getInstance() {
+    static PointingAppController getInstance() {
         if (sInstance == null) {
             loge("PointingAppController was not yet initialized.");
         }
@@ -101,7 +113,7 @@ public class PointingAppController {
      * @param featureFlags The telephony feature flags.
      * @return The singleton instance of PointingAppController.
      */
-    public static PointingAppController make(@NonNull Context context,
+    static PointingAppController make(@NonNull Context context,
             @NonNull FeatureFlags featureFlags) {
         if (sInstance == null) {
             sInstance = new PointingAppController(context, featureFlags);
@@ -115,37 +127,61 @@ public class PointingAppController {
      * @param context The Context for the PointingUIController.
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    public PointingAppController(@NonNull Context context,
+    protected PointingAppController(@NonNull Context context,
             @NonNull FeatureFlags featureFlags) {
         mContext = context;
         mFeatureFlags = featureFlags;
-        mStartedSatelliteTransmissionUpdates = false;
-        mLastNeedFullScreenPointingUI = false;
-        mLastIsDemoMode = false;
-        mLastIsEmergency = false;
-        mListenerForPointingUIRegistered = false;
+        mListenerForPointingUIRegistered.set(false);
         mActivityManager = mContext.getSystemService(ActivityManager.class);
         mPersistentLogger = SatelliteServiceUtils.getPersistentLogger(context);
     }
 
+    @Override
+    public void handleMessage(Message msg) {
+        switch (msg.what) {
+            case REQUEST_START_POINTING_UI: {
+                plogd("REQUEST_START_POINTING_UI");
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean needFullScreenPointingUI = (boolean) args.arg1;
+                boolean isDemoMode = (boolean) args.arg2;
+                boolean isEmergency = (boolean) args.arg3;
+                try {
+                    handleRequestStartPointingUI(needFullScreenPointingUI, isDemoMode, isEmergency);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_REMOVE_LISTENER_FOR_POINTING_UI: {
+                handleRequestRemoveListenerForPointingUI();
+                break;
+            }
+
+            default:
+                ploge("PointingAppControllerHandler: unexpected message code: " + msg.what);
+                break;
+        }
+    }
+
     /**
      * Set the flag mStartedSatelliteTransmissionUpdates to true or false based on the state of
      * transmission updates
      * @param startedSatelliteTransmissionUpdates boolean to set the flag
      */
-    @VisibleForTesting
-    public void setStartedSatelliteTransmissionUpdates(
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void setStartedSatelliteTransmissionUpdates(
             boolean startedSatelliteTransmissionUpdates) {
-        mStartedSatelliteTransmissionUpdates = startedSatelliteTransmissionUpdates;
+        mStartedSatelliteTransmissionUpdates.set(startedSatelliteTransmissionUpdates);
     }
 
     /**
      * Get the flag mStartedSatelliteTransmissionUpdates
      * @return returns mStartedSatelliteTransmissionUpdates
      */
-    @VisibleForTesting
-    public boolean getStartedSatelliteTransmissionUpdates() {
-        return mStartedSatelliteTransmissionUpdates;
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected boolean getStartedSatelliteTransmissionUpdates() {
+        return mStartedSatelliteTransmissionUpdates.get();
     }
 
     /**
@@ -163,8 +199,8 @@ public class PointingAppController {
             if (callerPackages != null) {
                 if (Arrays.stream(callerPackages).anyMatch(pointingUiPackage::contains)) {
                     plogd("Restarting pointingUI");
-                    startPointingUI(mLastNeedFullScreenPointingUI, mLastIsDemoMode,
-                            mLastIsEmergency);
+                    startPointingUI(mLastNeedFullScreenPointingUI.get(), mLastIsDemoMode.get(),
+                            mLastIsEmergency.get());
                 }
             }
         }
@@ -309,7 +345,8 @@ public class PointingAppController {
      * @param subId The subId of the subscription to register for receiving the updates.
      * @param callback The callback to notify of satellite transmission updates.
      */
-    public void registerForSatelliteTransmissionUpdates(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void registerForSatelliteTransmissionUpdates(int subId,
             ISatelliteTransmissionUpdateCallback callback) {
         subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         SatelliteTransmissionUpdateHandler handler =
@@ -338,7 +375,8 @@ public class PointingAppController {
      * @param callback The callback that was passed to {@link
      * #registerForSatelliteTransmissionUpdates(int, ISatelliteTransmissionUpdateCallback)}.
      */
-    public void unregisterForSatelliteTransmissionUpdates(int subId, Consumer<Integer> result,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void unregisterForSatelliteTransmissionUpdates(int subId, Consumer<Integer> result,
             ISatelliteTransmissionUpdateCallback callback) {
         subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         SatelliteTransmissionUpdateHandler handler =
@@ -365,8 +403,9 @@ public class PointingAppController {
      * {@link android.telephony.satellite.SatelliteTransmissionUpdateCallback
      * #onSatellitePositionChanged(pointingInfo)}.
      */
-    public void startSatelliteTransmissionUpdates(@NonNull Message message) {
-        if (mStartedSatelliteTransmissionUpdates) {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void startSatelliteTransmissionUpdates(@NonNull Message message) {
+        if (mStartedSatelliteTransmissionUpdates.get()) {
             plogd("startSatelliteTransmissionUpdates: already started");
             AsyncResult.forMessage(message, null, new SatelliteManager.SatelliteException(
                     SatelliteManager.SATELLITE_RESULT_SUCCESS));
@@ -374,7 +413,7 @@ public class PointingAppController {
             return;
         }
         SatelliteModemInterface.getInstance().startSendingSatellitePointingInfo(message);
-        mStartedSatelliteTransmissionUpdates = true;
+        mStartedSatelliteTransmissionUpdates.set(true);
     }
 
     /**
@@ -382,7 +421,8 @@ public class PointingAppController {
      * Reset the flag mStartedSatelliteTransmissionUpdates
      * This can be called by the pointing UI when the user stops pointing to the satellite.
      */
-    public void stopSatelliteTransmissionUpdates(@NonNull Message message) {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void stopSatelliteTransmissionUpdates(@NonNull Message message) {
         setStartedSatelliteTransmissionUpdates(false);
         SatelliteModemInterface.getInstance().stopSendingSatellitePointingInfo(message);
     }
@@ -391,7 +431,22 @@ public class PointingAppController {
      * Check if Pointing is needed and Launch Pointing UI
      * @param needFullScreenPointingUI if pointing UI has to be launchd with Full screen
      */
-    public void startPointingUI(boolean needFullScreenPointingUI, boolean isDemoMode,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void startPointingUI(boolean needFullScreenPointingUI, boolean isDemoMode,
+            boolean isEmergency) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = needFullScreenPointingUI;
+            args.arg2 = isDemoMode;
+            args.arg3 = isEmergency;
+            sendMessage(obtainMessage(REQUEST_START_POINTING_UI, args));
+            return;
+        }
+
+        handleRequestStartPointingUI(needFullScreenPointingUI, isDemoMode, isEmergency);
+    }
+
+    private void handleRequestStartPointingUI(boolean needFullScreenPointingUI, boolean isDemoMode,
             boolean isEmergency) {
         String packageName = getPointingUiPackageName();
         if (TextUtils.isEmpty(packageName)) {
@@ -417,18 +472,18 @@ public class PointingAppController {
         launchIntent.putExtra("needFullScreen", needFullScreenPointingUI);
         launchIntent.putExtra("isDemoMode", isDemoMode);
         launchIntent.putExtra("isEmergency", isEmergency);
+        launchIntent.setFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
 
         try {
-            synchronized (mListenerForPointingUIRegisteredLock) {
-                if (!mListenerForPointingUIRegistered) {
-                    mActivityManager.addOnUidImportanceListener(mUidImportanceListener,
-                            IMPORTANCE_GONE);
-                    mListenerForPointingUIRegistered = true;
-                }
+            if (!mListenerForPointingUIRegistered.get()) {
+                mActivityManager.addOnUidImportanceListener(mUidImportanceListener,
+                        IMPORTANCE_GONE);
+                mListenerForPointingUIRegistered.set(true);
             }
-            mLastNeedFullScreenPointingUI = needFullScreenPointingUI;
-            mLastIsDemoMode = isDemoMode;
-            mLastIsEmergency = isEmergency;
+
+            mLastNeedFullScreenPointingUI.set(needFullScreenPointingUI);
+            mLastIsDemoMode.set(isDemoMode);
+            mLastIsEmergency.set(isEmergency);
             mContext.startActivityAsUser(launchIntent, UserHandle.CURRENT);
         } catch (ActivityNotFoundException | IllegalArgumentException ex) {
             ploge("startPointingUI: Unable to start Pointing UI activity due to an exception, ex="
@@ -439,16 +494,26 @@ public class PointingAppController {
     /**
      * Remove the Importance Listener For Pointing UI App once the satellite is disabled
      */
-    public void removeListenerForPointingUI() {
-        synchronized (mListenerForPointingUIRegisteredLock) {
-            if (mListenerForPointingUIRegistered) {
-                mActivityManager.removeOnUidImportanceListener(mUidImportanceListener);
-                mListenerForPointingUIRegistered = false;
-            }
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void removeListenerForPointingUI() {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            sendMessage(obtainMessage(REQUEST_REMOVE_LISTENER_FOR_POINTING_UI));
+            return;
+        }
+
+        handleRequestRemoveListenerForPointingUI();
+    }
+
+    private void handleRequestRemoveListenerForPointingUI() {
+        plogd("handleRequestRemoveListenerForPointingUI");
+        if (mListenerForPointingUIRegistered.get()) {
+            mActivityManager.removeOnUidImportanceListener(mUidImportanceListener);
+            mListenerForPointingUIRegistered.set(false);
         }
     }
 
-    public void updateSendDatagramTransferState(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void updateSendDatagramTransferState(int subId,
             @SatelliteManager.DatagramType int datagramType,
             @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
             int sendPendingCount, int errorCode) {
@@ -472,8 +537,7 @@ public class PointingAppController {
      * This API is used to notify PointingAppController that a send datagram has just been
      * requested.
      */
-    public void onSendDatagramRequested(
-            int subId, @SatelliteManager.DatagramType int datagramType) {
+    void onSendDatagramRequested(int subId, @SatelliteManager.DatagramType int datagramType) {
         subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         SatelliteTransmissionUpdateHandler handler =
                 mSatelliteTransmissionUpdateHandlers.get(subId);
@@ -487,7 +551,8 @@ public class PointingAppController {
         }
     }
 
-    public void updateReceiveDatagramTransferState(int subId,
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected void updateReceiveDatagramTransferState(int subId,
             @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
             int receivePendingCount, int errorCode) {
         DatagramTransferStateHandlerRequest request = new DatagramTransferStateHandlerRequest(
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteConfig.java b/src/java/com/android/internal/telephony/satellite/SatelliteConfig.java
index cfade3021d..d33ba0451c 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteConfig.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteConfig.java
@@ -53,30 +53,85 @@ public class SatelliteConfig {
             "satelltie_access_config.json";
     private int mVersion;
     private Map<Integer, Map<String, Set<Integer>>> mSupportedServicesPerCarrier;
+    private Integer mCarrierRoamingMaxAllowedDataMode;
     private List<String> mSatelliteRegionCountryCodes;
     private Boolean mIsSatelliteRegionAllowed;
     private File mSatS2File;
     private File mSatelliteAccessConfigJsonFile;
     private SatelliteConfigData.SatelliteConfigProto mConfigData;
 
-    public SatelliteConfig(SatelliteConfigData.SatelliteConfigProto configData) {
+    public SatelliteConfig() {
+        logd("SatelliteConfig: constructing from scratch");
+    }
+
+    public SatelliteConfig(@NonNull SatelliteConfig satelliteConfig) {
+        logd("SatelliteConfig: constructing through deep copy of: " + satelliteConfig);
+        new SatelliteConfig(satelliteConfig.mConfigData);
+    }
+
+    public SatelliteConfig(@NonNull SatelliteConfigData.SatelliteConfigProto configData) {
+        logd("SatelliteConfig: constructing with configData: " + configData);
         mConfigData = configData;
         mVersion = mConfigData.version;
-        mSupportedServicesPerCarrier = getCarrierSupportedSatelliteServices();
-        mSatelliteRegionCountryCodes = List.of(
-                mConfigData.deviceSatelliteRegion.countryCodes);
-        mIsSatelliteRegionAllowed = mConfigData.deviceSatelliteRegion.isAllowed;
-        mSatS2File = null;
-        mSatelliteAccessConfigJsonFile = null;
-
-        Log.d(TAG, "mVersion:" + mVersion + " | "
-                + "mSupportedServicesPerCarrier:" + mSupportedServicesPerCarrier + " | "
-                + "mSatelliteRegionCountryCodes:"
-                + String.join(",", mSatelliteRegionCountryCodes) + " | "
-                + "mIsSatelliteRegionAllowed:" + mIsSatelliteRegionAllowed + " | "
-                + "s2CellFile size:" + mConfigData.deviceSatelliteRegion.s2CellFile.length  + " | "
-                + "satellite_access_config_json size:"
-                + mConfigData.deviceSatelliteRegion.satelliteAccessConfigFile.length);
+        logd("mVersion: " + mVersion);
+        buildCarrierSupportedServicesPerCarrier();
+        buildCarrierRoamingConfig();
+        buildDeviceSatelliteRegion();
+    }
+
+    private void buildCarrierSupportedServicesPerCarrier() {
+        logd("buildCarrierSupportedServicesPerCarrier");
+        if (mConfigData.carrierSupportedSatelliteServices == null) {
+            logd("mSupportedServicesPerCarrier: empty");
+        } else {
+            mSupportedServicesPerCarrier = getCarrierSupportedSatelliteServices();
+            logd("mSupportedServicesPerCarrier: " + mSupportedServicesPerCarrier);
+        }
+    }
+
+    private void buildCarrierRoamingConfig() {
+        logd("buildCarrierRoamingConfig");
+        if (mConfigData.carrierRoamingConfig == null) {
+            logd("mConfigData.carrierRoamingConfig: empty");
+        } else {
+            mCarrierRoamingMaxAllowedDataMode = mConfigData.carrierRoamingConfig.maxAllowedDataMode;
+            logd("mCarrierRoamingMaxAllowedDataMode: " + mCarrierRoamingMaxAllowedDataMode);
+        }
+    }
+
+    private void buildDeviceSatelliteRegion() {
+        logd("buildDeviceSatelliteRegion");
+        if (mConfigData.deviceSatelliteRegion == null) {
+            logd("mConfigData.deviceSatelliteRegion: empty");
+        } else {
+            if (mConfigData.deviceSatelliteRegion.countryCodes == null) {
+                logd("mConfigData.deviceSatelliteRegion.countryCodes is null, set empty list");
+                mSatelliteRegionCountryCodes = new ArrayList<>();
+            } else {
+                mSatelliteRegionCountryCodes = List.of(
+                        mConfigData.deviceSatelliteRegion.countryCodes);
+                logd("mSatelliteRegionCountryCodes: "
+                        + String.join(",", mSatelliteRegionCountryCodes));
+            }
+
+            mIsSatelliteRegionAllowed = mConfigData.deviceSatelliteRegion.isAllowed;
+            logd("mIsSatelliteRegionAllowed: " + mIsSatelliteRegionAllowed);
+
+            mSatS2File = null;
+            if (mConfigData.deviceSatelliteRegion.s2CellFile != null)  {
+                logd("s2CellFile size: " + mConfigData.deviceSatelliteRegion.s2CellFile.length);
+            } else {
+                logd("s2CellFile: empty");
+            }
+
+            mSatelliteAccessConfigJsonFile = null;
+            if (mConfigData.deviceSatelliteRegion.satelliteAccessConfigFile != null)  {
+                logd("satellite_access_config_json size: "
+                        + mConfigData.deviceSatelliteRegion.satelliteAccessConfigFile.length);
+            } else {
+                logd("satellite_access_config_json: empty");
+            }
+        }
     }
 
     /**
@@ -105,6 +160,31 @@ public class SatelliteConfig {
         return carrierToServicesMap;
     }
 
+    /**
+     * @return An {@link Integer} representing the value of
+     * {@code mCarrierRoamingMaxAllowedDataMode}. Returns {@code null} if it is not set,
+     * which usually implies missing or incomplete configuration
+     */
+    @Nullable
+    public Integer getSatelliteMaxAllowedDataMode() {
+        if (mCarrierRoamingMaxAllowedDataMode != null) {
+            return mCarrierRoamingMaxAllowedDataMode;
+        }
+        logd("mCarrierRoamingMaxAllowedDataMode : mConfigData is null or no config data");
+        return null;
+    }
+
+    /**
+     * Overrides the satellite max allowed data mode.
+     *
+     * @param maxAllowedDataMode the new max allowed data mode
+     */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    public void overrideSatelliteMaxAllowedDataMode(int maxAllowedDataMode) {
+        logd("overrideSatelliteMaxAllowedDataMode: " + maxAllowedDataMode);
+        mCarrierRoamingMaxAllowedDataMode = maxAllowedDataMode;
+    }
+
     /**
      * Get satellite plmns for carrier
      *
@@ -120,7 +200,7 @@ public class SatelliteConfig {
                 return new ArrayList<>(satelliteCapabilitiesMap.keySet());
             }
         }
-        Log.d(TAG, "getAllSatellitePlmnsForCarrier : mConfigData is null or no config data");
+        logd("getAllSatellitePlmnsForCarrier : mConfigData is null or no config data");
         return new ArrayList<>();
     }
 
@@ -139,10 +219,10 @@ public class SatelliteConfig {
             if (satelliteCapaMap != null) {
                 return satelliteCapaMap;
             } else {
-                Log.d(TAG, "No supported services found for carrier=" + carrierId);
+                logd("No supported services found for carrier=" + carrierId);
             }
         } else {
-            Log.d(TAG, "mSupportedServicesPerCarrier is null");
+            logd("mSupportedServicesPerCarrier is null");
         }
         return new HashMap<>();
     }
@@ -168,7 +248,7 @@ public class SatelliteConfig {
         if (mSatelliteRegionCountryCodes != null) {
             return mSatelliteRegionCountryCodes;
         }
-        Log.d(TAG, "getDeviceSatelliteCountryCodes : mConfigData is null or no config data");
+        logd("getDeviceSatelliteCountryCodes : mConfigData is null or no config data");
         return new ArrayList<>();
     }
 
@@ -178,7 +258,7 @@ public class SatelliteConfig {
     @Nullable
     public Boolean isSatelliteDataForAllowedRegion() {
         if (mIsSatelliteRegionAllowed == null) {
-            Log.d(TAG, "getIsSatelliteRegionAllowed : mConfigData is null or no config data");
+            logd("getIsSatelliteRegionAllowed : mConfigData is null or no config data");
         }
         return mIsSatelliteRegionAllowed;
     }
@@ -191,12 +271,12 @@ public class SatelliteConfig {
     @Nullable
     public File getSatelliteS2CellFile(@Nullable Context context) {
         if (context == null) {
-            Log.d(TAG, "getSatelliteS2CellFile : context is null");
+            logd("getSatelliteS2CellFile : context is null");
             return null;
         }
 
         if (isFileExist(mSatS2File)) {
-            Log.d(TAG, "File mSatS2File is already exist");
+            logd("File mSatS2File is already exist");
             return mSatS2File;
         }
 
@@ -205,7 +285,7 @@ public class SatelliteConfig {
                     context, mConfigData.deviceSatelliteRegion.s2CellFile, S2_CELL_FILE_NAME);
             return mSatS2File;
         }
-        Log.d(TAG, "getSatelliteS2CellFile: "
+        logd("getSatelliteS2CellFile: "
                 + "mConfigData is null or mConfigData.deviceSatelliteRegion is null");
         return null;
     }
@@ -217,12 +297,12 @@ public class SatelliteConfig {
     @Nullable
     public File getSatelliteAccessConfigJsonFile(@Nullable Context context) {
         if (context == null) {
-            Log.d(TAG, "getSatelliteAccessConfigJsonFile : context is null");
+            logd("getSatelliteAccessConfigJsonFile : context is null");
             return null;
         }
 
         if (isFileExist(mSatelliteAccessConfigJsonFile)) {
-            Log.d(TAG, "File mSatelliteAccessConfigJsonFile is already exist");
+            logd("File mSatelliteAccessConfigJsonFile is already exist");
             return mSatelliteAccessConfigJsonFile;
         }
 
@@ -232,7 +312,7 @@ public class SatelliteConfig {
                     SATELLITE_ACCESS_CONFIG_JSON_FILE_NAME);
             return mSatelliteAccessConfigJsonFile;
         }
-        Log.d(TAG, "mSatelliteAccessConfigJsonFile: "
+        logd("mSatelliteAccessConfigJsonFile: "
                 + "mConfigData is null or mConfigData.deviceSatelliteRegion is null");
         return null;
     }
@@ -244,7 +324,7 @@ public class SatelliteConfig {
      */
     @NonNull
     public int getSatelliteConfigDataVersion() {
-        Log.d(TAG, "getSatelliteConfigDataVersion: mVersion: " + mVersion);
+        logd("getSatelliteConfigDataVersion: mVersion: " + mVersion);
         return mVersion;
     }
 
@@ -259,7 +339,7 @@ public class SatelliteConfig {
             @Nullable byte[] byteArrayFile, String fileName) {
 
         if (context == null || byteArrayFile == null) {
-            Log.d(TAG, "copySatelliteFileToPhoneDirectory : context or byteArrayFile are null");
+            logd("copySatelliteFileToPhoneDirectory : context or byteArrayFile are null");
             return null;
         }
 
@@ -272,19 +352,17 @@ public class SatelliteConfig {
         try {
             InputStream inputStream = new ByteArrayInputStream(byteArrayFile);
             if (inputStream == null) {
-                Log.d(TAG, "copySatelliteFileToPhoneDirectory: Resource=" + fileName
+                logd("copySatelliteFileToPhoneDirectory: Resource=" + fileName
                         + " not found");
             } else {
                 Files.copy(inputStream, targetSatelliteFilePath,
                         StandardCopyOption.REPLACE_EXISTING);
             }
         } catch (IOException ex) {
-            Log.e(TAG, "copySatelliteFileToPhoneDirectory: ex=" + ex);
+            loge("copySatelliteFileToPhoneDirectory: ex=" + ex);
         }
-        Log.d(
-                TAG,
-                "targetSatelliteFilePath's path: "
-                        + targetSatelliteFilePath.toAbsolutePath().toString());
+        logd("targetSatelliteFilePath's path: "
+                + targetSatelliteFilePath.toAbsolutePath().toString());
         return targetSatelliteFilePath.toFile();
     }
 
@@ -295,24 +373,55 @@ public class SatelliteConfig {
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public void cleanOtaResources(@Nullable Context context) {
         if (context == null) {
-            Log.d(TAG, "cleanOtaResources : context is null");
+            logd("cleanOtaResources : context is null");
             return;
         }
         try {
             File satelliteFileDir = context.getDir(SATELLITE_DIR_NAME, Context.MODE_PRIVATE);
             if (!satelliteFileDir.exists()) {
-                Log.d(
-                        TAG,
-                        "cleanOtaResources: "
-                                + SATELLITE_DIR_NAME
-                                + " does not exist. No need to clean.");
+                logd("cleanOtaResources: " + SATELLITE_DIR_NAME
+                        + " does not exist. No need to clean.");
                 return;
             }
-            Log.d(TAG, "cleanOtaResources: Deleting contents under " + SATELLITE_DIR_NAME);
+            logd("cleanOtaResources: Deleting contents under " + SATELLITE_DIR_NAME);
             FileUtils.deleteContents(satelliteFileDir);
         } catch (Exception e) {
-            Log.e(TAG, "cleanOtaResources error : " + e);
+            loge("cleanOtaResources error : " + e);
+        }
+    }
+
+    /**
+     * This method cleans the Satellite Config OTA resources and it should be used only in CTS/Unit
+     * tests
+     */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    public boolean hasSatelliteS2CellFile() {
+        if (mConfigData != null && mConfigData.deviceSatelliteRegion != null) {
+            if (mConfigData.deviceSatelliteRegion.s2CellFile != null
+                    && mConfigData.deviceSatelliteRegion.s2CellFile.length > 0) {
+                logd("hasSatelliteS2CellFile: s2CellFile is exist");
+                return true;
+            }
         }
+        logd("hasSatelliteS2CellFile: s2CellFile is not exist");
+        return false;
+    }
+
+    /**
+     * This method cleans the Satellite Config OTA resources and it should be used only in CTS/Unit
+     * tests
+     */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    public boolean hasSatelliteAccessConfigFile() {
+        if (mConfigData != null && mConfigData.deviceSatelliteRegion != null) {
+            if (mConfigData.deviceSatelliteRegion.satelliteAccessConfigFile != null
+                    && mConfigData.deviceSatelliteRegion.satelliteAccessConfigFile.length > 0) {
+                logd("hasSatelliteAccessConfigFile: satelliteAccessConfigFile is exist");
+                return true;
+            }
+        }
+        logd("hasSatelliteAccessConfigFile: satelliteAccessConfigFile is not exist");
+        return false;
     }
 
     /**
@@ -321,9 +430,39 @@ public class SatelliteConfig {
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public boolean isFileExist(@Nullable File file) {
         if (file == null) {
-            Log.d(TAG, "isFileExist : file is null");
+            logd("isFileExist : file is null");
             return false;
         }
         return file.exists();
     }
+
+    private static void logd(@NonNull String log) {
+        Log.d(TAG, log);
+    }
+
+    private static void loge(@NonNull String log) {
+        Log.e(TAG, log);
+    }
+
+    @Override
+    public String toString() {
+        return "SatelliteConfig{"
+                + "mVersion="
+                + mVersion
+                + ", mSupportedServicesPerCarrier="
+                + mSupportedServicesPerCarrier
+                + ", mCarrierRoamingMaxAllowedDataMode="
+                + mCarrierRoamingMaxAllowedDataMode
+                + ", mSatelliteRegionCountryCodes="
+                + mSatelliteRegionCountryCodes
+                + ", mIsSatelliteRegionAllowed="
+                + mIsSatelliteRegionAllowed
+                + ", mSatS2File="
+                + mSatS2File
+                + ", mSatelliteAccessConfigJsonFile="
+                + mSatelliteAccessConfigJsonFile
+                + ", mConfigData="
+                + mConfigData
+                + "}";
+    }
 }
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteConfigParser.java b/src/java/com/android/internal/telephony/satellite/SatelliteConfigParser.java
index 4ff1880ba5..a6760d51c5 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteConfigParser.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteConfigParser.java
@@ -27,7 +27,6 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 
-
 /**
  * SatelliteConfigParser parses the config data and create SatelliteConfig.
  * The config data is located at "/data/misc/telephonyconfig/telephony_config.pb".
@@ -83,7 +82,7 @@ public class SatelliteConfigParser extends ConfigParser<SatelliteConfig> {
             Log.d(TAG, "SatelliteConfig is created");
         } catch (Exception e) {
             parseError = true;
-            Log.e(TAG, "Parse Error : " + e.getMessage());
+            Log.e(TAG, "Parse Error", e);
         } finally {
             if (parseError) {
                 mVersion = VERSION_UNKNOWN;
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteConstants.java b/src/java/com/android/internal/telephony/satellite/SatelliteConstants.java
index 7fbba14b2f..fb1d7bfe6a 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteConstants.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteConstants.java
@@ -67,22 +67,26 @@ public class SatelliteConstants {
     public static final int CONFIG_UPDATE_RESULT_DEVICE_DATA_INVALID_S2_CELL_FILE = 10;
     public static final int CONFIG_UPDATE_RESULT_IO_ERROR = 11;
     public static final int CONFIG_UPDATE_RESULT_INVALID_SATELLITE_ACCESS_CONFIG_FILE = 12;
+    public static final int CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_MAX_ALLOWED_DATA_MODE = 13;
 
-    @IntDef(prefix = {"CONFIG_UPDATE_RESULT_"}, value = {
-            CONFIG_UPDATE_RESULT_UNKNOWN,
-            CONFIG_UPDATE_RESULT_SUCCESS,
-            CONFIG_UPDATE_RESULT_INVALID_DOMAIN,
-            CONFIG_UPDATE_RESULT_INVALID_VERSION,
-            CONFIG_UPDATE_RESULT_NO_DATA,
-            CONFIG_UPDATE_RESULT_NO_SATELLITE_DATA,
-            CONFIG_UPDATE_RESULT_PARSE_ERROR,
-            CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_PLMN,
-            CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_SUPPORTED_SERVICES,
-            CONFIG_UPDATE_RESULT_DEVICE_DATA_INVALID_COUNTRY_CODE,
-            CONFIG_UPDATE_RESULT_DEVICE_DATA_INVALID_S2_CELL_FILE,
-            CONFIG_UPDATE_RESULT_IO_ERROR,
-            CONFIG_UPDATE_RESULT_INVALID_SATELLITE_ACCESS_CONFIG_FILE
-    })
+    @IntDef(
+            prefix = {"CONFIG_UPDATE_RESULT_"},
+            value = {
+                CONFIG_UPDATE_RESULT_UNKNOWN,
+                CONFIG_UPDATE_RESULT_SUCCESS,
+                CONFIG_UPDATE_RESULT_INVALID_DOMAIN,
+                CONFIG_UPDATE_RESULT_INVALID_VERSION,
+                CONFIG_UPDATE_RESULT_NO_DATA,
+                CONFIG_UPDATE_RESULT_NO_SATELLITE_DATA,
+                CONFIG_UPDATE_RESULT_PARSE_ERROR,
+                CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_PLMN,
+                CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_SUPPORTED_SERVICES,
+                CONFIG_UPDATE_RESULT_DEVICE_DATA_INVALID_COUNTRY_CODE,
+                CONFIG_UPDATE_RESULT_DEVICE_DATA_INVALID_S2_CELL_FILE,
+                CONFIG_UPDATE_RESULT_IO_ERROR,
+                CONFIG_UPDATE_RESULT_INVALID_SATELLITE_ACCESS_CONFIG_FILE,
+                CONFIG_UPDATE_RESULT_CARRIER_DATA_INVALID_MAX_ALLOWED_DATA_MODE
+            })
     @Retention(RetentionPolicy.SOURCE)
     public @interface ConfigUpdateResult {}
 
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteController.java b/src/java/com/android/internal/telephony/satellite/SatelliteController.java
index 76897630fc..788e10e11f 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteController.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteController.java
@@ -71,6 +71,7 @@ import android.annotation.ArrayRes;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.AlarmManager;
 import android.app.AlertDialog;
 import android.app.Notification;
 import android.app.NotificationChannel;
@@ -117,6 +118,7 @@ import android.os.ServiceSpecificException;
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
+import android.os.WorkSource;
 import android.provider.Settings;
 import android.provider.Telephony;
 import android.telecom.TelecomManager;
@@ -153,14 +155,13 @@ import android.telephony.satellite.SystemSelectionSpecifier;
 import android.text.TextUtils;
 import android.util.Log;
 import android.util.Pair;
-import android.util.SparseArray;
-import android.util.SparseBooleanArray;
 import android.uwb.UwbManager;
 import android.view.WindowManager;
 
 import com.android.internal.R;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.os.SomeArgs;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.DeviceStateMonitor;
 import com.android.internal.telephony.IBooleanConsumer;
@@ -202,6 +203,7 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
@@ -234,6 +236,8 @@ public class SatelliteController extends Handler {
     public static final int TIMEOUT_TYPE_DEMO_POINTING_NOT_ALIGNED_DURATION_MILLIS = 3;
     /** This is used by CTS to override evaluate esos profiles prioritization duration. */
     public static final int TIMEOUT_TYPE_EVALUATE_ESOS_PROFILES_PRIORITIZATION_DURATION_MILLIS = 4;
+    /** This is used by CTS to override evaluate carrier roaming ntn eligibility change duration. */
+    public static final int TIMEOUT_TYPE_EMERGENCY_CALL_MONITORING_DURATION_MILLIS = 5;
     /** Key used to read/write OEM-enabled satellite provision status in shared preferences. */
     private static final String OEM_ENABLED_SATELLITE_PROVISION_STATUS_KEY =
             "oem_enabled_satellite_provision_status_key";
@@ -248,8 +252,8 @@ public class SatelliteController extends Handler {
     public static final long DEFAULT_CARRIER_EMERGENCY_CALL_WAIT_FOR_CONNECTION_TIMEOUT_MILLIS =
             TimeUnit.SECONDS.toMillis(30);
 
-    /** Sets report entitled metrics cool down to 23 hours to help enforcing privacy requirement.*/
-    private static final long WAIT_FOR_REPORT_ENTITLED_MERTICS_TIMEOUT_MILLIS =
+    /** Sets general metrics report cool down to 23 hours to help enforcing privacy requirement.*/
+    private static final long REGULAR_METRIC_REPORTING_INTERVAL_MILLIS =
             TimeUnit.HOURS.toMillis(23);
 
     /**
@@ -309,7 +313,7 @@ public class SatelliteController extends Handler {
     private static final int EVENT_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_DONE = 51;
     protected static final int
             EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT = 52;
-    private static final int EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT = 53;
+    private static final int EVENT_WAIT_FOR_REGULAR_METRICS_REPORT_HYSTERESIS_TIMED_OUT = 53;
     protected static final int EVENT_SATELLITE_REGISTRATION_FAILURE = 54;
     private static final int EVENT_TERRESTRIAL_NETWORK_AVAILABLE_CHANGED = 55;
     private static final int EVENT_SET_NETWORK_SELECTION_AUTO_DONE = 56;
@@ -323,6 +327,37 @@ public class SatelliteController extends Handler {
         EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT = 63;
     private static final int CMD_GET_SATELLITE_ENABLED_FOR_CARRIER = 64;
     private static final int EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE = 65;
+    private static final int REQUEST_SATELLITE_ENABLED = 66;
+    private static final int REQUEST_IS_SATELLITE_ENABLED = 67;
+    private static final int REQUEST_IS_DEMO_MODE_ENABLED = 68;
+    private static final int REQUEST_IS_EMERGENCY_MODE_ENABLED = 69;
+    private static final int REQUEST_IS_SATELLITE_SUPPORTED = 70;
+    private static final int REQUEST_SATELLITE_CAPABILITIES = 71;
+    private static final int REQUEST_START_SATELLITE_TRANSMISSION_UPDATES = 72;
+    private static final int REQUEST_STOP_SATELLITE_TRANSMISSION_UPDATES = 73;
+    private static final int REQUEST_IS_SATELLITE_PROVISIONED = 74;
+    private static final int REQUEST_POLL_PENDING_DATAGRAMS = 75;
+    private static final int REQUEST_SEND_DATAGRAM = 76;
+    private static final int REQUEST_TIME_FOR_NEXT_SATELLITE_VISIBILITY = 77;
+    private static final int REQUEST_SATELLITE_DISPLAY_NAME = 78;
+    private static final int REQUEST_SELECTED_NB_IOT_SATELLITE_SUBSCRIPTION_ID = 79;
+    private static final int REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE = 80;
+    private static final int REQUEST_ADD_ATTACH_RESTRICTION_FOR_CARRIER = 81;
+    private static final int REQUEST_REMOVE_ATTACH_RESTRICTION_FOR_CARRIER = 82;
+    private static final int REQUEST_NTN_SIGNAL_STRENGTH = 83;
+    private static final int REQUEST_SATELLITE_SUBSCRIBER_PROVISION_STATUS = 84;
+    private static final int REQUEST_SET_NTN_SMS_SUPPORTED_BY_MESSAGES_APP = 85;
+    private static final int REQUEST_PROVISION_SATELLITE = 86;
+    private static final int REQUEST_DEPROVISION_SATELLITE = 87;
+    private static final int EVENT_SATELLITE_ACCESS_ALLOWED_STATE_CHANGED = 88;
+    private static final int EVENT_SATELLITE_ACCESS_CONFIGURATION_CHANGED = 89;
+    private static final int EVENT_BT_WIFI_NFC_STATE_CHANGED = 90;
+    private static final int EVENT_UWB_STATE_CHANGED = 91;
+    private static final int EVENT_CARRIER_CONFIG_CHANGED = 92;
+    private static final int EVENT_SATELLITE_ENTILEMENT_STATUS_UPDATED = 93;
+
+    private static final int TRUE = 1;
+    private static final int FALSE = 0;
 
     @NonNull private static SatelliteController sInstance;
     @NonNull private final Context mContext;
@@ -342,31 +377,104 @@ public class SatelliteController extends Handler {
     private final CommandsInterface mCi;
     private ContentResolver mContentResolver;
     private final DeviceStateMonitor mDSM;
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected final Object mSatellitePhoneLock = new Object();
-    @GuardedBy("mSatellitePhoneLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected Phone mSatellitePhone = null;
     private SatelliteOptimizedApplicationsTracker mSatelliteOptimizedApplicationsTracker;
-    private final Object mRadioStateLock = new Object();
-
-    /** Flags to indicate whether the respective radio is enabled */
-    @GuardedBy("mRadioStateLock")
-    private boolean mBTStateEnabled = false;
-    @GuardedBy("mRadioStateLock")
-    private boolean mNfcStateEnabled = false;
-    @GuardedBy("mRadioStateLock")
-    private boolean mUwbStateEnabled = false;
-    @GuardedBy("mRadioStateLock")
-    private boolean mWifiStateEnabled = false;
 
+    /** All the atomic variables are declared here. */
+    // Flags to indicate whether the respective radio is enabled
+    private AtomicBoolean mBTStateEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mNfcStateEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mUwbStateEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mWifiStateEnabled = new AtomicBoolean(false);
     // Flags to indicate that respective radios need to be disabled when satellite is enabled
-    private boolean mDisableBTOnSatelliteEnabled = false;
-    private boolean mDisableNFCOnSatelliteEnabled = false;
-    private boolean mDisableUWBOnSatelliteEnabled = false;
-    private boolean mDisableWifiOnSatelliteEnabled = false;
+    private AtomicBoolean mDisableBTOnSatelliteEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mDisableNFCOnSatelliteEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mDisableUWBOnSatelliteEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mDisableWifiOnSatelliteEnabled = new AtomicBoolean(false);
+    protected AtomicBoolean mIsSatelliteSupported = null;
+    private AtomicBoolean mNeedsSatellitePointing = new AtomicBoolean(false);
+    private AtomicBoolean mIsDemoModeEnabled = new AtomicBoolean(false);
+    private AtomicBoolean mIsEmergency = new AtomicBoolean(false);
+    private AtomicBoolean mIsSatelliteEnabled = null;
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected AtomicBoolean mIsRadioOn = new AtomicBoolean(false);
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected AtomicBoolean mRadioOffRequested = new AtomicBoolean(false);
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected AtomicBoolean mIsDeviceProvisioned = null;
+    private AtomicBoolean mOverriddenIsSatelliteViaOemProvisioned = null;
     private AtomicBoolean mIgnorePlmnListFromStorage = new AtomicBoolean(false);
+    private AtomicBoolean mNtnSmsSupportedByMessagesApp = null;
+    private AtomicBoolean mIsWifiConnected = new AtomicBoolean(false);
+    private AtomicBoolean mHasSentBroadcast = new AtomicBoolean(false);
+    @SatelliteManager.SatelliteModemState
+    private AtomicInteger mSatelliteModemState = new AtomicInteger(
+            SatelliteManager.SATELLITE_MODEM_STATE_UNKNOWN);
+    /** Flag to indicate that satellite is enabled successfully
+     * and waiting for all the radios to be disabled so that success can be sent to callback
+     */
+    private AtomicBoolean mWaitingForRadioDisabled = new AtomicBoolean(false);
+    private AtomicBoolean mWaitingForDisableSatelliteModemResponse = new AtomicBoolean(false);
+    private AtomicBoolean mWaitingForSatelliteModemOff = new AtomicBoolean(false);
+    /**
+     * Boolean set to {@code true} when device is eligible to connect to carrier roaming
+     * non-terrestrial network else set to {@code false}.
+     */
+    private AtomicBoolean mLastNotifiedNtnEligibility = null;
+    // For satellite CTS test which to configure intent component with the necessary values.
+    private AtomicBoolean mChangeIntentComponent = new AtomicBoolean(false);
+    private AtomicBoolean mIsNotificationShowing = new AtomicBoolean(false);
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected AtomicBoolean mSatelliteAccessAllowed = new AtomicBoolean(false);
+    private AtomicBoolean mOverrideNtnEligibility;
+    private AtomicBoolean mOverriddenDisableSatelliteWhileEnableInProgressSupported = null;
+    private AtomicLong mWaitTimeForSatelliteEnablingResponse = new AtomicLong(0);
+    private AtomicLong mDemoPointingAlignedDurationMillis = new AtomicLong(0);
+    private AtomicLong mDemoPointingNotAlignedDurationMillis = new AtomicLong(0);
+    private AtomicLong mEvaluateEsosProfilesPrioritizationDurationMillis = new AtomicLong(0);
+    private AtomicLong mLastEmergencyCallTime = new AtomicLong(0);
+    private AtomicLong mSatelliteEmergencyModeDurationMillis = new AtomicLong(0);
+    private AtomicLong mEmergencyCallMonitoringDurationMillisForCtsTest = new AtomicLong(0);
+    private AtomicLong mSessionStartTimeStamp = new AtomicLong(0);
+    private AtomicLong mSessionProcessingTimeStamp = new AtomicLong(0);
+    private static AtomicLong sNextSatelliteEnableRequestId = new AtomicLong(0);
+    private static AtomicLong sNextSystemSelectionChannelsUpdateRequestId = new AtomicLong(0);
+    /**
+     * This is used for testing only. When mEnforcedEmergencyCallToSatelliteHandoverType is valid,
+     * Telephony will ignore the IMS registration status and cellular availability, and always send
+     * the connection event EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer.
+     */
+    private AtomicInteger mEnforcedEmergencyCallToSatelliteHandoverType =
+            new AtomicInteger(INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE);
+    private AtomicInteger mDelayInSendingEventDisplayEmergencyMessage = new AtomicInteger(0);
+    private AtomicInteger mSimSlotIdForLaunchingT911ConversationThread = new AtomicInteger(0);
+    private AtomicInteger mMaxAllowedDataModeForCtsTest = new AtomicInteger(-1);
+    // The ID of the satellite subscription that has highest priority and is provisioned.
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected AtomicInteger mSelectedSatelliteSubId = new AtomicInteger(
+            SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+    protected AtomicInteger mResultReceiverTotalCount = new AtomicInteger(0);
 
+    /** All the variables that require lock are declared here. */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected final Object mSatellitePhoneLock = new Object();
+    @GuardedBy("mSatellitePhoneLock")
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected Phone mSatellitePhone = null;
+    private final Object mSatelliteCapabilitiesLock = new Object();
+    @GuardedBy("mSatelliteCapabilitiesLock")
+    private SatelliteCapabilities mSatelliteCapabilities;
+    private final Object mNtnSignalsStrengthLock = new Object();
+    @GuardedBy("mNtnSignalsStrengthLock")
+    private NtnSignalStrength mNtnSignalStrength =
+            new NtnSignalStrength(NTN_SIGNAL_STRENGTH_NONE);
+    private final Object mCarrierRoamingNtnAllSatellitePlmnSetLock = new Object();
+    @GuardedBy("mCarrierRoamingNtnAllSatellitePlmnSetLock")
+    private Set<String> mCarrierRoamingNtnAllSatellitePlmnSet = null;
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected final Object mSatelliteAccessConfigLock = new Object();
+    @GuardedBy("mSatelliteAccessConfigLock")
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected List<Integer> mCurrentLocationTagIds = new ArrayList();
     private final Object mSatelliteEnabledRequestLock = new Object();
     /* This variable is used to store the first enable request that framework has received in the
      * current session.
@@ -382,15 +490,18 @@ public class SatelliteController extends Handler {
      */
     @GuardedBy("mSatelliteEnabledRequestLock")
     private RequestSatelliteEnabledArgument mSatelliteEnableAttributesUpdateRequest = null;
-    /** Flag to indicate that satellite is enabled successfully
-     * and waiting for all the radios to be disabled so that success can be sent to callback
-     */
-    @GuardedBy("mSatelliteEnabledRequestLock")
-    private boolean mWaitingForRadioDisabled = false;
-    @GuardedBy("mSatelliteEnabledRequestLock")
-    private boolean mWaitingForDisableSatelliteModemResponse = false;
-    @GuardedBy("mSatelliteEnabledRequestLock")
-    private boolean mWaitingForSatelliteModemOff = false;
+    @NonNull protected final Object mSatelliteTokenProvisionedLock = new Object();
+    // key : priority, low value is high, value : List<SubscriptionInfo>
+    @GuardedBy("mSatelliteTokenProvisionedLock")
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected TreeMap<Integer, List<SubscriptionInfo>> mSubsInfoListPerPriority = new TreeMap<>();
+    // List of subscriber information and status at the time of last evaluation
+    @GuardedBy("mSatelliteTokenProvisionedLock")
+    private List<SatelliteSubscriberProvisionStatus> mLastEvaluatedSubscriberProvisionStatus =
+            new ArrayList<>();
+    // The last ICC ID that framework configured to modem.
+    @GuardedBy("mSatelliteTokenProvisionedLock")
+    private String mLastConfiguredIccId;
 
     private final AtomicBoolean mRegisteredForPendingDatagramCountWithSatelliteService =
             new AtomicBoolean(false);
@@ -411,6 +522,12 @@ public class SatelliteController extends Handler {
             new AtomicBoolean(false);
     private final AtomicBoolean mRegisteredForSatelliteCommunicationAccessStateChanged =
         new AtomicBoolean(false);
+
+    /**
+     * Map key: subId, value: PersistableBundle
+     */
+    @NonNull private final ConcurrentHashMap<Integer, PersistableBundle> mCarrierConfigArray =
+            new ConcurrentHashMap<>();
     /**
      * Map key: subId, value: callback to get error code of the provision request.
      */
@@ -457,125 +574,64 @@ public class SatelliteController extends Handler {
      */
     private final ConcurrentHashMap<IBinder, ISelectedNbIotSatelliteSubscriptionCallback>
             mSelectedNbIotSatelliteSubscriptionChangedListeners = new ConcurrentHashMap<>();
-
-    protected final Object mIsSatelliteSupportedLock = new Object();
-    @GuardedBy("mIsSatelliteSupportedLock")
-    protected Boolean mIsSatelliteSupported = null;
-    private boolean mIsDemoModeEnabled = false;
-    private boolean mIsEmergency = false;
-    private final Object mIsSatelliteEnabledLock = new Object();
-    @GuardedBy("mIsSatelliteEnabledLock")
-    private Boolean mIsSatelliteEnabled = null;
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected final Object mIsRadioOnLock = new Object();
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected boolean mIsRadioOn;
-    @GuardedBy("mIsRadioOnLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected boolean mRadioOffRequested = false;
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected final Object mDeviceProvisionLock = new Object();
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    @GuardedBy("mDeviceProvisionLock")
-    protected Boolean mIsDeviceProvisioned = null;
-    @GuardedBy("mDeviceProvisionLock")
-    private Boolean mOverriddenIsSatelliteViaOemProvisioned = null;
-    private final Object mSatelliteCapabilitiesLock = new Object();
-    @GuardedBy("mSatelliteCapabilitiesLock")
-    private SatelliteCapabilities mSatelliteCapabilities;
-    private final Object mNeedsSatellitePointingLock = new Object();
-    @GuardedBy("mNeedsSatellitePointingLock")
-    private boolean mNeedsSatellitePointing = false;
-    private final Object mNtnSignalsStrengthLock = new Object();
-    @GuardedBy("mNtnSignalsStrengthLock")
-    private NtnSignalStrength mNtnSignalStrength =
-            new NtnSignalStrength(NTN_SIGNAL_STRENGTH_NONE);
+    protected ConcurrentHashMap<String, Integer> mResultReceiverCountPerMethodMap =
+            new ConcurrentHashMap<>();
     /** Key: subId, value: (key: PLMN, value: set of
      * {@link android.telephony.NetworkRegistrationInfo.ServiceType})
      */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    @NonNull private final Map<Integer, Map<String, Set<Integer>>>
-            mSatelliteServicesSupportedByCarriersFromConfig = new HashMap<>();
-    @NonNull private final Object mSupportedSatelliteServicesLock = new Object();
+    @NonNull private final ConcurrentHashMap<Integer, Map<String, Set<Integer>>>
+            mSatelliteServicesSupportedByCarriersFromConfig = new ConcurrentHashMap<>();
+    @NonNull private final ConcurrentHashMap<Integer, CarrierRoamingSatelliteSessionStats>
+            mCarrierRoamingSatelliteSessionStatsMap = new ConcurrentHashMap<>();
+    /**
+     * Key: Subscription ID; Value: set of
+     * {@link android.telephony.NetworkRegistrationInfo.ServiceType}
+     */
+    @NonNull private final ConcurrentHashMap<Integer, List<Integer>>
+            mSatModeCapabilitiesForCarrierRoaming = new ConcurrentHashMap<>();
+
     @NonNull private final List<String> mSatellitePlmnListFromOverlayConfig;
     @NonNull private final CarrierConfigManager mCarrierConfigManager;
     @NonNull private final CarrierConfigManager.CarrierConfigChangeListener
             mCarrierConfigChangeListener;
     @NonNull private final ConfigProviderAdaptor.Callback mConfigDataUpdatedCallback;
-    @NonNull private final Object mCarrierConfigArrayLock = new Object();
     @NonNull
     private final SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedListener;
-    @GuardedBy("mCarrierConfigArrayLock")
-    @NonNull private final SparseArray<PersistableBundle> mCarrierConfigArray = new SparseArray<>();
-    @GuardedBy("mIsSatelliteEnabledLock")
+
     /** Key: Subscription ID, value: set of restriction reasons for satellite communication.*/
-    @NonNull private final Map<Integer, Set<Integer>> mSatelliteAttachRestrictionForCarrierArray =
-            new HashMap<>();
-    @GuardedBy("mIsSatelliteEnabledLock")
+    @NonNull private final ConcurrentHashMap<Integer, Set<Integer>>
+            mSatelliteAttachRestrictionForCarrierArray = new ConcurrentHashMap<>();
     /** Key: Subscription ID, value: the actual satellite enabled state in the modem -
      * {@code true} for enabled and {@code false} for disabled. */
-    @NonNull private final Map<Integer, Boolean> mIsSatelliteAttachEnabledForCarrierArrayPerSub =
-            new HashMap<>();
+    @NonNull private final ConcurrentHashMap<Integer, Boolean>
+            mIsSatelliteAttachEnabledForCarrierArrayPerSub = new ConcurrentHashMap<>();
     /** Key: subId, value: (key: Regional satellite config Id string, value: Integer
      * arrays of earfcns in the corresponding regions.)
      */
-    @GuardedBy("mRegionalSatelliteEarfcnsLock")
-    @NonNull private final Map<Integer, Map<String, Set<Integer>>>
-            mRegionalSatelliteEarfcns = new HashMap<>();
-    @NonNull private final Object mRegionalSatelliteEarfcnsLock = new Object();
+    @NonNull private final ConcurrentHashMap<Integer, Map<String, Set<Integer>>>
+            mRegionalSatelliteEarfcns = new ConcurrentHashMap<>();
+    // key : subscriberId, value : provisioned or not.
+    private ConcurrentHashMap<String, Boolean> mProvisionedSubscriberId = new ConcurrentHashMap<>();
+    // key : subscriberId, value : subId
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected ConcurrentHashMap<String, Integer> mSubscriberIdPerSub = new ConcurrentHashMap<>();
+
     @NonNull private final FeatureFlags mFeatureFlags;
-    @NonNull private final Object mSatelliteConnectedLock = new Object();
     /** Key: Subscription ID; Value: Last satellite connected time */
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final SparseArray<Long> mLastSatelliteDisconnectedTimesMillis =
-            new SparseArray<>();
+    @NonNull private final ConcurrentHashMap<Integer, Long> mLastSatelliteDisconnectedTimesMillis =
+            new ConcurrentHashMap<>();
     /**
      * Key: Subscription ID; Value: {@code true} if satellite was just connected,
      * {@code false} otherwise.
      */
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final SparseBooleanArray
-            mWasSatelliteConnectedViaCarrier = new SparseBooleanArray();
-
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final SparseBooleanArray mLastNotifiedNtnMode = new SparseBooleanArray();
-
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final SparseBooleanArray mInitialized = new SparseBooleanArray();
-
-    /**
-     * Boolean set to {@code true} when device is eligible to connect to carrier roaming
-     * non-terrestrial network else set to {@code false}.
-     */
-    @GuardedBy("mSatellitePhoneLock")
-    private Boolean mLastNotifiedNtnEligibility = null;
-    @GuardedBy("mSatellitePhoneLock")
-    private boolean mCheckingAccessRestrictionInProgress = false;
-
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final Map<Integer, CarrierRoamingSatelliteSessionStats>
-            mCarrierRoamingSatelliteSessionStatsMap = new HashMap<>();
-
-    /**
-     * Key: Subscription ID; Value: set of
-     * {@link android.telephony.NetworkRegistrationInfo.ServiceType}
-     */
-    @GuardedBy("mSatelliteConnectedLock")
-    @NonNull private final Map<Integer, List<Integer>>
-            mSatModeCapabilitiesForCarrierRoaming = new HashMap<>();
-
-    @GuardedBy("mSatelliteConnectedLock")
-    private SparseArray<NtnSignalStrength> mLastNotifiedCarrierRoamingNtnSignalStrength =
-            new SparseArray<>();
-
-    /**
-     * This is used for testing only. When mEnforcedEmergencyCallToSatelliteHandoverType is valid,
-     * Telephony will ignore the IMS registration status and cellular availability, and always send
-     * the connection event EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer.
-     */
-    private int mEnforcedEmergencyCallToSatelliteHandoverType =
-            INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE;
-    private int mDelayInSendingEventDisplayEmergencyMessage = 0;
+    @NonNull private final ConcurrentHashMap<Integer, Boolean>
+            mWasSatelliteConnectedViaCarrier = new ConcurrentHashMap<>();
+    @NonNull private final ConcurrentHashMap<Integer, Boolean> mLastNotifiedNtnMode =
+            new ConcurrentHashMap<>();
+    @NonNull private final ConcurrentHashMap<Integer, Boolean> mInitialized =
+            new ConcurrentHashMap<>();
+    private ConcurrentHashMap<Integer, NtnSignalStrength>
+            mLastNotifiedCarrierRoamingNtnSignalStrength = new ConcurrentHashMap<>();
     @NonNull private SharedPreferences mSharedPreferences = null;
 
     @Nullable private PersistentLogger mPersistentLogger = null;
@@ -584,68 +640,31 @@ public class SatelliteController extends Handler {
      * Key : Subscription ID, Value: {@code true} if the EntitlementStatus is enabled,
      * {@code false} otherwise.
      */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    private SparseBooleanArray mSatelliteEntitlementStatusPerCarrier = new SparseBooleanArray();
+    private ConcurrentHashMap<Integer, Boolean> mSatelliteEntitlementStatusPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : PLMN allowed list from entitlement. */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    private SparseArray<List<String>> mEntitlementPlmnListPerCarrier = new SparseArray<>();
+    private ConcurrentHashMap<Integer, List<String>> mEntitlementPlmnListPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : PLMN barred list from entitlement. */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    private SparseArray<List<String>> mEntitlementBarredPlmnListPerCarrier = new SparseArray<>();
+    private ConcurrentHashMap<Integer, List<String>> mEntitlementBarredPlmnListPerCarrier =
+            new ConcurrentHashMap<>();
     /**
      * Key : Subscription ID, Value : If there is an entitlementPlmnList, use it. Otherwise, use the
      * carrierPlmnList. */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    private final SparseArray<List<String>> mMergedPlmnListPerCarrier = new SparseArray<>();
+    private final ConcurrentHashMap<Integer, List<String>> mMergedPlmnListPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : map to plmn info with related data plan. */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    SparseArray<Map<String, Integer>> mEntitlementDataPlanMapPerCarrier = new SparseArray<>();
+    ConcurrentHashMap<Integer, Map<String, Integer>> mEntitlementDataPlanMapPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : map to plmn info with related service type. */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    SparseArray<Map<String, List<Integer>>> mEntitlementServiceTypeMapPerCarrier =
-            new SparseArray<>();
+    ConcurrentHashMap<Integer, Map<String, List<Integer>>> mEntitlementServiceTypeMapPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : map to plmn info with related service policy for data service */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    SparseArray<Map<String, Integer>> mEntitlementDataServicePolicyMapPerCarrier =
-            new SparseArray<>();
+    ConcurrentHashMap<Integer, Map<String, Integer>> mEntitlementDataServicePolicyMapPerCarrier =
+            new ConcurrentHashMap<>();
     /** Key Subscription ID, value : map to plmn info with related service policy for voice service */
-    @GuardedBy("mSupportedSatelliteServicesLock")
-    SparseArray<Map<String, Integer>> mEntitlementVoiceServicePolicyMapPerCarrier =
-            new SparseArray<>();
-    private static AtomicLong sNextSatelliteEnableRequestId = new AtomicLong(0);
-    private static AtomicLong sNextSystemSelectionChannelsUpdateRequestId = new AtomicLong(0);
-    // key : subscriberId, value : provisioned or not.
-    @GuardedBy("mSatelliteTokenProvisionedLock")
-    private Map<String, Boolean> mProvisionedSubscriberId = new HashMap<>();
-    // key : subscriberId, value : subId
-    @GuardedBy("mSatelliteTokenProvisionedLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected Map<String, Integer> mSubscriberIdPerSub = new HashMap<>();
-    // key : priority, low value is high, value : List<SubscriptionInfo>
-    @GuardedBy("mSatelliteTokenProvisionedLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected TreeMap<Integer, List<SubscriptionInfo>> mSubsInfoListPerPriority = new TreeMap<>();
-    // List of subscriber information and status at the time of last evaluation
-    @GuardedBy("mSatelliteTokenProvisionedLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    private List<SatelliteSubscriberProvisionStatus> mLastEvaluatedSubscriberProvisionStatus =
-            new ArrayList<>();
-    // The ID of the satellite subscription that has highest priority and is provisioned.
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected int mSelectedSatelliteSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
-    // The last ICC ID that framework configured to modem.
-    @GuardedBy("mSatelliteTokenProvisionedLock")
-    private String mLastConfiguredIccId;
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    @NonNull protected final Object mSatelliteTokenProvisionedLock = new Object();
-    private long mWaitTimeForSatelliteEnablingResponse;
-    private long mDemoPointingAlignedDurationMillis;
-    private long mDemoPointingNotAlignedDurationMillis;
-    private long mEvaluateEsosProfilesPrioritizationDurationMillis;
-    private final Object mLock = new Object();
-    @GuardedBy("mLock")
-    private long mLastEmergencyCallTime;
-    private long mSatelliteEmergencyModeDurationMillis;
+    ConcurrentHashMap<Integer, Map<String, Integer>> mEntitlementVoiceServicePolicyMapPerCarrier =
+            new ConcurrentHashMap<>();
     private static final int DEFAULT_SATELLITE_EMERGENCY_MODE_DURATION_SECONDS = 300;
     private AlertDialog mNetworkSelectionModeAutoDialog = null;
 
@@ -665,48 +684,22 @@ public class SatelliteController extends Handler {
     private final RegistrantList mSatelliteSubIdChangedRegistrants = new RegistrantList();
     private final BTWifiNFCStateReceiver mBTWifiNFCSateReceiver;
     private final UwbAdapterStateCallback mUwbAdapterStateCallback;
-    private final List<Integer> mCtsSatelliteAccessAllowedSubIds = new ArrayList<>();
-
-    private long mSessionStartTimeStamp;
-    private long mSessionProcessingTimeStamp;
+    @Nullable private List<Integer> mCtsSatelliteAccessAllowedSubIds = null;
 
     // Variable for backup and restore device's screen rotation settings.
     private String mDeviceRotationLockToBackupAndRestore = null;
     // This is used for testing only. Context#getSystemService is a final API and cannot be
     // mocked. Using this to inject a mock SubscriptionManager to work around this limitation.
     private SubscriptionManager mInjectSubscriptionManager = null;
-
-    private final Object mIsWifiConnectedLock = new Object();
-    @GuardedBy("mIsWifiConnectedLock")
-    private boolean mIsWifiConnected = false;
-    private boolean mHasSentBroadcast = false;
-    // For satellite CTS test which to configure intent component with the necessary values.
-    private boolean mChangeIntentComponent = false;
     private String mConfigSatelliteGatewayServicePackage = "";
     private String mConfigSatelliteCarrierRoamingEsosProvisionedClass = "";
-
-    private boolean mIsNotificationShowing = false;
     private static final String OPEN_MESSAGE_BUTTON = "open_message_button";
     private static final String HOW_IT_WORKS_BUTTON = "how_it_works_button";
     private static final String ACTION_NOTIFICATION_CLICK = "action_notification_click";
     private static final String ACTION_NOTIFICATION_DISMISS = "action_notification_dismiss";
-    private AtomicBoolean mOverrideNtnEligibility;
     private String mDefaultSmsPackageName = "";
     private String mSatelliteGatewayServicePackageName = "";
-    private Boolean mOverriddenDisableSatelliteWhileEnableInProgressSupported = null;
-
-    private final Object mNtnSmsSupportedByMessagesAppLock = new Object();
-    @GuardedBy("mNtnSmsSupportedByMessagesAppLock")
-    private Boolean mNtnSmsSupportedByMessagesApp = null;
-
-    private final Object mCarrierRoamingNtnAllSatellitePlmnSetLock = new Object();
-    @GuardedBy("mCarrierRoamingNtnAllSatellitePlmnSetLock")
-    private Set<String> mCarrierRoamingNtnAllSatellitePlmnSet = null;
-
-    private final Object mSatelliteModemStateLock = new Object();
-    @GuardedBy("mSatelliteModemStateLock")
-    @SatelliteManager.SatelliteModemState
-    private int mSatelliteModemState = SatelliteManager.SATELLITE_MODEM_STATE_UNKNOWN;
+    private String mOverriddenSatelliteGatewayServicePackageName = "";
 
     // Data Plan types at entitlement for the plmn allowed
     public static final int SATELLITE_DATA_PLAN_METERED = 0;
@@ -770,21 +763,18 @@ public class SatelliteController extends Handler {
     // device.
     private List<DeviceState> mDeviceStates = new ArrayList();
 
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected final Object mSatelliteAccessConfigLock = new Object();
-    @GuardedBy("mSatelliteAccessConfigLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected List<Integer> mCurrentLocationTagIds = new ArrayList();
-    @GuardedBy("mSatelliteAccessConfigLock")
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected boolean mSatelliteAccessAllowed = false;
+    @Nullable
+    private AlarmManager mAlarmManager;
+    @NonNull
+    private final AlarmManager.OnAlarmListener mRegularMetricReportAlarmListener =
+            () -> {
+                plogd("onAlarm: regular metric report hysteresis timer expired");
+                Message msg = SatelliteController.getInstance().obtainMessage(
+                        EVENT_WAIT_FOR_REGULAR_METRICS_REPORT_HYSTERESIS_TIMED_OUT, null);
+                msg.sendToTarget();
+            };
 
     public static final int RESULT_RECEIVER_COUNT_ANOMALY_THRESHOLD = 500;
-    protected final Object mResultReceiverTotalCountLock = new Object();
-    @GuardedBy("mResultReceiverTotalCountLock")
-    protected int mResultReceiverTotalCount;
-    @GuardedBy("mResultReceiverTotalCountLock")
-    protected HashMap<String, Integer> mResultReceiverCountPerMethodMap = new HashMap<>();
 
     // Satellite anomaly uuid -- ResultReceiver count threshold exceeded
     private final UUID mAnomalyUnexpectedResultReceiverCountUUID =
@@ -807,23 +797,20 @@ public class SatelliteController extends Handler {
      */
     public void incrementResultReceiverCount(String caller) {
         if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-            synchronized (mResultReceiverTotalCountLock) {
-                mResultReceiverTotalCount++;
-                logd("[incrementResultReceiverCount] : " + caller
-                        + " | ResultReceiver total count= " + mResultReceiverTotalCount);
-                mResultReceiverCountPerMethodMap.compute(caller,
-                        (k, v) -> v == null ? 1 : v + 1);
-
-                if (mResultReceiverTotalCount > RESULT_RECEIVER_COUNT_ANOMALY_THRESHOLD) {
-                    loge("[mResultReceiverTotalCount] is exceeds limits : "
-                            + mResultReceiverTotalCount);
-                    loge("[incrementResultReceiverCount] mResultReceiverCountPerMethodMap is "
-                            + mResultReceiverCountPerMethodMap);
-                    AnomalyReporter.reportAnomaly(
-                            generateAnomalyUnexpectedResultReceiverCountUUID(0, 0),
-                            "Satellite ResultReceiver total count= "
-                                    + mResultReceiverTotalCount + " exceeds limit.");
-                }
+            int resultReceiverTotalCount = mResultReceiverTotalCount.incrementAndGet();
+            logd("[incrementResultReceiverCount] : " + caller
+                    + " | ResultReceiver total count= " + resultReceiverTotalCount);
+            mResultReceiverCountPerMethodMap.compute(caller,
+                    (k, v) -> v == null ? 1 : v + 1);
+
+            if (resultReceiverTotalCount > RESULT_RECEIVER_COUNT_ANOMALY_THRESHOLD) {
+                loge("[mResultReceiverTotalCount] is exceeds limits : " + resultReceiverTotalCount);
+                loge("[incrementResultReceiverCount] mResultReceiverCountPerMethodMap is "
+                        + mResultReceiverCountPerMethodMap);
+                AnomalyReporter.reportAnomaly(
+                        generateAnomalyUnexpectedResultReceiverCountUUID(0, 0),
+                        "Satellite ResultReceiver total count= "
+                                + resultReceiverTotalCount + " exceeds limit.");
             }
         } else {
             logd("[incrementResultReceiverCount]: carrierRoamingNbIotNtn is not enabled");
@@ -839,15 +826,13 @@ public class SatelliteController extends Handler {
      */
     public void decrementResultReceiverCount(String caller) {
         if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-            synchronized (mResultReceiverTotalCountLock) {
-                if (mResultReceiverTotalCount > 0) {
-                    mResultReceiverTotalCount--;
-                }
-                logd("[decrementResultReceiverCount] : " + caller
-                        + " | ResultReceiver total count=" + mResultReceiverTotalCount);
-                mResultReceiverCountPerMethodMap.computeIfPresent(caller,
-                        (k, v) -> v > 0 ? v - 1 : v);
+            if (mResultReceiverTotalCount.get() > 0) {
+                mResultReceiverTotalCount.decrementAndGet();
             }
+            logd("[decrementResultReceiverCount] : " + caller
+                    + " | ResultReceiver total count=" + mResultReceiverTotalCount.get());
+            mResultReceiverCountPerMethodMap.computeIfPresent(caller,
+                    (k, v) -> v > 0 ? v - 1 : v);
         } else {
             logd("[decrementResultReceiverCount]: carrierRoamingNbIotNtn is not enabled");
         }
@@ -899,9 +884,7 @@ public class SatelliteController extends Handler {
         mContext = context;
         mFeatureFlags = featureFlags;
         Phone phone = SatelliteServiceUtils.getPhone();
-        synchronized (mSatellitePhoneLock) {
-            mSatellitePhone = phone;
-        }
+        setSatellitePhone(phone);
         mCi = phone.mCi;
         mDSM = phone.getDeviceStateMonitor();
         // Create the SatelliteModemInterface singleton, which is used to manage connections
@@ -932,9 +915,7 @@ public class SatelliteController extends Handler {
                 mContext, looper, mFeatureFlags, mPointingAppController);
 
         mCi.registerForRadioStateChanged(this, EVENT_RADIO_STATE_CHANGED, null);
-        synchronized (mIsRadioOnLock) {
-            mIsRadioOn = phone.isRadioOn();
-        }
+        mIsRadioOn.set(phone.isRadioOn());
 
         registerForPendingDatagramCount();
         registerForSatelliteModemStateChanged();
@@ -964,9 +945,20 @@ public class SatelliteController extends Handler {
         registerApplicationStateChanged();
         registerLocationServiceStateChanged();
         updateSupportedSatelliteServicesForActiveSubscriptions();
-        mCarrierConfigChangeListener =
-                (slotIndex, subId, carrierId, specificCarrierId) ->
-                        handleCarrierConfigChanged(slotIndex, subId, carrierId, specificCarrierId);
+        mCarrierConfigChangeListener = (slotIndex, subId, carrierId, specificCarrierId) -> {
+            if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+                SomeArgs args = SomeArgs.obtain();
+                args.arg1 = slotIndex;
+                args.arg2 = subId;
+                args.arg3 = carrierId;
+                args.arg4 = specificCarrierId;
+                sendMessage(obtainMessage(EVENT_CARRIER_CONFIG_CHANGED, args));
+                return;
+            }
+
+            handleCarrierConfigChanged(slotIndex, subId, carrierId, specificCarrierId);
+        };
+
         if (mCarrierConfigManager != null) {
             mCarrierConfigManager.registerCarrierConfigChangeListener(
                     new HandlerExecutor(new Handler(looper)), mCarrierConfigChangeListener);
@@ -990,31 +982,27 @@ public class SatelliteController extends Handler {
         loadSatelliteSharedPreferences();
         if (mSharedPreferences != null) {
             try {
-                synchronized (mNtnSmsSupportedByMessagesAppLock) {
-                    mNtnSmsSupportedByMessagesApp = mSharedPreferences.getBoolean(
-                            NTN_SMS_SUPPORTED_BY_MESSAGES_APP_KEY, false);
-                }
-
-                synchronized (mCarrierRoamingNtnAllSatellitePlmnSetLock) {
-                    mCarrierRoamingNtnAllSatellitePlmnSet = mSharedPreferences.getStringSet(
-                            CARRIER_ROAMING_NTN_ALL_SATELLITE_PLMN_SET_KEY, new HashSet<>());
-                }
+                setNtnSmsSupportedByMessagesAppCache(mSharedPreferences.getBoolean(
+                        NTN_SMS_SUPPORTED_BY_MESSAGES_APP_KEY, false));
+                setCarrierRoamingNtnAllSatellitePlmnSet(mSharedPreferences.getStringSet(
+                        CARRIER_ROAMING_NTN_ALL_SATELLITE_PLMN_SET_KEY, new HashSet<>()));
             } catch (Exception ex) {
                 plogd("SatelliteController constructor: "
                         + "cannot get default shared preferences. e" + ex);
             }
         }
 
-        mWaitTimeForSatelliteEnablingResponse = getWaitForSatelliteEnablingResponseTimeoutMillis();
-        mDemoPointingAlignedDurationMillis = getDemoPointingAlignedDurationMillisFromResources();
-        mDemoPointingNotAlignedDurationMillis =
-                getDemoPointingNotAlignedDurationMillisFromResources();
-        mSatelliteEmergencyModeDurationMillis =
-                getSatelliteEmergencyModeDurationFromOverlayConfig(context);
-        mEvaluateEsosProfilesPrioritizationDurationMillis =
-                getEvaluateEsosProfilesPrioritizationDurationMillis();
+        mWaitTimeForSatelliteEnablingResponse.set(
+                getWaitForSatelliteEnablingResponseTimeoutMillis());
+        mDemoPointingAlignedDurationMillis.set(getDemoPointingAlignedDurationMillisFromResources());
+        mDemoPointingNotAlignedDurationMillis.set(
+                getDemoPointingNotAlignedDurationMillisFromResources());
+        mSatelliteEmergencyModeDurationMillis.set(
+                getSatelliteEmergencyModeDurationFromOverlayConfig(context));
+        mEvaluateEsosProfilesPrioritizationDurationMillis.set(
+                getEvaluateEsosProfilesPrioritizationDurationMillis());
         sendMessageDelayed(obtainMessage(CMD_EVALUATE_ESOS_PROFILES_PRIORITIZATION),
-                mEvaluateEsosProfilesPrioritizationDurationMillis);
+                mEvaluateEsosProfilesPrioritizationDurationMillis.get());
 
         SubscriptionManager subscriptionManager = mContext.getSystemService(
                 SubscriptionManager.class);
@@ -1037,6 +1025,8 @@ public class SatelliteController extends Handler {
             sendRequestAsync(CMD_GET_SATELLITE_ENABLED_FOR_CARRIER, null, phoneToSendRequest);
         }
 
+        mAlarmManager = mContext.getSystemService(AlarmManager.class);
+        scheduleRegularMetricReportTimer();
         logd("Satellite Tracker is created");
     }
 
@@ -1092,13 +1082,16 @@ public class SatelliteController extends Handler {
     /**
      * Get satelliteConfig from SatelliteConfigParser
      */
+    @Nullable
     public SatelliteConfig getSatelliteConfig() {
         SatelliteConfigParser satelliteConfigParser = getSatelliteConfigParser();
         if (satelliteConfigParser == null) {
             Log.d(TAG, "satelliteConfigParser is not ready");
             return null;
         }
-        return satelliteConfigParser.getConfig();
+        SatelliteConfig satelliteConfig = satelliteConfigParser.getConfig();
+        logd("getSatelliteConfig: satelliteConfig: " + satelliteConfig);
+        return satelliteConfig;
     }
 
     /**
@@ -1113,6 +1106,7 @@ public class SatelliteController extends Handler {
     /**
      * Get SatelliteConfigParser from TelephonyConfigUpdateInstallReceiver
      */
+    @Nullable
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public SatelliteConfigParser getSatelliteConfigParser() {
         return (SatelliteConfigParser) TelephonyConfigUpdateInstallReceiver
@@ -1124,93 +1118,91 @@ public class SatelliteController extends Handler {
         if (mContentResolver != null) {
             IntentFilter radioStateIntentFilter = new IntentFilter();
 
-            synchronized (mRadioStateLock) {
-                // Initialize radio states to default value
-                mDisableBTOnSatelliteEnabled = false;
-                mDisableNFCOnSatelliteEnabled = false;
-                mDisableWifiOnSatelliteEnabled = false;
-                mDisableUWBOnSatelliteEnabled = false;
-
-                mBTStateEnabled = false;
-                mNfcStateEnabled = false;
-                mWifiStateEnabled = false;
-                mUwbStateEnabled = false;
-
-                // Read satellite mode radios from settings
-                String satelliteModeRadios = Settings.Global.getString(mContentResolver,
-                        Settings.Global.SATELLITE_MODE_RADIOS);
-                if (satelliteModeRadios == null) {
-                    ploge("initializeSatelliteModeRadios: satelliteModeRadios is null");
-                    return;
-                }
-                plogd("Radios To be checked when satellite is on: " + satelliteModeRadios);
-
-                if (satelliteModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) {
-                    BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
-                    if (bluetoothAdapter != null) {
-                        mDisableBTOnSatelliteEnabled = true;
-                        mBTStateEnabled = bluetoothAdapter.isEnabled();
-                        radioStateIntentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
-                    }
-                }
+            // Initialize radio states to default value
+            mDisableBTOnSatelliteEnabled.set(false);
+            mDisableNFCOnSatelliteEnabled.set(false);
+            mDisableWifiOnSatelliteEnabled.set(false);
+            mDisableUWBOnSatelliteEnabled.set(false);
+
+            mBTStateEnabled.set(false);
+            mNfcStateEnabled.set(false);
+            mWifiStateEnabled.set(false);
+            mUwbStateEnabled.set(false);
+
+            // Read satellite mode radios from settings
+            String satelliteModeRadios = Settings.Global.getString(mContentResolver,
+                    Settings.Global.SATELLITE_MODE_RADIOS);
+            if (satelliteModeRadios == null) {
+                ploge("initializeSatelliteModeRadios: satelliteModeRadios is null");
+                return;
+            }
+            plogd("Radios To be checked when satellite is on: " + satelliteModeRadios);
 
-                if (satelliteModeRadios.contains(Settings.Global.RADIO_NFC)) {
-                    Context applicationContext = mContext.getApplicationContext();
-                    NfcAdapter nfcAdapter = null;
-                    if (applicationContext != null) {
-                        nfcAdapter = NfcAdapter.getDefaultAdapter(mContext.getApplicationContext());
-                    }
-                    if (nfcAdapter != null) {
-                        mDisableNFCOnSatelliteEnabled = true;
-                        mNfcStateEnabled = nfcAdapter.isEnabled();
-                        radioStateIntentFilter.addAction(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
-                    }
+            if (satelliteModeRadios.contains(Settings.Global.RADIO_BLUETOOTH)) {
+                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+                if (bluetoothAdapter != null) {
+                    mDisableBTOnSatelliteEnabled.set(true);
+                    mBTStateEnabled.set(bluetoothAdapter.isEnabled());
+                    radioStateIntentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
                 }
+            }
 
-                if (satelliteModeRadios.contains(Settings.Global.RADIO_WIFI)) {
-                    WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
-                    if (wifiManager != null) {
-                        mDisableWifiOnSatelliteEnabled = true;
-                        mWifiStateEnabled = wifiManager.isWifiEnabled();
-                        radioStateIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
-                    }
+            if (satelliteModeRadios.contains(Settings.Global.RADIO_NFC)) {
+                Context applicationContext = mContext.getApplicationContext();
+                NfcAdapter nfcAdapter = null;
+                if (applicationContext != null) {
+                    nfcAdapter = NfcAdapter.getDefaultAdapter(mContext.getApplicationContext());
+                }
+                if (nfcAdapter != null) {
+                    mDisableNFCOnSatelliteEnabled.set(true);
+                    mNfcStateEnabled.set(nfcAdapter.isEnabled());
+                    radioStateIntentFilter.addAction(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
                 }
+            }
 
-                try {
-                    // Unregister receiver before registering it.
-                    mContext.unregisterReceiver(mBTWifiNFCSateReceiver);
-                } catch (IllegalArgumentException e) {
-                    plogd("initializeSatelliteModeRadios: unregisterReceiver, e=" + e);
+            if (satelliteModeRadios.contains(Settings.Global.RADIO_WIFI)) {
+                WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
+                if (wifiManager != null) {
+                    mDisableWifiOnSatelliteEnabled.set(true);
+                    mWifiStateEnabled.set(wifiManager.isWifiEnabled());
+                    radioStateIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
                 }
-                mContext.registerReceiver(mBTWifiNFCSateReceiver, radioStateIntentFilter);
-
-                if (satelliteModeRadios.contains(Settings.Global.RADIO_UWB)) {
-                    UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
-                    if (uwbManager != null) {
-                        mDisableUWBOnSatelliteEnabled = true;
-                        mUwbStateEnabled = uwbManager.isUwbEnabled();
-                        final long identity = Binder.clearCallingIdentity();
-                        try {
-                            // Unregister callback before registering it.
-                            uwbManager.unregisterAdapterStateCallback(mUwbAdapterStateCallback);
-                            uwbManager.registerAdapterStateCallback(mContext.getMainExecutor(),
-                                    mUwbAdapterStateCallback);
-                        } finally {
-                            Binder.restoreCallingIdentity(identity);
-                        }
+            }
+
+            try {
+                // Unregister receiver before registering it.
+                mContext.unregisterReceiver(mBTWifiNFCSateReceiver);
+            } catch (IllegalArgumentException e) {
+                plogd("initializeSatelliteModeRadios: unregisterReceiver, e=" + e);
+            }
+            mContext.registerReceiver(mBTWifiNFCSateReceiver, radioStateIntentFilter);
+
+            if (satelliteModeRadios.contains(Settings.Global.RADIO_UWB)) {
+                UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
+                if (uwbManager != null) {
+                    mDisableUWBOnSatelliteEnabled.set(true);
+                    mUwbStateEnabled.set(uwbManager.isUwbEnabled());
+                    final long identity = Binder.clearCallingIdentity();
+                    try {
+                        // Unregister callback before registering it.
+                        uwbManager.unregisterAdapterStateCallback(mUwbAdapterStateCallback);
+                        uwbManager.registerAdapterStateCallback(mContext.getMainExecutor(),
+                                mUwbAdapterStateCallback);
+                    } finally {
+                        Binder.restoreCallingIdentity(identity);
                     }
                 }
+            }
 
-                plogd("mDisableBTOnSatelliteEnabled: " + mDisableBTOnSatelliteEnabled
-                        + " mDisableNFCOnSatelliteEnabled: " + mDisableNFCOnSatelliteEnabled
-                        + " mDisableWifiOnSatelliteEnabled: " + mDisableWifiOnSatelliteEnabled
-                        + " mDisableUWBOnSatelliteEnabled: " + mDisableUWBOnSatelliteEnabled);
+            plogd("mDisableBTOnSatelliteEnabled: " + mDisableBTOnSatelliteEnabled.get()
+                    + " mDisableNFCOnSatelliteEnabled: " + mDisableNFCOnSatelliteEnabled.get()
+                    + " mDisableWifiOnSatelliteEnabled: " + mDisableWifiOnSatelliteEnabled.get()
+                    + " mDisableUWBOnSatelliteEnabled: " + mDisableUWBOnSatelliteEnabled.get());
 
-                plogd("mBTStateEnabled: " + mBTStateEnabled
-                        + " mNfcStateEnabled: " + mNfcStateEnabled
-                        + " mWifiStateEnabled: " + mWifiStateEnabled
-                        + " mUwbStateEnabled: " + mUwbStateEnabled);
-            }
+            plogd("mBTStateEnabled: " + mBTStateEnabled.get()
+                    + " mNfcStateEnabled: " + mNfcStateEnabled.get()
+                    + " mWifiStateEnabled: " + mWifiStateEnabled.get()
+                    + " mUwbStateEnabled: " + mUwbStateEnabled.get());
         }
     }
 
@@ -1236,75 +1228,95 @@ public class SatelliteController extends Handler {
         public void onStateChanged(int state, int reason) {
             plogd("UwbAdapterStateCallback#onStateChanged() called, state = " + toString(state));
             plogd("Adapter state changed reason " + String.valueOf(reason));
-            if (state == UwbManager.AdapterStateCallback.STATE_DISABLED) {
-                setUwbEnabledState(false);
-                evaluateToSendSatelliteEnabledSuccess();
-            } else {
-                setUwbEnabledState(true);
+            if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+                sendMessage(obtainMessage(EVENT_UWB_STATE_CHANGED, state));
+                return;
             }
-            plogd("mUwbStateEnabled: " + getUwbEnabledState());
+
+            handleEventUwbStateChanged(state);
         }
     }
 
+    private void handleEventUwbStateChanged(int state) {
+        if (state == UwbManager.AdapterStateCallback.STATE_DISABLED) {
+            setUwbEnabledState(false);
+            evaluateToSendSatelliteEnabledSuccess();
+        } else {
+            setUwbEnabledState(true);
+        }
+        plogd("mUwbStateEnabled: " + getUwbEnabledState());
+    }
+
     protected class BTWifiNFCStateReceiver extends BroadcastReceiver {
         @Override
         public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            if (action == null) {
-                plogd("BTWifiNFCStateReceiver NULL action for intent " + intent);
+            if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+                sendMessage(obtainMessage(EVENT_BT_WIFI_NFC_STATE_CHANGED, intent));
                 return;
             }
 
-            switch (action) {
-                case BluetoothAdapter.ACTION_STATE_CHANGED:
-                    int btState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
-                            BluetoothAdapter.ERROR);
-                    boolean currentBTStateEnabled = getBTEnabledState();
-                    if (btState == BluetoothAdapter.STATE_OFF) {
-                        setBTEnabledState(false);
-                        evaluateToSendSatelliteEnabledSuccess();
-                    } else if (btState == BluetoothAdapter.STATE_ON) {
-                        setBTEnabledState(true);
-                    }
+            handleEventBtWifiNfcStateChanged(intent);
+        }
+    }
 
-                    if (currentBTStateEnabled != getBTEnabledState()) {
-                        plogd("mBTStateEnabled=" + getBTEnabledState());
-                    }
-                    break;
+    private void handleEventBtWifiNfcStateChanged(@NonNull Intent intent) {
+        final String action = intent.getAction();
+        if (action == null) {
+            plogd("BTWifiNFCStateReceiver NULL action for intent " + intent);
+            return;
+        }
 
-                case NfcAdapter.ACTION_ADAPTER_STATE_CHANGED:
-                    int nfcState = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE, -1);
-                    boolean currentNfcStateEnabled = getNfcEnabledState();
-                    if (nfcState == NfcAdapter.STATE_ON) {
-                        setNfcEnabledState(true);
-                    } else if (nfcState == NfcAdapter.STATE_OFF) {
-                        setNfcEnabledState(false);
-                        evaluateToSendSatelliteEnabledSuccess();
-                    }
+        plogd("handleEventBtWifiNfcStateChanged: action=" + action);
 
-                    if (currentNfcStateEnabled != getNfcEnabledState()) {
-                        plogd("mNfcStateEnabled=" + getNfcEnabledState());
-                    }
-                    break;
+        switch (action) {
+            case BluetoothAdapter.ACTION_STATE_CHANGED:
+                int btState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                        BluetoothAdapter.ERROR);
+                boolean currentBTStateEnabled = getBTEnabledState();
+                if (btState == BluetoothAdapter.STATE_OFF) {
+                    setBTEnabledState(false);
+                    evaluateToSendSatelliteEnabledSuccess();
+                } else if (btState == BluetoothAdapter.STATE_ON) {
+                    setBTEnabledState(true);
+                }
 
-                case WifiManager.WIFI_STATE_CHANGED_ACTION:
-                    int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
-                            WifiManager.WIFI_STATE_UNKNOWN);
-                    boolean currentWifiStateEnabled = getWifiEnabledState();
-                    if (wifiState == WifiManager.WIFI_STATE_ENABLED) {
-                        setWifiEnabledState(true);
-                    } else if (wifiState == WifiManager.WIFI_STATE_DISABLED) {
-                        setWifiEnabledState(false);
-                        evaluateToSendSatelliteEnabledSuccess();
-                    }
+                if (currentBTStateEnabled != getBTEnabledState()) {
+                    plogd("mBTStateEnabled=" + getBTEnabledState());
+                }
+                break;
 
-                    if (currentWifiStateEnabled != getWifiEnabledState()) {
-                        plogd("mWifiStateEnabled=" + getWifiEnabledState());
-                    }
-                    break;
-                default:
-                    break;
-            }
+            case NfcAdapter.ACTION_ADAPTER_STATE_CHANGED:
+                int nfcState = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE, -1);
+                boolean currentNfcStateEnabled = getNfcEnabledState();
+                if (nfcState == NfcAdapter.STATE_ON) {
+                    setNfcEnabledState(true);
+                } else if (nfcState == NfcAdapter.STATE_OFF) {
+                    setNfcEnabledState(false);
+                    evaluateToSendSatelliteEnabledSuccess();
+                }
+
+                if (currentNfcStateEnabled != getNfcEnabledState()) {
+                    plogd("mNfcStateEnabled=" + getNfcEnabledState());
+                }
+                break;
+
+            case WifiManager.WIFI_STATE_CHANGED_ACTION:
+                int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
+                        WifiManager.WIFI_STATE_UNKNOWN);
+                boolean currentWifiStateEnabled = getWifiEnabledState();
+                if (wifiState == WifiManager.WIFI_STATE_ENABLED) {
+                    setWifiEnabledState(true);
+                } else if (wifiState == WifiManager.WIFI_STATE_DISABLED) {
+                    setWifiEnabledState(false);
+                    evaluateToSendSatelliteEnabledSuccess();
+                }
+
+                if (currentWifiStateEnabled != getWifiEnabledState()) {
+                    plogd("mWifiStateEnabled=" + getWifiEnabledState());
+                }
+                break;
+            default:
+                break;
         }
     }
 
@@ -1525,17 +1537,15 @@ public class SatelliteController extends Handler {
 
                 if (error == SATELLITE_RESULT_SUCCESS) {
                     if (argument.enableSatellite) {
-                        synchronized (mSatelliteEnabledRequestLock) {
-                            mWaitingForRadioDisabled = true;
-                            setDemoModeEnabled(argument.enableDemoMode);
-                        }
+                        mWaitingForRadioDisabled.set(true);
+                        setDemoModeEnabled(argument.enableDemoMode);
                         // TODO (b/361139260): Start a timer to wait for other radios off
                         setSettingsKeyForSatelliteMode(SATELLITE_MODE_ENABLED_TRUE);
                         setSettingsKeyToAllowDeviceRotation(SATELLITE_MODE_ENABLED_TRUE);
                         evaluateToSendSatelliteEnabledSuccess();
                     } else {
                         // Unregister importance listener for PointingUI when satellite is disabled
-                        if (mNeedsSatellitePointing) {
+                        if (mNeedsSatellitePointing.get()) {
                             mPointingAppController.removeListenerForPointingUI();
                         }
 
@@ -1543,9 +1553,7 @@ public class SatelliteController extends Handler {
                             moveSatelliteToOffStateAndCleanUpResources(SATELLITE_RESULT_SUCCESS);
                         }
 
-                        synchronized (mSatelliteEnabledRequestLock) {
-                            mWaitingForDisableSatelliteModemResponse = false;
-                        }
+                        mWaitingForDisableSatelliteModemResponse.set(false);
                     }
                     // Request NTN signal strength report when satellite enabled or disabled done.
                     mLatestRequestedStateForNtnSignalStrengthReport.set(argument.enableSatellite);
@@ -1570,33 +1578,31 @@ public class SatelliteController extends Handler {
                     mSessionMetricsStats.setInitializationResult(error)
                             .setSatelliteTechnology(getSupportedNtnRadioTechnology())
                             .setInitializationProcessingTime(
-                                    getElapsedRealtime() - mSessionProcessingTimeStamp)
-                            .setIsDemoMode(mIsDemoModeEnabled)
+                                    getElapsedRealtime() - mSessionProcessingTimeStamp.get())
+                            .setIsDemoMode(mIsDemoModeEnabled.get())
                             .setCarrierId(getSatelliteCarrierId())
                             .setIsEmergency(argument.isEmergency);
-                    mSessionProcessingTimeStamp = 0;
+                    mSessionProcessingTimeStamp.set(0);
 
                     if (error == SATELLITE_RESULT_SUCCESS) {
                         mControllerMetricsStats.onSatelliteEnabled();
                         mControllerMetricsStats.reportServiceEnablementSuccessCount();
                     } else {
                         mSessionMetricsStats.reportSessionMetrics();
-                        mSessionStartTimeStamp = 0;
+                        mSessionStartTimeStamp.set(0);
                         mControllerMetricsStats.reportServiceEnablementFailCount();
                     }
                 } else {
                     mSessionMetricsStats.setTerminationResult(error)
                             .setTerminationProcessingTime(getElapsedRealtime()
-                                    - mSessionProcessingTimeStamp)
+                                    - mSessionProcessingTimeStamp.get())
                             .setSessionDurationSec(calculateSessionDurationTimeSec())
                             .reportSessionMetrics();
-                    mSessionStartTimeStamp = 0;
-                    mSessionProcessingTimeStamp = 0;
+                    mSessionStartTimeStamp.set(0);
+                    mSessionProcessingTimeStamp.set(0);
                     mControllerMetricsStats.onSatelliteDisabled();
-                    handlePersistentLoggingOnSessionEnd(mIsEmergency);
-                    synchronized (mSatelliteEnabledRequestLock) {
-                        mWaitingForDisableSatelliteModemResponse = false;
-                    }
+                    handlePersistentLoggingOnSessionEnd(mIsEmergency.get());
+                    mWaitingForDisableSatelliteModemResponse.set(false);
                 }
                 break;
             }
@@ -1616,25 +1622,21 @@ public class SatelliteController extends Handler {
                     plogd("UpdateEnableAttributes: carrierRoamingNbIotNtn flag is disabled");
                     sendErrorAndReportSessionMetrics(
                             SatelliteManager.SATELLITE_RESULT_INVALID_ARGUMENTS, argument.callback);
-                    synchronized (mSatelliteEnabledRequestLock) {
-                        mSatelliteEnableAttributesUpdateRequest = null;
-                    }
+                    setSatelliteEnableAttributesUpdateRequest(null);
                     break;
                 }
 
-                synchronized (mSatelliteEnabledRequestLock) {
-                    if (mSatelliteEnabledRequest != null) {
-                        plogd("UpdateEnableAttributes: Satellite is being enabled. Need to "
-                                + "wait until enable complete before updating attributes");
-                        break;
-                    }
-                    if (isSatelliteBeingDisabled()) {
-                        plogd("UpdateEnableAttributes: Satellite is being disabled. Aborting the "
-                                + "enable attributes update request");
-                        mSatelliteEnableAttributesUpdateRequest = null;
-                        argument.callback.accept(SATELLITE_RESULT_REQUEST_ABORTED);
-                        break;
-                    }
+                if (getSatelliteEnabledRequest() != null) {
+                    plogd("UpdateEnableAttributes: Satellite is being enabled. Need to "
+                            + "wait until enable complete before updating attributes");
+                    break;
+                }
+                if (isSatelliteBeingDisabled()) {
+                    plogd("UpdateEnableAttributes: Satellite is being disabled. Aborting the "
+                            + "enable attributes update request");
+                    setSatelliteEnableAttributesUpdateRequest(null);
+                    argument.callback.accept(SATELLITE_RESULT_REQUEST_ABORTED);
+                    break;
                 }
                 onCompleted = obtainMessage(EVENT_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_DONE, request);
                 SatelliteModemEnableRequestAttributes enableRequestAttributes =
@@ -1644,9 +1646,7 @@ public class SatelliteController extends Handler {
                     sendErrorAndReportSessionMetrics(
                         SatelliteManager.SATELLITE_RESULT_INVALID_TELEPHONY_STATE,
                         argument.callback);
-                    synchronized (mSatelliteEnabledRequestLock) {
-                        mSatelliteEnableAttributesUpdateRequest = null;
-                    }
+                    setSatelliteEnableAttributesUpdateRequest(null);
                     break;
                 }
                 mSatelliteModemInterface.requestSatelliteEnabled(
@@ -1678,9 +1678,7 @@ public class SatelliteController extends Handler {
                     setDemoModeEnabled(argument.enableDemoMode);
                     setEmergencyMode(argument.isEmergency);
                 }
-                synchronized (mSatelliteEnabledRequestLock) {
-                    mSatelliteEnableAttributesUpdateRequest = null;
-                }
+                setSatelliteEnableAttributesUpdateRequest(null);
                 argument.callback.accept(error);
                 break;
             }
@@ -1690,9 +1688,7 @@ public class SatelliteController extends Handler {
                         (RequestSatelliteEnabledArgument) msg.obj;
                 plogw("Timed out to wait for the response from the modem for the request to "
                         + "update satellite enable attributes, request ID = " + argument.requestId);
-                synchronized (mSatelliteEnabledRequestLock) {
-                    mSatelliteEnableAttributesUpdateRequest = null;
-                }
+                setSatelliteEnableAttributesUpdateRequest(null);
                 argument.callback.accept(SATELLITE_RESULT_MODEM_TIMEOUT);
                 break;
             }
@@ -1774,13 +1770,8 @@ public class SatelliteController extends Handler {
                         error = SatelliteManager.SATELLITE_RESULT_INVALID_TELEPHONY_STATE;
                     } else {
                         SatelliteCapabilities capabilities = (SatelliteCapabilities) ar.result;
-                        synchronized (mNeedsSatellitePointingLock) {
-                            mNeedsSatellitePointing = capabilities.isPointingRequired();
-                        }
-
-                        synchronized (mSatelliteCapabilitiesLock) {
-                            mSatelliteCapabilities = capabilities;
-                        }
+                        mNeedsSatellitePointing.set(capabilities.isPointingRequired());
+                        setSatelliteCapabilities(capabilities);
                         overrideSatelliteCapabilitiesIfApplicable();
                         if (DBG) plogd("getSatelliteCapabilities: " + getSatelliteCapabilities());
                         bundle.putParcelable(SatelliteManager.KEY_SATELLITE_CAPABILITIES,
@@ -1825,20 +1816,16 @@ public class SatelliteController extends Handler {
             }
 
             case EVENT_RADIO_STATE_CHANGED: {
-                synchronized (mIsRadioOnLock) {
-                    logd("EVENT_RADIO_STATE_CHANGED: radioState=" + mCi.getRadioState());
-                    if (mCi.getRadioState() == TelephonyManager.RADIO_POWER_ON) {
-                        mIsRadioOn = true;
-                    } else if (mCi.getRadioState() == TelephonyManager.RADIO_POWER_OFF) {
-                        resetCarrierRoamingSatelliteModeParams();
-                        synchronized (mIsRadioOnLock) {
-                            if (mRadioOffRequested) {
-                                logd("EVENT_RADIO_STATE_CHANGED: set mIsRadioOn to false");
-                                stopWaitForCellularModemOffTimer();
-                                mIsRadioOn = false;
-                                mRadioOffRequested = false;
-                            }
-                        }
+                logd("EVENT_RADIO_STATE_CHANGED: radioState=" + mCi.getRadioState());
+                if (mCi.getRadioState() == TelephonyManager.RADIO_POWER_ON) {
+                    mIsRadioOn.set(true);
+                } else if (mCi.getRadioState() == TelephonyManager.RADIO_POWER_OFF) {
+                    resetCarrierRoamingSatelliteModeParams();
+                    if (mRadioOffRequested.get()) {
+                        logd("EVENT_RADIO_STATE_CHANGED: set mIsRadioOn to false");
+                        stopWaitForCellularModemOffTimer();
+                        mIsRadioOn.set(false);
+                        mRadioOffRequested.set(false);
                     }
                 }
 
@@ -1923,18 +1910,15 @@ public class SatelliteController extends Handler {
 
                 plogd("EVENT_EVALUATE_SATELLITE_ATTACH_RESTRICTION_CHANGE_DONE: subId="
                         + subId + " error:" + error);
-                synchronized (mIsSatelliteEnabledLock) {
-                    if (error == SATELLITE_RESULT_SUCCESS) {
-                        boolean enableSatellite = mSatelliteAttachRestrictionForCarrierArray
-                                .getOrDefault(argument.subId, Collections.emptySet()).isEmpty();
-                        plogd("EVENT_EVALUATE_SATELLITE_ATTACH_RESTRICTION_CHANGE_DONE: "
-                                + "satelliteAttachEnabledForCarrier=" + enableSatellite);
-                        mIsSatelliteAttachEnabledForCarrierArrayPerSub.put(subId, enableSatellite);
-                    } else {
-                        mIsSatelliteAttachEnabledForCarrierArrayPerSub.remove(subId);
-                    }
+                if (error == SATELLITE_RESULT_SUCCESS) {
+                    boolean enableSatellite = mSatelliteAttachRestrictionForCarrierArray
+                            .getOrDefault(argument.subId, Collections.emptySet()).isEmpty();
+                    plogd("EVENT_EVALUATE_SATELLITE_ATTACH_RESTRICTION_CHANGE_DONE: "
+                            + "satelliteAttachEnabledForCarrier=" + enableSatellite);
+                    mIsSatelliteAttachEnabledForCarrierArrayPerSub.put(subId, enableSatellite);
+                } else {
+                    mIsSatelliteAttachEnabledForCarrierArrayPerSub.remove(subId);
                 }
-
                 argument.callback.accept(error);
                 break;
             }
@@ -1953,30 +1937,24 @@ public class SatelliteController extends Handler {
                 ResultReceiver result = (ResultReceiver) request.argument;
                 int errorCode =  SatelliteServiceUtils.getSatelliteError(ar,
                         "requestNtnSignalStrength");
+
                 if (errorCode == SATELLITE_RESULT_SUCCESS) {
                     NtnSignalStrength ntnSignalStrength = (NtnSignalStrength) ar.result;
                     if (ntnSignalStrength != null) {
-                        synchronized (mNtnSignalsStrengthLock) {
-                            mNtnSignalStrength = ntnSignalStrength;
-                        }
+                        setNtnSignalStrength(ntnSignalStrength);
                         Bundle bundle = new Bundle();
                         bundle.putParcelable(KEY_NTN_SIGNAL_STRENGTH, ntnSignalStrength);
                         result.send(SATELLITE_RESULT_SUCCESS, bundle);
                     } else {
-                        synchronized (mNtnSignalsStrengthLock) {
-                            if (mNtnSignalStrength.getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
-                                mNtnSignalStrength = new NtnSignalStrength(
-                                        NTN_SIGNAL_STRENGTH_NONE);
-                            }
+                        if (getNtnSignalStrength().getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
+                            setNtnSignalStrength(new NtnSignalStrength(NTN_SIGNAL_STRENGTH_NONE));
                         }
                         ploge("EVENT_REQUEST_NTN_SIGNAL_STRENGTH_DONE: ntnSignalStrength is null");
                         result.send(SatelliteManager.SATELLITE_RESULT_REQUEST_FAILED, null);
                     }
                 } else {
-                    synchronized (mNtnSignalsStrengthLock) {
-                        if (mNtnSignalStrength.getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
-                            mNtnSignalStrength = new NtnSignalStrength(NTN_SIGNAL_STRENGTH_NONE);
-                        }
+                    if (getNtnSignalStrength().getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
+                        setNtnSignalStrength(new NtnSignalStrength(NTN_SIGNAL_STRENGTH_NONE));
                     }
                     result.send(errorCode, null);
                 }
@@ -2067,7 +2045,7 @@ public class SatelliteController extends Handler {
             }
 
             case EVENT_NOTIFY_NTN_ELIGIBILITY_HYSTERESIS_TIMED_OUT: {
-                boolean eligible = isCarrierRoamingNtnEligible(mSatellitePhone);
+                boolean eligible = isCarrierRoamingNtnEligible(getSatellitePhone());
                 plogd("EVENT_NOTIFY_NTN_ELIGIBILITY_HYSTERESIS_TIMED_OUT:"
                         + " isCarrierRoamingNtnEligible=" + eligible);
                 updateLastNotifiedNtnEligibilityAndNotify(eligible);
@@ -2095,13 +2073,11 @@ public class SatelliteController extends Handler {
                 } else {
                     String iccId = subscriptionInfo.getIccId();
                     argument.setIccId(iccId);
-                    synchronized (mSatelliteTokenProvisionedLock) {
-                        if (!iccId.equals(mLastConfiguredIccId)) {
-                            logd("updateSatelliteSubscription subId=" + subId
-                                    + ", iccId=" + iccId + " to modem");
-                            mSatelliteModemInterface.updateSatelliteSubscription(
+                    if (!iccId.equals(getLastConfiguredIccId())) {
+                        logd("updateSatelliteSubscription subId=" + subId
+                                + ", iccId=" + iccId + " to modem");
+                        mSatelliteModemInterface.updateSatelliteSubscription(
                                 iccId, onCompleted);
-                        }
                     }
                 }
                 if (provisionChanged) {
@@ -2127,9 +2103,7 @@ public class SatelliteController extends Handler {
                 int error = SatelliteServiceUtils.getSatelliteError(ar,
                         "updateSatelliteSubscription");
                 if (error == SATELLITE_RESULT_SUCCESS) {
-                    synchronized (mSatelliteTokenProvisionedLock) {
-                        mLastConfiguredIccId = argument.getIccId();
-                    }
+                    setLastConfiguredIccId(argument.getIccId());
                 }
                 mProvisionMetricsStats.setResultCode(error)
                         .setIsProvisionRequest(argument.mProvisioned)
@@ -2146,36 +2120,26 @@ public class SatelliteController extends Handler {
             }
 
             case EVENT_WIFI_CONNECTIVITY_STATE_CHANGED: {
-                synchronized (mIsWifiConnectedLock) {
-                    ar = (AsyncResult) msg.obj;
-                    mIsWifiConnected = (boolean) ar.result;
-                    plogd("EVENT_WIFI_CONNECTIVITY_STATE_CHANGED: mIsWifiConnected="
-                            + mIsWifiConnected);
-                }
+                ar = (AsyncResult) msg.obj;
+                mIsWifiConnected.set((boolean) ar.result);
+                plogd("EVENT_WIFI_CONNECTIVITY_STATE_CHANGED: mIsWifiConnected="
+                        + mIsWifiConnected.get());
                 evaluateCarrierRoamingNtnEligibilityChange();
                 break;
             }
 
             case EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT: {
                 plogw("Timed out to wait for cellular modem OFF state");
-                synchronized (mIsRadioOnLock) {
-                    mRadioOffRequested = false;
-                }
+                mRadioOffRequested.set(false);
                 break;
             }
 
-            case EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT: {
-                // TODO: b/366329504 report carrier roaming metrics for multiple subscription IDs.
-                synchronized (mSupportedSatelliteServicesLock) {
-                    int defaultSubId = mSubscriptionManagerService.getDefaultSubId();
-                    boolean isEntitled = mSatelliteEntitlementStatusPerCarrier.get(defaultSubId,
-                            false);
-                    mCarrierRoamingSatelliteControllerStats.reportIsDeviceEntitled(defaultSubId,
-                            isEntitled);
-                }
-                sendMessageDelayed(obtainMessage(
-                                EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT),
-                        WAIT_FOR_REPORT_ENTITLED_MERTICS_TIMEOUT_MILLIS);
+            case EVENT_WAIT_FOR_REGULAR_METRICS_REPORT_HYSTERESIS_TIMED_OUT: {
+                handleEntireEntitlementMetricReport();
+                handleEntireProvisionMetricReport();
+                handleCarrierRoamingConfigVersionReport();
+                handleMaxAllowedDataMetricsReport();
+                scheduleRegularMetricReportTimer();
                 break;
             }
 
@@ -2264,58 +2228,398 @@ public class SatelliteController extends Handler {
                 break;
             }
 
-            case CMD_LOCATION_SERVICE_STATE_CHANGED:
-                plogd("CMD_LOCATION_SERVICE_STATE_CHANGED");
-                // Fall through
-            case CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE: {
-                plogd("CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE");
-                evaluateCarrierRoamingNtnEligibilityChange();
-                boolean eligible = isCarrierRoamingNtnEligible(getSatellitePhone());
-                plogd("CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE: eligible=" + eligible);
-                int selectedSatelliteSubId = getSelectedSatelliteSubId();
-                Phone phone = SatelliteServiceUtils.getPhone(selectedSatelliteSubId);
-                if (eligible) {
-                    synchronized (mSatellitePhoneLock) {
-                        mLastNotifiedNtnEligibility = eligible;
-                    }
-                    phone.notifyCarrierRoamingNtnEligibleStateChanged(eligible);
+            case CMD_LOCATION_SERVICE_STATE_CHANGED:
+                plogd("CMD_LOCATION_SERVICE_STATE_CHANGED");
+                // Fall through
+            case CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE: {
+                plogd("CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE");
+                evaluateCarrierRoamingNtnEligibilityChange();
+                boolean eligible = isCarrierRoamingNtnEligible(getSatellitePhone());
+                plogd("CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE: eligible=" + eligible);
+                int selectedSatelliteSubId = getSelectedSatelliteSubId();
+                Phone phone = SatelliteServiceUtils.getPhone(selectedSatelliteSubId);
+                if (eligible) {
+                    setLastNotifiedNtnEligibility(eligible);
+                    phone.notifyCarrierRoamingNtnEligibleStateChanged(eligible);
+                }
+                break;
+            }
+
+            case CMD_GET_SATELLITE_ENABLED_FOR_CARRIER: {
+                request = (SatelliteControllerHandlerRequest) msg.obj;
+                Phone phone = request.phone;
+                int subId = phone.getSubId();
+                onCompleted = obtainMessage(EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE,
+                        subId);
+                int simSlot = SubscriptionManager.getSlotIndex(subId);
+                plogd("CMD_GET_SATELLITE_ENABLED_FOR_CARRIER: subId=" + subId);
+                phone.isSatelliteEnabledForCarrier(simSlot, onCompleted);
+                break;
+            }
+
+            case EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: {
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.result == null) {
+                    loge("EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: result is null");
+                } else {
+                    int subId = (int) ar.userObj;
+                    int error = SatelliteServiceUtils.getSatelliteError(
+                            ar, "isSatelliteEnabledForCarrier");
+                    boolean satelliteEnabled = (Boolean) ar.result;
+                    plogd("EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: subId=" + subId
+                            + " error=" + error + " satelliteEnabled=" + satelliteEnabled);
+
+                    if (error == SATELLITE_RESULT_SUCCESS) {
+                        mIsSatelliteAttachEnabledForCarrierArrayPerSub.put(
+                                subId, satelliteEnabled);
+                        evaluateEnablingSatelliteForCarrier(subId,
+                                SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER, null);
+                    }
+                }
+                break;
+            }
+
+            case REQUEST_SATELLITE_ENABLED: {
+                plogd("REQUEST_SATELLITE_ENABLED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean enableSatellite = (boolean) args.arg1;
+                boolean enableDemoMode = (boolean) args.arg2;
+                boolean isEmergency = (boolean) args.arg3;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg4;
+                try {
+                    handleRequestSatelliteEnabled(
+                            enableSatellite, enableDemoMode, isEmergency, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_IS_SATELLITE_ENABLED: {
+                plogd("REQUEST_IS_SATELLITE_ENABLED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestIsSatelliteEnabled(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_IS_DEMO_MODE_ENABLED: {
+                plogd("REQUEST_IS_DEMO_MODE_ENABLED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestIsDemoModeEnabled(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_IS_EMERGENCY_MODE_ENABLED: {
+                plogd("REQUEST_IS_EMERGENCY_MODE_ENABLED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestIsEmergencyModeEnabled(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_IS_SATELLITE_SUPPORTED: {
+                plogd("REQUEST_IS_SATELLITE_SUPPORTED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestIsSatelliteSupported(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SATELLITE_CAPABILITIES: {
+                plogd("REQUEST_SATELLITE_CAPABILITIES");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestSatelliteCapabilities(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_START_SATELLITE_TRANSMISSION_UPDATES: {
+                plogd("REQUEST_START_SATELLITE_TRANSMISSION_UPDATES");
+                SomeArgs args = (SomeArgs) msg.obj;
+                IIntegerConsumer errorCallback = (IIntegerConsumer) args.arg1;
+                ISatelliteTransmissionUpdateCallback callback =
+                        (ISatelliteTransmissionUpdateCallback) args.arg2;
+                try {
+                    handleRequestStartSatelliteTransmissionUpdates(errorCallback, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_STOP_SATELLITE_TRANSMISSION_UPDATES: {
+                plogd("REQUEST_STOP_SATELLITE_TRANSMISSION_UPDATES");
+                SomeArgs args = (SomeArgs) msg.obj;
+                IIntegerConsumer errorCallback = (IIntegerConsumer) args.arg1;
+                ISatelliteTransmissionUpdateCallback callback =
+                        (ISatelliteTransmissionUpdateCallback) args.arg2;
+                try {
+                    handleRequestStopSatelliteTransmissionUpdates(errorCallback, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_IS_SATELLITE_PROVISIONED: {
+                plogd("REQUEST_IS_SATELLITE_PROVISIONED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestIsSatelliteProvisioned(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_POLL_PENDING_DATAGRAMS: {
+                plogd("REQUEST_POLL_PENDING_DATAGRAMS");
+                SomeArgs args = (SomeArgs) msg.obj;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg1;
+                try {
+                    handleRequestPollPendingDatagrams(callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SEND_DATAGRAM: {
+                plogd("REQUEST_SEND_DATAGRAM");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int datagramType = (int) args.arg1;
+                SatelliteDatagram datagram = (SatelliteDatagram) args.arg2;
+                boolean needFullScreenPointingUI = (boolean) args.arg3;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg4;
+                try {
+                    handleRequestSendDatagram(
+                            datagramType, datagram, needFullScreenPointingUI, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_TIME_FOR_NEXT_SATELLITE_VISIBILITY: {
+                plogd("REQUEST_TIME_FOR_NEXT_SATELLITE_VISIBILITY");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestTimeForNextSatelliteVisibility(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SATELLITE_DISPLAY_NAME: {
+                plogd("REQUEST_SATELLITE_DISPLAY_NAME");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestSatelliteDisplayName(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SELECTED_NB_IOT_SATELLITE_SUBSCRIPTION_ID: {
+                plogd("REQUEST_SELECTED_NB_IOT_SATELLITE_SUBSCRIPTION_ID");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestSelectedNbIotSatelliteSubscriptionId(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE: {
+                plogd("REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE");
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean isAligned = (boolean) args.arg1;
+                try {
+                    handleRequestSetDeviceAlignedWithSatellite(isAligned);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_ADD_ATTACH_RESTRICTION_FOR_CARRIER: {
+                plogd("REQUEST_ADD_ATTACH_RESTRICTION_FOR_CARRIER");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int subId = (int) args.arg1;
+                int reason = (int) args.arg2;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg3;
+                try {
+                    handleRequestAddAttachRestrictionForCarrier(subId, reason, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_REMOVE_ATTACH_RESTRICTION_FOR_CARRIER: {
+                plogd("REQUEST_REMOVE_ATTACH_RESTRICTION_FOR_CARRIER");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int subId = (int) args.arg1;
+                int reason = (int) args.arg2;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg3;
+                try {
+                    handleRequestRemoveAttachRestrictionForCarrier(subId, reason, callback);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_NTN_SIGNAL_STRENGTH: {
+                plogd("REQUEST_NTN_SIGNAL_STRENGTH");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestNtnSignalStrength(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SATELLITE_SUBSCRIBER_PROVISION_STATUS: {
+                plogd("REQUEST_SATELLITE_SUBSCRIBER_PROVISION_STATUS");
+                SomeArgs args = (SomeArgs) msg.obj;
+                ResultReceiver result = (ResultReceiver) args.arg1;
+                try {
+                    handleRequestSatelliteSubscriberProvisionStatus(result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_SET_NTN_SMS_SUPPORTED_BY_MESSAGES_APP: {
+                plogd("REQUEST_SET_NTN_SMS_SUPPORTED_BY_MESSAGES_APP");
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean ntnSmsSupported = (boolean) args.arg1;
+                try {
+                    handleRequestSetNtnSmsSupportedByMessagesApp(ntnSmsSupported);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_PROVISION_SATELLITE: {
+                plogd("REQUEST_PROVISION_SATELLITE");
+                SomeArgs args = (SomeArgs) msg.obj;
+                List<SatelliteSubscriberInfo> list = (List<SatelliteSubscriberInfo>) args.arg1;
+                ResultReceiver result = (ResultReceiver) args.arg2;
+                try {
+                    handleRequestProvisionSatellite(list, result);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case REQUEST_DEPROVISION_SATELLITE: {
+                plogd("REQUEST_DEPROVISION_SATELLITE");
+                SomeArgs args = (SomeArgs) msg.obj;
+                List<SatelliteSubscriberInfo> list = (List<SatelliteSubscriberInfo>) args.arg1;
+                ResultReceiver result = (ResultReceiver) args.arg2;
+                try {
+                    handleRequestDeprovisionSatellite(list, result);
+                } finally {
+                    args.recycle();
                 }
                 break;
             }
 
-            case CMD_GET_SATELLITE_ENABLED_FOR_CARRIER: {
-                request = (SatelliteControllerHandlerRequest) msg.obj;
-                Phone phone = request.phone;
-                int subId = phone.getSubId();
-                onCompleted = obtainMessage(EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE,
-                        subId);
-                int simSlot = SubscriptionManager.getSlotIndex(subId);
-                plogd("CMD_GET_SATELLITE_ENABLED_FOR_CARRIER: subId=" + subId);
-                phone.isSatelliteEnabledForCarrier(simSlot, onCompleted);
+            case EVENT_SATELLITE_ACCESS_ALLOWED_STATE_CHANGED: {
+                plogd("EVENT_SATELLITE_ACCESS_ALLOWED_STATE_CHANGED");
+                handleSatelliteAccessAllowedStateChanged((boolean) msg.obj);
                 break;
             }
 
-            case EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: {
-                ar = (AsyncResult) msg.obj;
+            case EVENT_SATELLITE_ACCESS_CONFIGURATION_CHANGED: {
+                plogd("EVENT_SATELLITE_ACCESS_CONFIGURATION_CHANGED");
+                handleSatelliteAccessConfigUpdateResult((SatelliteAccessConfiguration) msg.obj);
+                break;
+            }
 
-                if (ar.result == null) {
-                    loge("EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: result is null");
-                } else {
-                    int subId = (int) ar.userObj;
-                    int error = SatelliteServiceUtils.getSatelliteError(
-                            ar, "isSatelliteEnabledForCarrier");
-                    boolean satelliteEnabled = (Boolean) ar.result;
-                    plogd("EVENT_GET_SATELLITE_ENABLED_FOR_CARRIER_DONE: subId=" + subId
-                            + " error=" + error + " satelliteEnabled=" + satelliteEnabled);
+            case EVENT_BT_WIFI_NFC_STATE_CHANGED: {
+                plogd("EVENT_BT_WIFI_NFC_STATE_CHANGED");
+                handleEventBtWifiNfcStateChanged((Intent) msg.obj);
+                break;
+            }
 
-                    if (error == SATELLITE_RESULT_SUCCESS) {
-                        synchronized (mIsSatelliteEnabledLock) {
-                            mIsSatelliteAttachEnabledForCarrierArrayPerSub.put(
-                                    subId, satelliteEnabled);
-                        }
-                        evaluateEnablingSatelliteForCarrier(subId,
-                                SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER, null);
-                    }
+            case EVENT_UWB_STATE_CHANGED: {
+                plogd("EVENT_UWB_STATE_CHANGED");
+                handleEventUwbStateChanged((int) msg.obj);
+                break;
+            }
+
+            case EVENT_CARRIER_CONFIG_CHANGED: {
+                plogd("EVENT_CARRIER_CONFIG_CHANGED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int slotIndex = (int) args.arg1;
+                int subId = (int) args.arg2;
+                int carrierId = (int) args.arg3;
+                int specificCarrierId = (int) args.arg4;
+                try {
+                    handleCarrierConfigChanged(slotIndex, subId, carrierId, specificCarrierId);
+                } finally {
+                    args.recycle();
+                }
+                break;
+            }
+
+            case EVENT_SATELLITE_ENTILEMENT_STATUS_UPDATED: {
+                plogd("EVENT_SATELLITE_ENTILEMENT_STATUS_UPDATED");
+                SomeArgs args = (SomeArgs) msg.obj;
+                int subId = args.argi1;
+                boolean entitlementEnabled = args.argi2 == TRUE ? true : false;
+                List<String> allowedPlmnList = (List<String>) args.arg1;
+                List<String> barredPlmnList = (List<String>) args.arg2;
+                Map<String, Integer> plmnDataPlanMap = (Map<String, Integer>) args.arg3;
+                Map<String, List<Integer>> plmnServiceTypeMap =
+                    (Map<String, List<Integer>>) args.arg4;
+                Map<String, Integer> plmnDataServicePolicyMap = (Map<String, Integer>) args.arg5;
+                Map<String, Integer> plmnVoiceServicePolicyMap = (Map<String, Integer>) args.arg6;
+                IIntegerConsumer callback = (IIntegerConsumer) args.arg7;
+                try {
+                    handleSatelliteEntitlementStatusUpdated(subId, entitlementEnabled,
+                        allowedPlmnList, barredPlmnList, plmnDataPlanMap, plmnServiceTypeMap,
+                        plmnDataServicePolicyMap, plmnVoiceServicePolicyMap, callback);
+                } finally {
+                    args.recycle();
                 }
                 break;
             }
@@ -2332,7 +2636,7 @@ public class SatelliteController extends Handler {
         @NonNull
         public ResultReceiver mResult;
         public long mRequestId;
-        public String mIccId;
+        @NonNull public String mIccId;
         public boolean mProvisioned;
 
         RequestProvisionSatelliteArgument(List<SatelliteSubscriberInfo> satelliteSubscriberInfoList,
@@ -2344,10 +2648,11 @@ public class SatelliteController extends Handler {
                     n -> ((n + 1) % Long.MAX_VALUE));
         }
 
-        public void setIccId(String iccId) {
+        public void setIccId(@NonNull String iccId) {
             mIccId = iccId;
         }
 
+        @NonNull
         public String getIccId() {
             return mIccId;
         }
@@ -2387,6 +2692,24 @@ public class SatelliteController extends Handler {
             boolean isEmergency, @NonNull IIntegerConsumer callback) {
         plogd("requestSatelliteEnabled enableSatellite: " + enableSatellite
                 + " enableDemoMode: " + enableDemoMode + " isEmergency: " + isEmergency);
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = enableSatellite;
+            args.arg2 = enableDemoMode;
+            args.arg3 = isEmergency;
+            args.arg4 = callback;
+            sendMessage(obtainMessage(REQUEST_SATELLITE_ENABLED, args));
+            return;
+        }
+
+        handleRequestSatelliteEnabled(enableSatellite, enableDemoMode, isEmergency, callback);
+    }
+
+    private void handleRequestSatelliteEnabled(boolean enableSatellite, boolean enableDemoMode,
+            boolean isEmergency, @NonNull IIntegerConsumer callback) {
+        plogd("handleRequestSatelliteEnabled: enableSatellite: " + enableSatellite
+                + " enableDemoMode: " + enableDemoMode + " isEmergency: " + isEmergency);
+
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(callback::accept);
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
@@ -2395,19 +2718,17 @@ public class SatelliteController extends Handler {
         }
 
         if (enableSatellite) {
-            synchronized (mIsRadioOnLock) {
-                if (!mIsRadioOn) {
-                    ploge("Radio is not on, can not enable satellite");
-                    sendErrorAndReportSessionMetrics(
-                            SatelliteManager.SATELLITE_RESULT_INVALID_MODEM_STATE, result);
-                    return;
-                }
-                if (mRadioOffRequested) {
-                    ploge("Radio is being powering off, can not enable satellite");
-                    sendErrorAndReportSessionMetrics(
-                            SatelliteManager.SATELLITE_RESULT_INVALID_MODEM_STATE, result);
-                    return;
-                }
+            if (!mIsRadioOn.get()) {
+                ploge("Radio is not on, can not enable satellite");
+                sendErrorAndReportSessionMetrics(
+                        SatelliteManager.SATELLITE_RESULT_INVALID_MODEM_STATE, result);
+                return;
+            }
+            if (mRadioOffRequested.get()) {
+                ploge("Radio is being powering off, can not enable satellite");
+                sendErrorAndReportSessionMetrics(
+                        SatelliteManager.SATELLITE_RESULT_INVALID_MODEM_STATE, result);
+                return;
             }
 
             if (mTelecomManager.isInEmergencyCall()) {
@@ -2435,86 +2756,84 @@ public class SatelliteController extends Handler {
          *      4. ongoing request = enable, current request = disable: send request to modem
          */
         Boolean isSatelliteEnabled = getIsSatelliteEnabled();
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-                if (mSatelliteEnabledRequest != null && mNetworkSelectionModeAutoDialog != null
-                        && mNetworkSelectionModeAutoDialog.isShowing()
-                        && request.isEmergency && request.enableSatellite) {
-                    sendErrorAndReportSessionMetrics(
-                            SatelliteManager.SATELLITE_RESULT_ILLEGAL_STATE,
-                            FunctionalUtils.ignoreRemoteException(
-                                    mSatelliteEnabledRequest.callback::accept));
-                    mSatelliteEnabledRequest = null;
-                    mNetworkSelectionModeAutoDialog.dismiss();
-                    mNetworkSelectionModeAutoDialog = null;
-                }
+        if (mFeatureFlags.carrierRoamingNbIotNtn()) {
+            RequestSatelliteEnabledArgument enabledRequest = getSatelliteEnabledRequest();
+            if (enabledRequest != null && mNetworkSelectionModeAutoDialog != null
+                    && mNetworkSelectionModeAutoDialog.isShowing()
+                    && request.isEmergency && request.enableSatellite) {
+                sendErrorAndReportSessionMetrics(
+                        SatelliteManager.SATELLITE_RESULT_ILLEGAL_STATE,
+                        FunctionalUtils.ignoreRemoteException(enabledRequest.callback::accept));
+                setSatelliteEnabledRequest(null);
+                mNetworkSelectionModeAutoDialog.dismiss();
+                mNetworkSelectionModeAutoDialog = null;
+            }
+        }
+        if (!isSatelliteEnabledRequestInProgress()) {
+            if (isSatelliteEnabled != null && isSatelliteEnabled == enableSatellite) {
+                evaluateToUpdateSatelliteEnabledAttributes(result,
+                        SatelliteManager.SATELLITE_RESULT_SUCCESS, request,
+                        mIsDemoModeEnabled.get(), mIsEmergency.get());
+                return;
             }
-            if (!isSatelliteEnabledRequestInProgress()) {
-                if (isSatelliteEnabled != null && isSatelliteEnabled == enableSatellite) {
-                    evaluateToUpdateSatelliteEnabledAttributes(result,
-                            SatelliteManager.SATELLITE_RESULT_SUCCESS, request,
-                            mIsDemoModeEnabled, mIsEmergency);
-                    return;
-                }
 
-                if (enableSatellite) {
-                    mSatelliteEnabledRequest = request;
-                } else {
-                    mSatelliteDisabledRequest = request;
-                }
-            } else if (isSatelliteBeingDisabled()) {
-                int resultCode = SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS;
-                if (enableSatellite) {
-                    plogw("requestSatelliteEnabled: The enable request cannot be "
-                            + "processed since disable satellite is in progress.");
-                    resultCode = SatelliteManager.SATELLITE_RESULT_DISABLE_IN_PROGRESS;
+            if (enableSatellite) {
+                setSatelliteEnabledRequest(request);
+            } else {
+                setSatelliteDisabledRequest(request);
+            }
+        } else if (isSatelliteBeingDisabled()) {
+            int resultCode = SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS;
+            if (enableSatellite) {
+                plogw("requestSatelliteEnabled: The enable request cannot be "
+                        + "processed since disable satellite is in progress.");
+                resultCode = SatelliteManager.SATELLITE_RESULT_DISABLE_IN_PROGRESS;
+            } else {
+                plogd("requestSatelliteEnabled: Disable is already in progress.");
+            }
+            sendErrorAndReportSessionMetrics(resultCode, result);
+            return;
+        } else {
+            // Satellite is being enabled or satellite enable attributes are being updated
+            if (enableSatellite) {
+                if (getSatelliteEnableAttributesUpdateRequest() == null) {
+                    /* Satellite is being enabled and framework receive a new enable request to
+                     * update the enable attributes.
+                     */
+                    evaluateToUpdateSatelliteEnabledAttributes(result,
+                            SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS,
+                            request, getSatelliteEnabledRequest().enableDemoMode,
+                            getSatelliteEnabledRequest().isEmergency);
                 } else {
-                    plogd("requestSatelliteEnabled: Disable is already in progress.");
+                    /* The enable attributes update request is already being processed.
+                     * Framework can't handle one more request to update enable attributes.
+                     */
+                    plogd("requestSatelliteEnabled: enable attributes update request is already"
+                            + " in progress.");
+                    sendErrorAndReportSessionMetrics(
+                            SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS, result);
                 }
-                sendErrorAndReportSessionMetrics(resultCode, result);
                 return;
             } else {
-                // Satellite is being enabled or satellite enable attributes are being updated
-                if (enableSatellite) {
-                    if (mSatelliteEnableAttributesUpdateRequest == null) {
-                        /* Satellite is being enabled and framework receive a new enable request to
-                         * update the enable attributes.
-                         */
-                        evaluateToUpdateSatelliteEnabledAttributes(result,
-                                SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS,
-                                request, mSatelliteEnabledRequest.enableDemoMode,
-                                mSatelliteEnabledRequest.isEmergency);
-                    } else {
-                        /* The enable attributes update request is already being processed.
-                         * Framework can't handle one more request to update enable attributes.
-                         */
-                        plogd("requestSatelliteEnabled: enable attributes update request is already"
-                                + " in progress.");
-                        sendErrorAndReportSessionMetrics(
-                                SatelliteManager.SATELLITE_RESULT_REQUEST_IN_PROGRESS, result);
-                    }
+                /* Users might want to end the satellite session while it is being enabled, or
+                 * the satellite session need to be disabled for an emergency call. Note: some
+                 * carriers want to disable satellite for prioritizing emergency calls. Thus,
+                 * we need to push the disable request to modem while enable is in progress.
+                 */
+                if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
+                    plogd("requestSatelliteEnabled: carrierRoamingNbIotNtn flag is disabled");
+                    sendErrorAndReportSessionMetrics(
+                            SatelliteManager.SATELLITE_RESULT_ENABLE_IN_PROGRESS, result);
+                    return;
+                }
+                if (!isDisableSatelliteWhileEnableInProgressSupported()) {
+                    plogd("requestSatelliteEnabled: disable satellite while enable in progress"
+                            + " is not supported");
+                    sendErrorAndReportSessionMetrics(
+                            SatelliteManager.SATELLITE_RESULT_ENABLE_IN_PROGRESS, result);
                     return;
-                } else {
-                    /* Users might want to end the satellite session while it is being enabled, or
-                     * the satellite session need to be disabled for an emergency call. Note: some
-                     * carriers want to disable satellite for prioritizing emergency calls. Thus,
-                     * we need to push the disable request to modem while enable is in progress.
-                     */
-                    if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
-                        plogd("requestSatelliteEnabled: carrierRoamingNbIotNtn flag is disabled");
-                        sendErrorAndReportSessionMetrics(
-                                SatelliteManager.SATELLITE_RESULT_ENABLE_IN_PROGRESS, result);
-                        return;
-                    }
-                    if (!isDisableSatelliteWhileEnableInProgressSupported()) {
-                        plogd("requestSatelliteEnabled: disable satellite while enable in progress"
-                                + " is not supported");
-                        sendErrorAndReportSessionMetrics(
-                                SatelliteManager.SATELLITE_RESULT_ENABLE_IN_PROGRESS, result);
-                        return;
-                    }
-                    mSatelliteDisabledRequest = request;
                 }
+                setSatelliteDisabledRequest(request);
             }
         }
 
@@ -2535,7 +2854,7 @@ public class SatelliteController extends Handler {
 
     private boolean isDisableSatelliteWhileEnableInProgressSupported() {
         if (mOverriddenDisableSatelliteWhileEnableInProgressSupported != null) {
-            return mOverriddenDisableSatelliteWhileEnableInProgressSupported;
+            return mOverriddenDisableSatelliteWhileEnableInProgressSupported.get();
         }
         return mContext.getResources().getBoolean(
             R.bool.config_support_disable_satellite_while_enable_in_progress);
@@ -2585,18 +2904,14 @@ public class SatelliteController extends Handler {
                     })
                     .setNegativeButton(cancel, (dialog, which) -> {
                         logd("checkNetworkSelectionModeAuto: setNegativeButton");
-                        synchronized (mSatelliteEnabledRequestLock) {
-                            mSatelliteEnabledRequest = null;
-                        }
+                        setSatelliteEnabledRequest(null);
                         sendErrorAndReportSessionMetrics(
                                 SatelliteManager.SATELLITE_RESULT_ILLEGAL_STATE,
                                 FunctionalUtils.ignoreRemoteException(argument.callback::accept));
                     })
                     .setOnCancelListener(dialog -> {
                         logd("checkNetworkSelectionModeAuto: setOnCancelListener");
-                        synchronized (mSatelliteEnabledRequestLock) {
-                            mSatelliteEnabledRequest = null;
-                        }
+                        setSatelliteEnabledRequest(null);
                         sendErrorAndReportSessionMetrics(
                                 SatelliteManager.SATELLITE_RESULT_ILLEGAL_STATE,
                                 FunctionalUtils.ignoreRemoteException(argument.callback::accept));
@@ -2648,9 +2963,7 @@ public class SatelliteController extends Handler {
         }
 
         if (needToReconfigureModem) {
-            synchronized (mSatelliteEnabledRequestLock) {
-                mSatelliteEnableAttributesUpdateRequest = enableRequest;
-            }
+            setSatelliteEnableAttributesUpdateRequest(enableRequest);
             sendRequestAsync(
                     CMD_UPDATE_SATELLITE_ENABLE_ATTRIBUTES, enableRequest, null);
         } else {
@@ -2667,14 +2980,16 @@ public class SatelliteController extends Handler {
      * request is in progress, {@code false} otherwise.
      */
     private boolean isSatelliteEnabledRequestInProgress() {
-        synchronized (mSatelliteEnabledRequestLock) {
-            plogd("mSatelliteEnabledRequest: " + (mSatelliteEnabledRequest != null)
-                    + ", mSatelliteDisabledRequest: " + (mSatelliteDisabledRequest != null)
-                    + ", mSatelliteEnableAttributesUpdateRequest: "
-                    + (mSatelliteEnableAttributesUpdateRequest != null));
-            return (mSatelliteEnabledRequest != null || mSatelliteDisabledRequest != null
-                    || mSatelliteEnableAttributesUpdateRequest != null);
-        }
+        RequestSatelliteEnabledArgument enabledRequest = getSatelliteEnabledRequest();
+        RequestSatelliteEnabledArgument disabledRequest = getSatelliteDisabledRequest();
+        RequestSatelliteEnabledArgument enableAttributesUpdateRequest =
+                getSatelliteEnableAttributesUpdateRequest();
+        plogd("mSatelliteEnabledRequest: " + (enabledRequest != null)
+                + ", mSatelliteDisabledRequest: " + (disabledRequest != null)
+                + ", mSatelliteEnableAttributesUpdateRequest: "
+                + (enableAttributesUpdateRequest != null));
+        return (enabledRequest != null || disabledRequest != null
+                || enableAttributesUpdateRequest != null);
     }
 
     /**
@@ -2684,6 +2999,18 @@ public class SatelliteController extends Handler {
      *               if the request is successful or an error code if the request failed.
      */
     public void requestIsSatelliteEnabled(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_IS_SATELLITE_ENABLED, args));
+            return;
+        }
+
+        handleRequestIsSatelliteEnabled(result);
+    }
+
+    private void handleRequestIsSatelliteEnabled(@NonNull ResultReceiver result) {
+        plogd("handleRequestIsSatelliteEnabled");
         int error = evaluateOemSatelliteRequestAllowed(false);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
@@ -2710,10 +3037,8 @@ public class SatelliteController extends Handler {
      * @return {@code true} if the satellite modem is enabled and {@code false} otherwise.
      */
     public boolean isSatelliteEnabled() {
-        synchronized (mIsSatelliteEnabledLock) {
-            if (mIsSatelliteEnabled == null) return false;
-            return mIsSatelliteEnabled;
-        }
+        if (mIsSatelliteEnabled == null) return false;
+        return mIsSatelliteEnabled.get();
     }
 
     /**
@@ -2727,9 +3052,7 @@ public class SatelliteController extends Handler {
             return true;
         }
 
-        synchronized (mSatelliteEnabledRequestLock) {
-            return (mSatelliteEnabledRequest != null);
-        }
+        return (getSatelliteEnabledRequest() != null);
     }
 
     /**
@@ -2754,9 +3077,7 @@ public class SatelliteController extends Handler {
             return true;
         }
 
-        synchronized (mSatelliteEnabledRequestLock) {
-            return (mSatelliteDisabledRequest != null);
-        }
+        return (getSatelliteDisabledRequest() != null);
     }
 
     /**
@@ -2766,6 +3087,18 @@ public class SatelliteController extends Handler {
      *               if the request is successful or an error code if the request failed.
      */
     public void requestIsDemoModeEnabled(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_IS_DEMO_MODE_ENABLED, args));
+            return;
+        }
+
+        handleRequestIsDemoModeEnabled(result);
+    }
+
+    private void handleRequestIsDemoModeEnabled(@NonNull ResultReceiver result) {
+        plogd("handleRequestIsDemoModeEnabled");
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
@@ -2773,7 +3106,7 @@ public class SatelliteController extends Handler {
         }
 
         final Bundle bundle = new Bundle();
-        bundle.putBoolean(SatelliteManager.KEY_DEMO_MODE_ENABLED, mIsDemoModeEnabled);
+        bundle.putBoolean(SatelliteManager.KEY_DEMO_MODE_ENABLED, mIsDemoModeEnabled.get());
         result.send(SATELLITE_RESULT_SUCCESS, bundle);
     }
 
@@ -2783,7 +3116,7 @@ public class SatelliteController extends Handler {
      * @return {@code true} if the satellite demo mode is enabled and {@code false} otherwise.
      */
     public boolean isDemoModeEnabled() {
-        return mIsDemoModeEnabled;
+        return mIsDemoModeEnabled.get();
     }
 
     /**
@@ -2793,12 +3126,22 @@ public class SatelliteController extends Handler {
      *               if the request is successful or an error code if the request failed.
      */
     public void requestIsEmergencyModeEnabled(@NonNull ResultReceiver result) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            Bundle bundle = new Bundle();
-            bundle.putBoolean(SatelliteManager.KEY_EMERGENCY_MODE_ENABLED,
-                    getRequestIsEmergency());
-            result.send(SATELLITE_RESULT_SUCCESS, bundle);
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_IS_EMERGENCY_MODE_ENABLED, args));
+            return;
         }
+
+        handleRequestIsEmergencyModeEnabled(result);
+    }
+
+    private void handleRequestIsEmergencyModeEnabled(@NonNull ResultReceiver result) {
+        plogd("handleRequestIsEmergencyModeEnabled");
+        Bundle bundle = new Bundle();
+        bundle.putBoolean(SatelliteManager.KEY_EMERGENCY_MODE_ENABLED,
+                getRequestIsEmergency());
+        result.send(SATELLITE_RESULT_SUCCESS, bundle);
     }
 
     /**
@@ -2808,6 +3151,18 @@ public class SatelliteController extends Handler {
      *               the device if the request is successful or an error code if the request failed.
      */
     public void requestIsSatelliteSupported(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_IS_SATELLITE_SUPPORTED, args));
+            return;
+        }
+
+        handleRequestIsSatelliteSupported(result);
+    }
+
+    private void handleRequestIsSatelliteSupported(@NonNull ResultReceiver result) {
+        plogd("handleRequestIsSatelliteSupported");
         int subId = getSelectedSatelliteSubId();
         Boolean isSatelliteSupported = getIsSatelliteSupported();
         if (isSatelliteSupported != null) {
@@ -2829,6 +3184,18 @@ public class SatelliteController extends Handler {
      *               if the request is successful or an error code if the request failed.
      */
     public void requestSatelliteCapabilities(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_SATELLITE_CAPABILITIES, args));
+            return;
+        }
+
+        handleRequestSatelliteCapabilities(result);
+    }
+
+    private void handleRequestSatelliteCapabilities(@NonNull ResultReceiver result) {
+        plogd("handleRequestSatelliteCapabilities");
         int error = evaluateOemSatelliteRequestAllowed(false);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
@@ -2858,6 +3225,21 @@ public class SatelliteController extends Handler {
     public void startSatelliteTransmissionUpdates(
             @NonNull IIntegerConsumer errorCallback,
             @NonNull ISatelliteTransmissionUpdateCallback callback) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = errorCallback;
+            args.arg2 = callback;
+            sendMessage(obtainMessage(REQUEST_START_SATELLITE_TRANSMISSION_UPDATES, args));
+            return;
+        }
+
+        handleRequestStartSatelliteTransmissionUpdates(errorCallback, callback);
+    }
+
+    private void handleRequestStartSatelliteTransmissionUpdates(
+            @NonNull IIntegerConsumer errorCallback,
+            @NonNull ISatelliteTransmissionUpdateCallback callback) {
+        plogd("handleRequestStartSatelliteTransmissionUpdates");
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(errorCallback::accept);
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
@@ -2881,6 +3263,21 @@ public class SatelliteController extends Handler {
      */
     public void stopSatelliteTransmissionUpdates(@NonNull IIntegerConsumer errorCallback,
             @NonNull ISatelliteTransmissionUpdateCallback callback) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = errorCallback;
+            args.arg2 = callback;
+            sendMessage(obtainMessage(REQUEST_STOP_SATELLITE_TRANSMISSION_UPDATES, args));
+            return;
+        }
+
+        handleRequestStopSatelliteTransmissionUpdates(errorCallback, callback);
+    }
+
+    private void handleRequestStopSatelliteTransmissionUpdates(
+            @NonNull IIntegerConsumer errorCallback,
+            @NonNull ISatelliteTransmissionUpdateCallback callback) {
+        plogd("handleRequestStopSatelliteTransmissionUpdates");
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(errorCallback::accept);
         mPointingAppController.unregisterForSatelliteTransmissionUpdates(
                 getSelectedSatelliteSubId(), result, callback);
@@ -3027,11 +3424,8 @@ public class SatelliteController extends Handler {
         } catch (RemoteException ex) {
             loge("registerForSatelliteProvisionStateChanged: " + ex);
         }
-        synchronized (mDeviceProvisionLock) {
-            plogd("registerForSatelliteProvisionStateChanged: report current provisioned "
-                    + "state, state=" + isProvisioned);
-        }
-
+        plogd("registerForSatelliteProvisionStateChanged: report current provisioned "
+                + "state, state=" + isProvisioned);
         return SATELLITE_RESULT_SUCCESS;
     }
 
@@ -3055,20 +3449,30 @@ public class SatelliteController extends Handler {
      *               request failed.
      */
     public void requestIsSatelliteProvisioned(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_IS_SATELLITE_PROVISIONED, args));
+            return;
+        }
+
+        handleRequestIsSatelliteProvisioned(result);
+    }
+
+    private void handleRequestIsSatelliteProvisioned(@NonNull ResultReceiver result) {
+        plogd("handleRequestIsSatelliteProvisioned");
         int error = evaluateOemSatelliteRequestAllowed(false);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
             return;
         }
 
-        synchronized (mDeviceProvisionLock) {
-            if (mIsDeviceProvisioned != null) {
-                Bundle bundle = new Bundle();
-                bundle.putBoolean(SatelliteManager.KEY_SATELLITE_PROVISIONED,
-                        mIsDeviceProvisioned);
-                result.send(SATELLITE_RESULT_SUCCESS, bundle);
-                return;
-            }
+        if (mIsDeviceProvisioned != null) {
+            Bundle bundle = new Bundle();
+            bundle.putBoolean(SatelliteManager.KEY_SATELLITE_PROVISIONED,
+                    mIsDeviceProvisioned.get());
+            result.send(SATELLITE_RESULT_SUCCESS, bundle);
+            return;
         }
 
         sendRequestAsync(CMD_IS_SATELLITE_PROVISIONED, result, null);
@@ -3166,6 +3570,18 @@ public class SatelliteController extends Handler {
      * @param callback The callback to get {@link SatelliteManager.SatelliteResult} of the request.
      */
     public void pollPendingDatagrams(@NonNull IIntegerConsumer callback) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = callback;
+            sendMessage(obtainMessage(REQUEST_POLL_PENDING_DATAGRAMS, args));
+            return;
+        }
+
+        handleRequestPollPendingDatagrams(callback);
+    }
+
+    private void handleRequestPollPendingDatagrams(@NonNull IIntegerConsumer callback) {
+        plogd("handleRequestPollPendingDatagrams");
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(callback::accept);
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
@@ -3195,6 +3611,22 @@ public class SatelliteController extends Handler {
     public void sendDatagram(@SatelliteManager.DatagramType int datagramType,
             SatelliteDatagram datagram, boolean needFullScreenPointingUI,
             @NonNull IIntegerConsumer callback) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = datagramType;
+            args.arg2 = datagram;
+            args.arg3 = needFullScreenPointingUI;
+            args.arg4 = callback;
+            sendMessage(obtainMessage(REQUEST_SEND_DATAGRAM, args));
+            return;
+        }
+
+        handleRequestSendDatagram(datagramType, datagram, needFullScreenPointingUI, callback);
+    }
+
+    private void handleRequestSendDatagram(@SatelliteManager.DatagramType int datagramType,
+            SatelliteDatagram datagram, boolean needFullScreenPointingUI,
+            @NonNull IIntegerConsumer callback) {
         plogd("sendSatelliteDatagram: datagramType: " + datagramType
                 + " needFullScreenPointingUI: " + needFullScreenPointingUI);
 
@@ -3208,10 +3640,9 @@ public class SatelliteController extends Handler {
         /**
          * TODO for NTN-based satellites: Check if satellite is acquired.
          */
-        if (mNeedsSatellitePointing) {
-
-            mPointingAppController.startPointingUI(needFullScreenPointingUI, mIsDemoModeEnabled,
-                    mIsEmergency);
+        if (mNeedsSatellitePointing.get()) {
+            mPointingAppController.startPointingUI(needFullScreenPointingUI,
+                    mIsDemoModeEnabled.get(), mIsEmergency.get());
         }
 
         mDatagramController.sendSatelliteDatagram(getSelectedSatelliteSubId(), datagramType,
@@ -3225,6 +3656,18 @@ public class SatelliteController extends Handler {
      *               be visible if the request is successful or an error code if the request failed.
      */
     public void requestTimeForNextSatelliteVisibility(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_TIME_FOR_NEXT_SATELLITE_VISIBILITY, args));
+            return;
+        }
+
+        handleRequestTimeForNextSatelliteVisibility(result);
+    }
+
+    private void handleRequestTimeForNextSatelliteVisibility(@NonNull ResultReceiver result) {
+        plogd("handleRequestTimeForNextSatelliteVisibility");
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
@@ -3241,6 +3684,18 @@ public class SatelliteController extends Handler {
      * @param isAligned {@true} means device is aligned with the satellite, otherwise {@false}.
      */
     public void setDeviceAlignedWithSatellite(@NonNull boolean isAligned) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = isAligned;
+            sendMessage(obtainMessage(REQUEST_SET_DEVICE_ALIGNED_WITH_SATELLITE, args));
+            return;
+        }
+
+        handleRequestSetDeviceAlignedWithSatellite(isAligned);
+    }
+
+    private void handleRequestSetDeviceAlignedWithSatellite(boolean isAligned) {
+        plogd("handleSetDeviceAlignedWithSatellite: isAligned=" + isAligned);
         DemoSimulator.getInstance().setDeviceAlignedWithSatellite(isAligned);
         mDatagramController.setDeviceAlignedWithSatellite(isAligned);
         if (mSatelliteSessionController != null) {
@@ -3265,18 +3720,35 @@ public class SatelliteController extends Handler {
             @SatelliteManager.SatelliteCommunicationRestrictionReason int reason,
             @NonNull IIntegerConsumer callback) {
         logd("addAttachRestrictionForCarrier(" + subId + ", " + reason + ")");
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = subId;
+            args.arg2 = reason;
+            args.arg3 = callback;
+            sendMessage(obtainMessage(REQUEST_ADD_ATTACH_RESTRICTION_FOR_CARRIER, args));
+            return;
+        }
+
+        handleRequestAddAttachRestrictionForCarrier(subId, reason, callback);
+    }
+
+    private void handleRequestAddAttachRestrictionForCarrier(int subId,
+            @SatelliteManager.SatelliteCommunicationRestrictionReason int reason,
+            @NonNull IIntegerConsumer callback) {
+        plogd("handleRequestAddAttachRestrictionForCarrier: subId=" + subId + " reason=" + reason);
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(callback::accept);
 
-        synchronized (mIsSatelliteEnabledLock) {
-            if (mSatelliteAttachRestrictionForCarrierArray.getOrDefault(
-                    subId, Collections.emptySet()).isEmpty()) {
-                mSatelliteAttachRestrictionForCarrierArray.put(subId, new HashSet<>());
-            } else if (mSatelliteAttachRestrictionForCarrierArray.get(subId).contains(reason)) {
-                result.accept(SATELLITE_RESULT_SUCCESS);
-                return;
-            }
-            mSatelliteAttachRestrictionForCarrierArray.get(subId).add(reason);
+        if (mSatelliteAttachRestrictionForCarrierArray.getOrDefault(
+                subId, Collections.emptySet()).isEmpty()) {
+            mSatelliteAttachRestrictionForCarrierArray.put(subId, new HashSet<>());
+        } else if (mSatelliteAttachRestrictionForCarrierArray.get(subId).contains(reason)) {
+            result.accept(SATELLITE_RESULT_SUCCESS);
+            return;
         }
+        mSatelliteAttachRestrictionForCarrierArray.get(subId).add(reason);
+        plogd("handleRequestAddAttachRestrictionForCarrier: subId=" + subId
+                + ", reasons=" + mSatelliteAttachRestrictionForCarrierArray.get(subId));
+
         RequestHandleSatelliteAttachRestrictionForCarrierArgument request =
                 new RequestHandleSatelliteAttachRestrictionForCarrierArgument(subId, reason,
                         result);
@@ -3298,17 +3770,35 @@ public class SatelliteController extends Handler {
             @SatelliteManager.SatelliteCommunicationRestrictionReason int reason,
             @NonNull IIntegerConsumer callback) {
         logd("removeAttachRestrictionForCarrier(" + subId + ", " + reason + ")");
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = subId;
+            args.arg2 = reason;
+            args.arg3 = callback;
+            sendMessage(obtainMessage(REQUEST_REMOVE_ATTACH_RESTRICTION_FOR_CARRIER, args));
+            return;
+        }
+
+        handleRequestRemoveAttachRestrictionForCarrier(subId, reason, callback);
+    }
+
+    private void handleRequestRemoveAttachRestrictionForCarrier(int subId,
+            @SatelliteManager.SatelliteCommunicationRestrictionReason int reason,
+            @NonNull IIntegerConsumer callback) {
+        plogd("handleRequestRemoveAttachRestrictionForCarrier: subId=" + subId
+                + " reason=" + reason);
         Consumer<Integer> result = FunctionalUtils.ignoreRemoteException(callback::accept);
 
-        synchronized (mIsSatelliteEnabledLock) {
-            if (mSatelliteAttachRestrictionForCarrierArray.getOrDefault(
-                    subId, Collections.emptySet()).isEmpty()
-                    || !mSatelliteAttachRestrictionForCarrierArray.get(subId).contains(reason)) {
-                result.accept(SATELLITE_RESULT_SUCCESS);
-                return;
-            }
-            mSatelliteAttachRestrictionForCarrierArray.get(subId).remove(reason);
+        if (mSatelliteAttachRestrictionForCarrierArray.getOrDefault(
+                subId, Collections.emptySet()).isEmpty()
+                || !mSatelliteAttachRestrictionForCarrierArray.get(subId).contains(reason)) {
+            result.accept(SATELLITE_RESULT_SUCCESS);
+            return;
         }
+        mSatelliteAttachRestrictionForCarrierArray.get(subId).remove(reason);
+        plogd("handleRequestRemoveAttachRestrictionForCarrier: subId=" + subId
+                + ", reasons=" + mSatelliteAttachRestrictionForCarrierArray.get(subId));
+
         RequestHandleSatelliteAttachRestrictionForCarrierArgument request =
                 new RequestHandleSatelliteAttachRestrictionForCarrierArgument(subId, reason,
                         result);
@@ -3325,14 +3815,12 @@ public class SatelliteController extends Handler {
      * @return Set of reasons for disallowing satellite attach for carrier.
      */
     @NonNull public Set<Integer> getAttachRestrictionReasonsForCarrier(int subId) {
-        synchronized (mIsSatelliteEnabledLock) {
-            Set<Integer> resultSet =
-                    mSatelliteAttachRestrictionForCarrierArray.get(subId);
-            if (resultSet == null) {
-                return new HashSet<>();
-            }
-            return new HashSet<>(resultSet);
+        Set<Integer> resultSet =
+                mSatelliteAttachRestrictionForCarrierArray.get(subId);
+        if (resultSet == null) {
+            return new HashSet<>();
         }
+        return new HashSet<>(resultSet);
     }
 
     /**
@@ -3344,6 +3832,18 @@ public class SatelliteController extends Handler {
     public void requestNtnSignalStrength(@NonNull ResultReceiver result) {
         if (DBG) plogd("requestNtnSignalStrength()");
 
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_NTN_SIGNAL_STRENGTH, args));
+            return;
+        }
+
+        handleRequestNtnSignalStrength(result);
+    }
+
+    private void handleRequestNtnSignalStrength(@NonNull ResultReceiver result) {
+        plogd("handleRequestNtnSignalStrength");
         int error = evaluateOemSatelliteRequestAllowed(true);
         if (error != SATELLITE_RESULT_SUCCESS) {
             result.send(error, null);
@@ -3352,13 +3852,12 @@ public class SatelliteController extends Handler {
 
         /* In case cache is available, it is not needed to request non-terrestrial signal strength
         to modem */
-        synchronized (mNtnSignalsStrengthLock) {
-            if (mNtnSignalStrength.getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
-                Bundle bundle = new Bundle();
-                bundle.putParcelable(KEY_NTN_SIGNAL_STRENGTH, mNtnSignalStrength);
-                result.send(SATELLITE_RESULT_SUCCESS, bundle);
-                return;
-            }
+        NtnSignalStrength ntnSignalStrength = getNtnSignalStrength();
+        if (ntnSignalStrength.getLevel() != NTN_SIGNAL_STRENGTH_NONE) {
+            Bundle bundle = new Bundle();
+            bundle.putParcelable(KEY_NTN_SIGNAL_STRENGTH, ntnSignalStrength);
+            result.send(SATELLITE_RESULT_SUCCESS, bundle);
+            return;
         }
 
         Phone phone = SatelliteServiceUtils.getPhone();
@@ -3386,14 +3885,13 @@ public class SatelliteController extends Handler {
         int error = evaluateOemSatelliteRequestAllowed(false);
         if (error == SATELLITE_RESULT_SUCCESS) {
             mNtnSignalStrengthChangedListeners.put(callback.asBinder(), callback);
-            synchronized (mNtnSignalsStrengthLock) {
-                try {
-                    callback.onNtnSignalStrengthChanged(mNtnSignalStrength);
-                    plogd("registerForNtnSignalStrengthChanged: " + mNtnSignalStrength);
-                } catch (RemoteException ex) {
-                    ploge("registerForNtnSignalStrengthChanged: RemoteException ex="
-                            + ex);
-                }
+            NtnSignalStrength ntnSignalStrength = getNtnSignalStrength();
+            try {
+                callback.onNtnSignalStrengthChanged(ntnSignalStrength);
+                plogd("registerForNtnSignalStrengthChanged: " + ntnSignalStrength);
+            } catch (RemoteException ex) {
+                ploge("registerForNtnSignalStrengthChanged: RemoteException ex="
+                        + ex);
             }
         } else {
             throw new RemoteException(new IllegalStateException("registration fails: " + error));
@@ -3542,15 +4040,9 @@ public class SatelliteController extends Handler {
         // Cached states need to be cleared whenever switching satellite vendor services.
         plogd("setSatelliteServicePackageName: Resetting cached states, provisioned="
                 + provisioned);
-        synchronized (mIsSatelliteSupportedLock) {
-            mIsSatelliteSupported = null;
-        }
-        synchronized (mIsSatelliteEnabledLock) {
-            mIsSatelliteEnabled = null;
-        }
-        synchronized (mSatelliteCapabilitiesLock) {
-            mSatelliteCapabilities = null;
-        }
+        mIsSatelliteSupported = null;
+        mIsSatelliteEnabled = null;
+        setSatelliteCapabilities(null);
         mSatelliteModemInterface.setSatelliteServicePackageName(servicePackageName);
         return true;
     }
@@ -3625,8 +4117,26 @@ public class SatelliteController extends Handler {
         if (reset) {
             mOverriddenDisableSatelliteWhileEnableInProgressSupported = null;
         } else {
-            mOverriddenDisableSatelliteWhileEnableInProgressSupported = supported;
+            mOverriddenDisableSatelliteWhileEnableInProgressSupported =
+                    new AtomicBoolean(supported);
+        }
+        return true;
+    }
+
+    /**
+     * This API can be used by only CTS to control the max allowed data mode.
+     *
+     * @param maxAllowedDataMode The max allowed data mode.
+     * @return {@code true} if the value is set successfully, {@code false} otherwise.
+     */
+    public boolean setMaxAllowedDataModeForCtsTest(int maxAllowedDataMode) {
+        if (!isMockModemAllowed()) {
+            plogd("setMaxAllowedDataModeForCtsTest: mock modem not allowed");
+            return false;
         }
+
+        plogd("setMaxAllowedDataModeForCtsTest - maxAllowedDataMode=" + maxAllowedDataMode);
+        mMaxAllowedDataModeForCtsTest.set(maxAllowedDataMode);
         return true;
     }
 
@@ -3677,33 +4187,40 @@ public class SatelliteController extends Handler {
                 + timeoutType + ", timeoutMillis=" + timeoutMillis);
         if (timeoutType == TIMEOUT_TYPE_WAIT_FOR_SATELLITE_ENABLING_RESPONSE) {
             if (reset) {
-                mWaitTimeForSatelliteEnablingResponse =
-                        getWaitForSatelliteEnablingResponseTimeoutMillis();
+                mWaitTimeForSatelliteEnablingResponse.set(
+                        getWaitForSatelliteEnablingResponseTimeoutMillis());
             } else {
-                mWaitTimeForSatelliteEnablingResponse = timeoutMillis;
+                mWaitTimeForSatelliteEnablingResponse.set(timeoutMillis);
             }
-            plogd("mWaitTimeForSatelliteEnablingResponse=" + mWaitTimeForSatelliteEnablingResponse);
+            plogd("mWaitTimeForSatelliteEnablingResponse="
+                    + mWaitTimeForSatelliteEnablingResponse.get());
         } else if (timeoutType == TIMEOUT_TYPE_DEMO_POINTING_ALIGNED_DURATION_MILLIS) {
             if (reset) {
-                mDemoPointingAlignedDurationMillis =
-                        getDemoPointingAlignedDurationMillisFromResources();
+                mDemoPointingAlignedDurationMillis.set(
+                        getDemoPointingAlignedDurationMillisFromResources());
             } else {
-                mDemoPointingAlignedDurationMillis = timeoutMillis;
+                mDemoPointingAlignedDurationMillis.set(timeoutMillis);
             }
         } else if (timeoutType == TIMEOUT_TYPE_DEMO_POINTING_NOT_ALIGNED_DURATION_MILLIS) {
             if (reset) {
-                mDemoPointingNotAlignedDurationMillis =
-                        getDemoPointingNotAlignedDurationMillisFromResources();
+                mDemoPointingNotAlignedDurationMillis.set(
+                        getDemoPointingNotAlignedDurationMillisFromResources());
             } else {
-                mDemoPointingNotAlignedDurationMillis = timeoutMillis;
+                mDemoPointingNotAlignedDurationMillis.set(timeoutMillis);
             }
         } else if (timeoutType
                 == TIMEOUT_TYPE_EVALUATE_ESOS_PROFILES_PRIORITIZATION_DURATION_MILLIS) {
             if (reset) {
-                mEvaluateEsosProfilesPrioritizationDurationMillis =
-                        getEvaluateEsosProfilesPrioritizationDurationMillis();
+                mEvaluateEsosProfilesPrioritizationDurationMillis.set(
+                        getEvaluateEsosProfilesPrioritizationDurationMillis());
+            } else {
+                mEvaluateEsosProfilesPrioritizationDurationMillis.set(timeoutMillis);
+            }
+        } else if (timeoutType == TIMEOUT_TYPE_EMERGENCY_CALL_MONITORING_DURATION_MILLIS) {
+            if (reset) {
+                mEmergencyCallMonitoringDurationMillisForCtsTest.set(0);
             } else {
-                mEvaluateEsosProfilesPrioritizationDurationMillis = timeoutMillis;
+                mEmergencyCallMonitoringDurationMillisForCtsTest.set(timeoutMillis);
             }
         } else {
             plogw("Invalid timeoutType=" + timeoutType);
@@ -3720,10 +4237,24 @@ public class SatelliteController extends Handler {
      * {@code false} otherwise.
      */
     public boolean setSatelliteGatewayServicePackageName(@Nullable String servicePackageName) {
+        if (!isMockModemAllowed()) {
+            plogd("setSatelliteGatewayServicePackageName: mock modem is not allowed");
+            return false;
+        }
         if (mSatelliteSessionController == null) {
             ploge("mSatelliteSessionController is not initialized yet");
             return false;
         }
+
+        if (servicePackageName == null || servicePackageName.equals("null")) {
+            mOverriddenSatelliteGatewayServicePackageName = null;
+        } else {
+            mOverriddenSatelliteGatewayServicePackageName = servicePackageName;
+        }
+        plogd("setSatelliteGatewayServicePackageName: "
+                + "mOverriddenSatelliteGatewayServicePackageName="
+                + mOverriddenSatelliteGatewayServicePackageName);
+
         return mSatelliteSessionController.setSatelliteGatewayServicePackageName(
                 servicePackageName);
     }
@@ -3752,20 +4283,24 @@ public class SatelliteController extends Handler {
      *                     To disable the override, use -1 for handoverType.
      * @param delaySeconds The event EVENT_DISPLAY_EMERGENCY_MESSAGE will be sent to Dialer
      *                     delaySeconds after the emergency call starts.
+     * @param simSlotId The SIM slot ID to use for loading T911 conversation thread.
      * @return {@code true} if the handover type is set successfully, {@code false} otherwise.
      */
-    public boolean setEmergencyCallToSatelliteHandoverType(int handoverType, int delaySeconds) {
+    public boolean setEmergencyCallToSatelliteHandoverType(
+        int handoverType, int delaySeconds, int simSlotId) {
         if (!isMockModemAllowed()) {
             ploge("setEmergencyCallToSatelliteHandoverType: mock modem not allowed");
             return false;
         }
         if (isHandoverTypeValid(handoverType)) {
-            mEnforcedEmergencyCallToSatelliteHandoverType = handoverType;
-            mDelayInSendingEventDisplayEmergencyMessage = delaySeconds > 0 ? delaySeconds : 0;
+            mEnforcedEmergencyCallToSatelliteHandoverType.set(handoverType);
+            mDelayInSendingEventDisplayEmergencyMessage.set(delaySeconds > 0 ? delaySeconds : 0);
+            mSimSlotIdForLaunchingT911ConversationThread.set(simSlotId);
         } else {
-            mEnforcedEmergencyCallToSatelliteHandoverType =
-                    INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE;
-            mDelayInSendingEventDisplayEmergencyMessage = 0;
+            mEnforcedEmergencyCallToSatelliteHandoverType.set(
+                    INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE);
+            mDelayInSendingEventDisplayEmergencyMessage.set(0);
+            mSimSlotIdForLaunchingT911ConversationThread.set(0);
         }
         return true;
     }
@@ -3783,24 +4318,32 @@ public class SatelliteController extends Handler {
             ploge("setOemEnabledSatelliteProvisionStatus: mock modem not allowed");
             return false;
         }
-        synchronized (mDeviceProvisionLock) {
-            if (reset) {
-                mOverriddenIsSatelliteViaOemProvisioned = null;
-            } else {
-                mOverriddenIsSatelliteViaOemProvisioned = isProvisioned;
-            }
+        if (reset) {
+            mOverriddenIsSatelliteViaOemProvisioned = null;
+        } else {
+            mOverriddenIsSatelliteViaOemProvisioned = new AtomicBoolean(isProvisioned);
         }
         return true;
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     protected int getEnforcedEmergencyCallToSatelliteHandoverType() {
-        return mEnforcedEmergencyCallToSatelliteHandoverType;
+        return mEnforcedEmergencyCallToSatelliteHandoverType.get();
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     protected int getDelayInSendingEventDisplayEmergencyMessage() {
-        return mDelayInSendingEventDisplayEmergencyMessage;
+        return mDelayInSendingEventDisplayEmergencyMessage.get();
+    }
+
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected int getSimSlotIdForLaunchingT911ConversationThread() {
+        return mSimSlotIdForLaunchingT911ConversationThread.get();
+    }
+
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    protected long getEmergencyCallMonitoringDurationMillisForCtsTests() {
+        return mEmergencyCallMonitoringDurationMillisForCtsTest.get();
     }
 
     private boolean isHandoverTypeValid(int handoverType) {
@@ -3857,9 +4400,7 @@ public class SatelliteController extends Handler {
     public void onSetCellularRadioPowerStateRequested(boolean powerOn) {
         logd("onSetCellularRadioPowerStateRequested: powerOn=" + powerOn);
 
-        synchronized (mIsRadioOnLock) {
-            mRadioOffRequested = !powerOn;
-        }
+        mRadioOffRequested.set(!powerOn);
         if (powerOn) {
             stopWaitForCellularModemOffTimer();
         } else {
@@ -3884,10 +4425,8 @@ public class SatelliteController extends Handler {
      */
     public void onPowerOffCellularRadioFailed() {
         logd("onPowerOffCellularRadioFailed");
-        synchronized (mIsRadioOnLock) {
-            mRadioOffRequested = false;
-            stopWaitForCellularModemOffTimer();
-        }
+        mRadioOffRequested.set(false);
+        stopWaitForCellularModemOffTimer();
     }
 
     /**
@@ -3999,22 +4538,20 @@ public class SatelliteController extends Handler {
      */
     private List<Integer> getSatelliteSupportedServicesFromConfig(int subId, String plmn) {
         if (plmn != null && !plmn.isEmpty()) {
-            synchronized (mSupportedSatelliteServicesLock) {
-                if (mSatelliteServicesSupportedByCarriersFromConfig.containsKey(subId)) {
-                    Map<String, Set<Integer>> supportedServices =
-                            mSatelliteServicesSupportedByCarriersFromConfig.get(subId);
-                    if (supportedServices != null && supportedServices.containsKey(plmn)) {
-                        return new ArrayList<>(supportedServices.get(plmn));
-                    } else {
-                        loge("getSupportedSatelliteServices: subId=" + subId
-                                + ", supportedServices "
-                                + "does not contain key plmn=" + plmn);
-                    }
+            if (mSatelliteServicesSupportedByCarriersFromConfig.containsKey(subId)) {
+                Map<String, Set<Integer>> supportedServices =
+                        mSatelliteServicesSupportedByCarriersFromConfig.get(subId);
+                if (supportedServices != null && supportedServices.containsKey(plmn)) {
+                    return new ArrayList<>(supportedServices.get(plmn));
                 } else {
-                    loge("getSupportedSatelliteServices: "
-                            + "mSatelliteServicesSupportedByCarriersFromConfig does not contain"
-                            + " key subId=" + subId);
+                    loge("getSupportedSatelliteServices: subId=" + subId
+                            + ", supportedServices "
+                            + "does not contain key plmn=" + plmn);
                 }
+            } else {
+                loge("getSupportedSatelliteServices: "
+                        + "mSatelliteServicesSupportedByCarriersFromConfig does not contain"
+                        + " key subId=" + subId);
             }
         }
 
@@ -4049,31 +4586,28 @@ public class SatelliteController extends Handler {
             logd("getSupportedSatelliteServices: invalid sub id");
             return new ArrayList<>();
         }
-        synchronized (mSupportedSatelliteServicesLock) {
-            if (plmn != null && !plmn.isEmpty()) {
-                Map<String, List<Integer>> allowedServicesList =
-                        mEntitlementServiceTypeMapPerCarrier.get(subId);
-                if (allowedServicesList != null && allowedServicesList.containsKey(plmn)) {
-                    List<Integer> allowedServiceValues = new ArrayList<>(
-                            allowedServicesList.get(plmn));
-                    if (allowedServiceValues != null && !allowedServiceValues.isEmpty()) {
-                        if (isDataServiceUpdateRequired(subId, plmn, allowedServiceValues)) {
-                            logd("getSupportedSatelliteServices: data service added to satellite"
-                                    + " plmn");
-                            allowedServiceValues.add(NetworkRegistrationInfo.SERVICE_TYPE_DATA);
-                        }
-                        if (allowedServiceValues.contains(NetworkRegistrationInfo.SERVICE_TYPE_DATA)
-                                && isMmsServiceUpdateRequired(subId, plmn, allowedServiceValues)) {
-                            allowedServiceValues.add(NetworkRegistrationInfo.SERVICE_TYPE_MMS);
-                        }
-                        return allowedServiceValues;
+        if (plmn != null && !plmn.isEmpty()) {
+            Map<String, List<Integer>> allowedServicesList =
+                    mEntitlementServiceTypeMapPerCarrier.get(subId);
+            if (allowedServicesList != null && allowedServicesList.containsKey(plmn)) {
+                List<Integer> allowedServiceValues = new ArrayList<>(
+                        allowedServicesList.get(plmn));
+                if (allowedServiceValues != null && !allowedServiceValues.isEmpty()) {
+                    if (isDataServiceUpdateRequired(subId, plmn, allowedServiceValues)) {
+                        logd("getSupportedSatelliteServices: data service added to satellite"
+                                + " plmn");
+                        allowedServiceValues.add(NetworkRegistrationInfo.SERVICE_TYPE_DATA);
                     }
+                    if (allowedServiceValues.contains(NetworkRegistrationInfo.SERVICE_TYPE_DATA)
+                            && isMmsServiceUpdateRequired(subId, plmn, allowedServiceValues)) {
+                        allowedServiceValues.add(NetworkRegistrationInfo.SERVICE_TYPE_MMS);
+                    }
+                    return allowedServiceValues;
                 }
             }
-
-            return getSatelliteSupportedServicesFromConfig(subId, plmn);
         }
 
+        return getSatelliteSupportedServicesFromConfig(subId, plmn);
     }
 
     /**
@@ -4204,20 +4738,18 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mSatelliteConnectedLock) {
-            Long lastDisconnectedTime = mLastSatelliteDisconnectedTimesMillis.get(subId);
-            long satelliteConnectionHysteresisTime =
-                    getSatelliteConnectionHysteresisTimeMillis(subId);
-            if (lastDisconnectedTime != null
-                    && (getElapsedRealtime() - lastDisconnectedTime)
-                    <= satelliteConnectionHysteresisTime) {
-                logd("isInSatelliteModeForCarrierRoaming: " + "subId:" + subId
-                        + " is connected to satellite within hysteresis time");
-                return true;
-            } else {
-                resetCarrierRoamingSatelliteModeParams(subId);
-                return false;
-            }
+        Long lastDisconnectedTime = mLastSatelliteDisconnectedTimesMillis.get(subId);
+        long satelliteConnectionHysteresisTime =
+                getSatelliteConnectionHysteresisTimeMillis(subId);
+        if (lastDisconnectedTime != null
+                && (getElapsedRealtime() - lastDisconnectedTime)
+                <= satelliteConnectionHysteresisTime) {
+            logd("isInSatelliteModeForCarrierRoaming: " + "subId:" + subId
+                    + " is connected to satellite within hysteresis time");
+            return true;
+        } else {
+            resetCarrierRoamingSatelliteModeParams(subId);
+            return false;
         }
     }
 
@@ -4238,7 +4770,7 @@ public class SatelliteController extends Handler {
      *                      {@code false} otherwise.
      */
     public boolean getRequestIsEmergency() {
-        return mIsEmergency;
+        return mIsEmergency.get();
     }
 
     /**
@@ -4303,11 +4835,9 @@ public class SatelliteController extends Handler {
      */
     @NonNull
     public List<Integer> getCapabilitiesForCarrierRoamingSatelliteMode(Phone phone) {
-        synchronized (mSatelliteConnectedLock) {
-            int subId = phone.getSubId();
-            if (mSatModeCapabilitiesForCarrierRoaming.containsKey(subId)) {
-                return mSatModeCapabilitiesForCarrierRoaming.get(subId);
-            }
+        int subId = phone.getSubId();
+        if (mSatModeCapabilitiesForCarrierRoaming.containsKey(subId)) {
+            return mSatModeCapabilitiesForCarrierRoaming.get(subId);
         }
 
         return new ArrayList<>();
@@ -4411,10 +4941,39 @@ public class SatelliteController extends Handler {
      */
     public void onSatelliteEntitlementStatusUpdated(int subId, boolean entitlementEnabled,
             @Nullable List<String> allowedPlmnList, @Nullable List<String> barredPlmnList,
-            @Nullable Map<String,Integer> plmnDataPlanMap,
-            @Nullable Map<String,List<Integer>> plmnServiceTypeMap,
-            @Nullable Map<String,Integer> plmnDataServicePolicyMap,
-            @Nullable Map<String,Integer> plmnVoiceServicePolicyMap,
+            @Nullable Map<String, Integer> plmnDataPlanMap,
+            @Nullable Map<String, List<Integer>> plmnServiceTypeMap,
+            @Nullable Map<String, Integer> plmnDataServicePolicyMap,
+            @Nullable Map<String, Integer> plmnVoiceServicePolicyMap,
+            @Nullable IIntegerConsumer callback) {
+        plogd("onSatelliteEntitlementStatusUpdated: subId=" + subId
+                + ", entitlementEnabled=" + entitlementEnabled);
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.argi1 = subId;
+            args.argi2 = entitlementEnabled ? TRUE : FALSE;
+            args.arg1 = allowedPlmnList;
+            args.arg2 = barredPlmnList;
+            args.arg3 = plmnDataPlanMap;
+            args.arg4 = plmnServiceTypeMap;
+            args.arg5 = plmnDataServicePolicyMap;
+            args.arg6 = plmnVoiceServicePolicyMap;
+            args.arg7 = callback;
+            sendMessage(obtainMessage(EVENT_SATELLITE_ENTILEMENT_STATUS_UPDATED, args));
+            return;
+        }
+
+        handleSatelliteEntitlementStatusUpdated(subId, entitlementEnabled, allowedPlmnList,
+                barredPlmnList, plmnDataPlanMap, plmnServiceTypeMap, plmnDataServicePolicyMap,
+                plmnVoiceServicePolicyMap, callback);
+    }
+
+    private void handleSatelliteEntitlementStatusUpdated(int subId, boolean entitlementEnabled,
+            @Nullable List<String> allowedPlmnList, @Nullable List<String> barredPlmnList,
+            @Nullable Map<String, Integer> plmnDataPlanMap,
+            @Nullable Map<String, List<Integer>> plmnServiceTypeMap,
+            @Nullable Map<String, Integer> plmnDataServicePolicyMap,
+            @Nullable Map<String, Integer> plmnVoiceServicePolicyMap,
             @Nullable IIntegerConsumer callback) {
         if (callback == null) {
             callback = new IIntegerConsumer.Stub() {
@@ -4442,7 +5001,8 @@ public class SatelliteController extends Handler {
         if (plmnVoiceServicePolicyMap == null) {
             plmnVoiceServicePolicyMap = new HashMap<>();
         }
-        logd("onSatelliteEntitlementStatusUpdated subId=" + subId + ", entitlementEnabled="
+        logd("handleSatelliteEntitlementStatusUpdated: "
+                + "subId=" + subId + ", entitlementEnabled="
                 + entitlementEnabled + ", allowedPlmnList=["
                 + String.join(",", allowedPlmnList) + "]" + ", barredPlmnList=["
                 + String.join(",", barredPlmnList) + "]"
@@ -4451,56 +5011,47 @@ public class SatelliteController extends Handler {
                 + ", plmnDataServicePolicyMap=" + plmnDataServicePolicyMap.toString()
                 + ", plmnVoiceServicePolicyMap=" + plmnVoiceServicePolicyMap.toString());
 
-        synchronized (mSupportedSatelliteServicesLock) {
-            if (mSatelliteEntitlementStatusPerCarrier.get(subId, false) != entitlementEnabled) {
-                logd("update the carrier satellite enabled to " + entitlementEnabled);
-                mSatelliteEntitlementStatusPerCarrier.put(subId, entitlementEnabled);
-                mCarrierRoamingSatelliteControllerStats.reportIsDeviceEntitled(subId,
-                        entitlementEnabled);
-                if (hasMessages(EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT)) {
-                    removeMessages(EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT);
-                    sendMessageDelayed(obtainMessage(
-                                    EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT),
-                            WAIT_FOR_REPORT_ENTITLED_MERTICS_TIMEOUT_MILLIS);
-                }
-                try {
-                    mSubscriptionManagerService.setSubscriptionProperty(subId,
-                            SATELLITE_ENTITLEMENT_STATUS, entitlementEnabled ? "1" : "0");
-                } catch (IllegalArgumentException | SecurityException e) {
-                    loge("onSatelliteEntitlementStatusUpdated: setSubscriptionProperty, e=" + e);
-                }
+        if (mSatelliteEntitlementStatusPerCarrier.computeIfAbsent(
+                subId, k -> false) != entitlementEnabled) {
+            logd("update the carrier satellite enabled to " + entitlementEnabled);
+            handleIndividualEntitlementMetricReport(subId, entitlementEnabled);
+            try {
+                mSubscriptionManagerService.setSubscriptionProperty(subId,
+                        SATELLITE_ENTITLEMENT_STATUS, entitlementEnabled ? "1" : "0");
+            } catch (IllegalArgumentException | SecurityException e) {
+                loge("handleSatelliteEntitlementStatusUpdated: setSubscriptionProperty, e=" + e);
             }
+        }
 
-            if (isValidPlmnList(allowedPlmnList) && isValidPlmnList(barredPlmnList)) {
-                mMergedPlmnListPerCarrier.remove(subId);
-                mEntitlementPlmnListPerCarrier.put(subId, allowedPlmnList);
-                mEntitlementBarredPlmnListPerCarrier.put(subId, barredPlmnList);
-                mEntitlementDataPlanMapPerCarrier.put(subId, plmnDataPlanMap);
-                mEntitlementDataServicePolicyMapPerCarrier.put(subId, plmnDataServicePolicyMap);
-                mEntitlementVoiceServicePolicyMapPerCarrier.put(subId, plmnVoiceServicePolicyMap);
-                updateAndNotifyChangesInCarrierRoamingNtnAvailableServices(subId,
-                        plmnServiceTypeMap);
-                updatePlmnListPerCarrier(subId);
+        if (isValidPlmnList(allowedPlmnList) && isValidPlmnList(barredPlmnList)) {
+            mMergedPlmnListPerCarrier.remove(subId);
+            mEntitlementPlmnListPerCarrier.put(subId, allowedPlmnList);
+            mEntitlementBarredPlmnListPerCarrier.put(subId, barredPlmnList);
+            mEntitlementDataPlanMapPerCarrier.put(subId, plmnDataPlanMap);
+            mEntitlementDataServicePolicyMapPerCarrier.put(subId, plmnDataServicePolicyMap);
+            mEntitlementVoiceServicePolicyMapPerCarrier.put(subId, plmnVoiceServicePolicyMap);
+            updateAndNotifyChangesInCarrierRoamingNtnAvailableServices(subId,
+                    plmnServiceTypeMap);
+            updatePlmnListPerCarrier(subId);
 
-                configureSatellitePlmnForCarrier(subId);
-                evaluateEnablingSatelliteForCarrier(subId,
-                        SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER, null);
-                mSubscriptionManagerService.setSatelliteEntitlementInfo(subId, allowedPlmnList,
-                        barredPlmnList, plmnDataPlanMap, plmnServiceTypeMap,
-                        plmnDataServicePolicyMap, plmnVoiceServicePolicyMap);
+            configureSatellitePlmnForCarrier(subId);
+            evaluateEnablingSatelliteForCarrier(subId,
+                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER, null);
+            mSubscriptionManagerService.setSatelliteEntitlementInfo(subId, allowedPlmnList,
+                    barredPlmnList, plmnDataPlanMap, plmnServiceTypeMap,
+                    plmnDataServicePolicyMap, plmnVoiceServicePolicyMap);
 
-            } else {
-                loge("onSatelliteEntitlementStatusUpdated: either invalid allowedPlmnList "
-                        + "or invalid barredPlmnList");
-            }
+        } else {
+            loge("handleSatelliteEntitlementStatusUpdated: either invalid allowedPlmnList "
+                    + "or invalid barredPlmnList");
+        }
 
-            if (mSatelliteEntitlementStatusPerCarrier.get(subId, false)) {
-                removeAttachRestrictionForCarrier(subId,
-                        SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
-            } else {
-                addAttachRestrictionForCarrier(subId,
-                        SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
-            }
+        if (mSatelliteEntitlementStatusPerCarrier.computeIfAbsent(subId, k -> false)) {
+            removeAttachRestrictionForCarrier(subId,
+                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
+        } else {
+            addAttachRestrictionForCarrier(subId,
+                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
         }
     }
 
@@ -4651,16 +5202,14 @@ public class SatelliteController extends Handler {
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     @Nullable
     protected Boolean isDeviceProvisioned() {
-        synchronized (mDeviceProvisionLock) {
-            if (mOverriddenIsSatelliteViaOemProvisioned != null) {
-                return mOverriddenIsSatelliteViaOemProvisioned;
-            }
+        if (mOverriddenIsSatelliteViaOemProvisioned != null) {
+            return mOverriddenIsSatelliteViaOemProvisioned.get();
+        }
 
-            if (mIsDeviceProvisioned == null) {
-                mIsDeviceProvisioned = getPersistedDeviceProvisionStatus();
-            }
-            return mIsDeviceProvisioned;
+        if (mIsDeviceProvisioned == null) {
+            mIsDeviceProvisioned = new AtomicBoolean(getPersistedDeviceProvisionStatus());
         }
+        return mIsDeviceProvisioned.get();
     }
 
     private void handleSatelliteEnabled(SatelliteControllerHandlerRequest request) {
@@ -4674,12 +5223,10 @@ public class SatelliteController extends Handler {
             plogw("handleSatelliteEnabled: enableRequestAttributes is null");
             sendErrorAndReportSessionMetrics(
                     SatelliteManager.SATELLITE_RESULT_INVALID_TELEPHONY_STATE, argument.callback);
-            synchronized (mSatelliteEnabledRequestLock) {
-                if (argument.enableSatellite) {
-                    mSatelliteEnabledRequest = null;
-                } else {
-                    mSatelliteDisabledRequest = null;
-                }
+            if (argument.enableSatellite) {
+                setSatelliteEnabledRequest(null);
+            } else {
+                setSatelliteDisabledRequest(null);
             }
             return;
         }
@@ -4695,10 +5242,8 @@ public class SatelliteController extends Handler {
          * modem is not in OFF state.
          */
         if (!argument.enableSatellite && mSatelliteModemInterface.isSatelliteServiceSupported()) {
-            synchronized (mSatelliteEnabledRequestLock) {
-                mWaitingForDisableSatelliteModemResponse = true;
-                if (!isSatelliteDisabled()) mWaitingForSatelliteModemOff = true;
-            }
+            mWaitingForDisableSatelliteModemResponse.set(true);
+            if (!isSatelliteDisabled()) mWaitingForSatelliteModemOff.set(true);
         }
 
         Message onCompleted = obtainMessage(EVENT_SET_SATELLITE_ENABLED_DONE, request);
@@ -4707,9 +5252,9 @@ public class SatelliteController extends Handler {
         startWaitForSatelliteEnablingResponseTimer(argument);
         // Logs satellite session timestamps for session metrics
         if (argument.enableSatellite) {
-            mSessionStartTimeStamp = getElapsedRealtime();
+            mSessionStartTimeStamp.set(getElapsedRealtime());
         }
-        mSessionProcessingTimeStamp = getElapsedRealtime();
+        mSessionProcessingTimeStamp.set(getElapsedRealtime());
     }
 
     /** Get the request attributes that modem needs to enable/disable satellite */
@@ -4754,9 +5299,7 @@ public class SatelliteController extends Handler {
     }
 
     private void updateSatelliteSupportedState(boolean supported) {
-        synchronized (mIsSatelliteSupportedLock) {
-            mIsSatelliteSupported = supported;
-        }
+        setIsSatelliteSupported(supported);
         mSatelliteSessionController = SatelliteSessionController.make(
                 mContext, getLooper(), mFeatureFlags, supported);
         plogd("updateSatelliteSupportedState: create a new SatelliteSessionController because "
@@ -4806,12 +5349,10 @@ public class SatelliteController extends Handler {
     }
 
     private void updateSatelliteEnabledState(boolean enabled, String caller) {
-        synchronized (mIsSatelliteEnabledLock) {
-            mIsSatelliteEnabled = enabled;
-        }
+        setIsSatelliteEnabled(enabled);
         if (mSatelliteSessionController != null) {
             mSatelliteSessionController.onSatelliteEnabledStateChanged(enabled);
-            mSatelliteSessionController.setDemoMode(mIsDemoModeEnabled);
+            mSatelliteSessionController.setDemoMode(mIsDemoModeEnabled.get());
         } else {
             ploge(caller + ": mSatelliteSessionController is not initialized yet");
         }
@@ -4913,42 +5454,40 @@ public class SatelliteController extends Handler {
         logd("updateSatelliteSubscriptionProvisionState: List=" + newList + " , provisioned="
                 + provisioned);
         boolean provisionChanged = false;
-        synchronized (mSatelliteTokenProvisionedLock) {
-            for (SatelliteSubscriberInfo subscriberInfo : newList) {
+        for (SatelliteSubscriberInfo subscriberInfo : newList) {
 
-                int subId = subscriberInfo.getSubscriptionId();
-                Boolean currentProvisioned =
-                        mProvisionedSubscriberId.get(subscriberInfo.getSubscriberId());
-                if (currentProvisioned == null) {
-                    currentProvisioned = false;
-                }
+            int subId = subscriberInfo.getSubscriptionId();
+            Boolean currentProvisioned =
+                    mProvisionedSubscriberId.get(subscriberInfo.getSubscriberId());
+            if (currentProvisioned == null) {
+                currentProvisioned = false;
+            }
 
-                Boolean isProvisionedInPersistentDb = false;
-                try {
-                    isProvisionedInPersistentDb = mSubscriptionManagerService
-                         .isSatelliteProvisionedForNonIpDatagram(subId);
-                    if (isProvisionedInPersistentDb == null) {
-                        isProvisionedInPersistentDb = false;
-                    }
-                } catch (IllegalArgumentException | SecurityException ex) {
-                    ploge("isSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
-                            + ex);
-                }
-                if (currentProvisioned == provisioned
-                        && isProvisionedInPersistentDb == provisioned) {
-                    continue;
-                }
-                provisionChanged = true;
-                mProvisionedSubscriberId.put(subscriberInfo.getSubscriberId(), provisioned);
-                try {
-                    mSubscriptionManagerService.setIsSatelliteProvisionedForNonIpDatagram(subId,
-                            provisioned);
-                    plogd("updateSatelliteSubscriptionProvisionState: set Provision state to db "
-                            + "subId=" + subId);
-                } catch (IllegalArgumentException | SecurityException ex) {
-                    ploge("setIsSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
-                            + ex);
+            Boolean isProvisionedInPersistentDb = false;
+            try {
+                isProvisionedInPersistentDb = mSubscriptionManagerService
+                        .isSatelliteProvisionedForNonIpDatagram(subId);
+                if (isProvisionedInPersistentDb == null) {
+                    isProvisionedInPersistentDb = false;
                 }
+            } catch (IllegalArgumentException | SecurityException ex) {
+                ploge("isSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
+                        + ex);
+            }
+            if (currentProvisioned == provisioned
+                    && isProvisionedInPersistentDb == provisioned) {
+                continue;
+            }
+            provisionChanged = true;
+            mProvisionedSubscriberId.put(subscriberInfo.getSubscriberId(), provisioned);
+            try {
+                mSubscriptionManagerService.setIsSatelliteProvisionedForNonIpDatagram(subId,
+                        provisioned);
+                plogd("updateSatelliteSubscriptionProvisionState: set Provision state to db "
+                        + "subId=" + subId);
+            } catch (IllegalArgumentException | SecurityException ex) {
+                ploge("setIsSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
+                        + ex);
             }
         }
         return provisionChanged;
@@ -4961,23 +5500,21 @@ public class SatelliteController extends Handler {
         notifySatelliteSubscriptionProvisionStateChanged(informList);
         updateCachedDeviceProvisionStatus();
         // Report updated provisioned status to metrics.
-        synchronized (mSatelliteTokenProvisionedLock) {
-            boolean isProvisioned = !mProvisionedSubscriberId.isEmpty()
-                    && mProvisionedSubscriberId.containsValue(Boolean.TRUE);
-            mControllerMetricsStats.setIsProvisioned(isProvisioned);
-        }
+        handleEntireProvisionMetricReport();
+        scheduleRegularMetricReportTimer();
         selectBindingSatelliteSubscription(false);
-        evaluateCarrierRoamingNtnEligibilityChange();
+        handleCarrierRoamingNtnAvailableServicesChanged();
     }
 
     private void updateCachedDeviceProvisionStatus() {
         boolean isProvisioned = getPersistedDeviceProvisionStatus();
         plogd("updateCachedDeviceProvisionStatus: isProvisioned=" + isProvisioned);
-        synchronized (mDeviceProvisionLock) {
-            if (mIsDeviceProvisioned == null || mIsDeviceProvisioned != isProvisioned) {
-                mIsDeviceProvisioned = isProvisioned;
-                notifyDeviceProvisionStateChanged(isProvisioned);
-            }
+        if (mIsDeviceProvisioned == null) {
+            mIsDeviceProvisioned = new AtomicBoolean(isProvisioned);
+            notifyDeviceProvisionStateChanged(isProvisioned);
+        } else if (mIsDeviceProvisioned.get() != isProvisioned) {
+            mIsDeviceProvisioned.set(isProvisioned);
+            notifyDeviceProvisionStateChanged(isProvisioned);
         }
     }
 
@@ -5000,11 +5537,7 @@ public class SatelliteController extends Handler {
     private void handleEventSatelliteModemStateChanged(
             @SatelliteManager.SatelliteModemState int state) {
         plogd("handleEventSatelliteModemStateChanged: state=" + state);
-
-        synchronized (mSatelliteModemStateLock) {
-            mSatelliteModemState = state;
-        }
-
+        mSatelliteModemState.set(state);
         if (state == SatelliteManager.SATELLITE_MODEM_STATE_UNAVAILABLE
                 || state == SatelliteManager.SATELLITE_MODEM_STATE_OFF) {
             if (!isWaitingForDisableSatelliteModemResponse()) {
@@ -5013,25 +5546,21 @@ public class SatelliteController extends Handler {
                 notifyModemStateChangedToSessionController(
                         SatelliteManager.SATELLITE_MODEM_STATE_OFF);
             }
-
-            synchronized (mSatelliteEnabledRequestLock) {
-                mWaitingForSatelliteModemOff = false;
-            }
+            mWaitingForSatelliteModemOff.set(false);
         } else {
             if (isSatelliteEnabledOrBeingEnabled() || isSatelliteBeingDisabled()) {
                 notifyModemStateChangedToSessionController(state);
             } else {
                 // Telephony framework and modem are out of sync. We need to disable
-                synchronized (mSatelliteEnabledRequestLock) {
-                    plogw("Satellite modem is in a bad state. Disabling satellite modem now ...");
-                    Consumer<Integer> result = integer -> plogd(
-                            "handleEventSatelliteModemStateChanged: disabling satellite result="
-                                    + integer);
-                    mSatelliteDisabledRequest = new RequestSatelliteEnabledArgument(
-                            false /* enableSatellite */, false /* enableDemoMode */,
-                            false /* isEmergency */, result);
-                    sendRequestAsync(CMD_SET_SATELLITE_ENABLED, mSatelliteDisabledRequest, null);
-                }
+                plogw("Satellite modem is in a bad state. Disabling satellite modem now ...");
+                Consumer<Integer> result = integer -> plogd(
+                        "handleEventSatelliteModemStateChanged: disabling satellite result="
+                                + integer);
+                RequestSatelliteEnabledArgument disabledRequest =
+                        new RequestSatelliteEnabledArgument(false /* enableSatellite */,
+                                false /* enableDemoMode */, false /* isEmergency */, result);
+                setSatelliteDisabledRequest(disabledRequest);
+                sendRequestAsync(CMD_SET_SATELLITE_ENABLED, disabledRequest, null);
             }
         }
     }
@@ -5046,11 +5575,9 @@ public class SatelliteController extends Handler {
         }
     }
 
-    private void handleEventNtnSignalStrengthChanged(NtnSignalStrength ntnSignalStrength) {
+    private void handleEventNtnSignalStrengthChanged(@NonNull NtnSignalStrength ntnSignalStrength) {
         logd("handleEventNtnSignalStrengthChanged: ntnSignalStrength=" + ntnSignalStrength);
-        synchronized (mNtnSignalsStrengthLock) {
-            mNtnSignalStrength = ntnSignalStrength;
-        }
+        setNtnSignalStrength(ntnSignalStrength);
         mSessionMetricsStats.updateMaxNtnSignalStrengthLevel(ntnSignalStrength.getLevel());
 
         List<INtnSignalStrengthCallback> deadCallersList = new ArrayList<>();
@@ -5070,9 +5597,7 @@ public class SatelliteController extends Handler {
     private void handleEventSatelliteCapabilitiesChanged(SatelliteCapabilities capabilities) {
         plogd("handleEventSatelliteCapabilitiesChanged()");
 
-        synchronized (mSatelliteCapabilitiesLock) {
-            mSatelliteCapabilities = capabilities;
-        }
+        setSatelliteCapabilities(capabilities);
         overrideSatelliteCapabilitiesIfApplicable();
 
         SatelliteCapabilities satelliteCapabilities = getSatelliteCapabilities();
@@ -5121,10 +5646,7 @@ public class SatelliteController extends Handler {
                     });
 
         }
-
-        synchronized (mIsSatelliteSupportedLock) {
-            mIsSatelliteSupported = supported;
-        }
+        setIsSatelliteSupported(supported);
     }
 
     private void handleEventSelectedNbIotSatelliteSubscriptionChanged(int selectedSubId) {
@@ -5287,71 +5809,61 @@ public class SatelliteController extends Handler {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected boolean areAllRadiosDisabled() {
-        synchronized (mRadioStateLock) {
-            if ((mDisableBTOnSatelliteEnabled && mBTStateEnabled)
-                    || (mDisableNFCOnSatelliteEnabled && mNfcStateEnabled)
-                    || (mDisableWifiOnSatelliteEnabled && mWifiStateEnabled)
-                    || (mDisableUWBOnSatelliteEnabled && mUwbStateEnabled)) {
-                plogd("All radios are not disabled yet.");
-                return false;
-            }
-            plogd("All radios are disabled.");
-            return true;
+        if ((mDisableBTOnSatelliteEnabled.get() && mBTStateEnabled.get())
+                || (mDisableNFCOnSatelliteEnabled.get() && mNfcStateEnabled.get())
+                || (mDisableWifiOnSatelliteEnabled.get() && mWifiStateEnabled.get())
+                || (mDisableUWBOnSatelliteEnabled.get() && mUwbStateEnabled.get())) {
+            plogd("All radios are not disabled yet.");
+            return false;
         }
+        plogd("All radios are disabled.");
+        return true;
     }
 
     private void evaluateToSendSatelliteEnabledSuccess() {
         plogd("evaluateToSendSatelliteEnabledSuccess");
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (areAllRadiosDisabled() && (mSatelliteEnabledRequest != null)
-                    && mWaitingForRadioDisabled) {
-                plogd("Sending success to callback that sent enable satellite request");
-                synchronized (mIsSatelliteEnabledLock) {
-                    mIsSatelliteEnabled = mSatelliteEnabledRequest.enableSatellite;
-                }
-                mSatelliteEnabledRequest.callback.accept(SATELLITE_RESULT_SUCCESS);
-                updateSatelliteEnabledState(
-                        mSatelliteEnabledRequest.enableSatellite,
-                        "EVENT_SET_SATELLITE_ENABLED_DONE");
-                setEmergencyMode(mSatelliteEnabledRequest.isEmergency);
-                if (mSatelliteEnabledRequest.enableSatellite
-                        && !mSatelliteEnabledRequest.isEmergency) {
-                    plogd("Starting pointingUI needFullscreenPointingUI=" + true
-                            + "mIsDemoModeEnabled=" + mIsDemoModeEnabled + ", isEmergency="
-                            + mSatelliteEnabledRequest.isEmergency);
-                    mPointingAppController.startPointingUI(true, mIsDemoModeEnabled, false);
-                }
-                mSatelliteEnabledRequest = null;
-                mWaitingForRadioDisabled = false;
+        RequestSatelliteEnabledArgument satelliteEnabledRequest = getSatelliteEnabledRequest();
+        if (areAllRadiosDisabled() && (satelliteEnabledRequest != null)
+                && mWaitingForRadioDisabled.get()) {
+            plogd("Sending success to callback that sent enable satellite request");
+            setIsSatelliteEnabled(satelliteEnabledRequest.enableSatellite);
+            satelliteEnabledRequest.callback.accept(SATELLITE_RESULT_SUCCESS);
+            updateSatelliteEnabledState(satelliteEnabledRequest.enableSatellite,
+                    "EVENT_SET_SATELLITE_ENABLED_DONE");
+            setEmergencyMode(satelliteEnabledRequest.isEmergency);
+            if (satelliteEnabledRequest.enableSatellite
+                    && !satelliteEnabledRequest.isEmergency) {
+                plogd("Starting pointingUI needFullscreenPointingUI=" + true
+                        + "mIsDemoModeEnabled=" + mIsDemoModeEnabled.get() + ", isEmergency="
+                        + satelliteEnabledRequest.isEmergency);
+                mPointingAppController.startPointingUI(true, mIsDemoModeEnabled.get(), false);
+            }
+            setSatelliteEnabledRequest(null);
+            mWaitingForRadioDisabled.set(false);
 
-                if (mSatelliteEnableAttributesUpdateRequest != null) {
-                    sendRequestAsync(CMD_UPDATE_SATELLITE_ENABLE_ATTRIBUTES,
-                            mSatelliteEnableAttributesUpdateRequest, null);
-                }
-                updateLastNotifiedNtnModeAndNotify(getSatellitePhone());
+            if (getSatelliteEnableAttributesUpdateRequest() != null) {
+                sendRequestAsync(CMD_UPDATE_SATELLITE_ENABLE_ATTRIBUTES,
+                        getSatelliteEnableAttributesUpdateRequest(), null);
+            }
+            updateLastNotifiedNtnModeAndNotify(getSatellitePhone());
 
-                if (mFeatureFlags.satelliteExitP2pSessionOutsideGeofence()) {
-                    evaluateDisablingP2pSession();
-                }
+            if (mFeatureFlags.satelliteExitP2pSessionOutsideGeofence()) {
+                evaluateDisablingP2pSession();
             }
         }
     }
 
     private void resetSatelliteEnabledRequest() {
         plogd("resetSatelliteEnabledRequest");
-        synchronized (mSatelliteEnabledRequestLock) {
-            mSatelliteEnabledRequest = null;
-            mWaitingForRadioDisabled = false;
-        }
+        setSatelliteEnabledRequest(null);
+        mWaitingForRadioDisabled.set(false);
     }
 
     private void resetSatelliteDisabledRequest() {
         plogd("resetSatelliteDisabledRequest");
-        synchronized (mSatelliteEnabledRequestLock) {
-            mSatelliteDisabledRequest = null;
-            mWaitingForDisableSatelliteModemResponse = false;
-            mWaitingForSatelliteModemOff = false;
-        }
+        setSatelliteDisabledRequest(null);
+        mWaitingForDisableSatelliteModemResponse.set(false);
+        mWaitingForSatelliteModemOff.set(false);
     }
 
     /**
@@ -5364,11 +5876,9 @@ public class SatelliteController extends Handler {
             @SatelliteManager.SatelliteResult int resultCode) {
         plogd("moveSatelliteToOffStateAndCleanUpResources");
         setDemoModeEnabled(false);
-        handlePersistentLoggingOnSessionEnd(mIsEmergency);
+        handlePersistentLoggingOnSessionEnd(mIsEmergency.get());
         setEmergencyMode(false);
-        synchronized (mIsSatelliteEnabledLock) {
-            mIsSatelliteEnabled = false;
-        }
+        setIsSatelliteEnabled(false);
         setSettingsKeyForSatelliteMode(SATELLITE_MODE_ENABLED_FALSE);
         setSettingsKeyToAllowDeviceRotation(SATELLITE_MODE_ENABLED_FALSE);
         abortSatelliteDisableRequest(resultCode);
@@ -5388,17 +5898,18 @@ public class SatelliteController extends Handler {
     }
 
     private void setDemoModeEnabled(boolean enabled) {
-        mIsDemoModeEnabled = enabled;
-        mDatagramController.setDemoMode(mIsDemoModeEnabled);
-        plogd("setDemoModeEnabled: mIsDemoModeEnabled=" + mIsDemoModeEnabled);
+        mIsDemoModeEnabled.set(enabled);
+        mDatagramController.setDemoMode(enabled);
+        plogd("setDemoModeEnabled: mIsDemoModeEnabled=" + enabled);
     }
 
     private void setEmergencyMode(boolean isEmergency) {
-        plogd("setEmergencyMode: mIsEmergency=" + mIsEmergency + ", isEmergency=" + isEmergency);
-        if (mIsEmergency != isEmergency) {
-            mIsEmergency = isEmergency;
+        plogd("setEmergencyMode: mIsEmergency=" + mIsEmergency.get()
+                + ", isEmergency=" + isEmergency);
+        if (mIsEmergency.get() != isEmergency) {
+            mIsEmergency.set(isEmergency);
             if (mSatelliteSessionController != null) {
-                mSatelliteSessionController.onEmergencyModeChanged(mIsEmergency);
+                mSatelliteSessionController.onEmergencyModeChanged(isEmergency);
             } else {
                 plogw("setEmergencyMode: mSatelliteSessionController is null");
             }
@@ -5449,16 +5960,13 @@ public class SatelliteController extends Handler {
     }
 
     private List<String> getCarrierPlmnList(int subId) {
-        synchronized (mSupportedSatelliteServicesLock) {
-            return mMergedPlmnListPerCarrier.get(subId, new ArrayList<>()).stream().toList();
-        }
+        return mMergedPlmnListPerCarrier.computeIfAbsent(
+                subId, k -> new ArrayList<>()).stream().toList();
     }
 
     private List<String> getBarredPlmnList(int subId) {
-        synchronized (mSupportedSatelliteServicesLock) {
-            return mEntitlementBarredPlmnListPerCarrier.get(
-                    subId, new ArrayList<>()).stream().toList();
-        }
+        return mEntitlementBarredPlmnListPerCarrier.computeIfAbsent(
+                subId, k -> new ArrayList<>()).stream().toList();
     }
 
     private void persistCarrierRoamingNtnAllSatellitePlmnSet(Set<String> allSatellitePlmnSet) {
@@ -5476,9 +5984,13 @@ public class SatelliteController extends Handler {
                 plogd("persistCarrierRoamingNtnAllSatellitePlmnSet: ex=" + ex);
             }
 
-            synchronized (mCarrierRoamingNtnAllSatellitePlmnSetLock) {
-                mCarrierRoamingNtnAllSatellitePlmnSet = allSatellitePlmnSet;
-            }
+            setCarrierRoamingNtnAllSatellitePlmnSet(allSatellitePlmnSet);
+        }
+    }
+
+    private void setCarrierRoamingNtnAllSatellitePlmnSet(Set<String> allSatellitePlmnSet) {
+        synchronized (mCarrierRoamingNtnAllSatellitePlmnSetLock) {
+            mCarrierRoamingNtnAllSatellitePlmnSet = allSatellitePlmnSet;
         }
     }
 
@@ -5505,12 +6017,9 @@ public class SatelliteController extends Handler {
                 plogd("getCarrierRoamingNtnAllSatellitePlmnSetFromStorage: ex=" + ex);
             }
 
-            synchronized (mCarrierRoamingNtnAllSatellitePlmnSetLock) {
-                mCarrierRoamingNtnAllSatellitePlmnSet = allSatellitePlmnSet;
-                plogd("getCarrierRoamingNtnAllSatellitePlmnSetFromStorage: "
-                        + mCarrierRoamingNtnAllSatellitePlmnSet);
-                return mCarrierRoamingNtnAllSatellitePlmnSet;
-            }
+            setCarrierRoamingNtnAllSatellitePlmnSet(allSatellitePlmnSet);
+            plogd("getCarrierRoamingNtnAllSatellitePlmnSetFromStorage: " + allSatellitePlmnSet);
+            return allSatellitePlmnSet;
         }
     }
 
@@ -5520,19 +6029,18 @@ public class SatelliteController extends Handler {
     }
 
     private void updateSupportedSatelliteServicesForActiveSubscriptions() {
-        synchronized (mSupportedSatelliteServicesLock) {
-            mSatelliteServicesSupportedByCarriersFromConfig.clear();
-            mMergedPlmnListPerCarrier.clear();
-            int[] activeSubIds = mSubscriptionManagerService.getActiveSubIdList(true);
-            if (activeSubIds != null) {
-                for (int subId : activeSubIds) {
-                    updateSupportedSatelliteServices(subId);
-                    handleCarrierRoamingNtnAvailableServicesChanged(subId);
-                }
-            } else {
-                loge("updateSupportedSatelliteServicesForActiveSubscriptions: "
-                        + "activeSubIds is null");
+        plogd("updateSupportedSatelliteServicesForActiveSubscriptions");
+        mSatelliteServicesSupportedByCarriersFromConfig.clear();
+        mMergedPlmnListPerCarrier.clear();
+        int[] activeSubIds = mSubscriptionManagerService.getActiveSubIdList(true);
+        if (activeSubIds != null) {
+            for (int subId : activeSubIds) {
+                updateSupportedSatelliteServices(subId);
+                handleCarrierRoamingNtnAvailableServicesChanged(subId);
             }
+        } else {
+            loge("updateSupportedSatelliteServicesForActiveSubscriptions: "
+                    + "activeSubIds is null");
         }
     }
 
@@ -5542,84 +6050,135 @@ public class SatelliteController extends Handler {
      */
     private void updatePlmnListPerCarrier(int subId) {
         plogd("updatePlmnListPerCarrier: subId=" + subId);
-        synchronized (mSupportedSatelliteServicesLock) {
-            List<String> carrierPlmnList, entitlementPlmnList;
-            if (getConfigForSubId(subId).getBoolean(KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL,
-                    false)) {
-                entitlementPlmnList = mEntitlementPlmnListPerCarrier.get(subId,
-                        new ArrayList<>()).stream().toList();
-                plogd("updatePlmnListPerCarrier: entitlementPlmnList="
-                        + String.join(",", entitlementPlmnList)
-                        + " size=" + entitlementPlmnList.size());
-                if (!entitlementPlmnList.isEmpty()) {
-                    mMergedPlmnListPerCarrier.put(subId, entitlementPlmnList);
-                    plogd("mMergedPlmnListPerCarrier is updated by Entitlement");
-                    mCarrierRoamingSatelliteControllerStats.reportConfigDataSource(subId,
-                            SatelliteConstants.CONFIG_DATA_SOURCE_ENTITLEMENT);
-                    return;
-                }
-            }
-
-            SatelliteConfig satelliteConfig = getSatelliteConfig();
-            if (satelliteConfig != null) {
-                TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
-                int carrierId = tm.createForSubscriptionId(subId).getSimCarrierId();
-                List<String> plmnList = satelliteConfig.getAllSatellitePlmnsForCarrier(carrierId);
-                if (!plmnList.isEmpty()) {
-                    plogd("mMergedPlmnListPerCarrier is updated by ConfigUpdater : "
-                            + String.join(",", plmnList));
-                    mMergedPlmnListPerCarrier.put(subId, plmnList);
-                    mCarrierRoamingSatelliteControllerStats.reportConfigDataSource(subId,
-                            SatelliteConstants.CONFIG_DATA_SOURCE_CONFIG_UPDATER);
-                    return;
-                }
+        List<String> carrierPlmnList, entitlementPlmnList;
+        if (getConfigForSubId(subId).getBoolean(KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL,
+                false)) {
+            entitlementPlmnList = mEntitlementPlmnListPerCarrier.computeIfAbsent(subId,
+                    k -> new ArrayList<>()).stream().toList();
+            plogd("updatePlmnListPerCarrier: entitlementPlmnList="
+                    + String.join(",", entitlementPlmnList)
+                    + " size=" + entitlementPlmnList.size());
+            if (!entitlementPlmnList.isEmpty()) {
+                mMergedPlmnListPerCarrier.put(subId, entitlementPlmnList);
+                plogd("mMergedPlmnListPerCarrier is updated by Entitlement");
+                mCarrierRoamingSatelliteControllerStats.reportConfigDataSource(subId,
+                        SatelliteConstants.CONFIG_DATA_SOURCE_ENTITLEMENT);
+                return;
             }
+        }
 
-            if (mSatelliteServicesSupportedByCarriersFromConfig.containsKey(subId)
-                    && mSatelliteServicesSupportedByCarriersFromConfig.get(subId) != null) {
-                carrierPlmnList =
-                        mSatelliteServicesSupportedByCarriersFromConfig.get(subId).keySet()
-                                .stream().toList();
-                plogd("mMergedPlmnListPerCarrier is updated by carrier config: "
-                        + String.join(",", carrierPlmnList));
+        SatelliteConfig satelliteConfig = getSatelliteConfig();
+        if (satelliteConfig != null) {
+            TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
+            int carrierId = tm.createForSubscriptionId(subId).getSimCarrierId();
+            List<String> plmnList = satelliteConfig.getAllSatellitePlmnsForCarrier(carrierId);
+            if (!plmnList.isEmpty()) {
+                plogd("mMergedPlmnListPerCarrier is updated by ConfigUpdater : "
+                        + String.join(",", plmnList));
+                mMergedPlmnListPerCarrier.put(subId, plmnList);
                 mCarrierRoamingSatelliteControllerStats.reportConfigDataSource(subId,
-                        SatelliteConstants.CONFIG_DATA_SOURCE_CARRIER_CONFIG);
-            } else {
-                carrierPlmnList = new ArrayList<>();
-                plogd("Empty mMergedPlmnListPerCarrier");
+                        SatelliteConstants.CONFIG_DATA_SOURCE_CONFIG_UPDATER);
+                return;
             }
-            mMergedPlmnListPerCarrier.put(subId, carrierPlmnList);
         }
+
+        if (mSatelliteServicesSupportedByCarriersFromConfig.containsKey(subId)
+                && mSatelliteServicesSupportedByCarriersFromConfig.get(subId) != null) {
+            carrierPlmnList =
+                    mSatelliteServicesSupportedByCarriersFromConfig.get(subId).keySet()
+                            .stream().toList();
+            plogd("mMergedPlmnListPerCarrier is updated by carrier config: "
+                    + String.join(",", carrierPlmnList));
+            mCarrierRoamingSatelliteControllerStats.reportConfigDataSource(subId,
+                    SatelliteConstants.CONFIG_DATA_SOURCE_CARRIER_CONFIG);
+        } else {
+            carrierPlmnList = new ArrayList<>();
+            plogd("Empty mMergedPlmnListPerCarrier");
+        }
+        mMergedPlmnListPerCarrier.put(subId, carrierPlmnList);
     }
 
     private void updateSupportedSatelliteServices(int subId) {
         plogd("updateSupportedSatelliteServices with subId " + subId);
-        synchronized (mSupportedSatelliteServicesLock) {
-            SatelliteConfig satelliteConfig = getSatelliteConfig();
+        SatelliteConfig satelliteConfig = getSatelliteConfig();
+
+        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
+        int carrierId = tm.createForSubscriptionId(subId).getSimCarrierId();
+
+        if (satelliteConfig != null) {
+            Map<String, Set<Integer>> supportedServicesPerPlmn =
+                    satelliteConfig.getSupportedSatelliteServices(carrierId);
+            if (!supportedServicesPerPlmn.isEmpty()) {
+                mSatelliteServicesSupportedByCarriersFromConfig.put(subId,
+                        supportedServicesPerPlmn);
+                plogd("updateSupportedSatelliteServices using ConfigUpdater, "
+                        + "supportedServicesPerPlmn = " + supportedServicesPerPlmn.size());
+                updatePlmnListPerCarrier(subId);
+                return;
+            } else {
+                plogd("supportedServicesPerPlmn is empty");
+            }
+        }
 
-            TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
-            int carrierId = tm.createForSubscriptionId(subId).getSimCarrierId();
+        mSatelliteServicesSupportedByCarriersFromConfig.put(
+                subId, readSupportedSatelliteServicesFromCarrierConfig(subId));
+        updatePlmnListPerCarrier(subId);
+        plogd("updateSupportedSatelliteServices using carrier config");
+    }
 
-            if (satelliteConfig != null) {
-                Map<String, Set<Integer>> supportedServicesPerPlmn =
-                        satelliteConfig.getSupportedSatelliteServices(carrierId);
-                if (!supportedServicesPerPlmn.isEmpty()) {
-                    mSatelliteServicesSupportedByCarriersFromConfig.put(subId,
-                            supportedServicesPerPlmn);
-                    plogd("updateSupportedSatelliteServices using ConfigUpdater, "
-                            + "supportedServicesPerPlmn = " + supportedServicesPerPlmn.size());
-                    updatePlmnListPerCarrier(subId);
-                    return;
-                } else {
-                    plogd("supportedServicesPerPlmn is empty");
-                }
-            }
+    @NonNull
+    private int getMaxAllowedDataModeDeviceConfigOverlay() {
+        int maxAllowedDataMode = CarrierConfigManager.SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED;
+        try {
+            maxAllowedDataMode =
+                    mContext.getResources().getInteger(R.integer.max_allowed_data_mode);
+        } catch (Resources.NotFoundException ex) {
+            ploge(
+                    "getMaxAllowedDataModeDeviceConfigOverlay: max_allowed_data_mode resource not"
+                            + " found. ex="
+                            + ex);
+        }
+        logd("getMaxAllowedDataModeDeviceConfigOverlay: " + maxAllowedDataMode);
+        return maxAllowedDataMode;
+    }
 
-            mSatelliteServicesSupportedByCarriersFromConfig.put(
-                    subId, readSupportedSatelliteServicesFromCarrierConfig(subId));
-            updatePlmnListPerCarrier(subId);
-            plogd("updateSupportedSatelliteServices using carrier config");
+    /**
+     * @return An integer representing the maximum allowed data mode. This will be the value from
+     *     the configupdater configuration if available and valid, otherwise the value from the
+     *     device configuration overlay.
+     */
+    public int getMaxAllowedDataMode() {
+        if (mMaxAllowedDataModeForCtsTest.get() >= 0) {
+            logd("getMaxAllowedDataMode: using the overridden value for CTS test="
+                + mMaxAllowedDataModeForCtsTest.get());
+            return mMaxAllowedDataModeForCtsTest.get();
+        }
+        int maxAllowedDataMode = getMaxAllowedDataModeDeviceConfigOverlay();
+        logd("getMaxAllowedDataMode: device config=" + maxAllowedDataMode);
+
+        SatelliteConfig satelliteConfig = getSatelliteConfig();
+        if (satelliteConfig == null) {
+            logd(
+                    "getMaxAllowedDataMode: satelliteConfig is null: "
+                            + "return "
+                            + maxAllowedDataMode);
+            return maxAllowedDataMode;
+        }
+
+        if (satelliteConfig.getSatelliteMaxAllowedDataMode() == null) {
+            logd(
+                    "getMaxAllowedDataMode: getSatelliteMaxAllowedDataMode() is null: "
+                            + "return "
+                            + maxAllowedDataMode);
+            return maxAllowedDataMode;
         }
+
+        maxAllowedDataMode = satelliteConfig.getSatelliteMaxAllowedDataMode();
+        logd(
+                "getMaxAllowedDataMode: "
+                        + "satelliteConfig.getSatelliteMaxAllowedDataMode()="
+                        + maxAllowedDataMode);
+        return maxAllowedDataMode;
     }
 
     @NonNull
@@ -5702,24 +6261,22 @@ public class SatelliteController extends Handler {
         resetCarrierRoamingSatelliteModeParams(subId);
         evaluateCarrierRoamingNtnEligibilityChange();
         sendMessageDelayed(obtainMessage(CMD_EVALUATE_ESOS_PROFILES_PRIORITIZATION),
-                mEvaluateEsosProfilesPrioritizationDurationMillis);
+                mEvaluateEsosProfilesPrioritizationDurationMillis.get());
         updateRegionalSatelliteEarfcns(subId);
     }
 
     private void getSatelliteEnabledForCarrierAtModem(int subId) {
         Phone phone = SatelliteServiceUtils.getPhone(subId);
-        synchronized (mIsSatelliteEnabledLock) {
-            if (!mIsSatelliteAttachEnabledForCarrierArrayPerSub.containsKey(subId)) {
-                // Get enabled status from modem for new subscription
-                sendRequestAsync(CMD_GET_SATELLITE_ENABLED_FOR_CARRIER, null, phone);
-            }
+        if (!mIsSatelliteAttachEnabledForCarrierArrayPerSub.containsKey(subId)) {
+            // Get enabled status from modem for new subscription
+            sendRequestAsync(CMD_GET_SATELLITE_ENABLED_FOR_CARRIER, null, phone);
         }
     }
 
     // imsi, msisdn, default sms subId change
     private void handleSubscriptionsChanged() {
         sendMessageDelayed(obtainMessage(CMD_EVALUATE_ESOS_PROFILES_PRIORITIZATION),
-                mEvaluateEsosProfilesPrioritizationDurationMillis);
+                mEvaluateEsosProfilesPrioritizationDurationMillis.get());
     }
 
     private void processNewCarrierConfigData(int subId) {
@@ -5731,9 +6288,7 @@ public class SatelliteController extends Handler {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected void updateCarrierConfig(int subId) {
-        synchronized (mCarrierConfigArrayLock) {
-            mCarrierConfigArray.put(subId, getConfigForSubId(subId));
-        }
+        mCarrierConfigArray.put(subId, getConfigForSubId(subId));
     }
 
     /**
@@ -5746,94 +6301,87 @@ public class SatelliteController extends Handler {
             return;
         }
 
-        synchronized (mSupportedSatelliteServicesLock) {
-            if (mEntitlementPlmnListPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementPlmnListPerCarrier: no correspondent cache, load from "
-                        + "persist storage");
-                List<String> entitlementPlmnList =
-                        mSubscriptionManagerService.getSatelliteEntitlementPlmnList(subId);
-                if (entitlementPlmnList.isEmpty()) {
-                    plogd("updateEntitlementPlmnListPerCarrier: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementPlmnListPerCarrier: entitlementPlmnList=" + String.join(",",
-                        entitlementPlmnList));
-                mEntitlementPlmnListPerCarrier.put(subId, entitlementPlmnList);
-            }
-
-            if (mEntitlementBarredPlmnListPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementBarredPlmnList: no correspondent cache, load from "
-                        + "persist storage");
-                List<String> entitlementBarredPlmnList =
-                        mSubscriptionManagerService.getSatelliteEntitlementBarredPlmnList(subId);
-                if (entitlementBarredPlmnList.isEmpty()) {
-                    plogd("updateEntitlementBarredPlmnList: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementBarredPlmnList: entitlementBarredPlmnList=" + String.join(
-                        ",", entitlementBarredPlmnList));
-                mEntitlementBarredPlmnListPerCarrier.put(subId, entitlementBarredPlmnList);
-            }
-
-            if (mEntitlementDataPlanMapPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementDataPlanForPlmns: no correspondent cache, load from "
-                        + "persist storage");
-                Map<String, Integer> entitlementDataPlanForPlmns =
-                        mSubscriptionManagerService.getSatelliteEntitlementDataPlanForPlmns(subId);
-                if (entitlementDataPlanForPlmns.isEmpty()) {
-                    plogd("updateEntitlementBarredPlmnList: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementDataPlanForPlmns: entitlementDataPlanForPlmns="
-                        + entitlementDataPlanForPlmns);
-                mEntitlementDataPlanMapPerCarrier.put(subId, entitlementDataPlanForPlmns);
-            }
-
-            if (mEntitlementServiceTypeMapPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementTypeMapPerCarrier: no correspondent cache, load from "
-                        + "persist storage");
-                Map<String, List<Integer>> entitlementTypeMapPerCarrier =
-                        mSubscriptionManagerService.getSatelliteEntitlementPlmnServiceTypeMap(
-                                subId);
-                if (entitlementTypeMapPerCarrier.isEmpty()) {
-                    plogd("updateEntitlementTypeMapPerCarrier: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementTypeMapPerCarrier: entitlementTypeMapPerCarrier="
-                        + entitlementTypeMapPerCarrier);
-                mEntitlementServiceTypeMapPerCarrier.put(subId, entitlementTypeMapPerCarrier);
-            }
-
-            if (mEntitlementDataServicePolicyMapPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementDataServicePolicy: no correspondent cache, load from "
-                        + "persist storage");
-                Map<String, Integer> entitlementDataServicePolicy =
-                        mSubscriptionManagerService.getSatelliteEntitlementPlmnDataServicePolicy(
-                                subId);
-                if (entitlementDataServicePolicy.isEmpty()) {
-                    plogd("updateEntitlementDataServicePolicy: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementDataServicePolicy: entitlementDataServicePolicy="
-                        + entitlementDataServicePolicy);
-                mEntitlementDataServicePolicyMapPerCarrier.put(subId, entitlementDataServicePolicy);
-            }
-
-            if (mEntitlementVoiceServicePolicyMapPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateEntitlementVoiceServicePolicy: no correspondent cache, load from "
-                        + "persist storage");
-                Map<String, Integer> entitlementVoiceServicePolicy =
-                        mSubscriptionManagerService.getSatelliteEntitlementPlmnVoiceServicePolicy(
-                                subId);
-                if (entitlementVoiceServicePolicy.isEmpty()) {
-                    plogd("updateEntitlementVoiceServicePolicy: read empty list");
-                    return;
-                }
-                plogd("updateEntitlementVoiceServicePolicy: entitlementVoiceServicePolicy="
-                        + entitlementVoiceServicePolicy);
-                mEntitlementVoiceServicePolicyMapPerCarrier.put(subId,
-                        entitlementVoiceServicePolicy);
+        if (!mEntitlementPlmnListPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementPlmnListPerCarrier: no correspondent cache, load from "
+                    + "persist storage");
+            List<String> entitlementPlmnList =
+                    mSubscriptionManagerService.getSatelliteEntitlementPlmnList(subId);
+            if (entitlementPlmnList.isEmpty()) {
+                plogd("updateEntitlementPlmnListPerCarrier: read empty list");
+                return;
+            }
+            plogd("updateEntitlementPlmnListPerCarrier: entitlementPlmnList=" + String.join(",",
+                    entitlementPlmnList));
+            mEntitlementPlmnListPerCarrier.put(subId, entitlementPlmnList);
+        }
+
+        if (!mEntitlementBarredPlmnListPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementBarredPlmnList: no correspondent cache, load from "
+                    + "persist storage");
+            List<String> entitlementBarredPlmnList =
+                    mSubscriptionManagerService.getSatelliteEntitlementBarredPlmnList(subId);
+            if (entitlementBarredPlmnList.isEmpty()) {
+                plogd("updateEntitlementBarredPlmnList: read empty list");
+            }
+            plogd("updateEntitlementBarredPlmnList: entitlementBarredPlmnList=" + String.join(
+                    ",", entitlementBarredPlmnList));
+            mEntitlementBarredPlmnListPerCarrier.put(subId, entitlementBarredPlmnList);
+        }
+
+        if (!mEntitlementDataPlanMapPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementDataPlanForPlmns: no correspondent cache, load from "
+                    + "persist storage");
+            Map<String, Integer> entitlementDataPlanForPlmns =
+                    mSubscriptionManagerService.getSatelliteEntitlementDataPlanForPlmns(subId);
+            if (entitlementDataPlanForPlmns.isEmpty()) {
+                plogd("updateEntitlementBarredPlmnList: read empty list");
+            }
+            plogd("updateEntitlementDataPlanForPlmns: entitlementDataPlanForPlmns="
+                    + entitlementDataPlanForPlmns);
+            mEntitlementDataPlanMapPerCarrier.put(subId, entitlementDataPlanForPlmns);
+        }
+
+        if (!mEntitlementServiceTypeMapPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementTypeMapPerCarrier: no correspondent cache, load from "
+                    + "persist storage");
+            Map<String, List<Integer>> entitlementTypeMapPerCarrier =
+                    mSubscriptionManagerService.getSatelliteEntitlementPlmnServiceTypeMap(
+                            subId);
+            if (entitlementTypeMapPerCarrier.isEmpty()) {
+                plogd("updateEntitlementTypeMapPerCarrier: read empty list");
+            }
+            plogd("updateEntitlementTypeMapPerCarrier: entitlementTypeMapPerCarrier="
+                    + entitlementTypeMapPerCarrier);
+            mEntitlementServiceTypeMapPerCarrier.put(subId, entitlementTypeMapPerCarrier);
+        }
+
+        if (!mEntitlementDataServicePolicyMapPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementDataServicePolicy: no correspondent cache, load from "
+                    + "persist storage");
+            Map<String, Integer> entitlementDataServicePolicy =
+                    mSubscriptionManagerService.getSatelliteEntitlementPlmnDataServicePolicy(
+                            subId);
+            if (entitlementDataServicePolicy.isEmpty()) {
+                plogd("updateEntitlementDataServicePolicy: read empty list");
+            }
+            plogd("updateEntitlementDataServicePolicy: entitlementDataServicePolicy="
+                    + entitlementDataServicePolicy);
+            mEntitlementDataServicePolicyMapPerCarrier.put(subId, entitlementDataServicePolicy);
+        }
+
+        if (!mEntitlementVoiceServicePolicyMapPerCarrier.containsKey(subId)) {
+            plogd("updateEntitlementVoiceServicePolicy: no correspondent cache, load from "
+                    + "persist storage");
+            Map<String, Integer> entitlementVoiceServicePolicy =
+                    mSubscriptionManagerService.getSatelliteEntitlementPlmnVoiceServicePolicy(
+                            subId);
+            if (entitlementVoiceServicePolicy.isEmpty()) {
+                plogd("updateEntitlementVoiceServicePolicy: read empty list");
             }
+            plogd("updateEntitlementVoiceServicePolicy: entitlementVoiceServicePolicy="
+                    + entitlementVoiceServicePolicy);
+            mEntitlementVoiceServicePolicyMapPerCarrier.put(subId,
+                    entitlementVoiceServicePolicy);
         }
     }
 
@@ -5871,16 +6419,14 @@ public class SatelliteController extends Handler {
             Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(
                     mSubscriptionManagerService.getSubscriptionInfo(subId));
             String subscriberId = subscriberIdPair.first;
-            synchronized (mSatelliteTokenProvisionedLock) {
-                if (mProvisionedSubscriberId.get(subscriberId) == null) {
-                    boolean Provisioned = mSubscriptionManagerService
-                            .isSatelliteProvisionedForNonIpDatagram(subId);
-                    if (Provisioned) {
-                        mProvisionedSubscriberId.put(subscriberId, true);
-                        logd("updateSatelliteProvisionStatePerSubscriberId: "
-                                + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, subscriberId)
-                                + " set true");
-                    }
+            if (mProvisionedSubscriberId.get(subscriberId) == null) {
+                boolean Provisioned = mSubscriptionManagerService
+                        .isSatelliteProvisionedForNonIpDatagram(subId);
+                if (Provisioned) {
+                    mProvisionedSubscriberId.put(subscriberId, true);
+                    logd("updateSatelliteProvisionStatePerSubscriberId: "
+                            + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, subscriberId)
+                            + " set true");
                 }
             }
         }
@@ -5976,46 +6522,42 @@ public class SatelliteController extends Handler {
      * {@code false} otherwise.
      */
     private boolean isSatelliteAttachEnabledForCarrierByUser(int subId) {
-        synchronized (mIsSatelliteEnabledLock) {
-            Set<Integer> cachedRestrictionSet =
-                    mSatelliteAttachRestrictionForCarrierArray.get(subId);
-            if (cachedRestrictionSet != null) {
-                return !cachedRestrictionSet.contains(
-                        SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER);
-            } else {
-                plogd("isSatelliteAttachEnabledForCarrierByUser() no correspondent cache, "
-                        + "load from persist storage");
-                try {
-                    String enabled =
-                            mSubscriptionManagerService.getSubscriptionProperty(subId,
-                                    SATELLITE_ATTACH_ENABLED_FOR_CARRIER,
-                                    mContext.getOpPackageName(), mContext.getAttributionTag());
-
-                    if (enabled == null) {
-                        ploge("isSatelliteAttachEnabledForCarrierByUser: invalid subId, subId="
-                                + subId);
-                        return false;
-                    }
-
-                    if (enabled.isEmpty()) {
-                        ploge("isSatelliteAttachEnabledForCarrierByUser: no data for subId(" + subId
-                                + ")");
-                        return false;
-                    }
+        Set<Integer> cachedRestrictionSet =
+                mSatelliteAttachRestrictionForCarrierArray.get(subId);
+        if (cachedRestrictionSet != null) {
+            return !cachedRestrictionSet.contains(
+                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER);
+        } else {
+            plogd("isSatelliteAttachEnabledForCarrierByUser() no correspondent cache, "
+                    + "load from persist storage");
+            try {
+                String enabled =
+                        mSubscriptionManagerService.getSubscriptionProperty(subId,
+                                SATELLITE_ATTACH_ENABLED_FOR_CARRIER,
+                                mContext.getOpPackageName(), mContext.getAttributionTag());
+
+                if (enabled == null) {
+                    ploge("isSatelliteAttachEnabledForCarrierByUser: invalid subId, subId="
+                            + subId);
+                    return false;
+                }
 
-                    synchronized (mIsSatelliteEnabledLock) {
-                        boolean result = enabled.equals("1");
-                        if (!result) {
-                            mSatelliteAttachRestrictionForCarrierArray.put(subId, new HashSet<>());
-                            mSatelliteAttachRestrictionForCarrierArray.get(subId).add(
-                                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER);
-                        }
-                        return result;
-                    }
-                } catch (IllegalArgumentException | SecurityException ex) {
-                    ploge("isSatelliteAttachEnabledForCarrierByUser: ex=" + ex);
+                if (enabled.isEmpty()) {
+                    ploge("isSatelliteAttachEnabledForCarrierByUser: no data for subId(" + subId
+                            + ")");
                     return false;
                 }
+
+                boolean result = enabled.equals("1");
+                if (!result) {
+                    mSatelliteAttachRestrictionForCarrierArray.put(subId, new HashSet<>());
+                    mSatelliteAttachRestrictionForCarrierArray.get(subId).add(
+                            SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER);
+                }
+                return result;
+            } catch (IllegalArgumentException | SecurityException ex) {
+                ploge("isSatelliteAttachEnabledForCarrierByUser: ex=" + ex);
+                return false;
             }
         }
     }
@@ -6028,10 +6570,8 @@ public class SatelliteController extends Handler {
      * @return {@code true} when there is at least on reason, {@code false} otherwise.
      */
     private boolean hasReasonToRestrictSatelliteCommunicationForCarrier(int subId) {
-        synchronized (mIsSatelliteEnabledLock) {
-            return !mSatelliteAttachRestrictionForCarrierArray
-                    .getOrDefault(subId, Collections.emptySet()).isEmpty();
-        }
+        return !mSatelliteAttachRestrictionForCarrierArray
+                .getOrDefault(subId, Collections.emptySet()).isEmpty();
     }
 
     private void updateRestrictReasonForEntitlementPerCarrier(int subId) {
@@ -6045,47 +6585,38 @@ public class SatelliteController extends Handler {
             public void accept(int result) {
                 plogd("updateRestrictReasonForEntitlementPerCarrier:" + result);
             }
-        };
-        synchronized (mSupportedSatelliteServicesLock) {
-            if (mSatelliteEntitlementStatusPerCarrier.indexOfKey(subId) < 0) {
-                plogd("updateRestrictReasonForEntitlementPerCarrier: no correspondent cache, "
-                        + "load from persist storage");
-                String entitlementStatus = null;
-                try {
-                    entitlementStatus =
-                            mSubscriptionManagerService.getSubscriptionProperty(subId,
-                                    SATELLITE_ENTITLEMENT_STATUS, mContext.getOpPackageName(),
-                                    mContext.getAttributionTag());
-                } catch (IllegalArgumentException | SecurityException e) {
-                    ploge("updateRestrictReasonForEntitlementPerCarrier, e=" + e);
-                }
-
-                if (entitlementStatus == null) {
-                    ploge("updateRestrictReasonForEntitlementPerCarrier: invalid subId, subId="
-                            + subId + " set to default value");
-                    entitlementStatus = "0";
-                }
+        };
+        if (!mSatelliteEntitlementStatusPerCarrier.containsKey(subId)) {
+            plogd("updateRestrictReasonForEntitlementPerCarrier: no correspondent cache, "
+                    + "load from persist storage");
+            String entitlementStatus = null;
+            try {
+                entitlementStatus =
+                        mSubscriptionManagerService.getSubscriptionProperty(subId,
+                                SATELLITE_ENTITLEMENT_STATUS, mContext.getOpPackageName(),
+                                mContext.getAttributionTag());
+            } catch (IllegalArgumentException | SecurityException e) {
+                ploge("updateRestrictReasonForEntitlementPerCarrier, e=" + e);
+            }
 
-                if (entitlementStatus.isEmpty()) {
-                    ploge("updateRestrictReasonForEntitlementPerCarrier: no data for subId(" + subId
-                            + "). set to default value");
-                    entitlementStatus = "0";
-                }
-                boolean result = entitlementStatus.equals("1");
-                mSatelliteEntitlementStatusPerCarrier.put(subId, result);
-                mCarrierRoamingSatelliteControllerStats.reportIsDeviceEntitled(subId, result);
-                if (hasMessages(EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT)) {
-                    removeMessages(EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT);
-                    sendMessageDelayed(obtainMessage(
-                                    EVENT_WAIT_FOR_REPORT_ENTITLED_TO_MERTICS_HYSTERESIS_TIMED_OUT),
-                            WAIT_FOR_REPORT_ENTITLED_MERTICS_TIMEOUT_MILLIS);
-                }
+            if (entitlementStatus == null) {
+                ploge("updateRestrictReasonForEntitlementPerCarrier: invalid subId, subId="
+                        + subId + " set to default value");
+                entitlementStatus = "0";
             }
 
-            if (!mSatelliteEntitlementStatusPerCarrier.get(subId, false)) {
-                addAttachRestrictionForCarrier(subId,
-                        SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
+            if (entitlementStatus.isEmpty()) {
+                ploge("updateRestrictReasonForEntitlementPerCarrier: no data for subId(" + subId
+                        + "). set to default value");
+                entitlementStatus = "0";
             }
+            boolean result = entitlementStatus.equals("1");
+            handleIndividualEntitlementMetricReport(subId, result);
+        }
+
+        if (!mSatelliteEntitlementStatusPerCarrier.computeIfAbsent(subId, k -> false)) {
+            addAttachRestrictionForCarrier(subId,
+                    SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT, callback);
         }
     }
 
@@ -6106,17 +6637,15 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mIsSatelliteEnabledLock) {
-            try {
-                mSubscriptionManagerService.setSubscriptionProperty(subId,
-                        SATELLITE_ATTACH_ENABLED_FOR_CARRIER,
-                        mSatelliteAttachRestrictionForCarrierArray.get(subId)
-                                .contains(SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER)
-                                ? "0" : "1");
-            } catch (IllegalArgumentException | SecurityException ex) {
-                ploge("persistSatelliteAttachEnabledForCarrierSetting, ex=" + ex);
-                return false;
-            }
+        try {
+            mSubscriptionManagerService.setSubscriptionProperty(subId,
+                    SATELLITE_ATTACH_ENABLED_FOR_CARRIER,
+                    mSatelliteAttachRestrictionForCarrierArray.get(subId)
+                            .contains(SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER)
+                            ? "0" : "1");
+        } catch (IllegalArgumentException | SecurityException ex) {
+            ploge("persistSatelliteAttachEnabledForCarrierSetting, ex=" + ex);
+            return false;
         }
         return true;
     }
@@ -6140,9 +6669,7 @@ public class SatelliteController extends Handler {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public boolean isSatelliteEnabledForCarrierAtModem(int subId) {
-        synchronized (mIsSatelliteEnabledLock) {
-            return mIsSatelliteAttachEnabledForCarrierArrayPerSub.getOrDefault(subId, false);
-        }
+        return mIsSatelliteAttachEnabledForCarrierArrayPerSub.getOrDefault(subId, false);
     }
 
     /**
@@ -6175,31 +6702,27 @@ public class SatelliteController extends Handler {
             return;
         }
 
-        /* Request to enable or disable the satellite in the cellular modem only when the desired
-        state and the current state are different. */
+        /* Request to enable or disable the satellite in the cellular modem. */
         boolean isSatelliteExpectedToBeEnabled = !isSatelliteRestrictedForCarrier(subId)
-                && isSatelliteSupportedViaCarrier(subId);
+                && isSatelliteSupportedViaCarrier(subId)
+                && getCarrierRoamingNtnConnectType(subId) == CARRIER_ROAMING_NTN_CONNECT_AUTOMATIC;
         boolean isSatelliteEnabledForCarrierAtModem = isSatelliteEnabledForCarrierAtModem(
                 phone.getSubId());
         plogd("evaluateEnablingSatelliteForCarrier: subId=" + subId + " reason=" + reason
                 + " isSatelliteExpectedToBeEnabled=" + isSatelliteExpectedToBeEnabled
                 + " isSatelliteEnabledForCarrierAtModem=" + isSatelliteEnabledForCarrierAtModem);
 
-        if (isSatelliteExpectedToBeEnabled != isSatelliteEnabledForCarrierAtModem) {
-            int simSlot = SubscriptionManager.getSlotIndex(subId);
-            RequestHandleSatelliteAttachRestrictionForCarrierArgument argument =
-                    new RequestHandleSatelliteAttachRestrictionForCarrierArgument(subId,
-                            reason, callback);
-            SatelliteControllerHandlerRequest request =
-                    new SatelliteControllerHandlerRequest(argument,
-                            SatelliteServiceUtils.getPhone(subId));
-            Message onCompleted = obtainMessage(
-                    EVENT_EVALUATE_SATELLITE_ATTACH_RESTRICTION_CHANGE_DONE, request);
-            phone.setSatelliteEnabledForCarrier(simSlot,
-                    isSatelliteExpectedToBeEnabled, onCompleted);
-        } else {
-            callback.accept(SATELLITE_RESULT_SUCCESS);
-        }
+        int simSlot = SubscriptionManager.getSlotIndex(subId);
+        RequestHandleSatelliteAttachRestrictionForCarrierArgument argument =
+                new RequestHandleSatelliteAttachRestrictionForCarrierArgument(subId,
+                        reason, callback);
+        SatelliteControllerHandlerRequest request =
+                new SatelliteControllerHandlerRequest(argument,
+                        SatelliteServiceUtils.getPhone(subId));
+        Message onCompleted = obtainMessage(
+                EVENT_EVALUATE_SATELLITE_ATTACH_RESTRICTION_CHANGE_DONE, request);
+        phone.setSatelliteEnabledForCarrier(simSlot,
+                isSatelliteExpectedToBeEnabled, onCompleted);
     }
 
     @SatelliteManager.SatelliteResult private int evaluateOemSatelliteRequestAllowed(
@@ -6263,21 +6786,20 @@ public class SatelliteController extends Handler {
         result.accept(error);
         mSessionMetricsStats.setInitializationResult(error)
                 .setSatelliteTechnology(getSupportedNtnRadioTechnology())
-                .setIsDemoMode(mIsDemoModeEnabled)
+                .setIsDemoMode(mIsDemoModeEnabled.get())
                 .setCarrierId(getSatelliteCarrierId())
                 .setIsNtnOnlyCarrier(isNtnOnlyCarrier())
                 .reportSessionMetrics();
-        mSessionStartTimeStamp = 0;
-        mSessionProcessingTimeStamp = 0;
+        mSessionStartTimeStamp.set(0);
+        mSessionProcessingTimeStamp.set(0);
     }
 
     public boolean isNtnOnlyCarrier() {
-        synchronized (mSatelliteTokenProvisionedLock) {
-            if (mSelectedSatelliteSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-                return false;
-            }
-            return mSelectedSatelliteSubId == getNtnOnlySubscriptionId();
+        int selectedSatelliteSubId = mSelectedSatelliteSubId.get();
+        if (selectedSatelliteSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            return false;
         }
+        return selectedSatelliteSubId == getNtnOnlySubscriptionId();
     }
 
     private void registerForServiceStateChanged() {
@@ -6306,60 +6828,59 @@ public class SatelliteController extends Handler {
                 continue;
             }
 
-            synchronized (mSatelliteConnectedLock) {
-                CarrierRoamingSatelliteSessionStats sessionStats =
-                        mCarrierRoamingSatelliteSessionStatsMap.get(subId);
-                if (DEBUG) {
-                    plogd("handleServiceStateForSatelliteConnectionViaCarrier : SubId = " + subId
-                            + "  isUsingNonTerrestrialNetwork = "
-                            + serviceState.isUsingNonTerrestrialNetwork());
-                }
-                if (serviceState.isUsingNonTerrestrialNetwork()) {
-                    if (sessionStats != null) {
-                        sessionStats.onSignalStrength(phone);
-                        if (!mWasSatelliteConnectedViaCarrier.get(subId)) {
-                            // Log satellite connection start
-                            sessionStats.onConnectionStart(phone);
-                        }
+            CarrierRoamingSatelliteSessionStats sessionStats =
+                    mCarrierRoamingSatelliteSessionStatsMap.get(subId);
+            if (DEBUG) {
+                plogd("handleServiceStateForSatelliteConnectionViaCarrier : SubId = " + subId
+                        + "  isUsingNonTerrestrialNetwork = "
+                        + serviceState.isUsingNonTerrestrialNetwork());
+            }
+            if (serviceState.isUsingNonTerrestrialNetwork()) {
+                if (sessionStats != null) {
+                    sessionStats.onSignalStrength(phone);
+                    if (!mWasSatelliteConnectedViaCarrier.computeIfAbsent(subId, k -> false)) {
+                        // Log satellite connection start
+                        sessionStats.onConnectionStart(phone);
                     }
+                }
 
-                    resetCarrierRoamingSatelliteModeParams(subId);
-                    mWasSatelliteConnectedViaCarrier.put(subId, true);
+                resetCarrierRoamingSatelliteModeParams(subId);
+                mWasSatelliteConnectedViaCarrier.put(subId, true);
 
-                    for (NetworkRegistrationInfo nri
-                            : serviceState.getNetworkRegistrationInfoList()) {
-                        if (nri.isNonTerrestrialNetwork()) {
-                            mSatModeCapabilitiesForCarrierRoaming.put(subId,
-                                    nri.getAvailableServices());
-                        }
+                for (NetworkRegistrationInfo nri
+                        : serviceState.getNetworkRegistrationInfoList()) {
+                    if (nri.isNonTerrestrialNetwork()) {
+                        mSatModeCapabilitiesForCarrierRoaming.put(subId,
+                                nri.getAvailableServices());
                     }
-                } else {
-                    Boolean connected = mWasSatelliteConnectedViaCarrier.get(subId);
-                    if (getWwanIsInService(serviceState)
-                            || serviceState.getState() == ServiceState.STATE_POWER_OFF) {
-                        resetCarrierRoamingSatelliteModeParams(subId);
-                    } else if (connected != null && connected) {
-                        // The device just got disconnected from a satellite network
-                        // and is not connected to any terrestrial network that  has coverage
-                        mLastSatelliteDisconnectedTimesMillis.put(subId, getElapsedRealtime());
-
-                        plogd("sendMessageDelayed subId:" + subId
-                                + " phoneId:" + phone.getPhoneId()
-                                + " time:" + getSatelliteConnectionHysteresisTimeMillis(subId));
-                        sendMessageDelayed(obtainMessage(EVENT_NOTIFY_NTN_HYSTERESIS_TIMED_OUT,
-                                        phone.getPhoneId()),
-                                getSatelliteConnectionHysteresisTimeMillis(subId));
-
-                        if (sessionStats != null) {
-                            // Log satellite connection end
-                            sessionStats.onConnectionEnd();
-                        }
+                }
+            } else {
+                Boolean connected = mWasSatelliteConnectedViaCarrier.computeIfAbsent(
+                        subId, k -> false);
+                if (getWwanIsInService(serviceState)
+                        || serviceState.getState() == ServiceState.STATE_POWER_OFF) {
+                    resetCarrierRoamingSatelliteModeParams(subId);
+                } else if (connected != null && connected) {
+                    // The device just got disconnected from a satellite network
+                    // and is not connected to any terrestrial network that  has coverage
+                    mLastSatelliteDisconnectedTimesMillis.put(subId, getElapsedRealtime());
+
+                    plogd("sendMessageDelayed subId:" + subId
+                            + " phoneId:" + phone.getPhoneId()
+                            + " time:" + getSatelliteConnectionHysteresisTimeMillis(subId));
+                    sendMessageDelayed(obtainMessage(EVENT_NOTIFY_NTN_HYSTERESIS_TIMED_OUT,
+                                    phone.getPhoneId()),
+                            getSatelliteConnectionHysteresisTimeMillis(subId));
+
+                    if (sessionStats != null) {
+                        // Log satellite connection end
+                        sessionStats.onConnectionEnd();
                     }
-                    mWasSatelliteConnectedViaCarrier.put(subId, false);
                 }
-                updateLastNotifiedNtnModeAndNotify(phone);
-                updateLastNotifiedCarrierRoamingNtnSignalStrengthAndNotify(phone);
+                mWasSatelliteConnectedViaCarrier.put(subId, false);
             }
+            updateLastNotifiedNtnModeAndNotify(phone);
+            updateLastNotifiedCarrierRoamingNtnSignalStrengthAndNotify(phone);
         }
         determineAutoConnectSystemNotification();
     }
@@ -6371,23 +6892,21 @@ public class SatelliteController extends Handler {
         }
 
         int subId = phone.getSubId();
-        synchronized (mSatelliteConnectedLock) {
-            boolean initialized = mInitialized.get(subId);
-            boolean lastNotifiedNtnMode = mLastNotifiedNtnMode.get(subId);
-            boolean currNtnMode = isInSatelliteModeForCarrierRoaming(phone);
-            plogd("updateLastNotifiedNtnModeAndNotify: subId=" + subId
-                    + " initialized=" + initialized
-                    + " lastNotifiedNtnMode=" + lastNotifiedNtnMode
-                    + " currNtnMode=" + currNtnMode);
-            if (!initialized || lastNotifiedNtnMode != currNtnMode) {
-                if (!initialized) mInitialized.put(subId, true);
-                mLastNotifiedNtnMode.put(subId, currNtnMode);
-                phone.notifyCarrierRoamingNtnModeChanged(currNtnMode);
-                updateLastNotifiedCarrierRoamingNtnSignalStrengthAndNotify(phone);
-                logCarrierRoamingSatelliteSessionStats(phone, lastNotifiedNtnMode, currNtnMode);
-                if(mIsNotificationShowing && !currNtnMode) {
-                    dismissSatelliteNotification();
-                }
+        boolean initialized = mInitialized.computeIfAbsent(subId, k -> false);
+        boolean lastNotifiedNtnMode = mLastNotifiedNtnMode.computeIfAbsent(subId, k -> false);
+        boolean currNtnMode = isInSatelliteModeForCarrierRoaming(phone);
+        plogd("updateLastNotifiedNtnModeAndNotify: subId=" + subId
+                + " initialized=" + initialized
+                + " lastNotifiedNtnMode=" + lastNotifiedNtnMode
+                + " currNtnMode=" + currNtnMode);
+        if (!initialized || lastNotifiedNtnMode != currNtnMode) {
+            if (!initialized) mInitialized.put(subId, true);
+            mLastNotifiedNtnMode.put(subId, currNtnMode);
+            phone.notifyCarrierRoamingNtnModeChanged(currNtnMode);
+            updateLastNotifiedCarrierRoamingNtnSignalStrengthAndNotify(phone);
+            logCarrierRoamingSatelliteSessionStats(phone, lastNotifiedNtnMode, currNtnMode);
+            if (mIsNotificationShowing.get() && !currNtnMode) {
+                dismissSatelliteNotification();
             }
         }
     }
@@ -6424,32 +6943,44 @@ public class SatelliteController extends Handler {
 
     private void logCarrierRoamingSatelliteSessionStats(@NonNull Phone phone,
             boolean lastNotifiedNtnMode, boolean currNtnMode) {
-        synchronized (mSatelliteConnectedLock) {
-            int subId = phone.getSubId();
-            if (!lastNotifiedNtnMode && currNtnMode) {
-                // Log satellite session start
-                CarrierRoamingSatelliteSessionStats sessionStats =
-                        CarrierRoamingSatelliteSessionStats.getInstance(subId);
-                int[] supported_satellite_services =
-                        getSupportedSatelliteServicesOnSessionStart(
-                                getSupportedSatelliteServicesForPlmn(subId,
-                        phone.getServiceState().getOperatorNumeric()));
-                int dataPolicy = mapDataPolicyForMetrics(getSatelliteDataServicePolicyForPlmn(subId,
-                        phone.getServiceState().getOperatorNumeric()));
-
-                sessionStats.onSessionStart(phone.getCarrierId(), phone,
-                        supported_satellite_services, dataPolicy);
-                mCarrierRoamingSatelliteSessionStatsMap.put(subId, sessionStats);
-                mCarrierRoamingSatelliteControllerStats.onSessionStart(subId);
-            } else if (lastNotifiedNtnMode && !currNtnMode) {
-                // Log satellite session end
-                CarrierRoamingSatelliteSessionStats sessionStats =
-                        mCarrierRoamingSatelliteSessionStatsMap.get(subId);
-                sessionStats.onSessionEnd(subId);
+        if (mIsDemoModeEnabled.get()) {
+            plogd("logCarrierRoamingSatelliteSessionStats: return, demo mode is enabled");
+            return;
+        }
+        int subId = phone.getSubId();
+        int userId = Binder.getCallingUserHandle().getIdentifier();
+        final long identity = Binder.clearCallingIdentity();
+        List<String> satelliteApps = List.of();
+        if (!lastNotifiedNtnMode && currNtnMode) {
+            // Log satellite session start
+            CarrierRoamingSatelliteSessionStats sessionStats =
+                    CarrierRoamingSatelliteSessionStats.getInstance(subId);
+            int[] supported_satellite_services =
+                    getSupportedSatelliteServicesOnSessionStart(
+                            getSupportedSatelliteServicesForPlmn(subId,
+                                    phone.getServiceState().getOperatorNumeric()));
+            int dataPolicy = mapDataPolicyForMetrics(getSatelliteDataServicePolicyForPlmn(subId,
+                    phone.getServiceState().getOperatorNumeric()));
+            satelliteApps = getSatelliteDataOptimizedApps(userId);
+
+            sessionStats.onSessionStart(phone.getCarrierId(), phone,
+                    supported_satellite_services, dataPolicy, satelliteApps, mFeatureFlags);
+            mCarrierRoamingSatelliteSessionStatsMap.put(subId, sessionStats);
+            mCarrierRoamingSatelliteControllerStats.onSessionStart(subId);
+        } else if (lastNotifiedNtnMode && !currNtnMode) {
+            // Log satellite session end
+            CarrierRoamingSatelliteSessionStats sessionStats =
+                    mCarrierRoamingSatelliteSessionStatsMap.get(subId);
+            if (sessionStats != null) {
+                satelliteApps = getSatelliteDataOptimizedApps(userId);
+                sessionStats.onSessionEnd(subId, satelliteApps);
                 mCarrierRoamingSatelliteSessionStatsMap.remove(subId);
-                mCarrierRoamingSatelliteControllerStats.onSessionEnd(subId);
+            } else {
+                plogd("logCarrierRoamingSatelliteSessionStats: sessionStats is null");
             }
+            mCarrierRoamingSatelliteControllerStats.onSessionEnd(subId);
         }
+        Binder.restoreCallingIdentity(identity);
     }
 
     private void evaluateCarrierRoamingNtnEligibilityChange() {
@@ -6491,10 +7022,9 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mSatellitePhoneLock) {
-            if (mLastNotifiedNtnEligibility != null && mLastNotifiedNtnEligibility) {
-                return false;
-            }
+        Boolean lastNotifiedNtnEligibility = getLastNotifiedNtnEligibility();
+        if (lastNotifiedNtnEligibility != null && lastNotifiedNtnEligibility) {
+            return false;
         }
 
         return true;
@@ -6540,17 +7070,16 @@ public class SatelliteController extends Handler {
         }
 
         int selectedSatelliteSubId = getSelectedSatelliteSubId();
-        synchronized (mSatellitePhoneLock) {
-            plogd("notifyNtnEligibility: phoneId=" + satellitePhone.getPhoneId()
-                    + " currentNtnEligibility=" + currentNtnEligibility);
-            if (mLastNotifiedNtnEligibility == null
-                    || mLastNotifiedNtnEligibility != currentNtnEligibility) {
-                mLastNotifiedNtnEligibility = currentNtnEligibility;
-                satellitePhone.notifyCarrierRoamingNtnEligibleStateChanged(currentNtnEligibility);
-                updateSatelliteSystemNotification(selectedSatelliteSubId,
-                        CarrierConfigManager.CARRIER_ROAMING_NTN_CONNECT_MANUAL,
-                        currentNtnEligibility);
-            }
+        plogd("notifyNtnEligibility: phoneId=" + satellitePhone.getPhoneId()
+                + " currentNtnEligibility=" + currentNtnEligibility);
+        Boolean lastNotifiedNtnEligibility = getLastNotifiedNtnEligibility();
+        if (lastNotifiedNtnEligibility == null
+                || lastNotifiedNtnEligibility != currentNtnEligibility) {
+            setLastNotifiedNtnEligibility(currentNtnEligibility);
+            satellitePhone.notifyCarrierRoamingNtnEligibleStateChanged(currentNtnEligibility);
+            updateSatelliteSystemNotification(selectedSatelliteSubId,
+                    CarrierConfigManager.CARRIER_ROAMING_NTN_CONNECT_MANUAL,
+                    currentNtnEligibility);
         }
     }
 
@@ -6564,10 +7093,27 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mSatellitePhoneLock) {
-            plogd("getLastNotifiedNtnEligibility: return " + mLastNotifiedNtnEligibility);
-            return mLastNotifiedNtnEligibility;
+        Boolean lastNotifiedNtnEligibility = getLastNotifiedNtnEligibility();
+        plogd("getLastNotifiedNtnEligibility: return " + lastNotifiedNtnEligibility);
+        if (lastNotifiedNtnEligibility == null) {
+            return false;
+        }
+        return lastNotifiedNtnEligibility;
+    }
+
+    private void setLastNotifiedNtnEligibility(boolean eligibility) {
+        if (mLastNotifiedNtnEligibility == null) {
+            mLastNotifiedNtnEligibility = new AtomicBoolean(eligibility);
+        } else {
+            mLastNotifiedNtnEligibility.set(eligibility);
+        }
+    }
+
+    private Boolean getLastNotifiedNtnEligibility() {
+        if (mLastNotifiedNtnEligibility == null) {
+            return null;
         }
+        return mLastNotifiedNtnEligibility.get();
     }
 
     private long getSatelliteConnectionHysteresisTimeMillis(int subId) {
@@ -6583,31 +7129,29 @@ public class SatelliteController extends Handler {
     }
 
     private void persistOemEnabledSatelliteProvisionStatus(boolean isProvisioned) {
-        synchronized (mDeviceProvisionLock) {
-            plogd("persistOemEnabledSatelliteProvisionStatus: isProvisioned=" + isProvisioned);
-            if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-                int subId = getNtnOnlySubscriptionId();
-                if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-                    try {
-                        mSubscriptionManagerService.setIsSatelliteProvisionedForNonIpDatagram(subId,
-                                isProvisioned);
-                        plogd("persistOemEnabledSatelliteProvisionStatus: subId=" + subId);
-                    } catch (IllegalArgumentException | SecurityException ex) {
-                        ploge("setIsSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
-                                + ex);
-                    }
-                } else {
-                    plogd("persistOemEnabledSatelliteProvisionStatus: INVALID_SUBSCRIPTION_ID");
+        plogd("persistOemEnabledSatelliteProvisionStatus: isProvisioned=" + isProvisioned);
+        if (mFeatureFlags.carrierRoamingNbIotNtn()) {
+            int subId = getNtnOnlySubscriptionId();
+            if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                try {
+                    mSubscriptionManagerService.setIsSatelliteProvisionedForNonIpDatagram(subId,
+                            isProvisioned);
+                    plogd("persistOemEnabledSatelliteProvisionStatus: subId=" + subId);
+                } catch (IllegalArgumentException | SecurityException ex) {
+                    ploge("setIsSatelliteProvisionedForNonIpDatagram: subId=" + subId + ", ex="
+                            + ex);
                 }
             } else {
-                if (!loadSatelliteSharedPreferences()) return;
+                plogd("persistOemEnabledSatelliteProvisionStatus: INVALID_SUBSCRIPTION_ID");
+            }
+        } else {
+            if (!loadSatelliteSharedPreferences()) return;
 
-                if (mSharedPreferences == null) {
-                    ploge("persistOemEnabledSatelliteProvisionStatus: mSharedPreferences is null");
-                } else {
-                    mSharedPreferences.edit().putBoolean(
-                            OEM_ENABLED_SATELLITE_PROVISION_STATUS_KEY, isProvisioned).apply();
-                }
+            if (mSharedPreferences == null) {
+                ploge("persistOemEnabledSatelliteProvisionStatus: mSharedPreferences is null");
+            } else {
+                mSharedPreferences.edit().putBoolean(
+                        OEM_ENABLED_SATELLITE_PROVISION_STATUS_KEY, isProvisioned).apply();
             }
         }
     }
@@ -6615,44 +7159,40 @@ public class SatelliteController extends Handler {
     @Nullable
     private boolean getPersistedDeviceProvisionStatus() {
         plogd("getPersistedDeviceProvisionStatus");
-        synchronized (mDeviceProvisionLock) {
-            if (mFeatureFlags.carrierRoamingNbIotNtn()) {
-                int subId = getNtnOnlySubscriptionId();
-                if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-                    if (mSubscriptionManagerService.isSatelliteProvisionedForNonIpDatagram(subId)) {
-                        return true;
-                    }
+        if (mFeatureFlags.carrierRoamingNbIotNtn()) {
+            int subId = getNtnOnlySubscriptionId();
+            if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                if (mSubscriptionManagerService.isSatelliteProvisionedForNonIpDatagram(subId)) {
+                    return true;
                 }
+            }
 
-                List<SubscriptionInfo> activeSubscriptionInfoList =
-                        mSubscriptionManagerService.getActiveSubscriptionInfoList(
+            List<SubscriptionInfo> activeSubscriptionInfoList =
+                    mSubscriptionManagerService.getActiveSubscriptionInfoList(
                             mContext.getOpPackageName(), mContext.getAttributionTag(), true);
-                for (SubscriptionInfo info : activeSubscriptionInfoList) {
-                    if (info.isSatelliteESOSSupported()) {
-                        if (mSubscriptionManagerService.isSatelliteProvisionedForNonIpDatagram(
-                                info.getSubscriptionId())) {
-                            Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(
-                                    mSubscriptionManagerService.getSubscriptionInfo(subId));
-                            String subscriberId = subscriberIdPair.first;
-                            synchronized (mSatelliteTokenProvisionedLock) {
-                                mProvisionedSubscriberId.put(subscriberId, true);
-                            }
-                            return true;
-                        }
+            for (SubscriptionInfo info : activeSubscriptionInfoList) {
+                if (info.isSatelliteESOSSupported()) {
+                    if (mSubscriptionManagerService.isSatelliteProvisionedForNonIpDatagram(
+                            info.getSubscriptionId())) {
+                        Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(
+                                mSubscriptionManagerService.getSubscriptionInfo(subId));
+                        String subscriberId = subscriberIdPair.first;
+                        mProvisionedSubscriberId.put(subscriberId, true);
+                        return true;
                     }
                 }
+            }
+            return false;
+        } else {
+            if (!loadSatelliteSharedPreferences()) return false;
+
+            if (mSharedPreferences == null) {
+                ploge("getPersistedDeviceProvisionStatus: mSharedPreferences is "
+                        + "null");
                 return false;
             } else {
-                if (!loadSatelliteSharedPreferences()) return false;
-
-                if (mSharedPreferences == null) {
-                    ploge("getPersistedDeviceProvisionStatus: mSharedPreferences is "
-                            + "null");
-                    return false;
-                } else {
-                    return mSharedPreferences.getBoolean(
-                            OEM_ENABLED_SATELLITE_PROVISION_STATUS_KEY, false);
-                }
+                return mSharedPreferences.getBoolean(
+                        OEM_ENABLED_SATELLITE_PROVISION_STATUS_KEY, false);
             }
         }
     }
@@ -6694,140 +7234,118 @@ public class SatelliteController extends Handler {
     }
 
     private void startWaitForCellularModemOffTimer() {
-        synchronized (mIsRadioOnLock) {
-            if (hasMessages(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT)) {
-                plogd("startWaitForCellularModemOffTimer: the timer was already started");
-                return;
-            }
-            long timeoutMillis = getWaitForCellularModemOffTimeoutMillis();
-            plogd("Start timer to wait for cellular modem OFF state, timeoutMillis="
-                    + timeoutMillis);
-            sendMessageDelayed(obtainMessage(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT),
-                    timeoutMillis);
+        if (hasMessages(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT)) {
+            plogd("startWaitForCellularModemOffTimer: the timer was already started");
+            return;
         }
+        long timeoutMillis = getWaitForCellularModemOffTimeoutMillis();
+        plogd("Start timer to wait for cellular modem OFF state, timeoutMillis="
+                + timeoutMillis);
+        sendMessageDelayed(obtainMessage(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT),
+                timeoutMillis);
     }
 
     private void stopWaitForCellularModemOffTimer() {
-        synchronized (mSatelliteEnabledRequestLock) {
-            plogd("Stop timer to wait for cellular modem OFF state");
-            removeMessages(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT);
-        }
+        plogd("Stop timer to wait for cellular modem OFF state");
+        removeMessages(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT);
     }
 
     private void startWaitForSatelliteEnablingResponseTimer(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument)) {
-                plogd("WaitForSatelliteEnablingResponseTimer of request ID "
-                        + argument.requestId + " was already started");
-                return;
-            }
-            plogd("Start timer to wait for response of the satellite enabling request ID="
-                    + argument.requestId + ", enableSatellite=" + argument.enableSatellite
-                    + ", mWaitTimeForSatelliteEnablingResponse="
-                    + mWaitTimeForSatelliteEnablingResponse);
-            sendMessageDelayed(obtainMessage(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT,
-                            argument), mWaitTimeForSatelliteEnablingResponse);
+        if (hasMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument)) {
+            plogd("WaitForSatelliteEnablingResponseTimer of request ID "
+                    + argument.requestId + " was already started");
+            return;
         }
+        plogd("Start timer to wait for response of the satellite enabling request ID="
+                + argument.requestId + ", enableSatellite=" + argument.enableSatellite
+                + ", mWaitTimeForSatelliteEnablingResponse="
+                + mWaitTimeForSatelliteEnablingResponse.get());
+        sendMessageDelayed(obtainMessage(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT,
+                argument), mWaitTimeForSatelliteEnablingResponse.get());
     }
 
     private void stopWaitForSatelliteEnablingResponseTimer(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            plogd("Stop timer to wait for response of the satellite enabling request ID="
-                    + argument.requestId + ", enableSatellite=" + argument.enableSatellite);
-            removeMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument);
-        }
+        plogd("Stop timer to wait for response of the satellite enabling request ID="
+                + argument.requestId + ", enableSatellite=" + argument.enableSatellite);
+        removeMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument);
     }
 
     private boolean shouldProcessEventSetSatelliteEnabledDone(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument)) {
-                return true;
-            }
-            return false;
+        if (hasMessages(EVENT_WAIT_FOR_SATELLITE_ENABLING_RESPONSE_TIMED_OUT, argument)) {
+            return true;
         }
+        return false;
     }
 
     private void startWaitForUpdateSystemSelectionChannelsResponseTimer(
             @NonNull UpdateSystemSelectionChannelsArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(
-                    EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT, argument)) {
-                plogd("WaitForUpdateSystemSelectionChannelsResponseTimer of request ID "
-                        + argument.requestId + " was already started");
-                return;
-            }
-            plogd("Start timer to wait for response of the system selection channels update request"
-                    + " ID=" + argument.requestId + ", mWaitTimeForSatelliteEnablingResponse="
-                    + mWaitTimeForSatelliteEnablingResponse);
-            sendMessageDelayed(
-                obtainMessage(EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT,
-                    argument), mWaitTimeForSatelliteEnablingResponse);
+        if (hasMessages(
+                EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT, argument)) {
+            plogd("WaitForUpdateSystemSelectionChannelsResponseTimer of request ID "
+                    + argument.requestId + " was already started");
+            return;
         }
+        plogd("Start timer to wait for response of the system selection channels update request"
+                + " ID=" + argument.requestId + ", mWaitTimeForSatelliteEnablingResponse="
+                + mWaitTimeForSatelliteEnablingResponse.get());
+        sendMessageDelayed(
+                obtainMessage(EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT,
+                        argument), mWaitTimeForSatelliteEnablingResponse.get());
     }
 
     private void stopWaitForUpdateSystemSelectionChannelsResponseTimer(
             @NonNull UpdateSystemSelectionChannelsArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            plogd("Stop timer to wait for response of the system selection channels"
-                      + " update request ID=" + argument.requestId);
-            removeMessages(
+        plogd("Stop timer to wait for response of the system selection channels"
+                + " update request ID=" + argument.requestId);
+        removeMessages(
                 EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT, argument);
-        }
     }
 
     private boolean shouldProcessEventUpdateSystemSelectionChannelsDone(
             @NonNull UpdateSystemSelectionChannelsArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(
-                    EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT, argument)) {
-                return true;
-            }
-            return false;
+        if (hasMessages(
+                EVENT_WAIT_FOR_UPDATE_SYSTEM_SELECTION_CHANNELS_RESPONSE_TIMED_OUT, argument)) {
+            return true;
         }
+        return false;
     }
 
     private void startWaitForUpdateSatelliteEnableAttributesResponseTimer(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
-                    argument)) {
-                plogd("WaitForUpdateSatelliteEnableAttributesResponseTimer of request ID "
-                        + argument.requestId + " was already started");
-                return;
-            }
-            plogd("Start timer to wait for response of the update satellite enable attributes"
-                    + " request ID=" + argument.requestId
-                    + ", enableSatellite=" + argument.enableSatellite
-                    + ", mWaitTimeForSatelliteEnablingResponse="
-                    + mWaitTimeForSatelliteEnablingResponse);
-            sendMessageDelayed(obtainMessage(
-                    EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
-                    argument), mWaitTimeForSatelliteEnablingResponse);
+        if (hasMessages(EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
+                argument)) {
+            plogd("WaitForUpdateSatelliteEnableAttributesResponseTimer of request ID "
+                    + argument.requestId + " was already started");
+            return;
         }
+        plogd("Start timer to wait for response of the update satellite enable attributes"
+                + " request ID=" + argument.requestId
+                + ", enableSatellite=" + argument.enableSatellite
+                + ", mWaitTimeForSatelliteEnablingResponse="
+                + mWaitTimeForSatelliteEnablingResponse.get());
+        sendMessageDelayed(obtainMessage(
+                EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
+                argument), mWaitTimeForSatelliteEnablingResponse.get());
     }
 
     private void stopWaitForUpdateSatelliteEnableAttributesResponseTimer(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            plogd("Stop timer to wait for response of the enable attributes update request ID="
-                    + argument.requestId + ", enableSatellite=" + argument.enableSatellite);
-            removeMessages(
-                    EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT, argument);
-        }
+        plogd("Stop timer to wait for response of the enable attributes update request ID="
+                + argument.requestId + ", enableSatellite=" + argument.enableSatellite);
+        removeMessages(
+                EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT, argument);
     }
 
     private boolean shouldProcessEventUpdateSatelliteEnableAttributesDone(
             @NonNull RequestSatelliteEnabledArgument argument) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (hasMessages(EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
-                    argument)) {
-                return true;
-            }
-            return false;
+        if (hasMessages(EVENT_WAIT_FOR_UPDATE_SATELLITE_ENABLE_ATTRIBUTES_RESPONSE_TIMED_OUT,
+                argument)) {
+            return true;
         }
+        return false;
     }
 
     private void handleEventWaitForSatelliteEnablingResponseTimedOut(
@@ -6850,13 +7368,9 @@ public class SatelliteController extends Handler {
                 Consumer<Integer> result =
                         FunctionalUtils.ignoreRemoteException(callback::accept);
 
-                RequestSatelliteEnabledArgument request;
-                synchronized (mSatelliteEnabledRequestLock) {
-                    mSatelliteDisabledRequest = new RequestSatelliteEnabledArgument(
-                            false, false, false, result);
-                    request = mSatelliteDisabledRequest;
-                }
-
+                RequestSatelliteEnabledArgument request = new RequestSatelliteEnabledArgument(
+                        false, false, false, result);
+                setSatelliteDisabledRequest(request);
                 sendRequestAsync(CMD_SET_SATELLITE_ENABLED, request, null);
             }
 
@@ -6864,8 +7378,8 @@ public class SatelliteController extends Handler {
             mSessionMetricsStats.setInitializationResult(SATELLITE_RESULT_MODEM_TIMEOUT)
                     .setSatelliteTechnology(getSupportedNtnRadioTechnology())
                     .setInitializationProcessingTime(
-                            getElapsedRealtime() - mSessionProcessingTimeStamp)
-                    .setIsDemoMode(mIsDemoModeEnabled)
+                            getElapsedRealtime() - mSessionProcessingTimeStamp.get())
+                    .setIsDemoMode(mIsDemoModeEnabled.get())
                     .setCarrierId(getSatelliteCarrierId())
                     .reportSessionMetrics();
         } else {
@@ -6874,13 +7388,13 @@ public class SatelliteController extends Handler {
             mSessionMetricsStats.setTerminationResult(SATELLITE_RESULT_MODEM_TIMEOUT)
                     .setSatelliteTechnology(getSupportedNtnRadioTechnology())
                     .setTerminationProcessingTime(
-                            getElapsedRealtime() - mSessionProcessingTimeStamp)
+                            getElapsedRealtime() - mSessionProcessingTimeStamp.get())
                     .setSessionDurationSec(calculateSessionDurationTimeSec())
                     .reportSessionMetrics();
         }
         notifyEnablementFailedToSatelliteSessionController(argument.enableSatellite);
-        mSessionStartTimeStamp = 0;
-        mSessionProcessingTimeStamp = 0;
+        mSessionStartTimeStamp.set(0);
+        mSessionProcessingTimeStamp.set(0);
     }
 
     private void handleCmdUpdateNtnSignalStrengthReporting(boolean shouldReport) {
@@ -6959,7 +7473,7 @@ public class SatelliteController extends Handler {
         if (DEBUG) {
             logd("determineAutoConnectSystemNotification: isNtn.first = " + isNtn.first
                     + " IsNotiToShow = " + !suppressSatelliteNotification
-                    + " mIsNotificationShowing = " + mIsNotificationShowing);
+                    + " mIsNotificationShowing = " + mIsNotificationShowing.get());
         }
         if (isNtn.first) {
             if (!suppressSatelliteNotification && getCarrierRoamingNtnConnectType(isNtn.second)
@@ -6968,7 +7482,7 @@ public class SatelliteController extends Handler {
                         CarrierConfigManager.CARRIER_ROAMING_NTN_CONNECT_AUTOMATIC,
                         /*visible*/ true);
             }
-        } else if (mIsNotificationShowing
+        } else if (mIsNotificationShowing.get()
                 && !isSatelliteConnectedViaCarrierWithinHysteresisTime().first) {
             // Dismiss the notification if it is still displaying.
             dismissSatelliteNotification();
@@ -6976,7 +7490,7 @@ public class SatelliteController extends Handler {
     }
 
     private void dismissSatelliteNotification() {
-        mIsNotificationShowing = false;
+        mIsNotificationShowing.set(false);
         updateSatelliteSystemNotification(-1, -1,/*visible*/ false);
     }
 
@@ -7119,7 +7633,7 @@ public class SatelliteController extends Handler {
         mContext.registerReceiver(mNotificationInteractionBroadcastReceiver, filter,
                 Context.RECEIVER_EXPORTED);
 
-        mIsNotificationShowing = true;
+        mIsNotificationShowing.set(true);
         mCarrierRoamingSatelliteControllerStats.reportCountOfSatelliteNotificationDisplayed(subId);
         mCarrierRoamingSatelliteControllerStats.reportCarrierId(getSatelliteCarrierId());
         mSessionMetricsStats.addCountOfSatelliteNotificationDisplayed();
@@ -7205,11 +7719,9 @@ public class SatelliteController extends Handler {
     }
 
     private void resetCarrierRoamingSatelliteModeParams(int subId) {
-        synchronized (mSatelliteConnectedLock) {
-            mLastSatelliteDisconnectedTimesMillis.put(subId, null);
-            mSatModeCapabilitiesForCarrierRoaming.remove(subId);
-            mWasSatelliteConnectedViaCarrier.put(subId, false);
-        }
+        mLastSatelliteDisconnectedTimesMillis.remove(subId);
+        mSatModeCapabilitiesForCarrierRoaming.remove(subId);
+        mWasSatelliteConnectedViaCarrier.put(subId, false);
     }
 
     /**
@@ -7220,21 +7732,19 @@ public class SatelliteController extends Handler {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     @NonNull
-    public PersistableBundle getPersistableBundle(int subId) {
-        synchronized (mCarrierConfigArrayLock) {
-            PersistableBundle config = mCarrierConfigArray.get(subId);
-            if (config == null) {
-                config = getConfigForSubId(subId);
-                mCarrierConfigArray.put(subId, config);
-            }
-            return config;
+    protected PersistableBundle getPersistableBundle(int subId) {
+        PersistableBundle config = mCarrierConfigArray.get(subId);
+        if (config == null) {
+            config = getConfigForSubId(subId);
+            mCarrierConfigArray.put(subId, config);
         }
+        return config;
     }
 
     // Should be invoked only when session termination done or session termination failed.
     private int calculateSessionDurationTimeSec() {
         return (int) (
-                (getElapsedRealtime() - mSessionStartTimeStamp
+                (getElapsedRealtime() - mSessionStartTimeStamp.get()
                 - mSessionMetricsStats.getSessionInitializationProcessingTimeMillis()
                 - mSessionMetricsStats.getSessionTerminationProcessingTimeMillis()) / 1000);
     }
@@ -7249,43 +7759,41 @@ public class SatelliteController extends Handler {
     }
 
     private void abortSatelliteEnableRequest(@SatelliteManager.SatelliteResult int resultCode) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (mSatelliteEnabledRequest != null) {
-                plogw("abortSatelliteEnableRequest");
-                if (resultCode == SATELLITE_RESULT_SUCCESS) {
-                    resultCode = SATELLITE_RESULT_REQUEST_ABORTED;
-                }
-                mSatelliteEnabledRequest.callback.accept(resultCode);
-                stopWaitForSatelliteEnablingResponseTimer(mSatelliteEnabledRequest);
-                mSatelliteEnabledRequest = null;
+        RequestSatelliteEnabledArgument satelliteEnabledRequest = getSatelliteEnabledRequest();
+        if (satelliteEnabledRequest != null) {
+            plogw("abortSatelliteEnableRequest");
+            if (resultCode == SATELLITE_RESULT_SUCCESS) {
+                resultCode = SATELLITE_RESULT_REQUEST_ABORTED;
             }
+            satelliteEnabledRequest.callback.accept(resultCode);
+            stopWaitForSatelliteEnablingResponseTimer(satelliteEnabledRequest);
+            setSatelliteEnabledRequest(null);
         }
     }
 
     private void abortSatelliteDisableRequest(@SatelliteManager.SatelliteResult int resultCode) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (mSatelliteDisabledRequest != null) {
-                plogd("abortSatelliteDisableRequest");
-                mSatelliteDisabledRequest.callback.accept(resultCode);
-                stopWaitForSatelliteEnablingResponseTimer(mSatelliteDisabledRequest);
-                mSatelliteDisabledRequest = null;
-            }
+        RequestSatelliteEnabledArgument satelliteDisabledRequest = getSatelliteDisabledRequest();
+        if (satelliteDisabledRequest != null) {
+            plogd("abortSatelliteDisableRequest");
+            satelliteDisabledRequest.callback.accept(resultCode);
+            stopWaitForSatelliteEnablingResponseTimer(satelliteDisabledRequest);
+            setSatelliteDisabledRequest(null);
         }
     }
 
     private void abortSatelliteEnableAttributesUpdateRequest(
             @SatelliteManager.SatelliteResult int resultCode) {
-        synchronized (mSatelliteEnabledRequestLock) {
-            if (mSatelliteEnableAttributesUpdateRequest != null) {
-                plogd("abortSatelliteEnableAttributesUpdateRequest");
-                if (resultCode == SATELLITE_RESULT_SUCCESS) {
-                    resultCode = SATELLITE_RESULT_REQUEST_ABORTED;
-                }
-                mSatelliteEnableAttributesUpdateRequest.callback.accept(resultCode);
-                stopWaitForUpdateSatelliteEnableAttributesResponseTimer(
-                        mSatelliteEnableAttributesUpdateRequest);
-                mSatelliteEnableAttributesUpdateRequest = null;
+        RequestSatelliteEnabledArgument satelliteEnableAttributesUpdateRequest =
+                getSatelliteEnableAttributesUpdateRequest();
+        if (satelliteEnableAttributesUpdateRequest != null) {
+            plogd("abortSatelliteEnableAttributesUpdateRequest");
+            if (resultCode == SATELLITE_RESULT_SUCCESS) {
+                resultCode = SATELLITE_RESULT_REQUEST_ABORTED;
             }
+            satelliteEnableAttributesUpdateRequest.callback.accept(resultCode);
+            stopWaitForUpdateSatelliteEnableAttributesResponseTimer(
+                    satelliteEnableAttributesUpdateRequest);
+            setSatelliteEnableAttributesUpdateRequest(null);
         }
     }
 
@@ -7308,7 +7816,7 @@ public class SatelliteController extends Handler {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public long getDemoPointingAlignedDurationMillis() {
-        return mDemoPointingAlignedDurationMillis;
+        return mDemoPointingAlignedDurationMillis.get();
     }
 
     private long getDemoPointingNotAlignedDurationMillisFromResources() {
@@ -7325,7 +7833,7 @@ public class SatelliteController extends Handler {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public long getDemoPointingNotAlignedDurationMillis() {
-        return mDemoPointingNotAlignedDurationMillis;
+        return mDemoPointingNotAlignedDurationMillis.get();
     }
 
     /** Returns {@code true} if WWAN is in service, else {@code false}.*/
@@ -7417,26 +7925,23 @@ public class SatelliteController extends Handler {
      * Set last emergency call time to the current time.
      */
     public void setLastEmergencyCallTime() {
-        synchronized (mLock) {
-            mLastEmergencyCallTime = getElapsedRealtime();
-            plogd("mLastEmergencyCallTime=" + mLastEmergencyCallTime);
-        }
+        mLastEmergencyCallTime.set(getElapsedRealtime());
+        plogd("mLastEmergencyCallTime=" + mLastEmergencyCallTime.get());
     }
 
     /**
      * Check if satellite is in emergency mode.
      */
     public boolean isInEmergencyMode() {
-        synchronized (mLock) {
-            if (mLastEmergencyCallTime == 0) return false;
+        if (mLastEmergencyCallTime.get() == 0) return false;
 
-            long currentTime = getElapsedRealtime();
-            if ((currentTime - mLastEmergencyCallTime) <= mSatelliteEmergencyModeDurationMillis) {
-                plogd("Satellite is in emergency mode");
-                return true;
-            }
-            return false;
+        long currentTime = getElapsedRealtime();
+        if ((currentTime - mLastEmergencyCallTime.get())
+                <= mSatelliteEmergencyModeDurationMillis.get()) {
+            plogd("Satellite is in emergency mode");
+            return true;
         }
+        return false;
     }
 
     private long getSatelliteEmergencyModeDurationFromOverlayConfig(@NonNull Context context) {
@@ -7480,84 +7985,80 @@ public class SatelliteController extends Handler {
         // Key : priority - lower value has higher priority; Value : List<SubscriptionInfo>
         TreeMap<Integer, List<SubscriptionInfo>> newSubsInfoListPerPriority = new TreeMap<>();
         plogd("evaluateESOSProfilesPrioritization: allSubInfos.size()=" + allSubInfos.size());
-        synchronized (mSatelliteTokenProvisionedLock) {
-            for (SubscriptionInfo info : allSubInfos) {
-                int subId = info.getSubscriptionId();
-                boolean isActive = info.isActive();
-                boolean isDefaultSmsSubId =
-                        mSubscriptionManagerService.getDefaultSmsSubId() == subId;
-                boolean isNtnOnly = info.isOnlyNonTerrestrialNetwork();
-                boolean isESOSSupported = info.isSatelliteESOSSupported();
-                boolean isCarrierSatelliteHigherPriority =
+        for (SubscriptionInfo info : allSubInfos) {
+            int subId = info.getSubscriptionId();
+            boolean isActive = info.isActive();
+            boolean isDefaultSmsSubId =
+                    mSubscriptionManagerService.getDefaultSmsSubId() == subId;
+            boolean isNtnOnly = info.isOnlyNonTerrestrialNetwork();
+            boolean isESOSSupported = info.isSatelliteESOSSupported();
+            boolean isCarrierSatelliteHigherPriority =
                     isCarrierSatelliteHigherPriority(info);
-                if (!isNtnOnly && !isESOSSupported) {
-                    continue;
-                }
-                if (!isActive && !isNtnOnly) {
-                    continue;
-                }
-                if (!isNtnOnly && !isCarrierConfigLoaded(subId)) {
-                    // Skip to add priority list if the carrier config is not loaded properly
-                    // for the given carrier subscription.
-                    continue;
-                }
+            if (!isNtnOnly && !isESOSSupported) {
+                continue;
+            }
+            if (!isActive && !isNtnOnly) {
+                continue;
+            }
+            if (!isNtnOnly && !isCarrierConfigLoaded(subId)) {
+                // Skip to add priority list if the carrier config is not loaded properly
+                // for the given carrier subscription.
+                continue;
+            }
 
-                int keyPriority = (isESOSSupported && isActive && isDefaultSmsSubId
+            int keyPriority = (isESOSSupported && isActive && isDefaultSmsSubId
                     && isCarrierSatelliteHigherPriority)
                     ? 0 : (isESOSSupported && isActive &&
-                        isCarrierSatelliteHigherPriority)
-                        ? 1 : (isNtnOnly)
-                            ? 2 : (isESOSSupported)
-                                ? 3 : -1;
-                if (keyPriority != -1) {
-                    newSubsInfoListPerPriority.computeIfAbsent(keyPriority,
-                            k -> new ArrayList<>()).add(info);
-                } else {
-                    plogw("evaluateESOSProfilesPrioritization: Got -1 keyPriority for subId="
-                            + info.getSubscriptionId());
-                }
+                    isCarrierSatelliteHigherPriority)
+                    ? 1 : (isNtnOnly)
+                    ? 2 : (isESOSSupported)
+                    ? 3 : -1;
+            if (keyPriority != -1) {
+                newSubsInfoListPerPriority.computeIfAbsent(keyPriority,
+                        k -> new ArrayList<>()).add(info);
+            } else {
+                plogw("evaluateESOSProfilesPrioritization: Got -1 keyPriority for subId="
+                        + info.getSubscriptionId());
+            }
 
-                Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(info);
-                String newSubscriberId = subscriberIdPair.first;
-                Optional<String> oldSubscriberId = mSubscriberIdPerSub.entrySet().stream()
-                        .filter(entry -> entry.getValue().equals(subId))
-                        .map(Map.Entry::getKey).findFirst();
-
-                if (oldSubscriberId.isPresent()
-                        && !newSubscriberId.equals(oldSubscriberId.get())) {
-                    mSubscriberIdPerSub.remove(oldSubscriberId.get());
-                    mProvisionedSubscriberId.remove(oldSubscriberId.get());
-                    logd("Old phone number is removed: id = " + subId);
-                    isChanged = true;
-                }
-                if (!newSubscriberId.isEmpty()) {
-                    mSubscriberIdPerSub.put(newSubscriberId, subId);
-                }
+            Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(info);
+            String newSubscriberId = subscriberIdPair.first;
+            Optional<String> oldSubscriberId = mSubscriberIdPerSub.entrySet().stream()
+                    .filter(entry -> entry.getValue().equals(subId))
+                    .map(Map.Entry::getKey).findFirst();
+
+            if (oldSubscriberId.isPresent()
+                    && !newSubscriberId.equals(oldSubscriberId.get())) {
+                mSubscriberIdPerSub.remove(oldSubscriberId.get());
+                mProvisionedSubscriberId.remove(oldSubscriberId.get());
+                logd("Old phone number is removed: id = " + subId);
+                isChanged = true;
+            }
+            if (!newSubscriberId.isEmpty()) {
+                mSubscriberIdPerSub.put(newSubscriberId, subId);
             }
         }
         plogd("evaluateESOSProfilesPrioritization: newSubsInfoListPerPriority.size()="
                   + newSubsInfoListPerPriority.size());
 
-        if (!mHasSentBroadcast && newSubsInfoListPerPriority.size() == 0) {
+        if (!mHasSentBroadcast.get() && newSubsInfoListPerPriority.size() == 0) {
             logd("evaluateESOSProfilesPrioritization: no satellite subscription available");
             return;
         }
 
         // If priority has changed, send broadcast for provisioned ESOS subs IDs
-        synchronized (mSatelliteTokenProvisionedLock) {
-            List<SatelliteSubscriberProvisionStatus> newEvaluatedSubscriberProvisionStatus =
-                    getPrioritizedSatelliteSubscriberProvisionStatusList(
-                            newSubsInfoListPerPriority);
-            if (isPriorityChanged(mSubsInfoListPerPriority, newSubsInfoListPerPriority)
-                    || isSubscriberContentChanged(mLastEvaluatedSubscriberProvisionStatus,
-                            newEvaluatedSubscriberProvisionStatus)
-                    || isChanged) {
-                mSubsInfoListPerPriority = newSubsInfoListPerPriority;
-                mLastEvaluatedSubscriberProvisionStatus = newEvaluatedSubscriberProvisionStatus;
-                sendBroadCastForProvisionedESOSSubs();
-                mHasSentBroadcast = true;
-                selectBindingSatelliteSubscription(false);
-            }
+        List<SatelliteSubscriberProvisionStatus> newEvaluatedSubscriberProvisionStatus =
+                getPrioritizedSatelliteSubscriberProvisionStatusList(
+                        newSubsInfoListPerPriority);
+        if (isPriorityChanged(getSubsInfoListPerPriority(), newSubsInfoListPerPriority)
+                || isSubscriberContentChanged(getLastEvaluatedSubscriberProvisionStatus(),
+                newEvaluatedSubscriberProvisionStatus)
+                || isChanged) {
+            setSubsInfoListPerPriority(newSubsInfoListPerPriority);
+            setLastEvaluatedSubscriberProvisionStatus(newEvaluatedSubscriberProvisionStatus);
+            sendBroadCastForProvisionedESOSSubs();
+            mHasSentBroadcast.set(true);
+            selectBindingSatelliteSubscription(false);
         }
     }
 
@@ -7691,11 +8192,7 @@ public class SatelliteController extends Handler {
 
         Intent intent = new Intent(action);
         intent.setComponent(new ComponentName(packageName, className));
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } else {
-            mContext.sendBroadcast(intent);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
         logd("sendBroadCastForProvisionedESOSSubs" + intent);
     }
 
@@ -7718,6 +8215,18 @@ public class SatelliteController extends Handler {
      *               or an error code if the request failed.
      */
     public void requestSatelliteDisplayName(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_SATELLITE_DISPLAY_NAME, args));
+            return;
+        }
+
+        handleRequestSatelliteDisplayName(result);
+    }
+
+    private void handleRequestSatelliteDisplayName(@NonNull ResultReceiver result) {
+        plogd("handleRequestSatelliteDisplayName");
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             plogd("requestSatelliteDisplayName: carrierRoamingNbIotNtn flag is disabled");
             result.send(SatelliteManager.SATELLITE_RESULT_NOT_SUPPORTED, null);
@@ -7741,6 +8250,16 @@ public class SatelliteController extends Handler {
      * to be used for provision if the request is successful or an error code if the request failed.
      */
     public void requestSatelliteSubscriberProvisionStatus(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_SATELLITE_SUBSCRIBER_PROVISION_STATUS, args));
+        }
+
+        handleRequestSatelliteSubscriberProvisionStatus(result);
+    }
+
+    private void handleRequestSatelliteSubscriberProvisionStatus(@NonNull ResultReceiver result) {
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             logd("requestSatelliteSubscriberProvisionStatus: carrierRoamingNbIotNtn is disabled");
             result.send(SATELLITE_RESULT_REQUEST_NOT_SUPPORTED, null);
@@ -7756,62 +8275,59 @@ public class SatelliteController extends Handler {
 
     private List<SatelliteSubscriberProvisionStatus>
             getPrioritizedSatelliteSubscriberProvisionStatusList() {
-        synchronized (mSatelliteTokenProvisionedLock) {
-            return getPrioritizedSatelliteSubscriberProvisionStatusList(mSubsInfoListPerPriority);
-        }
+        return getPrioritizedSatelliteSubscriberProvisionStatusList(getSubsInfoListPerPriority());
     }
 
+    @NonNull
     private List<SatelliteSubscriberProvisionStatus>
             getPrioritizedSatelliteSubscriberProvisionStatusList(
                     Map<Integer, List<SubscriptionInfo>> subsInfoListPerPriority) {
         List<SatelliteSubscriberProvisionStatus> list = new ArrayList<>();
-        synchronized (mSatelliteTokenProvisionedLock) {
-            for (int priority : subsInfoListPerPriority.keySet()) {
-                List<SubscriptionInfo> infoList = subsInfoListPerPriority.get(priority);
-                if (infoList == null) {
-                    logd("getPrioritySatelliteSubscriberProvisionStatusList: no exist this "
-                            + "priority " + priority);
+        for (int priority : subsInfoListPerPriority.keySet()) {
+            List<SubscriptionInfo> infoList = subsInfoListPerPriority.get(priority);
+            if (infoList == null) {
+                logd("getPrioritySatelliteSubscriberProvisionStatusList: no exist this "
+                        + "priority " + priority);
+                continue;
+            }
+            for (SubscriptionInfo info : infoList) {
+                Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(info);
+                String subscriberId = subscriberIdPair.first;
+                int carrierId = info.getCarrierId();
+                String apn = getConfigForSubId(info.getSubscriptionId())
+                        .getString(KEY_SATELLITE_NIDD_APN_NAME_STRING, "");
+                logd("getPrioritySatelliteSubscriberProvisionStatusList:"
+                        + " subscriberId:"
+                        + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, subscriberId)
+                        + " , carrierId=" + carrierId + " , apn=" + apn);
+                if (subscriberId.isEmpty()) {
+                    logd("getPrioritySatelliteSubscriberProvisionStatusList: getSubscriberId "
+                            + "failed skip this subscriberId.");
                     continue;
                 }
-                for (SubscriptionInfo info : infoList) {
-                    Pair<String, Integer> subscriberIdPair = getSubscriberIdAndType(info);
-                    String subscriberId = subscriberIdPair.first;
-                    int carrierId = info.getCarrierId();
-                    String apn = getConfigForSubId(info.getSubscriptionId())
-                            .getString(KEY_SATELLITE_NIDD_APN_NAME_STRING, "");
-                    logd("getPrioritySatelliteSubscriberProvisionStatusList:"
-                            + " subscriberId:"
-                            + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, subscriberId)
-                            + " , carrierId=" + carrierId + " , apn=" + apn);
-                    if (subscriberId.isEmpty()) {
-                        logd("getPrioritySatelliteSubscriberProvisionStatusList: getSubscriberId "
-                                + "failed skip this subscriberId.");
-                        continue;
-                    }
-                    SatelliteSubscriberInfo satelliteSubscriberInfo =
-                            new SatelliteSubscriberInfo.Builder().setSubscriberId(subscriberId)
-                                    .setCarrierId(carrierId).setNiddApn(apn)
-                                    .setSubscriptionId(info.getSubscriptionId())
-                                    .setSubscriberIdType(subscriberIdPair.second)
-                                    .build();
-                    boolean provisioned = mProvisionedSubscriberId.getOrDefault(subscriberId,
-                            false);
-                    logd("getPrioritySatelliteSubscriberProvisionStatusList: "
-                            + "satelliteSubscriberInfo=" + satelliteSubscriberInfo
-                            + ", provisioned=" + provisioned);
-                    list.add(new SatelliteSubscriberProvisionStatus.Builder()
-                            .setSatelliteSubscriberInfo(satelliteSubscriberInfo)
-                            .setProvisioned(provisioned).build());
-                    mSubscriberIdPerSub.put(subscriberId, info.getSubscriptionId());
-                }
+                SatelliteSubscriberInfo satelliteSubscriberInfo =
+                        new SatelliteSubscriberInfo.Builder().setSubscriberId(subscriberId)
+                                .setCarrierId(carrierId).setNiddApn(apn)
+                                .setSubscriptionId(info.getSubscriptionId())
+                                .setSubscriberIdType(subscriberIdPair.second)
+                                .build();
+                boolean provisioned = mProvisionedSubscriberId.getOrDefault(subscriberId,
+                        false);
+                logd("getPrioritySatelliteSubscriberProvisionStatusList: "
+                        + "satelliteSubscriberInfo=" + satelliteSubscriberInfo
+                        + ", provisioned=" + provisioned);
+                list.add(new SatelliteSubscriberProvisionStatus.Builder()
+                        .setSatelliteSubscriberInfo(satelliteSubscriberInfo)
+                        .setProvisioned(provisioned).build());
+                mSubscriberIdPerSub.put(subscriberId, info.getSubscriptionId());
             }
         }
         return list;
     }
 
     public int getSelectedSatelliteSubId() {
-        plogd("getSelectedSatelliteSubId: subId=" + mSelectedSatelliteSubId);
-        return mSelectedSatelliteSubId;
+        plogd("getSelectedSatelliteSubId: subId=" + mSelectedSatelliteSubId.get());
+        return mSelectedSatelliteSubId.get();
     }
 
     /**
@@ -7821,6 +8337,18 @@ public class SatelliteController extends Handler {
      *               id if the request is successful or an error code if the request failed.
      */
     public void requestSelectedNbIotSatelliteSubscriptionId(@NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = result;
+            sendMessage(obtainMessage(REQUEST_SELECTED_NB_IOT_SATELLITE_SUBSCRIPTION_ID, args));
+            return;
+        }
+
+        handleRequestSelectedNbIotSatelliteSubscriptionId(result);
+    }
+
+    private void handleRequestSelectedNbIotSatelliteSubscriptionId(@NonNull ResultReceiver result) {
+        plogd("handleRequestSelectedNbIotSatelliteSubscriptionId");
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             result.send(SATELLITE_RESULT_REQUEST_NOT_SUPPORTED, null);
             logd("requestSelectedNbIotSatelliteSubscriptionId: carrierRoamingNbIotNtn is disabled");
@@ -7910,10 +8438,16 @@ public class SatelliteController extends Handler {
             plogd("isSatelliteAvailableAtCurrentLocation: subscriptionInfo is null");
             return false;
         }
-        if (mCtsSatelliteAccessAllowedSubIds.contains(info.getSubscriptionId())) {
-            plogd("isSatelliteAvailableAtCurrentLocation: subscriptionId="
-                      + info.getSubscriptionId() + " is allowed for CTS testing");
-            return true;
+        if (mCtsSatelliteAccessAllowedSubIds != null) {
+            if (mCtsSatelliteAccessAllowedSubIds.contains(info.getSubscriptionId())) {
+                plogd("isSatelliteAvailableAtCurrentLocation: subscriptionId="
+                        + info.getSubscriptionId() + " is allowed for CTS testing");
+                return true;
+            } else {
+                plogd("isSatelliteAvailableAtCurrentLocation: subscriptionId="
+                        + info.getSubscriptionId() + " is not allowed for CTS testing");
+                return false;
+            }
         }
         if (!isSatelliteAccessAllowedAtCurrentLocation()) {
             plogd("isSatelliteAvailableAtCurrentLocation: satellite access is not allowed at " +
@@ -7977,16 +8511,12 @@ public class SatelliteController extends Handler {
      */
     public boolean isCarrierSatelliteAvailableAtCurrentLocation(
         List<Integer> carrierTagIds) {
-        synchronized (mSatelliteAccessConfigLock) {
-            return !Collections.disjoint(carrierTagIds, mCurrentLocationTagIds);
-        }
+        return !Collections.disjoint(carrierTagIds, getCurrentLocationTagIds());
     }
 
     private int getSubIdFromSubscriberId(String subscriberId) {
-        synchronized (mSatelliteTokenProvisionedLock) {
-            return mSubscriberIdPerSub.getOrDefault(subscriberId,
-                    SubscriptionManager.INVALID_SUBSCRIPTION_ID);
-        }
+        return mSubscriberIdPerSub.getOrDefault(subscriberId,
+                SubscriptionManager.INVALID_SUBSCRIPTION_ID);
     }
 
     private boolean isActiveSubId(int subId) {
@@ -8013,9 +8543,7 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mSatelliteTokenProvisionedLock) {
-            return mProvisionedSubscriberId.getOrDefault(subscriberId, false);
-        }
+        return mProvisionedSubscriberId.getOrDefault(subscriberId, false);
     }
 
     /**
@@ -8026,6 +8554,18 @@ public class SatelliteController extends Handler {
      */
     public void provisionSatellite(@NonNull List<SatelliteSubscriberInfo> list,
             @NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = list;
+            args.arg2 = result;
+            sendMessage(obtainMessage(REQUEST_PROVISION_SATELLITE, args));
+        }
+
+        handleRequestProvisionSatellite(list, result);
+    }
+
+    private void handleRequestProvisionSatellite(@NonNull List<SatelliteSubscriberInfo> list,
+            @NonNull ResultReceiver result) {
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             result.send(SATELLITE_RESULT_REQUEST_NOT_SUPPORTED, null);
             logd("provisionSatellite: carrierRoamingNbIotNtn not support");
@@ -8075,13 +8615,12 @@ public class SatelliteController extends Handler {
             logd("getRegionalSatelliteEarfcns: carrierRoamingNbIotNtnFlag is disabled");
             return new HashMap<>();
         }
-        synchronized (mRegionalSatelliteEarfcnsLock) {
-            if (mRegionalSatelliteEarfcns.containsKey(subId)) {
-                return mRegionalSatelliteEarfcns.get(subId);
-            } else {
-                logd("getRegionalSatelliteEarfcns: Earfcns for subId: " + subId + " not found");
-                return new HashMap<>();
-            }
+
+        if (mRegionalSatelliteEarfcns.containsKey(subId)) {
+            return mRegionalSatelliteEarfcns.get(subId);
+        } else {
+            logd("getRegionalSatelliteEarfcns: Earfcns for subId: " + subId + " not found");
+            return new HashMap<>();
         }
     }
 
@@ -8096,10 +8635,8 @@ public class SatelliteController extends Handler {
             return;
         }
 
-        synchronized (mRegionalSatelliteEarfcnsLock) {
-            mRegionalSatelliteEarfcns.put(subId,
-                    readRegionalSatelliteEarfcnsFromCarrierConfig(subId));
-        }
+        mRegionalSatelliteEarfcns.put(subId,
+                readRegionalSatelliteEarfcnsFromCarrierConfig(subId));
     }
 
     /**
@@ -8110,6 +8647,18 @@ public class SatelliteController extends Handler {
      */
     public void deprovisionSatellite(@NonNull List<SatelliteSubscriberInfo> list,
             @NonNull ResultReceiver result) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = list;
+            args.arg2 = result;
+            sendMessage(obtainMessage(REQUEST_DEPROVISION_SATELLITE, args));
+        }
+
+        handleRequestDeprovisionSatellite(list, result);
+    }
+
+    private void handleRequestDeprovisionSatellite(@NonNull List<SatelliteSubscriberInfo> list,
+            @NonNull ResultReceiver result) {
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             result.send(SATELLITE_RESULT_REQUEST_NOT_SUPPORTED, null);
             logd("deprovisionSatellite: carrierRoamingNbIotNtn not support");
@@ -8137,6 +8686,17 @@ public class SatelliteController extends Handler {
      * @param ntnSmsSupported {@code true} If application supports NTN SMS, else {@code false}.
      */
     public void setNtnSmsSupportedByMessagesApp(boolean ntnSmsSupported) {
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = ntnSmsSupported;
+            sendMessage(obtainMessage(REQUEST_SET_NTN_SMS_SUPPORTED_BY_MESSAGES_APP, args));
+            return;
+        }
+
+        handleRequestSetNtnSmsSupportedByMessagesApp(ntnSmsSupported);
+    }
+
+    private void handleRequestSetNtnSmsSupportedByMessagesApp(boolean ntnSmsSupported) {
         if (!mFeatureFlags.carrierRoamingNbIotNtn()) {
             return;
         }
@@ -8153,18 +8713,22 @@ public class SatelliteController extends Handler {
         } else {
             mSharedPreferences.edit().putBoolean(
                     NTN_SMS_SUPPORTED_BY_MESSAGES_APP_KEY, ntnSmsSupported).apply();
-            synchronized (mNtnSmsSupportedByMessagesAppLock) {
-                mNtnSmsSupportedByMessagesApp = ntnSmsSupported;
-            }
+            setNtnSmsSupportedByMessagesAppCache(ntnSmsSupported);
+        }
+    }
+
+    private void setNtnSmsSupportedByMessagesAppCache(boolean ntnSmsSupported) {
+        if (mNtnSmsSupportedByMessagesApp == null) {
+            mNtnSmsSupportedByMessagesApp = new AtomicBoolean(ntnSmsSupported);
+        } else {
+            mNtnSmsSupportedByMessagesApp.set(ntnSmsSupported);
         }
     }
 
     private boolean isNtnSmsSupportedByMessagesApp() {
-        synchronized (mNtnSmsSupportedByMessagesAppLock) {
-            if (mNtnSmsSupportedByMessagesApp != null) {
-                plogd("isNtnSmsSupportedByMessagesApp:" + mNtnSmsSupportedByMessagesApp);
-                return mNtnSmsSupportedByMessagesApp;
-            }
+        if (mNtnSmsSupportedByMessagesApp != null) {
+            plogd("isNtnSmsSupportedByMessagesApp:" + mNtnSmsSupportedByMessagesApp.get());
+            return mNtnSmsSupportedByMessagesApp.get();
         }
 
         if (!loadSatelliteSharedPreferences()) return false;
@@ -8175,35 +8739,46 @@ public class SatelliteController extends Handler {
         } else {
             boolean ntnSmsSupported = mSharedPreferences.getBoolean(
                     NTN_SMS_SUPPORTED_BY_MESSAGES_APP_KEY, false);
-            synchronized (mNtnSmsSupportedByMessagesAppLock) {
-                mNtnSmsSupportedByMessagesApp = ntnSmsSupported;
-                plogd("isNtnSmsSupportedByMessagesApp:" + mNtnSmsSupportedByMessagesApp);
-            }
+            setNtnSmsSupportedByMessagesAppCache(ntnSmsSupported);
+            plogd("isNtnSmsSupportedByMessagesApp:" + ntnSmsSupported);
             return ntnSmsSupported;
         }
     }
 
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    protected void setSatellitePhone(int subId) {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected void setSatellitePhone(int subId) {
+        Phone phone = SatelliteServiceUtils.getPhone(subId);
+        setSatellitePhone(phone);
+        plogd("setSatellitePhone: phoneId=" + (phone != null
+                ? phone.getPhoneId() : "null") + ", subId=" + subId);
+    }
+
+    /** set satellite phone */
+    private void setSatellitePhone(@Nullable Phone phone) {
+        synchronized (mSatellitePhoneLock) {
+            mSatellitePhone = phone;
+        }
+    }
+
+    /** return satellite phone */
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
+    @Nullable
+    protected Phone getSatellitePhone() {
         synchronized (mSatellitePhoneLock) {
-            mSatellitePhone = SatelliteServiceUtils.getPhone(subId);
-            plogd("mSatellitePhone: phoneId=" + (mSatellitePhone != null
-                      ? mSatellitePhone.getPhoneId() : "null") + ", subId=" + subId);
+            return mSatellitePhone;
         }
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected void setSelectedSatelliteSubId(int subId) {
-        synchronized (mSatelliteTokenProvisionedLock) {
-            plogd("setSelectedSatelliteSubId: subId=" + subId);
-            mSelectedSatelliteSubId = subId;
-        }
+        plogd("setSelectedSatelliteSubId: subId=" + subId);
+        mSelectedSatelliteSubId.set(subId);
     }
 
     /** Return the carrier ID of the binding satellite subscription. */
     public int getSatelliteCarrierId() {
         SubscriptionInfo subInfo = mSubscriptionManagerService.getSubscriptionInfo(
-            mSelectedSatelliteSubId);
+            mSelectedSatelliteSubId.get());
         if (subInfo == null) {
             logd("getSatelliteCarrierId: returns UNKNOWN_CARRIER_ID");
             return UNKNOWN_CARRIER_ID;
@@ -8232,7 +8807,7 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        if (!mIsRadioOn) {
+        if (!mIsRadioOn.get()) {
             plogd("isCarrierRoamingNtnEligible: radio is off");
             return false;
         }
@@ -8298,12 +8873,10 @@ public class SatelliteController extends Handler {
             return false;
         }
 
-        synchronized (mIsWifiConnectedLock) {
-            if (mIsWifiConnected) {
-                plogd("isCarrierRoamingNtnEligible[phoneId=" + phone.getPhoneId()
-                        + "]: Wi-Fi is connected");
-                return false;
-            }
+        if (mIsWifiConnected.get()) {
+            plogd("isCarrierRoamingNtnEligible[phoneId=" + phone.getPhoneId()
+                    + "]: Wi-Fi is connected");
+            return false;
         }
 
         return true;
@@ -8328,24 +8901,14 @@ public class SatelliteController extends Handler {
         return false;
     }
 
-    /** return satellite phone */
-    @Nullable
-    public Phone getSatellitePhone() {
-        synchronized (mSatellitePhoneLock) {
-            return mSatellitePhone;
-        }
-    }
-
     /** Start PointingUI if it is required. */
     public void startPointingUI() {
-        synchronized (mNeedsSatellitePointingLock) {
-            plogd("startPointingUI: mNeedsSatellitePointing=" + mNeedsSatellitePointing
-                    + ", mIsDemoModeEnabled=" + mIsDemoModeEnabled
-                    + ", mIsEmergency=" + mIsEmergency);
-            if (mNeedsSatellitePointing) {
-                mPointingAppController.startPointingUI(false /*needFullScreenPointingUI*/,
-                        mIsDemoModeEnabled, mIsEmergency);
-            }
+        plogd("startPointingUI: mNeedsSatellitePointing=" + mNeedsSatellitePointing.get()
+                + ", mIsDemoModeEnabled=" + mIsDemoModeEnabled.get()
+                + ", mIsEmergency=" + mIsEmergency.get());
+        if (mNeedsSatellitePointing.get()) {
+            mPointingAppController.startPointingUI(false /*needFullScreenPointingUI*/,
+                    mIsDemoModeEnabled.get(), mIsEmergency.get());
         }
     }
 
@@ -8370,11 +8933,10 @@ public class SatelliteController extends Handler {
                 public void onAccessAllowedStateChanged(boolean isAllowed) {
                     plogd("onAccessStateChanged: isAllowed=" + isAllowed);
                     if (mFeatureFlags.satelliteExitP2pSessionOutsideGeofence()) {
-                        handleSatelliteAccessAllowedStateChanged(isAllowed);
-                    } else{
-                        synchronized (mSatelliteAccessConfigLock) {
-                            mSatelliteAccessAllowed = isAllowed;
-                        }
+                        sendMessage(obtainMessage(EVENT_SATELLITE_ACCESS_ALLOWED_STATE_CHANGED,
+                            isAllowed));
+                    } else {
+                        mSatelliteAccessAllowed.set(isAllowed);
                         evaluateESOSProfilesPrioritization();
                         evaluateCarrierRoamingNtnEligibilityChange();
                         handleCarrierRoamingNtnAvailableServicesChanged();
@@ -8386,6 +8948,12 @@ public class SatelliteController extends Handler {
                     SatelliteAccessConfiguration satelliteAccessConfiguration) {
                     plogd("onAccessConfigurationChanged: satelliteAccessConfiguration="
                         + satelliteAccessConfiguration);
+                    if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+                        sendMessage(obtainMessage(EVENT_SATELLITE_ACCESS_CONFIGURATION_CHANGED,
+                                satelliteAccessConfiguration));
+                        return;
+                    }
+
                     handleSatelliteAccessConfigUpdateResult(satelliteAccessConfiguration);
                 }
             };
@@ -8405,10 +8973,7 @@ public class SatelliteController extends Handler {
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public void handleSatelliteAccessAllowedStateChanged(boolean isAllowed) {
         plogd("handleSatelliteAccessAllowedStateChanged: isAllowed=" + isAllowed);
-        synchronized (mSatelliteAccessConfigLock) {
-            mSatelliteAccessAllowed = isAllowed;
-        }
-
+        mSatelliteAccessAllowed.set(isAllowed);
         evaluateESOSProfilesPrioritization();
         selectBindingSatelliteSubscription(false);
         evaluateCarrierRoamingNtnEligibilityChange();
@@ -8446,15 +9011,13 @@ public class SatelliteController extends Handler {
     private void handleSatelliteAccessConfigUpdateResult(
         SatelliteAccessConfiguration satelliteAccessConfig) {
         if(satelliteAccessConfig != null) {
-            synchronized (mSatelliteAccessConfigLock) {
-                plogd("handleSatelliteAccessConfigUpdateResult:" + " satelliteAccessConfig="
+            plogd("handleSatelliteAccessConfigUpdateResult:" + " satelliteAccessConfig="
                     + satelliteAccessConfig);
-                List<Integer> tagIds = satelliteAccessConfig.getTagIds();
-                if (!mCurrentLocationTagIds.equals(tagIds)) {
-                    mCurrentLocationTagIds = tagIds;
-                    sendMessageDelayed(obtainMessage(CMD_EVALUATE_ESOS_PROFILES_PRIORITIZATION),
-                        mEvaluateEsosProfilesPrioritizationDurationMillis);
-                }
+            List<Integer> tagIds = satelliteAccessConfig.getTagIds();
+            if (!getCurrentLocationTagIds().equals(tagIds)) {
+                setCurrentLocationTagIds(tagIds);
+                sendMessageDelayed(obtainMessage(CMD_EVALUATE_ESOS_PROFILES_PRIORITIZATION),
+                        mEvaluateEsosProfilesPrioritizationDurationMillis.get());
             }
         } else {
                 plogd("handleSatelliteAccessConfigUpdateResult: "
@@ -8462,6 +9025,19 @@ public class SatelliteController extends Handler {
         }
     }
 
+    private void setCurrentLocationTagIds(@NonNull List<Integer> currentLocationTagIds) {
+        synchronized (mSatelliteAccessConfigLock) {
+            mCurrentLocationTagIds = currentLocationTagIds;
+        }
+    }
+
+    @NonNull
+    private List<Integer> getCurrentLocationTagIds() {
+        synchronized (mSatelliteAccessConfigLock) {
+            return mCurrentLocationTagIds;
+        }
+    }
+
     private void handleEventSatelliteRegistrationFailure(int causeCode) {
         plogd("handleEventSatelliteRegistrationFailure: " + causeCode);
 
@@ -8501,7 +9077,7 @@ public class SatelliteController extends Handler {
             mTerrestrialNetworkAvailableChangedListeners.remove(listener.asBinder());
         });
 
-        if (isAvailable && !mIsEmergency) {
+        if (isAvailable && !mIsEmergency.get()) {
             requestSatelliteEnabled(
                     false /* enableSatellite */, false /* enableDemoMode */,
                     false /* isEmergency */,
@@ -8540,9 +9116,9 @@ public class SatelliteController extends Handler {
         logd("setSatelliteSubscriberIdListChangedIntentComponent:" + name);
 
         if (name.contains("/")) {
-            mChangeIntentComponent = true;
+            mChangeIntentComponent.set(true);
         } else {
-            mChangeIntentComponent = false;
+            mChangeIntentComponent.set(false);
             return true;
         }
         boolean result = true;
@@ -8568,41 +9144,49 @@ public class SatelliteController extends Handler {
      * This API can be used by only CTS to override the satellite access allowed state for
      * a list of subscription IDs.
      *
+     * @param reset {@code true} mean the overridden configs should not be used, {@code false}
+     *              otherwise.
      * @param subIdListStr The string representation of the list of subscription IDs,
      *                     which are numbers separated by comma.
      * @return {@code true} if the satellite access allowed state is set successfully,
      * {@code false} otherwise.
      */
-    public boolean setSatelliteAccessAllowedForSubscriptions(@Nullable String subIdListStr) {
+    public boolean setSatelliteAccessAllowedForSubscriptions(
+        boolean reset, @Nullable String subIdListStr) {
         if (!isMockModemAllowed()) {
             plogd("setSatelliteAccessAllowedForSubscriptions: mock modem not allowed");
             return false;
         }
 
-        plogd("setSatelliteAccessAllowedForSubscriptions: subIdListStr=" + subIdListStr);
-        if (subIdListStr == null) {
-            mCtsSatelliteAccessAllowedSubIds.clear();
-            return true;
-        }
-
-        List<Integer> subIdList = new ArrayList<>();
-        for (String subIdStr : subIdListStr.split(",")) {
-            try {
-                subIdList.add(Integer.parseInt(subIdStr));
-            } catch (NumberFormatException e) {
-                plogd("setSatelliteAccessAllowedForSubscriptions: invalid subIdStr=" + subIdStr);
-                return false;
+        plogd("setSatelliteAccessAllowedForSubscriptions: subIdListStr=" + subIdListStr
+                  + " reset=" + reset);
+        boolean result = true;
+        if (reset) {
+            mCtsSatelliteAccessAllowedSubIds = null;
+        } else {
+            mCtsSatelliteAccessAllowedSubIds = new ArrayList<>();
+            if (!TextUtils.isEmpty(subIdListStr)) {
+                for (String subIdStr : subIdListStr.split(",")) {
+                    try {
+                        mCtsSatelliteAccessAllowedSubIds.add(Integer.parseInt(subIdStr));
+                    } catch (NumberFormatException e) {
+                        plogd("setSatelliteAccessAllowedForSubscriptions: invalid subIdStr="
+                                + subIdStr);
+                        mCtsSatelliteAccessAllowedSubIds = null;
+                        result = false;
+                    }
+                }
             }
         }
-        mCtsSatelliteAccessAllowedSubIds.clear();
-        mCtsSatelliteAccessAllowedSubIds.addAll(subIdList);
-        selectBindingSatelliteSubscription(false);
-        return true;
+        boolean isAllowed = mSatelliteAccessAllowed.get();
+        plogd("setSatelliteAccessAllowedForSubscriptions: isAllowed=" + isAllowed);
+        sendMessage(obtainMessage(EVENT_SATELLITE_ACCESS_ALLOWED_STATE_CHANGED, isAllowed));
+        return result;
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected String getConfigSatelliteGatewayServicePackage() {
-        if (!mChangeIntentComponent) {
+        if (!mChangeIntentComponent.get()) {
             return getStringFromOverlayConfig(
                     R.string.config_satellite_gateway_service_package);
         }
@@ -8611,7 +9195,7 @@ public class SatelliteController extends Handler {
     }
 
     private String getConfigSatelliteCarrierRoamingEsosProvisionedClass() {
-        if (!mChangeIntentComponent) {
+        if (!mChangeIntentComponent.get()) {
             return getStringFromOverlayConfig(
                     R.string.config_satellite_carrier_roaming_esos_provisioned_class);
         }
@@ -8641,17 +9225,13 @@ public class SatelliteController extends Handler {
     }
 
     private boolean isSatelliteDisabled() {
-        synchronized (mIsSatelliteEnabledLock) {
-            return ((mIsSatelliteEnabled != null) && !mIsSatelliteEnabled);
-        }
+        return ((mIsSatelliteEnabled != null) && !mIsSatelliteEnabled.get());
     }
 
     private boolean shouldStopWaitForEnableResponseTimer(
             @NonNull RequestSatelliteEnabledArgument argument) {
         if (argument.enableSatellite) return true;
-        synchronized (mSatelliteEnabledRequestLock) {
-            return !mWaitingForSatelliteModemOff;
-        }
+        return !mWaitingForSatelliteModemOff.get();
     }
 
     /**
@@ -8672,10 +9252,9 @@ public class SatelliteController extends Handler {
             } else {
                 mOverrideNtnEligibility.set(state);
             }
-            synchronized (mSatellitePhoneLock) {
-                if (this.mSatellitePhone != null) {
-                    updateLastNotifiedNtnEligibilityAndNotify(state);
-                }
+            Phone satellitePhone = getSatellitePhone();
+            if (satellitePhone != null) {
+                updateLastNotifiedNtnEligibilityAndNotify(state);
             }
         }
         return true;
@@ -8776,9 +9355,7 @@ public class SatelliteController extends Handler {
             Map<String, List<Integer>> plmnServiceTypeMap) {
         // If a service list is already cached, check it for changes
         int[] existingServices = getSupportedServicesOnCarrierRoamingNtn(subId);
-        synchronized (mSupportedSatelliteServicesLock) {
-            mEntitlementServiceTypeMapPerCarrier.put(subId, plmnServiceTypeMap);
-        }
+        mEntitlementServiceTypeMapPerCarrier.put(subId, plmnServiceTypeMap);
         int[] updatedServices = getSupportedServicesOnCarrierRoamingNtn(subId);
         if (existingServices.length > 0 && Arrays.equals(existingServices, updatedServices)) {
             plogd("No change in Entitlement service support data");
@@ -8832,24 +9409,22 @@ public class SatelliteController extends Handler {
     }
 
     private int[] getAvailableServicesWithEntitlementForSubId(int subId) {
-        synchronized (mSupportedSatelliteServicesLock) {
-            Map<String, List<Integer>> allowedServicesList =
-                    mEntitlementServiceTypeMapPerCarrier.get(subId);
-            if (allowedServicesList != null && !allowedServicesList.isEmpty()) {
-                Set<Integer> serviceTypes = new HashSet<>();
-                for (List<Integer> values : allowedServicesList.values()) {
-                    serviceTypes.addAll(values);
-                }
+        Map<String, List<Integer>> allowedServicesList =
+                mEntitlementServiceTypeMapPerCarrier.get(subId);
+        if (allowedServicesList != null && !allowedServicesList.isEmpty()) {
+            Set<Integer> serviceTypes = new HashSet<>();
+            for (List<Integer> values : allowedServicesList.values()) {
+                serviceTypes.addAll(values);
+            }
 
-                int[] result = new int[serviceTypes.size()];
-                int i = 0;
-                for (int value : serviceTypes) {
-                    result[i++] = value;
-                }
-                return result;
-            } else {
-                return new int[0]; // Return an empty array if the map is null or empty
+            int[] result = new int[serviceTypes.size()];
+            int i = 0;
+            for (int value : serviceTypes) {
+                result[i++] = value;
             }
+            return result;
+        } else {
+            return new int[0]; // Return an empty array if the map is null or empty
         }
     }
 
@@ -8894,15 +9469,30 @@ public class SatelliteController extends Handler {
             // Manual Connected
             plogd("isP2PSmsDisallowedOnCarrierRoamingNtn: manual connect");
             if (!isNtnSmsSupportedByMessagesApp()
-                    || !isApplicationSupportsP2P(mSatelliteGatewayServicePackageName)) {
+                    || !isApplicationSupportsP2P(getSatelliteGatewayServicePackageName())) {
                 plogd("isP2PSmsDisallowedOnCarrierRoamingNtn: APKs do not supports P2P");
                 return true;
             }
+
+            if (!isSubscriptionProvisioned(subId)) {
+                plogd("isP2PSmsDisallowedOnCarrierRoamingNtn: subId=" + subId
+                        + " is not provisioned.");
+                return true;
+            }
         }
         plogd("isP2PSmsDisallowedOnCarrierRoamingNtn: P2P is supported");
         return false;
     }
 
+    private String getSatelliteGatewayServicePackageName() {
+        if (!TextUtils.isEmpty(mOverriddenSatelliteGatewayServicePackageName)) {
+            logd("getSatelliteGatewayServicePackageName: return overridden package name"
+                    + " for CTS test " + mOverriddenSatelliteGatewayServicePackageName);
+            return mOverriddenSatelliteGatewayServicePackageName;
+        }
+        return mSatelliteGatewayServicePackageName;
+    }
+
     @NonNull
     private int[] getSupportedSatelliteServicesForCarrier(int subId) {
         PersistableBundle config = getPersistableBundle(subId);
@@ -8977,15 +9567,26 @@ public class SatelliteController extends Handler {
         logd("notifyEnabledStateChanged to " + isEnabled);
     }
 
+    private void setNtnSignalStrength(@NonNull NtnSignalStrength ntnSignalStrength) {
+        synchronized (mNtnSignalsStrengthLock) {
+            mNtnSignalStrength = ntnSignalStrength;
+        }
+    }
+
+    @NonNull
+    private NtnSignalStrength getNtnSignalStrength() {
+        synchronized (mNtnSignalsStrengthLock) {
+            return mNtnSignalStrength;
+        }
+    }
+
     private NtnSignalStrength getCarrierRoamingNtnSignalStrength(@NonNull Phone phone) {
         NtnSignalStrength carrierRoamingNtnSignalStrength = new NtnSignalStrength(
                 NTN_SIGNAL_STRENGTH_NONE);
 
         if (isInCarrierRoamingNbIotNtn(phone)) {
             if (isInConnectedState()) {
-                synchronized (mNtnSignalsStrengthLock) {
-                    carrierRoamingNtnSignalStrength = mNtnSignalStrength;
-                }
+                carrierRoamingNtnSignalStrength = getNtnSignalStrength();
                 plogd("getCarrierRoamingNtnSignalStrength[phoneId=" + phone.getPhoneId()
                         + "]: in carrier roaming nb iot ntn mode.");
             }
@@ -9006,18 +9607,16 @@ public class SatelliteController extends Handler {
      * Returns satellite connected state from modem, return true if connected.
      */
     public boolean isInConnectedState() {
-        synchronized (mSatelliteModemStateLock) {
-            switch (mSatelliteModemState) {
-                case SatelliteManager.SATELLITE_MODEM_STATE_CONNECTED: //fallthrough
-                case SatelliteManager.SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING: //fallthrough
-                case SatelliteManager.SATELLITE_MODEM_STATE_DATAGRAM_RETRYING: //fallthrough
-                case SatelliteManager.SATELLITE_MODEM_STATE_IDLE:
-                    plogd("isInConnectedState: return true");
-                    return true;
-                default:
-                    plogd("isInConnectedState: return false");
-                    return false;
-            }
+        switch (mSatelliteModemState.get()) {
+            case SatelliteManager.SATELLITE_MODEM_STATE_CONNECTED: //fallthrough
+            case SatelliteManager.SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING: //fallthrough
+            case SatelliteManager.SATELLITE_MODEM_STATE_DATAGRAM_RETRYING: //fallthrough
+            case SatelliteManager.SATELLITE_MODEM_STATE_IDLE:
+                plogd("isInConnectedState: return true");
+                return true;
+            default:
+                plogd("isInConnectedState: return false");
+                return false;
         }
     }
 
@@ -9030,14 +9629,12 @@ public class SatelliteController extends Handler {
 
         NtnSignalStrength currSignalStrength = getCarrierRoamingNtnSignalStrength(phone);
         int subId = phone.getSubId();
-        synchronized (mSatelliteConnectedLock) {
-            NtnSignalStrength lastNotifiedSignalStrength =
-                    mLastNotifiedCarrierRoamingNtnSignalStrength.get(subId);
-            if (lastNotifiedSignalStrength == null
-                    || lastNotifiedSignalStrength.getLevel() != currSignalStrength.getLevel()) {
-                mLastNotifiedCarrierRoamingNtnSignalStrength.put(subId, currSignalStrength);
-                phone.notifyCarrierRoamingNtnSignalStrengthChanged(currSignalStrength);
-            }
+        NtnSignalStrength lastNotifiedSignalStrength =
+                mLastNotifiedCarrierRoamingNtnSignalStrength.get(subId);
+        if (lastNotifiedSignalStrength == null
+                || lastNotifiedSignalStrength.getLevel() != currSignalStrength.getLevel()) {
+            mLastNotifiedCarrierRoamingNtnSignalStrength.put(subId, currSignalStrength);
+            phone.notifyCarrierRoamingNtnSignalStrengthChanged(currSignalStrength);
         }
     }
 
@@ -9076,44 +9673,57 @@ public class SatelliteController extends Handler {
     }
 
     private boolean isWaitingForSatelliteModemOff() {
-        synchronized (mSatelliteEnabledRequestLock) {
-            return mWaitingForSatelliteModemOff;
+        return mWaitingForSatelliteModemOff.get();
+    }
+
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected void setIsSatelliteSupported(boolean isSupported) {
+        if (mIsSatelliteSupported == null) {
+            mIsSatelliteSupported = new AtomicBoolean(isSupported);
+        } else {
+            mIsSatelliteSupported.set(isSupported);
         }
     }
 
     @Nullable
     private Boolean getIsSatelliteSupported() {
-        synchronized (mIsSatelliteSupportedLock) {
-            return mIsSatelliteSupported;
+        if (mIsSatelliteSupported == null) {
+            return null;
         }
+        return mIsSatelliteSupported.get();
     }
 
     private boolean isWaitingForDisableSatelliteModemResponse() {
-        synchronized (mSatelliteEnabledRequestLock) {
-            return mWaitingForDisableSatelliteModemResponse;
-        }
+        return mWaitingForDisableSatelliteModemResponse.get();
     }
 
     private boolean isSatelliteAccessAllowedAtCurrentLocation() {
-        synchronized (mSatelliteAccessConfigLock) {
-            return mSatelliteAccessAllowed;
+        return mSatelliteAccessAllowed.get();
+    }
+
+    private void setIsSatelliteEnabled(boolean enabled) {
+        if (mIsSatelliteEnabled == null) {
+            mIsSatelliteEnabled = new AtomicBoolean(enabled);
+        } else {
+            mIsSatelliteEnabled.set(enabled);
         }
     }
 
     @Nullable
     private Boolean getIsSatelliteEnabled() {
-        synchronized (mIsSatelliteEnabledLock) {
-            return mIsSatelliteEnabled;
+        if (mIsSatelliteEnabled == null) {
+            return null;
         }
+        return mIsSatelliteEnabled.get();
     }
 
-    @Nullable
-    private RequestSatelliteEnabledArgument getSatelliteDisabledRequest() {
-        synchronized (mSatelliteEnabledRequestLock) {
-            return mSatelliteDisabledRequest;
+    private void setSatelliteCapabilities(@Nullable SatelliteCapabilities capabilities) {
+        synchronized (mSatelliteCapabilitiesLock) {
+            mSatelliteCapabilities = capabilities;
         }
     }
 
+    @Nullable
     private SatelliteCapabilities getSatelliteCapabilities() {
         synchronized (mSatelliteCapabilitiesLock) {
             return mSatelliteCapabilities;
@@ -9121,51 +9731,185 @@ public class SatelliteController extends Handler {
     }
 
     private void setBTEnabledState(boolean enabled) {
-        synchronized (mRadioStateLock) {
-            mBTStateEnabled = enabled;
-        }
+        mBTStateEnabled.set(enabled);
     }
 
     private boolean getBTEnabledState() {
-        synchronized (mRadioStateLock) {
-            return mBTStateEnabled;
-        }
+        return mBTStateEnabled.get();
     }
 
     private void setNfcEnabledState(boolean enabled) {
-        synchronized (mRadioStateLock) {
-            mNfcStateEnabled = enabled;
-        }
+        mNfcStateEnabled.set(enabled);
     }
 
     private boolean getNfcEnabledState() {
-        synchronized (mRadioStateLock) {
-            return mNfcStateEnabled;
-        }
+        return mNfcStateEnabled.get();
     }
 
     private void setUwbEnabledState(boolean enabled) {
-        synchronized (mRadioStateLock) {
-            mUwbStateEnabled = enabled;
-        }
+        mUwbStateEnabled.set(enabled);
     }
 
     private boolean getUwbEnabledState() {
-        synchronized (mRadioStateLock) {
-            return mUwbStateEnabled;
-        }
+        return mUwbStateEnabled.get();
     }
 
     private void setWifiEnabledState(boolean enabled) {
-        synchronized (mRadioStateLock) {
-            mWifiStateEnabled = enabled;
-        }
+        mWifiStateEnabled.set(enabled);
     }
 
     private boolean getWifiEnabledState() {
-        synchronized (mRadioStateLock) {
-            return mWifiStateEnabled;
+        return mWifiStateEnabled.get();
+    }
+
+    private void handleCarrierRoamingConfigVersionReport() {
+        logd("handleCarrierRoamingConfigVersionReport");
+        int[] activeSubIds = mSubscriptionManagerService.getActiveSubIdList(true);
+        if (activeSubIds != null && activeSubIds.length > 0) {
+            for (int subId : activeSubIds) {
+                SatelliteConfig satelliteConfig = getSatelliteConfig();
+                if (satelliteConfig != null) {
+                    int carrierId = SatelliteServiceUtils.getCarrierIdFromSubscription(subId);
+                    mControllerMetricsStats.reportCurrentVersionOfCarrierRoamingSatelliteConfig(
+                            carrierId, satelliteConfig.getSatelliteConfigDataVersion());
+                } else {
+                    loge("handleCarrierRoamingConfigVersionReport: "
+                            + "no satellite config by configupdater");
+                }
+            }
+        } else {
+            loge("handleMaxAllowedDataMetricsReport: no active subId");
+        }
+    }
+
+    private void handleMaxAllowedDataMetricsReport() {
+        logd("handleMaxAllowedDataMetricsReport");
+        int[] activeSubIds = mSubscriptionManagerService.getActiveSubIdList(true);
+        if (activeSubIds != null && activeSubIds.length > 0) {
+            for (int subId : activeSubIds) {
+                int maxAllowedDataMode = getMaxAllowedDataMode();
+                int carrierId = SatelliteServiceUtils.getCarrierIdFromSubscription(subId);
+                mControllerMetricsStats
+                        .reportCurrentMaxAllowedDataMode(carrierId, maxAllowedDataMode);
+            }
+        } else {
+            loge("handleMaxAllowedDataMetricsReport: no active subId");
+        }
+    }
+
+    private void handleEntireEntitlementMetricReport() {
+        int[] activeSubIds = mSubscriptionManagerService.getActiveSubIdList(true);
+        if (activeSubIds != null && activeSubIds.length > 0) {
+            for (int subId : activeSubIds) {
+                boolean isSubIdEntitled = mSatelliteEntitlementStatusPerCarrier.computeIfAbsent(
+                        subId, k -> false);
+                mCarrierRoamingSatelliteControllerStats.reportIsDeviceEntitled(subId,
+                        isSubIdEntitled);
+                plogd("handleEntitlementMetricReport: subId=" + subId + ", isSubEntitled="
+                        + isSubIdEntitled);
+            }
+        } else {
+            loge("handleEntireEntitlementMetricReport: no active subId");
+        }
+    }
+
+    private void handleIndividualEntitlementMetricReport(int subId,
+            boolean isSubscriptionEntitled) {
+        mSatelliteEntitlementStatusPerCarrier.put(subId, isSubscriptionEntitled);
+        mCarrierRoamingSatelliteControllerStats.reportIsDeviceEntitled(subId,
+                isSubscriptionEntitled);
+    }
+
+    private void handleEntireProvisionMetricReport() {
+        logd("handleEntireProvisionMetricReport:");
+        // Hold the final aggregated status for each carrierId.
+        Map<Integer, CarrierReportInfo> reportDataPerCarrier = new HashMap<>();
+        // Aggregate provision status and isNtnOnlyCarrier info per carrierId
+        List<SubscriptionInfo> allSubInfos = mSubscriptionManagerService.getAllSubInfoList(
+                mContext.getOpPackageName(), mContext.getAttributionTag());
+        for (SubscriptionInfo info : allSubInfos) {
+            int subId = info.getSubscriptionId();
+            boolean isNtnOnlySubId = info.isOnlyNonTerrestrialNetwork();
+            boolean isActiveSubId = info.isActive();
+
+            if (!isNtnOnlySubId && !isActiveSubId) {
+                plogd("handleEntireProvisionMetricReport: subId=" + subId
+                        + " is neither NTN-only nor active. Skipping.");
+                continue;
+            }
+
+            int carrierId = SatelliteServiceUtils.getCarrierIdFromSubscription(subId);
+            if (carrierId == TelephonyManager.UNKNOWN_CARRIER_ID && !isNtnOnlySubId) {
+                plogd("handleEntireProvisionMetricReport: neither valid carrierId "
+                        + "nor NTN-only, subId=" + subId + ". Skipping.");
+                continue;
+            }
+
+            String subscriberId = getSubscriberIdAndType(info).first;
+            boolean isProvisioned = mProvisionedSubscriberId.getOrDefault(subscriberId, false);
+
+            CarrierReportInfo carrierInfo = reportDataPerCarrier.computeIfAbsent(
+                    carrierId, key -> new CarrierReportInfo());
+            carrierInfo.aggregate(isProvisioned, isNtnOnlySubId);
+        }
+
+        // Report the aggregated status for each carrierId
+        if (reportDataPerCarrier.isEmpty()) {
+            plogd("handleEntireProvisionMetricReport: No reportable data found");
+        } else {
+            plogd("handleEntireProvisionMetricReport: Reporting final aggregated status for "
+                    + reportDataPerCarrier.size() + " carrier(s).");
+            for (Map.Entry<Integer, CarrierReportInfo> reportEntry :
+                    reportDataPerCarrier.entrySet()) {
+                int carrierId = reportEntry.getKey();
+                CarrierReportInfo info = reportEntry.getValue();
+
+                plogd("handleEntireProvisionMetricReport: Final report for carrierId="
+                        + carrierId + ", isProvisioned=" + info.mIsAnySubProvisioned
+                        + ", isNtnOnlyCarrier=" + info.mIsNtnOnlyCarrier);
+
+                mControllerMetricsStats.setIsProvisioned(
+                        carrierId,
+                        info.mIsAnySubProvisioned,
+                        info.mIsNtnOnlyCarrier);
+            }
+        }
+    }
+
+    // Helper class to store aggregated information per carrierId.
+    private static class CarrierReportInfo {
+        boolean mIsAnySubProvisioned = false;
+        boolean mIsNtnOnlyCarrier = false;
+
+        void aggregate(boolean isProvisioned, boolean isNtnOnlyCarrier) {
+            // if any subId for the carrier was provisioned, this carrier is provisioned
+            if (isProvisioned) {
+                this.mIsAnySubProvisioned = true;
+            }
+            this.mIsNtnOnlyCarrier = isNtnOnlyCarrier;
+        }
+    }
+
+    private void scheduleRegularMetricReportTimer() {
+        if (mAlarmManager == null) {
+            plogd("scheduleRegularMetricReportTimer: AlarmManager is null");
+            return;
         }
+        mAlarmManager.cancel(mRegularMetricReportAlarmListener);
+        mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                getElapsedRealtime() + REGULAR_METRIC_REPORTING_INTERVAL_MILLIS,
+                TAG, new HandlerExecutor(this), new WorkSource(),
+                mRegularMetricReportAlarmListener);
+    }
+
+    /**
+     * Uses this function to set AlarmManager object for testing.
+     *
+     * @param alarmManager The instance of AlarmManager.
+     */
+    @VisibleForTesting
+    public void setAlarmManager(AlarmManager alarmManager) {
+        mAlarmManager = alarmManager;
     }
 
     /**
@@ -9180,12 +9924,10 @@ public class SatelliteController extends Handler {
      */
     public int getSatelliteDataPlanForPlmn(int subId, String plmn) {
         if (plmn != null) {
-            synchronized (mSupportedSatelliteServicesLock) {
-                Map<String, Integer> dataplanMap = mEntitlementDataPlanMapPerCarrier.get(subId);
-                logd("data plan available for sub id:" + dataplanMap);
-                if (dataplanMap != null && dataplanMap.containsKey(plmn)) {
-                    return dataplanMap.get(plmn);
-                }
+            Map<String, Integer> dataplanMap = mEntitlementDataPlanMapPerCarrier.get(subId);
+            logd("data plan available for sub id:" + dataplanMap);
+            if (dataplanMap != null && dataplanMap.containsKey(plmn)) {
+                return dataplanMap.get(plmn);
             }
         }
         // TODO (Override with carrier config value when configuration defined)
@@ -9218,29 +9960,53 @@ public class SatelliteController extends Handler {
 
     /**
      * Method to return the current satellite data service policy supported mode for the registered
-     * plmn based on entitlement provisioning information. Note: If no information at
-     * provisioning is supported this is overridden with operator carrier config information
-     * if available satellite services support data else data service policy is marked as
-     * restricted.
+     * plmn based on entitlement provisioning information. Note: If no information at provisioning
+     * is supported this is overridden with operator carrier config information if available
+     * satellite services support data else data service policy is marked as restricted. Note that
+     * the data service policy is capped at maxAllowedDataMode which is configured by OEMs through
+     * {@link R.integer.max_allowed_data_mode} or through {@link SatelliteConfig}
      *
      * @param subId current subscription id
      * @param plmn current registered plmn information
-     *
      * @return Supported modes {@link CarrierConfigManager.SATELLITE_DATA_SUPPORT_MODE}
      */
     public int getSatelliteDataServicePolicyForPlmn(int subId, String plmn) {
         plogd("getSatelliteDataServicePolicyForPlmn: subId=" + subId + " plmn=" + plmn);
+        int maxAllowedDataMode = getMaxAllowedDataMode();
+        plogd("getSatelliteDataServicePolicyForPlmn: maxAllowedDataMode=" + maxAllowedDataMode);
+
+        if (maxAllowedDataMode == CarrierConfigManager.SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED) {
+            plogd(
+                    "maxAllowedDataMode is "
+                            + CarrierConfigManager.SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED
+                            + ", the least possible value. Data service policy cannot go below"
+                            + " that. Therefore, returning this");
+            return maxAllowedDataMode;
+        }
+
         if (isValidSubscriptionId(subId)) {
-            Map<String, Integer> dataServicePolicy;
-            synchronized (mSupportedSatelliteServicesLock) {
-                dataServicePolicy = mEntitlementDataServicePolicyMapPerCarrier.get(subId);
-            }
+            Map<String, Integer> dataServicePolicy = getConfigForSubId(subId).getBoolean(
+                    KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, false)
+                    ? mEntitlementDataServicePolicyMapPerCarrier.get(subId)
+                    : null;
             plogd("getSatelliteDataServicePolicyForPlmn: dataServicePolicy=" + dataServicePolicy);
 
-            if (dataServicePolicy != null) {
+            if (dataServicePolicy != null && !dataServicePolicy.isEmpty()) {
                 if (!TextUtils.isEmpty(plmn) && dataServicePolicy.containsKey(plmn)) {
                     plogd("getSatelliteDataServicePolicyForPlmn: "
                             + "return policy using dataServicePolicy map");
+                    if (dataServicePolicy.get(plmn) > maxAllowedDataMode) {
+                        plogd(
+                                "getSatelliteDataServicePolicyForPlmn: dataServicePolicy shouldn't "
+                                        + "be bigger than maxAllowedDataMode: "
+                                        + maxAllowedDataMode);
+                        return maxAllowedDataMode;
+                    }
+
+                    plogd(
+                            "getSatelliteDataServicePolicyForPlmn: "
+                                    + "return policy using dataServicePolicy map: "
+                                    + dataServicePolicy.get(plmn));
                     return dataServicePolicy.get(plmn);
                 } else if (TextUtils.isEmpty(plmn)) {
                     int preferredPolicy =
@@ -9252,15 +10018,53 @@ public class SatelliteController extends Handler {
                             preferredPolicy = policy;
                         }
                     }
-                    plogd("getSatelliteDataServicePolicyForPlmn: "
-                            + "return preferredPolicy=" + preferredPolicy);
-                    return preferredPolicy;
+
+                    // when invoked getSatelliteDataServicePolicyPlmn() with empty plmn and data
+                    // service policy not provisioned i.e.data service policy info is empty with
+                    // or without plmn key, then ignore setting preferred data supported mode policy
+                    // as restricted and fallback to carrier configured data supported mode for the
+                    // subscription id.
+                    if (preferredPolicy
+                            > CarrierConfigManager.SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED) {
+                        plogd(
+                                "getSatelliteDataServicePolicyForPlmn: "
+                                        + "preferredPolicy="
+                                        + preferredPolicy);
+
+                        if (preferredPolicy > maxAllowedDataMode) {
+                            plogd(
+                                    "getSatelliteDataServicePolicyForPlmn: preferredPolicy"
+                                            + " shouldn't be bigger than maxAllowedDataMode: "
+                                            + maxAllowedDataMode);
+                            return maxAllowedDataMode;
+                        }
+
+                        plogd(
+                                "getSatelliteDataServicePolicyForPlmn: "
+                                        + "returning preferredPolicy="
+                                        + preferredPolicy);
+                        return preferredPolicy;
+                    }
                 }
             }
 
             if (isSatelliteDataServicesAllowed(subId, plmn)) {
                 plogd("getSatelliteDataServicePolicyForPlmn: return data support mode from config");
-                return getCarrierSatelliteDataSupportedModeFromConfig(subId);
+                int carrierSatelliteDataSupportedMode =
+                        getCarrierSatelliteDataSupportedModeFromConfig(subId);
+                if (carrierSatelliteDataSupportedMode > maxAllowedDataMode) {
+                    plogd(
+                            "getSatelliteDataServicePolicyForPlmn:"
+                                    + " carrierSatelliteDataSupportedMode shouldn't be bigger than"
+                                    + " maxAllowedDataMode: "
+                                    + maxAllowedDataMode);
+                    return maxAllowedDataMode;
+                }
+                plogd(
+                        "getSatelliteDataServicePolicyForPlmn: return data support mode from"
+                                + " config: "
+                                + carrierSatelliteDataSupportedMode);
+                return carrierSatelliteDataSupportedMode;
             }
         }
 
@@ -9280,15 +10084,13 @@ public class SatelliteController extends Handler {
      */
     public int getSatelliteVoiceServicePolicyForPlmn(int subId, String plmn) {
         if (plmn != null) {
-            synchronized (mSupportedSatelliteServicesLock) {
-                Map<String, Integer> voiceServicePolicy =
-                        mEntitlementVoiceServicePolicyMapPerCarrier.get(
-                                subId);
-                logd("voice policy available for sub id:" + voiceServicePolicy);
-                if (voiceServicePolicy != null && voiceServicePolicy.containsKey(plmn)
-                        && !plmn.isEmpty()) {
-                    return voiceServicePolicy.get(plmn);
-                }
+            Map<String, Integer> voiceServicePolicy =
+                    mEntitlementVoiceServicePolicyMapPerCarrier.get(
+                            subId);
+            logd("voice policy available for sub id:" + voiceServicePolicy);
+            if (voiceServicePolicy != null && voiceServicePolicy.containsKey(plmn)
+                    && !plmn.isEmpty()) {
+                return voiceServicePolicy.get(plmn);
             }
         }
         // TODO (Replace below code with related enum value, when voice service policy support mode
@@ -9343,4 +10145,85 @@ public class SatelliteController extends Handler {
         mIgnorePlmnListFromStorage.set(enabled);
         return true;
     }
+
+    private void setSatelliteEnabledRequest(@Nullable RequestSatelliteEnabledArgument argument) {
+        synchronized (mSatelliteEnabledRequestLock) {
+            mSatelliteEnabledRequest = argument;
+        }
+    }
+
+    @Nullable
+    private RequestSatelliteEnabledArgument getSatelliteEnabledRequest() {
+        synchronized (mSatelliteEnabledRequestLock) {
+            return mSatelliteEnabledRequest;
+        }
+    }
+
+    private void setSatelliteDisabledRequest(@Nullable RequestSatelliteEnabledArgument argument) {
+        synchronized (mSatelliteEnabledRequestLock) {
+            mSatelliteDisabledRequest = argument;
+        }
+    }
+
+    @Nullable
+    private RequestSatelliteEnabledArgument getSatelliteDisabledRequest() {
+        synchronized (mSatelliteEnabledRequestLock) {
+            return mSatelliteDisabledRequest;
+        }
+    }
+
+    private void setSatelliteEnableAttributesUpdateRequest(
+            @Nullable RequestSatelliteEnabledArgument argument) {
+        synchronized (mSatelliteEnabledRequestLock) {
+            mSatelliteEnableAttributesUpdateRequest = argument;
+        }
+    }
+
+    @Nullable
+    private RequestSatelliteEnabledArgument getSatelliteEnableAttributesUpdateRequest() {
+        synchronized (mSatelliteEnabledRequestLock) {
+            return mSatelliteEnableAttributesUpdateRequest;
+        }
+    }
+
+    private void setSubsInfoListPerPriority(
+            @NonNull TreeMap<Integer, List<SubscriptionInfo>> subsInfoListPerPriority) {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            mSubsInfoListPerPriority = subsInfoListPerPriority;
+        }
+    }
+
+    @NonNull
+    private TreeMap<Integer, List<SubscriptionInfo>> getSubsInfoListPerPriority() {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            return mSubsInfoListPerPriority;
+        }
+    }
+
+    private void setLastEvaluatedSubscriberProvisionStatus(
+            @NonNull List<SatelliteSubscriberProvisionStatus> subscriberProvisionStatus) {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            mLastEvaluatedSubscriberProvisionStatus = subscriberProvisionStatus;
+        }
+    }
+
+    @NonNull
+    private List<SatelliteSubscriberProvisionStatus> getLastEvaluatedSubscriberProvisionStatus() {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            return mLastEvaluatedSubscriberProvisionStatus;
+        }
+    }
+
+    private void setLastConfiguredIccId(@NonNull String lastConfiguredIccId) {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            mLastConfiguredIccId = lastConfiguredIccId;
+        }
+    }
+
+    @NonNull
+    private String getLastConfiguredIccId() {
+        synchronized (mSatelliteTokenProvisionedLock) {
+            return mLastConfiguredIccId;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteModemInterface.java b/src/java/com/android/internal/telephony/satellite/SatelliteModemInterface.java
index 9e5d9de20b..f84bad2175 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteModemInterface.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteModemInterface.java
@@ -57,6 +57,7 @@ import com.android.internal.telephony.flags.FeatureFlags;
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Satellite modem interface to manage connections with the satellite service and HAL interface.
@@ -67,6 +68,7 @@ public class SatelliteModemInterface {
     private static final long REBIND_MAXIMUM_DELAY = 64 * 1000; // 1 minute
     private static final int REBIND_MULTIPLIER = 2;
 
+    /** All the variables initialized inside the constructor are declared here. */
     @NonNull private static SatelliteModemInterface sInstance;
     @NonNull private final Context mContext;
     @NonNull private final DemoSimulator mDemoSimulator;
@@ -74,18 +76,21 @@ public class SatelliteModemInterface {
     @NonNull private final SatelliteListener mDemoListener;
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     @NonNull protected final ExponentialBackoff mExponentialBackoff;
-    @NonNull private final Object mLock = new Object();
+
     @NonNull private final SatelliteController mSatelliteController;
-    /**
-     * {@code true} to use the vendor satellite service and {@code false} to use the HAL.
-     */
-    private boolean mIsSatelliteServiceSupported;
+
+    @Nullable private PersistentLogger mPersistentLogger = null;
+
+    /** All the atomic variables are declared here. */
+    private AtomicBoolean mIsBound = new AtomicBoolean(false);
+    private AtomicBoolean mIsBinding = new AtomicBoolean(false);
+    // {@code true} to use the vendor satellite service and {@code false} to use the HAL.
+    private AtomicBoolean mIsSatelliteServiceSupported = new AtomicBoolean(false);
+
+    @NonNull private final Object mLock = new Object();
     @Nullable private ISatellite mSatelliteService;
     @Nullable private SatelliteServiceConnection mSatelliteServiceConnection;
     @NonNull private String mVendorSatellitePackageName = "";
-    private boolean mIsBound;
-    private boolean mIsBinding;
-    @Nullable private PersistentLogger mPersistentLogger = null;
 
     @NonNull private final RegistrantList mSatellitePositionInfoChangedRegistrants =
             new RegistrantList();
@@ -259,20 +264,17 @@ public class SatelliteModemInterface {
         mDemoSimulator = DemoSimulator.make(context, satelliteController);
         mVendorListener = new SatelliteListener(false);
         mDemoListener = new SatelliteListener(true);
-        mIsSatelliteServiceSupported = getSatelliteServiceSupport();
+        mIsSatelliteServiceSupported.set(getSatelliteServiceSupport());
         mSatelliteController = satelliteController;
         mExponentialBackoff = new ExponentialBackoff(REBIND_INITIAL_DELAY, REBIND_MAXIMUM_DELAY,
                 REBIND_MULTIPLIER, looper, () -> {
-            synchronized (mLock) {
-                if ((mIsBound && mSatelliteService != null) || mIsBinding) {
-                    return;
-                }
+            if ((mIsBound.get() && mSatelliteService != null) || mIsBinding.get()) {
+                return;
             }
+
             if (mSatelliteServiceConnection != null) {
-                synchronized (mLock) {
-                    mIsBound = false;
-                    mIsBinding = false;
-                }
+                mIsBound.set(false);
+                mIsBinding.set(false);
                 unbindService();
             }
             bindService();
@@ -305,18 +307,15 @@ public class SatelliteModemInterface {
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     protected void bindService() {
-        synchronized (mLock) {
-            if (mIsBinding || mIsBound) return;
-            mIsBinding = true;
-        }
+        if (mIsBinding.get() || mIsBound.get()) return;
+        mIsBinding.set(true);
+
         String packageName = getSatellitePackageName();
         if (TextUtils.isEmpty(packageName)) {
             ploge("Unable to bind to the satellite service because the package is undefined.");
             // Since the package name comes from static device configs, stop retry because
             // rebind will continue to fail without a valid package name.
-            synchronized (mLock) {
-                mIsBinding = false;
-            }
+            mIsBinding.set(false);
             mExponentialBackoff.stop();
             return;
         }
@@ -331,17 +330,13 @@ public class SatelliteModemInterface {
             if (success) {
                 plogd("Successfully bound to the satellite service.");
             } else {
-                synchronized (mLock) {
-                    mIsBinding = false;
-                }
+                mIsBinding.set(false);
                 mExponentialBackoff.notifyFailed();
                 ploge("Error binding to the satellite service. Retrying in "
                         + mExponentialBackoff.getCurrentDelay() + " ms.");
             }
         } catch (Exception e) {
-            synchronized (mLock) {
-                mIsBinding = false;
-            }
+            mIsBinding.set(false);
             mExponentialBackoff.notifyFailed();
             ploge("Exception binding to the satellite service. Retrying in "
                     + mExponentialBackoff.getCurrentDelay() + " ms. Exception: " + e);
@@ -364,10 +359,8 @@ public class SatelliteModemInterface {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             plogd("onServiceConnected: ComponentName=" + name);
-            synchronized (mLock) {
-                mIsBound = true;
-                mIsBinding = false;
-            }
+            mIsBound.set(true);
+            mIsBinding.set(false);
             mSatelliteService = ISatellite.Stub.asInterface(service);
             mExponentialBackoff.stop();
             try {
@@ -383,9 +376,7 @@ public class SatelliteModemInterface {
         @Override
         public void onServiceDisconnected(ComponentName name) {
             ploge("onServiceDisconnected: Waiting for reconnect.");
-            synchronized (mLock) {
-                mIsBinding = false;
-            }
+            mIsBinding.set(false);
             // Since we are still technically bound, clear the service and wait for reconnect.
             disconnectSatelliteService();
         }
@@ -393,10 +384,8 @@ public class SatelliteModemInterface {
         @Override
         public void onBindingDied(ComponentName name) {
             ploge("onBindingDied: Unbinding and rebinding service.");
-            synchronized (mLock) {
-                mIsBound = false;
-                mIsBinding = false;
-            }
+            mIsBound.set(false);
+            mIsBinding.set(false);
             unbindService();
             mExponentialBackoff.start();
         }
@@ -1308,7 +1297,7 @@ public class SatelliteModemInterface {
     }
 
     public boolean isSatelliteServiceSupported() {
-        return mIsSatelliteServiceSupported;
+        return mIsSatelliteServiceSupported.get();
     }
 
     /** Check if vendor satellite service is connected */
@@ -1359,10 +1348,8 @@ public class SatelliteModemInterface {
                 + "updated, new packageName=" + servicePackageName);
         mExponentialBackoff.stop();
         if (mSatelliteServiceConnection != null) {
-            synchronized (mLock) {
-                mIsBound = false;
-                mIsBinding = false;
-            }
+            mIsBound.set(false);
+            mIsBinding.set(false);
             unbindService();
         }
 
@@ -1371,7 +1358,7 @@ public class SatelliteModemInterface {
         } else {
             mVendorSatellitePackageName = servicePackageName;
         }
-        mIsSatelliteServiceSupported = getSatelliteServiceSupport();
+        mIsSatelliteServiceSupported.set(getSatelliteServiceSupport());
         bindService();
         mExponentialBackoff.start();
     }
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteOptimizedApplicationsTracker.java b/src/java/com/android/internal/telephony/satellite/SatelliteOptimizedApplicationsTracker.java
index df656df0e1..342ac89abb 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteOptimizedApplicationsTracker.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteOptimizedApplicationsTracker.java
@@ -31,16 +31,17 @@ import android.os.Looper;
 import android.os.Message;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.android.internal.telephony.PackageChangeReceiver;
 
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * SatelliteOptimizedApplicationsTracker will track the packages if they are Satellite optimized or
@@ -48,7 +49,8 @@ import java.util.Set;
  */
 public class SatelliteOptimizedApplicationsTracker {
 
-    @NonNull private final Map<Integer, Set<String>> mSatelliteApplications = new HashMap<>();
+    @NonNull private final ConcurrentHashMap<Integer, Set<String>> mSatelliteApplications =
+            new ConcurrentHashMap<>();
 
     /** Action used to initialize the state of the Tracker. */
     private static final int ACTION_INITIALIZE_TRACKER = 0;
@@ -167,7 +169,7 @@ public class SatelliteOptimizedApplicationsTracker {
     private void handlePackageMonitor(String packageName) {
         ApplicationInfo applicationInfo = getApplicationInfo(packageName);
         if (applicationInfo != null) {
-            if (isOptimizedSatelliteApplication(applicationInfo)) {
+            if (isOptimizedSatelliteApplication(applicationInfo, packageName)) {
                 addCacheOptimizedSatelliteApplication(packageName);
             } else {
                 removeCacheOptimizedSatelliteApplication(packageName);
@@ -187,20 +189,33 @@ public class SatelliteOptimizedApplicationsTracker {
         // Iterate through the packages
         for (PackageInfo packageInfo : packages) {
             if (packageInfo.applicationInfo != null
-                    && isOptimizedSatelliteApplication(packageInfo.applicationInfo)) {
+                    && isOptimizedSatelliteApplication(packageInfo.applicationInfo,
+                    packageInfo.packageName)) {
                 addCacheOptimizedSatelliteApplication(packageInfo.packageName);
             }
         }
     }
 
-    private boolean isOptimizedSatelliteApplication(@NonNull ApplicationInfo applicationInfo) {
-        boolean flag = false;
-        if (applicationInfo.metaData != null) {
-            // Get the application's metadata
-            Bundle metadata = applicationInfo.metaData;
-            flag = metadata.containsKey(APP_PROPERTY);
+    private boolean isOptimizedSatelliteApplication(@NonNull ApplicationInfo applicationInfo,
+            @NonNull String packageName) {
+        // Get the application's metadata
+        Bundle metadata = applicationInfo.metaData;
+        if (metadata != null) {
+            try {
+                final Object value = metadata.get(APP_PROPERTY);
+                if (value == null) return false; // No expected meta-data.
+
+                // Check if the retrieved object is a matched String.
+                return value instanceof String
+                        && TextUtils.equals((String) value, packageName);
+            } catch (Exception e) {
+                loge("Exception while reading metadata [ "
+                        + packageName
+                        + " ] exp = "
+                        + e.getMessage());
+            }
         }
-        return flag;
+        return false;
     }
 
     private void addCacheOptimizedSatelliteApplication(@NonNull String packageName) {
@@ -243,7 +258,17 @@ public class SatelliteOptimizedApplicationsTracker {
      *     #PROPERTY_SATELLITE_DATA_OPTIMIZED}
      */
     public @NonNull List<String> getSatelliteOptimizedApplications(int userId) {
-        return new ArrayList<>(mSatelliteApplications.get(userId));
+        // 1. Retrieve the Set directly from the ConcurrentHashMap.
+        Set<String> applications = mSatelliteApplications.get(userId);
+
+        // 2. Check if a Set was found for the userId.
+        if (applications != null) {
+            return new ArrayList<>(applications);
+        } else {
+            // 3. If no Set is found, return an empty, unmodifiable list.
+            // This is highly efficient and prevents null pointer exceptions for callers.
+            return Collections.emptyList();
+        }
     }
 
     private void log(String str) {
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommender.java b/src/java/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommender.java
index a7e35c9841..ed863e088b 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommender.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommender.java
@@ -65,7 +65,6 @@ import android.util.SparseArray;
 import com.android.ims.ImsException;
 import com.android.ims.ImsManager;
 import com.android.internal.R;
-import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneFactory;
@@ -78,6 +77,7 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 
 /**
@@ -98,38 +98,40 @@ public class SatelliteSOSMessageRecommender extends Handler {
     private static final int CMD_SEND_EVENT_DISPLAY_EMERGENCY_MESSAGE_FORCEFULLY = 6;
     private static final int EVENT_SATELLITE_ACCESS_RESTRICTION_CHECKING_RESULT = 7;
 
+    /** All the variables initialized inside the constructor are declared here. */
     @NonNull private final Context mContext;
     @NonNull
     private final SatelliteController mSatelliteController;
     @NonNull
     private final TelephonyCountryDetector mCountryDetector;
     private ImsManager mImsManager;
+    private SubscriptionManager mSubscriptionManager;
     @NonNull
     private final FeatureFlags mFeatureFlags;
-
-    private Connection mEmergencyConnection = null;
+    @Nullable private PersistentLogger mPersistentLogger = null;
     private final ISatelliteProvisionStateCallback mISatelliteProvisionStateCallback;
-    /** Key: Phone ID; Value: IMS RegistrationCallback */
-    private SparseArray<RegistrationManager.RegistrationCallback>
-            mImsRegistrationCallbacks = new SparseArray<>();
-    @GuardedBy("mLock")
-    private boolean mIsSatelliteAllowedForCurrentLocation = false;
-    @GuardedBy("mLock")
-    private boolean mCheckingAccessRestrictionInProgress = false;
-    protected long mTimeoutMillis = 0;
-    private final long mOemEnabledTimeoutMillis;
+
+    /** All the atomic variables are declared here. */
+    private AtomicBoolean mIsSatelliteAllowedForCurrentLocation = new AtomicBoolean(false);
+    private AtomicBoolean mCheckingAccessRestrictionInProgress = new AtomicBoolean(false);
     protected final AtomicBoolean mIsSatelliteConnectedViaCarrierWithinHysteresisTime =
             new AtomicBoolean(false);
     protected final AtomicInteger mSubIdOfSatelliteConnectedViaCarrierWithinHysteresisTime =
             new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
-    @GuardedBy("mLock")
-    private boolean mIsTimerTimedOut = false;
-    protected int mCountOfTimerStarted = 0;
-    private final Object mLock = new Object();
+    protected AtomicLong mTimeoutMillis = new AtomicLong(0);
+    private final AtomicLong mOemEnabledTimeoutMillis = new AtomicLong(0);
+    private AtomicBoolean mIsTimerTimedOut = new AtomicBoolean(false);
+    protected AtomicInteger mCountOfTimerStarted = new AtomicInteger(0);
+    private AtomicBoolean mIsTestEmergencyNumber = new AtomicBoolean(false);
 
-    @Nullable private PersistentLogger mPersistentLogger = null;
-
-    private boolean mIsTestEmergencyNumber = false;
+    /**
+     * All the variables declared here should only be accessed by methods that run inside the
+     * handler thread.
+     */
+    private Connection mEmergencyConnection = null;
+    /** Key: Phone ID; Value: IMS RegistrationCallback */
+    private SparseArray<RegistrationManager.RegistrationCallback>
+            mImsRegistrationCallbacks = new SparseArray<>();
 
     /**
      * Create an instance of SatelliteSOSMessageRecommender.
@@ -163,8 +165,9 @@ public class SatelliteSOSMessageRecommender extends Handler {
         mFeatureFlags = mSatelliteController.getFeatureFlags();
         mCountryDetector = TelephonyCountryDetector.getInstance(context, mFeatureFlags);
         mImsManager = imsManager;
-        mOemEnabledTimeoutMillis =
-                getOemEnabledEmergencyCallWaitForConnectionTimeoutMillis(context);
+        mSubscriptionManager = context.getSystemService(SubscriptionManager.class);
+        mOemEnabledTimeoutMillis.set(
+                getOemEnabledEmergencyCallWaitForConnectionTimeoutMillis(context));
         mISatelliteProvisionStateCallback = new ISatelliteProvisionStateCallback.Stub() {
             @Override
             public void onSatelliteProvisionStateChanged(boolean provisioned) {
@@ -223,7 +226,7 @@ public class SatelliteSOSMessageRecommender extends Handler {
             plogd("onEmergencyCallStarted: satellite is not supported");
             return;
         }
-        mIsTestEmergencyNumber = isTestEmergencyNumber;
+        mIsTestEmergencyNumber.set(isTestEmergencyNumber);
 
         if (hasMessages(EVENT_EMERGENCY_CALL_STARTED)) {
             logd("onEmergencyCallStarted: Ignoring due to ongoing event:");
@@ -299,10 +302,8 @@ public class SatelliteSOSMessageRecommender extends Handler {
         mEmergencyConnection = connection;
         handleStateChangedEventForHysteresisTimer();
 
-        synchronized (mLock) {
-            mCheckingAccessRestrictionInProgress = false;
-            mIsSatelliteAllowedForCurrentLocation = false;
-        }
+        mCheckingAccessRestrictionInProgress.set(false);
+        mIsSatelliteAllowedForCurrentLocation.set(false);
     }
 
     private void handleSatelliteProvisionStateChangedEvent(boolean provisioned) {
@@ -313,63 +314,57 @@ public class SatelliteSOSMessageRecommender extends Handler {
     }
 
     private void handleTimeoutEvent() {
-        synchronized (mLock) {
-            mIsTimerTimedOut = true;
-            evaluateSendingConnectionEventDisplayEmergencyMessage();
-        }
+        mIsTimerTimedOut.set(true);
+        evaluateSendingConnectionEventDisplayEmergencyMessage();
     }
 
     private void evaluateSendingConnectionEventDisplayEmergencyMessage() {
-        synchronized (mLock) {
-            if (mEmergencyConnection == null) {
-                ploge("No emergency call is ongoing...");
-                return;
-            }
-
-            if (!mIsTimerTimedOut || mCheckingAccessRestrictionInProgress) {
-                plogd("mIsTimerTimedOut=" + mIsTimerTimedOut
-                        + ", mCheckingAccessRestrictionInProgress="
-                        + mCheckingAccessRestrictionInProgress);
-                return;
-            }
+        if (mEmergencyConnection == null) {
+            ploge("No emergency call is ongoing...");
+            return;
+        }
 
-            updateAndGetProvisionState();
+        if (!mIsTimerTimedOut.get() || mCheckingAccessRestrictionInProgress.get()) {
+            plogd("mIsTimerTimedOut=" + mIsTimerTimedOut.get()
+                    + ", mCheckingAccessRestrictionInProgress="
+                    + mCheckingAccessRestrictionInProgress.get());
+            return;
+        }
 
-            /*
-             * The device might be connected to satellite after the emergency call started. Thus, we
-             * need to do this check again so that we will have higher chance of sending the event
-             * EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer.
-             */
-            updateSatelliteViaCarrierAvailability();
-
-            boolean isDialerNotified = false;
-            boolean isCellularAvailable = SatelliteServiceUtils.isCellularAvailable();
-            if (!isCellularAvailable
-                    && isSatelliteAllowed()
-                    && ((isDeviceProvisioned() && isSatelliteAllowedByReasons())
-                    || isSatelliteEmergencyMessagingViaCarrierAvailable())
-                    && shouldTrackCall(mEmergencyConnection.getState())) {
-                plogd("handleTimeoutEvent: Sent EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer");
-                Bundle extras = createExtraBundleForEventDisplayEmergencyMessage(
-                        mIsTestEmergencyNumber);
-                mEmergencyConnection.sendConnectionEvent(
-                        TelephonyManager.EVENT_DISPLAY_EMERGENCY_MESSAGE, extras);
-                isDialerNotified = true;
+        updateAndGetProvisionState();
 
-            }
-            plogd("handleTimeoutEvent: isImsRegistered=" + isImsRegistered()
-                    + ", isCellularAvailable=" + isCellularAvailable
-                    + ", isSatelliteAllowed=" + isSatelliteAllowed()
-                    + ", shouldTrackCall=" + shouldTrackCall(mEmergencyConnection.getState()));
-            cleanUpResources(isDialerNotified);
-        }
+        /*
+         * The device might be connected to satellite after the emergency call started. Thus, we
+         * need to do this check again so that we will have higher chance of sending the event
+         * EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer.
+         */
+        updateSatelliteViaCarrierAvailability();
+
+        boolean isDialerNotified = false;
+        boolean isCellularAvailable = SatelliteServiceUtils.isCellularAvailable();
+        if (!isCellularAvailable
+                && isSatelliteAllowed()
+                && ((isDeviceProvisioned() && isSatelliteAllowedByReasons())
+                || isSatelliteEmergencyMessagingViaCarrierAvailable())
+                && shouldTrackCall(mEmergencyConnection.getState())) {
+            plogd("handleTimeoutEvent: Sent EVENT_DISPLAY_EMERGENCY_MESSAGE to Dialer");
+            Bundle extras = createExtraBundleForEventDisplayEmergencyMessage(
+                    mIsTestEmergencyNumber.get());
+            mEmergencyConnection.sendConnectionEvent(
+                    TelephonyManager.EVENT_DISPLAY_EMERGENCY_MESSAGE, extras);
+            isDialerNotified = true;
+
+        }
+        plogd("handleTimeoutEvent: isImsRegistered=" + isImsRegistered()
+                + ", isCellularAvailable=" + isCellularAvailable
+                + ", isSatelliteAllowed=" + isSatelliteAllowed()
+                + ", shouldTrackCall=" + shouldTrackCall(mEmergencyConnection.getState()));
+        cleanUpResources(isDialerNotified);
     }
 
     private boolean isSatelliteAllowed() {
-        synchronized (mLock) {
-            if (isSatelliteEmergencyMessagingViaCarrierAvailable()) return true;
-            return mIsSatelliteAllowedForCurrentLocation;
-        }
+        if (isSatelliteEmergencyMessagingViaCarrierAvailable()) return true;
+        return mIsSatelliteAllowedForCurrentLocation.get();
     }
 
     private void updateSatelliteViaCarrierAvailability() {
@@ -382,8 +377,8 @@ public class SatelliteSOSMessageRecommender extends Handler {
      * Check if satellite is available via OEM
      * @return {@code true} if satellite is provisioned via OEM else return {@code false}
      */
-    @VisibleForTesting
-    public boolean isDeviceProvisioned() {
+    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
+    protected boolean isDeviceProvisioned() {
         Boolean satelliteProvisioned = mSatelliteController.isDeviceProvisioned();
         return satelliteProvisioned != null ? satelliteProvisioned : false;
     }
@@ -437,7 +432,7 @@ public class SatelliteSOSMessageRecommender extends Handler {
         SatelliteStats.getInstance().onSatelliteSosMessageRecommender(
                 new SatelliteStats.SatelliteSosMessageRecommenderParams.Builder()
                         .setDisplaySosMessageSent(isDialerNotified)
-                        .setCountOfTimerStarted(mCountOfTimerStarted)
+                        .setCountOfTimerStarted(mCountOfTimerStarted.get())
                         .setImsRegistered(isImsRegistered())
                         .setCellularServiceState(getBestCellularServiceState())
                         .setIsMultiSim(isMultiSim())
@@ -451,18 +446,16 @@ public class SatelliteSOSMessageRecommender extends Handler {
     private void cleanUpResources(boolean isDialerNotified) {
         plogd("cleanUpResources");
         reportESosRecommenderDecision(isDialerNotified);
-        synchronized (mLock) {
-            stopTimer();
-            if (mEmergencyConnection != null) {
-                unregisterForInterestedStateChangedEvents();
-            }
-            mEmergencyConnection = null;
-            mCountOfTimerStarted = 0;
-            mIsTimerTimedOut = false;
-            mCheckingAccessRestrictionInProgress = false;
-            mIsSatelliteAllowedForCurrentLocation = false;
-            mIsTestEmergencyNumber = false;
+        stopTimer();
+        if (mEmergencyConnection != null) {
+            unregisterForInterestedStateChangedEvents();
         }
+        mEmergencyConnection = null;
+        mCountOfTimerStarted.set(0);
+        mIsTimerTimedOut.set(false);
+        mCheckingAccessRestrictionInProgress.set(false);
+        mIsSatelliteAllowedForCurrentLocation.set(false);
+        mIsTestEmergencyNumber.set(false);
     }
 
     private void registerForInterestedStateChangedEvents() {
@@ -546,48 +539,44 @@ public class SatelliteSOSMessageRecommender extends Handler {
     }
 
     private void startTimer() {
-        synchronized (mLock) {
-            if (hasMessages(EVENT_TIME_OUT)) {
-                return;
-            }
-            sendMessageDelayed(obtainMessage(EVENT_TIME_OUT), mTimeoutMillis);
-            mCountOfTimerStarted++;
-            mIsTimerTimedOut = false;
-            plogd("startTimer mCountOfTimerStarted=" + mCountOfTimerStarted);
+        if (hasMessages(EVENT_TIME_OUT)) {
+            return;
         }
+        sendMessageDelayed(obtainMessage(EVENT_TIME_OUT), mTimeoutMillis.get());
+        int count = mCountOfTimerStarted.incrementAndGet();
+        mIsTimerTimedOut.set(false);
+        plogd("startTimer mCountOfTimerStarted=" + count);
     }
 
     private void stopTimer() {
-        synchronized (mLock) {
-            removeMessages(EVENT_TIME_OUT);
-        }
+        removeMessages(EVENT_TIME_OUT);
     }
 
     private void handleSatelliteAccessRestrictionCheckingResult(boolean satelliteAllowed) {
-        synchronized (mLock) {
-            mIsSatelliteAllowedForCurrentLocation = satelliteAllowed;
-            mCheckingAccessRestrictionInProgress = false;
-            evaluateSendingConnectionEventDisplayEmergencyMessage();
-        }
+        mIsSatelliteAllowedForCurrentLocation.set(satelliteAllowed);
+        mCheckingAccessRestrictionInProgress.set(false);
+        evaluateSendingConnectionEventDisplayEmergencyMessage();
     }
 
     private void selectEmergencyCallWaitForConnectionTimeoutDuration() {
-        if (isSatelliteEmergencyMessagingViaCarrierAvailable()) {
+        if (mSatelliteController.getEmergencyCallMonitoringDurationMillisForCtsTests() > 0) {
+            mTimeoutMillis.set(
+                mSatelliteController.getEmergencyCallMonitoringDurationMillisForCtsTests());
+            plogd("Use the overridden timeout value for CTS tests");
+        } else if (isSatelliteEmergencyMessagingViaCarrierAvailable()) {
             int satelliteSubId = mSubIdOfSatelliteConnectedViaCarrierWithinHysteresisTime.get();
-            mTimeoutMillis =
-                    mSatelliteController.getCarrierEmergencyCallWaitForConnectionTimeoutMillis(
-                            satelliteSubId);
+            mTimeoutMillis.set(mSatelliteController
+                    .getCarrierEmergencyCallWaitForConnectionTimeoutMillis(satelliteSubId));
         } else {
             int satelliteSubId = mSatelliteController.getSelectedSatelliteSubId();
             if (!SatelliteServiceUtils.isNtnOnlySubscriptionId(satelliteSubId)) {
-                mTimeoutMillis =
-                    mSatelliteController.getCarrierEmergencyCallWaitForConnectionTimeoutMillis(
-                        satelliteSubId);
+                mTimeoutMillis.set(mSatelliteController
+                        .getCarrierEmergencyCallWaitForConnectionTimeoutMillis(satelliteSubId));
             } else {
-                mTimeoutMillis = mOemEnabledTimeoutMillis;
+                mTimeoutMillis.set(mOemEnabledTimeoutMillis.get());
             }
         }
-        plogd("mTimeoutMillis = " + mTimeoutMillis);
+        plogd("mTimeoutMillis = " + mTimeoutMillis.get());
     }
 
     private static long getOemEnabledEmergencyCallWaitForConnectionTimeoutMillis(
@@ -692,6 +681,14 @@ public class SatelliteSOSMessageRecommender extends Handler {
         String action = getSatelliteEmergencyHandoverIntentActionFromOverlayConfig(mContext,
                 isTestEmergencyNumber);
 
+        int overriddenHandoverType =
+            mSatelliteController.getEnforcedEmergencyCallToSatelliteHandoverType();
+        if (overriddenHandoverType != INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE) {
+            handoverType = overriddenHandoverType;
+            plogd("createExtraBundleForEventDisplayEmergencyMessage: use the overridden"
+                      + " handoverType=" + handoverType);
+        }
+
         if (handoverType == EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911) {
             ComponentName defaultSmsAppComponent = getDefaultSmsApp();
             packageName = defaultSmsAppComponent.getPackageName();
@@ -718,10 +715,27 @@ public class SatelliteSOSMessageRecommender extends Handler {
             if (mEmergencyConnection != null) {
                 emergencyNumber = mEmergencyConnection.getAddress().getSchemeSpecificPart();
             }
-            plogd("emergencyNumber=" + emergencyNumber);
 
             Uri uri = Uri.parse("smsto:" + emergencyNumber);
             intent = new Intent(Intent.ACTION_SENDTO, uri);
+
+            // Populate the sim slot id for launching T911 conversation thread.
+            int simSlotId = 0;
+            if (mSatelliteController.getEnforcedEmergencyCallToSatelliteHandoverType()
+                    == EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911) {
+                simSlotId = mSatelliteController.getSimSlotIdForLaunchingT911ConversationThread();
+                plogd("Use the overridden simSlotId=" + simSlotId);
+            } else {
+                simSlotId = mSubscriptionManager.getSlotIndex(
+                    mSubIdOfSatelliteConnectedViaCarrierWithinHysteresisTime.get());
+            }
+            if (simSlotId != SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
+                intent.putExtra(TelephonyManager.EXTRA_SIM_SLOT_ID, simSlotId);
+                plogd("emergencyNumber=" + emergencyNumber + ", EXTRA_SIM_SLOT_ID="
+                      + intent.getIntExtra(TelephonyManager.EXTRA_SIM_SLOT_ID, -1));
+            } else {
+                plogd("emergencyNumber=" + emergencyNumber);
+            }
         } else {
             intent = new Intent(action);
             intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP);
@@ -731,6 +745,7 @@ public class SatelliteSOSMessageRecommender extends Handler {
                         ActivityOptions.MODE_BACKGROUND_ACTIVITY_START_ALLOWED)
                 .toBundle();
         intent.setComponent(new ComponentName(packageName, className));
+        plogd("Launching intent: intent=" + intent);
         return PendingIntent.getActivity(mContext, 0, intent,
                 PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE, activityOptions);
     }
@@ -773,7 +788,7 @@ public class SatelliteSOSMessageRecommender extends Handler {
     }
 
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
-    public int getEmergencyCallToSatelliteHandoverType() {
+    protected int getEmergencyCallToSatelliteHandoverType() {
         if (isSatelliteEmergencyMessagingViaCarrierAvailable()) {
             int satelliteSubId = mSubIdOfSatelliteConnectedViaCarrierWithinHysteresisTime.get();
             return mSatelliteController.getCarrierRoamingNtnEmergencyCallToSatelliteHandoverType(
@@ -790,13 +805,11 @@ public class SatelliteSOSMessageRecommender extends Handler {
     }
 
     private void requestIsSatelliteAllowedForCurrentLocation() {
-        synchronized (mLock) {
-            if (mCheckingAccessRestrictionInProgress) {
-                plogd("requestIsSatelliteCommunicationAllowedForCurrentLocation was already sent");
-                return;
-            }
-            mCheckingAccessRestrictionInProgress = true;
+        if (mCheckingAccessRestrictionInProgress.get()) {
+            plogd("requestIsSatelliteCommunicationAllowedForCurrentLocation was already sent");
+            return;
         }
+        mCheckingAccessRestrictionInProgress.set(true);
 
         OutcomeReceiver<Boolean, SatelliteManager.SatelliteException> callback =
                 new OutcomeReceiver<>() {
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteServiceUtils.java b/src/java/com/android/internal/telephony/satellite/SatelliteServiceUtils.java
index fd47c16ee1..dcbd0701b3 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteServiceUtils.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteServiceUtils.java
@@ -36,6 +36,7 @@ import android.telephony.PersistentLogger;
 import android.telephony.ServiceState;
 import android.telephony.SubscriptionInfo;
 import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
 import android.telephony.satellite.AntennaPosition;
 import android.telephony.satellite.EarfcnRange;
 import android.telephony.satellite.NtnSignalStrength;
@@ -738,6 +739,13 @@ public class SatelliteServiceUtils {
         return satelliteController.isInCarrierRoamingNbIotNtn(phone);
     }
 
+    /** Returns the carrier ID of the given subscription id. */
+    public static int getCarrierIdFromSubscription(int subId) {
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        return phone != null ? phone.getCarrierId() : TelephonyManager.UNKNOWN_CARRIER_ID;
+    }
+
     private static void logd(@NonNull String log) {
         Log.d(TAG, log);
     }
diff --git a/src/java/com/android/internal/telephony/satellite/SatelliteSessionController.java b/src/java/com/android/internal/telephony/satellite/SatelliteSessionController.java
index 5f23e0989b..ed7b316640 100644
--- a/src/java/com/android/internal/telephony/satellite/SatelliteSessionController.java
+++ b/src/java/com/android/internal/telephony/satellite/SatelliteSessionController.java
@@ -79,6 +79,7 @@ import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.satellite.metrics.SessionMetricsStats;
 import com.android.internal.telephony.util.ArrayUtils;
+import com.android.internal.util.IState;
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
 import com.android.telephony.Rlog;
@@ -147,14 +148,15 @@ public class SatelliteSessionController extends StateMachine {
     private static final int DEFAULT_ESOS_INACTIVITY_TIMEOUT_SEC = 600;
     private static final long UNDEFINED_TIMESTAMP = 0L;
 
+    /** All the atomic variables are declared here. */
+    private AtomicBoolean mIsBound = new AtomicBoolean(false);
+    private AtomicBoolean mIsBinding = new AtomicBoolean(false);
+
     @NonNull private final ExponentialBackoff mExponentialBackoff;
-    @NonNull private final Object mLock = new Object();
     @Nullable
     private ISatelliteGateway mSatelliteGatewayService;
     private String mSatelliteGatewayServicePackageName = "";
     @Nullable private SatelliteGatewayServiceConnection mSatelliteGatewayServiceConnection;
-    private boolean mIsBound;
-    private boolean mIsBinding;
     private boolean mIsRegisteredScreenStateChanged = false;
 
     @NonNull private static SatelliteSessionController sInstance;
@@ -293,16 +295,13 @@ public class SatelliteSessionController extends StateMachine {
         mIsSatelliteSupported = isSatelliteSupported;
         mExponentialBackoff = new ExponentialBackoff(REBIND_INITIAL_DELAY, REBIND_MAXIMUM_DELAY,
                 REBIND_MULTIPLIER, looper, () -> {
-            synchronized (mLock) {
-                if ((mIsBound && mSatelliteGatewayService != null) || mIsBinding) {
-                    return;
-                }
+            if ((mIsBound.get() && mSatelliteGatewayService != null) || mIsBinding.get()) {
+                return;
             }
+
             if (mSatelliteGatewayServiceConnection != null) {
-                synchronized (mLock) {
-                    mIsBound = false;
-                    mIsBinding = false;
-                }
+                mIsBound.set(false);
+                mIsBinding.set(false);
                 unbindService();
             }
             bindService();
@@ -533,10 +532,8 @@ public class SatelliteSessionController extends StateMachine {
         }
 
         if (mSatelliteGatewayServiceConnection != null) {
-            synchronized (mLock) {
-                mIsBound = false;
-                mIsBinding = false;
-            }
+            mIsBound.set(false);
+            mIsBinding.set(false);
             unbindService();
             bindService();
         }
@@ -623,8 +620,15 @@ public class SatelliteSessionController extends StateMachine {
      * @return {@code true} if state machine is in enabling state and {@code false} otherwise.
      */
     public boolean isInEnablingState() {
-        if (DBG) plogd("isInEnablingState: getCurrentState=" + getCurrentState());
-        return getCurrentState() == mEnablingState;
+        try {
+            IState currentState = getCurrentState();
+            if (DBG) plogd("isInEnablingState: getCurrentState=" + currentState);
+            return currentState == mEnablingState;
+        } catch (Exception e) {
+            plogw("isInEnablingState: Exception: " + e
+                + ", mCurrentState=" + mCurrentState);
+            return mCurrentState == SatelliteManager.SATELLITE_MODEM_STATE_ENABLING_SATELLITE;
+        }
     }
 
     /**
@@ -633,8 +637,15 @@ public class SatelliteSessionController extends StateMachine {
      * @return {@code true} if state machine is in disabling state and {@code false} otherwise.
      */
     public boolean isInDisablingState() {
-        if (DBG) plogd("isInDisablingState: getCurrentState=" + getCurrentState());
-        return getCurrentState() == mDisablingState;
+        try {
+            IState currentState = getCurrentState();
+            if (DBG) plogd("isInDisablingState: getCurrentState=" + currentState);
+            return currentState == mDisablingState;
+        } catch (Exception e) {
+            plogw("isInDisablingState: Exception: " + e
+                + ", mCurrentState=" + mCurrentState);
+            return mCurrentState == SatelliteManager.SATELLITE_MODEM_STATE_DISABLING_SATELLITE;
+        }
     }
 
     /**
@@ -1537,10 +1548,8 @@ public class SatelliteSessionController extends StateMachine {
     }
 
     private void bindService() {
-        synchronized (mLock) {
-            if (mIsBinding || mIsBound) return;
-            mIsBinding = true;
-        }
+        if (mIsBinding.get() || mIsBound.get()) return;
+        mIsBinding.set(true);
         mExponentialBackoff.start();
 
         String packageName = getSatelliteGatewayPackageName();
@@ -1549,9 +1558,7 @@ public class SatelliteSessionController extends StateMachine {
                     + " undefined.");
             // Since the package name comes from static device configs, stop retry because
             // rebind will continue to fail without a valid package name.
-            synchronized (mLock) {
-                mIsBinding = false;
-            }
+            mIsBinding.set(false);
             mExponentialBackoff.stop();
             return;
         }
@@ -1565,17 +1572,13 @@ public class SatelliteSessionController extends StateMachine {
             if (success) {
                 plogd("Successfully bound to the satellite gateway service.");
             } else {
-                synchronized (mLock) {
-                    mIsBinding = false;
-                }
+                mIsBinding.set(false);
                 mExponentialBackoff.notifyFailed();
                 ploge("Error binding to the satellite gateway service. Retrying in "
                         + mExponentialBackoff.getCurrentDelay() + " ms.");
             }
         } catch (Exception e) {
-            synchronized (mLock) {
-                mIsBinding = false;
-            }
+            mIsBinding.set(false);
             mExponentialBackoff.notifyFailed();
             ploge("Exception binding to the satellite gateway service. Retrying in "
                     + mExponentialBackoff.getCurrentDelay() + " ms. Exception: " + e);
@@ -1586,10 +1589,8 @@ public class SatelliteSessionController extends StateMachine {
         plogd("unbindService");
         mExponentialBackoff.stop();
         mSatelliteGatewayService = null;
-        synchronized (mLock) {
-            mIsBinding = false;
-            mIsBound = false;
-        }
+        mIsBinding.set(false);
+        mIsBound.set(false);
         if (mSatelliteGatewayServiceConnection != null) {
             mContext.unbindService(mSatelliteGatewayServiceConnection);
             mSatelliteGatewayServiceConnection = null;
@@ -1600,10 +1601,8 @@ public class SatelliteSessionController extends StateMachine {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             plogd("onServiceConnected: ComponentName=" + name);
-            synchronized (mLock) {
-                mIsBound = true;
-                mIsBinding = false;
-            }
+            mIsBound.set(true);
+            mIsBinding.set(false);
             mSatelliteGatewayService = ISatelliteGateway.Stub.asInterface(service);
             mExponentialBackoff.stop();
         }
@@ -1611,20 +1610,16 @@ public class SatelliteSessionController extends StateMachine {
         @Override
         public void onServiceDisconnected(ComponentName name) {
             ploge("onServiceDisconnected: Waiting for reconnect.");
-            synchronized (mLock) {
-                mIsBinding = false;
-                mIsBound = false;
-            }
+            mIsBinding.set(false);
+            mIsBound.set(false);
             mSatelliteGatewayService = null;
         }
 
         @Override
         public void onBindingDied(ComponentName name) {
             ploge("onBindingDied: Unbinding and rebinding service.");
-            synchronized (mLock) {
-                mIsBound = false;
-                mIsBinding = false;
-            }
+            mIsBound.set(false);
+            mIsBinding.set(false);
             unbindService();
             mExponentialBackoff.start();
         }
diff --git a/src/java/com/android/internal/telephony/satellite/metrics/CarrierRoamingSatelliteSessionStats.java b/src/java/com/android/internal/telephony/satellite/metrics/CarrierRoamingSatelliteSessionStats.java
index 7958769676..65a6471e71 100644
--- a/src/java/com/android/internal/telephony/satellite/metrics/CarrierRoamingSatelliteSessionStats.java
+++ b/src/java/com/android/internal/telephony/satellite/metrics/CarrierRoamingSatelliteSessionStats.java
@@ -16,25 +16,44 @@
 
 package com.android.internal.telephony.satellite.metrics;
 
+import static android.telephony.TelephonyManager.ACTION_DATA_STALL_DETECTED;
+
 import android.annotation.NonNull;
 import android.app.usage.NetworkStats;
 import android.app.usage.NetworkStatsManager;
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkRequest;
 import android.net.NetworkTemplate;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
 import android.os.SystemClock;
 import android.telephony.CellInfo;
 import android.telephony.CellSignalStrength;
 import android.telephony.CellSignalStrengthLte;
 import android.telephony.NetworkRegistrationInfo;
+import android.telephony.PreciseDataConnectionState;
 import android.telephony.ServiceState;
 import android.telephony.SignalStrength;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyCallback;
 import android.telephony.TelephonyManager;
+import android.telephony.data.ApnSetting;
 import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseArray;
 
 import com.android.internal.telephony.MccTable;
 import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.metrics.SatelliteStats;
 import com.android.internal.telephony.satellite.SatelliteConstants;
 import com.android.internal.telephony.satellite.SatelliteServiceUtils;
@@ -44,9 +63,14 @@ import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.OptionalDouble;
 import java.util.Set;
+import java.util.concurrent.Executor;
 
 public class CarrierRoamingSatelliteSessionStats {
     private static final String TAG = CarrierRoamingSatelliteSessionStats.class.getSimpleName();
@@ -71,6 +95,185 @@ public class CarrierRoamingSatelliteSessionStats {
     private Context mContext;
     private long mSatelliteDataConsumedBytes = 0L;
     private long mDataUsageOnSessionStartBytes = 0L;
+    private Map<String, Long> mPerAppDataUsageOnSessionStartMap = new HashMap<>();
+    private Map<String, Integer> mSatelliteAppUidMap = new HashMap<>();
+    private int[] mLastFailCauses = new int[5];
+    private int mCountOfDataConnections = 0;
+    private int mCountOfDataDisconnections = 0;
+    private int mCurrentState = TelephonyManager.DATA_DISCONNECTED;
+    private int mFailCauseIndex = 0;
+    private int mCountOfDataStalls = 0;
+    private int mSumOfDownlinkBandwidthKbps = 0;
+    private int mSumOfUplinkBandwidthKbps = 0;
+    private int mAverageUplinkBandwidthKbps = 0;
+    private int mAverageDownlinkBandwidthKbps = 0;
+    private int mMinUplinkBandwidthKbps = Integer.MAX_VALUE;
+    private int mMaxUplinkBandwidthKbps = 0;
+    private int mMaxDownlinkBandwidthKbps = 0;
+    private int mMinDownlinkBandwidthKbps = Integer.MAX_VALUE;
+    private final Executor mExecutor = Runnable::run;
+    private DataStallIntentReceiver mDataStallIntentReceiver;
+    private TelephonyListenerImpl mTelephonyListener;
+    private ConnectivityManager mConnectivityManager;
+    private NetworkCapabilities mNetworkcapabilities;
+    @NonNull private FeatureFlags mFeatureFlags;
+    String[] mSatelliteAppsPackageNameArray = null;
+    private long[] mPerAppSatelliteDataConsumedBytesArray = new long[]{0L};
+    private static final int MAX_SATELLITE_TOP_APPS_TRACKED = 5;
+    private int[] mSatelliteAppsUidArray = new int[MAX_SATELLITE_TOP_APPS_TRACKED];
+
+    private final ConnectivityManager.NetworkCallback mNetworkCallback =
+            new ConnectivityManager.NetworkCallback() {
+                @Override
+                public void onAvailable(Network network) {
+                    logd("On Available: " + network);
+                    if (network != null) {
+                        if (mConnectivityManager != null) {
+                            mNetworkcapabilities =
+                                    mConnectivityManager.getNetworkCapabilities(network);
+                            if (mNetworkcapabilities != null
+                                    && mNetworkcapabilities.hasTransport(
+                                    NetworkCapabilities.TRANSPORT_SATELLITE)
+                                    && mNetworkcapabilities.hasCapability(
+                                    NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
+                                logd("found satellite data connection");
+                                startDataConnectionTracker();
+                            }
+                        }
+                    }
+                }
+
+                @Override
+                public void onCapabilitiesChanged(Network network,
+                        NetworkCapabilities networkCapabilities) {
+                    logd("onCapabilitiesChanged: " + network);
+                    mNetworkcapabilities = networkCapabilities;
+                }
+            };
+
+    public class DataStallIntentReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            if (intent.getAction().equals(ACTION_DATA_STALL_DETECTED)) {
+                Bundle dsrsStatsBundle = intent.getBundleExtra("EXTRA_DSRS_STATS_BUNDLE");
+                if (dsrsStatsBundle != null && dsrsStatsBundle.containsKey("IsRecovered")) {
+                    boolean isRecovered = false;
+                    if (dsrsStatsBundle.get("IsRecovered") instanceof Integer) {
+                        isRecovered = dsrsStatsBundle.getInt("IsRecovered") == 1;
+                    } else if (dsrsStatsBundle.get("IsRecovered") instanceof Boolean) {
+                        isRecovered = dsrsStatsBundle.getBoolean("IsRecovered");
+                    }
+                    if (!isRecovered && mCurrentState == TelephonyManager.DATA_CONNECTED) {
+                        mCountOfDataStalls++;
+                        logd("data stall count: " + mCountOfDataStalls);
+                    }
+                }
+            }
+        }
+    };
+
+    private class TelephonyListenerImpl extends TelephonyCallback
+            implements TelephonyCallback.PreciseDataConnectionStateListener {
+        private final Executor mExecutor;
+        private TelephonyManager mTelephonyManager = null;
+
+        TelephonyListenerImpl(Executor executor) {
+            mExecutor = executor;
+        }
+
+        public void register(TelephonyManager tm) {
+            if (tm == null) {
+                return;
+            }
+            mTelephonyManager = tm;
+            mTelephonyManager.registerTelephonyCallback(mExecutor, this);
+        }
+
+        public void unregister() {
+            if (mTelephonyManager != null) {
+                mTelephonyManager.unregisterTelephonyCallback(this);
+                mTelephonyManager = null;
+            }
+        }
+
+        @Override
+        public void onPreciseDataConnectionStateChanged(
+                @NonNull PreciseDataConnectionState preciseDataConnectionState) {
+            // For debugging purpose
+            logd("Received PrecisionDataStateChange:" + preciseDataConnectionState);
+            if (preciseDataConnectionState != null) {
+                int apnTypeBitMask = preciseDataConnectionState.getApnSetting().getApnTypeBitmask();
+                if ((apnTypeBitMask & ApnSetting.TYPE_DEFAULT) > 0) {
+                    int newState = preciseDataConnectionState.getState();
+                    logd("Internet Connection status: " + newState);
+                    if (mCurrentState != newState) {
+                        if (newState == TelephonyManager.DATA_CONNECTED) {
+                            handleConnection();
+                            updateLinkBandwidthForConnection();
+                        } else if (newState == TelephonyManager.DATA_DISCONNECTED) {
+                            handleDisconnection();
+                            storeFailCause(preciseDataConnectionState.getLastCauseCode());
+                        }
+                    }
+                }
+            }
+        }
+    };
+
+    private void updateLinkBandwidthForConnection() {
+        if (mNetworkcapabilities != null) {
+            int uplink = mNetworkcapabilities.getLinkUpstreamBandwidthKbps();
+            int downlink = mNetworkcapabilities.getLinkDownstreamBandwidthKbps();
+
+            mSumOfUplinkBandwidthKbps += uplink;
+            mSumOfDownlinkBandwidthKbps += downlink;
+
+            if (uplink > 0) {
+                mMaxUplinkBandwidthKbps = Math.max(mMaxUplinkBandwidthKbps, uplink);
+                mMinUplinkBandwidthKbps = Math.min(mMinUplinkBandwidthKbps, uplink);
+
+            }
+            if (downlink > 0) {
+                mMaxDownlinkBandwidthKbps = Math.max(mMaxDownlinkBandwidthKbps, downlink);
+                mMinDownlinkBandwidthKbps = Math.min(mMinDownlinkBandwidthKbps, downlink);
+            }
+        } else {
+            loge("networkcapabilities found null");
+        }
+    }
+
+    private boolean registerTelephonyListener() {
+        int subId = mPhone.getSubId();
+        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            return false;
+        }
+
+        TelephonyManager telephonyManager = mContext.getSystemService(TelephonyManager.class);
+        if (telephonyManager != null) {
+            mTelephonyListener = new TelephonyListenerImpl(mExecutor);
+            mTelephonyListener.register(telephonyManager.createForSubscriptionId(subId));
+        }
+
+        return true;
+    }
+
+    private void handleConnection() {
+        mCountOfDataConnections++;
+        logd("Connection established. Total connections: " + mCountOfDataConnections);
+        mCurrentState = TelephonyManager.DATA_CONNECTED;
+    }
+
+    private void handleDisconnection() {
+        mCountOfDataDisconnections++;
+        logd("Connection lost. Total disconnections: " + mCountOfDataDisconnections);
+        mCurrentState = TelephonyManager.DATA_DISCONNECTED;
+    }
+
+    private void storeFailCause(int failCause) {
+        mLastFailCauses[mFailCauseIndex] = failCause;
+        mFailCauseIndex = (mFailCauseIndex + 1) % 5; // Circular buffer
+        logd("current fail causes: " + Arrays.toString(mLastFailCauses));
+    }
 
     public CarrierRoamingSatelliteSessionStats(int subId) {
         logd("Create new CarrierRoamingSatelliteSessionStats. subId=" + subId);
@@ -82,16 +285,18 @@ public class CarrierRoamingSatelliteSessionStats {
     public static CarrierRoamingSatelliteSessionStats getInstance(int subId) {
         synchronized (sCarrierRoamingSatelliteSessionStats) {
             if (sCarrierRoamingSatelliteSessionStats.get(subId) == null) {
-                sCarrierRoamingSatelliteSessionStats.put(subId,
-                        new CarrierRoamingSatelliteSessionStats(subId));
+                sCarrierRoamingSatelliteSessionStats.put(
+                        subId, new CarrierRoamingSatelliteSessionStats(subId));
             }
             return sCarrierRoamingSatelliteSessionStats.get(subId);
         }
     }
 
     /** Log carrier roaming satellite session start */
-    public void onSessionStart(int carrierId, Phone phone, int[] supportedServices,
-            int serviceDataPolicy) {
+    public void onSessionStart(
+            int carrierId, Phone phone, int[] supportedServices, int serviceDataPolicy,
+            List<String> satelliteApps,
+            @NonNull FeatureFlags featureFlags) {
         mPhone = phone;
         mContext = mPhone.getContext();
         mCarrierId = carrierId;
@@ -102,6 +307,11 @@ public class CarrierRoamingSatelliteSessionStats {
         onConnectionStart(mPhone);
         mDataUsageOnSessionStartBytes = getDataUsage();
         logd("current data consumed: " + mDataUsageOnSessionStartBytes);
+        mFeatureFlags = featureFlags;
+        registerForSatelliteDataNetworkCallback();
+        if (mFeatureFlags.satelliteDataMetrics()) {
+            mPerAppDataUsageOnSessionStartMap = getPerAppSatelliteDataUsage(satelliteApps);
+        }
     }
 
     /** Log carrier roaming satellite connection start */
@@ -110,6 +320,57 @@ public class CarrierRoamingSatelliteSessionStats {
         updateNtnRoamingInHomeCountry(phone);
     }
 
+    private void registerDataStallIntentReceiver() {
+        if (mDataStallIntentReceiver == null) {
+            logd("Track data stall status");
+            mDataStallIntentReceiver = new DataStallIntentReceiver();
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ACTION_DATA_STALL_DETECTED);
+            mContext.registerReceiver(mDataStallIntentReceiver, filter, Context.RECEIVER_EXPORTED);
+        }
+    }
+
+    private void registerForSatelliteDataNetworkCallback() {
+        if (!mFeatureFlags.satelliteDataMetrics()) {
+            return;
+        }
+
+        NetworkRequest.Builder builder = new NetworkRequest.Builder();
+        builder.addTransportType(NetworkCapabilities.TRANSPORT_SATELLITE);
+        builder.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED);
+        builder.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED);
+        mConnectivityManager = (ConnectivityManager) mPhone.getContext()
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        if (mConnectivityManager != null) {
+            logd("register for best matching");
+            HandlerThread satelliteNetworkHandlerThread = new HandlerThread(
+                    "SatelliteNetworkCallbackThread");
+            satelliteNetworkHandlerThread.start(); // Start the thread
+            Handler satelliteNetworkHandler =
+                    new Handler(satelliteNetworkHandlerThread.getLooper());
+            mConnectivityManager.registerBestMatchingNetworkCallback(
+                    builder.build(), mNetworkCallback, satelliteNetworkHandler);
+        } else {
+            loge("network callback not registered");
+        }
+    }
+
+    private void startDataConnectionTracker() {
+        logd("Start tracking data disconnection for the cause");
+
+        if (mTelephonyListener ==  null) {
+            // track precision data state changes
+            if (registerTelephonyListener()) {
+                // track data stall status
+                registerDataStallIntentReceiver();
+            } else {
+                loge("fails tor register for precision data connection state change");
+            }
+        } else {
+            loge("telephony listener is registered");
+        }
+    }
+
     /** calculate total satellite data consumed at the session */
     private long getDataUsage() {
         if (mContext == null) {
@@ -130,16 +391,155 @@ public class CarrierRoamingSatelliteSessionStats {
                 // Consider data usage calculation of only metered capabilities / data network
                 builder.setMeteredness(android.net.NetworkStats.METERED_YES);
                 NetworkTemplate template = builder.build();
-                final NetworkStats.Bucket ret = networkStatsManager
-                        .querySummaryForDevice(template, 0L, System.currentTimeMillis());
+                final NetworkStats.Bucket ret =
+                        networkStatsManager.querySummaryForDevice(
+                                template, 0L, System.currentTimeMillis());
                 return ret.getRxBytes() + ret.getTxBytes();
             }
         }
         return 0L;
     }
 
+    private void stopDataConnectionTracker() {
+        logd("deregister tracking data disconnection and cause");
+        // unregister the data stall intent receiver
+        if (mDataStallIntentReceiver != null) {
+            mContext.unregisterReceiver(mDataStallIntentReceiver);
+            mDataStallIntentReceiver = null;
+        }
+
+        // unregister the precise data connection state change listener
+        if (mTelephonyListener != null) {
+            mTelephonyListener.unregister();
+            mTelephonyListener = null;
+        }
+    }
+
+    private int updateAvgBandwidthForSession(int bandwidth, int numConnections) {
+        double result = (double) bandwidth / numConnections; // Cast to double for accurate division
+        return (int) Math.round(result); // Round to the nearest int
+    }
+
+    private void deregisterSatelliteDataNetworkCallback() {
+        logd("unregister callbacks");
+        // Session End can be received before onLost() at network callback. So stop the
+        // listener and data stall intent receiver tracking if running
+        stopDataConnectionTracker();
+        if (mConnectivityManager != null) {
+            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
+            mConnectivityManager = null;
+        }
+    }
+
+    private void logSatelliteAppData() {
+        if (mSatelliteAppsPackageNameArray == null || mSatelliteAppsPackageNameArray.length == 0) {
+            Log.d(TAG, "No satellite app data to log.");
+            return;
+        }
+
+        for (int i = 0; i < mSatelliteAppsPackageNameArray.length; i++) {
+            // Ensure array bounds are checked if arrays might not be perfectly synchronized,
+            // though in this context they should be of the same length.
+            if (i < mSatelliteAppsUidArray.length
+                    && i < mPerAppSatelliteDataConsumedBytesArray.length) {
+                Log.d(TAG, "Package: " + mSatelliteAppsPackageNameArray[i]
+                        + ", UID: " + mSatelliteAppsUidArray[i]
+                        + ", Bytes: " + mPerAppSatelliteDataConsumedBytesArray[i]);
+            } else {
+                Log.w(TAG, "Mismatched array lengths at index: "
+                        + i + ". Skipping logging for this entry.");
+                break; // Or continue, depending on desired behavior
+            }
+        }
+    }
+
+    private void updatePerAppDataConsumedMaptoArray(Map<String, Long> appDataUsageMap) {
+        if (appDataUsageMap == null || appDataUsageMap.isEmpty()) {
+            Log.w(TAG, "No satellite data usage found. The app data usage map is null or empty.");
+            return;
+        }
+
+        // Extract package names
+        mSatelliteAppsPackageNameArray = appDataUsageMap.keySet().toArray(new String[0]);
+
+        // Extract UIDs using streams
+        mSatelliteAppsUidArray = Arrays.stream(mSatelliteAppsPackageNameArray)
+                .mapToInt(packageName -> mSatelliteAppUidMap.getOrDefault(packageName, -1))
+                .toArray();
+
+        // Extract data consumption bytes
+        mPerAppSatelliteDataConsumedBytesArray = appDataUsageMap.values().stream()
+                .mapToLong(Long::longValue) // Convert Long objects to primitive long values
+                .toArray();
+
+        // Log the processed data for verification
+        logSatelliteAppData();
+    }
+
+    private Map<String, Long> computePerAppSatelliteDataUsageWithSession(Map<String, Long> map2) {
+        // The satelliteSessionUsageMap is initialized as a HashMap, and now the method signature
+        // explicitly states that a HashMap will be returned.
+        HashMap<String, Long> satelliteSessionUsageMap = new HashMap<>();
+
+        // Iterate through each entry in Map2
+        for (Map.Entry<String, Long> entry : map2.entrySet()) {
+            String key = entry.getKey();
+            Long currentDataUsageBytes = entry.getValue();
+
+            // Check if the key from Map2 exists in Map1
+            if (mPerAppDataUsageOnSessionStartMap.containsKey(key)) {
+                Long initialDataUsageBytes =
+                        mPerAppDataUsageOnSessionStartMap.get(key);
+                // If available, find the difference (Map2 - Map1)
+                satelliteSessionUsageMap.put(key,
+                        currentDataUsageBytes
+                                - initialDataUsageBytes);
+            } else {
+                // If Map2 key is not found in Map1,
+                // add Map2 key and its corresponding value to the new map
+                satelliteSessionUsageMap.put(key, currentDataUsageBytes);
+            }
+        }
+        return satelliteSessionUsageMap;
+    }
+
+    private Map<String, Long> findTopNPackagesWithMaxData(Map<String, Long> dataConsumptionMap) {
+
+        // Handle null or empty input map
+        if (dataConsumptionMap == null || dataConsumptionMap.isEmpty()) {
+            return new HashMap<>(); // Return an empty HashMap
+        }
+
+        // Convert the HashMap to a List of Map.Entry for sorting
+        List<Map.Entry<String, Long>> list =
+                new LinkedList<>(dataConsumptionMap.entrySet());
+
+        // Sort the list in descending order of data consumed
+        Collections.sort(list, new Comparator<Map.Entry<String, Long>>() {
+            public int compare(Map.Entry<String, Long> o1,
+                    Map.Entry<String, Long> o2) {
+                return (o2.getValue()).compareTo(o1.getValue());
+            }
+        });
+
+        // Create a HashMap to store the top 5 entries (order is not guaranteed)
+        HashMap<String, Long> result = new HashMap<>();
+        int count = 0;
+        for (Map.Entry<String, Long> entry : list) {
+            if (count < MAX_SATELLITE_TOP_APPS_TRACKED) {
+                result.put(entry.getKey(), entry.getValue());
+                count++;
+            } else {
+                // We have found our top 5
+                break;
+            }
+        }
+
+        return result;
+    }
+
     /** Log carrier roaming satellite session end */
-    public void onSessionEnd(int subId) {
+    public void onSessionEnd(int subId, List<String> satelliteApps) {
         onConnectionEnd();
         long dataUsageOnSessionEndBytes = getDataUsage();
         logd("update data consumed: " + dataUsageOnSessionEndBytes);
@@ -149,12 +549,173 @@ public class CarrierRoamingSatelliteSessionStats {
                     dataUsageOnSessionEndBytes - mDataUsageOnSessionStartBytes;
         }
         logd("satellite data consumed at session: " + mSatelliteDataConsumedBytes);
+
+        if (mFeatureFlags.satelliteDataMetrics()) {
+            Map<String, Long> perAppDataUsageOnSessionEndMap = getPerAppSatelliteDataUsage(
+                    satelliteApps);
+            if (!perAppDataUsageOnSessionEndMap.isEmpty()) {
+                Map<String, Long> currSatelliteSessionPerAppDataUsageMap =
+                        computePerAppSatelliteDataUsageWithSession(perAppDataUsageOnSessionEndMap);
+                Map<String, Long> top5PackagesWithMaxDataMap =
+                        findTopNPackagesWithMaxData(currSatelliteSessionPerAppDataUsageMap);
+                logd("top 5 satellite data usage apps:" + top5PackagesWithMaxDataMap);
+                updatePerAppDataConsumedMaptoArray(top5PackagesWithMaxDataMap);
+            } else {
+                loge("per app satellite consumed array is empty");
+            }
+        }
+
+        if (mSumOfDownlinkBandwidthKbps > 0 && mCountOfDataConnections > 0) {
+            mAverageDownlinkBandwidthKbps = updateAvgBandwidthForSession(
+                    mSumOfDownlinkBandwidthKbps, mCountOfDataConnections);
+        }
+        if (mSumOfUplinkBandwidthKbps > 0 && mCountOfDataConnections > 0) {
+            mAverageUplinkBandwidthKbps = updateAvgBandwidthForSession(mSumOfUplinkBandwidthKbps,
+                    mCountOfDataConnections);
+        }
+        if (mCurrentState == TelephonyManager.DATA_CONNECTED) {
+            handleDisconnection();
+            storeFailCause(65535 /*lost connection cause*/);
+        }
         reportMetrics(subId);
         mIsNtnRoamingInHomeCountry = false;
         mSupportedSatelliteServices = new int[0];
         mServiceDataPolicy = SatelliteConstants.SATELLITE_ENTITLEMENT_SERVICE_POLICY_UNKNOWN;
         mSatelliteDataConsumedBytes = 0L;
+        mSatelliteAppsPackageNameArray = null;
+        Arrays.fill(mSatelliteAppsUidArray, 0);
+        mPerAppSatelliteDataConsumedBytesArray = new long[]{0L};
         mDataUsageOnSessionStartBytes = 0L;
+        resetSatelliteDataState();
+    }
+
+    private Map<String, Integer> updatePackageNameWithUids(List<String> satelliteApps) {
+        HashMap<String, Integer> satelliteAppMap = new HashMap<>();
+
+        try {
+            if (mContext == null) {
+                // Log an error or throw an exception if context is null
+                // For example: Log.e("AppUidResolver", "Context cannot be null.");
+                return satelliteAppMap;
+            }
+
+            if (satelliteApps == null || satelliteApps.isEmpty()) {
+                return satelliteAppMap;
+            }
+
+            PackageManager packageManager = mContext.getPackageManager();
+            for (String packageName : satelliteApps) {
+                try {
+                    // Get ApplicationInfo for the package.
+                    // The flag 0 means no specific flags are requested.
+                    ApplicationInfo appInfo = packageManager.getApplicationInfo(packageName, 0);
+                    // Load the label (application name) using the PackageManager
+                    satelliteAppMap.put(packageName, appInfo.uid);
+                } catch (PackageManager.NameNotFoundException e) {
+                    loge("Package Manager found exception");
+                }
+            }
+        } catch (Exception e) {
+            loge("found exception on finding uids:" + e);
+        }
+        return satelliteAppMap;
+    }
+
+    private String findKeysByValue(Map<String, Integer> map, Integer targetValue) {
+        String key = null;
+
+        if (map == null || map.isEmpty()) {
+            logd("Found Packagename: " + null);
+            return key;
+        }
+
+        for (Map.Entry<String, Integer> entry : map.entrySet()) {
+            if (entry.getValue().equals(targetValue)) {
+                key = entry.getKey();
+                logd("Found Packagename: " + key);
+            }
+        }
+        return key;
+    }
+
+    private void updateDataUsageMap(NetworkStats networkStats, Map<String, Long> dataUsageMap) {
+        long totalBytes;
+        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
+        while (networkStats.hasNextBucket()) {
+            totalBytes = 0L;
+            networkStats.getNextBucket(bucket);
+            if (bucket.getUid() != -1 && mSatelliteAppUidMap.containsValue(bucket.getUid())) {
+                String packageName =
+                        findKeysByValue(mSatelliteAppUidMap, bucket.getUid());
+                if (dataUsageMap.containsKey(packageName)) {
+                    totalBytes = dataUsageMap.getOrDefault(packageName, 0L);
+                }
+                totalBytes += bucket.getRxBytes() + bucket.getTxBytes();
+                if (totalBytes > 0) {
+                    dataUsageMap.put(packageName, totalBytes);
+                }
+            }
+        }
+    }
+
+    private Map<String, Long> getPerAppSatelliteDataUsage(@NonNull List<String> satelliteApps) {
+        Map<String, Long> dataUsageMap = new HashMap<>();
+
+        // track satellite data usage of satellite constrained apps
+        logd("satellite app List: " + satelliteApps);
+        if (!satelliteApps.isEmpty()) {
+            mSatelliteAppUidMap = updatePackageNameWithUids(satelliteApps);
+            logd("satellite App Map: " + mSatelliteAppUidMap);
+            if (!mSatelliteAppUidMap.isEmpty()) {
+                NetworkStatsManager networkStatsManager =
+                        mContext.getSystemService(NetworkStatsManager.class);
+                final String subscriberId = mPhone.getSubscriberId();
+                if (networkStatsManager != null && !TextUtils.isEmpty(subscriberId)) {
+                    final NetworkTemplate.Builder builder =
+                            new NetworkTemplate.Builder(NetworkTemplate.MATCH_MOBILE);
+                    logd("subscriber id for data consumed: " + subscriberId);
+                    try {
+                        builder.setSubscriberIds(Set.of(subscriberId));
+                        // Consider data usage calculation of only metered capabilities
+                        // data network
+                        builder.setMeteredness(android.net.NetworkStats.METERED_YES);
+                        NetworkStats networkStats;
+                        NetworkTemplate template = builder.build();
+                        networkStats =
+                                networkStatsManager.querySummary(template, 0,
+                                        System.currentTimeMillis());
+                        updateDataUsageMap(networkStats, dataUsageMap);
+                    } catch (SecurityException e) {
+                        loge("querying networkstats met with approach:" + e);
+                    }
+                }
+            }
+            logd("NetworkStats per apps: " + dataUsageMap);
+        } else {
+            loge("Satellite apps list is empty");
+        }
+        return dataUsageMap;
+    }
+
+    private void resetSatelliteDataState() {
+        if (!mFeatureFlags.satelliteDataMetrics()) {
+            return;
+        }
+        deregisterSatelliteDataNetworkCallback();
+        Arrays.fill(mLastFailCauses, 0);
+        mFailCauseIndex = 0;
+        mCurrentState = TelephonyManager.DATA_DISCONNECTED;
+        mCountOfDataConnections = 0;
+        mCountOfDataDisconnections = 0;
+        mCountOfDataStalls = 0;
+        mAverageUplinkBandwidthKbps = 0;
+        mAverageDownlinkBandwidthKbps = 0;
+        mSumOfDownlinkBandwidthKbps = 0;
+        mSumOfUplinkBandwidthKbps = 0;
+        mMinUplinkBandwidthKbps = Integer.MAX_VALUE;
+        mMaxUplinkBandwidthKbps = 0;
+        mMinDownlinkBandwidthKbps = Integer.MAX_VALUE;
+        mMaxDownlinkBandwidthKbps = 0;
     }
 
     /** Log carrier roaming satellite connection end */
@@ -225,12 +786,12 @@ public class CarrierRoamingSatelliteSessionStats {
     }
 
     private void reportMetrics(int subId) {
-        int totalSatelliteModeTimeSec = mSessionStartTimeSec > 0
-                ? getElapsedRealtimeInSec() - mSessionStartTimeSec : 0;
+        int totalSatelliteModeTimeSec =
+                mSessionStartTimeSec > 0 ? getElapsedRealtimeInSec() - mSessionStartTimeSec : 0;
         int numberOfSatelliteConnections = getNumberOfSatelliteConnections();
 
-        List<Integer> connectionGapList = getSatelliteConnectionGapList(
-                numberOfSatelliteConnections);
+        List<Integer> connectionGapList =
+                getSatelliteConnectionGapList(numberOfSatelliteConnections);
         int satelliteConnectionGapMinSec = 0;
         int satelliteConnectionGapMaxSec = 0;
         if (!connectionGapList.isEmpty()) {
@@ -263,9 +824,23 @@ public class CarrierRoamingSatelliteSessionStats {
                         .setSatelliteDataConsumedBytes(mSatelliteDataConsumedBytes)
                         .setIsMultiSim(isMultiSim)
                         .setIsNbIotNtn(SatelliteServiceUtils.isNbIotNtn(subId))
+                        .setCountOfDataConnections(mCountOfDataConnections)
+                        .setLastFailCauses(mLastFailCauses)
+                        .setCountOfDataDisconnections(mCountOfDataDisconnections)
+                        .setCountOfDataStalls(mCountOfDataStalls)
+                        .setAverageUplinkBandwidthKbps(mAverageUplinkBandwidthKbps)
+                        .setAverageDownlinkBandwidthKbps(mAverageDownlinkBandwidthKbps)
+                        .setMinimumUplinkBandwidthKbps(mMinUplinkBandwidthKbps)
+                        .setMaximumUplinkBandwidthKbps(mMaxUplinkBandwidthKbps)
+                        .setMinimumDownlinkBandwidthKbps(mMinDownlinkBandwidthKbps)
+                        .setMaximumDownlinkBandwidthKbps(mMaxDownlinkBandwidthKbps)
+                        .setSatelliteSupportedApps(mSatelliteAppsPackageNameArray)
+                        .setSatelliteSupportedUids(mSatelliteAppsUidArray)
+                        .setPerAppSatelliteDataConsumedBytes(mPerAppSatelliteDataConsumedBytesArray)
                         .build();
         SatelliteStats.getInstance().onCarrierRoamingSatelliteSessionMetrics(params);
         logd("Supported satellite services: " + Arrays.toString(mSupportedSatelliteServices));
+        logd("last fail causes: " + Arrays.toString(mLastFailCauses));
         logd("reportMetrics: " + params);
         initializeParams();
     }
@@ -308,10 +883,11 @@ public class CarrierRoamingSatelliteSessionStats {
             return 0;
         }
 
-        OptionalDouble averageDuration = mSatelliteConnectionTimesList.stream()
-                .filter(SatelliteConnectionTimes::isValid)
-                .mapToLong(SatelliteConnectionTimes::getDuration)
-                .average();
+        OptionalDouble averageDuration =
+                mSatelliteConnectionTimesList.stream()
+                        .filter(SatelliteConnectionTimes::isValid)
+                        .mapToLong(SatelliteConnectionTimes::getDuration)
+                        .average();
 
         return (int) (averageDuration.isPresent() ? averageDuration.getAsDouble() / 1000 : 0);
     }
@@ -323,15 +899,15 @@ public class CarrierRoamingSatelliteSessionStats {
 
         List<Integer> connectionGapList = new ArrayList<>();
         for (int i = 1; i < mSatelliteConnectionTimesList.size(); i++) {
-            SatelliteConnectionTimes prevConnection =
-                    mSatelliteConnectionTimesList.get(i - 1);
-            SatelliteConnectionTimes currentConnection =
-                    mSatelliteConnectionTimesList.get(i);
+            SatelliteConnectionTimes prevConnection = mSatelliteConnectionTimesList.get(i - 1);
+            SatelliteConnectionTimes currentConnection = mSatelliteConnectionTimesList.get(i);
 
             if (prevConnection.getEndTime() > 0
                     && currentConnection.getStartTime() > prevConnection.getEndTime()) {
-                int gap = (int) ((currentConnection.getStartTime() - prevConnection.getEndTime())
-                        / 1000);
+                int gap =
+                        (int)
+                                ((currentConnection.getStartTime() - prevConnection.getEndTime())
+                                        / 1000);
                 connectionGapList.add(gap);
             }
         }
@@ -361,7 +937,8 @@ public class CarrierRoamingSatelliteSessionStats {
         }
 
         Collections.sort(list);
-        return size % 2 == 0 ? (list.get(size / 2 - 1) + list.get(size / 2)) / 2
+        return size % 2 == 0
+                ? (list.get(size / 2 - 1) + list.get(size / 2)) / 2
                 : list.get(size / 2);
     }
 
@@ -386,8 +963,7 @@ public class CarrierRoamingSatelliteSessionStats {
         }
 
         String satelliteRegisteredPlmn = "";
-        for (NetworkRegistrationInfo nri
-                : serviceState.getNetworkRegistrationInfoList()) {
+        for (NetworkRegistrationInfo nri : serviceState.getNetworkRegistrationInfoList()) {
             if (nri.isNonTerrestrialNetwork()) {
                 satelliteRegisteredPlmn = nri.getRegisteredPlmn();
             }
@@ -401,10 +977,9 @@ public class CarrierRoamingSatelliteSessionStats {
         }
         String simCountry = MccTable.countryCodeForMcc(subscriptionInfoInternal.getMcc());
         mIsNtnRoamingInHomeCountry = true;
-        if (satelliteRegisteredPlmn != null
-                && satelliteRegisteredPlmn.length() >= 3) {
-            String satelliteRegisteredCountry = MccTable.countryCodeForMcc(
-                    satelliteRegisteredPlmn.substring(0, 3));
+        if (satelliteRegisteredPlmn != null && satelliteRegisteredPlmn.length() >= 3) {
+            String satelliteRegisteredCountry =
+                    MccTable.countryCodeForMcc(satelliteRegisteredPlmn.substring(0, 3));
             if (simCountry.equalsIgnoreCase(satelliteRegisteredCountry)) {
                 mIsNtnRoamingInHomeCountry = true;
             } else {
@@ -413,8 +988,9 @@ public class CarrierRoamingSatelliteSessionStats {
                 mIsNtnRoamingInHomeCountry = false;
             }
         }
-        logd("updateNtnRoamingInHomeCountry: mIsNtnRoamingInHomeCountry="
-                + mIsNtnRoamingInHomeCountry);
+        logd(
+                "updateNtnRoamingInHomeCountry: mIsNtnRoamingInHomeCountry="
+                        + mIsNtnRoamingInHomeCountry);
     }
 
     private static class SatelliteConnectionTimes {
diff --git a/src/java/com/android/internal/telephony/satellite/metrics/ControllerMetricsStats.java b/src/java/com/android/internal/telephony/satellite/metrics/ControllerMetricsStats.java
index 571c1054fa..7e672d7ed4 100644
--- a/src/java/com/android/internal/telephony/satellite/metrics/ControllerMetricsStats.java
+++ b/src/java/com/android/internal/telephony/satellite/metrics/ControllerMetricsStats.java
@@ -390,12 +390,13 @@ public class ControllerMetricsStats {
     }
 
     /** Capture the latest provisioned state for satellite service */
-    @VisibleForTesting
-    public void setIsProvisioned(boolean isProvisioned) {
-        logd("setIsProvisioned:" + isProvisioned);
+    public void setIsProvisioned(int carrierId, boolean isProvisioned, boolean isNtnOnlyCarrier) {
+        logd("setIsProvisioned: carrierId=" + carrierId + ", isProvisioned=" + isProvisioned);
         mSatelliteStats.onSatelliteControllerMetrics(
                 new SatelliteStats.SatelliteControllerParams.Builder()
+                        .setCarrierId(carrierId)
                         .setIsProvisioned(isProvisioned)
+                        .setIsNtnOnlyCarrier(isNtnOnlyCarrier)
                         .build());
     }
 
@@ -447,6 +448,32 @@ public class ControllerMetricsStats {
                         .build());
     }
 
+    /**
+     * Report a current version of carrier roaming satellite config.
+     */
+    public void reportCurrentVersionOfCarrierRoamingSatelliteConfig(int cid, int version) {
+        logd("reportCurrentVersionOfCarrierRoamingSatelliteConfig: cid=" + cid
+                + " version=" + version);
+        mSatelliteStats.onSatelliteControllerMetrics(
+                new SatelliteStats.SatelliteControllerParams.Builder()
+                        .setCarrierId(cid)
+                        .setCarrierRoamingSatelliteConfigVersion(version)
+                        .build());
+    }
+
+    /**
+     * Report a current max allowed data mode.
+     */
+    public void reportCurrentMaxAllowedDataMode(int cid, int maxAllowedDataMode) {
+        logd("reportCurrentMaxAllowedDataMode: cid=" + cid
+                + " maxAllowedDataMode=" + maxAllowedDataMode);
+        mSatelliteStats.onSatelliteControllerMetrics(
+                new SatelliteStats.SatelliteControllerParams.Builder()
+                        .setCarrierId(cid)
+                        .setMaxAllowedDataMode(maxAllowedDataMode)
+                        .build());
+    }
+
     /**
      * Add count when the notification for P2P SMS over satellite avaibility is shown or removed.
      */
diff --git a/src/java/com/android/internal/telephony/security/CellularNetworkSecuritySafetySource.java b/src/java/com/android/internal/telephony/security/CellularNetworkSecuritySafetySource.java
index 2d4776c387..053345ab31 100644
--- a/src/java/com/android/internal/telephony/security/CellularNetworkSecuritySafetySource.java
+++ b/src/java/com/android/internal/telephony/security/CellularNetworkSecuritySafetySource.java
@@ -23,8 +23,10 @@ import static android.safetycenter.SafetySourceData.SEVERITY_LEVEL_RECOMMENDATIO
 
 import android.annotation.IntDef;
 import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.safetycenter.SafetyCenterManager;
@@ -42,10 +44,9 @@ import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.time.Instant;
-import java.time.ZoneId;
-import java.time.format.DateTimeFormatter;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.HashMap;
-import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Stream;
@@ -91,6 +92,9 @@ public class CellularNetworkSecuritySafetySource {
     private boolean mIdentifierDisclosureIssuesEnabled;
     private HashMap<Integer, IdentifierDisclosure> mIdentifierDisclosures = new HashMap<>();
 
+    // Broadcast receiver for airplane mode intent broadcasts
+    private final BroadcastReceiver mReceiver = new CellularNetworkSecurityBroadcastReceiver();
+
     /**
      * Gets a singleton CellularNetworkSecuritySafetySource.
      */
@@ -111,9 +115,22 @@ public class CellularNetworkSecuritySafetySource {
 
     /** Enables or disables the null cipher issue and clears any current issues. */
     public synchronized void setNullCipherIssueEnabled(Context context, boolean enabled) {
-        mNullCipherStateIssuesEnabled = enabled;
-        mNullCipherStates.clear();
-        updateSafetyCenter(context);
+        // This check ensures that if we're enabled and we are asked to enable ourselves again (can
+        // happen if the modem restarts), we don't clear our state.
+        if (enabled != mNullCipherStateIssuesEnabled) {
+            mNullCipherStateIssuesEnabled = enabled;
+            mNullCipherStates.clear();
+            updateSafetyCenter(context);
+            if (enabled) {
+                // Register for airplane mode intent broadcasts.
+                IntentFilter intentFilter =
+                        new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+                context.registerReceiver(mReceiver, intentFilter);
+            } else {
+                // Unregister for airplane mode intent broadcasts.
+                context.unregisterReceiver(mReceiver);
+            }
+        }
     }
 
     /** Sets the null cipher issue state for the identified subscription. */
@@ -241,7 +258,7 @@ public class CellularNetworkSecuritySafetySource {
                 break;
             case NULL_CIPHER_STATE_NOTIFY_ENCRYPTED:
                 builder = new SafetySourceIssue.Builder(
-                        NULL_CIPHER_ISSUE_NON_ENCRYPTED_ID + "_" + subId,
+                        NULL_CIPHER_ISSUE_ENCRYPTED_ID + "_" + subId,
                         context.getString(
                                 R.string.scNullCipherIssueEncryptedTitle,
                                 subInfo.getDisplayName()),
@@ -307,7 +324,7 @@ public class CellularNetworkSecuritySafetySource {
                         context.getString(R.string.scIdentifierDisclosureIssueTitle),
                         context.getString(
                                 R.string.scIdentifierDisclosureIssueSummaryNotification,
-                                getCurrentTime(),
+                                getCurrentTime(context),
                                 subInfo.getDisplayName())).build();
         SafetySourceIssue.Builder builder =
                 new SafetySourceIssue.Builder(
@@ -315,7 +332,7 @@ public class CellularNetworkSecuritySafetySource {
                         context.getString(R.string.scIdentifierDisclosureIssueTitle),
                         context.getString(
                                 R.string.scIdentifierDisclosureIssueSummary,
-                                getCurrentTime(),
+                                getCurrentTime(context),
                                 subInfo.getDisplayName()),
                         SEVERITY_LEVEL_RECOMMENDATION,
                         IDENTIFIER_DISCLOSURE_ISSUE_ID)
@@ -347,10 +364,9 @@ public class CellularNetworkSecuritySafetySource {
         return Optional.of(builder.build());
     }
 
-    private String getCurrentTime() {
-        String pattern = DateFormat.getBestDateTimePattern(Locale.getDefault(), "hh:mm");
-        return Instant.now().atZone(ZoneId.systemDefault())
-              .format(DateTimeFormatter.ofPattern(pattern)).toString();
+    private String getCurrentTime(Context context) {
+        Date today = Calendar.getInstance().getTime();
+        return DateFormat.getTimeFormat(context).format(today);
     }
 
     /**
@@ -446,4 +462,21 @@ public class CellularNetworkSecuritySafetySource {
             return Objects.hash(mDisclosureCount, mWindowStart, mWindowEnd);
         }
     }
+
+    /**
+     * Receiver for airplane mode intent broadcasts for cellular network security.
+     */
+    private class CellularNetworkSecurityBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                boolean airplaneMode = intent.getBooleanExtra("state", false);
+                if (airplaneMode) {
+                    mNullCipherStates.clear();
+                    updateSafetyCenter(context);
+                }
+            }
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/security/NullCipherNotifier.java b/src/java/com/android/internal/telephony/security/NullCipherNotifier.java
index e13c5b001c..d8ed7facca 100644
--- a/src/java/com/android/internal/telephony/security/NullCipherNotifier.java
+++ b/src/java/com/android/internal/telephony/security/NullCipherNotifier.java
@@ -251,7 +251,6 @@ public class NullCipherNotifier {
             case SecurityAlgorithmUpdate.SECURITY_ALGORITHM_IMS_NULL:
             case SecurityAlgorithmUpdate.SECURITY_ALGORITHM_SIP_NULL:
             case SecurityAlgorithmUpdate.SECURITY_ALGORITHM_SRTP_NULL:
-            case SecurityAlgorithmUpdate.SECURITY_ALGORITHM_OTHER:
                 return true;
             default:
                 return false;
diff --git a/src/java/com/android/internal/telephony/subscription/SubscriptionManagerService.java b/src/java/com/android/internal/telephony/subscription/SubscriptionManagerService.java
index bedc20e9d5..b2bfb3c0dc 100644
--- a/src/java/com/android/internal/telephony/subscription/SubscriptionManagerService.java
+++ b/src/java/com/android/internal/telephony/subscription/SubscriptionManagerService.java
@@ -141,6 +141,8 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
@@ -160,6 +162,9 @@ public class SubscriptionManagerService extends ISub.Stub {
     /** Whether enabling verbose debugging message or not. */
     private static final boolean VDBG = false;
 
+    // Compile-time debug flag for controlling worker thread behavior
+    private static final boolean USE_WORKER_THREAD = false;
+
     /**
      * The columns in {@link SimInfo} table that can be directly accessed through
      * {@link #getSubscriptionProperty(int, String, String, String)} or
@@ -235,6 +240,11 @@ public class SubscriptionManagerService extends ISub.Stub {
     @NonNull
     private static final BinderWrapper BINDER_WRAPPER = new BinderWrapper();
 
+    /** Regular expression to determine if a string is in MAC address format. */
+    private static final Pattern MAC_ADDRESS_PATTERN = Pattern.compile(
+            // Matches formats like 00:1B:44:11:3A:B7 or 00-1B-44-11-3A-B7
+            "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$");
+
     /** Instance of subscription manager service. */
     @NonNull
     private static SubscriptionManagerService sInstance;
@@ -568,7 +578,7 @@ public class SubscriptionManagerService extends ISub.Stub {
 
         Looper dbLooper = null;
 
-        if (mFeatureFlags.threadShred()) {
+        if (mFeatureFlags.threadShred() && SubscriptionManagerService.USE_WORKER_THREAD) {
             dbLooper = WorkerThread.get().getLooper();
         } else {
             // Create a separate thread for subscription database manager.
@@ -628,12 +638,10 @@ public class SubscriptionManagerService extends ISub.Stub {
         // Broadcast sub Id on service initialized.
         broadcastSubId(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED,
                 getDefaultDataSubId());
-        if (mFeatureFlags.ddsCallback()) {
-            mSubscriptionManagerServiceCallbacks.forEach(
-                    callback -> callback.invokeFromExecutor(
-                            () -> callback.onDefaultDataSubscriptionChanged(
-                                    getDefaultDataSubId())));
-        }
+        mSubscriptionManagerServiceCallbacks.forEach(
+                callback -> callback.invokeFromExecutor(
+                        () -> callback.onDefaultDataSubscriptionChanged(
+                                getDefaultDataSubId())));
 
         broadcastSubId(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED,
                 getDefaultVoiceSubId());
@@ -869,6 +877,22 @@ public class SubscriptionManagerService extends ISub.Stub {
         return result.build();
     }
 
+    /**
+     * Get the stripped ICCID, which sometimes ended with 'F'. Also not doing this if the ICCID
+     * is MAC address (used by texting through bluetooth).
+     *
+     * @param iccId The original ICCID.
+     * @return The fixed ICCID.
+     */
+    @VisibleForTesting
+    @NonNull
+    public static String getStrippedIccid(@NonNull String iccId) {
+        Matcher matcher = MAC_ADDRESS_PATTERN.matcher(iccId);
+        if (matcher.matches()) return iccId;
+
+        return TextUtils.emptyIfNull(IccUtils.stripTrailingFs(iccId));
+    }
+
     /**
      * @return The list of ICCIDs from the inserted physical SIMs.
      */
@@ -884,7 +908,7 @@ public class SubscriptionManagerService extends ISub.Stub {
                 // Non euicc slots will have single port, so use default port index.
                 String iccId = uiccSlot.getIccId(TelephonyManager.DEFAULT_PORT_INDEX);
                 if (!TextUtils.isEmpty(iccId)) {
-                    iccidList.add(IccUtils.stripTrailingFs(iccId));
+                    iccidList.add(getStrippedIccid(iccId));
                 }
             }
         }
@@ -1393,7 +1417,7 @@ public class SubscriptionManagerService extends ISub.Stub {
         }
 
         SubscriptionInfoInternal subInfo = mSubscriptionDatabaseManager
-                .getSubscriptionInfoInternalByIccId(IccUtils.stripTrailingFs(iccId));
+                .getSubscriptionInfoInternalByIccId(getStrippedIccid(iccId));
         return subInfo != null && subInfo.areUiccApplicationsEnabled();
     }
 
@@ -1407,8 +1431,7 @@ public class SubscriptionManagerService extends ISub.Stub {
     @NonNull
     private String getIccId(int phoneId) {
         UiccPort port = mUiccController.getUiccPort(phoneId);
-        return (port == null) ? "" : TextUtils.emptyIfNull(
-                IccUtils.stripTrailingFs(port.getIccId()));
+        return (port == null) ? "" : getStrippedIccid(port.getIccId());
     }
 
     /**
@@ -2010,11 +2033,15 @@ public class SubscriptionManagerService extends ISub.Stub {
         enforcePermissions("getActiveSubscriptionInfoForIccId",
                 Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
 
-        enforceTelephonyFeatureWithException(callingPackage, "getActiveSubscriptionInfoForIccId");
+        if (!mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_force_phone_globals_creation)) {
+            enforceTelephonyFeatureWithException(callingPackage,
+                    "getActiveSubscriptionInfoForIccId");
+        }
 
         final long identity = Binder.clearCallingIdentity();
         try {
-            iccId = IccUtils.stripTrailingFs(iccId);
+            iccId = getStrippedIccid(iccId);
             SubscriptionInfoInternal subInfo = mSubscriptionDatabaseManager
                     .getSubscriptionInfoInternalByIccId(iccId);
 
@@ -2322,7 +2349,10 @@ public class SubscriptionManagerService extends ISub.Stub {
                 + SubscriptionManager.subscriptionTypeToString(subscriptionType) + ", "
                 + getCallingPackage());
 
-        enforceTelephonyFeatureWithException(getCurrentPackageName(), "addSubInfo");
+        if (!mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_force_phone_globals_creation)) {
+            enforceTelephonyFeatureWithException(getCurrentPackageName(), "addSubInfo");
+        }
 
         if (subscriptionType == SubscriptionManager.SUBSCRIPTION_TYPE_LOCAL_SIM) {
             if (!SubscriptionManager.isValidSlotIndex(slotIndex)) {
@@ -2345,7 +2375,7 @@ public class SubscriptionManagerService extends ISub.Stub {
                 return -1;
             }
 
-            iccId = IccUtils.stripTrailingFs(iccId);
+            iccId = getStrippedIccid(iccId);
             SubscriptionInfoInternal subInfo = mSubscriptionDatabaseManager
                     .getSubscriptionInfoInternalByIccId(iccId);
 
@@ -2393,7 +2423,10 @@ public class SubscriptionManagerService extends ISub.Stub {
                 + SubscriptionManager.subscriptionTypeToString(subscriptionType) + ", "
                 + getCallingPackage());
 
-        enforceTelephonyFeatureWithException(getCurrentPackageName(), "removeSubInfo");
+        if (!mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_force_phone_globals_creation)) {
+            enforceTelephonyFeatureWithException(getCurrentPackageName(), "removeSubInfo");
+        }
 
         final long identity = Binder.clearCallingIdentity();
         try {
@@ -3102,6 +3135,11 @@ public class SubscriptionManagerService extends ISub.Stub {
                     + subId + ", phoneId=" + phoneId);
             mDefaultSubId.set(subId);
 
+            if (mFeatureFlags.updateResourceConfiguration()) {
+                String mccMnc = mTelephonyManager.getSimOperatorNumeric(subId);
+                MccTable.updateMccMncConfiguration(mContext, mccMnc);
+            }
+
             Intent intent = new Intent(SubscriptionManager.ACTION_DEFAULT_SUBSCRIPTION_CHANGED);
             intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
             SubscriptionManager.putPhoneIdAndSubIdExtra(intent, phoneId, subId);
@@ -3125,7 +3163,7 @@ public class SubscriptionManagerService extends ISub.Stub {
     @Override
     public int getDefaultSubIdAsUser(@UserIdInt int userId) {
         enforceTelephonyFeatureWithException(getCurrentPackageName(),
-                "getDefaultVoiceSubIdAsUser");
+                "getDefaultSubIdAsUser");
 
         return getDefaultAsUser(userId, mDefaultSubId.get());
     }
@@ -3214,11 +3252,9 @@ public class SubscriptionManagerService extends ISub.Stub {
 
                 broadcastSubId(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED,
                         subId);
-                if (mFeatureFlags.ddsCallback()) {
-                    mSubscriptionManagerServiceCallbacks.forEach(
-                            callback -> callback.invokeFromExecutor(
-                                    () -> callback.onDefaultDataSubscriptionChanged(subId)));
-                }
+                mSubscriptionManagerServiceCallbacks.forEach(
+                        callback -> callback.invokeFromExecutor(
+                                () -> callback.onDefaultDataSubscriptionChanged(subId)));
 
                 updateDefaultSubId();
             }
@@ -3613,7 +3649,10 @@ public class SubscriptionManagerService extends ISub.Stub {
                     + "carrier privilege");
         }
 
-        enforceTelephonyFeatureWithException(callingPackage, "isActiveSubId");
+        if (!mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_force_phone_globals_creation)) {
+            enforceTelephonyFeatureWithException(callingPackage, "isActiveSubId");
+        }
 
         final long identity = Binder.clearCallingIdentity();
         try {
@@ -4447,7 +4486,7 @@ public class SubscriptionManagerService extends ISub.Stub {
                 // When port is inactive, sometimes valid iccid is present in the slot status,
                 // hence update the portIndex. (Pre-U behavior)
                 SubscriptionInfoInternal subInfo = mSubscriptionDatabaseManager
-                        .getSubscriptionInfoInternalByIccId(IccUtils.stripTrailingFs(iccId));
+                        .getSubscriptionInfoInternalByIccId(getStrippedIccid(iccId));
                 int subId;
                 if (subInfo != null) {
                     subId = subInfo.getSubscriptionId();
@@ -4456,7 +4495,7 @@ public class SubscriptionManagerService extends ISub.Stub {
                 } else {
                     // If iccId is new, add a subscription record in the database so it can be
                     // activated later. (Pre-U behavior)
-                    subId = insertSubscriptionInfo(IccUtils.stripTrailingFs(iccId),
+                    subId = insertSubscriptionInfo(getStrippedIccid(iccId),
                             SubscriptionManager.INVALID_SIM_SLOT_INDEX, "",
                             SubscriptionManager.SUBSCRIPTION_TYPE_LOCAL_SIM);
                     mSubscriptionDatabaseManager.setDisplayName(subId,
@@ -4526,12 +4565,8 @@ public class SubscriptionManagerService extends ISub.Stub {
             // Too many packages running with phone uid. Just return one here.
             return "com.android.phone";
         }
-        if (mFeatureFlags.hsumPackageManager()) {
-            return Arrays.toString(mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
-                    .getPackageManager().getPackagesForUid(Binder.getCallingUid()));
-        }
-        return Arrays.toString(mContext.getPackageManager().getPackagesForUid(
-                Binder.getCallingUid()));
+        return Arrays.toString(mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
+                .getPackageManager().getPackagesForUid(Binder.getCallingUid()));
     }
 
     /**
@@ -4846,15 +4881,10 @@ public class SubscriptionManagerService extends ISub.Stub {
      */
     @Nullable
     private String getCurrentPackageName() {
-        if (mFeatureFlags.hsumPackageManager()) {
-            PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
-                    .getPackageManager();
-            if (pm == null) return null;
-            String[] callingPackageNames = pm.getPackagesForUid(Binder.getCallingUid());
-            return (callingPackageNames == null) ? null : callingPackageNames[0];
-        }
-        if (mPackageManager == null) return null;
-        String[] callingPackageNames = mPackageManager.getPackagesForUid(Binder.getCallingUid());
+        PackageManager pm = mContext.createContextAsUser(Binder.getCallingUserHandle(), 0)
+                .getPackageManager();
+        if (pm == null) return null;
+        String[] callingPackageNames = pm.getPackagesForUid(Binder.getCallingUid());
         return (callingPackageNames == null) ? null : callingPackageNames[0];
     }
 
@@ -4970,7 +5000,7 @@ public class SubscriptionManagerService extends ISub.Stub {
     }
 
     private boolean canManageSubscription(SubscriptionInfo subInfo, String packageName) {
-        if (Flags.hsumPackageManager() && UserManager.isHeadlessSystemUserMode()) {
+        if (UserManager.isHeadlessSystemUserMode()) {
             return mSubscriptionManager.canManageSubscriptionAsUser(subInfo, packageName,
                     UserHandle.of(ActivityManager.getCurrentUser()));
         } else {
diff --git a/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java b/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
index b705cbcf5e..27410715a3 100644
--- a/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
@@ -16,10 +16,9 @@
 
 package com.android.internal.telephony.uicc;
 
-import android.annotation.NonNull;
-
 import static com.android.internal.telephony.util.TelephonyUtils.FORCE_VERBOSE_STATE_LOGGING;
 
+import android.annotation.NonNull;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.content.Intent;
@@ -396,11 +395,7 @@ public class IsimUiccRecords extends IccRecords implements IsimRecords {
         Intent intent = new Intent(INTENT_ISIM_REFRESH);
         log("send ISim REFRESH: " + INTENT_ISIM_REFRESH);
         SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mParentApp.getPhoneId());
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } else {
-            mContext.sendBroadcast(intent);
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/uicc/PinStorage.java b/src/java/com/android/internal/telephony/uicc/PinStorage.java
index e26050ea04..faa569137d 100644
--- a/src/java/com/android/internal/telephony/uicc/PinStorage.java
+++ b/src/java/com/android/internal/telephony/uicc/PinStorage.java
@@ -38,6 +38,7 @@ import static com.android.internal.telephony.uicc.IccCardStatus.PinState.PINSTAT
 import static com.android.internal.telephony.uicc.IccCardStatus.PinState.PINSTATE_ENABLED_VERIFIED;
 import static com.android.internal.telephony.util.TelephonyUtils.FORCE_VERBOSE_STATE_LOGGING;
 
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.KeyguardManager;
 import android.content.BroadcastReceiver;
@@ -47,6 +48,7 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.os.AsyncResult;
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
 import android.os.PersistableBundle;
 import android.os.WorkSource;
@@ -66,10 +68,12 @@ import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.TelephonyStatsLog;
+import com.android.internal.telephony.flags.FeatureFlags;
 import com.android.internal.telephony.nano.StoredPinProto.EncryptedPin;
 import com.android.internal.telephony.nano.StoredPinProto.StoredPin;
 import com.android.internal.telephony.nano.StoredPinProto.StoredPin.PinStatus;
 import com.android.internal.telephony.uicc.IccCardStatus.PinState;
+import com.android.internal.telephony.util.WorkerThread;
 import com.android.internal.util.ArrayUtils;
 import com.android.telephony.Rlog;
 
@@ -79,6 +83,7 @@ import java.security.KeyStore;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
+import java.util.concurrent.Executors;
 
 import javax.crypto.Cipher;
 import javax.crypto.KeyGenerator;
@@ -145,6 +150,7 @@ public class PinStorage extends Handler {
     private final int mBootCount;
     private final KeyStore mKeyStore;
 
+    @Nullable
     private SecretKey mLongTermSecretKey;
     private SecretKey mShortTermSecretKey;
 
@@ -178,7 +184,8 @@ public class PinStorage extends Handler {
         }
     };
 
-    public PinStorage(Context context) {
+    public PinStorage(Context context, @NonNull Looper looper, @NonNull FeatureFlags featureFlags) {
+        super(looper);
         mContext = context;
         mBootCount = getBootCount();
         mKeyStore = initializeKeyStore();
@@ -208,9 +215,17 @@ public class PinStorage extends Handler {
         // The short term key is retrieved later when needed.
         String alias = (!mIsDeviceSecure || mIsDeviceLocked)
                 ? KEYSTORE_ALIAS_LONG_TERM_ALWAYS : KEYSTORE_ALIAS_LONG_TERM_USER_AUTH;
-        mLongTermSecretKey = initializeSecretKey(alias, /*createIfAbsent=*/ true);
+        // This is the main thread, so accessing keystore in a separate thread to prevent ANR.
+        if (featureFlags.threadShred()) {
+            WorkerThread.getExecutor().execute(() -> mLongTermSecretKey = initializeSecretKey(
+                    alias, /*createIfAbsent=*/ true));
+        } else {
+            Executors.newSingleThreadExecutor()
+                    .execute(() -> mLongTermSecretKey = initializeSecretKey(
+                            alias, /*createIfAbsent=*/ true));
+        }
 
-        // If the device is not securee or is unlocked, we can start logic. Otherwise we need to
+        // If the device is not secured or is unlocked, we can start logic. Otherwise we need to
         // wait for the device to be unlocked and store any temporary PIN in RAM.
         if (!mIsDeviceSecure || !mIsDeviceLocked) {
             mRamStorage = null;
@@ -664,12 +679,12 @@ public class PinStorage extends Handler {
         if (mIsDeviceLocked) {
             // If the device is still locked, retrieve data from RAM storage.
             if (mRamStorage != null && mRamStorage.get(slotId) != null) {
-                result =  decryptStoredPin(mRamStorage.get(slotId), mLongTermSecretKey);
+                result = decryptStoredPin(mRamStorage.get(slotId), mLongTermSecretKey);
             }
         } else {
             // Load both the stored PIN in available state (with long-term key) and in other states
             // (with short-term key). At most one of them should be present at any given time and
-            // we treat the case wheere both are present as an error.
+            // we treat the case where both are present as an error.
             StoredPin availableStoredPin = loadPinInformationFromDisk(
                     slotId, SHARED_PREFS_AVAILABLE_PIN_BASE_KEY, mLongTermSecretKey);
             StoredPin rebootStoredPin = loadPinInformationFromDisk(
@@ -807,7 +822,7 @@ public class PinStorage extends Handler {
      * @return true if the operation was successful, false otherwise
      */
     private boolean savePinInformation(SharedPreferences.Editor editor, int slotId,
-            StoredPin storedPin, String baseKey, SecretKey secretKey) {
+            StoredPin storedPin, String baseKey, @Nullable SecretKey secretKey) {
         if (secretKey == null) {
             // Secret key for encryption is missing
             return false;
@@ -1150,7 +1165,7 @@ public class PinStorage extends Handler {
     }
 
     /** Returns the encrypted version of {@code input}, or an empty array in case of error. */
-    private byte[] encrypt(SecretKey secretKey, byte[] input) {
+    private byte[] encrypt(@Nullable SecretKey secretKey, byte[] input) {
         if (secretKey == null) {
             loge("Encrypt: Secret key is null");
             return new byte[0];
diff --git a/src/java/com/android/internal/telephony/uicc/SimPhonebookRecordCache.java b/src/java/com/android/internal/telephony/uicc/SimPhonebookRecordCache.java
index b1fc47367b..2f568446d0 100644
--- a/src/java/com/android/internal/telephony/uicc/SimPhonebookRecordCache.java
+++ b/src/java/com/android/internal/telephony/uicc/SimPhonebookRecordCache.java
@@ -23,22 +23,19 @@ import android.os.Handler;
 import android.os.Message;
 import android.telephony.Rlog;
 import android.telephony.TelephonyManager;
-import android.text.TextUtils;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.RadioInterfaceCapabilityController;
-import com.android.internal.telephony.uicc.AdnCapacity;
-import com.android.internal.telephony.uicc.IccConstants;
+import com.android.internal.telephony.flags.Flags;
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.concurrent.ConcurrentSkipListMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentSkipListMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Collectors;
 
 
@@ -443,6 +440,9 @@ public class SimPhonebookRecordCache extends Handler {
                 mIsCacheInvalidated.set(true);
                 fillCacheWithoutWaiting();
             } else if (newCapacity.isSimValid()) {
+                if(Flags.simPhonebookCacheFix()) {
+                    mIsCacheInvalidated.set(false);
+                }
                 notifyAdnLoadingWaiters();
                 tryFireUpdatePendingList();
             } else {
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index c242a1b29d..98f4829274 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -27,7 +27,6 @@ import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.BroadcastOptions;
-import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
@@ -35,8 +34,10 @@ import android.content.pm.PackageManager;
 import android.os.AsyncResult;
 import android.os.Build;
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
 import android.os.RegistrantList;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.preference.PreferenceManager;
 import android.sysprop.TelephonyProperties;
@@ -74,6 +75,7 @@ import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import com.android.internal.telephony.uicc.euicc.EuiccCard;
 import com.android.internal.telephony.util.ArrayUtils;
 import com.android.internal.telephony.util.TelephonyUtils;
+import com.android.internal.telephony.util.WorkerThread;
 import com.android.telephony.Rlog;
 
 import java.io.FileDescriptor;
@@ -162,7 +164,6 @@ public class UiccController extends Handler {
     private final TelephonyManager mTelephonyManager;
 
     // this needs to be here, because on bootup we dont know which index maps to which UiccSlot
-    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     private CommandsInterface[] mCis;
     private UiccSlot[] mUiccSlots;
     private int[] mPhoneIdToSlotId;
@@ -226,14 +227,12 @@ public class UiccController extends Handler {
     // SharedPreferences key for saving the default euicc card ID
     private static final String DEFAULT_CARD = "default_card";
 
-    @UnsupportedAppUsage
     private static final Object mLock = new Object();
-    @UnsupportedAppUsage
+
     private static UiccController mInstance;
     @VisibleForTesting
     public static ArrayList<IccSlotStatus> sLastSlotStatus;
 
-    @UnsupportedAppUsage
     @VisibleForTesting
     public Context mContext;
 
@@ -276,7 +275,23 @@ public class UiccController extends Handler {
                 com.android.internal.R.integer.config_num_physical_slots);
         numPhysicalSlots = TelephonyProperties.sim_slots_count().orElse(numPhysicalSlots);
         if (DBG) {
-            logWithLocalLog("config_num_physical_slots = " + numPhysicalSlots);
+            logl("config_num_physical_slots = " + numPhysicalSlots);
+        }
+
+        int mVendorApiLevel = SystemProperties.getInt(
+                "ro.vendor.api_level", Build.VERSION.DEVICE_INITIAL_SDK_INT);
+        logl("current vendor api_level: " + mVendorApiLevel);
+        // Adjust numPhysicalSlots only for devices that were originally launched with a version
+        // of Android older than or equals to VENDOR_API_2024_Q2. This is to avoid impacting vendor
+        // freeze targets.
+        if (mVendorApiLevel <= Build.VENDOR_API_2024_Q2) {
+            logl("Adjusting numPhysicalSlots for firstApiLevel = " + mVendorApiLevel
+                    + " based on mCis.length");
+            // Minimum number of physical slot count should be equals to or greater than
+            // phone count,if it is less than phone count use phone count as physical slot count.
+            if (numPhysicalSlots < mCis.length) {
+                numPhysicalSlots = mCis.length;
+            }
         }
 
         mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
@@ -310,7 +325,12 @@ public class UiccController extends Handler {
         PhoneConfigurationManager.registerForMultiSimConfigChange(
                 this, EVENT_MULTI_SIM_CONFIG_CHANGED, null);
 
-        mPinStorage = new PinStorage(mContext);
+        if (mFeatureFlags.threadShred()) {
+            mPinStorage = new PinStorage(mContext, WorkerThread.getHandler().getLooper(),
+                    mFeatureFlags);
+        } else {
+            mPinStorage = new PinStorage(mContext, Looper.myLooper(), mFeatureFlags);
+        }
         if (!TelephonyUtils.IS_USER) {
             mUseRemovableEsimAsDefault = PreferenceManager.getDefaultSharedPreferences(mContext)
                     .getBoolean(REMOVABLE_ESIM_AS_DEFAULT, false);
@@ -341,7 +361,6 @@ public class UiccController extends Handler {
         }
     }
 
-    @UnsupportedAppUsage
     public static UiccController getInstance() {
         if (mInstance == null) {
             throw new RuntimeException(
@@ -350,7 +369,6 @@ public class UiccController extends Handler {
         return mInstance;
     }
 
-    @UnsupportedAppUsage
     public UiccCard getUiccCard(int phoneId) {
         synchronized (mLock) {
             return getUiccCardForPhone(phoneId);
@@ -469,7 +487,7 @@ public class UiccController extends Handler {
     /** Map logicalSlot to physicalSlot, portIndex and activate the physicalSlot with portIndex if
      *  it is inactive. */
     public void switchSlots(List<UiccSlotMapping> slotMapping, Message response) {
-        logWithLocalLog("switchSlots: " + slotMapping);
+        logl("switchSlots: " + slotMapping);
         mRadioConfig.setSimSlotsMapping(slotMapping, response);
     }
 
@@ -555,7 +573,6 @@ public class UiccController extends Handler {
     }
 
     // Easy to use API
-    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     public IccRecords getIccRecords(int phoneId, int family) {
         synchronized (mLock) {
             UiccCardApplication app = getUiccCardApplication(phoneId, family);
@@ -567,7 +584,6 @@ public class UiccController extends Handler {
     }
 
     // Easy to use API
-    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     public IccFileHandler getIccFileHandler(int phoneId, int family) {
         synchronized (mLock) {
             UiccCardApplication app = getUiccCardApplication(phoneId, family);
@@ -580,7 +596,6 @@ public class UiccController extends Handler {
 
 
     //Notifies when card status changes
-    @UnsupportedAppUsage
     public void registerForIccChanged(Handler h, int what, Object obj) {
         synchronized (mLock) {
             mIccChangedRegistrants.addUnique(h, what, obj);
@@ -603,12 +618,12 @@ public class UiccController extends Handler {
             String eventName = eventToString(msg.what);
 
             if (phoneId < 0 || phoneId >= mCis.length) {
-                Rlog.e(LOG_TAG, "Invalid phoneId : " + phoneId + " received with event "
+                logel("Invalid phoneId : " + phoneId + " received with event "
                         + eventName);
                 return;
             }
 
-            logWithLocalLog("handleMessage: Received " + eventName + " for phoneId " + phoneId);
+            logl("handleMessage: Received " + eventName + " for phoneId " + phoneId);
 
             AsyncResult ar = (AsyncResult)msg.obj;
             switch (msg.what) {
@@ -669,7 +684,7 @@ public class UiccController extends Handler {
                     onMultiSimConfigChanged(activeModemCount);
                     break;
                 default:
-                    Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
+                    logel(" Unknown Event " + msg.what);
                     break;
             }
         }
@@ -679,7 +694,7 @@ public class UiccController extends Handler {
         int prevActiveModemCount = mCis.length;
         mCis = PhoneFactory.getCommandsInterfaces();
 
-        logWithLocalLog("onMultiSimConfigChanged: prevActiveModemCount " + prevActiveModemCount
+        logl("onMultiSimConfigChanged: prevActiveModemCount " + prevActiveModemCount
                 + ", newActiveModemCount " + newActiveModemCount);
 
         // Resize array.
@@ -736,7 +751,6 @@ public class UiccController extends Handler {
     }
 
     // Easy to use API
-    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     public UiccCardApplication getUiccCardApplication(int phoneId, int family) {
         synchronized (mLock) {
             UiccPort uiccPort = getUiccPortForPhone(phoneId);
@@ -808,7 +822,7 @@ public class UiccController extends Handler {
         intent.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
         int subId = SubscriptionManager.getSubscriptionId(phoneId);
         SubscriptionManager.putPhoneIdAndMaybeSubIdExtra(intent, phoneId, subId);
-        Rlog.d(LOG_TAG, "Broadcasting intent ACTION_SIM_STATE_CHANGED " + state + " reason "
+        log("Broadcasting intent ACTION_SIM_STATE_CHANGED " + state + " reason "
                 + reason + " for phone: " + phoneId + " sub: " + subId);
         IntentBroadcaster.getInstance().broadcastStickyIntent(mContext, intent, phoneId);
     }
@@ -837,15 +851,11 @@ public class UiccController extends Handler {
                 portIndex = slot.getPortIndexFromPhoneId(phoneId);
                 intent.putExtra(PhoneConstants.PORT_KEY, portIndex);
             }
-            Rlog.d(LOG_TAG, "Broadcasting intent ACTION_SIM_CARD_STATE_CHANGED "
+            log("Broadcasting intent ACTION_SIM_CARD_STATE_CHANGED "
                     + TelephonyManager.simStateToString(state) + " for phone: " + phoneId
                     + " slot: " + slotId + " port: " + portIndex + " sub: " + subId);
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                        Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            } else {
-                mContext.sendBroadcast(intent, Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                    Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
             TelephonyMetrics.getInstance().updateSimState(phoneId, state);
         }
     }
@@ -881,16 +891,12 @@ public class UiccController extends Handler {
             if (slot != null) {
                 intent.putExtra(PhoneConstants.PORT_KEY, slot.getPortIndexFromPhoneId(phoneId));
             }
-            Rlog.d(LOG_TAG, "Broadcasting intent ACTION_SIM_APPLICATION_STATE_CHANGED "
+            log("Broadcasting intent ACTION_SIM_APPLICATION_STATE_CHANGED "
                     + TelephonyManager.simStateToString(state)
                     + " for phone: " + phoneId + " slot: " + slotId + " port: "
                     + slot.getPortIndexFromPhoneId(phoneId) + " sub: " + subId);
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                        Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            } else {
-                mContext.sendBroadcast(intent, Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                    Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
             TelephonyMetrics.getInstance().updateSimState(phoneId, state);
         }
     }
@@ -914,7 +920,6 @@ public class UiccController extends Handler {
             case IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED:
                 return TelephonyManager.SIM_STATE_PERM_DISABLED;
             default:
-                Rlog.e(LOG_TAG, "Unexpected SIM locked reason " + lockedReason);
                 return TelephonyManager.SIM_STATE_UNKNOWN;
         }
     }
@@ -995,10 +1000,10 @@ public class UiccController extends Handler {
     public void updateSimState(int phoneId, @NonNull IccCardConstants.State state,
             @Nullable String reason) {
         post(() -> {
-            log("updateSimState: phoneId=" + phoneId + ", state=" + state + ", reason="
+            logl("updateSimState: phoneId=" + phoneId + ", state=" + state + ", reason="
                     + reason);
             if (!SubscriptionManager.isValidPhoneId(phoneId)) {
-                Rlog.e(LOG_TAG, "updateSimState: Invalid phone id " + phoneId);
+                logel("updateSimState: Invalid phone id " + phoneId);
                 return;
             }
 
@@ -1037,7 +1042,7 @@ public class UiccController extends Handler {
                         }
 
                         if (!SubscriptionManager.isValidPhoneId(phoneId)) {
-                            Rlog.e(LOG_TAG, "updateSimState: Cannot update carrier services. "
+                            logel("updateSimState: Cannot update carrier services. "
                                     + "Invalid phone id " + phoneId);
                             return;
                         }
@@ -1045,7 +1050,7 @@ public class UiccController extends Handler {
                         // At this point, the SIM state must be a final state (meaning we won't
                         // get more SIM state updates). So resolve the carrier id and update the
                         // carrier services.
-                        log("updateSimState: resolve carrier id and update carrier "
+                        logl("updateSimState: resolve carrier id and update carrier "
                                 + "services.");
                         PhoneFactory.getPhone(phoneId).resolveSubscriptionCarrierId(
                                 legacySimState);
@@ -1057,26 +1062,26 @@ public class UiccController extends Handler {
 
     private synchronized void onGetIccCardStatusDone(AsyncResult ar, Integer index) {
         if (ar.exception != null) {
-            Rlog.e(LOG_TAG,"Error getting ICC status. "
+            logel("Error getting ICC status. "
                     + "RIL_REQUEST_GET_ICC_STATUS should "
-                    + "never return an error", ar.exception);
+                    + "never return an error " + ar.exception);
             return;
         }
         if (!isValidPhoneIndex(index)) {
-            Rlog.e(LOG_TAG,"onGetIccCardStatusDone: invalid index : " + index);
+            logel("onGetIccCardStatusDone: invalid index : " + index);
             return;
         }
         if (isShuttingDown()) {
             // Do not process the SIM/SLOT events during device shutdown,
             // as it may unnecessarily modify the persistent information
             // like, SubscriptionManager.UICC_APPLICATIONS_ENABLED.
-            log("onGetIccCardStatusDone: shudown in progress ignore event");
+            log("onGetIccCardStatusDone: shutdown in progress ignore event");
             return;
         }
 
         IccCardStatus status = (IccCardStatus)ar.result;
 
-        logWithLocalLog("onGetIccCardStatusDone: phoneId-" + index + " IccCardStatus: " + status);
+        logl("onGetIccCardStatusDone: phoneId-" + index + " IccCardStatus: " + status);
 
         int slotId = status.mSlotPortMapping.mPhysicalSlotIndex;
         if (VDBG) log("onGetIccCardStatusDone: phoneId-" + index + " physicalSlotIndex " + slotId);
@@ -1139,7 +1144,7 @@ public class UiccController extends Handler {
                 if (mDefaultEuiccCardId == UNINITIALIZED_CARD_ID
                         || mDefaultEuiccCardId == TEMPORARILY_UNSUPPORTED_CARD_ID) {
                     mDefaultEuiccCardId = convertToPublicCardId(cardString);
-                    logWithLocalLog("IccCardStatus eid="
+                    logl("IccCardStatus eid="
                             + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, cardString) + " slot=" + slotId
                             + " mDefaultEuiccCardId=" + mDefaultEuiccCardId);
                 }
@@ -1280,13 +1285,11 @@ public class UiccController extends Handler {
             for (UiccSlot slot : mUiccSlots) {
                 if (slot != null && slot.isRemovable() && slot.isEuicc() && slot.isActive()) {
                     int cardId = convertToPublicCardId(slot.getEid());
-                    Rlog.d(LOG_TAG,
-                            "getCardIdForDefaultEuicc: Removable eSIM is default, cardId: "
-                                    + cardId);
+                    log("getCardIdForDefaultEuicc: Removable eSIM is default, cardId: " + cardId);
                     return cardId;
                 }
             }
-            Rlog.d(LOG_TAG, "getCardIdForDefaultEuicc: No removable eSIM slot is found");
+            log("getCardIdForDefaultEuicc: No removable eSIM slot is found");
         }
         return mDefaultEuiccCardId;
     }
@@ -1324,10 +1327,10 @@ public class UiccController extends Handler {
                     != CommandException.Error.REQUEST_NOT_SUPPORTED) {
                 // this is not expected; there should be no exception other than
                 // REQUEST_NOT_SUPPORTED
-                logeWithLocalLog("Unexpected error getting slot status: " + ar.exception);
+                logel("Unexpected error getting slot status: " + ar.exception);
             } else {
                 // REQUEST_NOT_SUPPORTED
-                logWithLocalLog("onGetSlotStatusDone: request not supported; marking "
+                logl("onGetSlotStatusDone: request not supported; marking "
                         + "mIsSlotStatusSupported to false");
                 mIsSlotStatusSupported = false;
             }
@@ -1347,7 +1350,7 @@ public class UiccController extends Handler {
             log("onGetSlotStatusDone: No change in slot status");
             return;
         }
-        logWithLocalLog("onGetSlotStatusDone: " + status);
+        logl("onGetSlotStatusDone: " + status);
 
         sLastSlotStatus = status;
 
@@ -1358,7 +1361,7 @@ public class UiccController extends Handler {
 
         int numSlots = status.size();
         if (mUiccSlots.length < numSlots) {
-            logeWithLocalLog("The number of the physical slots reported " + numSlots
+            logel("The number of the physical slots reported " + numSlots
                     + " is greater than the expectation " + mUiccSlots.length);
             numSlots = mUiccSlots.length;
         }
@@ -1379,7 +1382,7 @@ public class UiccController extends Handler {
                         int logicalSlotIndex = iss.mSimPortInfos[j].mLogicalSlotIndex;
                         // Correctness check: logicalSlotIndex should be valid for an active slot
                         if (!isValidPhoneIndex(logicalSlotIndex)) {
-                            Rlog.e(LOG_TAG, "Skipping slot " + i + " portIndex " + j + " as phone "
+                            logel("Skipping slot " + i + " portIndex " + j + " as phone "
                                     + logicalSlotIndex
                                     + " is not available to communicate with this slot");
                         } else {
@@ -1413,7 +1416,7 @@ public class UiccController extends Handler {
                 if (!mUiccSlots[i].isRemovable() && !isDefaultEuiccCardIdSet) {
                     isDefaultEuiccCardIdSet = true;
                     mDefaultEuiccCardId = convertToPublicCardId(eid);
-                    logWithLocalLog("Using eid=" + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, eid)
+                    logl("Using eid=" + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, eid)
                             + " in slot=" + i + " to set mDefaultEuiccCardId="
                             + mDefaultEuiccCardId);
                 }
@@ -1432,7 +1435,7 @@ public class UiccController extends Handler {
                     if (!TextUtils.isEmpty(eid)) {
                         isDefaultEuiccCardIdSet = true;
                         mDefaultEuiccCardId = convertToPublicCardId(eid);
-                        logWithLocalLog("Using eid="
+                        logl("Using eid="
                                 + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, eid)
                                 + " from removable eUICC in slot=" + i
                                 + " to set mDefaultEuiccCardId=" + mDefaultEuiccCardId);
@@ -1443,7 +1446,7 @@ public class UiccController extends Handler {
         }
 
         if (mHasBuiltInEuicc && !anyEuiccIsActive && !isDefaultEuiccCardIdSet) {
-            logWithLocalLog(
+            logl(
                     "onGetSlotStatusDone: mDefaultEuiccCardId=TEMPORARILY_UNSUPPORTED_CARD_ID");
             isDefaultEuiccCardIdSet = true;
             mDefaultEuiccCardId = TEMPORARILY_UNSUPPORTED_CARD_ID;
@@ -1466,7 +1469,7 @@ public class UiccController extends Handler {
                     }
                 }
                 if (!defaultEuiccCardIdIsStillInserted) {
-                    logWithLocalLog("onGetSlotStatusDone: mDefaultEuiccCardId="
+                    logl("onGetSlotStatusDone: mDefaultEuiccCardId="
                             + mDefaultEuiccCardId
                             + " is no longer inserted. Setting mDefaultEuiccCardId=UNINITIALIZED");
                     mDefaultEuiccCardId = UNINITIALIZED_CARD_ID;
@@ -1474,7 +1477,7 @@ public class UiccController extends Handler {
             } else {
                 // no known eUICCs at all (it's possible that an eUICC is inserted and we just don't
                 // know it's EID)
-                logWithLocalLog("onGetSlotStatusDone: mDefaultEuiccCardId=UNINITIALIZED");
+                logl("onGetSlotStatusDone: mDefaultEuiccCardId=UNINITIALIZED");
                 mDefaultEuiccCardId = UNINITIALIZED_CARD_ID;
             }
         }
@@ -1483,7 +1486,7 @@ public class UiccController extends Handler {
 
         // Correctness check: number of active ports should be valid
         if (numActivePorts != mPhoneIdToSlotId.length) {
-            Rlog.e(LOG_TAG, "Number of active ports " + numActivePorts
+            logel("Number of active ports " + numActivePorts
                        + " does not match the number of Phones" + mPhoneIdToSlotId.length);
         }
 
@@ -1492,13 +1495,8 @@ public class UiccController extends Handler {
         options.setBackgroundActivityStartsAllowed(true);
         Intent intent = new Intent(TelephonyManager.ACTION_SIM_SLOT_STATUS_CHANGED);
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        if (mFeatureFlags.hsumBroadcast()) {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
-                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, options.toBundle());
-        } else {
-            mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE,
-                    options.toBundle());
-        }
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL,
+                android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, options.toBundle());
     }
 
     private boolean hasActivePort(IccSimPortInfo[] simPortInfos) {
@@ -1535,32 +1533,32 @@ public class UiccController extends Handler {
 
     private void onSimRefresh(AsyncResult ar, Integer index) {
         if (ar.exception != null) {
-            Rlog.e(LOG_TAG, "onSimRefresh: Sim REFRESH with exception: " + ar.exception);
+            logel("onSimRefresh: Sim REFRESH with exception: " + ar.exception);
             return;
         }
 
         if (!isValidPhoneIndex(index)) {
-            Rlog.e(LOG_TAG,"onSimRefresh: invalid index : " + index);
+            logel("onSimRefresh: invalid index : " + index);
             return;
         }
 
         IccRefreshResponse resp = (IccRefreshResponse) ar.result;
-        logWithLocalLog("onSimRefresh: index " + index + ", " + resp);
+        logl("onSimRefresh: index " + index + ", " + resp);
 
         if (resp == null) {
-            Rlog.e(LOG_TAG, "onSimRefresh: received without input");
+            logel("onSimRefresh: received without input");
             return;
         }
 
         UiccCard uiccCard = getUiccCardForPhone(index);
         if (uiccCard == null) {
-            Rlog.e(LOG_TAG,"onSimRefresh: refresh on null card : " + index);
+            logel("onSimRefresh: refresh on null card : " + index);
             return;
         }
 
         UiccPort uiccPort = getUiccPortForPhone(index);
         if (uiccPort == null) {
-            Rlog.e(LOG_TAG, "onSimRefresh: refresh on null port : " + index);
+            logel("onSimRefresh: refresh on null port : " + index);
             return;
         }
 
@@ -1596,18 +1594,18 @@ public class UiccController extends Handler {
     // is first loaded
     private void onEidReady(AsyncResult ar, Integer index) {
         if (ar.exception != null) {
-            Rlog.e(LOG_TAG, "onEidReady: exception: " + ar.exception);
+            logel("onEidReady: exception: " + ar.exception);
             return;
         }
 
         if (!isValidPhoneIndex(index)) {
-            Rlog.e(LOG_TAG, "onEidReady: invalid index: " + index);
+            logel("onEidReady: invalid index: " + index);
             return;
         }
         int slotId = mPhoneIdToSlotId[index];
         EuiccCard card = (EuiccCard) mUiccSlots[slotId].getUiccCard();
         if (card == null) {
-            Rlog.e(LOG_TAG, "onEidReady: UiccCard in slot " + slotId + " is null");
+            logel("onEidReady: UiccCard in slot " + slotId + " is null");
             return;
         }
 
@@ -1618,14 +1616,14 @@ public class UiccController extends Handler {
                 || mDefaultEuiccCardId == TEMPORARILY_UNSUPPORTED_CARD_ID) {
             if (!mUiccSlots[slotId].isRemovable()) {
                 mDefaultEuiccCardId = convertToPublicCardId(eid);
-                logWithLocalLog("onEidReady: eid="
+                logl("onEidReady: eid="
                         + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, eid)
                         + " slot=" + slotId + " mDefaultEuiccCardId=" + mDefaultEuiccCardId);
             } else if (!mHasActiveBuiltInEuicc) {
                 // we only set a removable eUICC to the default if there are no active non-removable
                 // eUICCs
                 mDefaultEuiccCardId = convertToPublicCardId(eid);
-                logWithLocalLog("onEidReady: eid="
+                logl("onEidReady: eid="
                         + Rlog.pii(TelephonyUtils.IS_DEBUGGABLE, eid)
                         + " from removable eUICC in slot=" + slotId + " mDefaultEuiccCardId="
                         + mDefaultEuiccCardId);
@@ -1768,7 +1766,7 @@ public class UiccController extends Handler {
                 PreferenceManager.getDefaultSharedPreferences(mContext).edit();
         editor.putBoolean(REMOVABLE_ESIM_AS_DEFAULT, isDefault);
         editor.apply();
-        Rlog.d(LOG_TAG, "setRemovableEsimAsDefaultEuicc isDefault: " + isDefault);
+        log("setRemovableEsimAsDefaultEuicc isDefault: " + isDefault);
     }
 
     /**
@@ -1776,7 +1774,7 @@ public class UiccController extends Handler {
      * This API is added for test purpose to check whether removable eSIM is default eUICC or not.
      */
     public boolean isRemovableEsimDefaultEuicc() {
-        Rlog.d(LOG_TAG, "mUseRemovableEsimAsDefault: " + mUseRemovableEsimAsDefault);
+        log("mUseRemovableEsimAsDefault: " + mUseRemovableEsimAsDefault);
         return mUseRemovableEsimAsDefault;
     }
 
@@ -1793,17 +1791,16 @@ public class UiccController extends Handler {
         }
     }
 
-    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     private void log(String string) {
         Rlog.d(LOG_TAG, string);
     }
 
-    private void logWithLocalLog(String string) {
+    private void logl(String string) {
         Rlog.d(LOG_TAG, string);
         sLocalLog.log("UiccController: " + string);
     }
 
-    private void logeWithLocalLog(String string) {
+    private void logel(String string) {
         Rlog.e(LOG_TAG, string);
         sLocalLog.log("UiccController: " + string);
     }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccProfile.java b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
index 2551cb8dac..4eb2e2518f 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccProfile.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
@@ -70,7 +70,6 @@ import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.TelephonyStatsLog;
 import com.android.internal.telephony.cat.CatService;
 import com.android.internal.telephony.flags.FeatureFlags;
-import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.subscription.SubscriptionInfoInternal;
 import com.android.internal.telephony.subscription.SubscriptionManagerService;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
@@ -1161,9 +1160,8 @@ public class UiccProfile extends IccCard {
 
             // Reload the carrier privilege rules if necessary.
             log("Before privilege rules: " + mCarrierPrivilegeRules + " : " + ics.mCardState);
-            if (mCarrierPrivilegeRules == null && ics.mCardState == CardState.CARDSTATE_PRESENT && (
-                    !Flags.uiccAppCountCheckToCreateChannel()
-                            || mLastReportedNumOfUiccApplications > 0)) {
+            if (mCarrierPrivilegeRules == null && ics.mCardState == CardState.CARDSTATE_PRESENT
+                    && mLastReportedNumOfUiccApplications > 0) {
                 mCarrierPrivilegeRules = new UiccCarrierPrivilegeRules(this,
                         mHandler.obtainMessage(EVENT_CARRIER_PRIVILEGES_LOADED));
             } else if (mCarrierPrivilegeRules != null
diff --git a/src/java/com/android/internal/telephony/uicc/UiccStateChangedLauncher.java b/src/java/com/android/internal/telephony/uicc/UiccStateChangedLauncher.java
index ff48fd1a9b..2ce85f1c53 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccStateChangedLauncher.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccStateChangedLauncher.java
@@ -100,11 +100,7 @@ public class UiccStateChangedLauncher extends Handler {
         Intent intent = new Intent(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
         intent.setPackage(sDeviceProvisioningPackage);
         try {
-            if (mFeatureFlags.hsumBroadcast()) {
-                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-            } else {
-                mContext.sendBroadcast(intent);
-            }
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
         } catch (Exception e) {
             Log.e(TAG, e.toString());
         }
diff --git a/src/java/com/android/internal/telephony/uicc/euicc/apdu/ApduSender.java b/src/java/com/android/internal/telephony/uicc/euicc/apdu/ApduSender.java
index 5a63179761..1f2c88d377 100644
--- a/src/java/com/android/internal/telephony/uicc/euicc/apdu/ApduSender.java
+++ b/src/java/com/android/internal/telephony/uicc/euicc/apdu/ApduSender.java
@@ -61,7 +61,6 @@ public class ApduSender {
     // Status code of APDU response
     private static final int STATUS_NO_ERROR = 0x9000;
     private static final int SW1_NO_ERROR = 0x91;
-    private static final int STATUS_CHANNEL_CLOSED = 0x6881; // b/359336875
 
     private static final int WAIT_TIME_MS = 2000;
     private static final String CHANNEL_ID_PRE = "esim-channel";
@@ -282,15 +281,12 @@ public class ApduSender {
                                 int status = (fullResponse.sw1 << 8) | fullResponse.sw2;
                                 if (status != STATUS_NO_ERROR
                                         && fullResponse.sw1 != SW1_NO_ERROR) {
-                                    if (status == STATUS_CHANNEL_CLOSED) {
-                                        // Channel is closed by EUICC e.g. REFRESH.
-                                        tearDownPreferences();
-                                        mChannelOpened = false;
-                                        // TODO: add retry
-                                    }
+                                    // During a EuiccSession, on errors like b/359336875, close the
+                                    // channel immediately so next sendCommand will open a new
+                                    // channel. This is same as the behavior without EuiccSession.
                                     returnRespnseOrException(
                                             command.channel,
-                                            closeChannelImmediately,
+                                            true /* closeChannelImmediately */,
                                             null /* response */,
                                             new ApduException(status),
                                             resultCallback,
@@ -399,12 +395,15 @@ public class ApduSender {
     }
 
     /**
-     * Closes the opened logical channel.
+     * Closes the given logical channel and return a response or exception via callback.
+     *
+     * <p>The successfulness of closing the channel isn't checked and doesn't affect the behavior
+     * of this method.
      *
      * @param response If {@code exception} is null, this will be returned to {@code resultCallback}
      *     after the channel has been closed.
-     * @param exception If not null, this will be returned to {@code resultCallback} after the
-     *     channel has been closed.
+     * @param exception If not {@code null}, this will be returned to {@code resultCallback} after
+     *     the channel has been closed.
      */
     private void closeAndReturn(
             int channel,
diff --git a/src/java/com/android/internal/telephony/util/NotificationChannelController.java b/src/java/com/android/internal/telephony/util/NotificationChannelController.java
index de1ddd3026..ac6a385fa4 100644
--- a/src/java/com/android/internal/telephony/util/NotificationChannelController.java
+++ b/src/java/com/android/internal/telephony/util/NotificationChannelController.java
@@ -23,7 +23,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.media.AudioAttributes;
-import android.net.Uri;
 import android.provider.Settings;
 import android.telephony.SubscriptionManager;
 
@@ -138,7 +137,6 @@ public class NotificationChannelController {
 
     /**
      * migrate deprecated voicemail notification settings to initial notification channel settings
-     * {@link VoicemailNotificationSettingsUtil#getRingTonePreference(Context)}}
      * {@link VoicemailNotificationSettingsUtil#getVibrationPreference(Context)}
      * notification settings are based on subId, only migrate if sub id matches.
      * otherwise fallback to predefined voicemail channel settings.
@@ -151,10 +149,6 @@ public class NotificationChannelController {
                 NotificationManager.IMPORTANCE_DEFAULT);
         voiceMailChannel.enableVibration(
                 VoicemailNotificationSettingsUtil.getVibrationPreference(context));
-        Uri sound = VoicemailNotificationSettingsUtil.getRingTonePreference(context);
-        voiceMailChannel.setSound(
-                (sound == null) ? Settings.System.DEFAULT_NOTIFICATION_URI : sound,
-                new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_NOTIFICATION).build());
         context.getSystemService(NotificationManager.class)
                 .createNotificationChannel(voiceMailChannel);
     }
diff --git a/src/java/com/android/internal/telephony/util/VoicemailNotificationSettingsUtil.java b/src/java/com/android/internal/telephony/util/VoicemailNotificationSettingsUtil.java
index d8988e3230..3dd3d375c9 100644
--- a/src/java/com/android/internal/telephony/util/VoicemailNotificationSettingsUtil.java
+++ b/src/java/com/android/internal/telephony/util/VoicemailNotificationSettingsUtil.java
@@ -21,10 +21,8 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.net.Uri;
 import android.preference.PreferenceManager;
-import android.provider.Settings;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
-import android.text.TextUtils;
 
 public class VoicemailNotificationSettingsUtil {
     private static final String VOICEMAIL_NOTIFICATION_RINGTONE_SHARED_PREFS_KEY_PREFIX =
@@ -64,27 +62,15 @@ public class VoicemailNotificationSettingsUtil {
     }
 
    public static void setRingtoneUri(Context context, Uri ringtoneUri) {
-        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-        String ringtoneUriStr = ringtoneUri != null ? ringtoneUri.toString() : "";
-
-        SharedPreferences.Editor editor = prefs.edit();
-        editor.putString(getVoicemailRingtoneSharedPrefsKey(), ringtoneUriStr);
-        editor.commit();
+        // Do nothing; we don't use the shared preference any more.
     }
 
     public static Uri getRingtoneUri(Context context) {
         final NotificationChannel channel = NotificationChannelController.getChannel(
                 NotificationChannelController.CHANNEL_ID_VOICE_MAIL, context);
-        return (channel != null) ? channel.getSound() : getRingTonePreference(context);
-    }
-
-    public static Uri getRingTonePreference(Context context) {
-        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-        migrateVoicemailRingtoneSettingsIfNeeded(context, prefs);
-        String uriString = prefs.getString(
-                getVoicemailRingtoneSharedPrefsKey(),
-                Settings.System.DEFAULT_NOTIFICATION_URI.toString());
-        return !TextUtils.isEmpty(uriString) ? Uri.parse(uriString) : null;
+        // Note: NEVER look at the shared preferences; this was migrated to the notification channel
+        // in Android P.
+        return (channel != null) ? channel.getSound() : null;
     }
 
     /**
diff --git a/tests/telephonytests/src/com/android/internal/telephony/CarrierKeyDownloadMgrTest.java b/tests/telephonytests/src/com/android/internal/telephony/CarrierKeyDownloadMgrTest.java
index e60e95b610..47d97a9bbb 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/CarrierKeyDownloadMgrTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/CarrierKeyDownloadMgrTest.java
@@ -192,7 +192,7 @@ public class CarrierKeyDownloadMgrTest extends TelephonyTest {
         String mccMnc = "310270";
         mCarrierKeyDM.parseJsonAndPersistKey(mJsonStr, mccMnc, 1);
         verify(mPhone, times(2)).setCarrierInfoForImsiEncryption(
-                (ArgumentMatchers.refEq(imsiEncryptionInfo)));
+                (ArgumentMatchers.refEq(imsiEncryptionInfo)), anyBoolean());
     }
 
     /**
@@ -214,7 +214,7 @@ public class CarrierKeyDownloadMgrTest extends TelephonyTest {
         String mccMnc = "310270";
         mCarrierKeyDM.parseJsonAndPersistKey(mJsonStr1, mccMnc, 1);
         verify(mPhone, times(2)).setCarrierInfoForImsiEncryption(
-                (ArgumentMatchers.refEq(imsiEncryptionInfo)));
+                (ArgumentMatchers.refEq(imsiEncryptionInfo)), anyBoolean());
     }
 
     public void testParseJsonPublicKey(String mcc, String mnc, int carrierId) {
@@ -229,7 +229,7 @@ public class CarrierKeyDownloadMgrTest extends TelephonyTest {
         String mccMnc = mcc + mnc;
         mCarrierKeyDM.parseJsonAndPersistKey(mJsonStr1, mccMnc, carrierId);
         verify(mPhone, times(2)).setCarrierInfoForImsiEncryption(
-                (ArgumentMatchers.refEq(imsiEncryptionInfo)));
+                (ArgumentMatchers.refEq(imsiEncryptionInfo)), anyBoolean());
     }
 
     @Test
@@ -252,7 +252,7 @@ public class CarrierKeyDownloadMgrTest extends TelephonyTest {
         String mccMnc = "310290";
         String badJsonStr = "{badJsonString}";
         mCarrierKeyDM.parseJsonAndPersistKey(badJsonStr, mccMnc, 1);
-        verify(mPhone, times(0)).setCarrierInfoForImsiEncryption(any());
+        verify(mPhone, times(0)).setCarrierInfoForImsiEncryption(any(), anyBoolean());
     }
 
     /**
@@ -490,7 +490,7 @@ public class CarrierKeyDownloadMgrTest extends TelephonyTest {
         int carrierId = 1;
         mCarrierKeyDM.parseJsonAndPersistKey(mJsonStr3GppSpec, mccMnc, carrierId);
         verify(mPhone).setCarrierInfoForImsiEncryption(
-                (ArgumentMatchers.refEq(imsiEncryptionInfo)));
+                (ArgumentMatchers.refEq(imsiEncryptionInfo)), anyBoolean());
     }
 
     /**
diff --git a/tests/telephonytests/src/com/android/internal/telephony/CarrierServiceBindHelperTest.java b/tests/telephonytests/src/com/android/internal/telephony/CarrierServiceBindHelperTest.java
index ae43b2fbc9..abe31690c6 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/CarrierServiceBindHelperTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/CarrierServiceBindHelperTest.java
@@ -16,6 +16,8 @@
 
 package com.android.internal.telephony;
 
+import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -150,30 +152,22 @@ public class CarrierServiceBindHelperTest extends TelephonyTest {
         verify(mTelephonyManager, never()).unregisterCarrierPrivilegesCallback(eq(phone0Callback));
     }
 
-    @Test
-    public void testCarrierAppConnectionLost_resetsCarrierNetworkChange() {
-        if (!Flags.disableCarrierNetworkChangeOnCarrierAppLost()) {
-            return;
-        }
-        // Static test data
-        String carrierServicePackageName = "android.test.package.carrier";
+    private void setupCarrierServiceMocks(
+            String carrierServicePackageName, String carrierServiceClassName) {
+        String carrierServiceFullName = carrierServicePackageName + "." + carrierServiceClassName;
         ComponentName carrierServiceComponentName =
-                new ComponentName("android.test.package", "carrier");
-        ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
-                ArgumentCaptor.forClass(ServiceConnection.class);
+                new ComponentName(carrierServicePackageName, carrierServiceClassName);
+
         ResolveInfo resolveInfo = new ResolveInfo();
         ServiceInfo serviceInfo = new ServiceInfo();
-        serviceInfo.packageName = carrierServicePackageName;
-        serviceInfo.name = "carrier";
+        serviceInfo.packageName = carrierServiceFullName;
+        serviceInfo.name = carrierServiceClassName;
         serviceInfo.metaData = new Bundle();
         serviceInfo.metaData.putBoolean("android.service.carrier.LONG_LIVED_BINDING", true);
         resolveInfo.serviceInfo = serviceInfo;
-
-        // Set up expectations for construction/initialization.
-        doReturn(carrierServicePackageName)
+        doReturn(carrierServiceFullName)
                 .when(mTelephonyManager)
                 .getCarrierServicePackageNameForLogicalSlot(PHONE_ID_0);
-        doReturn(1).when(mTelephonyManager).getActiveModemCount();
         doReturn(resolveInfo)
                 .when(mPackageManager)
                 .resolveService(any(), eq(PackageManager.GET_META_DATA));
@@ -181,9 +175,24 @@ public class CarrierServiceBindHelperTest extends TelephonyTest {
         mContextFixture.addService(
                 CarrierService.CARRIER_SERVICE_INTERFACE,
                 carrierServiceComponentName,
-                carrierServicePackageName,
+                carrierServiceFullName,
                 carrierServiceInterface,
                 serviceInfo);
+    }
+
+    @Test
+    public void testCarrierAppConnectionLost_resetsCarrierNetworkChange_withSubId() {
+        if (!Flags.disableCarrierNetworkChangeOnCarrierAppLost()) {
+            return;
+        }
+        setupCarrierServiceMocks("android.test.package", "carrier");
+        ComponentName carrierServiceComponentName =
+                new ComponentName("android.test.package", "carrier");
+
+        // Set up expectations for construction/initialization.
+        ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
+                ArgumentCaptor.forClass(ServiceConnection.class);
+        doReturn(1).when(mTelephonyManager).getActiveModemCount();
 
         mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
         processAllMessages();
@@ -202,43 +211,65 @@ public class CarrierServiceBindHelperTest extends TelephonyTest {
 
         // Test CarrierService disconnection
         serviceConnection.onServiceDisconnected(carrierServiceComponentName);
-        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(
+                PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager, never())
+                .notifyCarrierNetworkChange(PHONE_ID_0, INVALID_SUBSCRIPTION_ID, false);
     }
 
     @Test
-    public void testCarrierAppBindingLost_resetsCarrierNetworkChange() {
+    public void testCarrierAppBindingLost_resetsCarrierNetworkChange_withSubId() {
         if (!Flags.disableCarrierNetworkChangeOnCarrierAppLost()) {
             return;
         }
-        // Static test data
-        String carrierServicePackageName = "android.test.package.carrier";
+        setupCarrierServiceMocks("android.test.package", "carrier");
         ComponentName carrierServiceComponentName =
                 new ComponentName("android.test.package", "carrier");
+
+        // Set up expectations for construction/initialization.
         ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
                 ArgumentCaptor.forClass(ServiceConnection.class);
-        ResolveInfo resolveInfo = new ResolveInfo();
-        ServiceInfo serviceInfo = new ServiceInfo();
-        serviceInfo.packageName = carrierServicePackageName;
-        serviceInfo.name = "carrier";
-        serviceInfo.metaData = new Bundle();
-        serviceInfo.metaData.putBoolean("android.service.carrier.LONG_LIVED_BINDING", true);
-        resolveInfo.serviceInfo = serviceInfo;
+        doReturn(1).when(mTelephonyManager).getActiveModemCount();
+
+        mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
+        processAllMessages();
+
+        CarrierPrivilegesCallback phoneCallback =
+                expectRegisterCarrierPrivilegesCallback(PHONE_ID_0);
+        assertNotNull(phoneCallback);
+        phoneCallback.onCarrierServiceChanged(null, 0);
+        processAllMessages();
+
+        // Grab the ServiceConnection for CarrierService
+        verify(mContext)
+                .bindService(any(Intent.class), anyInt(), any(), serviceConnectionCaptor.capture());
+        ServiceConnection serviceConnection = serviceConnectionCaptor.getAllValues().get(0);
+        assertNotNull(serviceConnection);
+
+        // Test CarrierService disconnection
+        serviceConnection.onBindingDied(carrierServiceComponentName);
+        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(
+                PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager, never())
+                .notifyCarrierNetworkChange(PHONE_ID_0, INVALID_SUBSCRIPTION_ID, false);
+    }
+
+    @Test
+    public void testCarrierAppBindingLost_resetsCarrierNetworkChange_withPhoneId() {
+        if (!Flags.disableCarrierNetworkChangeOnCarrierAppLost()) {
+            return;
+        }
+        if (!Flags.cleanupCarrierNetworkChangeByPhoneid()) {
+            return;
+        }
+        setupCarrierServiceMocks("android.test.package", "carrier");
+        ComponentName carrierServiceComponentName =
+                new ComponentName("android.test.package", "carrier");
 
         // Set up expectations for construction/initialization.
-        doReturn(carrierServicePackageName)
-                .when(mTelephonyManager)
-                .getCarrierServicePackageNameForLogicalSlot(PHONE_ID_0);
-        doReturn(1).when(mTelephonyManager).getActiveModemCount();
-        doReturn(resolveInfo)
-                .when(mPackageManager)
-                .resolveService(any(), eq(PackageManager.GET_META_DATA));
-        ICarrierService carrierServiceInterface = Mockito.mock(ICarrierService.class);
-        mContextFixture.addService(
-                CarrierService.CARRIER_SERVICE_INTERFACE,
-                carrierServiceComponentName,
-                carrierServicePackageName,
-                carrierServiceInterface,
-                serviceInfo);
+        ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
+                ArgumentCaptor.forClass(ServiceConnection.class);
+        Mockito.when(mTelephonyManager.getActiveModemCount()).thenReturn(1).thenReturn(0);
 
         mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
         processAllMessages();
@@ -257,7 +288,49 @@ public class CarrierServiceBindHelperTest extends TelephonyTest {
 
         // Test CarrierService disconnection
         serviceConnection.onBindingDied(carrierServiceComponentName);
-        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager, never()).notifyCarrierNetworkChange(
+                PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(
+                PHONE_ID_0, INVALID_SUBSCRIPTION_ID, false);
+    }
+
+    @Test
+    public void testCarrierAppConnectionLost_resetsCarrierNetworkChange_withPhoneId() {
+        if (!Flags.disableCarrierNetworkChangeOnCarrierAppLost()) {
+            return;
+        }
+        if (!Flags.cleanupCarrierNetworkChangeByPhoneid()) {
+            return;
+        }
+        setupCarrierServiceMocks("android.test.package", "carrier");
+        ComponentName carrierServiceComponentName =
+                new ComponentName("android.test.package", "carrier");
+
+        // Set up expectations for construction/initialization.
+        ArgumentCaptor<ServiceConnection> serviceConnectionCaptor =
+                ArgumentCaptor.forClass(ServiceConnection.class);
+        Mockito.when(mTelephonyManager.getActiveModemCount()).thenReturn(1).thenReturn(0);
+
+        mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
+        processAllMessages();
+
+        CarrierPrivilegesCallback phoneCallback =
+                expectRegisterCarrierPrivilegesCallback(PHONE_ID_0);
+        assertNotNull(phoneCallback);
+        phoneCallback.onCarrierServiceChanged(null, 0);
+        processAllMessages();
+
+        // Grab the ServiceConnection for CarrierService
+        verify(mContext)
+                .bindService(any(Intent.class), anyInt(), any(), serviceConnectionCaptor.capture());
+        ServiceConnection serviceConnection = serviceConnectionCaptor.getAllValues().get(0);
+        assertNotNull(serviceConnection);
+
+        // Test CarrierService disconnection
+        serviceConnection.onServiceDisconnected(carrierServiceComponentName);
+        verify(mTelephonyRegistryManager, never()).notifyCarrierNetworkChange(PHONE_ID_0, false);
+        verify(mTelephonyRegistryManager).notifyCarrierNetworkChange(
+                PHONE_ID_0, INVALID_SUBSCRIPTION_ID, false);
     }
     // TODO (b/232461097): Add UT cases to cover more scenarios (user unlock, SIM state change...)
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java b/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
index fe6e1b9ec7..94806c928e 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
@@ -440,6 +440,8 @@ public class ContextFixture implements TestFixture<Context> {
 
         @Override
         public void unregisterReceiver(BroadcastReceiver receiver) {
+            mBroadcastReceiversByAction.entries().removeIf(entry
+                    -> receiver == entry.getValue());
         }
 
         @Override
diff --git a/tests/telephonytests/src/com/android/internal/telephony/DisplayInfoControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/DisplayInfoControllerTest.java
index adcd9a9f6d..caad2b682b 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/DisplayInfoControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/DisplayInfoControllerTest.java
@@ -25,10 +25,10 @@ import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.verify;
 
 import android.os.AsyncResult;
-import android.os.HandlerThread;
 import android.os.PersistableBundle;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.CarrierConfigManager;
+import android.telephony.CarrierConfigManager.CarrierConfigChangeListener;
 import android.telephony.CellIdentity;
 import android.telephony.CellIdentityCdma;
 import android.telephony.CellIdentityLte;
@@ -42,14 +42,11 @@ import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
 import android.text.TextUtils;
 
-import com.android.internal.telephony.flags.FeatureFlags;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
 
 import java.util.Collections;
 import java.util.concurrent.Executor;
@@ -64,66 +61,43 @@ public class DisplayInfoControllerTest extends TelephonyTest {
     private static final String NETWORK = "TestNet";
 
     // Mocked classes
-    private FeatureFlags mFeatureFlags;
-
     private DisplayInfoController mDic;
     private ServiceStateTracker mSst;
-    private ServiceStateTrackerTestHandler mSstHandler;
     private PersistableBundle mBundle;
-    private CarrierConfigManager.CarrierConfigChangeListener mCarrierConfigChangeListener;
-
-    private class ServiceStateTrackerTestHandler extends HandlerThread {
-        private ServiceStateTrackerTestHandler(String name) {
-            super(name);
-        }
-
-        @Override
-        public void onLooperPrepared() {
-            SignalStrengthController ssc = new SignalStrengthController(mPhone);
-            doReturn(ssc).when(mPhone).getSignalStrengthController();
-            doReturn(new ServiceState()).when(mPhone).getServiceState();
-            doReturn(NUMERIC).when(mTelephonyManager).getSimOperatorNumericForPhone(eq(PHONE_ID));
-            doReturn(NETWORK).when(mTelephonyManager).getSimOperatorNameForPhone(eq(PHONE_ID));
-
-            // Capture listener registered for ServiceStateTracker to emulate the carrier config
-            // change notification used later. In this test, it's the second one. The first one
-            // comes from RatRatcheter.
-            ArgumentCaptor<CarrierConfigManager.CarrierConfigChangeListener>
-                    listenerArgumentCaptor = ArgumentCaptor.forClass(
-                    CarrierConfigManager.CarrierConfigChangeListener.class);
-            mSst = new ServiceStateTracker(mPhone, mSimulatedCommands, mFeatureFlags);
-            verify(mCarrierConfigManager, atLeast(2)).registerCarrierConfigChangeListener(any(),
-                    listenerArgumentCaptor.capture());
-            mCarrierConfigChangeListener = listenerArgumentCaptor.getAllValues().get(1);
-            doReturn(mSst).when(mPhone).getServiceStateTracker();
-            setReady(true);
-        }
-    }
+    private CarrierConfigChangeListener mCarrierConfigChangeListener;
 
     @Before
     public void setUp() throws Exception {
         logd("DisplayInfoControllerTest setup!");
         super.setUp(getClass().getSimpleName());
 
-        mFeatureFlags = Mockito.mock(FeatureFlags.class);
         doReturn((Executor) Runnable::run).when(mContext).getMainExecutor();
         mBundle = mContextFixture.getCarrierConfigBundle();
         mBundle.putBoolean(CarrierConfigManager.KEY_SHOW_ROAMING_INDICATOR_BOOL, true);
-        mSstHandler = new ServiceStateTrackerTestHandler(getClass().getSimpleName());
-        mSstHandler.start();
-        waitUntilReady();
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+
+        SignalStrengthController ssc = new SignalStrengthController(mPhone);
+        doReturn(ssc).when(mPhone).getSignalStrengthController();
+        doReturn(new ServiceState()).when(mPhone).getServiceState();
+        doReturn(NUMERIC).when(mTelephonyManager).getSimOperatorNumericForPhone(eq(PHONE_ID));
+        doReturn(NETWORK).when(mTelephonyManager).getSimOperatorNameForPhone(eq(PHONE_ID));
+
+        // Capture listener registered for ServiceStateTracker to emulate the carrier config
+        // change notification used later. In this test, it's the second one. The first one
+        // comes from RatRatcheter.
+        ArgumentCaptor<CarrierConfigChangeListener>
+                listenerArgumentCaptor = ArgumentCaptor.forClass(
+                CarrierConfigChangeListener.class);
+        mSst = new ServiceStateTracker(mPhone, mSimulatedCommands, mFeatureFlags);
+        verify(mCarrierConfigManager, atLeast(2)).registerCarrierConfigChangeListener(any(),
+                listenerArgumentCaptor.capture());
+        mCarrierConfigChangeListener = listenerArgumentCaptor.getAllValues().get(1);
+        doReturn(mSst).when(mPhone).getServiceStateTracker();
+
+        processAllMessages();
     }
 
     @After
     public void tearDown() throws Exception {
-        mSst.removeCallbacksAndMessages(null);
-        mSst = null;
-        mSstHandler.quit();
-        mSstHandler.join();
-        mSstHandler = null;
-        mBundle = null;
-        mCarrierConfigChangeListener = null;
         super.tearDown();
     }
 
@@ -131,7 +105,7 @@ public class DisplayInfoControllerTest extends TelephonyTest {
         mCarrierConfigChangeListener.onCarrierConfigChanged(PHONE_ID,
                 SubscriptionManager.INVALID_SUBSCRIPTION_ID, TelephonyManager.UNKNOWN_CARRIER_ID,
                 TelephonyManager.UNKNOWN_CARRIER_ID);
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+        processAllMessages();
     }
 
     private static String getPlmnFromCellIdentity(final CellIdentity ci) {
@@ -155,7 +129,7 @@ public class DisplayInfoControllerTest extends TelephonyTest {
                 new LteVopsSupportInfo(
                         LteVopsSupportInfo.LTE_STATUS_SUPPORTED,
                         LteVopsSupportInfo.LTE_STATUS_SUPPORTED);
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+        processAllMessages();
         NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(
                 NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 state, dataRat, 0, false, null, cid, getPlmnFromCellIdentity(cid), 1, false, false,
@@ -166,13 +140,13 @@ public class DisplayInfoControllerTest extends TelephonyTest {
                 mSst.obtainMessage(
                         ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                         new AsyncResult(mSst.mPollingContext, oldOpNamesResult, null)));
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+        processAllMessages();
         // update data reg state to be in service
         mSst.sendMessage(
                 mSst.obtainMessage(
                         ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                         new AsyncResult(mSst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+        processAllMessages();
         NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(
                 NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 state, voiceRat, 0, false, null, cid, getPlmnFromCellIdentity(cid), false, 0, 0, 0);
@@ -180,7 +154,7 @@ public class DisplayInfoControllerTest extends TelephonyTest {
                 mSst.obtainMessage(
                         ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                         new AsyncResult(mSst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSstHandler.getThreadHandler());
+        processAllMessages();
     }
 
     @Test
diff --git a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
index 3f777447a2..0145f129b8 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
@@ -161,6 +161,7 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
 
         doReturn(false).when(mSST).isDeviceShuttingDown();
         doReturn(true).when(mImsManager).isVolteEnabledByPlatform();
+        doReturn(true).when(mFeatureFlags).allowedServices();
 
         mPhoneUT = new GsmCdmaPhone(mContext, mSimulatedCommands, mNotifier, true, 0,
             PhoneConstants.PHONE_TYPE_GSM, mTelephonyComponentFactory, (c, p) -> mImsManager,
@@ -2759,6 +2760,64 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
                 any(Message.class));
     }
 
+    @Test
+    public void testAllowedImsServices() {
+        mPhoneUT.mCi = mMockCi;
+        // Update allowed IMS service for VoLTE and VoWiFi
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(1)).updateAllowedImsServices(any(), any(), any());
+        mPhoneUT.setAllowedImsServicesForHomeOnly(
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, true);
+        verify(mMockCi, times(2)).updateAllowedImsServices(any(), any(), any());
+
+        // Do not update allowed IMS services to modem if no change
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(2)).updateAllowedImsServices(any(), any(), any());
+
+        // Update allowed IMS service for VoWiFi
+        mPhoneUT.setAllowedImsServicesForAny(
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, true);
+        verify(mMockCi, times(3)).updateAllowedImsServices(any(), any(), any());
+    }
+
+    @Test
+    public void testClearAllowedImsServicesOnSimAbsent() {
+        mPhoneUT.mCi = mMockCi;
+        // Set allowed IMS service for VoLTE.
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(1)).updateAllowedImsServices(any(), any(), any());
+
+        // Clear allowed IMS service on SIM absent.
+        Intent intent = new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
+        intent.putExtra(SubscriptionManager.EXTRA_SLOT_INDEX, mPhone.getPhoneId());
+        intent.putExtra(TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_ABSENT);
+        mContext.sendBroadcast(intent);
+        processAllFutureMessages();
+
+        // Set allowed IMS service for VoLTE.
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(2)).updateAllowedImsServices(any(), any(), any());
+    }
+
+    @Test
+    public void testClearAllowedImsServicesOnSimUnknown() {
+        mPhoneUT.mCi = mMockCi;
+        // Set allowed IMS service for VoLTE.
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(1)).updateAllowedImsServices(any(), any(), any());
+
+        // Clear allowed IMS service on SIM unknown.
+        Intent intent = new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
+        intent.putExtra(SubscriptionManager.EXTRA_SLOT_INDEX, mPhone.getPhoneId());
+        intent.putExtra(TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_UNKNOWN);
+        mContext.sendBroadcast(intent);
+        processAllFutureMessages();
+
+        // Set allowed IMS service for VoLTE.
+        mPhoneUT.setAllowedImsServicesForAny(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, true);
+        verify(mMockCi, times(2)).updateAllowedImsServices(any(), any(), any());
+    }
+
     private void sendRadioAvailableToPhone(GsmCdmaPhone phone) {
         phone.sendMessage(phone.obtainMessage(EVENT_RADIO_AVAILABLE,
                 new AsyncResult(null, new int[]{ServiceState.RIL_RADIO_TECHNOLOGY_GSM}, null)));
diff --git a/tests/telephonytests/src/com/android/internal/telephony/ImsSmsDispatcherTest.java b/tests/telephonytests/src/com/android/internal/telephony/ImsSmsDispatcherTest.java
index 6c84b0801b..3512e4f90c 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/ImsSmsDispatcherTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/ImsSmsDispatcherTest.java
@@ -36,6 +36,7 @@ import static org.mockito.Mockito.when;
 import android.content.Context;
 import android.os.Binder;
 import android.os.PersistableBundle;
+import android.os.Process;
 import android.telephony.CarrierConfigManager;
 import android.telephony.SmsMessage;
 import android.telephony.ims.stub.ImsSmsImplBase;
@@ -87,7 +88,7 @@ public class ImsSmsDispatcherTest extends TelephonyTest {
             return mMockConnector;
         }).when(mConnectorFactory).create(any(), anyInt(), anyString(), any(), any());
         mImsSmsDispatcher = new ImsSmsDispatcher(mPhone, mSmsDispatchersController,
-                mConnectorFactory);
+                mConnectorFactory, mFeatureFlags);
         processAllMessages();
         // set the ImsManager instance
         verify(mMockConnector).connect();
@@ -336,7 +337,8 @@ public class ImsSmsDispatcherTest extends TelephonyTest {
         doReturn(mSmsUsageMonitor).when(mSmsDispatchersController).getUsageMonitor();
 
         mImsSmsDispatcher.sendText("+15555551212", null, "MessageRef test",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0,
+                Process.INVALID_UID);
         verify(mImsManager).sendSms(eq(token + 1), eq(messageRef), eq(SmsMessage.FORMAT_3GPP),
                 nullable(String.class), eq(false), (byte[]) any());
     }
@@ -351,7 +353,8 @@ public class ImsSmsDispatcherTest extends TelephonyTest {
         doReturn(mSmsUsageMonitor).when(mSmsDispatchersController).getUsageMonitor();
 
         mImsSmsDispatcher.sendText("+15555551212", null, "MessageRef test",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0,
+                Process.INVALID_UID);
         verify(mImsManager).sendSms(eq(token + 1), eq(messageRef), eq(SmsMessage.FORMAT_3GPP),
                 nullable(String.class), eq(false), (byte[]) any());
 
@@ -385,7 +388,8 @@ public class ImsSmsDispatcherTest extends TelephonyTest {
         doReturn(mSmsUsageMonitor).when(mSmsDispatchersController).getUsageMonitor();
 
         mImsSmsDispatcher.sendText("+15555551212", null, "MessageRef test",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0,
+                Process.INVALID_UID);
         verify(mImsManager).sendSms(eq(token + 1), eq(messageRef), eq(SmsMessage.FORMAT_3GPP),
                 nullable(String.class), eq(false), (byte[]) any());
 
@@ -423,7 +427,8 @@ public class ImsSmsDispatcherTest extends TelephonyTest {
         when(mPhone.getPhoneType()).thenReturn(PhoneConstants.PHONE_TYPE_GSM);
         doReturn(mSmsUsageMonitor).when(mSmsDispatchersController).getUsageMonitor();
         mImsSmsDispatcher.sendText("+15555551212", null, "Retry test",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0,
+                Process.INVALID_UID);
         verify(mImsManager).sendSms(eq(token + 1), eq(messageRef), eq(SmsMessage.FORMAT_3GPP),
                 nullable(String.class), eq(false), (byte[]) any());
         assertEquals(2, mImsSmsDispatcher.getMaxRetryCountOverIms());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/MccTableTest.java b/tests/telephonytests/src/com/android/internal/telephony/MccTableTest.java
index 2af83fa519..713656f3b1 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/MccTableTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/MccTableTest.java
@@ -56,9 +56,7 @@ public class MccTableTest {
 
     @Parameterized.Parameters(name = "{0}")
     public static List<FlagsParameterization> getParams() {
-        return FlagsParameterization.allCombinationsOf(
-                Flags.FLAG_USE_I18N_FOR_MCC_MAPPING,
-                com.android.icu.Flags.FLAG_TELEPHONY_LOOKUP_MCC_EXTENSION);
+        return FlagsParameterization.allCombinationsOf(Flags.FLAG_USE_I18N_FOR_MCC_MAPPING);
     }
 
     @Rule
@@ -155,7 +153,6 @@ public class MccTableTest {
     @Test
     public void telephonyFinder_shouldBeIdenticalToTelephonyMccTable() {
         assumeTrue(Flags.useI18nForMccMapping());
-        assumeTrue(com.android.icu.Flags.telephonyLookupMccExtension());
 
         TelephonyNetworkFinder telephonyNetworkFinder =
                 TelephonyLookup.getInstance().getTelephonyNetworkFinder();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/NetworkTypeControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/NetworkTypeControllerTest.java
index 4db6f56a9c..8a0f87b9d5 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/NetworkTypeControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/NetworkTypeControllerTest.java
@@ -2221,6 +2221,65 @@ public class NetworkTypeControllerTest extends TelephonyTest {
         assertEquals("connected_mmwave", getCurrentState().getName());
     }
 
+    @Test
+    public void testNrAdvancedRequiresWideSingleCc() {
+        // Set up the carrier config to require wide single CC for NR Advanced.
+        mBundle.putBoolean(CarrierConfigManager
+                .KEY_NR_ADVANCED_REQUIRES_SINGLE_CC_ABOVE_BANDWIDTH_THRESHOLD_BOOL, true);
+        // Set a bandwidth threshold that is relevant for a single wide band.
+        mBundle.putInt(CarrierConfigManager.KEY_NR_ADVANCED_THRESHOLD_BANDWIDTH_KHZ_INT, 100000);
+        sendCarrierConfigChanged();
+
+        // Ensure NR is mmWave.
+        doReturn(NetworkRegistrationInfo.NR_STATE_CONNECTED).when(mServiceState).getNrState();
+        doReturn(ServiceState.FREQUENCY_RANGE_MMWAVE).when(mServiceState).getNrFrequencyRange();
+
+        // Case 1: Multiple NR PCCs, one is wide enough (100MHz), others are not.
+        // Expected: Should qualify for NR_ADVANCED because the *maximum* bandwidth
+        // (100000 KHz) meets the 100000 KHz threshold.
+        List<PhysicalChannelConfig> pccs1 = new ArrayList<>();
+        pccs1.add(new PhysicalChannelConfig.Builder()
+                .setNetworkType(TelephonyManager.NETWORK_TYPE_NR)
+                .setCellConnectionStatus(CellInfo.CONNECTION_PRIMARY_SERVING)
+                .setCellBandwidthDownlinkKhz(90000) // 90 MHz - Not wide enough alone
+                .setPhysicalCellId(1)
+                .build());
+        pccs1.add(new PhysicalChannelConfig.Builder()
+                .setNetworkType(TelephonyManager.NETWORK_TYPE_NR)
+                .setCellConnectionStatus(CellInfo.CONNECTION_SECONDARY_SERVING)
+                .setCellBandwidthDownlinkKhz(100000) // 100 MHz - Wide enough!
+                .setPhysicalCellId(2)
+                .build());
+        // Total sum = 190000 KHz; Max = 100000 KHz.
+        // Since mNrAdvancedRequiresWideSingleCc is true, max is considered.
+        doReturn(pccs1).when(mSST).getPhysicalChannelConfigList();
+        sendCarrierConfigChanged();
+        assertEquals(TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_ADVANCED,
+                mNetworkTypeController.getOverrideNetworkType());
+
+        // Case 2: Multiple NR PCCs, none are individually wide enough.
+        // Expected: Should NOT qualify for NR_ADVANCED because no single CC meets the threshold.
+        List<PhysicalChannelConfig> pccs2 = new ArrayList<>();
+        pccs2.add(new PhysicalChannelConfig.Builder()
+                .setNetworkType(TelephonyManager.NETWORK_TYPE_NR)
+                .setCellConnectionStatus(CellInfo.CONNECTION_PRIMARY_SERVING)
+                .setCellBandwidthDownlinkKhz(70000) // 70 MHz
+                .setPhysicalCellId(3)
+                .build());
+        pccs2.add(new PhysicalChannelConfig.Builder()
+                .setNetworkType(TelephonyManager.NETWORK_TYPE_NR)
+                .setCellConnectionStatus(CellInfo.CONNECTION_SECONDARY_SERVING)
+                .setCellBandwidthDownlinkKhz(80000) // 80 MHz
+                .setPhysicalCellId(4)
+                .build());
+        // Total sum = 150000 KHz (would qualify if summing); Max = 80000 KHz (does NOT qualify).
+        // Since mNrAdvancedRequiresWideSingleCc is true, max is considered.
+        doReturn(pccs2).when(mSST).getPhysicalChannelConfigList();
+        sendCarrierConfigChanged();
+        assertEquals(TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA, // Not NR_ADVANCED
+                mNetworkTypeController.getOverrideNetworkType());
+    }
+
     @Test
     public void testNrAdvancedDisabledWhileRoaming() throws Exception {
         assertEquals("DefaultState", getCurrentState().getName());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/PhoneNumberUtilsTest.java b/tests/telephonytests/src/com/android/internal/telephony/PhoneNumberUtilsTest.java
index b08830c341..84df2790d6 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/PhoneNumberUtilsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/PhoneNumberUtilsTest.java
@@ -21,6 +21,8 @@ import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNull;
 import static junit.framework.Assert.assertTrue;
 
+import static org.junit.Assume.assumeTrue;
+
 import android.net.Uri;
 import android.platform.test.flag.junit.SetFlagsRule;
 import android.telephony.PhoneNumberUtils;
@@ -29,6 +31,7 @@ import android.text.style.TtsSpan;
 
 import androidx.test.filters.FlakyTest;
 import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
 
 import com.android.internal.telephony.flags.Flags;
 
@@ -37,7 +40,9 @@ import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(AndroidJUnit4.class)
 public class PhoneNumberUtilsTest {
 
     private static final int MIN_MATCH = 7;
@@ -540,11 +545,19 @@ public class PhoneNumberUtilsTest {
     @SmallTest
     @Test
     public void testWithNumberNotEqualToVoiceMail() throws Exception {
-        assertFalse(PhoneNumberUtils.isVoiceMailNumber("911"));
-        assertFalse(PhoneNumberUtils.isVoiceMailNumber("tel:911"));
-        assertFalse(PhoneNumberUtils.isVoiceMailNumber("+18001234567"));
-        assertFalse(PhoneNumberUtils.isVoiceMailNumber(""));
-        assertFalse(PhoneNumberUtils.isVoiceMailNumber(null));
+        try {
+            assertFalse(PhoneNumberUtils.isVoiceMailNumber("911"));
+            assertFalse(PhoneNumberUtils.isVoiceMailNumber("tel:911"));
+            assertFalse(PhoneNumberUtils.isVoiceMailNumber("+18001234567"));
+            assertFalse(PhoneNumberUtils.isVoiceMailNumber(""));
+            assertFalse(PhoneNumberUtils.isVoiceMailNumber(null));
+        } catch (UnsupportedOperationException e) {
+            // Telephony calling is not supported on this device so skip.
+            // Note: these tests run against static methods on PhoneNumberUtils, and there is no
+            // context available here to check package manager for FEATURE_TELEPHONY_CALLING, so we
+            // will catch the exception and do the assumption in this somewhat unorthodox manner.
+            assumeTrue("Telephony calling required", false);
+        }
         // This test fails on a device without a sim card
         /*TelephonyManager mTelephonyManager =
             (TelephonyManager)getContext().getSystemService(Context.TELEPHONY_SERVICE);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/ServiceStateTrackerTest.java b/tests/telephonytests/src/com/android/internal/telephony/ServiceStateTrackerTest.java
index 316ccd7773..091ac27609 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/ServiceStateTrackerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/ServiceStateTrackerTest.java
@@ -26,8 +26,8 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyString;
@@ -55,7 +55,6 @@ import android.os.AsyncResult;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.Looper;
 import android.os.Message;
 import android.os.PersistableBundle;
 import android.os.Process;
@@ -89,15 +88,16 @@ import android.telephony.gsm.GsmCellLocation;
 import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.telephony.satellite.ISatelliteModemStateCallback;
 import android.telephony.satellite.SatelliteManager;
+import android.testing.AndroidTestingRunner;
+import android.testing.TestableLooper;
 import android.text.TextUtils;
 import android.util.Pair;
 
 import androidx.test.filters.FlakyTest;
-import androidx.test.filters.MediumTest;
-import androidx.test.filters.SmallTest;
 
 import com.android.internal.R;
 import com.android.internal.telephony.data.AccessNetworksManager;
+import com.android.internal.telephony.data.DataNetwork;
 import com.android.internal.telephony.data.DataNetworkController;
 import com.android.internal.telephony.emergency.EmergencyStateTracker;
 import com.android.internal.telephony.metrics.ServiceStateStats;
@@ -111,6 +111,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 
@@ -123,11 +124,12 @@ import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
 
+@RunWith(AndroidTestingRunner.class)
+@TestableLooper.RunWithLooper
 public class ServiceStateTrackerTest extends TelephonyTest {
     // Mocked classes
     private ProxyController mProxyController;
     private Handler mTestHandler;
-    private NetworkService mIwlanNetworkService;
     private INetworkService.Stub mIwlanNetworkServiceStub;
     private SubscriptionInfo mSubInfo;
 
@@ -142,7 +144,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     private SignalStrengthController mSsc;
 
     private ServiceStateTracker sst;
-    private ServiceStateTrackerTestHandler mSSTTestHandler;
     private PersistableBundle mBundle;
     private SatelliteController mSatelliteController;
     private EmergencyStateTracker mEmergencyStateTracker;
@@ -156,8 +157,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     private static final int EVENT_DATA_RAT_CHANGED = 7;
     private static final int EVENT_PS_RESTRICT_ENABLED = 8;
     private static final int EVENT_PS_RESTRICT_DISABLED = 9;
-    private static final int EVENT_VOICE_ROAMING_ON = 10;
-    private static final int EVENT_VOICE_ROAMING_OFF = 11;
     private static final int EVENT_VOICE_RAT_CHANGED = 12;
 
     private static final int PHONE_ID = 0;
@@ -175,6 +174,9 @@ public class ServiceStateTrackerTest extends TelephonyTest {
             WIFI_CALLING_FLIGHT_MODE_FORMAT };
 
     private static final String HOME_PLMN = "310260";
+    private static final String HOME_MCC = "310";
+    private static final String HOME_MNC = "260";
+
     private static final String PLMN1 = "480123";
     private static final String PLMN2 = "586111";
     private static final String HOME_PNN = "home pnn";
@@ -185,35 +187,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     };
     private static final String SATELLITE_DISPLAY_NAME = "SatelliteTest";
 
-    private class ServiceStateTrackerTestHandler extends HandlerThread {
-
-        private ServiceStateTrackerTestHandler(String name) {
-            super(name);
-        }
-
-        @Override
-        public void onLooperPrepared() {
-            mSsc = new SignalStrengthController(mPhone);
-            doReturn(mSsc).when(mPhone).getSignalStrengthController();
-
-            // Capture listener registered for ServiceStateTracker to emulate the carrier config
-            // change notification used later. In this test, it's the third one. The first one
-            // comes from RatRatcheter and the second one comes from SignalStrengthController.
-            ArgumentCaptor<CarrierConfigManager.CarrierConfigChangeListener>
-                    listenerArgumentCaptor =
-                            ArgumentCaptor.forClass(
-                                    CarrierConfigManager.CarrierConfigChangeListener.class);
-            sst = new ServiceStateTracker(mPhone, mSimulatedCommands, mFeatureFlags);
-            verify(mCarrierConfigManager, atLeast(3)).registerCarrierConfigChangeListener(any(),
-                    listenerArgumentCaptor.capture());
-            mCarrierConfigChangeListener = listenerArgumentCaptor.getAllValues().get(2);
-
-            sst.setServiceStateStats(mServiceStateStats);
-            doReturn(sst).when(mPhone).getServiceStateTracker();
-            setReady(true);
-        }
-    }
-
     private void addNetworkService() {
         mCellularNetworkService = new CellularNetworkService();
         ServiceInfo CellularServiceInfo = new ServiceInfo();
@@ -251,7 +224,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         super.setUp(getClass().getSimpleName());
         mProxyController = Mockito.mock(ProxyController.class);
         mTestHandler = Mockito.mock(Handler.class);
-        mIwlanNetworkService = Mockito.mock(NetworkService.class);
         mIwlanNetworkServiceStub = Mockito.mock(INetworkService.Stub.class);
         mSubInfo = Mockito.mock(SubscriptionInfo.class);
         mSubInfoInternal = new SubscriptionInfoInternal.Builder().setId(1).build();
@@ -276,7 +248,12 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         doReturn(mIwlanNetworkServiceStub).when(mIwlanNetworkServiceStub).asBinder();
         addNetworkService();
 
-        doReturn(true).when(mDataNetworkController).areAllDataDisconnected();
+        Field field = NetworkService.class.getDeclaredField("mHandlerThread");
+        field.setAccessible(true);
+        monitorTestableLooper(new TestableLooper(
+                ((HandlerThread) field.get(mCellularNetworkService)).getLooper()));
+
+        doReturn(true).when(mDataNetworkController).areAllDataDisconnected(anyBoolean());
 
         doReturn(new ServiceState()).when(mPhone).getServiceState();
 
@@ -308,10 +285,25 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mContextFixture.putBooleanResource(
                 R.bool.config_enable_cellular_on_boot_default, true);
 
-        mSSTTestHandler = new ServiceStateTrackerTestHandler(getClass().getSimpleName());
-        mSSTTestHandler.start();
-        waitUntilReady();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        mSsc = new SignalStrengthController(mPhone);
+        doReturn(mSsc).when(mPhone).getSignalStrengthController();
+
+        // Capture listener registered for ServiceStateTracker to emulate the carrier config
+        // change notification used later. In this test, it's the third one. The first one
+        // comes from RatRatcheter and the second one comes from SignalStrengthController.
+        ArgumentCaptor<CarrierConfigManager.CarrierConfigChangeListener>
+                listenerArgumentCaptor =
+                ArgumentCaptor.forClass(
+                        CarrierConfigManager.CarrierConfigChangeListener.class);
+        sst = new ServiceStateTracker(mPhone, mSimulatedCommands, mFeatureFlags);
+        verify(mCarrierConfigManager, atLeast(3)).registerCarrierConfigChangeListener(any(),
+                listenerArgumentCaptor.capture());
+        mCarrierConfigChangeListener = listenerArgumentCaptor.getAllValues().get(2);
+
+        sst.setServiceStateStats(mServiceStateStats);
+        doReturn(sst).when(mPhone).getServiceStateTracker();
+
+        processAllMessages();
 
         // Voice radio tech change will always trigger an update of
         // phone object irrespective of this config
@@ -393,27 +385,21 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 SATELLITE_DISPLAY_NAME);
 
         sendCarrierConfigUpdate(PHONE_ID);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         mEmergencyStateTracker = Mockito.mock(EmergencyStateTracker.class);
         replaceInstance(EmergencyStateTracker.class, "INSTANCE", null, mEmergencyStateTracker);
 
+        doReturn(true).when(mFeatureFlags).keepWfcOnApm();
         logd("ServiceStateTrackerTest -Setup!");
     }
 
     @After
     public void tearDown() throws Exception {
-        sst.removeCallbacksAndMessages(null);
-        sst = null;
-        mSSTTestHandler.quit();
-        mSSTTestHandler.join();
-        mSSTTestHandler = null;
         if (mCellularNetworkService != null) {
             mCellularNetworkService.onDestroy();
             mCellularNetworkService = null;
         }
-        mSsc = null;
-        mBundle = null;
         super.tearDown();
     }
 
@@ -429,17 +415,31 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testSetRadioPower() {
         boolean oldState = (mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
         sst.setRadioPower(!oldState);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(oldState
                 != (mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON));
     }
 
     @Test
-    public void testSetRadioPowerWaitForAllDataDisconnected() throws Exception {
+    public void testSetRadioPowerAfterShuttingDownRequest() {
+        sst.setRadioPower(true);
+        processAllMessages();
+
+        sst.requestShutdown();
+        processAllMessages();
+        assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_UNAVAILABLE);
+        assertEquals(TelephonyManager.RADIO_POWER_UNAVAILABLE, mSimulatedCommands.getRadioState());
+
+        sst.setRadioPower(true);
+        processAllMessages();
+        assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
+    }
+
+    @Test
+    public void testSetRadioPowerWaitForAllDataDisconnectedShutDown() throws Exception {
         // Set up DSDS environment
         GsmCdmaPhone phone2 = Mockito.mock(GsmCdmaPhone.class);
         DataNetworkController dataNetworkController_phone2 =
@@ -448,19 +448,19 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         replaceInstance(PhoneFactory.class, "sPhones", null, mPhones);
         doReturn(dataNetworkController_phone2).when(phone2).getDataNetworkController();
         doReturn(mSST).when(phone2).getServiceStateTracker();
-        doReturn(false).when(mDataNetworkController).areAllDataDisconnected();
-        doReturn(false).when(dataNetworkController_phone2).areAllDataDisconnected();
+        doReturn(false).when(mDataNetworkController).areAllDataDisconnected(anyBoolean());
+        doReturn(false).when(dataNetworkController_phone2).areAllDataDisconnected(anyBoolean());
         doReturn(1).when(mPhone).getSubId();
         doReturn(2).when(phone2).getSubId();
 
         // Start with radio on
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
 
         // Turn on APM and verify that both subs are waiting for all data disconnected
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         verify(mDataNetworkController).tearDownAllDataNetworks(
                 eq(3 /* TEAR_DOWN_REASON_AIRPLANE_MODE_ON */));
@@ -475,17 +475,17 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 callback2.capture());
 
         // Data disconnected on sub 2, still waiting for data disconnected on sub 1
-        doReturn(true).when(dataNetworkController_phone2).areAllDataDisconnected();
-        callback2.getValue().onAnyDataNetworkExistingChanged(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        doReturn(true).when(dataNetworkController_phone2).areAllDataDisconnected(anyBoolean());
+        callback2.getValue().onAnyDataNetworkExistingChanged(false, false);
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         verify(dataNetworkController_phone2, times(1)).unregisterDataNetworkControllerCallback(
                 any());
 
         // Data disconnected on sub 1, radio should power off now
-        doReturn(true).when(mDataNetworkController).areAllDataDisconnected();
-        callback1.getValue().onAnyDataNetworkExistingChanged(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        doReturn(true).when(mDataNetworkController).areAllDataDisconnected(anyBoolean());
+        callback1.getValue().onAnyDataNetworkExistingChanged(false, false);
+        processAllMessages();
         verify(mDataNetworkController, times(1)).unregisterDataNetworkControllerCallback(any());
         assertEquals(TelephonyManager.RADIO_POWER_OFF, mSimulatedCommands.getRadioState());
         verify(mEmergencyStateTracker, never()).onCellularRadioPowerOffRequested();
@@ -503,19 +503,19 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         replaceInstance(PhoneFactory.class, "sPhones", null, mPhones);
         doReturn(dataNetworkController_phone2).when(phone2).getDataNetworkController();
         doReturn(mSST).when(phone2).getServiceStateTracker();
-        doReturn(false).when(mDataNetworkController).areAllDataDisconnected();
-        doReturn(false).when(dataNetworkController_phone2).areAllDataDisconnected();
+        doReturn(false).when(mDataNetworkController).areAllDataDisconnected(anyBoolean());
+        doReturn(false).when(dataNetworkController_phone2).areAllDataDisconnected(anyBoolean());
         doReturn(1).when(mPhone).getSubId();
         doReturn(2).when(phone2).getSubId();
 
         // Start with radio on
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
 
         // Turn on APM
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
 
         // Verify checking emergency mode
@@ -535,32 +535,31 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 callback2.capture());
 
         // Data disconnected on sub 2, still waiting for data disconnected on sub 1
-        doReturn(true).when(dataNetworkController_phone2).areAllDataDisconnected();
-        callback2.getValue().onAnyDataNetworkExistingChanged(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        doReturn(true).when(dataNetworkController_phone2).areAllDataDisconnected(anyBoolean());
+        callback2.getValue().onAnyDataNetworkExistingChanged(false, false);
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         verify(dataNetworkController_phone2, times(1)).unregisterDataNetworkControllerCallback(
                 any());
 
         // Data disconnected on sub 1, radio should power off now
-        doReturn(true).when(mDataNetworkController).areAllDataDisconnected();
-        callback1.getValue().onAnyDataNetworkExistingChanged(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        doReturn(true).when(mDataNetworkController).areAllDataDisconnected(anyBoolean());
+        callback1.getValue().onAnyDataNetworkExistingChanged(false, false);
+        processAllMessages();
         verify(mDataNetworkController, times(1)).unregisterDataNetworkControllerCallback(any());
         assertEquals(TelephonyManager.RADIO_POWER_OFF, mSimulatedCommands.getRadioState());
     }
 
     @Test
-    @SmallTest
     public void testSetRadioPowerOnForEmergencyCall() {
         // Turn off radio first.
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_OFF);
 
         // Turn on radio for emergency call.
         sst.setRadioPower(true, true, true, false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.mSetRadioPowerForEmergencyCall);
         assertTrue(mSimulatedCommands.mSetRadioPowerAsSelectedPhoneForEmergencyCall);
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
@@ -568,20 +567,19 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         // If we try again without forceApply=true, no command should be sent to modem. Because
         // radio power is already ON.
         sst.setRadioPower(true, false, false, false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.mSetRadioPowerForEmergencyCall);
         assertTrue(mSimulatedCommands.mSetRadioPowerAsSelectedPhoneForEmergencyCall);
 
         // Call setRadioPower on with forceApply=true. ForEmergencyCall and isSelectedPhone should
         // be cleared.
         sst.setRadioPower(true, false, false, true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.mSetRadioPowerForEmergencyCall);
         assertFalse(mSimulatedCommands.mSetRadioPowerAsSelectedPhoneForEmergencyCall);
     }
 
     @Test
-    @MediumTest
     public void testSetRadioPowerForReason() {
         testSetRadioPowerForReason(TelephonyManager.RADIO_POWER_REASON_THERMAL);
         testSetRadioPowerForReason(TelephonyManager.RADIO_POWER_REASON_NEARBY_DEVICE);
@@ -598,14 +596,14 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         assertTrue(sst.getRadioPowerOffReasons().size() == 1);
         verify(mSatelliteController).onSetCellularRadioPowerStateRequested(eq(false));
         clearInvocations(mSatelliteController);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_OFF);
         sst.setRadioPowerForReason(true, false, false, false,
                 TelephonyManager.RADIO_POWER_REASON_USER);
         assertTrue(sst.getRadioPowerOffReasons().contains(reason));
         assertTrue(sst.getRadioPowerOffReasons().size() == 1);
         verify(mSatelliteController, never()).onSetCellularRadioPowerStateRequested(anyBoolean());
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_OFF);
 
         // Radio power state reason is removed and radio turns on if turned on for same reason it
@@ -613,23 +611,22 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.setRadioPowerForReason(true, false, false, false, reason);
         assertTrue(sst.getRadioPowerOffReasons().isEmpty());
         verify(mSatelliteController).onSetCellularRadioPowerStateRequested(eq(true));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
 
         // Turn radio off, then successfully turn radio on for emergency call.
         sst.setRadioPowerForReason(false, false, false, false, reason);
         assertTrue(sst.getRadioPowerOffReasons().contains(reason));
         assertTrue(sst.getRadioPowerOffReasons().size() == 1);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_OFF);
         sst.setRadioPower(true, true, true, false);
         assertTrue(sst.getRadioPowerOffReasons().isEmpty());
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
     }
 
     @Test
-    @MediumTest
     public void testSetRadioPowerForMultipleReasons() {
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
         assertTrue(sst.getRadioPowerOffReasons().isEmpty());
@@ -655,7 +652,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.setRadioPowerForReason(false, false, false, false, reason);
         assertTrue(sst.getRadioPowerOffReasons().contains(reason));
         assertTrue(sst.getRadioPowerOffReasons().size() == powerOffReasonSize);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_OFF);
     }
 
@@ -664,17 +661,84 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.setRadioPowerForReason(true, false, false, false, reason);
         assertFalse(sst.getRadioPowerOffReasons().contains(reason));
         assertTrue(sst.getRadioPowerOffReasons().size() == powerOffReasonSize);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == expectedRadioPowerState);
     }
 
     @Test
-    @MediumTest
+    public void testSetRadioPowerWaitForAllDataDisconnectedApmThenShutDown() throws Exception {
+        // Set up DSDS environment
+        DataNetworkController dataNetworkController2 =
+                Mockito.mock(DataNetworkController.class);
+        mPhones = new Phone[] {mPhone, mPhone2};
+        replaceInstance(PhoneFactory.class, "sPhones", null, mPhones);
+        doReturn(dataNetworkController2).when(mPhone2).getDataNetworkController();
+        doReturn(mSST).when(mPhone2).getServiceStateTracker();
+        doReturn(false).when(mDataNetworkController).areAllDataDisconnected(true);
+        doReturn(false).when(dataNetworkController2).areAllDataDisconnected(true);
+        doReturn(1).when(mPhone).getSubId();
+        doReturn(2).when(mPhone2).getSubId();
+
+        // Start with radio on
+        sst.setRadioPower(true);
+        processAllMessages();
+        assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
+
+        // Turn on APM and verify that both subs are waiting for all data disconnected
+        sst.setRadioPower(false);
+        processAllMessages();
+        assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
+        verify(mDataNetworkController).tearDownAllDataNetworks(
+                eq(3 /* TEAR_DOWN_REASON_AIRPLANE_MODE_ON */));
+        verify(dataNetworkController2, never()).tearDownAllDataNetworks(anyInt());
+        ArgumentCaptor<DataNetworkController.DataNetworkControllerCallback> callback1 =
+                ArgumentCaptor.forClass(DataNetworkController.DataNetworkControllerCallback.class);
+        ArgumentCaptor<DataNetworkController.DataNetworkControllerCallback> callback2 =
+                ArgumentCaptor.forClass(DataNetworkController.DataNetworkControllerCallback.class);
+        verify(mDataNetworkController, times(1)).registerDataNetworkControllerCallback(
+                callback1.capture());
+        verify(dataNetworkController2, times(1)).registerDataNetworkControllerCallback(
+                callback2.capture());
+
+        // Data disconnected on sub 2, still waiting for data disconnected on sub 1
+        doReturn(true).when(dataNetworkController2).areAllDataDisconnected(true);
+        callback2.getValue().onAnyDataNetworkExistingChanged(true, false);
+        processAllMessages();
+        assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
+        verify(dataNetworkController2, times(1)).unregisterDataNetworkControllerCallback(
+                any());
+
+        // Shut down device, verify disconnect all data networks
+        doReturn(false).when(mDataNetworkController).areAllDataDisconnected(false);
+        doReturn(false).when(dataNetworkController2).areAllDataDisconnected(false);
+        clearInvocations(mDataNetworkController, dataNetworkController2);
+        sst.requestShutdown();
+        processAllMessages();
+        verify(mDataNetworkController).tearDownAllDataNetworks(
+                DataNetwork.TEAR_DOWN_REASON_DEVICE_SHUT_DOWN);
+        verify(mDataNetworkController, times(1)).registerDataNetworkControllerCallback(
+                callback1.capture());
+        verify(dataNetworkController2, times(1)).registerDataNetworkControllerCallback(
+                callback2.capture());
+
+        // Data disconnected on sub 1, radio should power off now
+        doReturn(true).when(mDataNetworkController).areAllDataDisconnected(false);
+        doReturn(true).when(dataNetworkController2).areAllDataDisconnected(false);
+        callback2.getValue().onAnyDataNetworkExistingChanged(false, false);
+        callback1.getValue().onAnyDataNetworkExistingChanged(false, false);
+        processAllMessages();
+        verify(mDataNetworkController, times(1)).unregisterDataNetworkControllerCallback(any());
+        assertEquals(TelephonyManager.RADIO_POWER_UNAVAILABLE, mSimulatedCommands.getRadioState());
+        verify(mEmergencyStateTracker, never()).onCellularRadioPowerOffRequested();
+    }
+
+
+    @Test
     public void testSetRadioPowerForReasonCarrier() {
         // Carrier disable radio power
         sst.setRadioPowerForReason(false, false, false, false,
                 TelephonyManager.RADIO_POWER_REASON_CARRIER);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.getRadioState()
                 == TelephonyManager.RADIO_POWER_ON);
         assertFalse(sst.getDesiredPowerState());
@@ -685,7 +749,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         // User toggle radio power will not overrides carrier settings
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.getRadioState()
                 == TelephonyManager.RADIO_POWER_ON);
         assertFalse(sst.getDesiredPowerState());
@@ -697,7 +761,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         // Carrier re-enable radio power
         sst.setRadioPowerForReason(true, false, false, false,
                 TelephonyManager.RADIO_POWER_REASON_CARRIER);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
         assertTrue(sst.getDesiredPowerState());
         assertTrue(sst.getPowerStateFromCarrier());
@@ -707,7 +771,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.setRadioPower(false);
         sst.setRadioPowerForReason(true, false, false, false,
                 TelephonyManager.RADIO_POWER_REASON_CARRIER);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.getRadioState()
                 == TelephonyManager.RADIO_POWER_ON);
         assertFalse(sst.getDesiredPowerState());
@@ -715,7 +779,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testRilTrafficAfterSetRadioPower() {
         sst.setRadioPower(true);
         final int getOperatorCallCount = mSimulatedCommands.getGetOperatorCallCount();
@@ -727,9 +790,9 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 mSimulatedCommands.getGetNetworkSelectionModeCallCount();
         sst.setRadioPower(false);
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.pollState();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // This test was meant to be for *no* ril traffic. However, RADIO_STATE_CHANGED is
         // considered a modem triggered action and that causes a pollState() to be done
@@ -744,7 +807,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         // Note that if the poll is triggered by a network change notification
         // and the modem is supposed to be off, we should still do the poll
         mSimulatedCommands.notifyNetworkStateChanged();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertEquals(getOperatorCallCount + 2 , mSimulatedCommands.getGetOperatorCallCount());
         assertEquals(getDataRegistrationStateCallCount + 2,
@@ -755,10 +818,8 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 mSimulatedCommands.getGetNetworkSelectionModeCallCount());
     }
 
-    @FlakyTest
     @Ignore
     @Test
-    @MediumTest
     public void testSpnUpdateShowPlmnOnly() {
         doReturn(0).when(mSimRecords).getCarrierNameDisplayCondition();
         doReturn(IccCardApplicationStatus.AppState.APPSTATE_UNKNOWN).
@@ -766,7 +827,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_NETWORK_STATE_CHANGED, null));
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
         verify(mContextFixture.getTestDouble(), times(3))
@@ -811,7 +872,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testCachedCellInfoList() {
         ArrayList<CellInfo> list = new ArrayList();
         list.add(getCellInfoGsm());
@@ -822,76 +882,17 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         // null worksource and no response message will update the writethrough cache
         sst.requestAllCellInfo(null, null);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(sst.getAllCellInfo(), list);
     }
 
-    private static class CellInfoHandler extends Handler {
-        // Need to define this here so that it's accessible
-        public List<CellInfo> cellInfoResult;
-
-        CellInfoHandler(Looper l) {
-            super(l);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            synchronized (msg) {
-                assertTrue("handler received null message", msg.obj != null);
-                AsyncResult ar = (AsyncResult) msg.obj;
-                cellInfoResult = (List<CellInfo>) ar.result;
-                msg.notifyAll();
-            }
-        }
-    }
-
     @Test
-    @MediumTest
-    public void testGetCellInfoResponse() throws InterruptedException {
-        mSimulatedCommands.setCellInfoListBehavior(true);
-        ArrayList<CellInfo> list = new ArrayList();
-        list.add(getCellInfoGsm());
-        mSimulatedCommands.setCellInfoList(list);
-        CellInfoHandler cih = new CellInfoHandler(mSSTTestHandler.getLooper());
-
-        Message rsp = cih.obtainMessage(0x7357);
-
-        sst.requestAllCellInfo(null, rsp);
-
-        synchronized (rsp) {
-            if (cih.cellInfoResult == null) rsp.wait(5000);
-        }
-
-        AsyncResult ar = (AsyncResult) rsp.obj;
-        assertTrue("CellInfo Response Not Received", cih.cellInfoResult != null);
-        assertEquals(getCellInfoGsm(), cih.cellInfoResult.get(0));
-    }
-
-    @Test
-    @MediumTest
-    public void testGetCellInfoResponseTimeout() throws InterruptedException {
-        mSimulatedCommands.setCellInfoListBehavior(false);
-        CellInfoHandler cih = new CellInfoHandler(mSSTTestHandler.getLooper());
-
-        Message rsp = cih.obtainMessage(0x7357);
-
-        sst.requestAllCellInfo(null, rsp);
-
-        synchronized (rsp) {
-            if (cih.cellInfoResult == null) rsp.wait(5000);
-        }
-
-        assertTrue("Spurious CellInfo Response Received", cih.cellInfoResult == null);
-    }
-
-    @Test
-    @MediumTest
     public void testImsRegState() {
         // Simulate IMS registered
         mSimulatedCommands.setImsRegistrationState(new int[]{1, PhoneConstants.PHONE_TYPE_GSM});
 
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_IMS_STATE_CHANGED, null));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertTrue(sst.isImsRegistered());
 
@@ -899,7 +900,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setImsRegistrationState(new int[]{0, PhoneConstants.PHONE_TYPE_GSM});
 
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_IMS_STATE_CHANGED, null));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertFalse(sst.isImsRegistered());
     }
@@ -912,7 +913,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         sst.mSS = ss;
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_IMS_SERVICE_STATE_CHANGED));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // The listener will be notified that the service state was changed.
         verify(mPhone).notifyServiceStateChanged(any(ServiceState.class));
@@ -923,7 +924,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.mSS = ss;
 
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_IMS_SERVICE_STATE_CHANGED));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Nothing happened because the IMS service state was not affected the merged service state.
         verify(mPhone, times(1)).notifyServiceStateChanged(any(ServiceState.class));
@@ -933,11 +934,10 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mCarrierConfigChangeListener.onCarrierConfigChanged(phoneId,
                 SubscriptionManager.INVALID_SUBSCRIPTION_ID,
                 TelephonyManager.UNKNOWN_CARRIER_ID, TelephonyManager.UNKNOWN_CARRIER_ID);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     @Test
-    @MediumTest
     // TODO(nharold): we probably should remove support for this procedure (GET_LOC)
     public void testGsmCellLocation() {
         CellIdentityGsm cellIdentityGsm = new CellIdentityGsm(
@@ -954,7 +954,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_GET_LOC_DONE,
                 new AsyncResult(null, result, null)));
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         WorkSource workSource = new WorkSource(Process.myUid(), mContext.getPackageName());
         GsmCellLocation cl = (GsmCellLocation) sst.getCellIdentity().asCellLocation();
         assertEquals(2, cl.getLac());
@@ -963,7 +963,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
     @FlakyTest /* flakes 0.86% of the time */
     @Test
-    @MediumTest
     // TODO(nharold): we probably should remove support for this procedure (GET_LOC)
     public void testCdmaCellLocation() {
         CellIdentityCdma cellIdentityCdma = new CellIdentityCdma(1, 2, 3, 4, 5, "test", "tst");
@@ -978,7 +977,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_GET_LOC_DONE,
                 new AsyncResult(null, result, null)));
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         WorkSource workSource = new WorkSource(Process.myUid(), mContext.getPackageName());
         CdmaCellLocation cl = (CdmaCellLocation) sst.getCellIdentity().asCellLocation();
         assertEquals(5, cl.getBaseStationLatitude());
@@ -1006,7 +1005,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForVoiceRoamingOn() throws Exception {
         sst.registerForVoiceRoamingOn(mTestHandler, EVENT_DATA_ROAMING_ON, null);
 
@@ -1015,7 +1013,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setVoiceRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1027,7 +1025,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForVoiceRoamingOn(mTestHandler);
@@ -1037,14 +1035,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForVoiceRoamingOff() throws Exception {
         // Enable roaming
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1052,7 +1049,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForVoiceRoamingOff(mTestHandler, EVENT_DATA_ROAMING_OFF, null);
 
@@ -1062,7 +1059,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1074,7 +1071,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForVoiceRoamingOff(mTestHandler);
@@ -1084,14 +1081,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForDataRoamingOn() throws Exception {
         sst.registerForDataRoamingOn(mTestHandler, EVENT_DATA_ROAMING_ON, null);
 
@@ -1101,7 +1097,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1113,7 +1109,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForDataRoamingOn(mTestHandler);
@@ -1123,14 +1119,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForDataRoamingOff() throws Exception {
         // Enable roaming
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1138,7 +1133,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForDataRoamingOff(mTestHandler, EVENT_DATA_ROAMING_OFF, null, true);
 
@@ -1148,7 +1143,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1160,7 +1155,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForDataRoamingOff(mTestHandler);
@@ -1170,14 +1165,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndInvalidregForDataConnAttach() throws Exception {
         // Initially set service state out of service
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1185,7 +1179,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(23);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForDataConnectionAttached(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 mTestHandler, EVENT_DATA_CONNECTION_ATTACHED, null);
@@ -1195,7 +1189,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
         verify(mTestHandler).sendMessageAtTime(messageArgumentCaptor.capture(), anyLong());
@@ -1206,7 +1200,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(-1);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForDataConnectionAttached(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
@@ -1217,14 +1211,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForDataConnAttach() throws Exception {
         // Initially set service state out of service
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1232,7 +1225,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForDataConnectionAttached(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 mTestHandler, EVENT_DATA_CONNECTION_ATTACHED, null);
@@ -1242,7 +1235,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1254,7 +1247,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForDataConnectionAttached(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
@@ -1265,14 +1258,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndUnregForDataConnDetach() throws Exception {
         // Initially set service state in service
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1288,7 +1280,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1300,7 +1292,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForDataConnectionDetached(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
@@ -1311,14 +1303,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegisterForVoiceRegStateOrRatChange() throws Exception {
         NetworkRegistrationInfo nri = new NetworkRegistrationInfo.Builder()
                 .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
@@ -1330,7 +1321,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.mSS.setState(ServiceState.STATE_IN_SERVICE);
         sst.registerForVoiceRegStateOrRatChanged(mTestHandler, EVENT_VOICE_RAT_CHANGED, null);
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Verify if message was posted to handler and value of result
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1344,7 +1335,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testRegisterForDataRegStateOrRatChange() {
         NetworkRegistrationInfo nrs = new NetworkRegistrationInfo.Builder()
                 .setDomain(NetworkRegistrationInfo.DOMAIN_PS)
@@ -1356,7 +1346,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.registerForDataRegStateOrRatChanged(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 mTestHandler, EVENT_DATA_RAT_CHANGED, null);
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Verify if message was posted to handler and value of result
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1367,9 +1357,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ((AsyncResult)messageArgumentCaptor.getValue().obj).result);
     }
 
-    @FlakyTest /* flakes 0.43% of the time */
     @Test
-    @MediumTest
     public void testRegAndUnregForNetworkAttached() throws Exception {
         // Initially set service state out of service
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1377,7 +1365,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForNetworkAttached(mTestHandler, EVENT_REGISTERED_TO_NETWORK, null);
 
@@ -1386,7 +1374,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1398,7 +1386,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_UNKNOWN);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForNetworkAttached(mTestHandler);
@@ -1408,14 +1396,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify that no new message posted to handler
         verify(mTestHandler, times(1)).sendMessageAtTime(any(Message.class), anyLong());
     }
 
     @Test
-    @MediumTest
     public void testRegAndInvalidRegForNetworkAttached() throws Exception {
         // Initially set service state out of service
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1423,7 +1410,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(23);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForNetworkAttached(mTestHandler, EVENT_REGISTERED_TO_NETWORK, null);
 
@@ -1432,8 +1419,8 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForDelayedHandlerAction(mSSTTestHandler.getThreadHandler(), 500, 200);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        //waitForDelayedHandlerAction(mSSTTestHandler.getThreadHandler(), 500, 200);
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1445,13 +1432,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(-1);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Unregister registrant
         sst.unregisterForNetworkAttached(mTestHandler);
 
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.registerForNetworkAttached(mTestHandler, EVENT_REGISTERED_TO_NETWORK, null);
 
@@ -1460,7 +1447,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         mSimulatedCommands.setDataRegState(NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
         mSimulatedCommands.notifyNetworkStateChanged();
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify if registered handler has message posted to it
         messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1470,14 +1457,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testRegisterForPsRestrictedEnabled() throws Exception {
         sst.mRestrictedState.setPsRestricted(true);
         // Since PsRestricted is set to true, registerForPsRestrictedEnabled will
         // also post message to handler
         sst.registerForPsRestrictedEnabled(mTestHandler, EVENT_PS_RESTRICT_ENABLED, null);
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify posted message
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1486,14 +1472,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testRegisterForPsRestrictedDisabled() throws Exception {
         sst.mRestrictedState.setPsRestricted(true);
         // Since PsRestricted is set to true, registerForPsRestrictedDisabled will
         // also post message to handler
         sst.registerForPsRestrictedDisabled(mTestHandler, EVENT_PS_RESTRICT_DISABLED, null);
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // verify posted message
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
@@ -1502,7 +1487,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @MediumTest
     public void testOnRestrictedStateChanged() throws Exception {
         ServiceStateTracker spySst = spy(sst);
         doReturn(true).when(mPhone).isPhoneTypeGsm();
@@ -1566,7 +1550,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     private void internalCheckForRestrictedStateChange(ServiceStateTracker serviceStateTracker,
                 int times, int[] restrictedState) {
         mSimulatedCommands.triggerRestrictedStateChanged(restrictedState[0]);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         ArgumentCaptor<Integer> intArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
         verify(serviceStateTracker, times(times)).setNotification(intArgumentCaptor.capture());
         assertEquals(intArgumentCaptor.getValue().intValue(), restrictedState[1]);
@@ -1583,7 +1567,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetPsNotifications() throws Exception {
         int subId = 1;
         sst.mSubId = subId;
@@ -1616,7 +1599,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetCsNotifications() throws Exception {
         int subId = 1;
         sst.mSubId = subId;
@@ -1650,7 +1632,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetCsNormalNotifications() throws Exception {
         int subId = 1;
         sst.mSubId = subId;
@@ -1683,7 +1664,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetCsEmergencyNotifications() throws Exception {
         int subId = 1;
         sst.mSubId = subId;
@@ -1718,7 +1698,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetNotificationsForGroupedSubs() {
         //if subscription is grouped, no notification should be set whatsoever
         int subId = 1;
@@ -1751,104 +1730,95 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testGetDesiredPowerState() {
         sst.setRadioPower(true);
         assertEquals(sst.getDesiredPowerState(), true);
     }
 
     @Test
-    @SmallTest
     public void testGetCurrentDataRegState() throws Exception {
         sst.mSS.setDataRegState(ServiceState.STATE_OUT_OF_SERVICE);
         assertEquals(sst.getCurrentDataConnectionState(), ServiceState.STATE_OUT_OF_SERVICE);
     }
 
     @Test
-    @MediumTest
     public void testIsImsRegistered() throws Exception {
         mSimulatedCommands.setImsRegistrationState(new int[]{1, PhoneConstants.PHONE_TYPE_GSM});
         mSimulatedCommands.notifyImsNetworkStateChanged();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(sst.isImsRegistered(), true);
     }
 
     @Test
-    @SmallTest
     public void testIsDeviceShuttingDown() throws Exception {
         sst.requestShutdown();
         assertEquals(true, sst.isDeviceShuttingDown());
     }
 
     @Test
-    @SmallTest
     public void testShuttingDownRequest() throws Exception {
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.requestShutdown();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.getRadioState()
                 != TelephonyManager.RADIO_POWER_UNAVAILABLE);
     }
 
     @Test
-    @SmallTest
     public void testShuttingDownRequestWithRadioPowerFailResponse() throws Exception {
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Simulate RIL fails the radio power settings.
         mSimulatedCommands.setRadioPowerFailResponse(true);
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(mSimulatedCommands.getRadioState() == TelephonyManager.RADIO_POWER_ON);
         verify(mSatelliteController).onSetCellularRadioPowerStateRequested(eq(false));
         verify(mSatelliteController).onPowerOffCellularRadioFailed();
         sst.requestShutdown();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertFalse(mSimulatedCommands.getRadioState()
                 != TelephonyManager.RADIO_POWER_UNAVAILABLE);
     }
 
     @Test
-    @SmallTest
     public void testSetImsRegisteredStateRunsShutdownImmediately() throws Exception {
         doReturn(true).when(mPhone).isPhoneTypeGsm();
         sst.setImsRegistrationState(true);
         mSimulatedCommands.setRadioPowerFailResponse(false);
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         sst.requestShutdown();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sst.setImsRegistrationState(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_UNAVAILABLE, mSimulatedCommands.getRadioState());
     }
 
 
     @Test
-    @SmallTest
     public void testImsRegisteredNoDelayShutDown() throws Exception {
         doReturn(true).when(mPhone).isPhoneTypeGsm();
         // The radio power off delay time is 0, so there should should be no delay.
         sst.setImsRegistrationState(true);
         mSimulatedCommands.setRadioPowerFailResponse(false);
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Turn off the radio and ensure radio power is off
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_OFF, mSimulatedCommands.getRadioState());
     }
 
     @Test
-    @SmallTest
     public void testImsRegisteredAPMOnOffToggle() throws Exception {
         doReturn(true).when(mPhone).isPhoneTypeGsm();
         mContextFixture.putIntResource(
@@ -1856,32 +1826,29 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.setImsRegistrationState(true);
         mSimulatedCommands.setRadioPowerFailResponse(false);
         sst.setRadioPower(true);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Turn off the radio and ensure radio power is still on and then turn it back on again
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.setRadioPower(true);
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
 
         // Ensure the timeout was cancelled and we still see radio power is on.
         // Timeout for IMS reg + some extra time to remove race conditions
-        waitForDelayedHandlerAction(mSSTTestHandler.getThreadHandler(),
-                sst.getRadioPowerOffDelayTimeoutForImsRegistration() + 1000, 1000);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_ON, mSimulatedCommands.getRadioState());
     }
 
     @Test
-    @SmallTest
     public void testSetTimeFromNITZStr_withoutAge() throws Exception {
         {
             // Mock sending correct nitz str from RIL with a zero ageMs
             String nitzStr = "15/06/20,00:00:00+0";
             NitzData expectedNitzData = NitzData.parse(nitzStr);
             mSimulatedCommands.triggerNITZupdate(nitzStr);
-            waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+            processAllMessages();
 
             ArgumentCaptor<NitzSignal> argumentsCaptor =
                     ArgumentCaptor.forClass(NitzSignal.class);
@@ -1898,7 +1865,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testSetTimeFromNITZStr_withAge() throws Exception {
         {
             // Mock sending correct nitz str from RIL with a non-zero ageMs
@@ -1906,7 +1872,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
             long ageMs = 60 * 1000;
             NitzData expectedNitzData = NitzData.parse(nitzStr);
             mSimulatedCommands.triggerNITZupdate(nitzStr, ageMs);
-            waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+            processAllMessages();
 
             ArgumentCaptor<NitzSignal> argumentsCaptor =
                     ArgumentCaptor.forClass(NitzSignal.class);
@@ -1939,7 +1905,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(
                 NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                 state, voiceRat, 0, false,
@@ -1947,7 +1913,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     private void changeRegStateWithIwlan(int state, CellIdentity cid, int voiceRat, int dataRat,
@@ -1965,7 +1931,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // CS WWAN
         NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(
@@ -1974,7 +1940,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // PS WLAN
         NetworkRegistrationInfo dataIwlanResult = new NetworkRegistrationInfo(
@@ -1984,7 +1950,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_IWLAN_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataIwlanResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     @Test
@@ -1995,7 +1961,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, oldOpNamesResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(oldOpNamesResult[0], sst.getServiceState().getOperatorAlpha());
 
         // if the device is not registered, the modem returns an invalid operator
@@ -2003,7 +1969,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, badOpNamesResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(null, sst.getServiceState().getOperatorAlpha());
     }
 
@@ -2019,7 +1985,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, null,
                         new CommandException(CommandException.Error.RADIO_NOT_AVAILABLE))));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertEquals(ServiceState.STATE_IN_SERVICE, sst.getServiceState().getState());
         assertEquals(ServiceState.STATE_IN_SERVICE,
@@ -2031,7 +1997,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     public void testPollStateExceptionRadioPowerOff() {
         // Turn off radio first.
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_OFF, mSimulatedCommands.getRadioState());
         assertEquals(ServiceState.STATE_POWER_OFF, sst.getServiceState().getState());
         assertEquals(ServiceState.STATE_POWER_OFF,
@@ -2045,7 +2011,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, null,
                         new CommandException(CommandException.Error.RADIO_NOT_AVAILABLE))));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertEquals(ServiceState.STATE_POWER_OFF, sst.getServiceState().getVoiceRegState());
         assertEquals(ServiceState.STATE_POWER_OFF, sst.getServiceState().getDataRegState());
@@ -2056,7 +2022,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     public void testPollStateExceptionRadioPowerOffOnIwlan() {
         // Turn off radio first.
         sst.setRadioPower(false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(TelephonyManager.RADIO_POWER_OFF, mSimulatedCommands.getRadioState());
         assertEquals(ServiceState.STATE_POWER_OFF, sst.getServiceState().getState());
         assertEquals(ServiceState.STATE_POWER_OFF,
@@ -2072,7 +2038,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, null,
                         new CommandException(CommandException.Error.RADIO_NOT_AVAILABLE))));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertNull(null, sst.getServiceState().getOperatorAlpha());
         assertEquals(ServiceState.STATE_POWER_OFF, sst.getServiceState().getVoiceRegState());
@@ -2101,11 +2067,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(sst.mSS.isEmergencyOnly());
     }
 
@@ -2130,11 +2096,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertTrue(sst.mSS.isEmergencyOnly());
     }
 
@@ -2196,7 +2162,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         }
         sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_PHYSICAL_CHANNEL_CONFIG,
                 new AsyncResult(null, pc, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     private void sendPhyChanConfigChange(int[] bandwidths, int networkType, int pci) {
@@ -2221,11 +2187,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     private void sendRegStateUpdateForNrCellId(CellIdentityNr cellId) {
@@ -2246,11 +2212,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     private void sendRegStateUpdateForLteOnOos() throws Exception {
@@ -2270,11 +2236,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
     }
 
     @Test
@@ -2389,11 +2355,11 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(0, sst.mSS.getCellBandwidths().length);
     }
 
@@ -2413,7 +2379,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
      * new ServiceState when a poll event occurs. This causes ServiceState#getRilDataRadioTechnology
      * to change even though the underlying transports have not changed state.
      */
-    @SmallTest
     @Test
     public void testRilDataTechnologyChangeTransportPreference() {
         when(mAccessNetworksManager.isAnyApnOnIwlan()).thenReturn(false);
@@ -2458,7 +2423,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE,
                         LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
         CellIdentityLte cellIdentity =
-                new CellIdentityLte(1, 1, 5, 1, new int[] {1, 2}, 5000, "001", "01", "test",
+                new CellIdentityLte(1, 1, 5, 1, new int[] {1, 2}, 5000, HOME_MCC, HOME_MNC, "test",
                         "tst", Collections.emptyList(), null);
         if (!passCellId) {
             cellIdentity = null;
@@ -2467,8 +2432,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_OPERATOR,
                 new AsyncResult(sst.mPollingContext, opNamesResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
-
+        processAllMessages();
 
         // PS WWAN
         NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(
@@ -2479,7 +2443,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // PS WLAN
         int wlanRat = TelephonyManager.NETWORK_TYPE_UNKNOWN;
@@ -2494,10 +2458,9 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_IWLAN_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataIwlanResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(opNamesResult[0], sst.getServiceState().getOperatorAlpha());
         assertEquals(opNamesResult[2], sst.getServiceState().getOperatorNumeric());
-        verify(mLocaleTracker).updateOperatorNumeric(eq(opNamesResult[2]));
     }
 
     /**
@@ -2513,13 +2476,14 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         changeRegStateWithIwlanOperatorNumeric(NetworkRegistrationInfo.REGISTRATION_STATE_HOME,
                 TelephonyManager.NETWORK_TYPE_LTE,
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME, OpNamesResult, true);
-        verify(mLocaleTracker).updateOperatorNumeric(eq(OpNamesResult[2]));
+        verify(mLocaleTracker).updateOperatorNumeric(eq(HOME_MCC + HOME_MNC));
+        Mockito.clearInvocations(mLocaleTracker);
         changeRegStateWithIwlanOperatorNumeric(
                 NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING,
                 TelephonyManager.NETWORK_TYPE_LTE,
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME, OpNamesResult, true);
         /* cellId based mccmnc */
-        verify(mLocaleTracker).updateOperatorNumeric(eq("00101"));
+        verify(mLocaleTracker).updateOperatorNumeric(eq(HOME_MCC + HOME_MNC));
         changeRegStateWithIwlanOperatorNumeric(
                 NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING,
                 TelephonyManager.NETWORK_TYPE_LTE,
@@ -2544,7 +2508,9 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME,
                 TelephonyManager.NETWORK_TYPE_LTE,
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME, OpNamesResult, true);
-        verify(mLocaleTracker).updateOperatorNumeric(eq(OpNamesResult[2]));
+        verify(mLocaleTracker).updateOperatorNumeric(eq(HOME_MCC + HOME_MNC));
+
+        clearInvocations(mLocaleTracker);
 
         // Test with Cellular as NOT_REG
         changeRegStateWithIwlanOperatorNumeric(
@@ -2552,7 +2518,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 TelephonyManager.NETWORK_TYPE_UNKNOWN,
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME, OpNamesResult, true);
         /* cellId based mccmnc */
-        verify(mLocaleTracker).updateOperatorNumeric(eq("00101"));
+        verify(mLocaleTracker).updateOperatorNumeric(eq(HOME_MCC + HOME_MNC));
 
         // IMS over Iwlan is registered.
         doReturn(mImsPhone)
@@ -2632,7 +2598,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testOnLteVopsInfoChanged() {
         ServiceState ss = new ServiceState();
         ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
@@ -2664,7 +2629,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(ServiceState.STATE_IN_SERVICE, sst.getCurrentDataConnectionState());
         NetworkRegistrationInfo sSnetworkRegistrationInfo =
                 sst.mSS.getNetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS,
@@ -2684,7 +2649,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sSnetworkRegistrationInfo =
                 sst.mSS.getNetworkRegistrationInfo(2, 1);
@@ -2693,7 +2658,6 @@ public class ServiceStateTrackerTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void testOnNrVopsInfoChanged() {
         ServiceState ss = new ServiceState();
         ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
@@ -2726,7 +2690,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceResult, null)));
 
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertEquals(ServiceState.STATE_IN_SERVICE, sst.getCurrentDataConnectionState());
         NetworkRegistrationInfo sSnetworkRegistrationInfo =
                 sst.mSS.getNetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS,
@@ -2747,7 +2711,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataResult, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         sSnetworkRegistrationInfo =
                 sst.mSS.getNetworkRegistrationInfo(2, 1);
@@ -2773,7 +2737,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         assertTrue(sst.hasMessages(sst.EVENT_RESET_LAST_KNOWN_CELL_IDENTITY));
 
         sst.obtainMessage(sst.EVENT_RESET_LAST_KNOWN_CELL_IDENTITY, null).sendToTarget();
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
         assertNull(sst.getLastKnownCellIdentity());
     }
 
@@ -3299,7 +3263,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         when(mAccessNetworksManager.isAnyApnOnIwlan()).thenReturn(true);
         accessNetworksManagerCallback.onPreferredTransportChanged(0, false);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertTrue(sst.mSS.isIwlanPreferred());
     }
@@ -3336,13 +3300,13 @@ public class ServiceStateTrackerTest extends TelephonyTest {
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, voiceReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // Update data registered to satellite roaming PLMN
         sst.sendMessage(sst.obtainMessage(
                 ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION,
                 new AsyncResult(sst.mPollingContext, dataReg, null)));
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         assertTrue(sst.mSS.isUsingNonTerrestrialNetwork());
         List<NetworkRegistrationInfo> nriList =
@@ -3386,7 +3350,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         doReturn(true).when(mSatelliteController).isInConnectedState();
         callback.onSatelliteModemStateChanged(SatelliteManager.SATELLITE_MODEM_STATE_CONNECTED);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // update the spn
         sst.updateCarrierDisplayName();
@@ -3414,7 +3378,7 @@ public class ServiceStateTrackerTest extends TelephonyTest {
 
         callback.onSatelliteModemStateChanged(
                 SatelliteManager.SATELLITE_MODEM_STATE_DATAGRAM_TRANSFERRING);
-        waitForLastHandlerAction(mSSTTestHandler.getThreadHandler());
+        processAllMessages();
 
         // update the spn
         sst.updateCarrierDisplayName();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SignalStrengthControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/SignalStrengthControllerTest.java
index b59c4de0cf..6bd0e0bf03 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SignalStrengthControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SignalStrengthControllerTest.java
@@ -1513,6 +1513,70 @@ public class SignalStrengthControllerTest extends TelephonyTest {
         reset(mSimulatedCommandsVerifier);
     }
 
+    @Test
+    public void testLteSignalStrengthReportingCriteriaWhenApmOnOff() {
+        SignalStrength ss = new SignalStrength(
+                new CellSignalStrengthCdma(),
+                new CellSignalStrengthGsm(),
+                new CellSignalStrengthWcdma(),
+                new CellSignalStrengthTdscdma(),
+                new CellSignalStrengthLte(
+                        -110, /* rssi */
+                        -114, /* rsrp */
+                        -5, /* rsrq */
+                        0, /* rssnr */
+                        SignalStrength.INVALID, /* cqi */
+                        SignalStrength.INVALID /* ta */),
+                new CellSignalStrengthNr());
+
+        // RSRP NTN_LTE threshold set to Good and LTE threshold set to poor.
+        mBundle.putInt(CarrierConfigManager.KEY_PARAMETERS_USED_FOR_NTN_LTE_SIGNAL_BAR_INT,
+                CellSignalStrengthLte.USE_RSRP);
+        mBundle.putIntArray(CarrierConfigManager.KEY_NTN_LTE_RSRP_THRESHOLDS_INT_ARRAY,
+                new int[]{-125 /* SIGNAL_STRENGTH_POOR */, -120 /* SIGNAL_STRENGTH_MODERATE */,
+                        -115 /* SIGNAL_STRENGTH_GOOD */, -110/* SIGNAL_STRENGTH_GREAT */});
+        mBundle.putIntArray(CarrierConfigManager.KEY_LTE_RSRP_THRESHOLDS_INT_ARRAY,
+                new int[]{-114, /* SIGNAL_STRENGTH_POOR */ -110, /* SIGNAL_STRENGTH_MODERATE */
+                        -105, /* SIGNAL_STRENGTH_GOOD */ -100, /* SIGNAL_STRENGTH_GREAT */});
+        CarrierConfigManager mockConfigManager = Mockito.mock(CarrierConfigManager.class);
+        when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE))
+                .thenReturn(mockConfigManager);
+        when(mockConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
+
+        // NTN -> APM ON -> APM OFF -> NTN
+        // When NTN is connected, check the signal strength is GOOD
+        AsyncResult asyncResult = mock(AsyncResult.class);
+        asyncResult.result = mServiceState;
+        doReturn(true).when(mServiceState).isUsingNonTerrestrialNetwork();
+        mSsc.handleMessage(mSsc.obtainMessage(10/*EVENT_SERVICE_STATE_CHANGED*/, asyncResult));
+        processAllMessages();
+
+        mSimulatedCommands.setSignalStrength(ss);
+        mSimulatedCommands.notifySignalStrength();
+        processAllMessages();
+        assertEquals(CellSignalStrength.SIGNAL_STRENGTH_GOOD, mSsc.getSignalStrength().getLevel());
+
+        // APM ON -> APM OFF triggers EVENT_ON_DEVICE_IDLE_STATE_CHANGED
+        // Thresholds are updated to LTE, check the signal strength is poor.
+        doReturn(false).when(mServiceState).isUsingNonTerrestrialNetwork();
+        mSsc.onDeviceIdleStateChanged(false);
+        processAllMessages();
+        mSimulatedCommands.setSignalStrength(ss);
+        mSimulatedCommands.notifySignalStrength();
+        processAllMessages();
+        assertEquals(CellSignalStrength.SIGNAL_STRENGTH_POOR, mSsc.getSignalStrength().getLevel());
+
+        // Again When NTN is connected, thresholds are updated to NTN LTE
+        doReturn(true).when(mServiceState).isUsingNonTerrestrialNetwork();
+        mSsc.handleMessage(mSsc.obtainMessage(10/*EVENT_SERVICE_STATE_CHANGED*/, asyncResult));
+        processAllMessages();
+
+        mSimulatedCommands.setSignalStrength(ss);
+        mSimulatedCommands.notifySignalStrength();
+        processAllMessages();
+        assertEquals(CellSignalStrength.SIGNAL_STRENGTH_GOOD, mSsc.getSignalStrength().getLevel());
+    }
+
     private void verifyAllEmptyThresholdAreDisabledWhenSetSignalStrengthReportingCriteria(
             int expectedNonEmptyThreshold) {
         ArgumentCaptor<List<SignalThresholdInfo>> signalThresholdInfoCaptor =
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
index 39c0cacf8a..53f3f94330 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommands.java
@@ -2033,6 +2033,26 @@ public class SimulatedCommands extends BaseCommands
         resultSuccess(result, null);
     };
 
+    @Override
+    public void setUserDataEnabled(Message result, boolean enabled) {
+        SimulatedCommandsVerifier.getInstance().setUserDataEnabled(result, enabled);
+        resultSuccess(result, null);
+    }
+
+    @Override
+    public void setUserDataRoamingEnabled(Message result, boolean enabled) {
+        SimulatedCommandsVerifier.getInstance().setUserDataRoamingEnabled(result, enabled);
+        resultSuccess(result, null);
+    }
+
+    @Override
+    public void notifyImsDataNetwork(int accessNetwork, int dataNetworkState,
+            int physicalTransportType, int physicalNetworkSlotIndex, Message result) {
+        SimulatedCommandsVerifier.getInstance().notifyImsDataNetwork(accessNetwork,
+                dataNetworkState, physicalTransportType, physicalNetworkSlotIndex, result);
+        resultSuccess(result, null);
+    }
+
     public void setImsRegistrationState(int[] regState) {
         mImsRegState = regState;
     }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommandsVerifier.java b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommandsVerifier.java
index 6fc56169f3..b70681b479 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommandsVerifier.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SimulatedCommandsVerifier.java
@@ -1476,6 +1476,19 @@ public class SimulatedCommandsVerifier implements CommandsInterface {
     public void cancelHandover(Message result, int callId) {
     }
 
+    @Override
+    public void setUserDataEnabled(Message result, boolean enabled) {
+    }
+
+    @Override
+    public void setUserDataRoamingEnabled(Message result, boolean enabled) {
+    }
+
+    @Override
+    public void notifyImsDataNetwork(int accessNetwork, int dataNetworkState,
+            int physicalTransportType, int physicalNetworkSlotIndex, Message result) {
+    }
+
     /**
      * Register to listen for the changes in the primary IMEI with respect to the sim slot.
      */
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SmsControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/SmsControllerTest.java
index 0f4f3d5ab6..e7003f839d 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SmsControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SmsControllerTest.java
@@ -22,6 +22,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.doReturn;
@@ -33,6 +34,7 @@ import android.compat.testing.PlatformCompatChangeRule;
 import android.content.pm.PackageManager;
 import android.os.Binder;
 import android.os.Build;
+import android.os.Process;
 import android.telephony.TelephonyManager;
 import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
@@ -202,7 +204,7 @@ public class SmsControllerTest extends TelephonyTest {
         mSmsControllerUT.sendVisualVoicemailSmsForSubscriber(mCallingPackage, mCallingUserId,
                 null , subId, null, 0, null, null);
         verify(mIccSmsInterfaceManager).sendTextWithSelfPermissions(any(), eq(mCallingUserId),
-                any(), any(), any(), any(), any(), any(), eq(false), eq(true));
+                any(), any(), any(), any(), any(), any(), eq(false), eq(true), anyInt());
     }
 
     @Test
@@ -213,7 +215,7 @@ public class SmsControllerTest extends TelephonyTest {
                 null , 1, null, 0, null, null);
         verify(mIccSmsInterfaceManager, never()).sendTextWithSelfPermissions(any(),
                 eq(mCallingUserId), any(), any(), any(), any(), any(), any(),
-                eq(false), eq(true));
+                eq(false), eq(true), anyInt());
 
         doReturn(false).when(mPhone).isInEcm();
     }
@@ -228,8 +230,9 @@ public class SmsControllerTest extends TelephonyTest {
         mSmsControllerUT.sendTextForSubscriber(subId, mCallingPackage, null, "1234",
                 null, "text", null, null, false, 0L, true, true);
         verify(mIccSmsInterfaceManager, Mockito.times(1))
-                .sendText(mCallingPackage, mCallingUserId,
-                        "1234", null, "text", null, null, false, 0L, true);
+                .sendText(eq(mCallingPackage), eq(mCallingUserId),
+                        eq("1234"), isNull(), eq("text"), isNull(), isNull(), eq(false), eq(0L),
+                        eq(true), anyInt());
     }
 
     @Test
@@ -246,8 +249,9 @@ public class SmsControllerTest extends TelephonyTest {
         mSmsControllerUT.sendTextForSubscriber(subId, mCallingPackage, null, "1234",
                 null, "text", null, null, false, 0L, true, true);
         verify(mIccSmsInterfaceManager, Mockito.times(1))
-                .sendText(mCallingPackage, mCallingUserId,
-                        "1234", null, "text", null, null, false, 0L, true);
+                .sendText(eq(mCallingPackage), eq(mCallingUserId),
+                        eq("1234"), isNull(), eq("text"), isNull(), isNull(), eq(false), eq(0L),
+                        eq(true), anyInt());
     }
 
     @Test
@@ -264,7 +268,7 @@ public class SmsControllerTest extends TelephonyTest {
                 null, "text", null, null, false, 0L, true, true);
         verify(mIccSmsInterfaceManager, Mockito.times(0))
                 .sendText(mCallingPackage, mCallingUserId,
-                        "1234", null, "text", null, null, false, 0L, true);
+                        "1234", null, "text", null, null, false, 0L, true, Process.INVALID_UID);
     }
 
     @Test
@@ -328,7 +332,8 @@ public class SmsControllerTest extends TelephonyTest {
         mSmsControllerUT.sendTextForSubscriber(subId, mCallingPackage, null, "1234",
                 null, "text", null, null, false, 0L, true, true);
         verify(mIccSmsInterfaceManager, Mockito.times(1))
-                .sendText(mCallingPackage, mCallingUserId,
-                        "1234", null, "text", null, null, false, 0L, true);
+                .sendText(eq(mCallingPackage), eq(mCallingUserId),
+                        eq("1234"), isNull(), eq("text"), isNull(), isNull(), eq(false), eq(0L),
+                        eq(true), anyInt());
     }
 }
\ No newline at end of file
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SmsDispatchersControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/SmsDispatchersControllerTest.java
index 37362d5a17..1883ea4147 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SmsDispatchersControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SmsDispatchersControllerTest.java
@@ -24,21 +24,25 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.clearInvocations;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.app.PendingIntent;
@@ -47,12 +51,14 @@ import android.net.Uri;
 import android.os.AsyncResult;
 import android.os.Looper;
 import android.os.Message;
+import android.os.Process;
 import android.provider.Telephony.Sms.Intents;
 import android.telephony.DisconnectCause;
 import android.telephony.DomainSelectionService;
 import android.telephony.NetworkRegistrationInfo;
 import android.telephony.PhoneNumberUtils;
 import android.telephony.SmsManager;
+import android.telephony.ims.stub.ImsSmsImplBase;
 import android.test.FlakyTest;
 import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
@@ -60,7 +66,9 @@ import android.util.Singleton;
 
 import androidx.test.filters.SmallTest;
 
+import com.android.ims.FeatureConnector;
 import com.android.ims.ImsManager;
+import com.android.internal.telephony.GsmAlphabet.TextEncodingDetails;
 import com.android.internal.telephony.domainselection.DomainSelectionConnection;
 import com.android.internal.telephony.domainselection.EmergencySmsDomainSelectionConnection;
 import com.android.internal.telephony.domainselection.SmsDomainSelectionConnection;
@@ -99,31 +107,31 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         public void testSendData(String callingPackage, int callingUser,
                 String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent,
-                PendingIntent deliveryIntent, boolean isForVvm) {
+                PendingIntent deliveryIntent, boolean isForVvm, int uid) {
             sendData(callingPackage, callingUser, destAddr, scAddr,
-                    destPort, data, sentIntent, deliveryIntent, isForVvm);
+                    destPort, data, sentIntent, deliveryIntent, isForVvm, uid);
         }
 
         public void testSendMultipartText(String destAddr, String scAddr,
                 ArrayList<String> parts, ArrayList<PendingIntent> sentIntents,
                 ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg,
                 int callingUser, boolean persistMessage, int priority, boolean expectMore,
-                int validityPeriod, long messageId) {
+                int validityPeriod, long messageId, int uid) {
             sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, messageUri,
                     callingPkg, callingUser, persistMessage, priority, expectMore,
-                    validityPeriod, messageId);
+                    validityPeriod, messageId, uid);
         }
 
         public void testNotifySmsSentToEmergencyStateTracker(String destAddr, long messageId,
                 boolean isOverIms, boolean isLastSmsPart) {
             notifySmsSent(getSmsTracker(destAddr, messageId), isOverIms,
-                isLastSmsPart, true/*success*/);
+                    isLastSmsPart, true/*success*/);
         }
 
         public void testNotifySmsSentFailedToEmergencyStateTracker(String destAddr,
                 long messageId, boolean isOverIms) {
             notifySmsSent(getSmsTracker(destAddr, messageId), isOverIms,
-                true/*isLastSmsPart*/, false/*success*/);
+                    true/*isLastSmsPart*/, false/*success*/);
         }
 
         public void testNotifySmsReceivedViaImsToEmergencyStateTracker(String origAddr) {
@@ -138,17 +146,18 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
     /**
      * Inherits the SMSDispatcher to verify the abstract or protected methods.
      */
-    protected abstract static class TestSmsDispatcher extends SMSDispatcher {
-        public TestSmsDispatcher(Phone phone, SmsDispatchersController smsDispatchersController) {
-            super(phone, smsDispatchersController);
+    protected static class TestSmsDispatcher extends SMSDispatcher {
+        public TestSmsDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
+                @NonNull FeatureFlags featureFlags) {
+            super(phone, smsDispatchersController, featureFlags);
         }
 
         @Override
         public void sendData(String callingPackage, int callingUser, String destAddr,
                 String scAddr, int destPort, byte[] data, PendingIntent sentIntent,
-                PendingIntent deliveryIntent, boolean isForVvm, long uniqueMessageId) {
+                PendingIntent deliveryIntent, boolean isForVvm, long uniqueMessageId, int uid) {
             super.sendData(callingPackage, callingUser, destAddr, scAddr, destPort,
-                    data, sentIntent, deliveryIntent, isForVvm, uniqueMessageId);
+                    data, sentIntent, deliveryIntent, isForVvm, uniqueMessageId, uid);
         }
 
         @Override
@@ -159,6 +168,45 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         public String getFormat() {
             return SmsConstants.FORMAT_3GPP;
         }
+
+        @Override
+        protected boolean shouldBlockSmsForEcbm() {
+            return false;
+        }
+
+        @Override
+        protected SmsMessageBase.SubmitPduBase getSubmitPdu(String scAdd, String destAdd,
+                String message, boolean statusReportRequested, SmsHeader smsHeader,
+                int priority,
+                int validityPeriod) {
+            return null;
+        }
+
+        @Override
+        protected SmsMessageBase.SubmitPduBase getSubmitPdu(String scAdd, String destAdd,
+                int destPort, byte[] message, boolean statusReportRequested) {
+            return null;
+        }
+
+        @Override
+        protected SmsMessageBase.SubmitPduBase getSubmitPdu(String scAdd, String destAdd,
+                String message, boolean statusReportRequested, SmsHeader smsHeader,
+                int priority,
+                int validityPeriod, int messageRef) {
+            return null;
+        }
+
+        @Override
+        protected SmsMessageBase.SubmitPduBase getSubmitPdu(String scAdd, String destAdd,
+                int destPort, byte[] message, boolean statusReportRequested, int messageRef) {
+            return null;
+        }
+
+        @Override
+        protected TextEncodingDetails calculateLength(CharSequence messageBody,
+                boolean use7bitOnly) {
+            return null;
+        }
     }
 
     /**
@@ -166,16 +214,16 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
      */
     protected static class TestImsSmsDispatcher extends ImsSmsDispatcher {
         public TestImsSmsDispatcher(Phone phone, SmsDispatchersController smsDispatchersController,
-                FeatureConnectorFactory factory) {
-            super(phone, smsDispatchersController, factory);
+                FeatureConnectorFactory factory, @NonNull FeatureFlags featureFlags) {
+            super(phone, smsDispatchersController, factory, featureFlags);
         }
 
         @Override
         public void sendData(String callingPackage, int callingUser, String destAddr, String scAddr,
                 int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent,
-                boolean isForVvm, long uniqueMessageId) {
+                boolean isForVvm, long uniqueMessageId, int uid) {
             super.sendData(callingPackage, callingUser, destAddr, scAddr, destPort,
-                    data, sentIntent, deliveryIntent, isForVvm, uniqueMessageId);
+                    data, sentIntent, deliveryIntent, isForVvm, uniqueMessageId, uid);
         }
 
         @Override
@@ -214,7 +262,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                 mMockDatagramDispatcher);
         setupMockPackagePermissionChecks();
         mSmsDispatchersController = new TestSmsDispatchersController(mPhone, mSmsStorageMonitor,
-            mSmsUsageMonitor, mTestableLooper.getLooper(), mFeatureFlags);
+                mSmsUsageMonitor, mTestableLooper.getLooper(), mFeatureFlags);
         mCallingUserId = mContext.getUserId();
         processAllMessages();
     }
@@ -233,7 +281,9 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         super.tearDown();
     }
 
-    @Test @SmallTest @FlakyTest
+    @Test
+    @SmallTest
+    @FlakyTest
     public void testSmsHandleStateUpdate() throws Exception {
         assertEquals(SmsConstants.FORMAT_UNKNOWN, mSmsDispatchersController.getImsSmsFormat());
         //Mock ImsNetWorkStateChange with GSM phone type
@@ -242,7 +292,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         assertTrue(mSmsDispatchersController.isIms());
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testReportSmsMemoryStatus() throws Exception {
         int eventReportMemoryStatusDone = 3;
         SmsStorageMonitor smsStorageMonnitor = new SmsStorageMonitor(mPhone, mFeatureFlags);
@@ -255,7 +306,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         assertNull(ar.exception);
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testReportSmsMemoryStatusFailure() throws Exception {
         int eventReportMemoryStatusDone = 3;
         SmsStorageMonitor smsStorageMonnitor = new SmsStorageMonitor(mPhone, mFeatureFlags);
@@ -266,37 +318,177 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         assertNotNull(ar.exception);
     }
 
-    @Test @SmallTest @FlakyTest
+    @Test
+    @SmallTest
+    @FlakyTest
     public void testSendImsGmsTest() throws Exception {
         switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
         mSmsDispatchersController.sendText("111"/* desAddr*/, "222" /*scAddr*/, TAG,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
         verify(mSimulatedCommandsVerifier).sendImsGsmSms(eq("038122F2"),
-                eq("0100038111F100001CD3F69C989EC3C3F431BA2C9F0FDF6EBAFCCD6697E5D4F29C0E"), eq(0), eq(0),
+                eq("0100038111F100001CD3F69C989EC3C3F431BA2C9F0FDF6EBAFCCD6697E5D4F29C0E"), eq(0),
+                eq(0),
                 any(Message.class));
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
+    public void testSendTextMessageRefSequence() throws Exception {
+        setUpSpySmsDispatchers();
+        doReturn(true).when(mImsSmsDispatcher).isMessageRefIncrementViaTelephony();
+        doReturn(true).when(mGsmSmsDispatcher).isMessageRefIncrementViaTelephony();
+        int messageRef = mSmsDispatchersController.getMessageReference();
+
+        doReturn(true).when(mImsSmsDispatcher).isAvailable();
+        mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+        assertEquals(messageRef + 1, mSmsDispatchersController.getMessageReference());
+        verify(mImsSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
+                any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
+        // PS->PS
+        mSmsDispatchersController.sendText("1112", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+        assertEquals(messageRef + 2, mSmsDispatchersController.getMessageReference());
+        verify(mImsSmsDispatcher).sendText(eq("1112"), eq("2222"), eq("text"), eq(mSentIntent),
+                any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
+        // PS->CS
+        doReturn(false).when(mImsSmsDispatcher).isAvailable();
+        mSmsDispatchersController.sendText("1113", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+        assertEquals(messageRef + 3, mSmsDispatchersController.getMessageReference());
+        verify(mGsmSmsDispatcher).sendText(eq("1113"), eq("2222"), eq("text"), eq(mSentIntent),
+                any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
+        // CS->CS
+        mSmsDispatchersController.sendText("1114", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+        assertEquals(messageRef + 4, mSmsDispatchersController.getMessageReference());
+        verify(mGsmSmsDispatcher).sendText(eq("1114"), eq("2222"), eq("text"), eq(mSentIntent),
+                any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
+        // CS->PS
+        doReturn(true).when(mImsSmsDispatcher).isAvailable();
+        mSmsDispatchersController.sendText("1115", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+        assertEquals(messageRef + 5, mSmsDispatchersController.getMessageReference());
+        verify(mImsSmsDispatcher).sendText(eq("1115"), eq("2222"), eq("text"), eq(mSentIntent),
+                any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
+    }
+
+    @Test
+    @SmallTest
+    public void testMessageReferenceIncrementDuringFallback() throws Exception {
+        setUpSpySmsDispatchers();
+        doReturn(true).when(mImsSmsDispatcher).isAvailable();
+        doReturn(true).when(mImsSmsDispatcher).isMessageRefIncrementViaTelephony();
+        doReturn(true).when(mGsmSmsDispatcher).isMessageRefIncrementViaTelephony();
+        int messageRef = mSmsDispatchersController.getMessageReference();
+
+        doAnswer(invocation -> {
+            mTracker = (SMSDispatcher.SmsTracker) invocation.getArgument(0);
+            int token = mImsSmsDispatcher.mNextToken.get();
+            mImsSmsDispatcher.mTrackers.put(token, mTracker);
+            // Verify TP-MR increment only by 1
+            assertEquals(messageRef + 1, mSmsDispatchersController.getMessageReference());
+            // Limit retries to 1
+            if (mTracker.mRetryCount < 1) {
+                doReturn(false).when(mImsSmsDispatcher).isAvailable();
+                mImsSmsDispatcher.getSmsListener().onSendSmsResult(token, 0,
+                        ImsSmsImplBase.SEND_STATUS_ERROR_FALLBACK, 0, SmsResponse.NO_ERROR_CODE);
+            }
+            return 0;
+        }).when(mImsSmsDispatcher).sendSms(any(SMSDispatcher.SmsTracker.class));
+
+        // Send SMS
+        mSmsDispatchersController.sendText("1113", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+
+        ArgumentCaptor<SMSDispatcher.SmsTracker> captor =
+                ArgumentCaptor.forClass(SMSDispatcher.SmsTracker.class);
+        verify(mImsSmsDispatcher).sendSms(captor.capture());
+        mTracker = captor.getValue();
+
+        verify(mGsmSmsDispatcher).sendSms(eq(mTracker));
+        // Verify TP-MR value is same as that was over IMS
+        assertEquals(messageRef + 1, mSmsDispatchersController.getMessageReference());
+    }
+
+    @Test
+    @SmallTest
+    public void testMessageReferenceIncrementDuringImsRetry() throws Exception {
+        setUpSpySmsDispatchers();
+        doReturn(true).when(mImsSmsDispatcher).isAvailable();
+        doReturn(true).when(mImsSmsDispatcher).isMessageRefIncrementViaTelephony();
+        doReturn(true).when(mGsmSmsDispatcher).isMessageRefIncrementViaTelephony();
+        int messageRef = mSmsDispatchersController.getMessageReference();
+
+        doAnswer(invocation -> {
+            mTracker = (SMSDispatcher.SmsTracker) invocation.getArgument(0);
+            int token = mImsSmsDispatcher.mNextToken.get();
+            mImsSmsDispatcher.mTrackers.put(token, mTracker);
+            // Verify TP-MR increment by 1 only
+            assertEquals(messageRef + 1, mSmsDispatchersController.getMessageReference());
+
+            // Limit retries to 1
+            if (mTracker.mRetryCount < 1) {
+                mImsSmsDispatcher.getSmsListener().onSendSmsResult(token, 0,
+                        ImsSmsImplBase.SEND_STATUS_ERROR_FALLBACK, 0, SmsResponse.NO_ERROR_CODE);
+            }
+            return 0;
+        }).when(mImsSmsDispatcher).sendSms(any(SMSDispatcher.SmsTracker.class));
+
+        // Send SMS
+        mSmsDispatchersController.sendText("1113", "2222", "text", mSentIntent, null, null,
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
+
+        // Verify SMS is sent over IMS twice
+        verify(mImsSmsDispatcher, times(2)).sendSms(any(SMSDispatcher.SmsTracker.class));
+        verify(mGsmSmsDispatcher, times(0)).sendSms(any(SMSDispatcher.SmsTracker.class));
+    }
+
+    @Test
+    @SmallTest
     public void testSendImsGmsTestWithOutDesAddr() throws Exception {
         switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
         mSmsDispatchersController.sendText(null, "222" /*scAddr*/, TAG,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
         verify(mSimulatedCommandsVerifier, times(0)).sendImsGsmSms(anyString(), anyString(),
                 anyInt(), anyInt(), any(Message.class));
     }
 
-    @Test @SmallTest @FlakyTest /* flakes 0.85% of the time on gce, 0.43% on marlin */
+    @Test
+    @SmallTest
+    @FlakyTest /* flakes 0.85% of the time on gce, 0.43% on marlin */
     public void testSendRetrySmsGsmTest() throws Exception {
         // newFormat will be based on voice technology will be GSM if phone type is not CDMA
         switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
         replaceInstance(SMSDispatcher.SmsTracker.class, "mFormat", mTracker,
                 SmsConstants.FORMAT_3GPP);
         mSmsDispatchersController.sendRetrySms(mTracker);
-        verify(mSimulatedCommandsVerifier).sendImsGsmSms((String)isNull(), (String)isNull(), eq(0),
+        verify(mSimulatedCommandsVerifier).sendImsGsmSms((String) isNull(), (String) isNull(),
+                eq(0),
                 eq(0), any(Message.class));
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testSendRetrySmsNullPdu() throws Exception {
         HashMap<String, Object> map = new HashMap<>();
         map.put("scAddr", "");
@@ -312,7 +504,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                 eq(NO_ERROR_CODE));
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testInjectNullSmsPdu() throws Exception {
         // unmock ActivityManager to be able to register receiver, create real PendingIntent and
         // receive TEST_INTENT
@@ -323,14 +516,15 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         mSmsDispatchersController.injectSmsPdu(null, SmsConstants.FORMAT_3GPP, true,
                 (SmsDispatchersController.SmsInjectionCallback) result -> {
                     mInjectionCallbackTriggered = true;
-                   assertEquals(Intents.RESULT_SMS_GENERIC_ERROR, result);
+                    assertEquals(Intents.RESULT_SMS_GENERIC_ERROR, result);
                 }
         );
         processAllMessages();
         assertEquals(true, mInjectionCallbackTriggered);
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testSendImsGmsTestWithSmsc() {
         IccSmsInterfaceManager iccSmsInterfaceManager = Mockito.mock(IccSmsInterfaceManager.class);
         when(mPhone.getIccSmsInterfaceManager()).thenReturn(iccSmsInterfaceManager);
@@ -341,7 +535,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         mSmsDispatchersController.sendText("111", null /*scAddr*/, TAG,
                 null, null, null, "com.android.messaging",
                 mContext.getUserId(), false, -1, false,
-                -1, false, 0L);
+                -1, false, 0L, Process.INVALID_UID);
         byte[] smscbyte = PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength(
                 "222");
         String smsc = IccUtils.bytesToHexString(smscbyte);
@@ -416,7 +610,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpEmergencyStateTracker(DisconnectCause.NOT_DISCONNECTED);
 
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -434,7 +629,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(mEmergencySmsDsc).finishSelection();
         verify(mImsSmsDispatcher).sendText(eq("911"), eq("2222"), eq("text"), eq(mSentIntent),
                 any(), any(), eq("test-app"), eq(mCallingUserId), eq(false),
-                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
         assertEquals(0, holder.getPendingRequests().size());
@@ -448,7 +644,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpEmergencyStateTracker(DisconnectCause.OUT_OF_SERVICE);
 
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         // Verify the domain selection requested regardless of the result of EmergencyStateTracker.
@@ -466,7 +663,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         ArrayList<PendingIntent> sentIntents = new ArrayList<>();
         ArrayList<PendingIntent> deliveryIntents = new ArrayList<>();
         mSmsDispatchersController.testSendMultipartText("911", "2222", parts, sentIntents,
-                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L);
+                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -485,7 +683,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(mImsSmsDispatcher).sendMultipartText(eq("911"), eq("2222"), eq(parts),
                 eq(sentIntents), eq(deliveryIntents), any(), eq("test-app"),
                 eq(mCallingUserId), eq(false), eq(0), eq(false),
-                eq(10), eq(1L), anyLong());
+                eq(10), eq(1L), anyLong(), eq(Process.INVALID_UID));
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
         assertEquals(0, holder.getPendingRequests().size());
@@ -658,7 +856,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         when(mImsSmsDispatcher.isAvailable()).thenReturn(true);
 
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -684,7 +883,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         verify(mImsSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
                 any(), any(), eq("test-app"), eq(mCallingUserId),
-                eq(false), eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(false), eq(0), eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
     }
 
     @Test
@@ -699,7 +899,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
                 "test-app", mCallingUserId, false, 0, false,
-                10, false, 1L, false);
+                10, false, 1L, false, Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -725,7 +925,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         verify(mImsSmsDispatcher).sendText(eq("911"), eq("2222"), eq("text"), eq(mSentIntent),
                 any(), any(), eq("test-app"), eq(0), eq(false), eq(0), eq(false), eq(10),
-                eq(false), eq(1L), eq(false), anyLong());
+                eq(false), eq(1L), eq(false), anyLong(), eq(Process.INVALID_UID));
     }
 
     @Test
@@ -735,7 +935,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpSmsDispatchers();
 
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -746,7 +947,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         assertEquals(1, holder.getPendingRequests().size());
 
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         verify(mSmsDsc).requestDomainSelection(any(), any());
@@ -761,30 +963,12 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(mImsSmsDispatcher, times(2)).sendText(eq("1111"), eq("2222"),
                 eq("text"), eq(mSentIntent), any(), any(), eq("test-app"), eq(mCallingUserId),
                 eq(false), eq(0), eq(false), eq(10), eq(false), eq(1L),
-                eq(false), anyLong());
+                eq(false), anyLong(), eq(Process.INVALID_UID));
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
         assertEquals(0, holder.getPendingRequests().size());
     }
 
-    @Test
-    @SmallTest
-    public void testSendTextWhenFeatureFlagDisabledForSmsDomainSelection() throws Exception {
-        setUpDomainSelectionConnection();
-        setUpSmsDispatchers();
-        when(mFeatureFlags.smsDomainSelectionEnabled()).thenReturn(false);
-        when(mImsSmsDispatcher.isAvailable()).thenReturn(true);
-
-        mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
-
-        // Expect that the domain selection is not executed and
-        // ImsSmsDispatcher handles this text directly.
-        verify(mImsSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"),
-                eq(mSentIntent), any(), any(), eq("test-app"), eq(mCallingUserId), eq(false), eq(0),
-                eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong());
-    }
-
     @Test
     @SmallTest
     public void testSendTextWhenDomainSelectionFinishedAndNewTextSent() throws Exception {
@@ -792,7 +976,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpSmsDispatchers();
 
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -830,7 +1015,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         // Expect that new domain selection connection is created and domain selection is performed.
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         verify(mSmsDsc).finishSelection();
@@ -846,7 +1032,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(newSmsDsc).finishSelection();
         verify(mImsSmsDispatcher, times(2)).sendText(eq("1111"), eq("2222"), eq("text"),
                 eq(mSentIntent), any(), any(), eq("test-app"), eq(mCallingUserId), eq(false), eq(0),
-                eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
         assertEquals(0, holder.getPendingRequests().size());
@@ -861,7 +1048,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpEmergencyStateTracker(DisconnectCause.NOT_DISCONNECTED);
 
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -901,7 +1089,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         // Expect that new domain selection connection is created and domain selection is performed.
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         verify(mEmergencySmsDsc).finishSelection();
@@ -917,7 +1106,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(newEmergencySmsDsc).finishSelection();
         verify(mImsSmsDispatcher, times(2)).sendText(eq("911"), eq("2222"), eq("text"),
                 eq(mSentIntent), any(), any(), eq("test-app"), eq(0), eq(false), eq(0), eq(false),
-                eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
         assertEquals(0, holder.getPendingRequests().size());
@@ -941,14 +1131,14 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                         return true;
                     }
                 });
-        when(mFeatureFlags.smsDomainSelectionEnabled()).thenReturn(true);
         setUpSmsDispatchers();
         when(mImsSmsDispatcher.isAvailable()).thenReturn(true);
 
         // Expect that creating a domain selection connection is failed and
         // fallback to the legacy implementation.
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -960,7 +1150,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         verify(mImsSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
                 any(), any(), eq("test-app"), eq(mCallingUserId), eq(false), eq(0),
-                eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(false), eq(10), eq(false), eq(1L), eq(false), anyLong(),
+                eq(Process.INVALID_UID));
     }
 
     @Test
@@ -982,7 +1173,6 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                         return true;
                     }
                 });
-        when(mFeatureFlags.smsDomainSelectionEnabled()).thenReturn(true);
         setUpSmsDispatchers();
         setUpEmergencyStateTracker(DisconnectCause.NOT_DISCONNECTED);
         when(mImsSmsDispatcher.isAvailable()).thenReturn(true);
@@ -990,7 +1180,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         // Expect that creating a domain selection connection is failed and
         // fallback to the legacy implementation.
         mSmsDispatchersController.sendText("911", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -1003,7 +1194,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
 
         verify(mImsSmsDispatcher).sendText(eq("911"), eq("2222"), eq("text"), eq(mSentIntent),
                 any(), any(), eq("test-app"), eq(mCallingUserId), eq(false), eq(0), eq(false),
-                eq(10), eq(false), eq(1L), eq(false), anyLong());
+                eq(10), eq(false), eq(1L), eq(false), anyLong(), eq(Process.INVALID_UID));
     }
 
     private void switchImsSmsFormat(int phoneType) {
@@ -1025,7 +1216,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         when(mSatelliteController.shouldSendSmsToDatagramDispatcher(any(Phone.class)))
                 .thenReturn(true);
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
         verify(mMockDatagramDispatcher).sendSms(any());
 
@@ -1034,7 +1226,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         ArrayList<PendingIntent> sentIntents = new ArrayList<>();
         ArrayList<PendingIntent> deliveryIntents = new ArrayList<>();
         mSmsDispatchersController.testSendMultipartText("1111", "2222", parts, sentIntents,
-                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L);
+                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L,
+                Process.INVALID_UID);
         processAllMessages();
         verify(mMockDatagramDispatcher).sendSms(any());
     }
@@ -1073,10 +1266,9 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                         return true;
                     }
                 });
-        when(mFeatureFlags.smsDomainSelectionEnabled()).thenReturn(enabled);
     }
 
-    private void setUpDomainSelectionConnection()  {
+    private void setUpDomainSelectionConnection() {
         mEmergencySmsDsc = Mockito.mock(EmergencySmsDomainSelectionConnection.class);
         mSmsDsc = Mockito.mock(SmsDomainSelectionConnection.class);
         mSmsDispatchersController.setDomainSelectionResolverProxy(
@@ -1094,7 +1286,6 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                         return true;
                     }
                 });
-        when(mFeatureFlags.smsDomainSelectionEnabled()).thenReturn(true);
 
         mDscFuture = new CompletableFuture<>();
         when(mSmsDsc.requestDomainSelection(
@@ -1126,6 +1317,30 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                         | PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT);
     }
 
+    private void setUpSpySmsDispatchers() throws Exception {
+        ImsSmsDispatcher.FeatureConnectorFactory mConnectorFactory = mock(
+                ImsSmsDispatcher.FeatureConnectorFactory.class);
+        FeatureConnector mMockConnector = mock(FeatureConnector.class);
+        when(mConnectorFactory.create(any(), anyInt(), anyString(), any(), any())).thenReturn(
+                mMockConnector);
+        mImsSmsDispatcher =
+                spy(new TestImsSmsDispatcher(mPhone, mSmsDispatchersController, mConnectorFactory,
+                        mFeatureFlags));
+
+        mGsmSmsDispatcher = spy(
+                new TestSmsDispatcher(mPhone, mSmsDispatchersController, mFeatureFlags));
+
+        mCdmaSmsDispatcher = Mockito.mock(TestSmsDispatcher.class);
+        when(mCdmaSmsDispatcher.getFormat()).thenReturn(SmsConstants.FORMAT_3GPP2);
+
+        replaceInstance(SmsDispatchersController.class, "mImsSmsDispatcher",
+                mSmsDispatchersController, mImsSmsDispatcher);
+        replaceInstance(SmsDispatchersController.class, "mGsmDispatcher",
+                mSmsDispatchersController, mGsmSmsDispatcher);
+        replaceInstance(SmsDispatchersController.class, "mCdmaDispatcher",
+                mSmsDispatchersController, mCdmaSmsDispatcher);
+    }
+
     private void setUpEmergencyStateTracker(int result) throws Exception {
         mEmergencySmsFuture = new CompletableFuture<Integer>();
         mEmergencyStateTracker = Mockito.mock(EmergencyStateTracker.class);
@@ -1144,9 +1359,10 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpDomainSelectionConnection();
         setUpSmsDispatchers();
 
-        byte[] data = new byte[] { 0x01 };
+        byte[] data = new byte[]{0x01};
         mSmsDispatchersController.testSendData(
-                "test-app", mCallingUserId, "1111", "2222", 8080, data, mSentIntent, null, false);
+                "test-app", mCallingUserId, "1111", "2222", 8080, data, mSentIntent, null, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -1163,13 +1379,16 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         verify(mSmsDsc).finishSelection();
         if (domain == NetworkRegistrationInfo.DOMAIN_PS) {
             verify(mImsSmsDispatcher).sendData(eq("test-app"), eq(0), eq("1111"), eq("2222"),
-                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong());
+                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong(),
+                    eq(Process.INVALID_UID));
         } else if (isCdmaMo) {
             verify(mCdmaSmsDispatcher).sendData(eq("test-app"), eq(0), eq("1111"), eq("2222"),
-                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong());
+                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong(),
+                    eq(Process.INVALID_UID));
         } else {
             verify(mGsmSmsDispatcher).sendData(eq("test-app"), eq(0), eq("1111"), eq("2222"),
-                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong());
+                    eq(8080), eq(data), eq(mSentIntent), any(), eq(false), anyLong(),
+                    eq(Process.INVALID_UID));
         }
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
@@ -1182,7 +1401,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         setUpSmsDispatchers();
 
         mSmsDispatchersController.sendText("1111", "2222", "text", mSentIntent, null, null,
-                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false);
+                "test-app", mCallingUserId, false, 0, false, 10, false, 1L, false,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -1200,15 +1420,15 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         if (domain == NetworkRegistrationInfo.DOMAIN_PS) {
             verify(mImsSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
                     any(), any(), eq("test-app"), eq(0), eq(false), eq(0), eq(false), eq(10),
-                    eq(false), eq(1L), eq(false), anyLong());
+                    eq(false), eq(1L), eq(false), anyLong(), eq(Process.INVALID_UID));
         } else if (isCdmaMo) {
             verify(mCdmaSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
                     any(), any(), eq("test-app"), eq(0), eq(false), eq(0), eq(false), eq(10),
-                    eq(false), eq(1L), eq(false), anyLong());
+                    eq(false), eq(1L), eq(false), anyLong(), eq(Process.INVALID_UID));
         } else {
             verify(mGsmSmsDispatcher).sendText(eq("1111"), eq("2222"), eq("text"), eq(mSentIntent),
                     any(), any(), eq("test-app"), eq(0), eq(false), eq(0), eq(false), eq(10),
-                    eq(false), eq(1L), eq(false), anyLong());
+                    eq(false), eq(1L), eq(false), anyLong(), eq(Process.INVALID_UID));
         }
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
@@ -1224,7 +1444,8 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         ArrayList<PendingIntent> sentIntents = new ArrayList<>();
         ArrayList<PendingIntent> deliveryIntents = new ArrayList<>();
         mSmsDispatchersController.testSendMultipartText("1111", "2222", parts, sentIntents,
-                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L);
+                deliveryIntents, null, "test-app", mCallingUserId, false, 0, false, 10, 1L,
+                Process.INVALID_UID);
         processAllMessages();
 
         SmsDispatchersController.DomainSelectionConnectionHolder holder =
@@ -1242,16 +1463,18 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
         if (domain == NetworkRegistrationInfo.DOMAIN_PS) {
             verify(mImsSmsDispatcher).sendMultipartText(eq("1111"), eq("2222"), eq(parts),
                     eq(sentIntents), eq(deliveryIntents), any(), eq("test-app"), eq(mCallingUserId),
-                    eq(false), eq(0), eq(false), eq(10), eq(1L), anyLong());
+                    eq(false), eq(0), eq(false), eq(10), eq(1L), anyLong(),
+                    eq(Process.INVALID_UID));
         } else if (isCdmaMo) {
             verify(mCdmaSmsDispatcher).sendMultipartText(eq("1111"), eq("2222"), eq(parts),
                     eq(sentIntents), eq(deliveryIntents), any(), eq("test-app"), eq(mCallingUserId),
                     eq(false), eq(0),
-                    eq(false), eq(10), eq(1L), anyLong());
+                    eq(false), eq(10), eq(1L), anyLong(), eq(Process.INVALID_UID));
         } else {
             verify(mGsmSmsDispatcher).sendMultipartText(eq("1111"), eq("2222"), eq(parts),
                     eq(sentIntents), eq(deliveryIntents), any(), eq("test-app"), eq(mCallingUserId),
-                    eq(false), eq(0), eq(false), eq(10), eq(1L), anyLong());
+                    eq(false), eq(0), eq(false), eq(10), eq(1L), anyLong(),
+                    eq(Process.INVALID_UID));
         }
         assertNull(holder.getConnection());
         assertFalse(holder.isDomainSelectionRequested());
@@ -1328,6 +1551,7 @@ public class SmsDispatchersControllerTest extends TelephonyTest {
                 SmsDispatchersController.PendingRequest.TYPE_TEXT, null, "test-app",
                 mCallingUserId, "1111", "2222", asArrayList(mSentIntent), asArrayList(null),
                 false, null, 0, asArrayList("text"), null,
-                false, 0, false, 10, 100L, false, false);
+                false, 0, false, 10, 100L, false, false,
+                Process.INVALID_UID);
     }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SmsStorageMonitorTest.java b/tests/telephonytests/src/com/android/internal/telephony/SmsStorageMonitorTest.java
index bdf7e7878b..0feeafcf14 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SmsStorageMonitorTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SmsStorageMonitorTest.java
@@ -173,8 +173,12 @@ public class SmsStorageMonitorTest extends TelephonyTest {
                 new Intent(Intent.ACTION_DEVICE_STORAGE_NOT_FULL));
         processAllMessages();
 
+        // Report memory available to IMS
         verify(mIccSmsInterfaceManager.mDispatchersController)
                 .reportSmsMemoryStatus(any(Message.class));
+
+        // Report memory available to Modem
+        verify(mSimulatedCommandsVerifier).reportSmsMemoryStatus(eq(true), any(Message.class));
     }
 
     @Test @SmallTest
diff --git a/tests/telephonytests/src/com/android/internal/telephony/TelephonyCountryDetectorTest.java b/tests/telephonytests/src/com/android/internal/telephony/TelephonyCountryDetectorTest.java
index 31c995b468..caaf3adcfe 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/TelephonyCountryDetectorTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/TelephonyCountryDetectorTest.java
@@ -102,6 +102,7 @@ public class TelephonyCountryDetectorTest extends TelephonyTest {
         mTestableLooper = new TestableLooper(mLooper);
 
         mLocaleTrackers = new LocaleTracker[]{mMockLocaleTracker, mMockLocaleTracker2};
+        replaceInstance(PhoneFactory.class, "sMadeDefaults", null, true);
         replaceInstance(PhoneFactory.class, "sPhones", null, new Phone[] {mPhone, mPhone2});
         when(mPhone.getServiceStateTracker()).thenReturn(mSST);
         when(mPhone.getPhoneId()).thenReturn(0);
@@ -196,6 +197,12 @@ public class TelephonyCountryDetectorTest extends TelephonyTest {
         assertTrue(mCountryDetectorUT.getCurrentNetworkCountryIso().contains("CA"));
     }
 
+    @Test
+    public void testGetCurrentNetworkCountryIso_DefaultPhoneNotCreated() throws Exception {
+        replaceInstance(PhoneFactory.class, "sMadeDefaults", null, false);
+        assertTrue(mCountryDetectorUT.getCurrentNetworkCountryIso().isEmpty());
+    }
+
     @Test
     public void testCachedNetworkCountryCodeUpdate() {
         assertTrue(mCountryDetectorUT.getCachedNetworkCountryIsoInfo().isEmpty());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/TelephonyRegistryTest.java b/tests/telephonytests/src/com/android/internal/telephony/TelephonyRegistryTest.java
index 4e00a711c2..a8e0cd559c 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/TelephonyRegistryTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/TelephonyRegistryTest.java
@@ -125,6 +125,7 @@ public class TelephonyRegistryTest extends TelephonyTest {
     private int mSrvccState = -1;
     private ServiceState mServiceState = null;
     private int mRadioPowerState = RADIO_POWER_UNAVAILABLE;
+    private boolean mCarrierNetworkChange = false;
     private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
     private int mNetworkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
     private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
@@ -206,28 +207,29 @@ public class TelephonyRegistryTest extends TelephonyTest {
                 TelephonyCallback.EVENT_OUTGOING_EMERGENCY_SMS);
     }
 
-    public class TelephonyCallbackWrapper extends TelephonyCallback implements
-            TelephonyCallback.SrvccStateListener,
-            TelephonyCallback.PhoneCapabilityListener,
-            TelephonyCallback.ActiveDataSubscriptionIdListener,
-            TelephonyCallback.RadioPowerStateListener,
-            TelephonyCallback.PreciseDataConnectionStateListener,
-            TelephonyCallback.DataConnectionStateListener,
-            TelephonyCallback.DisplayInfoListener,
-            TelephonyCallback.LinkCapacityEstimateChangedListener,
-            TelephonyCallback.PhysicalChannelConfigListener,
-            TelephonyCallback.CellLocationListener,
-            TelephonyCallback.ServiceStateListener,
-            TelephonyCallback.CellInfoListener,
-            TelephonyCallback.BarringInfoListener,
-            TelephonyCallback.RegistrationFailedListener,
-            TelephonyCallback.DataActivityListener,
-            TelephonyCallback.SimultaneousCellularCallingSupportListener,
-            TelephonyCallback.EmergencyCallbackModeListener,
-            TelephonyCallback.CarrierRoamingNtnListener,
-            TelephonyCallback.SecurityAlgorithmsListener,
-            TelephonyCallback.CellularIdentifierDisclosedListener,
-            TelephonyCallback.CallAttributesListener {
+    public class TelephonyCallbackWrapper extends TelephonyCallback
+            implements TelephonyCallback.SrvccStateListener,
+                    TelephonyCallback.PhoneCapabilityListener,
+                    TelephonyCallback.ActiveDataSubscriptionIdListener,
+                    TelephonyCallback.RadioPowerStateListener,
+                    TelephonyCallback.CarrierNetworkListener,
+                    TelephonyCallback.PreciseDataConnectionStateListener,
+                    TelephonyCallback.DataConnectionStateListener,
+                    TelephonyCallback.DisplayInfoListener,
+                    TelephonyCallback.LinkCapacityEstimateChangedListener,
+                    TelephonyCallback.PhysicalChannelConfigListener,
+                    TelephonyCallback.CellLocationListener,
+                    TelephonyCallback.ServiceStateListener,
+                    TelephonyCallback.CellInfoListener,
+                    TelephonyCallback.BarringInfoListener,
+                    TelephonyCallback.RegistrationFailedListener,
+                    TelephonyCallback.DataActivityListener,
+                    TelephonyCallback.SimultaneousCellularCallingSupportListener,
+                    TelephonyCallback.EmergencyCallbackModeListener,
+                    TelephonyCallback.CarrierRoamingNtnListener,
+                    TelephonyCallback.SecurityAlgorithmsListener,
+                    TelephonyCallback.CellularIdentifierDisclosedListener,
+                    TelephonyCallback.CallAttributesListener {
         // This class isn't mockable to get invocation counts because the IBinder is null and
         // crashes the TelephonyRegistry. Make a cheesy verify(times()) alternative.
         public AtomicInteger invocationCount = new AtomicInteger(0);
@@ -259,6 +261,13 @@ public class TelephonyRegistryTest extends TelephonyTest {
             invocationCount.incrementAndGet();
             mRadioPowerState = state;
         }
+
+        @Override
+        public void onCarrierNetworkChange(boolean active) {
+            invocationCount.incrementAndGet();
+            mCarrierNetworkChange = active;
+        }
+
         @Override
         public void onPreciseDataConnectionStateChanged(PreciseDataConnectionState preciseState) {
             invocationCount.incrementAndGet();
@@ -502,6 +511,143 @@ public class TelephonyRegistryTest extends TelephonyTest {
         assertEquals(activeSubId, mActiveSubId);
     }
 
+    @Test
+    @SmallTest
+    public void testCarrierNetworkChangeWithSubId_initialStateIsFalse() {
+        int subId = 1;
+        doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
+        doReturn(0 /*slotIndex*/).when(mMockSubInfo).getSimSlotIndex();
+        int[] events = {TelephonyCallback.EVENT_CARRIER_NETWORK_CHANGED};
+
+        mTelephonyRegistry.listenWithEventList(
+                false /*renounceFineLocationAccess*/,
+                false /*renounceCoarseLocationAccess*/,
+                subId,
+                mContext.getOpPackageName(),
+                mContext.getAttributionTag(),
+                mTelephonyCallback.callback,
+                events,
+                true /*notifyNow*/);
+
+        processAllMessages();
+        assertFalse(mCarrierNetworkChange);
+    }
+
+    @Test
+    @SmallTest
+    public void testCarrierNetworkChangeWithSubId_notifyFalse() {
+        int subId = 1;
+        doReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS)
+                .when(mTelephonyManager)
+                .getCarrierPrivilegeStatus(anyInt());
+        doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
+        int phoneId = 0;
+        doReturn(phoneId).when(mMockSubInfo).getSimSlotIndex();
+        int[] events = {TelephonyCallback.EVENT_CARRIER_NETWORK_CHANGED};
+
+        mTelephonyRegistry.listenWithEventList(
+                false /*renounceFineLocationAccess*/,
+                false /*renounceCoarseLocationAccess*/,
+                subId,
+                mContext.getOpPackageName(),
+                mContext.getAttributionTag(),
+                mTelephonyCallback.callback,
+                events,
+                true /*notifyNow*/);
+
+        mTelephonyRegistry.notifyCarrierNetworkChangeForPhoneAndSubId(phoneId, subId, false);
+        processAllMessages();
+        assertFalse(mCarrierNetworkChange);
+    }
+
+    @Test
+    @SmallTest
+    public void testCarrierNetworkChangeWithSubId_notifyTrue() {
+        int subId = 1;
+        doReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS)
+                .when(mTelephonyManager)
+                .getCarrierPrivilegeStatus(anyInt());
+        doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
+        int phoneId = 0;
+        doReturn(phoneId).when(mMockSubInfo).getSimSlotIndex();
+        int[] events = {TelephonyCallback.EVENT_CARRIER_NETWORK_CHANGED};
+
+        mTelephonyRegistry.listenWithEventList(
+                false /*renounceFineLocationAccess*/,
+                false /*renounceCoarseLocationAccess*/,
+                subId,
+                mContext.getOpPackageName(),
+                mContext.getAttributionTag(),
+                mTelephonyCallback.callback,
+                events,
+                true /*notifyNow*/);
+
+        mTelephonyRegistry.notifyCarrierNetworkChangeForPhoneAndSubId(phoneId, subId, true);
+        processAllMessages();
+        assertTrue(mCarrierNetworkChange);
+    }
+
+    @Test
+    @SmallTest
+    public void testCarrierNetworkChangeForPhone_updatesOnRegistration() {
+        int subId = 1;
+        int phoneId = 0;
+        doReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS)
+                .when(mTelephonyManager)
+                .getCarrierPrivilegeStatus(anyInt());
+        doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
+        doReturn(phoneId).when(mMockSubInfo).getSimSlotIndex();
+        int[] events = {TelephonyCallback.EVENT_CARRIER_NETWORK_CHANGED};
+
+        assertFalse(mCarrierNetworkChange);
+        mTelephonyRegistry.notifyCarrierNetworkChangeForPhoneAndSubId(
+                phoneId, INVALID_SUBSCRIPTION_ID, true);
+        mTelephonyRegistry.listenWithEventList(
+                false /*renounceFineLocationAccess*/,
+                false /*renounceCoarseLocationAccess*/,
+                subId,
+                mContext.getOpPackageName(),
+                mContext.getAttributionTag(),
+                mTelephonyCallback.callback,
+                events,
+                true /*notifyNow*/);
+
+        processAllMessages();
+        assertTrue(mCarrierNetworkChange);
+    }
+
+    @Test
+    @SmallTest
+    public void testCarrierNetworkChangeForPhone_notifiesSubListener() {
+        int subId = 1;
+        int phoneId = 0;
+        doReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS)
+                .when(mTelephonyManager)
+                .getCarrierPrivilegeStatus(anyInt());
+        doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
+        doReturn(phoneId).when(mMockSubInfo).getSimSlotIndex();
+        int[] events = {TelephonyCallback.EVENT_CARRIER_NETWORK_CHANGED};
+
+        mTelephonyRegistry.listenWithEventList(
+                false /*renounceFineLocationAccess*/,
+                false /*renounceCoarseLocationAccess*/,
+                subId,
+                mContext.getOpPackageName(),
+                mContext.getAttributionTag(),
+                mTelephonyCallback.callback,
+                events,
+                true /*notifyNow*/);
+
+        mTelephonyRegistry.notifyCarrierNetworkChangeForPhoneAndSubId(phoneId, subId, true);
+        processAllMessages();
+        assertTrue(mCarrierNetworkChange);
+
+        mTelephonyRegistry.notifyCarrierNetworkChangeForPhoneAndSubId(
+                phoneId, INVALID_SUBSCRIPTION_ID, false);
+        processAllMessages();
+        assertFalse(mCarrierNetworkChange);
+    }
+
     /**
      * Test that we first receive a callback when listen(...) is called that contains the latest
      * notify(...) response and then that the callback is called correctly when notify(...) is
@@ -1815,7 +1961,7 @@ public class TelephonyRegistryTest extends TelephonyTest {
     @Test
     @EnableFlags(Flags.FLAG_CARRIER_ROAMING_NB_IOT_NTN)
     public void testNotifyCarrierRoamingNtnSignalStrengthChanged() {
-        int subId = INVALID_SUBSCRIPTION_ID;
+        int subId = 2;
         doReturn(mMockSubInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());
         doReturn(0/*slotIndex*/).when(mMockSubInfo).getSimSlotIndex();
         int[] events = {TelephonyCallback.EVENT_CARRIER_ROAMING_NTN_SIGNAL_STRENGTH_CHANGED};
diff --git a/tests/telephonytests/src/com/android/internal/telephony/TelephonyTest.java b/tests/telephonytests/src/com/android/internal/telephony/TelephonyTest.java
index 26ab6da21e..4e399a02f3 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/TelephonyTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/TelephonyTest.java
@@ -20,8 +20,8 @@ import static com.android.internal.telephony.TelephonyStatsLog.CELLULAR_SERVICE_
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.nullable;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyInt;
@@ -61,8 +61,6 @@ import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
 import android.os.Looper;
-import android.os.Message;
-import android.os.MessageQueue;
 import android.os.RegistrantList;
 import android.os.ServiceManager;
 import android.os.StrictMode;
@@ -564,11 +562,13 @@ public abstract class TelephonyTest {
         mDomainSelectionResolver = Mockito.mock(DomainSelectionResolver.class);
         mNullCipherNotifier = Mockito.mock(NullCipherNotifier.class);
 
-        lenient().doReturn(true).when(mFeatureFlags).hsumBroadcast();
-        lenient().doReturn(true).when(mFeatureFlags).hsumPackageManager();
         lenient().doReturn(true).when(mFeatureFlags).dataServiceCheck();
         lenient().doReturn(true).when(mFeatureFlags).phoneTypeCleanup();
         lenient().doReturn(true).when(mFeatureFlags).cleanupCdma();
+        lenient().doReturn(true).when(mFeatureFlags).threadShred();
+        lenient().doReturn(true).when(mFeatureFlags).dynamicModemShutdown();
+        lenient().doReturn(true).when(mFeatureFlags).dataServiceNotifyImsDataNetwork();
+        lenient().doReturn(true).when(mFeatureFlags).keepWfcOnApm();
 
         WorkerThread.reset();
         TelephonyManager.disableServiceHandleCaching();
@@ -600,6 +600,7 @@ public abstract class TelephonyTest {
                 .queryLocalInterface(anyString());
 
         mPhone.mCi = mSimulatedCommands;
+        mPhone.mCT = mCT;
         mCT.mCi = mSimulatedCommands;
         lenient().doReturn(mUiccCard).when(mPhone).getUiccCard();
         lenient().doReturn(mUiccCard).when(mUiccSlot).getUiccCard();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiverTest.java b/tests/telephonytests/src/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiverTest.java
index 64dd24e278..d55a5c88cc 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiverTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/configupdate/TelephonyConfigUpdateInstallReceiverTest.java
@@ -340,4 +340,33 @@ public class TelephonyConfigUpdateInstallReceiverTest extends TelephonyTest {
         assertFalse(spyTelephonyConfigUpdateInstallReceiver
                 .isValidSatelliteCarrierConfigData(mockParser));
     }
+
+    @Test
+    public void testIsValidMaxAllowedDataMode() {
+        TelephonyConfigUpdateInstallReceiver spyTelephonyConfigUpdateInstallReceiver =
+                spy(new TelephonyConfigUpdateInstallReceiver());
+        SatelliteConfigParser mockParser = mock(SatelliteConfigParser.class);
+        SatelliteConfig mockConfig = mock(SatelliteConfig.class);
+        doReturn(mockConfig).when(mockParser).getConfig();
+
+        assertTrue(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(null).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertTrue(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(0).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertTrue(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(1).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertTrue(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(2).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertTrue(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(-1).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertFalse(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+
+        doReturn(3).when(mockConfig).getSatelliteMaxAllowedDataMode();
+        assertFalse(spyTelephonyConfigUpdateInstallReceiver.isValidMaxAllowedDataMode(mockParser));
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/AutoDataSwitchControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/AutoDataSwitchControllerTest.java
index 1dcf2fa515..b1eb78a740 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/AutoDataSwitchControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/AutoDataSwitchControllerTest.java
@@ -138,6 +138,7 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
             doReturn(mSignalStrength).when(phone).getSignalStrength();
             doReturn(mDataNetworkController).when(phone).getDataNetworkController();
             doReturn(mDataConfigManager).when(mDataNetworkController).getDataConfigManager();
+            doReturn(mDataSettingsManager).when(phone).getDataSettingsManager();
             doAnswer(invocation -> phone.getSubId() == mDefaultDataSub)
                     .when(phone).isUserDataEnabled();
         }
@@ -196,7 +197,9 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
         mScheduledEventsToExtras = getPrivateField(mAutoDataSwitchControllerUT,
                 "mScheduledEventsToExtras", Map.class);
 
-        doReturn(true).when(mFeatureFlags).autoDataSwitchEnhanced();
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST);
+
+        doReturn(true).when(mFeatureFlags).autoDataPruneListener();
     }
 
     @After
@@ -417,6 +420,7 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
 
         // 4.1.2 Display info and signal strength on secondary phone became bad,
         // but primary become service, then don't switch.
+        logd("4.1.2 Display info and signal strength on secondary became bad, don't switch.");
         prepareIdealUsesNonDdsCondition();
         processAllFutureMessages();
         clearInvocations(mMockedPhoneSwitcherCallback, mMockedAlarmManager);
@@ -430,6 +434,7 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
                 EVENT_STABILITY_CHECK_PASSED));
 
         // 4.2 Display info on default phone became good just as the secondary
+        logd("4.2 Display info on default phone became good just as the secondary.");
         prepareIdealUsesNonDdsCondition();
         processAllFutureMessages();
         clearInvocations(mMockedPhoneSwitcherCallback, mMockedAlarmManager);
@@ -442,6 +447,7 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
                 EVENT_STABILITY_CHECK_PASSED));
 
         // 4.3 Signal strength on default phone became just as good as the secondary
+        logd("4.3 Signal strength on default phone became just as good as the secondary.");
         prepareIdealUsesNonDdsCondition();
         processAllFutureMessages();
         clearInvocations(mMockedPhoneSwitcherCallback, mMockedAlarmManager);
@@ -723,9 +729,187 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
         }
     }
 
+    @Test
+    public void testDataSettingsChangedUpdateListener() {
+        setDefaultDataSubId(SUB_1); // Phone 1 is default
+        int modemCount = mPhones.length; // Should be 2
+
+        // Pre-condition: Assume listeners are registered initially (cleared invocations in setUp)
+
+        // --- Scenario 1: Disable Default Phone User Data ---
+        logd("Scenario 1: Disable Default Phone User Data");
+        doReturn(false).when(mPhone).isUserDataEnabled();
+
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(EVALUATION_REASON_DATA_SETTINGS_CHANGED);
+        processAllMessages();
+
+        // Verify unregister calls for *both* phones
+        verify(mDisplayInfoController, times(modemCount))
+                .unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, times(modemCount)).unregisterForSignalStrengthChanged(
+                any());
+        verify(mSST, times(modemCount)).unregisterForServiceStateChanged(any());
+        // Verify register calls were NOT made
+        verify(mDisplayInfoController, never()).registerForTelephonyDisplayInfoChanged(
+                any(), anyInt(), any());
+        verify(mSignalStrengthController, never()).registerForSignalStrengthChanged(
+                any(), anyInt(), any());
+        verify(mSST, never()).registerForServiceStateChanged(any(), anyInt(), any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST);
+
+        // --- Scenario 2: Re-enable Default Phone User Data ---
+        logd("Scenario 2: Re-enable Default Phone User Data");
+        doReturn(true).when(mPhone).isUserDataEnabled();
+
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(EVALUATION_REASON_DATA_SETTINGS_CHANGED);
+        processAllMessages();
+
+        // Verify register calls for *both* phones
+        verify(mDisplayInfoController, times(modemCount)).registerForTelephonyDisplayInfoChanged(
+                any(), eq(EVENT_DISPLAY_INFO_CHANGED), any());
+        verify(mSignalStrengthController, times(modemCount)).registerForSignalStrengthChanged(
+                any(), eq(EVENT_SIGNAL_STRENGTH_CHANGED), any());
+        verify(mSST, times(modemCount)).registerForServiceStateChanged(
+                any(), eq(EVENT_SERVICE_STATE_CHANGED), any());
+        // Verify unregister calls were NOT made
+        verify(mDisplayInfoController, never()).unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, never()).unregisterForSignalStrengthChanged(any());
+        verify(mSST, never()).unregisterForServiceStateChanged(any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST); // Reset
+
+        // --- Scenario 3: Disable *Only* Candidate Phone Data Setting ---
+        logd("Scenario 3: Disable *Only* Candidate Phone Data Setting");
+        doReturn(true).when(mPhone).isUserDataEnabled(); // Ensure default is enabled
+        doReturn(false).when(mDataSettingsManager).isDataEnabled(); // Disable candidate
+
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(EVALUATION_REASON_DATA_SETTINGS_CHANGED);
+        processAllMessages();
+
+        // Verify unregister calls for *both* phones (as no candidates left)
+        verify(mDisplayInfoController, times(modemCount))
+                .unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, times(modemCount))
+                .unregisterForSignalStrengthChanged(any());
+        verify(mSST, times(modemCount)).unregisterForServiceStateChanged(any());
+        // Verify register calls were NOT made
+        verify(mDisplayInfoController, never())
+                .registerForTelephonyDisplayInfoChanged(any(), anyInt(), any());
+        verify(mSignalStrengthController, never())
+                .registerForSignalStrengthChanged(any(), anyInt(), any());
+        verify(mSST, never()).registerForServiceStateChanged(any(), anyInt(), any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST); // Reset
+
+        // --- Scenario 4: Re-enable Candidate Phone Data Setting ---
+        logd("Scenario 4: Re-enable Candidate Phone Data Setting");
+        doReturn(true).when(mDataSettingsManager).isDataEnabled();
+
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(EVALUATION_REASON_DATA_SETTINGS_CHANGED);
+        processAllMessages();
+
+        // Verify register calls for *both* phones
+        verify(mDisplayInfoController, times(modemCount)).registerForTelephonyDisplayInfoChanged(
+                any(), eq(EVENT_DISPLAY_INFO_CHANGED), any());
+        verify(mSignalStrengthController, times(modemCount)).registerForSignalStrengthChanged(
+                any(), eq(EVENT_SIGNAL_STRENGTH_CHANGED), any());
+        verify(mSST, times(modemCount)).registerForServiceStateChanged(
+                any(), eq(EVENT_SERVICE_STATE_CHANGED), any());
+        // Verify unregister calls were NOT made
+        verify(mDisplayInfoController, never()).unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, never()).unregisterForSignalStrengthChanged(any());
+        verify(mSST, never()).unregisterForServiceStateChanged(any());
+    }
+
+    @Test
+    public void testDefaultNetworkChangedUpdateListener() {
+        setDefaultDataSubId(SUB_1); // Phone 1 is default
+        int modemCount = mPhones.length; // Should be 2
+
+        // Pre-condition: Assume listeners are registered initially (cleared invocations in setUp)
+
+        // --- Scenario 1: Default network becomes non-cellular (WIFI) ---
+        logd("Scenario 1: Default network becomes WIFI");
+        NetworkCapabilities wifiCapabilities = new NetworkCapabilities();
+        wifiCapabilities.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
+        mAutoDataSwitchControllerUT.updateDefaultNetworkCapabilities(wifiCapabilities);
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(AutoDataSwitchController
+                .EVALUATION_REASON_DEFAULT_NETWORK_CHANGED);
+        processAllMessages();
+
+        // Verify unregister calls for *both* phones
+        verify(mDisplayInfoController, times(modemCount))
+                .unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, times(modemCount))
+                .unregisterForSignalStrengthChanged(any());
+        verify(mSST, times(modemCount)).unregisterForServiceStateChanged(any());
+        // Verify register calls were NOT made
+        verify(mDisplayInfoController, never()).registerForTelephonyDisplayInfoChanged(
+                any(), anyInt(), any());
+        verify(mSignalStrengthController, never()).registerForSignalStrengthChanged(
+                any(), anyInt(), any());
+        verify(mSST, never()).registerForServiceStateChanged(any(), anyInt(), any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST); // Reset
+
+        // --- Scenario 2: Default network becomes cellular ---
+        logd("Scenario 2: Default network becomes CELLULAR");
+        NetworkCapabilities cellularCapabilities = new NetworkCapabilities();
+        cellularCapabilities.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+        mAutoDataSwitchControllerUT.updateDefaultNetworkCapabilities(cellularCapabilities);
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(AutoDataSwitchController
+                .EVALUATION_REASON_DEFAULT_NETWORK_CHANGED);
+        processAllMessages();
+
+        // Verify register calls for *both* phones
+        verify(mDisplayInfoController, times(modemCount)).registerForTelephonyDisplayInfoChanged(
+                any(), eq(EVENT_DISPLAY_INFO_CHANGED), any());
+        verify(mSignalStrengthController, times(modemCount)).registerForSignalStrengthChanged(any(),
+                eq(EVENT_SIGNAL_STRENGTH_CHANGED), any());
+        verify(mSST, times(modemCount)).registerForServiceStateChanged(any(),
+                eq(EVENT_SERVICE_STATE_CHANGED), any());
+        // Verify unregister calls were NOT made
+        verify(mDisplayInfoController, never()).unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, never()).unregisterForSignalStrengthChanged(any());
+        verify(mSST, never()).unregisterForServiceStateChanged(any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST); // Reset
+
+        // --- Scenario 3: Default network lost (null) ---
+        logd("Scenario 3: Default network lost (null)");
+        // First switch to non-cellular to ensure listeners are off
+        mAutoDataSwitchControllerUT.updateDefaultNetworkCapabilities(wifiCapabilities);
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(AutoDataSwitchController
+                .EVALUATION_REASON_DEFAULT_NETWORK_CHANGED);
+        processAllMessages();
+
+        verify(mDisplayInfoController, times(modemCount))
+                .unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, times(modemCount))
+                .unregisterForSignalStrengthChanged(any());
+        verify(mSST, times(modemCount))
+                .unregisterForServiceStateChanged(any());
+        clearInvocations(mDisplayInfoController, mSignalStrengthController, mSST);
+
+        // Now lose the network
+        mAutoDataSwitchControllerUT.updateDefaultNetworkCapabilities(null);
+        mAutoDataSwitchControllerUT.evaluateAutoDataSwitch(AutoDataSwitchController
+                .EVALUATION_REASON_DEFAULT_NETWORK_CHANGED);
+        processAllMessages();
+
+        // Verify register calls for *both* phones (null network means cellular is possible)
+        verify(mDisplayInfoController, times(modemCount)).registerForTelephonyDisplayInfoChanged(
+                any(), eq(EVENT_DISPLAY_INFO_CHANGED), any());
+        verify(mSignalStrengthController, times(modemCount)).registerForSignalStrengthChanged(any(),
+                eq(EVENT_SIGNAL_STRENGTH_CHANGED), any());
+        verify(mSST, times(modemCount)).registerForServiceStateChanged(any(),
+                eq(EVENT_SERVICE_STATE_CHANGED), any());
+
+        verify(mDisplayInfoController, never())
+                .unregisterForTelephonyDisplayInfoChanged(any());
+        verify(mSignalStrengthController, never()).unregisterForSignalStrengthChanged(any());
+        verify(mSST, never()).unregisterForServiceStateChanged(any());
+    }
+
     @Test
     public void testRatSignalStrengthSkipEvaluation() {
-        // Verify the secondary phone is OOS and its score(0) is too low to justify the evaluation
+        // Score NOT significantly better to justify the evaluation
         clearInvocations(mMockedPhoneSwitcherCallback);
         displayInfoChanged(PHONE_2, mBadTelephonyDisplayInfo);
         processAllFutureMessages();
@@ -734,6 +918,30 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
         verify(mMockedPhoneSwitcherCallback, never()).onRequireValidation(anyInt(), anyBoolean());
     }
 
+    /**
+     * Scenario 2: On Default, Candidate score IS better, BUT Candidate is NOT HOME.
+     */
+    @Test
+    public void testBetterCandidate_onDefault_nonHome_scoreHigh_noEval() {
+        doReturn(PHONE_1).when(mPhoneSwitcher).getPreferredDataPhoneId();
+
+        // Setup state: Low score for default, high score for backup
+        displayInfoChanged(PHONE_1, mBadTelephonyDisplayInfo);
+        signalStrengthChanged(PHONE_1, SignalStrength.SIGNAL_STRENGTH_POOR);
+        displayInfoChanged(PHONE_2, mGoodTelephonyDisplayInfo); // High score inputs
+        signalStrengthChanged(PHONE_2, SignalStrength.SIGNAL_STRENGTH_GREAT);
+        serviceStateChanged(PHONE_2, NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
+        processAllMessages();
+
+        // Trigger internal call via another display info change
+        displayInfoChanged(PHONE_2, mGoodTelephonyDisplayInfo);
+        processAllMessages();
+
+        // Verify no evaluation scheduled (skipped because not HOME)
+        assertThat(mAutoDataSwitchControllerUT.hasMessages(EVENT_EVALUATE_AUTO_SWITCH)).isFalse();
+        mAutoDataSwitchControllerUT.removeMessages(EVENT_EVALUATE_AUTO_SWITCH);
+    }
+
     /**
      * Trigger conditions
      * 1. service state changes
@@ -766,6 +974,7 @@ public class AutoDataSwitchControllerTest extends TelephonyTest {
 
         // 4.2 Auto switch feature is enabled
         doReturn(true).when(mPhone2).getDataRoamingEnabled();
+        doReturn(true).when(mDataSettingsManager).isDataEnabled();
         mDataEvaluation.addDataAllowedReason(DataEvaluation.DataAllowedReason.NORMAL);
 
         // 5. No default network
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataCallResponseTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataCallResponseTest.java
index c0a921149b..f40fada6e5 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataCallResponseTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataCallResponseTest.java
@@ -21,7 +21,9 @@ import static org.junit.Assert.assertNotEquals;
 import android.net.InetAddresses;
 import android.net.LinkAddress;
 import android.os.Parcel;
+import android.telephony.AccessNetworkConstants;
 import android.telephony.PreciseDataConnectionState;
+import android.telephony.SubscriptionManager;
 import android.telephony.data.ApnSetting;
 import android.telephony.data.DataCallResponse;
 import android.telephony.data.EpsQos;
@@ -52,6 +54,7 @@ public class DataCallResponseTest extends AndroidTestCase {
     private static final byte[] FAKE_OS_APP_ID_2 = {-105, -92, -104, -29, -4, -110, 92,
             -108, -119, -122, 3, 51, -48, 110, 78, 71, 10, 69, 78, 84, 69,
             82, 80, 82, 73, 83, 69, 50};
+    private static final int PHYSICAL_NETWORK_SLOT_INDEX = 1;
 
     @SmallTest
     public void testParcel() {
@@ -77,6 +80,8 @@ public class DataCallResponseTest extends AndroidTestCase {
                         Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
                 .setNetworkValidationStatus(
                         PreciseDataConnectionState.NETWORK_VALIDATION_UNSUPPORTED)
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
                 .build();
 
         Parcel p = Parcel.obtain();
@@ -108,6 +113,8 @@ public class DataCallResponseTest extends AndroidTestCase {
                         Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
                 .setNetworkValidationStatus(
                         PreciseDataConnectionState.NETWORK_VALIDATION_IN_PROGRESS)
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
                 .build();
 
         DataCallResponse response1 = new DataCallResponse.Builder()
@@ -129,6 +136,8 @@ public class DataCallResponseTest extends AndroidTestCase {
                         Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
                 .setNetworkValidationStatus(
                         PreciseDataConnectionState.NETWORK_VALIDATION_IN_PROGRESS)
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
                 .build();
 
         assertEquals(response, response);
@@ -156,6 +165,8 @@ public class DataCallResponseTest extends AndroidTestCase {
                         new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID),
                         new TrafficDescriptor(FAKE_DNN_2, FAKE_OS_APP_ID_2)))
                 .setNetworkValidationStatus(PreciseDataConnectionState.NETWORK_VALIDATION_SUCCESS)
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
                 .build();
 
         assertNotSame(response1, response2);
@@ -186,6 +197,8 @@ public class DataCallResponseTest extends AndroidTestCase {
                         new TrafficDescriptor(FAKE_DNN_2, FAKE_OS_APP_ID_2),
                         new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
                 .setNetworkValidationStatus(PreciseDataConnectionState.NETWORK_VALIDATION_SUCCESS)
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
                 .build();
 
         assertEquals(response2, response3);
@@ -193,4 +206,75 @@ public class DataCallResponseTest extends AndroidTestCase {
                 response3.getNetworkValidationStatus());
         assertEquals(response2.hashCode(), response3.hashCode());
     }
+
+    @SmallTest
+    public void testPhysicalNetworkSlotIndex() {
+        DataCallResponse response = new DataCallResponse.Builder()
+                .setCause(0)
+                .setRetryDurationMillis(-1L)
+                .setId(1)
+                .setLinkStatus(2)
+                .setProtocolType(ApnSetting.PROTOCOL_IP)
+                .setInterfaceName(FAKE_IFNAME)
+                .setAddresses(Arrays.asList(
+                        new LinkAddress(InetAddresses.parseNumericAddress(FAKE_ADDRESS), 0)))
+                .setDnsAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_DNS)))
+                .setGatewayAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_GATEWAY)))
+                .setPcscfAddresses(
+                        Arrays.asList(InetAddresses.parseNumericAddress(FAKE_PCSCF_ADDRESS)))
+                .setMtuV4(1440)
+                .setMtuV6(1440)
+                .setTrafficDescriptors(
+                        Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
+                .build();
+        assertEquals(response.getPhysicalNetworkSlotIndex(), PHYSICAL_NETWORK_SLOT_INDEX);
+
+        response = new DataCallResponse.Builder()
+                .setCause(0)
+                .setRetryDurationMillis(-1L)
+                .setId(1)
+                .setLinkStatus(2)
+                .setProtocolType(ApnSetting.PROTOCOL_IP)
+                .setInterfaceName(FAKE_IFNAME)
+                .setAddresses(Arrays.asList(
+                        new LinkAddress(InetAddresses.parseNumericAddress(FAKE_ADDRESS), 0)))
+                .setDnsAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_DNS)))
+                .setGatewayAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_GATEWAY)))
+                .setPcscfAddresses(
+                        Arrays.asList(InetAddresses.parseNumericAddress(FAKE_PCSCF_ADDRESS)))
+                .setMtuV4(1440)
+                .setMtuV6(1440)
+                .setTrafficDescriptors(
+                        Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
+                .build();
+        assertEquals(response.getPhysicalNetworkSlotIndex(),
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX);
+
+        response = new DataCallResponse.Builder()
+                .setCause(0)
+                .setRetryDurationMillis(-1L)
+                .setId(1)
+                .setLinkStatus(2)
+                .setProtocolType(ApnSetting.PROTOCOL_IP)
+                .setInterfaceName(FAKE_IFNAME)
+                .setAddresses(Arrays.asList(
+                        new LinkAddress(InetAddresses.parseNumericAddress(FAKE_ADDRESS), 0)))
+                .setDnsAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_DNS)))
+                .setGatewayAddresses(Arrays.asList(InetAddresses.parseNumericAddress(FAKE_GATEWAY)))
+                .setPcscfAddresses(
+                        Arrays.asList(InetAddresses.parseNumericAddress(FAKE_PCSCF_ADDRESS)))
+                .setMtuV4(1440)
+                .setMtuV6(1440)
+                .setTrafficDescriptors(
+                        Arrays.asList(new TrafficDescriptor(FAKE_DNN, FAKE_OS_APP_ID)))
+                .setPhysicalNetworkTransportType(AccessNetworkConstants.TRANSPORT_TYPE_INVALID)
+                .setPhysicalNetworkSlotIndex(PHYSICAL_NETWORK_SLOT_INDEX)
+                .build();
+        assertEquals(response.getPhysicalNetworkSlotIndex(),
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX);
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkControllerTest.java
index a7bd9bc131..21f64299e7 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkControllerTest.java
@@ -75,7 +75,6 @@ import android.telephony.DataSpecificRegistrationInfo;
 import android.telephony.LteVopsSupportInfo;
 import android.telephony.NetworkRegistrationInfo;
 import android.telephony.NetworkRegistrationInfo.RegistrationState;
-import android.telephony.PreciseDataConnectionState;
 import android.telephony.ServiceState;
 import android.telephony.SubscriptionInfo;
 import android.telephony.SubscriptionManager;
@@ -587,13 +586,14 @@ public class DataNetworkControllerTest extends TelephonyTest {
         processAllMessages();
     }
 
-    private void setImsRegistered(boolean registered) {
+    private void setImsRegistered(boolean registered,
+            @ImsRegistrationImplBase.ImsRegistrationTech int regTech) {
         if (registered) {
             final ArraySet<String> features = new ArraySet<>();
             features.add("feature1");
             features.add("feature2");
-            ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(
-                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE).setFeatureTags(features).build();
+            ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(regTech)
+                    .setFeatureTags(features).build();
 
             mMmtelRegCallback.onRegistered(attr);
         } else {
@@ -602,13 +602,14 @@ public class DataNetworkControllerTest extends TelephonyTest {
         }
     }
 
-    private void setRcsRegistered(boolean registered) {
+    private void setRcsRegistered(boolean registered,
+            @ImsRegistrationImplBase.ImsRegistrationTech int regTech) {
         if (registered) {
             final ArraySet<String> features = new ArraySet<>();
             features.add("feature1");
             features.add("feature2");
-            ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(
-                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE).setFeatureTags(features).build();
+            ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(regTech)
+                    .setFeatureTags(features).build();
 
             mRcsRegCallback.onRegistered(attr);
         } else {
@@ -868,7 +869,8 @@ public class DataNetworkControllerTest extends TelephonyTest {
         mMockSubInfo = Mockito.mock(SubscriptionInfo.class);
         mMockPackageManager = Mockito.mock(PackageManager.class);
         when(mTelephonyComponentFactory.makeDataSettingsManager(any(Phone.class),
-                any(DataNetworkController.class), any(FeatureFlags.class), any(Looper.class),
+                any(DataNetworkController.class), any(SparseArray.class), any(FeatureFlags.class),
+                any(Looper.class),
                 any(DataSettingsManager.DataSettingsManagerCallback.class))).thenCallRealMethod();
         doReturn(mMockedImsMmTelManager).when(mMockedImsManager).getImsMmTelManager(anyInt());
         doReturn(mMockedImsRcsManager).when(mMockedImsManager).getImsRcsManager(anyInt());
@@ -892,6 +894,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
         doReturn(new SubscriptionInfoInternal.Builder().setId(1).build())
                 .when(mSubscriptionManagerService).getSubscriptionInfoInternal(anyInt());
         doReturn(true).when(mFeatureFlags).incallHandoverPolicy();
+        doReturn(true).when(mFeatureFlags).keepWfcOnApm();
 
         when(mContext.getPackageManager()).thenReturn(mMockPackageManager);
         doReturn(true).when(mMockPackageManager).hasSystemFeature(anyString());
@@ -953,6 +956,8 @@ public class DataNetworkControllerTest extends TelephonyTest {
         // as well, except some modules below we replaced with mocks.
         mDataNetworkControllerUT = new DataNetworkController(mPhone, Looper.myLooper(),
                 mFeatureFlags);
+
+        doReturn(true).when(mSST).isRadioOn();
         // First two come from DataServiceManager and the third comes from DataConfigManager which
         // is what we want to capture and assign to mCarrierConfigChangeListener
         verify(mCarrierConfigManager, times(3)).registerCarrierConfigChangeListener(any(),
@@ -1448,7 +1453,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
                 NetworkCapabilities.NET_CAPABILITY_INTERNET);
         mDataNetworkControllerUT.addNetworkRequest(request);
         processAllMessages();
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(true));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(true, true);
         verify(mMockedDataNetworkControllerCallback).onConnectedInternetDataNetworksChanged(any());
 
         int countOfCallbacks = dataNetworkControllerCallbacks.size();
@@ -1471,7 +1476,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
                 TelephonyManager.SIM_STATE_ABSENT, 0).sendToTarget();
         processAllMessages();
         verifyAllDataDisconnected();
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onConnectedInternetDataNetworksChanged(
                 eq(Collections.emptySet()));
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
@@ -1764,7 +1769,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
         serviceStateChanged(TelephonyManager.NETWORK_TYPE_GSM,
                 NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
         verifyAllDataDisconnected();
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onConnectedInternetDataNetworksChanged(
                 eq(Collections.emptySet()));
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
@@ -3152,7 +3157,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
         // establish a new one on IWLAN
 
         // Verify all data disconnected.
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
                 eq(DataCallResponse.LINK_STATUS_INACTIVE));
 
@@ -3243,7 +3248,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
         processAllMessages();
 
         // Verify all data disconnected.
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
                 eq(DataCallResponse.LINK_STATUS_INACTIVE));
 
@@ -3278,7 +3283,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
                 AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
 
         // Verify all data disconnected.
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
                 eq(DataCallResponse.LINK_STATUS_INACTIVE));
 
@@ -4046,7 +4051,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
 
         // Deactivate the data, verify notify PCO gone.
         mDataNetworkControllerUT.tearDownAllDataNetworks(
-                DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+                DataNetwork.TEAR_DOWN_REASON_DEVICE_SHUT_DOWN);
         processAllFutureMessages();
 
         verify(mMockedDataNetworkControllerCallback).onNrAdvancedCapableByPcoChanged(eq(false));
@@ -4173,7 +4178,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
 
         // There shouldn't be all data disconnected event.
         verify(mMockedDataNetworkControllerCallback, never())
-                .onAnyDataNetworkExistingChanged(anyBoolean());
+                .onAnyDataNetworkExistingChanged(anyBoolean(), anyBoolean());
 
         // Verify IMS is still alive.
         List<DataNetwork> dataNetworkList = getDataNetworks();
@@ -4689,9 +4694,14 @@ public class DataNetworkControllerTest extends TelephonyTest {
 
     @Test
     public void testImsGracefulTearDown() throws Exception {
-        setImsRegistered(true);
-        setRcsRegistered(true);
+        setImsRegistered(true, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
+        setRcsRegistered(true, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
+
+        // IMS preferred on Wifi
+        updateTransport(NetworkCapabilities.NET_CAPABILITY_IMS,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
 
+        // IMS service requests an IMS network, expects the network on IWLAN.
         NetworkCapabilities netCaps = new NetworkCapabilities();
         netCaps.addCapability(NetworkCapabilities.NET_CAPABILITY_IMS);
         netCaps.maybeMarkCapabilitiesRestricted();
@@ -4702,40 +4712,182 @@ public class DataNetworkControllerTest extends TelephonyTest {
         TelephonyNetworkRequest networkRequest = new TelephonyNetworkRequest(
                 nativeNetworkRequest, mPhone, mFeatureFlags);
 
+        mDataNetworkControllerUT.addNetworkRequest(networkRequest);
+        setSuccessfulSetupDataResponse(mMockedWlanDataServiceManager, 2/*cid*/);
+
+        // IMS service requests an internet network, expects the network on WWAN.
+        netCaps = new NetworkCapabilities();
+        netCaps.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
+        netCaps.setRequestorPackageName(FAKE_MMTEL_PACKAGE);
+
+        nativeNetworkRequest = new NetworkRequest(netCaps,
+                ConnectivityManager.TYPE_MOBILE, ++mNetworkRequestId, NetworkRequest.Type.REQUEST);
+        networkRequest = new TelephonyNetworkRequest(nativeNetworkRequest, mPhone, mFeatureFlags);
+
         mDataNetworkControllerUT.addNetworkRequest(networkRequest);
 
         processAllMessages();
         Mockito.clearInvocations(mPhone);
 
-        // SIM removal
-        mDataNetworkControllerUT.obtainMessage(9/*EVENT_SIM_STATE_CHANGED*/,
-                TelephonyManager.SIM_STATE_ABSENT, 0).sendToTarget();
+
+        List<DataNetwork> networks = getDataNetworks();
+        assertEquals(2, networks.size());
+
+        // Turn on APM mode.
+        doReturn(false).when(mSST).getDesiredPowerState();
+        mDataNetworkControllerUT.tearDownAllDataNetworks(DataNetwork
+                .TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
         processAllMessages();
 
-        // Make sure data network enters disconnecting state
-        ArgumentCaptor<PreciseDataConnectionState> pdcsCaptor =
-                ArgumentCaptor.forClass(PreciseDataConnectionState.class);
-        verify(mPhone).notifyDataConnection(pdcsCaptor.capture());
-        PreciseDataConnectionState pdcs = pdcsCaptor.getValue();
-        assertThat(pdcs.getState()).isEqualTo(TelephonyManager.DATA_DISCONNECTING);
+        // Expect the network on WWAN immediately disconnected because IMS registration is on IWLAN.
+        // And it has no RCS requests.
+        assertWithMessage("Expect 1 network but have " + networks)
+                .that(networks.size()).isEqualTo(1);
+        DataNetwork wlanNetwork = networks.get(0);
+        // Expect the network on IWLAN enters stays alive.
+        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, wlanNetwork.getTransport());
+        assertTrue(wlanNetwork.isConnected());
 
-        // IMS de-registered. Now data network is safe to be torn down.
+        // Turn off APM mode
+        doReturn(true).when(mSST).getDesiredPowerState();
+        // IMS service requests an RCS network, expects the network on WWAN.
+        netCaps = new NetworkCapabilities();
+        netCaps.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
+        netCaps.setRequestorPackageName(FAKE_RCS_PACKAGE);
+
+        nativeNetworkRequest = new NetworkRequest(netCaps,
+                ConnectivityManager.TYPE_MOBILE, ++mNetworkRequestId, NetworkRequest.Type.REQUEST);
+        networkRequest = new TelephonyNetworkRequest(
+                nativeNetworkRequest, mPhone, mFeatureFlags);
+
+        mDataNetworkControllerUT.addNetworkRequest(networkRequest);
+        processAllMessages();
+
+        // Turn on APM mode again.
+        doReturn(false).when(mSST).getDesiredPowerState();
+        mDataNetworkControllerUT.tearDownAllDataNetworks(DataNetwork
+                .TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+        processAllMessages();
+
+        // Expect both IMS and RCS networks are alive.
+        assertWithMessage("Expect 2 networks but only have " + networks)
+                .that(networks.size()).isEqualTo(2);
+        // Expect the network on WWAN enters disconnecting state because RCS is registered on WWAN.
+        for (DataNetwork nw : networks) {
+            if (nw.getTransport() == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
+                assertTrue(nw.isConnected());
+            } else {
+                assertTrue(nw.isDisconnecting());
+            }
+        }
+
+        // RCS de-registered. Now internet RCS data network is safe to be torn down.
+        // IMS de-registered. But since IMS is on IWLAN, it should remain intact.
         Mockito.clearInvocations(mPhone);
-        setImsRegistered(false);
-        setRcsRegistered(false);
+        setImsRegistered(false, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
+        setRcsRegistered(false, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
         processAllMessages();
 
         // All data should be disconnected.
-        verifyAllDataDisconnected();
-        verifyNoConnectedNetworkHasCapability(NetworkCapabilities.NET_CAPABILITY_IMS);
-        verify(mPhone).notifyDataConnection(pdcsCaptor.capture());
-        pdcs = pdcsCaptor.getValue();
-        assertThat(pdcs.getState()).isEqualTo(TelephonyManager.DATA_DISCONNECTED);
+        assertTrue(mDataNetworkControllerUT.areAllDataDisconnected(true));
+        assertFalse(mDataNetworkControllerUT.areAllDataDisconnected(false));
+        assertTrue(wlanNetwork.isConnected());
+    }
+
+    @Test
+    public void testTearDownNetworksApm() throws Exception {
+        testSetupImsDataNetwork();
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(true, true);
+
+        List<DataNetwork> networks = getDataNetworks();
+
+        Mockito.reset(mMockedWlanDataServiceManager);
+        clearInvocations(mMockedDataNetworkControllerCallback);
+        // IMS preferred on WLAN
+        updateTransport(NetworkCapabilities.NET_CAPABILITY_IMS,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
+
+        // Capture the message for setup data call response. We want to delay it.
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mMockedWlanDataServiceManager).setupDataCall(anyInt(), any(DataProfile.class),
+                anyBoolean(), anyBoolean(), anyInt(), any(), anyInt(), any(), any(), anyBoolean(),
+                messageCaptor.capture());
+
+        // Verify the only cellular network is handing over to WLAN
+        assertTrue(networks.get(0).isHandoverInProgress());
+
+        // Turn on APM mode .
+        mDataNetworkControllerUT.tearDownAllDataNetworks(DataNetwork
+                .TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+        processAllMessages();
+
+        assertTrue(mDataNetworkControllerUT.areAllDataDisconnected(true));
+
+        // Finally WLAN handover is completed with failure.
+        Message msg = messageCaptor.getValue();
+        DataCallResponse response = new DataCallResponse.Builder()
+                .setCause(DataFailCause.ERROR_UNSPECIFIED)
+                .setRetryDurationMillis(123)
+                .setHandoverFailureMode(
+                        DataCallResponse.HANDOVER_FAILURE_MODE_NO_FALLBACK_RETRY_SETUP_NORMAL)
+                .build();
+        msg.getData().putParcelable("data_call_response", response);
+        msg.arg1 = DataServiceCallback.RESULT_ERROR_UNSUPPORTED;
+        msg.sendToTarget();
+        processAllFutureMessages();
+
+        // WWAN network came into existence due to handover failed.
+        // Verify disconnected after the handover failure.
+        assertTrue(mDataNetworkControllerUT.areAllDataDisconnected(true));
+    }
+
+    @Test
+    public void testHandoverOnAnyCellularDataNetworkExistingChanged() throws Exception {
+        // Setup on WLAN
+        doReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN).when(mAccessNetworksManager)
+                .getPreferredTransportByNetworkCapability(NetworkCapabilities.NET_CAPABILITY_IMS);
+        mDataNetworkControllerUT.addNetworkRequest(
+                createNetworkRequest(NetworkCapabilities.NET_CAPABILITY_IMS,
+                        NetworkCapabilities.NET_CAPABILITY_MMTEL));
+        processAllMessages();
+
+        DataNetwork dataNetwork = getDataNetworks().get(0);
+        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, dataNetwork.getTransport());
+        verify(mMockedDataNetworkControllerCallback)
+                .onAnyDataNetworkExistingChanged(true, false);
+
+        // Change preferred transport to WWAN
+        Mockito.reset(mMockedWwanDataServiceManager);
+        updateTransport(NetworkCapabilities.NET_CAPABILITY_IMS,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
+
+        // Handing over from WLAN TO WWAN.
+        // Capture the message for setup data call response. We want to delay it.
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mMockedWwanDataServiceManager).setupDataCall(anyInt(), any(DataProfile.class),
+                anyBoolean(), anyBoolean(), anyInt(), any(), anyInt(), any(), any(), anyBoolean(),
+                messageCaptor.capture());
+
+        // Finally WWAN handover is completed with failure.
+        Message msg = messageCaptor.getValue();
+        DataCallResponse response = new DataCallResponse.Builder()
+                .setCause(DataFailCause.ERROR_UNSPECIFIED)
+                .setRetryDurationMillis(123)
+                .setHandoverFailureMode(
+                        DataCallResponse.HANDOVER_FAILURE_MODE_NO_FALLBACK_RETRY_SETUP_NORMAL)
+                .build();
+        msg.getData().putParcelable("data_call_response", response);
+        msg.arg1 = DataServiceCallback.RESULT_ERROR_UNSUPPORTED;
+        msg.sendToTarget();
+        processAllMessages();
+
+        // The expected cellular is aborted due to handover failure.
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(true, false);
     }
 
     @Test
     public void testNoGracefulTearDownForEmergencyDataNetwork() throws Exception {
-        setImsRegistered(true);
+        setImsRegistered(true, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
 
         mCarrierConfig.putStringArray(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY,
                 new String[]{"source=EUTRAN, target=IWLAN, type=disallowed, capabilities=EIMS|IMS",
@@ -4764,7 +4916,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
                 AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
 
         // Verify all data disconnected.
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
                 eq(DataCallResponse.LINK_STATUS_INACTIVE));
 
@@ -5342,7 +5494,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
                 TelephonyManager.SIM_STATE_ABSENT, 0).sendToTarget();
         processAllMessages();
         verifyAllDataDisconnected();
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
         verify(mMockedDataNetworkControllerCallback).onConnectedInternetDataNetworksChanged(
                 eq(Collections.emptySet()));
         verify(mMockedDataNetworkControllerCallback).onPhysicalLinkStatusChanged(
@@ -5933,10 +6085,10 @@ public class DataNetworkControllerTest extends TelephonyTest {
         testSetupDataNetwork();
         doReturn(true).when(mSST).isPendingRadioPowerOffAfterDataOff();
         mDataNetworkControllerUT.tearDownAllDataNetworks(
-                DataNetwork.TEAR_DOWN_REASON_AIRPLANE_MODE_ON);
+                DataNetwork.TEAR_DOWN_REASON_DEVICE_SHUT_DOWN);
         processAllMessages();
         verifyAllDataDisconnected();
-        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(eq(false));
+        verify(mMockedDataNetworkControllerCallback).onAnyDataNetworkExistingChanged(false, false);
 
         clearInvocations(mMockedDataNetworkControllerCallback);
         mDataNetworkControllerUT.addNetworkRequest(
@@ -5944,7 +6096,7 @@ public class DataNetworkControllerTest extends TelephonyTest {
         processAllMessages();
         verifyAllDataDisconnected();
         verify(mMockedDataNetworkControllerCallback, never()).onAnyDataNetworkExistingChanged(
-                anyBoolean());
+                anyBoolean(), anyBoolean());
     }
 
     @Test
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkTest.java
index 6e92353d1e..ba61fb4427 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataNetworkTest.java
@@ -24,6 +24,7 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.ArgumentMatchers.nullable;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.Mockito.atLeastOnce;
@@ -62,6 +63,7 @@ import android.telephony.LteVopsSupportInfo;
 import android.telephony.NetworkRegistrationInfo;
 import android.telephony.PreciseDataConnectionState;
 import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyDisplayInfo;
 import android.telephony.TelephonyManager;
 import android.telephony.data.ApnSetting;
@@ -283,6 +285,14 @@ public class DataNetworkTest extends TelephonyTest {
 
     private DataCallResponse createDataCallResponse(int cid, int linkStatus,
             List<TrafficDescriptor> tds, Qos defaultQos, int validationStatus) {
+        return createDataCallResponse(cid, linkStatus, tds, defaultQos, validationStatus,
+                AccessNetworkConstants.TRANSPORT_TYPE_INVALID,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX);
+    }
+
+    private DataCallResponse createDataCallResponse(int cid, int linkStatus,
+            List<TrafficDescriptor> tds, Qos defaultQos, int validationStatus,
+            int physicalNetworkTransportType, int physicalNetworkSlotIndex) {
         return new DataCallResponse.Builder()
                 .setCause(0)
                 .setRetryDurationMillis(-1L)
@@ -308,6 +318,8 @@ public class DataNetworkTest extends TelephonyTest {
                 .setTrafficDescriptors(tds)
                 .setDefaultQos(defaultQos)
                 .setNetworkValidationStatus(validationStatus)
+                .setPhysicalNetworkTransportType(physicalNetworkTransportType)
+                .setPhysicalNetworkSlotIndex(physicalNetworkSlotIndex)
                 .build();
     }
 
@@ -378,6 +390,30 @@ public class DataNetworkTest extends TelephonyTest {
         }
     }
 
+    private void verifyImsDataNetwork(int times, List<Integer> accessNetworks,
+            List<Integer> dataStates, List<Integer> physicalNetworkTransports,
+            List<Integer> physicalNetworkSlotIndexs) {
+        for (int i = 0; i < mDataServiceManagers.size(); i++) {
+            DataServiceManager dataServiceManager = mDataServiceManagers.valueAt(i);
+            ArgumentCaptor<Integer> accessNetwork = ArgumentCaptor.forClass(Integer.class);
+            ArgumentCaptor<Integer> dataState = ArgumentCaptor.forClass(Integer.class);
+            ArgumentCaptor<Integer> transport = ArgumentCaptor.forClass(Integer.class);
+            ArgumentCaptor<Integer> phoneId = ArgumentCaptor.forClass(Integer.class);
+            verify(dataServiceManager, times(times)).notifyImsDataNetwork(
+                    accessNetwork.capture(), dataState.capture(), transport.capture(),
+                    phoneId.capture(), isNull());
+            List<Integer> capturedAccessNetworks = accessNetwork.getAllValues();
+            List<Integer> capturedDataStates = dataState.getAllValues();
+            List<Integer> capturedTransports = transport.getAllValues();
+            List<Integer> capturedSlotIndexs = phoneId.getAllValues();
+            for (int j = 0; j < times; j++) {
+                assertThat(capturedAccessNetworks.get(j)).isEqualTo(accessNetworks.get(j));
+                assertThat(capturedDataStates.get(j)).isEqualTo(dataStates.get(j));
+                assertThat(capturedTransports.get(j)).isEqualTo(physicalNetworkTransports.get(j));
+                assertThat(capturedSlotIndexs.get(j)).isEqualTo(physicalNetworkSlotIndexs.get(j));
+            }
+        }
+    }
 
     @Before
     public void setUp() throws Exception {
@@ -560,7 +596,10 @@ public class DataNetworkTest extends TelephonyTest {
                 argThat(caps -> caps.hasCapability(
                         NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED)),
                 any());
-
+        verify(mMockedWwanDataServiceManager, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), isNull());
+        verify(mMockedWlanDataServiceManager, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), isNull());
         verify(mDataNetworkCallback).onConnected(eq(mDataNetworkUT));
     }
 
@@ -772,7 +811,10 @@ public class DataNetworkTest extends TelephonyTest {
                 NetworkCapabilities.NET_CAPABILITY_IMS)).isTrue();
         assertThat(mDataNetworkUT.getNetworkCapabilities().hasCapability(
                 NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)).isFalse();
-
+        verifyImsDataNetwork(2, List.of(AccessNetworkType.EUTRAN, AccessNetworkType.EUTRAN),
+                List.of(TelephonyManager.DATA_CONNECTING, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN), List.of(0, 0));
         verify(mDataNetworkCallback).onConnected(eq(mDataNetworkUT));
     }
 
@@ -1055,7 +1097,12 @@ public class DataNetworkTest extends TelephonyTest {
                 NetworkCapabilities.NET_CAPABILITY_IMS)).isTrue();
         assertThat(mDataNetworkUT.getNetworkCapabilities().hasCapability(
                 NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)).isFalse();
-
+        verifyImsDataNetwork(2, List.of(AccessNetworkType.IWLAN, AccessNetworkType.IWLAN),
+                List.of(TelephonyManager.DATA_CONNECTING, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
+                List.of(SubscriptionManager.INVALID_SIM_SLOT_INDEX,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX));
         verify(mDataNetworkCallback).onConnected(eq(mDataNetworkUT));
     }
 
@@ -1089,6 +1136,106 @@ public class DataNetworkTest extends TelephonyTest {
         assertThat(pdcsList.get(3).getNetworkType()).isEqualTo(TelephonyManager.NETWORK_TYPE_IWLAN);
         assertThat(pdcsList.get(3).getTransportType())
                 .isEqualTo(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
+        verifyImsDataNetwork(4, List.of(AccessNetworkType.IWLAN, AccessNetworkType.IWLAN,
+                AccessNetworkType.IWLAN, AccessNetworkType.IWLAN),
+                List.of(TelephonyManager.DATA_CONNECTING, TelephonyManager.DATA_CONNECTED,
+                TelephonyManager.DATA_DISCONNECTING, TelephonyManager.DATA_DISCONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
+                List.of(SubscriptionManager.INVALID_SIM_SLOT_INDEX,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX));
+    }
+
+    @Test
+    public void testImsDataNetworkFlagDisabled() throws Exception {
+        doReturn(false).when(mFeatureFlags).dataServiceNotifyImsDataNetwork();
+        createImsDataNetwork(true/*isMmtel*/);
+        verify(mMockedWwanDataServiceManager, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), isNull());
+        verify(mMockedWlanDataServiceManager, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), isNull());
+    }
+
+    @Test
+    public void testImsDataNetwork_HandoverSuccess() throws Exception {
+        createImsDataNetwork(true/*isMmtel*/);
+        setSuccessfulSetupDataResponse(mMockedWlanDataServiceManager, 456);
+        // Now handover to IWLAN
+        mDataNetworkUT.startHandover(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, null);
+        processAllMessages();
+        verifyImsDataNetwork(3, List.of(AccessNetworkType.EUTRAN, AccessNetworkType.EUTRAN,
+                AccessNetworkType.IWLAN), List.of(TelephonyManager.DATA_CONNECTING,
+                TelephonyManager.DATA_CONNECTED, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
+                List.of(0, 0, SubscriptionManager.INVALID_SIM_SLOT_INDEX));
+
+        // Now handover back to cellular
+        Mockito.clearInvocations(mMockedWwanDataServiceManager);
+        Mockito.clearInvocations(mMockedWlanDataServiceManager);
+        mDataNetworkUT.startHandover(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, null);
+        processAllFutureMessages();
+        verifyImsDataNetwork(1, List.of(AccessNetworkType.EUTRAN),
+                List.of(TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WWAN), List.of(0));
+    }
+
+    @Test
+    public void testImsDataNetwork_HandoverFailure() throws Exception {
+        createImsDataNetwork(true/*isMmtel*/);
+        setFailedSetupDataResponse(mMockedWlanDataServiceManager,
+                DataServiceCallback.RESULT_ERROR_TEMPORARILY_UNAVAILABLE);
+        // Now attempt to handover to IWLAN but fail it.
+        mDataNetworkUT.startHandover(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, null);
+        processAllMessages();
+        verifyImsDataNetwork(3, List.of(AccessNetworkType.EUTRAN, AccessNetworkType.EUTRAN,
+                AccessNetworkType.EUTRAN), List.of(TelephonyManager.DATA_CONNECTING,
+                TelephonyManager.DATA_CONNECTED, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN), List.of(0, 0, 0));
+    }
+
+    @Test
+    public void testImsDataNetwork_IwlanMobility() throws Exception {
+        testCreateDataNetworkOnIwlan();
+        // Physical network transport and physical network slot index change
+        DataCallResponse response = createDataCallResponse(
+                    123, DataCallResponse.LINK_STATUS_ACTIVE, Collections.emptyList(), null,
+                    PreciseDataConnectionState.NETWORK_VALIDATION_UNSUPPORTED,
+                    AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 1);
+        mDataNetworkUT.obtainMessage(8/*EVENT_DATA_STATE_CHANGED*/,
+                new AsyncResult(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                        List.of(response), null)).sendToTarget();
+        processAllMessages();
+        verifyImsDataNetwork(3, List.of(AccessNetworkType.IWLAN, AccessNetworkType.IWLAN,
+                AccessNetworkType.IWLAN), List.of(TelephonyManager.DATA_CONNECTING,
+                TelephonyManager.DATA_CONNECTED, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN),
+                List.of(SubscriptionManager.INVALID_SIM_SLOT_INDEX,
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX, 1));
+    }
+
+    @Test
+    public void testImsDataNetwork_AccessNetworkChange() throws Exception {
+        testCreateImsDataNetwork();
+        // Access network change
+        serviceStateChanged(TelephonyManager.NETWORK_TYPE_NR,
+                NetworkRegistrationInfo.REGISTRATION_STATE_HOME, /*isNtn=*/false);
+        processAllMessages();
+        verifyImsDataNetwork(3, List.of(AccessNetworkType.EUTRAN, AccessNetworkType.EUTRAN,
+                AccessNetworkType.NGRAN), List.of(TelephonyManager.DATA_CONNECTING,
+                TelephonyManager.DATA_CONNECTED, TelephonyManager.DATA_CONNECTED),
+                List.of(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN), List.of(0, 0, 0));
     }
 
     @Test
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataServiceManagerTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataServiceManagerTest.java
index 30f49ad63b..9595e2e76e 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataServiceManagerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataServiceManagerTest.java
@@ -22,6 +22,7 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
@@ -33,6 +34,8 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.PersistableBundle;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.AccessNetworkConstants.AccessNetworkType;
 import android.telephony.TelephonyManager;
@@ -45,9 +48,11 @@ import android.testing.TestableLooper;
 
 import com.android.internal.R;
 import com.android.internal.telephony.TelephonyTest;
+import com.android.internal.telephony.flags.Flags;
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -58,6 +63,9 @@ import java.util.List;
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper
 public class DataServiceManagerTest extends TelephonyTest {
+    @Rule
+    public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
     private final DataProfile mGeneralPurposeDataProfile = new DataProfile.Builder()
             .setApnSetting(new ApnSetting.Builder()
                     .setId(2163)
@@ -120,6 +128,7 @@ public class DataServiceManagerTest extends TelephonyTest {
         Field field = DataService.class.getDeclaredField("mHandler");
         field.setAccessible(true);
         mDataServiceHandler = (Handler) field.get(mCellularDataService);
+        monitorTestableLooper(new TestableLooper(mDataServiceHandler.getLooper()));
 
         ServiceInfo serviceInfo = new ServiceInfo();
         serviceInfo.packageName = "com.android.phone";
@@ -134,11 +143,10 @@ public class DataServiceManagerTest extends TelephonyTest {
                 filter);
 
         mDataServiceManagerUT = new DataServiceManager(mPhone, Looper.myLooper(),
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mFeatureFlags);
     }
 
     private void waitAndVerifyResult(Message message, int resultCode) {
-        waitForLastHandlerAction(mDataServiceHandler);
         processAllMessages();
 
         ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
@@ -283,4 +291,110 @@ public class DataServiceManagerTest extends TelephonyTest {
         mDataServiceManagerUT.requestNetworkValidation(123, message);
         waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
     }
+
+    @Test
+    public void testNotifyUserDataEnabled_FlagDisabled() throws Exception {
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+        verify(mSimulatedCommandsVerifier, never()).setUserDataRoamingEnabled(any(Message.class),
+                anyBoolean());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_USER_DATA_TOGGLE_NOTIFY)
+    public void testNotifyUserDataEnabled_ServiceNotBound() throws Exception {
+        doReturn(true).when(mFeatureFlags).dataServiceUserDataToggleNotify();
+        createDataServiceManager(false);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        verify(mSimulatedCommandsVerifier, never()).setUserDataRoamingEnabled(any(Message.class),
+                anyBoolean());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_USER_DATA_TOGGLE_NOTIFY)
+    public void testNotifyUserDataEnabled_FlagEnabled() throws Exception {
+        doReturn(true).when(mFeatureFlags).dataServiceUserDataToggleNotify();
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_SUCCESS);
+        verify(mSimulatedCommandsVerifier).setUserDataEnabled(any(Message.class), anyBoolean());
+    }
+
+    @Test
+    public void testNotifyUserDataRoamingEnabled_FlagDisabled() throws Exception {
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataRoamingEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+        verify(mSimulatedCommandsVerifier, never()).setUserDataRoamingEnabled(any(Message.class),
+                anyBoolean());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_USER_DATA_TOGGLE_NOTIFY)
+    public void testNotifyUserDataRoamingEnabled_ServiceNotBound() throws Exception {
+        doReturn(true).when(mFeatureFlags).dataServiceUserDataToggleNotify();
+        createDataServiceManager(false);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataRoamingEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        verify(mSimulatedCommandsVerifier, never()).setUserDataRoamingEnabled(any(Message.class),
+                anyBoolean());
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_USER_DATA_TOGGLE_NOTIFY)
+    public void testNotifyUserDataRoamingEnabled_FlagEnabled() throws Exception {
+        doReturn(true).when(mFeatureFlags).dataServiceUserDataToggleNotify();
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyUserDataRoamingEnabled(true, message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_SUCCESS);
+        verify(mSimulatedCommandsVerifier).setUserDataRoamingEnabled(any(Message.class),
+                anyBoolean());
+    }
+
+    @Test
+    public void testNotifyImsDataNetwork_FlagDisabled() throws Exception {
+        doReturn(false).when(mFeatureFlags).dataServiceNotifyImsDataNetwork();
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyImsDataNetwork(AccessNetworkType.EUTRAN,
+                TelephonyManager.DATA_CONNECTED, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0,
+                message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_UNSUPPORTED);
+        verify(mSimulatedCommandsVerifier, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), any(Message.class));
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_NOTIFY_IMS_DATA_NETWORK)
+    public void testNotifyImsDataNetwork_ServiceNotBound() throws Exception {
+        createDataServiceManager(false);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyImsDataNetwork(AccessNetworkType.EUTRAN,
+                TelephonyManager.DATA_CONNECTED, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0,
+                message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_ERROR_ILLEGAL_STATE);
+        verify(mSimulatedCommandsVerifier, never()).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), any(Message.class));
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_DATA_SERVICE_NOTIFY_IMS_DATA_NETWORK)
+    public void testNotifyImsDataNetwork_FlagEnabled() throws Exception {
+        createDataServiceManager(true);
+        Message message = mHandler.obtainMessage(1234);
+        mDataServiceManagerUT.notifyImsDataNetwork(AccessNetworkType.EUTRAN,
+                TelephonyManager.DATA_CONNECTED, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0,
+                message);
+        waitAndVerifyResult(message, DataServiceCallback.RESULT_SUCCESS);
+        verify(mSimulatedCommandsVerifier).notifyImsDataNetwork(anyInt(), anyInt(),
+                anyInt(), anyInt(), any(Message.class));
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataSettingsManagerTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataSettingsManagerTest.java
index 620cf3991f..3820a19efb 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataSettingsManagerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataSettingsManagerTest.java
@@ -21,8 +21,11 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.never;
@@ -33,9 +36,11 @@ import android.annotation.NonNull;
 import android.os.Looper;
 import android.os.Message;
 import android.os.PersistableBundle;
+import android.telephony.AccessNetworkConstants;
 import android.telephony.TelephonyManager;
 import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
+import android.util.SparseArray;
 
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneFactory;
@@ -51,6 +56,7 @@ import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -65,6 +71,7 @@ public class DataSettingsManagerTest extends TelephonyTest {
 
     DataSettingsManager mDataSettingsManagerUT;
     PersistableBundle mBundle;
+    List<DataServiceManager> mMockDataServiceManagers;
 
     @Before
     public void setUp() throws Exception {
@@ -72,12 +79,23 @@ public class DataSettingsManagerTest extends TelephonyTest {
         super.setUp(getClass().getSimpleName());
         mMockedDataSettingsManagerCallback = Mockito.mock(DataSettingsManagerCallback.class);
         mBundle = mContextFixture.getCarrierConfigBundle();
+        mMockDataServiceManagers = List.of(
+                mMockedWwanDataServiceManager,
+                mMockedWlanDataServiceManager
+        );
+        SparseArray<DataServiceManager> mMockDataServiceManagerSparseArray = new SparseArray<>();
+        mMockDataServiceManagerSparseArray.put(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
+                mMockedWwanDataServiceManager);
+        mMockDataServiceManagerSparseArray.put(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
+                mMockedWlanDataServiceManager);
         doReturn(true).when(mDataConfigManager).isConfigCarrierSpecific();
+        doReturn(true).when(mFeatureFlags).dataServiceUserDataToggleNotify();
 
         doReturn(new SubscriptionInfoInternal.Builder().setId(1).build())
                 .when(mSubscriptionManagerService).getSubscriptionInfoInternal(anyInt());
 
         mDataSettingsManagerUT = new DataSettingsManager(mPhone, mDataNetworkController,
+                mMockDataServiceManagerSparseArray,
                 mFeatureFlags, Looper.myLooper(), mMockedDataSettingsManagerCallback);
         logd("DataSettingsManagerTest -Setup!");
     }
@@ -123,15 +141,33 @@ public class DataSettingsManagerTest extends TelephonyTest {
     @Test
     public void testDefaultDataRoamingEnabled() {
         doReturn(true).when(mDataConfigManager).isDataRoamingEnabledByDefault();
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
         mDataSettingsManagerUT.setDefaultDataRoamingEnabled();
         assertTrue(mDataSettingsManagerUT.isDataRoamingEnabled());
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            // should notify the default data roaming
+            verify(mockDataServiceManager,
+                    times(1)).notifyUserDataRoamingEnabled(eq(true),
+                    isNull());
+            clearInvocations(mockDataServiceManager);
+        });
 
         mDataSettingsManagerUT.setDataRoamingEnabled(false);
         processAllMessages();
         assertFalse(mDataSettingsManagerUT.isDataRoamingEnabled());
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager,
+                    times(1)).notifyUserDataRoamingEnabled(eq(false),
+                    isNull());
+            clearInvocations(mockDataServiceManager);
+        });
 
         mDataSettingsManagerUT.setDefaultDataRoamingEnabled();
         assertFalse(mDataSettingsManagerUT.isDataRoamingEnabled());
+        // Should not notify data service manager when there have no changes
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> verify(mockDataServiceManager,
+                never()).notifyUserDataRoamingEnabled(anyBoolean(),
+                isNull()));
     }
 
     @Test
@@ -227,6 +263,128 @@ public class DataSettingsManagerTest extends TelephonyTest {
         verify(mPhone).notifyDataEnabled(false, TelephonyManager.DATA_ENABLED_REASON_OVERRIDE);
     }
 
+    @Test
+    public void testUpdateDataEnabledAndNotifyDataService() throws Exception {
+        // Mock 2nd phone the DDS phone.
+        int phone2Id = 1;
+        int phone2SubId = 2;
+        doReturn(phone2SubId).when(mSubscriptionManagerService).getDefaultDataSubId();
+        Phone phone2 = Mockito.mock(Phone.class);
+        doReturn(phone2Id).when(phone2).getPhoneId();
+        doReturn(phone2SubId).when(phone2).getSubId();
+        doReturn(phone2Id).when(mSubscriptionManagerService).getPhoneId(phone2SubId);
+        DataSettingsManager dataSettingsManager2 = Mockito.mock(DataSettingsManager.class);
+        doReturn(dataSettingsManager2).when(phone2).getDataSettingsManager();
+        doReturn(true).when(phone2).isUserDataEnabled();
+
+        mPhones = new Phone[]{mPhone, phone2};
+        replaceInstance(PhoneFactory.class, "sPhones", null, mPhones);
+
+        processAllMessages();
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+        mDataSettingsManagerUT.sendEmptyMessage(11 /* EVENT_INITIALIZE */);
+        processAllMessages();
+        // Verify notified user data enabling state to data service manager when initialize
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager, times(1)).notifyUserDataEnabled(eq(true),
+                    isNull());
+            clearInvocations(mockDataServiceManager);
+        });
+
+        mDataSettingsManagerUT.setDataEnabled(TelephonyManager.DATA_ENABLED_REASON_USER, false, "");
+        processAllMessages();
+        // Verify notified user data enabling state to data service manager when data disabled
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager, times(1)).notifyUserDataEnabled(eq(false),
+                    isNull());
+            clearInvocations(mockDataServiceManager);
+        });
+
+        mDataSettingsManagerUT.setDataEnabled(TelephonyManager.DATA_ENABLED_REASON_USER, true, "");
+        processAllMessages();
+        // Verify notified user data enabling state to data service manager when data enabled
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager, times(1)).notifyUserDataEnabled(eq(true),
+                    isNull());
+            clearInvocations(mockDataServiceManager);
+        });
+    }
+
+    @Test
+    public void testInitializeNotifyDataServiceUserDataEnabled() throws Exception {
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            // After initialize, should notify data service the current data & roaming enabled state
+            verify(mockDataServiceManager, times(1)).notifyUserDataEnabled(eq(true),
+                    isNull());
+            verify(mockDataServiceManager, times(1)).notifyUserDataRoamingEnabled(anyBoolean(),
+                    isNull());
+        });
+    }
+
+    @Test
+    public void testNotifyDataServiceUserDataEnabledWhenSimStateChanged() {
+        processAllMessages();
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+
+        var dataNetworkControllerCallbackArgumentCaptor = ArgumentCaptor.forClass(
+                DataNetworkController.DataNetworkControllerCallback.class);
+        verify(mDataNetworkController).registerDataNetworkControllerCallback(
+                dataNetworkControllerCallbackArgumentCaptor.capture());
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+        // Sim absent should not trigger notify
+        dataNetworkControllerCallbackArgumentCaptor.getValue().onSimStateChanged(
+                TelephonyManager.SIM_STATE_ABSENT);
+        processAllMessages();
+
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager, never()).notifyUserDataRoamingEnabled(anyBoolean(),
+                    any());
+            verify(mockDataServiceManager, never()).notifyUserDataEnabled(anyBoolean(), any());
+        });
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+        // Sim loaded should trigger notify
+        dataNetworkControllerCallbackArgumentCaptor.getValue().onSimStateChanged(
+                TelephonyManager.SIM_STATE_LOADED);
+        processAllMessages();
+
+        mMockDataServiceManagers.forEach(mockDataServiceManager -> {
+            verify(mockDataServiceManager, times(1)).notifyUserDataRoamingEnabled(eq(false),
+                    isNull());
+            verify(mockDataServiceManager, times(1)).notifyUserDataEnabled(eq(true),
+                    isNull());
+        });
+    }
+
+    @Test
+    public void testNotifyCorrespondingDataServiceUserDataEnabledWhenDataServiceBound() {
+        processAllMessages();
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+        var dataNetworkControllerCallbackArgumentCaptor = ArgumentCaptor.forClass(
+                DataNetworkController.DataNetworkControllerCallback.class);
+        verify(mDataNetworkController).registerDataNetworkControllerCallback(
+                dataNetworkControllerCallbackArgumentCaptor.capture());
+        mMockDataServiceManagers.forEach(Mockito::clearInvocations);
+
+        dataNetworkControllerCallbackArgumentCaptor.getValue().onDataServiceBound(
+                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
+        processAllMessages();
+
+        // Notify the bound data service manager
+        verify(mMockedWwanDataServiceManager, times(1)).notifyUserDataRoamingEnabled(eq(false),
+                isNull());
+        verify(mMockedWwanDataServiceManager, times(1)).notifyUserDataEnabled(eq(true),
+                isNull());
+        // Should not notify another data service manager
+        verify(mMockedWlanDataServiceManager, never()).notifyUserDataRoamingEnabled(anyBoolean(),
+                any());
+        verify(mMockedWlanDataServiceManager, never()).notifyUserDataEnabled(anyBoolean(), any());
+    }
+
     @Test
     public void testNotifyDataEnabledFromNewValidSubId() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/DataStallRecoveryManagerTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/DataStallRecoveryManagerTest.java
index 8cbd61fc7e..ded0427ccb 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/DataStallRecoveryManagerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/DataStallRecoveryManagerTest.java
@@ -26,7 +26,9 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.content.Intent;
 import android.database.ContentObserver;
 import android.net.NetworkAgent;
@@ -47,15 +49,15 @@ import com.android.internal.telephony.data.DataNetworkController.DataNetworkCont
 import com.android.internal.telephony.data.DataSettingsManager.DataSettingsManagerCallback;
 import com.android.internal.telephony.data.DataStallRecoveryManager.DataStallRecoveryManagerCallback;
 
+import java.lang.reflect.Field;
+import java.util.Set;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 
-import java.lang.reflect.Field;
-import java.util.Set;
-
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper
 public class DataStallRecoveryManagerTest extends TelephonyTest {
@@ -92,6 +94,9 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
         Field field = DataStallRecoveryManager.class.getDeclaredField("mPredictWaitingMillis");
         field.setAccessible(true);
 
+        // Mock TelecomManager
+        when(mContext.getSystemService(Context.TELECOM_SERVICE)).thenReturn(mTelecomManager);
+
         mFakeContentResolver = new FakeContentResolver();
         doReturn(mFakeContentResolver).when(mContext).getContentResolver();
         // Set the global settings for action enabled state and duration to
@@ -129,6 +134,9 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
         field.set(mDataStallRecoveryManager, 0L);
 
+        doReturn(false).when(mTelecomManager).isInEmergencyCall();
+        doReturn(false).when(mPhone).isInEcm();
+
         logd("DataStallRecoveryManagerTest -Setup!");
     }
 
@@ -183,6 +191,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testRecoveryStepPDPReset() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(1);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -197,6 +206,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testRecoveryStepRestartRadio() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(3);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -211,6 +221,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testRecoveryStepModemReset() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(4);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -226,6 +237,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testDoNotDoRecoveryActionWhenPoorSignal() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(3);
         doReturn(1).when(mSignalStrength).getLevel();
@@ -242,6 +254,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testDoNotDoRecoveryActionWhenDialCall() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(3);
         doReturn(3).when(mSignalStrength).getLevel();
@@ -360,6 +373,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testDoNotDoRecoveryWhenDataNoService() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(1);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -375,6 +389,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testDoNotDoRecoveryWhenDataNetworkNotConnected() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(1);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -434,6 +449,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
     public void testSendDSRMData() throws Exception {
         ArgumentCaptor<Intent> captorIntent = ArgumentCaptor.forClass(Intent.class);
 
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         logd("Set phone status to normal status.");
         sendOnInternetDataNetworkCallback(true);
         doReturn(mSignalStrength).when(mPhone).getSignalStrength();
@@ -447,7 +463,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
         processAllFutureMessages();
 
         logd("Verify that the DataStallRecoveryManager sends the expected intents.");
-        verify(mPhone.getContext(), times(3)).sendBroadcast(captorIntent.capture());
+        verify(mPhone.getContext(), times(4)).sendBroadcast(captorIntent.capture());
         logd(captorIntent.getAllValues().toString());
         for (int i = 0; i < captorIntent.getAllValues().size(); i++) {
             Intent intent = captorIntent.getAllValues().get(i);
@@ -585,6 +601,7 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
 
     @Test
     public void testDoNotDoRecoveryActionWhenActiveCall() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
         sendOnInternetDataNetworkCallback(true);
         mDataStallRecoveryManager.setRecoveryAction(
                 DataStallRecoveryManager.RECOVERY_ACTION_RADIO_RESTART);
@@ -602,4 +619,128 @@ public class DataStallRecoveryManagerTest extends TelephonyTest {
         assertThat(mDataStallRecoveryManager.getRecoveryAction())
                 .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_RADIO_RESTART);
     }
+
+    // set private boolean field using reflection
+    private void setPrivateBooleanField(Object obj, String fieldName, boolean value)
+            throws Exception {
+        Field field = obj.getClass().getDeclaredField(fieldName);
+        field.setAccessible(true);
+        field.setBoolean(obj, value);
+    }
+
+    // get private boolean field using reflection
+    private boolean getPrivateBooleanField(Object obj, String fieldName) throws Exception {
+        Field field = obj.getClass().getDeclaredField(fieldName);
+        field.setAccessible(true);
+        return field.getBoolean(obj);
+    }
+
+    /**
+     * Test that setRecoveryAction is skipped if the network is invalid and recovery has not yet
+     * started.
+     */
+    @Test
+    public void testSetRecoveryAction_skipWhenInvalidNetworkAndNotStarted() throws Exception {
+        // Ensure initial state has recovery not started
+        assertThat(mDataStallRecoveryManager.getRecoveryAction())
+                .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_GET_DATA_CALL_LIST);
+        assertThat(getPrivateBooleanField(mDataStallRecoveryManager, "mRecoveryTriggered"))
+                .isFalse();
+
+        // set network state to invalid
+        setPrivateBooleanField(mDataStallRecoveryManager, "mIsValidNetwork", false);
+
+        mDataStallRecoveryManager.setRecoveryAction(
+                DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+        processAllMessages();
+
+        // Verify that the recovery action was NOT changed.
+        assertThat(mDataStallRecoveryManager.getRecoveryAction())
+                .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_GET_DATA_CALL_LIST);
+    }
+
+    /** Test that the DSRM state is reset when the SIM state changes to ABSENT. */
+    @Test
+    public void testOnSimStateChanged_absentResetsState() throws Exception {
+        ArgumentCaptor<DataNetworkControllerCallback> dataNetworkControllerCallbackCaptor =
+                ArgumentCaptor.forClass(DataNetworkControllerCallback.class);
+        verify(mDataNetworkController, times(2))
+                .registerDataNetworkControllerCallback(
+                        dataNetworkControllerCallbackCaptor.capture());
+        DataNetworkControllerCallback callback =
+                dataNetworkControllerCallbackCaptor.getAllValues().get(0);
+        assertNotNull(callback);
+
+        // Set network to valid initially
+        setPrivateBooleanField(mDataStallRecoveryManager, "mIsValidNetwork", true);
+        mDataStallRecoveryManager.setRecoveryAction(
+                DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+        setPrivateBooleanField(mDataStallRecoveryManager, "mRecoveryTriggered", true);
+        setPrivateBooleanField(mDataStallRecoveryManager, "mDataStalled", true);
+        assertThat(mDataStallRecoveryManager.getRecoveryAction())
+                .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+        assertThat(getPrivateBooleanField(mDataStallRecoveryManager, "mIsValidNetwork")).isTrue();
+
+        // Trigger the onSimStateChanged callback with SIM_STATE_ABSENT
+        logd("Simulating SIM_STATE_ABSENT");
+        callback.onSimStateChanged(TelephonyManager.SIM_STATE_ABSENT);
+        processAllMessages(); // Process messages potentially posted by reset()
+
+        assertThat(getPrivateBooleanField(mDataStallRecoveryManager, "mIsValidNetwork")).isFalse();
+    }
+
+    @Test
+    public void testDoNotDoRecoveryActionWhenInEmergencyCall() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
+        sendOnInternetDataNetworkCallback(true);
+        mDataStallRecoveryManager.setRecoveryAction(
+                DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+        doReturn(mSignalStrength).when(mPhone).getSignalStrength();
+        doReturn(3).when(mSignalStrength).getLevel();
+        doReturn(PhoneConstants.State.IDLE).when(mPhone).getState();
+        doReturn(true).when(mDataNetworkController).isInternetDataAllowed(true);
+        // set not in ECM
+        doReturn(false).when(mPhone).isInEcm();
+        // set in emergency call
+        doReturn(true).when(mTelecomManager).isInEmergencyCall();
+        logd("Sending validation failed callback while in emergency call");
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_NOT_VALID);
+        processAllFutureMessages();
+
+        verify(mDataStallRecoveryManagerCallback, never()).onDataStallReestablishInternet();
+        verify(mSST, never()).powerOffRadioSafely();
+        verify(mPhone, never()).rebootModem(any());
+
+        // Still at cleanup
+        assertThat(mDataStallRecoveryManager.getRecoveryAction())
+                .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+    }
+    @Test
+    public void testDoNotDoRecoveryActionWhenInEcm() throws Exception {
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_VALID);
+        sendOnInternetDataNetworkCallback(true);
+        mDataStallRecoveryManager.setRecoveryAction(
+                DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+        doReturn(mSignalStrength).when(mPhone).getSignalStrength();
+        doReturn(3).when(mSignalStrength).getLevel();
+        doReturn(PhoneConstants.State.IDLE).when(mPhone).getState();
+        doReturn(true).when(mDataNetworkController).isInternetDataAllowed(true);
+        // set in ECM
+        doReturn(true).when(mPhone).isInEcm();
+        // set not in emergency call
+        doReturn(false).when(mTelecomManager).isInEmergencyCall();
+        logd("Sending validation failed callback while in ECM");
+
+        sendValidationStatusCallback(NetworkAgent.VALIDATION_STATUS_NOT_VALID);
+        processAllFutureMessages();
+
+        verify(mDataStallRecoveryManagerCallback, never()).onDataStallReestablishInternet();
+        verify(mSST, never()).powerOffRadioSafely();
+        verify(mPhone, never()).rebootModem(any());
+
+        // Still at cleanup
+        assertThat(mDataStallRecoveryManager.getRecoveryAction())
+                .isEqualTo(DataStallRecoveryManager.RECOVERY_ACTION_CLEANUP);
+    }
+
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/data/PhoneSwitcherTest.java b/tests/telephonytests/src/com/android/internal/telephony/data/PhoneSwitcherTest.java
index e9b1cdfd7d..d56c9da39c 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/data/PhoneSwitcherTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/data/PhoneSwitcherTest.java
@@ -193,7 +193,6 @@ public class PhoneSwitcherTest extends TelephonyTest {
         mServiceManagerMockedServices.put("isub", mIBinder);
 
         doReturn(mTelephonyDisplayInfo).when(mDisplayInfoController).getTelephonyDisplayInfo();
-        doReturn(true).when(mFeatureFlags).ddsCallback();
     }
 
     @After
diff --git a/tests/telephonytests/src/com/android/internal/telephony/emergency/EmergencyStateTrackerTest.java b/tests/telephonytests/src/com/android/internal/telephony/emergency/EmergencyStateTrackerTest.java
index d50e781f2c..dd531aa660 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/emergency/EmergencyStateTrackerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/emergency/EmergencyStateTrackerTest.java
@@ -1601,6 +1601,39 @@ public class EmergencyStateTrackerTest extends TelephonyTest {
                 Integer.valueOf(DisconnectCause.NOT_DISCONNECTED));
     }
 
+    @Test
+    @SmallTest
+    public void testStartEmergencySmsWhileRadioOff() {
+        EmergencyStateTracker emergencyStateTracker = setupEmergencyStateTracker(
+                /* isSuplDdsSwitchRequiredForEmergencyCall= */ true);
+        Phone phone0 = setupTestPhoneForEmergencyCall(/* isRoaming= */ false,
+                /* isRadioOn= */ false);
+        CompletableFuture<Integer> future = emergencyStateTracker.startEmergencySms(phone0,
+                TEST_SMS_ID, false);
+
+        assertTrue(future.isDone());
+        // Returns DisconnectCause#POWER_OFF immediately.
+        assertEquals(future.getNow(DisconnectCause.ERROR_UNSPECIFIED),
+                Integer.valueOf(DisconnectCause.POWER_OFF));
+    }
+
+    @Test
+    @SmallTest
+    public void testStartEmergencySmsWhileRadioBeingTurnedOff() {
+        EmergencyStateTracker emergencyStateTracker = setupEmergencyStateTracker(
+                /* isSuplDdsSwitchRequiredForEmergencyCall= */ true);
+        Phone phone0 = setupTestPhoneForEmergencyCall(/* isRoaming= */ false,
+                /* isRadioOn= */ true);
+        when(mSST.getDesiredPowerState()).thenReturn(false);
+        CompletableFuture<Integer> future = emergencyStateTracker.startEmergencySms(phone0,
+                TEST_SMS_ID, false);
+
+        assertTrue(future.isDone());
+        // Returns DisconnectCause#POWER_OFF immediately.
+        assertEquals(future.getNow(DisconnectCause.ERROR_UNSPECIFIED),
+                Integer.valueOf(DisconnectCause.POWER_OFF));
+    }
+
     @Test
     @SmallTest
     public void testStartEmergencyCallActiveAndSmsOnSamePhone() {
@@ -3296,6 +3329,8 @@ public class EmergencyStateTrackerTest extends TelephonyTest {
 
         // Airplane mode is ON, but radio power state is still ON
         Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 1);
+        // Radio is being turning off.
+        when(mSST.getDesiredPowerState()).thenReturn(false);
 
         CompletableFuture<Integer> unused = emergencyStateTracker.startEmergencyCall(testPhone,
                 mTestConnection1, false);
@@ -3694,6 +3729,7 @@ public class EmergencyStateTrackerTest extends TelephonyTest {
         doReturn(2).when(mTelephonyManagerProxy).getPhoneCount();
         when(mPhoneFactoryProxy.getPhones()).thenReturn(phones.toArray(new Phone[phones.size()]));
         testPhone0.getServiceState().setRoaming(isRoaming);
+        when(mSST.getDesiredPowerState()).thenReturn(isRadioOn);
         return testPhone0;
     }
 
diff --git a/tests/telephonytests/src/com/android/internal/telephony/euicc/EuiccControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/euicc/EuiccControllerTest.java
index 4ff13de740..f2111e8927 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/euicc/EuiccControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/euicc/EuiccControllerTest.java
@@ -1097,21 +1097,21 @@ public class EuiccControllerTest extends TelephonyTest {
     public void testDeleteSubscription_adminOwned_success() throws Exception {
         setHasWriteEmbeddedPermission(false);
         setHasManageDevicePolicyManagedSubscriptionsPermission(true);
-        String callingPackage = "whatever";
         SubscriptionInfo subInfo1 = new SubscriptionInfo.Builder()
                 .setId(SUBSCRIPTION_ID)
                 .setEmbedded(true)
                 .setIccId(ICC_ID)
                 .setCardId(CARD_ID)
                 .setPortIndex(TelephonyManager.DEFAULT_PORT_INDEX)
-                .setGroupOwner(callingPackage)
                 .build();
         ArrayList<SubscriptionInfo> subInfos = new ArrayList<>(Arrays.asList(subInfo1));
+        doReturn(true).when(mDevicePolicyManager).isSubscriptionEnterpriseManaged(eq(subInfo1),
+                anyString());
         when(mSubscriptionManager.getAvailableSubscriptionInfoList()).thenReturn(subInfos);
 
         callDeleteSubscription(
                 SUBSCRIPTION_ID, ICC_ID, true /* complete */,
-                0 /* result */, callingPackage /* callingPackage */);
+                0 /* result */, "whatever" /* callingPackage */);
 
         verifyIntentSent(EuiccManager.EMBEDDED_SUBSCRIPTION_RESULT_OK,
                 0 /* detailedCode */);
@@ -1121,21 +1121,21 @@ public class EuiccControllerTest extends TelephonyTest {
     public void testDeleteSubscription_adminOwned_noPermissions_error() throws Exception {
         setHasWriteEmbeddedPermission(false);
         setHasManageDevicePolicyManagedSubscriptionsPermission(false);
-        String callingPackage = "whatever";
         SubscriptionInfo subInfo1 = new SubscriptionInfo.Builder()
                 .setId(SUBSCRIPTION_ID)
                 .setEmbedded(true)
                 .setIccId(ICC_ID)
                 .setCardId(CARD_ID)
                 .setPortIndex(TelephonyManager.DEFAULT_PORT_INDEX)
-                .setGroupOwner(callingPackage)
                 .build();
         ArrayList<SubscriptionInfo> subInfos = new ArrayList<>(Arrays.asList(subInfo1));
+        doReturn(true).when(mDevicePolicyManager).isSubscriptionEnterpriseManaged(eq(subInfo1),
+                anyString());
         when(mSubscriptionManager.getAvailableSubscriptionInfoList()).thenReturn(subInfos);
 
         callDeleteSubscription(
                 SUBSCRIPTION_ID, ICC_ID, true /* complete */,
-                0 /* result */, callingPackage /* callingPackage */);
+                0 /* result */, "whatever" /* callingPackage */);
 
         verifyIntentSent(EuiccManager.EMBEDDED_SUBSCRIPTION_RESULT_ERROR,
                 0 /* detailedCode */);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/gsm/GsmSmsDispatcherTest.java b/tests/telephonytests/src/com/android/internal/telephony/gsm/GsmSmsDispatcherTest.java
index e99a05466a..2854e01409 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/gsm/GsmSmsDispatcherTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/gsm/GsmSmsDispatcherTest.java
@@ -27,11 +27,15 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeFalse;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -47,9 +51,11 @@ import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
 import android.location.Country;
 import android.location.CountryDetector;
+import android.os.AsyncResult;
 import android.os.Binder;
 import android.os.HandlerThread;
 import android.os.Message;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.provider.Settings;
@@ -68,10 +74,13 @@ import androidx.test.filters.MediumTest;
 import androidx.test.filters.SmallTest;
 
 import com.android.internal.R;
+import com.android.internal.telephony.CommandException;
 import com.android.internal.telephony.ContextFixture;
 import com.android.internal.telephony.ISub;
 import com.android.internal.telephony.SMSDispatcher;
+import com.android.internal.telephony.SmsConstants;
 import com.android.internal.telephony.SmsDispatchersController;
+import com.android.internal.telephony.SmsResponse;
 import com.android.internal.telephony.TelephonyTest;
 import com.android.internal.telephony.TelephonyTestUtils;
 import com.android.internal.telephony.TestApplication;
@@ -134,7 +143,7 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         @Override
         public void onLooperPrepared() {
             mGsmSmsDispatcher = new GsmSMSDispatcher(mPhone, mSmsDispatchersController,
-                    mGsmInboundSmsHandler);
+                    mGsmInboundSmsHandler, mFeatureFlags);
             setReady(true);
         }
     }
@@ -166,7 +175,7 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         mGsmSmsDispatcherTestHandler.start();
         waitUntilReady();
         mGsmSmsDispatcher = new GsmSMSDispatcher(mPhone, mSmsDispatchersController,
-                mGsmInboundSmsHandler);
+                mGsmInboundSmsHandler, mFeatureFlags);
         mCallingUserId = Binder.getCallingUserHandle().getIdentifier();
         processAllMessages();
     }
@@ -180,14 +189,16 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         super.tearDown();
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testSmsStatus() {
-        mSimulatedCommands.notifySmsStatus(new byte[]{(byte)0xFF, (byte)0xFF, (byte)0xFF});
+        mSimulatedCommands.notifySmsStatus(new byte[]{(byte) 0xFF, (byte) 0xFF, (byte) 0xFF});
         processAllMessages();
         verify(mSimulatedCommandsVerifier).acknowledgeLastIncomingGsmSms(true, 0, null);
     }
 
-    @Test @MediumTest
+    @Test
+    @MediumTest
     public void testSendSmsToRegularNumber_doesNotNotifyblockedNumberProvider() throws Exception {
         setupMockPackagePermissionChecks();
 
@@ -196,7 +207,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
                 .thenReturn(new Country("US", Country.COUNTRY_SOURCE_SIM));
 
         mGsmSmsDispatcher.sendText("6501002000", "121" /*scAddr*/, "test sms",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
 
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), anyString(), any(Message.class));
         // Blocked number provider is notified about the emergency contact asynchronously.
@@ -206,7 +218,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
 
     @FlakyTest
     @Ignore
-    @Test @MediumTest
+    @Test
+    @MediumTest
     public void testSendSmsToEmergencyNumber_notifiesBlockedNumberProvider() throws Exception {
         setupMockPackagePermissionChecks();
 
@@ -216,7 +229,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
 
         mGsmSmsDispatcher.sendText(
                 getEmergencyNumberFromSystemPropertiesOrDefault(), "121" /*scAddr*/, "test sms",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
 
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), anyString(), any(Message.class));
         // Blocked number provider is notified about the emergency contact asynchronously.
@@ -224,7 +238,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         assertEquals(1, mFakeBlockedNumberContentProvider.mNumEmergencyContactNotifications);
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     public void testSmsMessageValidityPeriod() throws Exception {
         int vp;
         vp = SmsMessage.getRelativeValidityPeriod(-5);
@@ -260,7 +275,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         // send invalid dest address: +
         mReceivedTestIntent = false;
         mGsmSmsDispatcher.sendText("+", "222" /*scAddr*/, TAG,
-                pendingIntent, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                pendingIntent, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
         waitForMs(500);
         verify(mSimulatedCommandsVerifier, times(0)).sendSMS(anyString(), anyString(),
                 any(Message.class));
@@ -291,7 +307,7 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         Settings.Global.putInt(mContext.getContentResolver(),
                 Settings.Global.DEVICE_PROVISIONED, 1);
 
-        mGsmSmsDispatcher.sendRawPdu(new SMSDispatcher.SmsTracker[] {mSmsTracker});
+        mGsmSmsDispatcher.sendRawPdu(new SMSDispatcher.SmsTracker[]{mSmsTracker});
         //waitForHandlerAction(mGsmSmsDispatcher, TIMEOUT_MS);
         processAllMessages();
 
@@ -303,7 +319,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         assertEquals(RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED, (int) argumentCaptor.getValue());
     }
 
-    @Test @SmallTest
+    @Test
+    @SmallTest
     @FlakyTest
     @Ignore
     public void testSendMultipartTextWithInvalidText() throws Exception {
@@ -325,7 +342,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         // send SMS and check sentIntent
         mReceivedTestIntent = false;
         mGsmSmsDispatcher.sendMultipartText("+123" /*destAddr*/, "222" /*scAddr*/, parts,
-                sentIntents, null, null, null, mCallingUserId, false, -1, false, -1, 0L, 0L);
+                sentIntents, null, null, null, mCallingUserId, false, -1, false, -1, 0L, 0L,
+                Process.INVALID_UID);
 
         waitForMs(500);
         synchronized (mLock) {
@@ -417,7 +435,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
                 false,
                 -1,
                 false,
-                0L);
+                0L,
+                Process.INVALID_UID);
         processAllMessages();
         synchronized (mLock) {
             if (!mReceivedTestIntent) {
@@ -474,7 +493,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         mGsmSmsDispatcher.mCarrierMessagingTimeout = 100;
 
         mGsmSmsDispatcher.sendText("6501002000", "121" /*scAddr*/, "test sms",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
         // wait for timeout
         waitForMs(150);
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), anyString(), any(Message.class));
@@ -488,7 +508,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         mockUiccWithCarrierApp();
 
         mGsmSmsDispatcher.sendText("6501002000", "121" /*scAddr*/, "test sms",
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
         processAllMessages();
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), anyString(), any(Message.class));
     }
@@ -513,7 +534,7 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
 
         mGsmSmsDispatcher.sendMultipartText("6501002000" /*destAddr*/, "222" /*scAddr*/, parts,
                 withSentIntents ? sentIntents : null, null, null, null, mCallingUserId,
-                false, -1, false, -1, 0L, 0L);
+                false, -1, false, -1, 0L, 0L, Process.INVALID_UID);
     }
 
     @Test
@@ -591,7 +612,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         }
 
         mGsmSmsDispatcher.sendText("111", "222" /*scAddr*/, TAG,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
 
         ArgumentCaptor<String> pduCaptor = ArgumentCaptor.forClass(String.class);
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), pduCaptor.capture(),
@@ -612,7 +634,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
             messageRef += parts.size();
         }
         mGsmSmsDispatcher.sendMultipartText("6501002000" /*destAddr*/, "222" /*scAddr*/, parts,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, 0L, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, 0L, 0L,
+                Process.INVALID_UID);
         waitForMs(150);
         ArgumentCaptor<String> pduCaptor = ArgumentCaptor.forClass(String.class);
 
@@ -635,7 +658,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         mSubscriptionManagerService.setLastUsedTPMessageReference(mPhone.getSubId(), -1);
 
         mGsmSmsDispatcher.sendText("111", "222" /*scAddr*/, TAG,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
 
         ArgumentCaptor<String> pduCaptor = ArgumentCaptor.forClass(String.class);
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), pduCaptor.capture(),
@@ -652,7 +676,8 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         Message msg = mGsmSmsDispatcher.obtainMessage(17);
         mPhone.getIccRecords().setSmssTpmrValue(255, msg);
         mGsmSmsDispatcher.sendText("111", "222" /*scAddr*/, TAG,
-                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L);
+                null, null, null, null, mCallingUserId, false, -1, false, -1, false, 0L,
+                Process.INVALID_UID);
 
         ArgumentCaptor<String> pduCaptor = ArgumentCaptor.forClass(String.class);
         verify(mSimulatedCommandsVerifier).sendSMS(anyString(), pduCaptor.capture(),
@@ -681,7 +706,7 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         // Set isMtSmsPollingMessage to true
         when(mSmsTracker.isMtSmsPollingMessage(any())).thenReturn(true);
 
-        mGsmSmsDispatcher.sendRawPdu(new SMSDispatcher.SmsTracker[] {mSmsTracker});
+        mGsmSmsDispatcher.sendRawPdu(new SMSDispatcher.SmsTracker[]{mSmsTracker});
         processAllMessages();
 
         verify(mSmsTracker, times(0)).onFailed(any(), anyInt(), anyInt());
@@ -732,4 +757,96 @@ public class GsmSmsDispatcherTest extends TelephonyTest {
         doReturn(false).when(mMockSatelliteController).isSatelliteEnabled();
         assertFalse(mGsmSmsDispatcher.shouldBlockPremiumSmsInSatelliteMode());
     }
+
+    @Test
+    public void testSendCompleteEvent_ExceedMaxRetryCount() {
+        HashMap<String, Object> data = new HashMap<String, Object>();
+        byte[] pdu = new byte[1];
+        data.put("pdu", pdu);
+
+        String destAddr = "0123456789";
+        String format = SmsConstants.FORMAT_3GPP;
+        long messageId = 202L;
+        int retryCount = 2;
+        String fullMessageText = "Test SMS for mRetryCount < max (PDU: byte[1])";
+
+        SMSDispatcher.SmsTracker smsTracker = new SMSDispatcher.SmsTracker(data, destAddr, format,
+                messageId, retryCount, fullMessageText);
+
+        sendSendSendCompleteEvent(smsTracker, CommandException.Error.SMS_FAIL_RETRY);
+
+        verify(mPhone.getSmsStats()).onOutgoingSms(
+                anyBoolean(),                                   // isOverIms
+                eq(false),                                // isFormat3gpp2
+                anyBoolean(),                                   // fallbackToCs
+                eq(SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY),  // resultCode
+                eq(SmsResponse.NO_ERROR_CODE),                  // errorCode
+                eq(messageId),                                  // messageId
+                eq(true),                                 // isFromDefaultSmsApplication
+                anyLong(),                                      // interval
+                anyBoolean(),                                   // isEmergencyNumber
+                anyBoolean(),                                   // isMtSmsPollingMessage
+                eq(pdu.length),                                 // pduLength
+                eq(null),                                 // app package name
+                anyInt()                                        // application uid
+        );
+
+        retryCount = 3;
+        smsTracker = new SMSDispatcher.SmsTracker(data, destAddr, format,
+                messageId, retryCount, fullMessageText);
+        doReturn(true).when(mFeatureFlags).satellite25q4Apis();
+        sendSendSendCompleteEvent(smsTracker, CommandException.Error.SMS_FAIL_RETRY);
+
+        // only metrics report should have updated error code
+        verify(mSmsTracker).onFailed(any(Context.class),
+                eq(SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY), eq(SmsResponse.NO_ERROR_CODE));
+        verify(mPhone.getSmsStats()).onOutgoingSms(
+                anyBoolean(),
+                eq(false),
+                anyBoolean(),
+                eq(SmsManager.RESULT_SMS_SEND_FAIL_AFTER_MAX_RETRY),    // resultCode
+                eq(SmsResponse.NO_ERROR_CODE),
+                eq(messageId),
+                eq(true),
+                anyLong(),
+                anyBoolean(),
+                anyBoolean(),
+                eq(pdu.length),
+                eq(null),
+                anyInt()
+        );
+
+        doReturn(false).when(mFeatureFlags).satellite25q4Apis();
+        sendSendSendCompleteEvent(smsTracker, CommandException.Error.SMS_FAIL_RETRY);
+
+        verify(mSmsTracker).onFailed(any(Context.class),
+                eq(SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY), eq(SmsResponse.NO_ERROR_CODE));
+        verify(mPhone.getSmsStats(), times(2)).onOutgoingSms(
+                anyBoolean(),
+                eq(false),
+                anyBoolean(),
+                eq(SmsManager.RESULT_RIL_SMS_SEND_FAIL_RETRY),    // resultCode
+                eq(SmsResponse.NO_ERROR_CODE),
+                eq(messageId),
+                eq(true),
+                anyLong(),
+                anyBoolean(),
+                anyBoolean(),
+                eq(pdu.length),
+                eq(null),
+                anyInt()
+        );
+    }
+
+    private void sendSendSendCompleteEvent(SMSDispatcher.SmsTracker smsTracker,
+            CommandException.Error error) {
+        mSmsTracker = spy(smsTracker);
+        doReturn(true).when(mSmsTracker).isFromDefaultSmsApplication(any());
+        CommandException commandException = new CommandException(error);
+
+        Message msg = mGsmSmsDispatcher.obtainMessage(2 /* EVENT_SEND_SMS_COMPLETE */);
+        msg.obj = new AsyncResult(mSmsTracker, null, commandException);
+        msg.sendToTarget();
+        processAllMessages();
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java b/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
index 2fc44fb96a..fc27c22f9f 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
@@ -2815,6 +2815,74 @@ public class ImsPhoneCallTrackerTest extends TelephonyTest {
         }
     }
 
+    @Test
+    public void testAllowedImsServicesForVowifi() {
+        doReturn(true).when(mFeatureFlags).allowedServices();
+        ImsManager.ImsStatsCallback imsStatsCallback = mCTUT.getImsStatsCallback();
+        when(mImsManager.isWfcRoamingEnabledByUser()).thenReturn(false);
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, /*isEnabled= */ true);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN), eq(true), eq(true));
+
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, /*isEnabled= */ false);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN), eq(false), eq(true));
+
+        when(mImsManager.isWfcRoamingEnabledByUser()).thenReturn(true);
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, /*isEnabled= */ true);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN), eq(true), eq(false));
+
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, /*isEnabled= */ false);
+        verify(mImsPhone, times(2)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN), eq(false), eq(true));
+    }
+
+    @Test
+    public void testAllowedImsServicesForVolte() {
+        doReturn(true).when(mFeatureFlags).allowedServices();
+        ImsManager.ImsStatsCallback imsStatsCallback = mCTUT.getImsStatsCallback();
+        PersistableBundle bundle = mContextFixture.getCarrierConfigBundle();
+        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_CONFIG_APPLIED_BOOL, true);
+        bundle.putBoolean(
+                CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL, true);
+        sendCarrierConfigChanged();
+        verify(mImsPhone, never()).setAllowedImsServices(anyInt(), anyBoolean(), anyBoolean());
+
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_LTE, /*isEnabled= */ true);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_LTE), eq(true), eq(false));
+
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_LTE, /*isEnabled= */ false);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_LTE), eq(false), eq(true));
+
+        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_CONFIG_APPLIED_BOOL, true);
+        bundle.putBoolean(
+                CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL, false);
+        sendCarrierConfigChanged();
+        verify(mImsPhone, times(2)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_LTE), eq(false), eq(true));
+
+        imsStatsCallback.onEnabledMmTelCapabilitiesChanged(
+                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
+                ImsRegistrationImplBase.REGISTRATION_TECH_LTE, /*isEnabled= */ true);
+        verify(mImsPhone, times(1)).setAllowedImsServices(
+                eq(ImsRegistrationImplBase.REGISTRATION_TECH_LTE), eq(true), eq(true));
+    }
+
     private ImsPhoneConnection placeCallAndMakeActive() {
         ImsPhoneConnection connection = placeCall();
         ImsCall imsCall = connection.getImsCall();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/metrics/PersistAtomsStorageTest.java b/tests/telephonytests/src/com/android/internal/telephony/metrics/PersistAtomsStorageTest.java
index 1e384c114a..e7d1b8f566 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/metrics/PersistAtomsStorageTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/metrics/PersistAtomsStorageTest.java
@@ -1160,6 +1160,8 @@ public class PersistAtomsStorageTest extends TelephonyTest {
         mSatelliteController1.countOfOutgoingDatagramTypeSmsFail = 4;
         mSatelliteController1.countOfIncomingDatagramTypeSmsSuccess = 5;
         mSatelliteController1.countOfIncomingDatagramTypeSmsFail = 6;
+        mSatelliteController1.carrierRoamingSatelliteConfigVersion = 19;
+        mSatelliteController1.maxAllowedDataMode = 0;
 
         mSatelliteController2 = new SatelliteController();
         mSatelliteController2.countOfSatelliteServiceEnablementsSuccess = 2 + 1;
@@ -1201,6 +1203,8 @@ public class PersistAtomsStorageTest extends TelephonyTest {
         mSatelliteController2.countOfOutgoingDatagramTypeSmsFail = 14;
         mSatelliteController2.countOfIncomingDatagramTypeSmsSuccess = 15;
         mSatelliteController2.countOfIncomingDatagramTypeSmsFail = 16;
+        mSatelliteController2.carrierRoamingSatelliteConfigVersion = 21;
+        mSatelliteController2.maxAllowedDataMode = 1;
 
         // SatelliteController atom has one data point
         mSatelliteControllers =
@@ -4490,6 +4494,9 @@ public class PersistAtomsStorageTest extends TelephonyTest {
                 mSatelliteController1.countOfIncomingDatagramTypeSmsSuccess * 2;
         expected.countOfIncomingDatagramTypeSmsFail =
                 mSatelliteController1.countOfIncomingDatagramTypeSmsFail * 2;
+        expected.carrierRoamingSatelliteConfigVersion =
+                mSatelliteController1.carrierRoamingSatelliteConfigVersion;
+        expected.maxAllowedDataMode = mSatelliteController1.maxAllowedDataMode;
 
         // Service state and service switch should be added successfully
         verifyCurrentStateSavedToFileOnce();
@@ -4662,6 +4669,9 @@ public class PersistAtomsStorageTest extends TelephonyTest {
         expected.countOfIncomingDatagramTypeSmsFail =
                 mSatelliteController1.countOfIncomingDatagramTypeSmsFail
                         + mSatelliteController2.countOfIncomingDatagramTypeSmsFail;
+        expected.carrierRoamingSatelliteConfigVersion =
+                mSatelliteController2.carrierRoamingSatelliteConfigVersion;
+        expected.maxAllowedDataMode = mSatelliteController2.maxAllowedDataMode;
 
         // Service state and service switch should be added successfully
         verifyCurrentStateSavedToFileOnce();
@@ -6124,6 +6134,9 @@ public class PersistAtomsStorageTest extends TelephonyTest {
                         stats.countOfIncomingDatagramTypeSmsSuccess);
                 assertEquals(expectedStats.countOfIncomingDatagramTypeSmsFail,
                         stats.countOfIncomingDatagramTypeSmsFail);
+                assertEquals(expectedStats.carrierRoamingSatelliteConfigVersion,
+                        stats.carrierRoamingSatelliteConfigVersion);
+                assertEquals(expectedStats.maxAllowedDataMode, stats.maxAllowedDataMode);
                 actualCount++;
             }
         }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/metrics/SatelliteStatsTest.java b/tests/telephonytests/src/com/android/internal/telephony/metrics/SatelliteStatsTest.java
index 4c24d40afd..9ce1bfb791 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/metrics/SatelliteStatsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/metrics/SatelliteStatsTest.java
@@ -118,6 +118,8 @@ public class SatelliteStatsTest extends TelephonyTest {
                         .setCountOfOutgoingDatagramTypeSmsFail(4)
                         .setCountOfIncomingDatagramTypeSmsSuccess(5)
                         .setCountOfIncomingDatagramTypeSmsFail(6)
+                        .setCarrierRoamingSatelliteConfigVersion(19)
+                        .setMaxAllowedDataMode(0)
                         .build();
 
         mSatelliteStats.onSatelliteControllerMetrics(param);
@@ -203,6 +205,11 @@ public class SatelliteStatsTest extends TelephonyTest {
                 stats.countOfIncomingDatagramTypeSmsSuccess);
         assertEquals(param.getCountOfIncomingDatagramTypeSmsSuccess(),
                 stats.countOfIncomingDatagramTypeSmsSuccess);
+        assertEquals(
+                SatelliteStats.SatelliteControllerParams.getCarrierRoamingSatelliteConfigVersion(),
+                stats.carrierRoamingSatelliteConfigVersion);
+        assertEquals(SatelliteStats.SatelliteControllerParams.getMaxAllowedDataMode(),
+                stats.maxAllowedDataMode);
 
         verifyNoMoreInteractions(mPersistAtomsStorage);
     }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramControllerTest.java
index f4d7e61cc9..3965893d4f 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramControllerTest.java
@@ -29,6 +29,8 @@ import static android.telephony.satellite.SatelliteManager.SATELLITE_DATAGRAM_TR
 import static android.telephony.satellite.SatelliteManager.SATELLITE_DATAGRAM_TRANSFER_STATE_SENDING;
 import static android.telephony.satellite.SatelliteManager.SATELLITE_RESULT_SUCCESS;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
@@ -37,10 +39,11 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 
+import android.annotation.NonNull;
+import android.content.Context;
 import android.os.Looper;
+import android.telephony.satellite.ISatelliteDatagramCallback;
 import android.telephony.satellite.SatelliteDatagram;
 import android.telephony.satellite.SatelliteManager;
 import android.testing.AndroidTestingRunner;
@@ -48,6 +51,7 @@ import android.testing.TestableLooper;
 
 import com.android.internal.R;
 import com.android.internal.telephony.TelephonyTest;
+import com.android.internal.telephony.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -63,11 +67,11 @@ import java.util.function.Consumer;
 public class DatagramControllerTest extends TelephonyTest {
     private static final String TAG = "DatagramControllerTest";
 
-    private DatagramController mDatagramControllerUT;
+    private TestDatagramController mDatagramControllerUT;
 
-    @Mock private DatagramReceiver mMockDatagramReceiver;
+    @Mock private DatagramReceiverTest.TestDatagramReceiver mMockDatagramReceiver;
     @Mock private DatagramDispatcher mMockDatagramDispatcher;
-    @Mock private PointingAppController mMockPointingAppController;
+    @Mock private PointingAppControllerTest.TestPointingAppController mMockPointingAppController;
     @Mock private SatelliteSessionController mMockSatelliteSessionController;
     @Mock private SatelliteController mMockSatelliteController;
 
@@ -88,7 +92,7 @@ public class DatagramControllerTest extends TelephonyTest {
         replaceInstance(SatelliteSessionController.class, "sInstance", null,
                 mMockSatelliteSessionController);
         when(mMockSatelliteController.isSatelliteAttachRequired()).thenReturn(true);
-        mDatagramControllerUT = new DatagramController(
+        mDatagramControllerUT = new TestDatagramController(
                 mContext, Looper.myLooper(), mFeatureFlags, mMockPointingAppController);
 
         // Move both send and receive to IDLE state
@@ -336,4 +340,124 @@ public class DatagramControllerTest extends TelephonyTest {
         mDatagramControllerUT.setDemoMode(true);
         mDatagramControllerUT.pushDemoModeDatagram(datagramType, datagram);
     }
+
+    public static class TestDatagramController extends DatagramController {
+
+        public TestDatagramController(@NonNull Context context, @NonNull Looper  looper,
+                @NonNull FeatureFlags featureFlags,
+                @NonNull PointingAppController pointingAppController) {
+            super(context, looper, featureFlags, pointingAppController);
+        }
+
+        @Override
+        protected void updateSendStatus(int subId, int datagramType, int datagramTransferState,
+                int sendPendingCount, int errorCode) {
+            super.updateSendStatus(subId, datagramType, datagramTransferState, sendPendingCount,
+                    errorCode);
+        }
+
+        @Override
+        protected void updateReceiveStatus(int subId,
+                @SatelliteManager.DatagramType int datagramType,
+                @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
+                int receivePendingCount, int errorCode) {
+            super.updateReceiveStatus(subId, datagramType, datagramTransferState,
+                    receivePendingCount, errorCode);
+        }
+
+        @Override
+        protected boolean isSendingInIdleState() {
+            return super.isSendingInIdleState();
+        }
+
+        @Override
+        protected int getReceivePendingCount() {
+            return super.getReceivePendingCount();
+        }
+
+        @Override
+        protected boolean isReceivingDatagrams() {
+            return super.isReceivingDatagrams();
+        }
+
+        @Override
+        protected boolean isPollingInIdleState() {
+            return super.isPollingInIdleState();
+        }
+
+        @Override
+        protected long getDatagramWaitTimeForConnectedState(boolean isLastSosMessage) {
+            return super.getDatagramWaitTimeForConnectedState(isLastSosMessage);
+        }
+
+        @Override
+        protected void setDemoMode(boolean isDemoMode) {
+            super.setDemoMode(isDemoMode);
+        }
+
+        @Override
+        protected SatelliteDatagram popDemoModeDatagram() {
+            return super.popDemoModeDatagram();
+        }
+
+        @Override
+        protected void pushDemoModeDatagram(@SatelliteManager.DatagramType int datagramType,
+                SatelliteDatagram datagram) {
+            super.pushDemoModeDatagram(datagramType, datagram);
+        }
+
+        @Override
+        protected void onSatelliteModemStateChanged(
+                @SatelliteManager.SatelliteModemState int state) {
+            super.onSatelliteModemStateChanged(state);
+        }
+
+        @Override
+        protected boolean needsWaitingForSatelliteConnected(
+                @SatelliteManager.DatagramType int datagramType) {
+            return super.needsWaitingForSatelliteConnected(datagramType);
+        }
+
+        @Override
+        @SatelliteManager.SatelliteResult protected int registerForSatelliteDatagram(int subId,
+                @NonNull ISatelliteDatagramCallback callback) {
+            return super.registerForSatelliteDatagram(subId, callback);
+        }
+
+        @Override
+        protected void unregisterForSatelliteDatagram(int subId,
+                @NonNull ISatelliteDatagramCallback callback) {
+            super.unregisterForSatelliteDatagram(subId, callback);
+        }
+
+        @Override
+        protected void pollPendingSatelliteDatagrams(int subId,
+                @NonNull Consumer<Integer> callback) {
+            super.pollPendingSatelliteDatagrams(subId, callback);
+        }
+
+        @Override
+        protected void sendSatelliteDatagram(int subId,
+                @SatelliteManager.DatagramType int datagramType,
+                @NonNull SatelliteDatagram datagram, boolean needFullScreenPointingUI,
+                @NonNull Consumer<Integer> callback) {
+            super.sendSatelliteDatagram(subId, datagramType, datagram, needFullScreenPointingUI,
+                    callback);
+        }
+
+        @Override
+        protected boolean isEmergencyCommunicationEstablished() {
+            return super.isEmergencyCommunicationEstablished();
+        }
+
+        @Override
+        protected void setDeviceAlignedWithSatellite(boolean isAligned) {
+            super.setDeviceAlignedWithSatellite(isAligned);
+        }
+
+        @Override
+        protected boolean waitForAligningToSatellite(boolean isAligned) {
+            return super.waitForAligningToSatellite(isAligned);
+        }
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramDispatcherTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramDispatcherTest.java
index 745a5b2366..fb2ffa4761 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramDispatcherTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramDispatcherTest.java
@@ -52,6 +52,7 @@ import android.os.AsyncResult;
 import android.os.Binder;
 import android.os.Looper;
 import android.os.Message;
+import android.os.Process;
 import android.telephony.Rlog;
 import android.telephony.satellite.SatelliteDatagram;
 import android.telephony.satellite.SatelliteManager;
@@ -111,10 +112,13 @@ public class DatagramDispatcherTest extends TelephonyTest {
             TEST_WAIT_FOR_DATAGRAM_SENDING_RESPONSE_FOR_LAST_MESSAGE_TIMEOUT_MILLIS =
             (int) TimeUnit.SECONDS.toMillis(60);
 
+    private static final int TEST_MT_SMS_POLLING_THROTTLE_MILLIS =
+            (int) TimeUnit.SECONDS.toMillis(60);
+
     private TestDatagramDispatcher mDatagramDispatcherUT;
 
-    @Mock private SatelliteController mMockSatelliteController;
-    @Mock private DatagramController mMockDatagramController;
+    @Mock private SatelliteControllerTest.TestSatelliteController mMockSatelliteController;
+    @Mock private DatagramControllerTest.TestDatagramController mMockDatagramController;
     @Mock private DatagramReceiver mMockDatagramReceiver;
     @Mock private SatelliteModemInterface mMockSatelliteModemInterface;
     @Mock private ControllerMetricsStats mMockControllerMetricsStats;
@@ -166,6 +170,7 @@ public class DatagramDispatcherTest extends TelephonyTest {
                 mMockSessionMetricsStats);
 
         when(mFeatureFlags.carrierRoamingNbIotNtn()).thenReturn(true);
+        doReturn(true).when(mFeatureFlags).satelliteImproveMultiThreadDesign();
         mDatagramDispatcherUT = new TestDatagramDispatcher(mContext, Looper.myLooper(),
                 mFeatureFlags,
                 mMockDatagramController);
@@ -178,6 +183,9 @@ public class DatagramDispatcherTest extends TelephonyTest {
         when(mPhone.getSmsDispatchersController()).thenReturn(mMockSmsDispatchersController);
         when(mMockSatelliteController.getSatelliteCarrierId()).thenReturn(UNKNOWN_CARRIER_ID);
         mPendingSms = createPendingRequest();
+
+        mContextFixture.putIntResource(R.integer.config_mt_sms_polling_throttle_millis,
+                TEST_MT_SMS_POLLING_THROTTLE_MILLIS);
     }
 
     @After
@@ -1307,6 +1315,7 @@ public class DatagramDispatcherTest extends TelephonyTest {
 
     private void setModemState(int state) {
         mDatagramDispatcherUT.onSatelliteModemStateChanged(state);
+        processAllMessages();
     }
 
     private void setShouldPollMtSmsTrue() {
@@ -1328,7 +1337,7 @@ public class DatagramDispatcherTest extends TelephonyTest {
                 SmsDispatchersController.PendingRequest.TYPE_TEXT, null, "test-app",
                 Binder.getCallingUserHandle().getIdentifier(), "1111", "2222", asArrayList(null),
                 asArrayList(null), false, null, 0, asArrayList("text"), null, false, 0, false,
-                10, 100L, false, /* isMtSmsPolling= */ true);
+                10, 100L, false, /* isMtSmsPolling= */ true, /* uid= */ Process.INVALID_UID);
         mDatagramDispatcherUT.sendSms(pendingRequest);
         SomeArgs args = SomeArgs.obtain();
         args.arg1 = mPhone.getSubId();
@@ -1383,6 +1392,11 @@ public class DatagramDispatcherTest extends TelephonyTest {
             super.setShouldSendDatagramToModemInDemoMode(shouldSendToModemInDemoMode);
         }
 
+        @Override
+        protected boolean isEmergencyCommunicationEstablished() {
+            return super.isEmergencyCommunicationEstablished();
+        }
+
         public void setDuration(long duration) {
             mLong = duration;
         }
@@ -1403,6 +1417,6 @@ public class DatagramDispatcherTest extends TelephonyTest {
                 SmsDispatchersController.PendingRequest.TYPE_TEXT, null, "test-app",
                 Binder.getCallingUserHandle().getIdentifier(), "1111", "2222", asArrayList(null),
                 asArrayList(null), false, null, 0, asArrayList("text"), null, false, 0, false,
-                10, 100L, false, false);
+                10, 100L, false, false, Process.INVALID_UID);
     }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramReceiverTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramReceiverTest.java
index b72cff85e6..ab80c01583 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramReceiverTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/DatagramReceiverTest.java
@@ -75,6 +75,7 @@ import org.mockito.MockitoAnnotations;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
 
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper
@@ -86,12 +87,12 @@ public class DatagramReceiverTest extends TelephonyTest {
     private static final long TEST_DATAGRAM_WAIT_FOR_CONNECTED_STATE_TIMEOUT_MILLIS =
             TimeUnit.SECONDS.toMillis(60);
 
-    private DatagramReceiver mDatagramReceiverUT;
+    private TestDatagramReceiver mDatagramReceiverUT;
     private DatagramReceiver.SatelliteDatagramListenerHandler mSatelliteDatagramListenerHandler;
     private TestDatagramReceiver mTestDemoModeDatagramReceiver;
 
     @Mock private SatelliteController mMockSatelliteController;
-    @Mock private DatagramController mMockDatagramController;
+    @Mock private DatagramControllerTest.TestDatagramController mMockDatagramController;
     @Mock private SatelliteModemInterface mMockSatelliteModemInterface;
     @Mock private ControllerMetricsStats mMockControllerMetricsStats;
     @Mock private SatelliteSessionController mMockSatelliteSessionController;
@@ -129,7 +130,8 @@ public class DatagramReceiverTest extends TelephonyTest {
         replaceInstance(SessionMetricsStats.class, "sInstance", null,
                 mMockSessionMetricsStats);
 
-        mDatagramReceiverUT = DatagramReceiver.make(mContext, Looper.myLooper(), mFeatureFlags,
+        doReturn(true).when(mFeatureFlags).satelliteImproveMultiThreadDesign();
+        mDatagramReceiverUT = new TestDatagramReceiver(mContext, Looper.myLooper(), mFeatureFlags,
                 mMockDatagramController);
         mTestDemoModeDatagramReceiver = new TestDatagramReceiver(mContext, Looper.myLooper(),
                 mFeatureFlags,
@@ -165,11 +167,13 @@ public class DatagramReceiverTest extends TelephonyTest {
     @Test
     public void testPollPendingSatelliteDatagrams_usingSatelliteModemInterface_success()
             throws Exception {
+        TestDatagramReceiver testDatagramReceiver = new TestDatagramReceiver(mContext,
+                Looper.myLooper(), mFeatureFlags, mMockDatagramController);
         doReturn(true).when(mMockSatelliteModemInterface).isSatelliteServiceSupported();
         doAnswer(invocation -> {
             Message message = (Message) invocation.getArguments()[0];
 
-            mDatagramReceiverUT.obtainMessage(2 /*EVENT_POLL_PENDING_SATELLITE_DATAGRAMS_DONE*/,
+            testDatagramReceiver.obtainMessage(2 /*EVENT_POLL_PENDING_SATELLITE_DATAGRAMS_DONE*/,
                             new AsyncResult(message.obj, null, null))
                     .sendToTarget();
             return null;
@@ -180,7 +184,7 @@ public class DatagramReceiverTest extends TelephonyTest {
                 .thenReturn(TEST_DATAGRAM_WAIT_FOR_CONNECTED_STATE_TIMEOUT_MILLIS);
         mResultListener.clear();
 
-        mDatagramReceiverUT.pollPendingSatelliteDatagrams(SUB_ID, mResultListener::offer);
+        testDatagramReceiver.pollPendingSatelliteDatagrams(SUB_ID, mResultListener::offer);
         processAllMessages();
         mInOrder.verify(mMockDatagramController)
                 .needsWaitingForSatelliteConnected(eq(SatelliteManager.DATAGRAM_TYPE_UNKNOWN));
@@ -190,11 +194,11 @@ public class DatagramReceiverTest extends TelephonyTest {
                 eq(SatelliteManager.SATELLITE_RESULT_SUCCESS));
         mInOrder.verify(mMockDatagramController).getDatagramWaitTimeForConnectedState(eq(false));
         verifyNoMoreInteractions(mMockSatelliteModemInterface);
-        assertTrue(mDatagramReceiverUT.isDatagramWaitForConnectedStateTimerStarted());
+        assertTrue(testDatagramReceiver.isDatagramWaitForConnectedStateTimerStarted());
 
         doReturn(false).when(mMockDatagramController)
                 .needsWaitingForSatelliteConnected(eq(SatelliteManager.DATAGRAM_TYPE_UNKNOWN));
-        mDatagramReceiverUT.onSatelliteModemStateChanged(
+        testDatagramReceiver.onSatelliteModemStateChanged(
                 SatelliteManager.SATELLITE_MODEM_STATE_CONNECTED);
         processAllMessages();
 
@@ -207,20 +211,20 @@ public class DatagramReceiverTest extends TelephonyTest {
                 .pollPendingSatelliteDatagrams(any(Message.class));
         assertEquals(1, mResultListener.size());
         assertThat(mResultListener.peek()).isEqualTo(SatelliteManager.SATELLITE_RESULT_SUCCESS);
-        assertFalse(mDatagramReceiverUT.isDatagramWaitForConnectedStateTimerStarted());
+        assertFalse(testDatagramReceiver.isDatagramWaitForConnectedStateTimerStarted());
 
         clearInvocations(mMockSatelliteModemInterface);
         clearInvocations(mMockSessionMetricsStats);
         mResultListener.clear();
         doReturn(true).when(mMockDatagramController)
                 .needsWaitingForSatelliteConnected(eq(SatelliteManager.DATAGRAM_TYPE_UNKNOWN));
-        mDatagramReceiverUT.pollPendingSatelliteDatagrams(SUB_ID, mResultListener::offer);
+        testDatagramReceiver.pollPendingSatelliteDatagrams(SUB_ID, mResultListener::offer);
         processAllMessages();
         mInOrder.verify(mMockDatagramController)
                 .needsWaitingForSatelliteConnected(eq(SatelliteManager.DATAGRAM_TYPE_UNKNOWN));
         mInOrder.verify(mMockDatagramController).getDatagramWaitTimeForConnectedState(eq(false));
         verifyNoMoreInteractions(mMockSatelliteModemInterface);
-        assertTrue(mDatagramReceiverUT.isDatagramWaitForConnectedStateTimerStarted());
+        assertTrue(testDatagramReceiver.isDatagramWaitForConnectedStateTimerStarted());
 
         moveTimeForward(TEST_DATAGRAM_WAIT_FOR_CONNECTED_STATE_TIMEOUT_MILLIS);
         processAllMessages();
@@ -237,7 +241,7 @@ public class DatagramReceiverTest extends TelephonyTest {
         assertThat(mResultListener.peek()).isEqualTo(
                 SatelliteManager.SATELLITE_RESULT_NOT_REACHABLE);
         verify(mMockSessionMetricsStats, times(1)).addCountOfFailedIncomingDatagram();
-        assertFalse(mDatagramReceiverUT.isDatagramWaitForConnectedStateTimerStarted());
+        assertFalse(testDatagramReceiver.isDatagramWaitForConnectedStateTimerStarted());
 
         mResultListener.clear();
         mDatagramReceiverUT.onSatelliteModemStateChanged(
@@ -511,13 +515,15 @@ public class DatagramReceiverTest extends TelephonyTest {
                 .isEqualTo(SatelliteManager.SATELLITE_RESULT_NOT_SUPPORTED);
     }
 
-    private static class TestDatagramReceiver extends DatagramReceiver {
+    public static class TestDatagramReceiver extends DatagramReceiver {
         private long mLong =  SATELLITE_ALIGN_TIMEOUT;
 
-        TestDatagramReceiver(@NonNull Context context, @NonNull Looper looper,
+        public TestDatagramReceiver(@NonNull Context context, @NonNull Looper looper,
                 @NonNull FeatureFlags featureFlags,
                 @NonNull DatagramController datagramController) {
             super(context, looper, featureFlags, datagramController);
+            make(context, looper, featureFlags, datagramController);
+
         }
 
         @Override
@@ -526,7 +532,7 @@ public class DatagramReceiverTest extends TelephonyTest {
         }
 
         @Override
-        public void setDeviceAlignedWithSatellite(boolean isAligned) {
+        protected void setDeviceAlignedWithSatellite(boolean isAligned) {
             super.setDeviceAlignedWithSatellite(isAligned);
         }
 
@@ -538,6 +544,29 @@ public class DatagramReceiverTest extends TelephonyTest {
         public void setDuration(long duration) {
             mLong = duration;
         }
+
+        @Override
+        protected boolean isDatagramWaitForConnectedStateTimerStarted() {
+            return super.isDatagramWaitForConnectedStateTimerStarted();
+        }
+
+        @Override
+        protected int registerForSatelliteDatagram(int subId,
+                @NonNull ISatelliteDatagramCallback callback) {
+            return super.registerForSatelliteDatagram(subId, callback);
+        }
+
+        @Override
+        protected void pollPendingSatelliteDatagrams(
+                int subId, @NonNull Consumer<Integer> callback) {
+            super.pollPendingSatelliteDatagrams(subId, callback);
+        }
+
+        @Override
+        protected void onSatelliteModemStateChanged(
+                @SatelliteManager.SatelliteModemState int state) {
+            super.onSatelliteModemStateChanged(state);
+        }
     }
 
     private static class TestSatelliteDatagramCallback extends ISatelliteDatagramCallback.Stub {
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/DemoSimulatorTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/DemoSimulatorTest.java
index 2b184689df..97dde11ce1 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/DemoSimulatorTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/DemoSimulatorTest.java
@@ -21,6 +21,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.clearInvocations;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -73,6 +74,7 @@ public class DemoSimulatorTest extends TelephonyTest {
         when(mMockSatelliteController.getDemoPointingNotAlignedDurationMillis()).thenReturn(
                 TEST_DEVICE_POINTING_NOT_ALIGNED_DURATION_MILLIS);
 
+        doReturn(true).when(mFeatureFlags).satelliteImproveMultiThreadDesign();
         mTestDemoSimulator = new TestDemoSimulator(mContext, Looper.myLooper(),
                 mMockSatelliteController);
         mTestDemoSimulator.setSatelliteListener(mISatelliteListener);
@@ -242,5 +244,10 @@ public class DemoSimulatorTest extends TelephonyTest {
         boolean isDeviceNotAlignedTimerStarted() {
             return hasMessages(EVENT_DEVICE_NOT_ALIGNED);
         }
+
+        @Override
+        protected void setDeviceAlignedWithSatellite(boolean isAligned) {
+            super.setDeviceAlignedWithSatellite(isAligned);
+        }
     }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/PointingAppControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/PointingAppControllerTest.java
index 93af153b59..b0eac33a2b 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/PointingAppControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/PointingAppControllerTest.java
@@ -33,6 +33,8 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.annotation.NonNull;
+import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.AsyncResult;
@@ -50,6 +52,7 @@ import android.util.Log;
 
 import com.android.internal.R;
 import com.android.internal.telephony.TelephonyTest;
+import com.android.internal.telephony.flags.FeatureFlags;
 
 import org.junit.After;
 import org.junit.Before;
@@ -63,6 +66,7 @@ import org.mockito.MockitoAnnotations;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
 
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper
@@ -80,7 +84,7 @@ public class PointingAppControllerTest extends TelephonyTest {
     private static final String KEY_IS_DEMO_MODE = "isDemoMode";
     private static final String KEY_IS_EMERGENCY = "isEmergency";
 
-    private PointingAppController mPointingAppController;
+    private TestPointingAppController mPointingAppController;
     InOrder mInOrder;
     InOrder mInOrderForPointingUi;
 
@@ -106,7 +110,8 @@ public class PointingAppControllerTest extends TelephonyTest {
                 mMockSatelliteModemInterface);
         replaceInstance(SatelliteController.class, "sInstance", null,
                 mMockSatelliteController);
-        mPointingAppController = new PointingAppController(mContext, mFeatureFlags);
+        doReturn(true).when(mFeatureFlags).satelliteImproveMultiThreadDesign();
+        mPointingAppController = new TestPointingAppController(mContext, mFeatureFlags);
         mContextFixture.putResource(R.string.config_pointing_ui_package,
                 KEY_POINTING_UI_PACKAGE_NAME);
         mContextFixture.putResource(R.string.config_pointing_ui_class,
@@ -321,6 +326,7 @@ public class PointingAppControllerTest extends TelephonyTest {
     public void testStartPointingUI() throws Exception {
         ArgumentCaptor<Intent> startedIntentCaptor = ArgumentCaptor.forClass(Intent.class);
         mPointingAppController.startPointingUI(true, true, true);
+        processAllMessages();
         verify(mContext).startActivityAsUser(startedIntentCaptor.capture(), eq(UserHandle.CURRENT));
         Intent intent = startedIntentCaptor.getValue();
         assertEquals(KEY_POINTING_UI_PACKAGE_NAME, intent.getComponent().getPackageName());
@@ -337,10 +343,12 @@ public class PointingAppControllerTest extends TelephonyTest {
     @Test
     public void testRestartPointingUi() throws Exception {
         mPointingAppController.startPointingUI(true, false, true);
+        processAllMessages();
         mInOrderForPointingUi.verify(mContext).startActivityAsUser(any(Intent.class),
                 eq(UserHandle.CURRENT));
         testRestartPointingUi(true, false, true);
         mPointingAppController.startPointingUI(false, true, false);
+        processAllMessages();
         mInOrderForPointingUi.verify(mContext).startActivityAsUser(any(Intent.class),
                 eq(UserHandle.CURRENT));
         testRestartPointingUi(false, true, false);
@@ -352,6 +360,7 @@ public class PointingAppControllerTest extends TelephonyTest {
         doReturn(new String[]{KEY_POINTING_UI_PACKAGE_NAME}).when(mPackageManager)
             .getPackagesForUid(anyInt());
         mPointingAppController.mUidImportanceListener.onUidImportance(1, IMPORTANCE_GONE);
+        processAllMessages();
         ArgumentCaptor<Intent> restartedIntentCaptor = ArgumentCaptor.forClass(Intent.class);
         mInOrderForPointingUi.verify(mContext).startActivityAsUser(restartedIntentCaptor.capture(),
                 eq(UserHandle.CURRENT));
@@ -449,4 +458,72 @@ public class PointingAppControllerTest extends TelephonyTest {
     private static void loge(String message) {
         Log.e(TAG, message);
     }
+
+    public static class TestPointingAppController extends PointingAppController {
+        public TestPointingAppController(@NonNull Context context,
+                @NonNull FeatureFlags featureFlags) {
+            super(context, featureFlags);
+        }
+
+        @Override
+        protected void setStartedSatelliteTransmissionUpdates(
+                boolean startedSatelliteTransmissionUpdates) {
+            super.setStartedSatelliteTransmissionUpdates(startedSatelliteTransmissionUpdates);
+        }
+
+        @Override
+        protected boolean getStartedSatelliteTransmissionUpdates() {
+            return super.getStartedSatelliteTransmissionUpdates();
+        }
+
+        @Override
+        protected void registerForSatelliteTransmissionUpdates(int subId,
+                ISatelliteTransmissionUpdateCallback callback) {
+            super.registerForSatelliteTransmissionUpdates(subId, callback);
+        }
+
+        @Override
+        protected void unregisterForSatelliteTransmissionUpdates(int subId,
+                Consumer<Integer> result, ISatelliteTransmissionUpdateCallback callback) {
+            super.unregisterForSatelliteTransmissionUpdates(subId, result, callback);
+        }
+
+        @Override
+        protected void startSatelliteTransmissionUpdates(@NonNull Message message) {
+            super.startSatelliteTransmissionUpdates(message);
+        }
+
+        @Override
+        protected void stopSatelliteTransmissionUpdates(@NonNull Message message) {
+            super.stopSatelliteTransmissionUpdates(message);
+        }
+
+        @Override
+        protected void startPointingUI(boolean needFullScreenPointingUI, boolean isDemoMode,
+                boolean isEmergency) {
+            super.startPointingUI(needFullScreenPointingUI, isDemoMode, isEmergency);
+        }
+
+        @Override
+        protected void removeListenerForPointingUI() {
+            super.removeListenerForPointingUI();
+        }
+
+        @Override
+        protected void updateSendDatagramTransferState(int subId,
+                @SatelliteManager.DatagramType int datagramType,
+                @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
+                int sendPendingCount, int errorCode) {
+            super.updateSendDatagramTransferState(subId, datagramType, datagramTransferState,
+                    sendPendingCount, errorCode);
+        }
+
+        @Override
+        protected void updateReceiveDatagramTransferState(int subId,
+                @SatelliteManager.SatelliteDatagramTransferState int datagramTransferState,
+                int receivePendingCount, int errorCode) {
+            super.updateReceiveDatagramTransferState(subId, datagramTransferState,
+                    receivePendingCount, errorCode);
+        }
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteConfigParserTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteConfigParserTest.java
index 62181bdf0b..3baed0d58d 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteConfigParserTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteConfigParserTest.java
@@ -16,6 +16,11 @@
 
 package com.android.internal.telephony.satellite;
 
+import static android.telephony.CarrierConfigManager.SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED;
+import static android.telephony.NetworkRegistrationInfo.SERVICE_TYPE_DATA;
+import static android.telephony.NetworkRegistrationInfo.SERVICE_TYPE_SMS;
+import static android.telephony.NetworkRegistrationInfo.SERVICE_TYPE_VOICE;
+
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.TestCase.assertFalse;
 
@@ -30,6 +35,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 
 import android.content.Context;
+import android.telephony.CarrierConfigManager;
 import android.testing.AndroidTestingRunner;
 
 import androidx.test.InstrumentationRegistry;
@@ -58,6 +64,15 @@ import java.util.Set;
 
 @RunWith(AndroidTestingRunner.class)
 public class SatelliteConfigParserTest extends TelephonyTest {
+
+    private static final String PLMN_310160 = "310160";
+    private static final String PLMN_310220 = "310220";
+    private static final String PLMN_310260 = "310260";
+    private static final String PLMN_45005  = "45060";
+
+    private static final String COUNTRY_US = "US";
+    private static final String COUNTRY_IN = "IN";
+
     private byte[] mBytesProtoBuffer;
 
     @Before
@@ -77,25 +92,33 @@ public class SatelliteConfigParserTest extends TelephonyTest {
         // carriersupportedservices
         SatelliteConfigData.CarrierSupportedSatelliteServicesProto.Builder
                 carrierSupportedSatelliteServiceBuilder =
-                        SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
+                SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
 
         // carriersupportedservices#carrier_id
         carrierSupportedSatelliteServiceBuilder.setCarrierId(1);
 
+        // carrierroamingconfig
+        SatelliteConfigData.CarrierRoamingConfigProto.Builder carrierRoamingConfigBuilder =
+                SatelliteConfigData.CarrierRoamingConfigProto.newBuilder();
+        carrierRoamingConfigBuilder.setMaxAllowedDataMode(
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        satelliteConfigBuilder.setCarrierRoamingConfig(carrierRoamingConfigBuilder);
+        carrierRoamingConfigBuilder.clear();
+
         // carriersupportedservices#providercapability
         SatelliteConfigData.SatelliteProviderCapabilityProto.Builder
                 satelliteProviderCapabilityBuilder =
-                        SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
-        satelliteProviderCapabilityBuilder.setCarrierPlmn("310160");
-        satelliteProviderCapabilityBuilder.addAllowedServices(1);
-        satelliteProviderCapabilityBuilder.addAllowedServices(2);
-        satelliteProviderCapabilityBuilder.addAllowedServices(3);
+                SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310160);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_VOICE);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_DATA);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
         carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
                 satelliteProviderCapabilityBuilder);
         satelliteProviderCapabilityBuilder.clear();
 
-        satelliteProviderCapabilityBuilder.setCarrierPlmn("310220");
-        satelliteProviderCapabilityBuilder.addAllowedServices(3);
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310220);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
         carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
                 satelliteProviderCapabilityBuilder);
         satelliteProviderCapabilityBuilder.clear();
@@ -110,7 +133,7 @@ public class SatelliteConfigParserTest extends TelephonyTest {
         satelliteRegionBuilder.setS2CellFile(ByteString.copyFrom(testS2Content.getBytes()));
         satelliteRegionBuilder.setSatelliteAccessConfigFile(
                 ByteString.copyFrom(testSatelliteAccessConfigContent.getBytes()));
-        satelliteRegionBuilder.addCountryCodes("US");
+        satelliteRegionBuilder.addCountryCodes(COUNTRY_US);
         satelliteRegionBuilder.setIsAllowed(true);
         satelliteConfigBuilder.setDeviceSatelliteRegion(satelliteRegionBuilder);
 
@@ -130,11 +153,11 @@ public class SatelliteConfigParserTest extends TelephonyTest {
     @Test
     public void testGetAllSatellitePlmnsForCarrier() {
         List<String> compareList_cid1 = new ArrayList<>();
-        compareList_cid1.add("310160");
-        compareList_cid1.add("310220");
+        compareList_cid1.add(PLMN_310160);
+        compareList_cid1.add(PLMN_310220);
         List<String> compareList_cid_placeholder = new ArrayList<>();
-        compareList_cid_placeholder.add("310260");
-        compareList_cid_placeholder.add("45060");
+        compareList_cid_placeholder.add(PLMN_310260);
+        compareList_cid_placeholder.add(PLMN_45005);
 
 
         SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
@@ -166,14 +189,14 @@ public class SatelliteConfigParserTest extends TelephonyTest {
     public void testGetSupportedSatelliteServices() {
         Map<String, Set<Integer>> compareMapCarrierId1 = new HashMap<>();
         Set<Integer> compareSet310160 = new HashSet<>();
-        compareSet310160.add(1);
-        compareSet310160.add(2);
-        compareSet310160.add(3);
-        compareMapCarrierId1.put("310160", compareSet310160);
+        compareSet310160.add(SERVICE_TYPE_VOICE);
+        compareSet310160.add(SERVICE_TYPE_DATA);
+        compareSet310160.add(SERVICE_TYPE_SMS);
+        compareMapCarrierId1.put(PLMN_310160, compareSet310160);
 
         Set<Integer> compareSet310220 = new HashSet<>();
-        compareSet310220.add(3);
-        compareMapCarrierId1.put("310220", compareSet310220);
+        compareSet310220.add(SERVICE_TYPE_SMS);
+        compareMapCarrierId1.put(PLMN_310220, compareSet310220);
 
         SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
         assertNotNull(satelliteConfigParserNull);
@@ -197,12 +220,12 @@ public class SatelliteConfigParserTest extends TelephonyTest {
     @Test
     public void testGetDeviceSatelliteCountryCodes() {
         List<String> compareList_countryCodes = new ArrayList<>();
-        compareList_countryCodes.add("US");
+        compareList_countryCodes.add(COUNTRY_US);
         Collections.sort(compareList_countryCodes);
 
         List<String> compareList_countryCodes_placeholder = new ArrayList<>();
-        compareList_countryCodes_placeholder.add("US");
-        compareList_countryCodes_placeholder.add("IN");
+        compareList_countryCodes_placeholder.add(COUNTRY_US);
+        compareList_countryCodes_placeholder.add(COUNTRY_IN);
         Collections.sort(compareList_countryCodes_placeholder);
 
         SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
@@ -379,4 +402,473 @@ public class SatelliteConfigParserTest extends TelephonyTest {
         assertNotNull(satelliteConfigParser.getConfig());
         assertEquals(4, satelliteConfigParser.getConfig().getSatelliteConfigDataVersion());
     }
+
+    @Test
+    public void testGetCarrierRoamingConfigMaxAllowedDataMode() {
+        SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
+        assertNotNull(satelliteConfigParserNull);
+        assertNull(satelliteConfigParserNull.getConfig());
+
+        SatelliteConfigParser satelliteConfigParserPlaceholder =
+                new SatelliteConfigParser("test".getBytes());
+        assertNotNull(satelliteConfigParserPlaceholder);
+        assertNull(satelliteConfigParserPlaceholder.getConfig());
+
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+        assertEquals(Integer.valueOf(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED),
+                satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+    }
+
+    @Test
+    public void testNullCarrierRoamingConfig() {
+        SatelliteConfigData.TelephonyConfigProto.Builder telephonyConfigBuilder =
+                SatelliteConfigData.TelephonyConfigProto.newBuilder();
+        SatelliteConfigData.SatelliteConfigProto.Builder satelliteConfigBuilder =
+                SatelliteConfigData.SatelliteConfigProto.newBuilder();
+
+        // version
+        satelliteConfigBuilder.setVersion(4);
+
+        // carriersupportedservices
+        SatelliteConfigData.CarrierSupportedSatelliteServicesProto.Builder
+                carrierSupportedSatelliteServiceBuilder =
+                SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
+
+        // carriersupportedservices#carrier_id
+        carrierSupportedSatelliteServiceBuilder.setCarrierId(1);
+
+        // not building carrierroamingconfig
+
+        // carriersupportedservices#providercapability
+        SatelliteConfigData.SatelliteProviderCapabilityProto.Builder
+                satelliteProviderCapabilityBuilder =
+                SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310160);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_VOICE);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_DATA);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+        carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                satelliteProviderCapabilityBuilder);
+        satelliteProviderCapabilityBuilder.clear();
+
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310220);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+        carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                satelliteProviderCapabilityBuilder);
+        satelliteProviderCapabilityBuilder.clear();
+
+        satelliteConfigBuilder.addCarrierSupportedSatelliteServices(
+                carrierSupportedSatelliteServiceBuilder);
+
+        // satelliteregion
+        SatelliteConfigData.SatelliteRegionProto.Builder satelliteRegionBuilder =
+                SatelliteConfigData.SatelliteRegionProto.newBuilder();
+        String testS2Content = "0123456789", testSatelliteAccessConfigContent = "sac";
+        satelliteRegionBuilder.setS2CellFile(ByteString.copyFrom(testS2Content.getBytes()));
+        satelliteRegionBuilder.setSatelliteAccessConfigFile(
+                ByteString.copyFrom(testSatelliteAccessConfigContent.getBytes()));
+        satelliteRegionBuilder.addCountryCodes(COUNTRY_US);
+        satelliteRegionBuilder.setIsAllowed(true);
+        satelliteConfigBuilder.setDeviceSatelliteRegion(satelliteRegionBuilder);
+
+        telephonyConfigBuilder.setSatellite(satelliteConfigBuilder);
+
+        SatelliteConfigData.TelephonyConfigProto telephonyConfigData =
+                telephonyConfigBuilder.build();
+        mBytesProtoBuffer = telephonyConfigData.toByteArray();
+
+        SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
+        assertNotNull(satelliteConfigParserNull);
+        assertNull(satelliteConfigParserNull.getConfig());
+
+        SatelliteConfigParser satelliteConfigParserPlaceholder =
+                new SatelliteConfigParser("test".getBytes());
+        assertNotNull(satelliteConfigParserPlaceholder);
+        assertNull(satelliteConfigParserPlaceholder.getConfig());
+
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNull(satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+    }
+
+    @Test
+    public void testNullMaxAllowedDataMode() {
+        SatelliteConfigData.TelephonyConfigProto.Builder telephonyConfigBuilder =
+                SatelliteConfigData.TelephonyConfigProto.newBuilder();
+        SatelliteConfigData.SatelliteConfigProto.Builder satelliteConfigBuilder =
+                SatelliteConfigData.SatelliteConfigProto.newBuilder();
+
+        // version
+        satelliteConfigBuilder.setVersion(4);
+
+        // carriersupportedservices
+        SatelliteConfigData.CarrierSupportedSatelliteServicesProto.Builder
+                carrierSupportedSatelliteServiceBuilder =
+                SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
+
+        // carriersupportedservices#carrier_id
+        carrierSupportedSatelliteServiceBuilder.setCarrierId(1);
+
+        // carrierroamingconfig, but not setting maxAllowedDataMode
+        SatelliteConfigData.CarrierRoamingConfigProto.Builder carrierRoamingConfigBuilder =
+                SatelliteConfigData.CarrierRoamingConfigProto.newBuilder();
+        satelliteConfigBuilder.setCarrierRoamingConfig(carrierRoamingConfigBuilder);
+        carrierRoamingConfigBuilder.clear();
+
+        // carriersupportedservices#providercapability
+        SatelliteConfigData.SatelliteProviderCapabilityProto.Builder
+                satelliteProviderCapabilityBuilder =
+                SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310160);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_VOICE);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_DATA);
+        satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+        carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                satelliteProviderCapabilityBuilder);
+        satelliteProviderCapabilityBuilder.clear();
+
+        satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310220);
+        satelliteProviderCapabilityBuilder.addAllowedServices(3);
+        carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                satelliteProviderCapabilityBuilder);
+        satelliteProviderCapabilityBuilder.clear();
+
+        satelliteConfigBuilder.addCarrierSupportedSatelliteServices(
+                carrierSupportedSatelliteServiceBuilder);
+
+        // satelliteregion
+        SatelliteConfigData.SatelliteRegionProto.Builder satelliteRegionBuilder =
+                SatelliteConfigData.SatelliteRegionProto.newBuilder();
+        String testS2Content = "0123456789", testSatelliteAccessConfigContent = "sac";
+        satelliteRegionBuilder.setS2CellFile(ByteString.copyFrom(testS2Content.getBytes()));
+        satelliteRegionBuilder.setSatelliteAccessConfigFile(
+                ByteString.copyFrom(testSatelliteAccessConfigContent.getBytes()));
+        satelliteRegionBuilder.addCountryCodes(COUNTRY_US);
+        satelliteRegionBuilder.setIsAllowed(true);
+        satelliteConfigBuilder.setDeviceSatelliteRegion(satelliteRegionBuilder);
+
+        telephonyConfigBuilder.setSatellite(satelliteConfigBuilder);
+
+        SatelliteConfigData.TelephonyConfigProto telephonyConfigData =
+                telephonyConfigBuilder.build();
+        mBytesProtoBuffer = telephonyConfigData.toByteArray();
+
+        SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
+        assertNotNull(satelliteConfigParserNull);
+        assertNull(satelliteConfigParserNull.getConfig());
+
+        SatelliteConfigParser satelliteConfigParserPlaceholder =
+                new SatelliteConfigParser("test".getBytes());
+        assertNotNull(satelliteConfigParserPlaceholder);
+        assertNull(satelliteConfigParserPlaceholder.getConfig());
+
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+        assertEquals(Integer.valueOf(0),
+                satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+    }
+
+    private void setProtoData(boolean carrierSupportedSatelliteServices,
+            boolean carrierRoamingConfigs, boolean satelliteRegion) {
+
+        SatelliteConfigData.TelephonyConfigProto.Builder telephonyConfigBuilder =
+                SatelliteConfigData.TelephonyConfigProto.newBuilder();
+        SatelliteConfigData.SatelliteConfigProto.Builder satelliteConfigBuilder =
+                SatelliteConfigData.SatelliteConfigProto.newBuilder();
+
+        // set version
+        satelliteConfigBuilder.setVersion(4);
+
+        if (carrierSupportedSatelliteServices) {
+            SatelliteConfigData.CarrierSupportedSatelliteServicesProto.Builder
+                    carrierSupportedSatelliteServiceBuilder =
+                    SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
+
+            // set carriersupportedservices#carrier_id
+            carrierSupportedSatelliteServiceBuilder.setCarrierId(1);
+
+            // set carriersupportedservices#providercapability
+            SatelliteConfigData.SatelliteProviderCapabilityProto.Builder
+                    satelliteProviderCapabilityBuilder =
+                    SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
+            satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310160);
+            satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_VOICE);
+            satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_DATA);
+            satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+            carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                    satelliteProviderCapabilityBuilder);
+            satelliteProviderCapabilityBuilder.clear();
+
+            satelliteProviderCapabilityBuilder.setCarrierPlmn(PLMN_310220);
+            satelliteProviderCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+            carrierSupportedSatelliteServiceBuilder.addSupportedSatelliteProviderCapabilities(
+                    satelliteProviderCapabilityBuilder);
+            satelliteProviderCapabilityBuilder.clear();
+
+            satelliteConfigBuilder.addCarrierSupportedSatelliteServices(
+                    carrierSupportedSatelliteServiceBuilder);
+        }
+
+        if (carrierRoamingConfigs) {
+            // set carrierRoamingConfigs#maxalloweddatamode
+            SatelliteConfigData.CarrierRoamingConfigProto.Builder carrierRoamingConfigBuilder =
+                    SatelliteConfigData.CarrierRoamingConfigProto.newBuilder();
+            carrierRoamingConfigBuilder.setMaxAllowedDataMode(
+                    SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+            satelliteConfigBuilder.setCarrierRoamingConfig(carrierRoamingConfigBuilder);
+            carrierRoamingConfigBuilder.clear();
+        }
+
+        if (satelliteRegion) {
+            SatelliteConfigData.SatelliteRegionProto.Builder satelliteRegionBuilder =
+                    SatelliteConfigData.SatelliteRegionProto.newBuilder();
+            String testS2Content = "0123456789", testSatelliteAccessConfigContent = "sac";
+            // set satelliteRegions#s2cellFile
+            satelliteRegionBuilder.setS2CellFile(ByteString.copyFrom(testS2Content.getBytes()));
+            // set satelliteRegions#satelliteAccessConfigFile
+            satelliteRegionBuilder.setSatelliteAccessConfigFile(
+                    ByteString.copyFrom(testSatelliteAccessConfigContent.getBytes()));
+            // set satelliteRegions#countrycode
+            satelliteRegionBuilder.addCountryCodes(COUNTRY_US);
+            // set satelliteRegions#isAllowed
+            satelliteRegionBuilder.setIsAllowed(true);
+
+            satelliteConfigBuilder.setDeviceSatelliteRegion(satelliteRegionBuilder);
+        }
+
+        telephonyConfigBuilder.setSatellite(satelliteConfigBuilder);
+        SatelliteConfigData.TelephonyConfigProto telephonyConfigData =
+                telephonyConfigBuilder.build();
+        mBytesProtoBuffer = telephonyConfigData.toByteArray();
+    }
+
+    @Test
+    public void testEmptyCasePerEachTopLevelProto() {
+        SatelliteConfigParser satelliteConfigParserNull = new SatelliteConfigParser((byte[]) null);
+        assertNotNull(satelliteConfigParserNull);
+        assertNull(satelliteConfigParserNull.getConfig());
+
+        SatelliteConfigParser satelliteConfigParserPlaceholder =
+                new SatelliteConfigParser("test".getBytes());
+        assertNotNull(satelliteConfigParserPlaceholder);
+        assertNull(satelliteConfigParserPlaceholder.getConfig());
+
+        // When carrierRoamingConfigs null and satelliteRegion null,
+        // Verify carrierSupportedSatelliteServices child items are not null
+        setProtoData(true, false, false);
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getSupportedSatelliteServices(1));
+
+        // When carrierSupportedSatelliteServices is null and satelliteRegion is null
+        // Verify carrierRoamingConfigs child items are not null
+        setProtoData(false, true, false);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+
+        // When carrierSupportedSatelliteServices null and carrierRoamingConfigs null
+        // Verify satelliteRegion child items are not null
+        setProtoData(false, false, true);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes());
+        assertNotNull(satelliteConfigParser.getConfig().isSatelliteDataForAllowedRegion());
+    }
+
+    private void setProtoDataOnlySatelliteRegionProto(
+            boolean countryCodes,
+            boolean allowed,
+            boolean s2CellFile,
+            boolean satelliteAccessConfigFile) {
+
+        SatelliteConfigData.TelephonyConfigProto.Builder telephonyConfigBuilder =
+                SatelliteConfigData.TelephonyConfigProto.newBuilder();
+        SatelliteConfigData.SatelliteConfigProto.Builder satelliteConfigBuilder =
+                SatelliteConfigData.SatelliteConfigProto.newBuilder();
+
+        satelliteConfigBuilder.setVersion(4);
+
+        SatelliteConfigData.SatelliteRegionProto.Builder satelliteRegionBuilder =
+                SatelliteConfigData.SatelliteRegionProto.newBuilder();
+        String testS2Content = "0123456789", testSatelliteAccessConfigContent = "sac";
+
+        if (s2CellFile) {
+            satelliteRegionBuilder.setS2CellFile(ByteString.copyFrom(testS2Content.getBytes()));
+        }
+
+        if (satelliteAccessConfigFile) {
+            satelliteRegionBuilder.setSatelliteAccessConfigFile(
+                    ByteString.copyFrom(testSatelliteAccessConfigContent.getBytes()));
+        }
+
+        if (countryCodes) {
+            satelliteRegionBuilder.addCountryCodes(COUNTRY_US);
+        }
+
+        if (allowed) {
+            satelliteRegionBuilder.setIsAllowed(true);
+        }
+
+        satelliteConfigBuilder.setDeviceSatelliteRegion(satelliteRegionBuilder);
+        telephonyConfigBuilder.setSatellite(satelliteConfigBuilder);
+        SatelliteConfigData.TelephonyConfigProto telephonyConfigData =
+                telephonyConfigBuilder.build();
+        mBytesProtoBuffer = telephonyConfigData.toByteArray();
+    }
+
+    @Test
+    public void testEmptyItemOfSatelliteRegionProto() {
+        setProtoDataOnlySatelliteRegionProto(false, true, true, true);
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes());
+        assertEquals(0,
+                satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes().size());
+        assertNotNull(satelliteConfigParser.getConfig().isSatelliteDataForAllowedRegion());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteS2CellFile());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteAccessConfigFile());
+
+        setProtoDataOnlySatelliteRegionProto(true, false, true, true);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes());
+        assertNotNull(satelliteConfigParser.getConfig().isSatelliteDataForAllowedRegion());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteS2CellFile());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteAccessConfigFile());
+
+        setProtoDataOnlySatelliteRegionProto(true, true, false, true);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().isSatelliteDataForAllowedRegion());
+        assertNotNull(satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes());
+        assertFalse(satelliteConfigParser.getConfig().hasSatelliteS2CellFile());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteAccessConfigFile());
+
+        setProtoDataOnlySatelliteRegionProto(true, true, true, false);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().isSatelliteDataForAllowedRegion());
+        assertNotNull(satelliteConfigParser.getConfig().getDeviceSatelliteCountryCodes());
+        assertTrue(satelliteConfigParser.getConfig().hasSatelliteS2CellFile());
+        assertFalse(satelliteConfigParser.getConfig().hasSatelliteAccessConfigFile());
+    }
+
+    private void setProtoDataOnlyCarrierSupportedSatelliteServicesProto(
+            boolean carrierId,
+            boolean plmn,
+            boolean serviceType) {
+        SatelliteConfigData.TelephonyConfigProto.Builder telephonyConfigBuilder =
+                SatelliteConfigData.TelephonyConfigProto.newBuilder();
+        SatelliteConfigData.SatelliteConfigProto.Builder satelliteConfigBuilder =
+                SatelliteConfigData.SatelliteConfigProto.newBuilder();
+
+        satelliteConfigBuilder.setVersion(4);
+
+        SatelliteConfigData.CarrierSupportedSatelliteServicesProto.Builder
+                carrierSupportedSatelliteServiceBuilder =
+                SatelliteConfigData.CarrierSupportedSatelliteServicesProto.newBuilder();
+
+        if (carrierId) {
+            carrierSupportedSatelliteServiceBuilder.setCarrierId(1);
+        }
+
+        SatelliteConfigData.SatelliteProviderCapabilityProto.Builder providerCapabilityBuilder =
+                SatelliteConfigData.SatelliteProviderCapabilityProto.newBuilder();
+        if (plmn) {
+            providerCapabilityBuilder.setCarrierPlmn(PLMN_45005);
+        }
+        if (serviceType) {
+            providerCapabilityBuilder.addAllowedServices(SERVICE_TYPE_SMS);
+        }
+        carrierSupportedSatelliteServiceBuilder
+                .addSupportedSatelliteProviderCapabilities(providerCapabilityBuilder);
+
+        satelliteConfigBuilder
+                .addCarrierSupportedSatelliteServices(carrierSupportedSatelliteServiceBuilder);
+        telephonyConfigBuilder.setSatellite(satelliteConfigBuilder);
+        SatelliteConfigData.TelephonyConfigProto telephonyConfigData =
+                telephonyConfigBuilder.build();
+        mBytesProtoBuffer = telephonyConfigData.toByteArray();
+    }
+
+    @Test
+    public void testEmptyItemOfCarrierSupportedSatelliteServicesProto() {
+        setProtoDataOnlyCarrierSupportedSatelliteServicesProto(false, true, true);
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertTrue(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).isEmpty());
+
+        setProtoDataOnlyCarrierSupportedSatelliteServicesProto(true, false, true);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertFalse(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).isEmpty());
+        assertFalse(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).containsKey(PLMN_45005));
+
+        setProtoDataOnlyCarrierSupportedSatelliteServicesProto(true, true, false);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertFalse(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).isEmpty());
+        assertTrue(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).containsKey(PLMN_45005));
+        assertTrue(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).get(PLMN_45005).isEmpty());
+
+        setProtoDataOnlyCarrierSupportedSatelliteServicesProto(true, true, true);
+        satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertFalse(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).isEmpty());
+        assertTrue(satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).containsKey(PLMN_45005));
+        assertEquals(Set.of(SERVICE_TYPE_SMS), satelliteConfigParser.getConfig()
+                .getSupportedSatelliteServices(1).get(PLMN_45005));
+    }
+
+    @Test
+    public void testOverrideConfigByOverridingSatelliteMaxAllowedDataMode() {
+        SatelliteConfigParser satelliteConfigParser = new SatelliteConfigParser(mBytesProtoBuffer);
+        assertNotNull(satelliteConfigParser);
+        assertNotNull(satelliteConfigParser.getConfig());
+        assertNotNull(satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+        assertEquals(
+                Integer.valueOf(CarrierConfigManager.SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED),
+                satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+
+        SatelliteConfig satelliteConfig = new SatelliteConfig();
+        satelliteConfig.overrideSatelliteMaxAllowedDataMode(
+                CarrierConfigManager.SATELLITE_DATA_SUPPORT_ALL);
+        satelliteConfigParser.overrideConfig(satelliteConfig);
+        assertEquals(
+                Integer.valueOf(CarrierConfigManager.SATELLITE_DATA_SUPPORT_ALL),
+                satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+
+        satelliteConfig.overrideSatelliteMaxAllowedDataMode(
+                CarrierConfigManager.SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        satelliteConfigParser.overrideConfig(satelliteConfig);
+        assertEquals(
+                Integer.valueOf(CarrierConfigManager.SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED),
+                satelliteConfigParser.getConfig().getSatelliteMaxAllowedDataMode());
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteControllerTest.java
index 7bdb3d2372..1d28aec069 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteControllerTest.java
@@ -108,6 +108,7 @@ import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doAnswer;
@@ -122,6 +123,7 @@ import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.AlarmManager;
 import android.app.NotificationManager;
 import android.app.usage.NetworkStatsManager;
 import android.content.BroadcastReceiver;
@@ -146,6 +148,7 @@ import android.os.OutcomeReceiver;
 import android.os.PersistableBundle;
 import android.os.RemoteException;
 import android.os.ResultReceiver;
+import android.os.WorkSource;
 import android.platform.test.annotations.RequiresFlagsDisabled;
 import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.platform.test.flag.junit.CheckFlagsRule;
@@ -183,8 +186,6 @@ import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
 import android.util.IntArray;
 import android.util.Pair;
-import android.util.SparseArray;
-import android.util.SparseBooleanArray;
 
 import com.android.internal.R;
 import com.android.internal.telephony.IBooleanConsumer;
@@ -196,6 +197,7 @@ import com.android.internal.telephony.TelephonyTest;
 import com.android.internal.telephony.configupdate.ConfigProviderAdaptor;
 import com.android.internal.telephony.configupdate.TelephonyConfigUpdateInstallReceiver;
 import com.android.internal.telephony.flags.FeatureFlags;
+import com.android.internal.telephony.satellite.metrics.CarrierRoamingSatelliteControllerStats;
 import com.android.internal.telephony.satellite.metrics.ControllerMetricsStats;
 import com.android.internal.telephony.satellite.metrics.ProvisionMetricsStats;
 import com.android.internal.telephony.satellite.metrics.SessionMetricsStats;
@@ -209,6 +211,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.ArgumentMatchers;
+import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
@@ -222,10 +225,13 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;
 
 @RunWith(AndroidTestingRunner.class)
@@ -265,11 +271,13 @@ public class SatelliteControllerTest extends TelephonyTest {
     private SubscriptionInfo testSubscriptionInfo2;
 
     @Mock private TestSatelliteController mMockSatelliteController;
-    @Mock private DatagramController mMockDatagramController;
+    @Mock private DatagramControllerTest.TestDatagramController mMockDatagramController;
     @Mock private SatelliteModemInterface mMockSatelliteModemInterface;
     @Mock private SatelliteSessionController mMockSatelliteSessionController;
-    @Mock private PointingAppController mMockPointingAppController;
+    @Mock private PointingAppControllerTest.TestPointingAppController mMockPointingAppController;
     @Mock private ControllerMetricsStats mMockControllerMetricsStats;
+    @Mock private CarrierRoamingSatelliteControllerStats
+            mMockCarrierRoamingSatelliteControllerStats;
     @Mock private ProvisionMetricsStats mMockProvisionMetricsStats;
     @Mock private SessionMetricsStats mMockSessionMetricsStats;
     @Mock private SubscriptionManagerService mMockSubscriptionManagerService;
@@ -288,6 +296,10 @@ public class SatelliteControllerTest extends TelephonyTest {
     @Mock private SubscriptionInfo mSubscriptionInfo;
     @Mock private PackageManager mMockPManager;
     @Mock private Intent mMockLocationIntent;
+    @Mock private AlarmManager mMockAlarmManager;
+
+    @Captor
+    private ArgumentCaptor<AlarmManager.OnAlarmListener> mAlarmListenerCaptor;
 
     private Semaphore mIIntegerConsumerSemaphore = new Semaphore(0);
     private IIntegerConsumer mIIntegerConsumer = new IIntegerConsumer.Stub() {
@@ -602,6 +614,8 @@ public class SatelliteControllerTest extends TelephonyTest {
                 mMockPointingAppController);
         replaceInstance(ControllerMetricsStats.class, "sInstance", null,
                 mMockControllerMetricsStats);
+        replaceInstance(CarrierRoamingSatelliteControllerStats.class, "sInstance", null,
+                mMockCarrierRoamingSatelliteControllerStats);
         replaceInstance(ProvisionMetricsStats.class, "sInstance", null,
                 mMockProvisionMetricsStats);
         replaceInstance(SessionMetricsStats.class, "sInstance", null,
@@ -731,7 +745,13 @@ public class SatelliteControllerTest extends TelephonyTest {
         doReturn(mSubscriptionInfo).when(mMockSubscriptionManagerService).getSubscriptionInfo(
                 anyInt());
         doReturn("").when(mSubscriptionInfo).getIccId();
+
+        doReturn(true).when(mFeatureFlags).satelliteImproveMultiThreadDesign();
         doReturn(TEST_ALL_SATELLITE_PLMN_SET).when(mMockSatelliteController).getAllPlmnSet();
+        mSatelliteControllerUT.setAlarmManager(mMockAlarmManager);
+        doNothing().when(mMockAlarmManager).cancel(any(AlarmManager.OnAlarmListener.class));
+        doNothing().when(mMockAlarmManager).setExact(anyInt(), anyLong(), anyString(),
+                any(Executor.class), any(WorkSource.class), mAlarmListenerCaptor.capture());
     }
 
     @After
@@ -743,7 +763,8 @@ public class SatelliteControllerTest extends TelephonyTest {
 
     @Test
     public void testShouldTurnOffCarrierSatelliteForEmergencyCall() throws Exception {
-        DatagramController datagramController = mock(DatagramController.class);
+        DatagramControllerTest.TestDatagramController datagramController = mock(
+                DatagramControllerTest.TestDatagramController.class);
         replaceInstance(SatelliteController.class, "mDatagramController",
                 mSatelliteControllerUT, datagramController);
 
@@ -991,6 +1012,7 @@ public class SatelliteControllerTest extends TelephonyTest {
                     /*slotIndex*/ 0, /*subId*/ SUB_ID, /*carrierId*/ 0, /*specificCarrierId*/ 0)
             );
         }
+        processAllMessages();
         when(mServiceState.getNetworkRegistrationInfoList()).thenReturn(List.of(satelliteNri));
         when(mServiceState.isUsingNonTerrestrialNetwork()).thenReturn(true);
         sendServiceStateChangedEvent();
@@ -1435,6 +1457,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         // Verify satellite enabled for emergency
         assertTrue(mSatelliteControllerUT.getRequestIsEmergency());
         mSatelliteControllerUT.requestIsEmergencyModeEnabled(mRequestIsEmergencyReceiver);
+        processAllMessages();
         assertTrue(mRequestIsEmergency);
     }
 
@@ -1539,6 +1562,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         setUpResponseForStartSatelliteTransmissionUpdates(SATELLITE_RESULT_SUCCESS);
         mSatelliteControllerUT.startSatelliteTransmissionUpdates(mIIntegerConsumer,
                 mStartTransmissionUpdateCallback);
+        processAllMessages();
         verify(mMockPointingAppController).registerForSatelliteTransmissionUpdates(anyInt(),
                 eq(mStartTransmissionUpdateCallback));
         processAllMessages();
@@ -1570,6 +1594,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         setUpResponseForStopSatelliteTransmissionUpdates(SATELLITE_RESULT_SUCCESS);
         mSatelliteControllerUT.stopSatelliteTransmissionUpdates(mIIntegerConsumer,
                 mStopTransmissionUpdateCallback);
+        processAllMessages();
         verify(mMockPointingAppController).unregisterForSatelliteTransmissionUpdates(anyInt(),
                 any(), eq(mStopTransmissionUpdateCallback));
         processAllMessages();
@@ -1583,6 +1608,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         setUpResponseForStopSatelliteTransmissionUpdates(SATELLITE_RESULT_INVALID_TELEPHONY_STATE);
         mSatelliteControllerUT.stopSatelliteTransmissionUpdates(mIIntegerConsumer,
                 mStopTransmissionUpdateCallback);
+        processAllMessages();
         verify(mMockPointingAppController, times(2)).unregisterForSatelliteTransmissionUpdates(
                 anyInt(), any(), eq(mStopTransmissionUpdateCallback));
         processAllMessages();
@@ -1598,6 +1624,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mIsDemoModeEnabledSemaphore.drainPermits();
         resetSatelliteControllerUT();
         mSatelliteControllerUT.requestIsDemoModeEnabled(mIsDemoModeEnabledReceiver);
+        processAllMessages();
         assertTrue(waitForRequestIsDemoModeEnabledResult(1));
         assertEquals(SATELLITE_RESULT_INVALID_TELEPHONY_STATE, mQueriedIsDemoModeEnabledResultCode);
         assertFalse(mQueriedIsDemoModeEnabled);
@@ -1606,6 +1633,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         setUpResponseForRequestIsSatelliteSupported(false, SATELLITE_RESULT_SUCCESS);
         verifySatelliteSupported(false, SATELLITE_RESULT_SUCCESS);
         mSatelliteControllerUT.requestIsDemoModeEnabled(mIsDemoModeEnabledReceiver);
+        processAllMessages();
         assertTrue(waitForRequestIsDemoModeEnabledResult(1));
         assertEquals(SATELLITE_RESULT_NOT_SUPPORTED, mQueriedIsDemoModeEnabledResultCode);
         assertFalse(mQueriedIsDemoModeEnabled);
@@ -1614,6 +1642,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         setUpResponseForRequestIsSatelliteSupported(true, SATELLITE_RESULT_SUCCESS);
         verifySatelliteSupported(true, SATELLITE_RESULT_SUCCESS);
         mSatelliteControllerUT.requestIsDemoModeEnabled(mIsDemoModeEnabledReceiver);
+        processAllMessages();
         assertTrue(waitForRequestIsDemoModeEnabledResult(1));
         assertEquals(SATELLITE_RESULT_SERVICE_NOT_PROVISIONED, mQueriedIsDemoModeEnabledResultCode);
         assertFalse(mQueriedIsDemoModeEnabled);
@@ -1624,6 +1653,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         verifySatelliteSupported(true, SATELLITE_RESULT_SUCCESS);
         verifySatelliteProvisioned(false, SATELLITE_RESULT_SUCCESS);
         mSatelliteControllerUT.requestIsDemoModeEnabled(mIsDemoModeEnabledReceiver);
+        processAllMessages();
         assertTrue(waitForRequestIsDemoModeEnabledResult(1));
         assertEquals(SATELLITE_RESULT_SERVICE_NOT_PROVISIONED, mQueriedIsDemoModeEnabledResultCode);
         assertFalse(mQueriedIsDemoModeEnabled);
@@ -1632,6 +1662,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         boolean isDemoModeEnabled = mSatelliteControllerUT.isDemoModeEnabled();
         provisionSatelliteService();
         mSatelliteControllerUT.requestIsDemoModeEnabled(mIsDemoModeEnabledReceiver);
+        processAllMessages();
         assertTrue(waitForRequestIsDemoModeEnabledResult(1));
         assertEquals(SATELLITE_RESULT_SUCCESS, mQueriedIsDemoModeEnabledResultCode);
         assertEquals(isDemoModeEnabled, mQueriedIsDemoModeEnabled);
@@ -1749,7 +1780,7 @@ public class SatelliteControllerTest extends TelephonyTest {
     }
 
     @Test
-    public void testRegisterForSatelliteProvisionStateChanged() {
+    public void testRegisterForSatelliteProvisionStateChanged() throws Exception {
         when(mFeatureFlags.carrierRoamingNbIotNtn()).thenReturn(true);
         Semaphore semaphore = new Semaphore(0);
         ISatelliteProvisionStateCallback callback =
@@ -2372,14 +2403,15 @@ public class SatelliteControllerTest extends TelephonyTest {
         // Add satellite attach restriction reason by user
         mIIntegerConsumerResults.clear();
         reset(mMockSatelliteModemInterface);
+        reset(mPhone);
         setUpResponseForRequestSetSatelliteEnabledForCarrier(false, SATELLITE_RESULT_SUCCESS);
         doReturn(true).when(mMockSatelliteModemInterface).isSatelliteServiceSupported();
         mSatelliteControllerUT.addAttachRestrictionForCarrier(SUB_ID,
                 SATELLITE_COMMUNICATION_RESTRICTION_REASON_USER, mIIntegerConsumer);
         processAllMessages();
         assertEquals(SATELLITE_RESULT_SUCCESS, (long) mIIntegerConsumerResults.get(0));
-        verify(mPhone, never())
-                .setSatelliteEnabledForCarrier(anyInt(), anyBoolean(), any(Message.class));
+        verify(mPhone, times(1))
+                .setSatelliteEnabledForCarrier(anyInt(), eq(false), any(Message.class));
         assertTrue(waitForIIntegerConsumerResult(1));
         restrictionSet =
                 mSatelliteControllerUT.getAttachRestrictionReasonsForCarrier(SUB_ID);
@@ -2388,6 +2420,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         // remove satellite restriction reason by user
         mIIntegerConsumerResults.clear();
         reset(mMockSatelliteModemInterface);
+        reset(mPhone);
         setUpResponseForRequestSetSatelliteEnabledForCarrier(true, SATELLITE_RESULT_SUCCESS);
         doReturn(true).when(mMockSatelliteModemInterface).isSatelliteServiceSupported();
         mSatelliteControllerUT.removeAttachRestrictionForCarrier(SUB_ID,
@@ -2431,8 +2464,8 @@ public class SatelliteControllerTest extends TelephonyTest {
         restrictionSet =
                 mSatelliteControllerUT.getAttachRestrictionReasonsForCarrier(SUB_ID);
         assertTrue(restrictionSet.contains(SATELLITE_COMMUNICATION_RESTRICTION_REASON_GEOLOCATION));
-        verify(mPhone, never())
-                .setSatelliteEnabledForCarrier(anyInt(), anyBoolean(), any(Message.class));
+        verify(mPhone, times(1))
+                .setSatelliteEnabledForCarrier(anyInt(), eq(false), any(Message.class));
 
         // remove satellite attach restriction reason by geolocation
         mIIntegerConsumerResults.clear();
@@ -2448,8 +2481,8 @@ public class SatelliteControllerTest extends TelephonyTest {
                 mSatelliteControllerUT.getAttachRestrictionReasonsForCarrier(SUB_ID);
         assertTrue(!restrictionSet.contains(
                 SATELLITE_COMMUNICATION_RESTRICTION_REASON_GEOLOCATION));
-        verify(mPhone, never())
-                .setSatelliteEnabledForCarrier(anyInt(), anyBoolean(), any(Message.class));
+        verify(mPhone, times(2))
+                .setSatelliteEnabledForCarrier(anyInt(), eq(false), any(Message.class));
 
         // remove satellite restriction reason by user
         mIIntegerConsumerResults.clear();
@@ -2913,7 +2946,7 @@ public class SatelliteControllerTest extends TelephonyTest {
 
         mCarrierConfigBundle.putBoolean(CarrierConfigManager.KEY_SATELLITE_ATTACH_SUPPORTED_BOOL,
                 true);
-        SparseBooleanArray satelliteEnabledPerCarrier = new SparseBooleanArray();
+        ConcurrentHashMap<Integer, Boolean> satelliteEnabledPerCarrier = new ConcurrentHashMap<>();
         replaceInstance(SatelliteController.class, "mSatelliteEntitlementStatusPerCarrier",
                 mSatelliteControllerUT, satelliteEnabledPerCarrier);
 
@@ -2921,7 +2954,8 @@ public class SatelliteControllerTest extends TelephonyTest {
         reset(mMockSatelliteModemInterface);
         setUpResponseForRequestSetSatelliteEnabledForCarrier(true, SATELLITE_RESULT_SUCCESS);
         doReturn(true).when(mMockSatelliteModemInterface).isSatelliteServiceSupported();
-        Map<Integer, Set<Integer>> satelliteAttachRestrictionForCarrierArray = new HashMap<>();
+        ConcurrentHashMap<Integer, Set<Integer>> satelliteAttachRestrictionForCarrierArray =
+                new ConcurrentHashMap<>();
         satelliteAttachRestrictionForCarrierArray.put(SUB_ID, new HashSet<>());
         satelliteAttachRestrictionForCarrierArray.get(SUB_ID).add(
                 SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT);
@@ -2944,7 +2978,9 @@ public class SatelliteControllerTest extends TelephonyTest {
         // satellite service is disabled by entitlement server.
         mIIntegerConsumerResults.clear();
         reset(mMockSatelliteModemInterface);
-        Map<Integer, Boolean> enabledForCarrierArrayPerSub = new HashMap<>();
+        reset(mPhone);
+        ConcurrentHashMap<Integer, Boolean> enabledForCarrierArrayPerSub =
+                new ConcurrentHashMap<>();
         enabledForCarrierArrayPerSub.put(SUB_ID, true);
         replaceInstance(SatelliteController.class, "mIsSatelliteAttachEnabledForCarrierArrayPerSub",
                 mSatelliteControllerUT, enabledForCarrierArrayPerSub);
@@ -2968,7 +3004,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("testPassSatellitePlmnToModemAfterUpdateSatelliteEntitlementStatus");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -2985,6 +3021,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         verify(mMockSatelliteModemInterface, never()).requestSatelliteEnabled(
                 any(SatelliteModemEnableRequestAttributes.class), any(Message.class));
 
@@ -3004,8 +3041,8 @@ public class SatelliteControllerTest extends TelephonyTest {
         // are available and the barred plmn list is empty, verify passing to the modem.
         reset(mMockSatelliteModemInterface);
         reset(mPhone);
-        Map<Integer, Map<String, Set<Integer>>>
-                satelliteServicesSupportedByCarriers = new HashMap<>();
+        ConcurrentHashMap<Integer, Map<String, Set<Integer>>>
+                satelliteServicesSupportedByCarriers = new ConcurrentHashMap<>();
         List<String> carrierConfigPlmnList = Arrays.stream(new String[]{"00105", "00106"}).toList();
         Map<String, Set<Integer>> plmnAndService = new HashMap<>();
         plmnAndService.put(carrierConfigPlmnList.get(0), new HashSet<>(Arrays.asList(3, 5)));
@@ -3051,6 +3088,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         verify(mMockSatelliteModemInterface, never()).requestSatelliteEnabled(
                 any(SatelliteModemEnableRequestAttributes.class), any(Message.class));
 
@@ -3061,6 +3099,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         verify(mMockSatelliteModemInterface, never()).requestSatelliteEnabled(
                 any(SatelliteModemEnableRequestAttributes.class), any(Message.class));
 
@@ -3071,6 +3110,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         verify(mMockSatelliteModemInterface, never()).requestSatelliteEnabled(
                 any(SatelliteModemEnableRequestAttributes.class), any(Message.class));
 
@@ -3081,6 +3121,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         verify(mMockSatelliteModemInterface, never()).requestSatelliteEnabled(
                 any(SatelliteModemEnableRequestAttributes.class), any(Message.class));
     }
@@ -3091,6 +3132,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         List<String> plmnListPerCarrier = mSatelliteControllerUT.getSatellitePlmnsForCarrier(
                 SUB_ID);
@@ -3126,10 +3168,10 @@ public class SatelliteControllerTest extends TelephonyTest {
     public void testUpdateSupportedSatelliteServices() throws Exception {
         logd("testUpdateSupportedSatelliteServices");
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         replaceInstance(SatelliteController.class,
                 "mSatelliteServicesSupportedByCarriersFromConfig",
-                mSatelliteControllerUT, new HashMap<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<Integer> servicesPerPlmn;
 
         // verify whether an empty list is returned with conditions below
@@ -3184,7 +3226,8 @@ public class SatelliteControllerTest extends TelephonyTest {
                 servicesPerPlmn.stream().sorted().toList());
     }
     private void setEntitlementPlmnList(List<String> plmnList) throws Exception {
-        SparseArray<List<String>> entitlementPlmnListPerCarrier = new SparseArray<>();
+        ConcurrentHashMap<Integer, List<String>> entitlementPlmnListPerCarrier =
+                new ConcurrentHashMap<>();
         if (!plmnList.isEmpty()) {
             entitlementPlmnListPerCarrier.clear();
             entitlementPlmnListPerCarrier.put(SUB_ID, plmnList);
@@ -3195,7 +3238,8 @@ public class SatelliteControllerTest extends TelephonyTest {
 
     private void setEntitlementPlmnList(SatelliteController targetClass, int subId,
             List<String> plmnList) throws Exception {
-        SparseArray<List<String>> entitlementPlmnListPerCarrier = new SparseArray<>();
+        ConcurrentHashMap<Integer, List<String>> entitlementPlmnListPerCarrier =
+                new ConcurrentHashMap<>();
         if (!plmnList.isEmpty()) {
             entitlementPlmnListPerCarrier.clear();
             entitlementPlmnListPerCarrier.put(subId, plmnList);
@@ -3248,7 +3292,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("testUpdatePlmnListPerCarrier");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         mCarrierConfigBundle.putBoolean(
                 CarrierConfigManager.KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, true);
         List<String> plmnListPerCarrier;
@@ -3304,7 +3348,7 @@ public class SatelliteControllerTest extends TelephonyTest {
     @Test
     public void testEntitlementStatus() throws Exception {
         logd("testEntitlementStatus");
-        SparseBooleanArray satelliteEnabledPerCarrier = new SparseBooleanArray();
+        ConcurrentHashMap<Integer, Boolean> satelliteEnabledPerCarrier = new ConcurrentHashMap<>();
         replaceInstance(SatelliteController.class, "mSatelliteEntitlementStatusPerCarrier",
                 mSatelliteControllerUT, satelliteEnabledPerCarrier);
 
@@ -3312,14 +3356,16 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, true, new ArrayList<>(),
                 new ArrayList<>(), new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         assertEquals(true, satelliteEnabledPerCarrier.get(SUB_ID));
-        assertEquals(false, satelliteEnabledPerCarrier.get(SUB_ID1));
+        assertEquals(false, satelliteEnabledPerCarrier.computeIfAbsent(SUB_ID1, k -> false));
 
         // Change SUB_ID1's EntitlementStatus to true
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID1, true, new ArrayList<>(),
                 new ArrayList<>(), new HashMap<>(), new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         assertEquals(true, satelliteEnabledPerCarrier.get(SUB_ID));
         assertEquals(true, satelliteEnabledPerCarrier.get(SUB_ID1));
@@ -3328,6 +3374,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false, new ArrayList<>(),
                 new ArrayList<>(), new HashMap<>(), new HashMap<>(), new HashMap<>(),
                 new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         assertEquals(false, satelliteEnabledPerCarrier.get(SUB_ID));
         assertEquals(true, satelliteEnabledPerCarrier.get(SUB_ID1));
@@ -3390,10 +3437,10 @@ public class SatelliteControllerTest extends TelephonyTest {
         doReturn(new ArrayList<>()).when(
                 mMockSubscriptionManagerService).getSatelliteEntitlementPlmnList(anyInt());
         replaceInstance(SatelliteController.class, "mEntitlementPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         replaceInstance(SatelliteController.class,
                 "mSatelliteServicesSupportedByCarriersFromConfig",
-                mSatelliteControllerUT, new HashMap<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         mCarrierConfigBundle.putBoolean(CarrierConfigManager.KEY_SATELLITE_ATTACH_SUPPORTED_BOOL,
                 true);
         mCarrierConfigBundle.putBoolean(
@@ -3412,7 +3459,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         // plmn list is empty, check whether valid entitlement plmn list is returned
         // when calling getSatellitePlmnsForCarrier before the entitlement query.
         replaceInstance(SatelliteController.class, "mEntitlementPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> expectedSatelliteEntitlementPlmnList = Arrays.asList("123456,12560");
         doReturn(expectedSatelliteEntitlementPlmnList).when(
                 mMockSubscriptionManagerService).getSatelliteEntitlementPlmnList(anyInt());
@@ -3431,7 +3478,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         // plmn list is valid, check whether valid entitlement plmn list is returned when
         // calling getSatellitePlmnsForCarrier before the entitlement query.
         replaceInstance(SatelliteController.class, "mEntitlementPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         PersistableBundle carrierSupportedSatelliteServicesPerProvider = new PersistableBundle();
         List<String> carrierConfigPlmnList = Arrays.asList("00102", "00103", "00105");
         carrierSupportedSatelliteServicesPerProvider.putIntArray(
@@ -3458,7 +3505,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         // plmn list is valid, check whether valid carrier config plmn list is returned when
         // calling getSatellitePlmnsForCarrier before the entitlement query.
         replaceInstance(SatelliteController.class, "mEntitlementPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         doReturn(new ArrayList<>()).when(
                 mMockSubscriptionManagerService).getSatelliteEntitlementPlmnList(anyInt());
         for (Pair<Executor, CarrierConfigManager.CarrierConfigChangeListener> pair
@@ -4242,6 +4289,50 @@ public class SatelliteControllerTest extends TelephonyTest {
         assertTrue(mSatelliteControllerUT.isFoldable(mContext, foldableDeviceStateList));
     }
 
+    @Test
+    public void testGetMaxAllowedDataMode() {
+        logd("testGetMaxAllowedDataMode");
+        doReturn(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED)
+                .when(mResources)
+                .getInteger(eq(R.integer.max_allowed_data_mode));
+
+        // case mMockConfigParser is null
+        doReturn(null).when(mMockConfigParser).getConfig();
+        assertEquals(
+                "Check satelliteConfig is null case",
+                SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED,
+                mSatelliteControllerUT.getMaxAllowedDataMode());
+
+        // case mMockConfig.getSatelliteMaxAllowedDataMode is null
+        doReturn(mMockConfig).when(mMockConfigParser).getConfig();
+        doReturn(null).when(mMockConfig).getSatelliteMaxAllowedDataMode();
+        assertEquals(
+                "Check getSatelliteMaxAllowedDataMode() is null case",
+                SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED,
+                mSatelliteControllerUT.getMaxAllowedDataMode());
+
+        // case mMockConfig.getSatelliteMaxAllowedDataMode is bigger than device config
+        doReturn(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+        assertEquals(
+                "Check satelliteConfig value is 'bandwidth constrained' case",
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED,
+                mSatelliteControllerUT.getMaxAllowedDataMode());
+
+        // case mMockConfig.getSatelliteMaxAllowedDataMode is smaller than device config
+        doReturn(SATELLITE_DATA_SUPPORT_ALL)
+                .when(mResources)
+                .getInteger(eq(R.integer.max_allowed_data_mode));
+        doReturn(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+        assertEquals(
+                "Check satelliteConfig value should override device config",
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED,
+                mSatelliteControllerUT.getMaxAllowedDataMode());
+    }
+
     @Test
     public void testTerrestrialNetworkAvailableChangedCallback() {
         when(mFeatureFlags.carrierRoamingNbIotNtn()).thenReturn(true);
@@ -4383,9 +4474,63 @@ public class SatelliteControllerTest extends TelephonyTest {
     @Test
     public void testProvisionSatellite() throws Exception {
         when(mFeatureFlags.carrierRoamingNbIotNtn()).thenReturn(true);
+        when(mFeatureFlags.satelliteImproveMultiThreadDesign()).thenReturn(true);
         verifyRequestSatelliteSubscriberProvisionStatus();
         List<SatelliteSubscriberInfo> inputList = getExpectedSatelliteSubscriberInfoList();
+
+        try {
+            replaceInstance(SatelliteController.class, "sInstance", null, mSatelliteControllerUT);
+        } catch (Exception ex) {
+            loge(ex.toString());
+        }
+        reset(mMockControllerMetricsStats);
+        reset(mMockAlarmManager);
+        doNothing().when(mMockAlarmManager).setExact(anyInt(), anyLong(), anyString(),
+                any(Executor.class), any(WorkSource.class), mAlarmListenerCaptor.capture());
         verifyProvisionSatellite(inputList);
+
+        int numberOfCarriers = (int) inputList.stream()
+                .map(SatelliteSubscriberInfo::getCarrierId)
+                .distinct()
+                .count();
+        // TODO b/409584433 for now handleRequestProvisionSatellite is invoked 2 times.
+        //  expectedMetricReportCallCount should be restore to numberOfCarriers eventually.
+        int expectedMetricReportCallCount = numberOfCarriers;
+        if (mFeatureFlags.satelliteImproveMultiThreadDesign()) {
+            expectedMetricReportCallCount *= 2;
+        }
+        verify(mMockControllerMetricsStats, times(expectedMetricReportCallCount)).setIsProvisioned(
+                anyInt(), eq(true), anyBoolean());
+        verify(mMockAlarmManager, atLeastOnce()).cancel(any(AlarmManager.OnAlarmListener.class));
+        verify(mMockAlarmManager, atLeastOnce()).setExact(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
+                anyLong(), anyString(), any(Executor.class),
+                any(WorkSource.class), any(AlarmManager.OnAlarmListener.class));
+        AlarmManager.OnAlarmListener capturedListener = mAlarmListenerCaptor.getValue();
+        if (capturedListener == null) {
+            fail("AlarmListener was not captured by AlarmManager.setExact()");
+        }
+
+        final CountDownLatch countDownLatch = new CountDownLatch(numberOfCarriers);
+        doAnswer(invocation -> {
+            countDownLatch.countDown();
+            return null;
+        }).when(mMockControllerMetricsStats).setIsProvisioned(anyInt(), anyBoolean(), anyBoolean());
+        capturedListener.onAlarm();
+        processAllMessages();
+        try {
+            if (!countDownLatch.await(2, TimeUnit.SECONDS)) {
+                fail("Handler did not process the expected message (latch timed out)");
+            }
+        } catch (InterruptedException ex) {
+            loge(ex.toString());
+        }
+        expectedMetricReportCallCount +=  numberOfCarriers;
+        verify(mMockControllerMetricsStats, times(expectedMetricReportCallCount)).setIsProvisioned(
+                anyInt(), eq(true), anyBoolean());
+        verify(mMockAlarmManager, atLeast(2)).cancel(any(AlarmManager.OnAlarmListener.class));
+        verify(mMockAlarmManager, atLeast(2)).setExact(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
+                anyLong(), anyString(), any(Executor.class),
+                any(WorkSource.class), any(AlarmManager.OnAlarmListener.class));
     }
 
     private void verifyProvisionSatellite(List<SatelliteSubscriberInfo> inputList) {
@@ -4458,7 +4603,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         inputList.add(list.get(0));
         verifyProvisionSatellite(inputList);
 
-        verify(mMockSatelliteModemInterface, times(1)).updateSatelliteSubscription(anyString(),
+        verify(mMockSatelliteModemInterface, times(2)).updateSatelliteSubscription(anyString(),
                 any());
         assertTrue(waitForForEvents(
                 semaphore, 1, "testRegisterForSatelliteSubscriptionProvisionStateChanged"));
@@ -4604,11 +4749,11 @@ public class SatelliteControllerTest extends TelephonyTest {
         Field provisionedSubscriberIdField = SatelliteController.class.getDeclaredField(
                 "mProvisionedSubscriberId");
         provisionedSubscriberIdField.setAccessible(true);
-        provisionedSubscriberIdField.set(mSatelliteControllerUT, new HashMap<>());
+        provisionedSubscriberIdField.set(mSatelliteControllerUT, new ConcurrentHashMap<>());
         Field subscriberIdPerSubField = SatelliteController.class.getDeclaredField(
                 "mSubscriberIdPerSub");
         subscriberIdPerSubField.setAccessible(true);
-        subscriberIdPerSubField.set(mSatelliteControllerUT, new HashMap<>());
+        subscriberIdPerSubField.set(mSatelliteControllerUT, new ConcurrentHashMap<>());
         Field lastConfiguredIccIdField = SatelliteController.class.getDeclaredField(
                 "mLastConfiguredIccId");
         lastConfiguredIccIdField.setAccessible(true);
@@ -4757,7 +4902,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         Field provisionedSubscriberIdField = SatelliteController.class.getDeclaredField(
                 "mProvisionedSubscriberId");
         provisionedSubscriberIdField.setAccessible(true);
-        Map<String, Boolean> testProvisionedSubscriberId = new HashMap<>();;
+        ConcurrentHashMap<String, Boolean> testProvisionedSubscriberId = new ConcurrentHashMap<>();
         testProvisionedSubscriberId.put(carrierSubscriberId, true);
         testProvisionedSubscriberId.put(oemSubscriberId, true);
         provisionedSubscriberIdField.set(mSatelliteControllerUT, testProvisionedSubscriberId);
@@ -4829,8 +4974,8 @@ public class SatelliteControllerTest extends TelephonyTest {
 
         List<SatelliteSubscriberInfo> inputList = getExpectedSatelliteSubscriberInfoList();
         verifyProvisionSatellite(inputList);
-        verify(mMockSubscriptionManagerService).setIsSatelliteProvisionedForNonIpDatagram(
-                eq(SUB_ID), eq(true));
+        verify(mMockSubscriptionManagerService, times(2))
+                .setIsSatelliteProvisionedForNonIpDatagram(eq(SUB_ID), eq(true));
     }
 
     @Test
@@ -4851,6 +4996,13 @@ public class SatelliteControllerTest extends TelephonyTest {
         }
         assertTrue(mSatelliteControllerUT
                 .isP2PSmsDisallowedOnCarrierRoamingNtn(/*subId*/ SUB_ID));
+
+        mSatelliteControllerUT.isSatelliteProvisioned = true;
+        mSatelliteControllerUT.setNtnSmsSupportedByMessagesApp(true);
+        mSatelliteControllerUT.mIsApplicationSupportsP2P = true;
+        processAllMessages();
+        assertFalse(mSatelliteControllerUT
+                .isP2PSmsDisallowedOnCarrierRoamingNtn(/*subId*/ SUB_ID));
     }
 
     @Test
@@ -5696,6 +5848,11 @@ public class SatelliteControllerTest extends TelephonyTest {
                 61 /* CMD_EVALUATE_CARRIER_ROAMING_NTN_ELIGIBILITY_CHANGE */).sendToTarget();
     }
 
+    private void sendEventWaitForRegularMetricsReportHysteresisTimedOut() {
+        mSatelliteControllerUT.obtainMessage(
+                53 /* EVENT_WAIT_FOR_REGULAR_METRICS_REPORT_HYSTERESIS_TIMED_OUT */).sendToTarget();
+    }
+
     private void sendCmdGetSatelliteEnabledForCarrier(Phone phone) {
         SatelliteController.SatelliteControllerHandlerRequest request =
                 new SatelliteController.SatelliteControllerHandlerRequest(null, phone);
@@ -5940,11 +6097,21 @@ public class SatelliteControllerTest extends TelephonyTest {
             isApplicationUpdated = false;
         }
 
+        @Nullable
+        public Phone getSatellitePhone() {
+            return super.getSatellitePhone();
+        }
+
         @Override
         protected void initializeSatelliteModeRadios() {
             logd("initializeSatelliteModeRadios");
         }
 
+        @NonNull
+        protected PersistableBundle getPersistableBundle(int subId) {
+            return super.getPersistableBundle(subId);
+        }
+
         @Override
         protected void setSettingsKeyForSatelliteMode(int val) {
             logd("setSettingsKeyForSatelliteMode: val=" + val);
@@ -5996,9 +6163,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         @Override
         protected void setSelectedSatelliteSubId(int subId) {
             logd("setSelectedSatelliteSubId: subId=" + subId);
-            synchronized (mSatelliteTokenProvisionedLock) {
-                mSelectedSatelliteSubId = subId;
-            }
+            mSelectedSatelliteSubId = new AtomicInteger(subId);
         }
 
         @Override
@@ -6065,42 +6230,43 @@ public class SatelliteControllerTest extends TelephonyTest {
         }
 
         void setSatelliteProvisioned(@Nullable Boolean isProvisioned) {
-            synchronized (mDeviceProvisionLock) {
-                mIsDeviceProvisioned = isProvisioned;
+            if (isProvisioned == null) {
+                mIsDeviceProvisioned = null;
+                return;
             }
-        }
 
-        void setIsSatelliteSupported(@Nullable Boolean isSatelliteSupported) {
-            synchronized (mIsSatelliteSupportedLock) {
-                mIsSatelliteSupported = isSatelliteSupported;
+            if (mIsDeviceProvisioned == null) {
+                mIsDeviceProvisioned = new AtomicBoolean(isProvisioned);
+            } else {
+                mIsDeviceProvisioned.set(isProvisioned);
             }
         }
 
+        @Override
+        protected void setIsSatelliteSupported(boolean isSatelliteSupported) {
+            super.setIsSatelliteSupported(isSatelliteSupported);
+        }
+
         @Override
         protected Set<String> getAllPlmnSet() {
             return super.getAllPlmnSet();
         }
 
         public boolean isRadioOn() {
-            synchronized (mIsRadioOnLock) {
-                return mIsRadioOn;
-            }
+            return mIsRadioOn.get();
         }
 
         public boolean isRadioOffRequested() {
-            synchronized (mIsRadioOnLock) {
-                return mRadioOffRequested;
-            }
+            return mRadioOffRequested.get();
         }
 
         public boolean isWaitForCellularModemOffTimerStarted() {
             return hasMessages(EVENT_WAIT_FOR_CELLULAR_MODEM_OFF_TIMED_OUT);
         }
 
-        public Map<String, Integer> subscriberIdPerSub() {
-            synchronized (mSatelliteTokenProvisionedLock) {
-                return mSubscriberIdPerSub;
-            }
+        /** Return subscriberId for each subscription map. */
+        public ConcurrentHashMap<String, Integer> subscriberIdPerSub() {
+            return mSubscriberIdPerSub;
         }
 
         public Map<Integer, List<SubscriptionInfo>> subsInfoListPerPriority() {
@@ -6126,21 +6292,15 @@ public class SatelliteControllerTest extends TelephonyTest {
         }
 
         public int getResultReceiverTotalCount() {
-            synchronized (mResultReceiverTotalCountLock) {
-                return mResultReceiverTotalCount;
-            }
+            return mResultReceiverTotalCount.get();
         }
 
-        public HashMap<String, Integer> getResultReceiverCountPerMethodMap() {
-            synchronized (mResultReceiverTotalCountLock) {
-                return mResultReceiverCountPerMethodMap;
-            }
+        public ConcurrentHashMap<String, Integer> getResultReceiverCountPerMethodMap() {
+            return mResultReceiverCountPerMethodMap;
         }
 
         public void setIsSatelliteAllowedState(boolean isAllowed) {
-            synchronized(mSatelliteAccessConfigLock) {
-                mSatelliteAccessAllowed = isAllowed;
-            }
+            mSatelliteAccessAllowed = new AtomicBoolean(isAllowed);
         }
 
         public void setCallOnlySuperMethod() {
@@ -6223,6 +6383,7 @@ public class SatelliteControllerTest extends TelephonyTest {
     public void testSetNtnSmsSupportedByMessagesApp() {
         when(mFeatureFlags.carrierRoamingNbIotNtn()).thenReturn(true);
         mSatelliteControllerUT.setNtnSmsSupportedByMessagesApp(true);
+        processAllMessages();
         assertTrue(mSharedPreferences.getBoolean(
                 SatelliteController.NTN_SMS_SUPPORTED_BY_MESSAGES_APP_KEY, false));
     }
@@ -6249,7 +6410,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("testGetSatelliteDataPlanForPlmn_WithEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6268,6 +6429,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, dataPlanListMap, new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         int dataPlanForPlmn;
         dataPlanForPlmn = mSatelliteControllerUT.getSatelliteDataPlanForPlmn(SUB_ID, "00101");
@@ -6282,7 +6444,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("testGetSatelliteDataPlanForPlmn_WithoutEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6299,6 +6461,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, dataPlanListMap, new HashMap<>(),
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         int dataPlanForPlmn = mSatelliteControllerUT.getSatelliteDataPlanForPlmn(SUB_ID, "00101");
         assertEquals(SATELLITE_DATA_PLAN_METERED, dataPlanForPlmn);
@@ -6310,7 +6473,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("TestGetSupportedSatelliteServicesForPlmn_WithEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6346,6 +6509,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         List<Integer> allowedServiceForPlmn;
         allowedServiceForPlmn = mSatelliteControllerUT
@@ -6368,7 +6532,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("TestGetSupportedSatelliteServicesForPlmn_WithEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6404,6 +6568,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         List<Integer> allowedServiceForPlmn;
         allowedServiceForPlmn = mSatelliteControllerUT
@@ -6429,7 +6594,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("TestGetSupportedSatelliteServicesForPlmn_WithEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6465,6 +6630,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         List<Integer> allowedServiceForPlmn;
         allowedServiceForPlmn = mSatelliteControllerUT
@@ -6487,7 +6653,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("TestGetSupportedSatelliteServicesForPlmn_WithEntitlement");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6523,6 +6689,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         List<Integer> allowedServiceForPlmn;
         allowedServiceForPlmn = mSatelliteControllerUT
@@ -6545,7 +6712,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         logd("TestGetSupportedSatelliteServicesForPlmn_WithoutAllowedServices");
 
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6563,6 +6730,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, dataPlanListMap, allowedServiceListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         // Verify whether the carrier config plmn list is returned with conditions below
         // the config data plmn list : empty
@@ -6591,11 +6759,17 @@ public class SatelliteControllerTest extends TelephonyTest {
     public void testGetSupportedSatelliteDataModeForPlmn_WithEntitlement() throws Exception {
         logd("testGetSupportedSatelliteDataModeForPlmn_WithEntitlement");
 
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode, SATELLITE_DATA_SUPPORT_ALL);
+        doReturn(SATELLITE_DATA_SUPPORT_ALL).when(mMockConfig).getSatelliteMaxAllowedDataMode();
+
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
+
+        // With Satellite entitlement support bool true with entitlement data service policy
         mCarrierConfigBundle.putBoolean(
                 CarrierConfigManager.KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, true);
         mCarrierConfigBundle.putBoolean(CarrierConfigManager.KEY_SATELLITE_ATTACH_SUPPORTED_BOOL,
@@ -6612,6 +6786,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 dataServicePolicyMap, new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         int dataSupportModeForPlmn;
         dataSupportModeForPlmn = mSatelliteControllerUT
@@ -6629,14 +6804,198 @@ public class SatelliteControllerTest extends TelephonyTest {
         dataSupportModeForPlmn = mSatelliteControllerUT
                 .getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
         assertEquals(SATELLITE_DATA_SUPPORT_ALL, dataSupportModeForPlmn);
+
+        // When satellite entitlement bool is false , validate the value is read from carrier
+        // config, when data services is supported
+        mCarrierConfigBundle.putBoolean(
+                CarrierConfigManager.KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, false);
+        setConfigData(new ArrayList<>());
+        PersistableBundle carrierSupportedSatelliteServicesPerProvider =
+                new PersistableBundle();
+        List<String> carrierConfigPlmnList = List.of("00101");
+        carrierSupportedSatelliteServicesPerProvider.putIntArray(
+                carrierConfigPlmnList.get(0), new int[]{2, 3, 5});
+        mCarrierConfigBundle.putPersistableBundle(CarrierConfigManager
+                        .KEY_CARRIER_SUPPORTED_SATELLITE_SERVICES_PER_PROVIDER_BUNDLE,
+                carrierSupportedSatelliteServicesPerProvider);
+        mCarrierConfigBundle.putInt(
+                CarrierConfigManager.KEY_SATELLITE_DATA_SUPPORT_MODE_INT,
+                SATELLITE_DATA_SUPPORT_ALL);
+        invokeCarrierConfigChanged();
+
+        // satellite data service policy for plmn is as per carrier config set when
+        // satellite entitlement boolean is false with satellite entitlement data available
+        dataSupportModeForPlmn = mSatelliteControllerUT
+                .getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_ALL, dataSupportModeForPlmn);
+
+        // Empty data service policy map case, validate the value is read from carrier
+        // config, when data services is supported
+        dataServicePolicyMap = new HashMap<>();
+        mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, true,
+                entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
+                dataServicePolicyMap, new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
+        mCarrierConfigBundle.putInt(
+                CarrierConfigManager.KEY_SATELLITE_DATA_SUPPORT_MODE_INT,
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        // satellite data service policy is as per carrier config set when data entitlement
+        // policy is empty
+        dataSupportModeForPlmn = mSatelliteControllerUT
+                .getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+    }
+
+    @Test
+    public void testRegularMetricsDataReport() throws Exception {
+        setSatelliteSubscriberTesting(false);
+        doReturn(new int[]{SUB_ID, SUB_ID1}).when(mMockSubscriptionManagerService)
+                .getActiveSubIdList(true);
+        doReturn(mMockConfig).when(mMockConfigParser).getConfig();
+
+        sendEventWaitForRegularMetricsReportHysteresisTimedOut();
+        processAllMessages();
+
+        verify(mMockControllerMetricsStats, times(1))
+                .setIsProvisioned(anyInt(), anyBoolean(), anyBoolean());
+        verify(mMockCarrierRoamingSatelliteControllerStats, times(2))
+                .reportIsDeviceEntitled(anyInt(), anyBoolean());
+        verify(mMockControllerMetricsStats, times(2))
+                .reportCurrentVersionOfCarrierRoamingSatelliteConfig(anyInt(), anyInt());
+        verify(mMockControllerMetricsStats, times(2))
+                .reportCurrentMaxAllowedDataMode(anyInt(), anyInt());
+
+        verify(mMockAlarmManager, atLeast(1))
+                .cancel(any(AlarmManager.OnAlarmListener.class));
+        verify(mMockAlarmManager, atLeast(1))
+                .setExact(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP), anyLong(), anyString(),
+                        any(Executor.class), any(WorkSource.class),
+                        any(AlarmManager.OnAlarmListener.class));
+    }
+
+    @Test
+    public void testGetSupportedSatelliteDataModeForPlmn_WithEntitlement_AllMaxAllowedDataMode()
+            throws Exception {
+        logd("testGetSupportedSatelliteDataModeForPlmn_WithEntitlement_AllMaxAllowedDataMode");
+
+        replaceInstance(
+                SatelliteController.class,
+                "mMergedPlmnListPerCarrier",
+                mSatelliteControllerUT,
+                new ConcurrentHashMap<>());
+        List<String> overlayConfigPlmnList = new ArrayList<>();
+        replaceInstance(
+                SatelliteController.class,
+                "mSatellitePlmnListFromOverlayConfig",
+                mSatelliteControllerUT,
+                overlayConfigPlmnList);
+        mCarrierConfigBundle.putBoolean(
+                CarrierConfigManager.KEY_SATELLITE_ATTACH_SUPPORTED_BOOL, true);
+
+        // With Satellite entitlement support bool true with entitlement data service policy map
+        mCarrierConfigBundle.putBoolean(
+                CarrierConfigManager.KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, true);
+
+        List<String> entitlementPlmnList =
+                Arrays.stream(new String[] {"00101", "00102", "00103", "00104"}).toList();
+        List<String> barredPlmnList = new ArrayList<>();
+        Map<String, Integer> dataServicePolicyMap =
+                Map.of(
+                        "00101", SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED,
+                        "00102", SATELLITE_DATA_SUPPORT_ALL);
+        mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(
+                SUB_ID,
+                false,
+                entitlementPlmnList,
+                barredPlmnList,
+                new HashMap<>(),
+                new HashMap<>(),
+                dataServicePolicyMap,
+                new HashMap<>(),
+                mIIntegerConsumer);
+        processAllMessages();
+
+        // Cap maxAllowedDataMode to SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode,
+                SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED);
+        doReturn(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+
+        int dataSupportModeForPlmn;
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00102");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        // Cap maxAllowedDataMode to SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode,
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        doReturn(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00102");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        // Cap maxAllowedDataMode to SATELLITE_DATA_SUPPORT_ALL
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode, SATELLITE_DATA_SUPPORT_ALL);
+        doReturn(SATELLITE_DATA_SUPPORT_ALL).when(mMockConfig).getSatelliteMaxAllowedDataMode();
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00102");
+        assertEquals(SATELLITE_DATA_SUPPORT_ALL, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ALL, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ALL, dataSupportModeForPlmn);
     }
 
     @Test
     public void testGetSupportedSatelliteDataModeForPlmn_WithoutEntitlement() throws Exception {
         logd("testGetSupportedSatelliteDataModeForPlmn_WithoutEntitlement");
 
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode, SATELLITE_DATA_SUPPORT_ALL);
+        doReturn(SATELLITE_DATA_SUPPORT_ALL).when(mMockConfig).getSatelliteMaxAllowedDataMode();
+
         replaceInstance(SatelliteController.class, "mMergedPlmnListPerCarrier",
-                mSatelliteControllerUT, new SparseArray<>());
+                mSatelliteControllerUT, new ConcurrentHashMap<>());
         List<String> overlayConfigPlmnList = new ArrayList<>();
         replaceInstance(SatelliteController.class, "mSatellitePlmnListFromOverlayConfig",
                 mSatelliteControllerUT, overlayConfigPlmnList);
@@ -6653,6 +7012,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), new HashMap<>(),
                 dataServicePolicyMap, new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
 
         // when Available satellite services is not configured with data service
         mCarrierConfigBundle.putInt(
@@ -6690,6 +7050,132 @@ public class SatelliteControllerTest extends TelephonyTest {
                 .getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
         assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
 
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+    }
+
+    @Test
+    public void testGetSupportedSatelliteDataModeForPlmn_WithoutEntitlement_AllMaxAllowedDataMode()
+            throws Exception {
+        logd("testGetSupportedSatelliteDataModeForPlmn_WithoutEntitlement_AllMaxAllowedDataMode");
+
+        replaceInstance(
+                SatelliteController.class,
+                "mMergedPlmnListPerCarrier",
+                mSatelliteControllerUT,
+                new ConcurrentHashMap<>());
+        List<String> overlayConfigPlmnList = new ArrayList<>();
+        replaceInstance(
+                SatelliteController.class,
+                "mSatellitePlmnListFromOverlayConfig",
+                mSatelliteControllerUT,
+                overlayConfigPlmnList);
+        mCarrierConfigBundle.putBoolean(
+                CarrierConfigManager.KEY_SATELLITE_ATTACH_SUPPORTED_BOOL, true);
+
+        // Without entitlement
+        mCarrierConfigBundle.putBoolean(
+                CarrierConfigManager.KEY_SATELLITE_ENTITLEMENT_SUPPORTED_BOOL, false);
+
+        List<String> entitlementPlmnList =
+                Arrays.stream(new String[] {"00101", "00102", "00103", "00104"}).toList();
+        List<String> barredPlmnList = new ArrayList<>();
+        Map<String, Integer> dataServicePolicyMap = new HashMap<>();
+        mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(
+                SUB_ID,
+                false,
+                entitlementPlmnList,
+                barredPlmnList,
+                new HashMap<>(),
+                new HashMap<>(),
+                dataServicePolicyMap,
+                new HashMap<>(),
+                mIIntegerConsumer);
+        processAllMessages();
+
+        // when Available satellite services is not configured with data service
+        mCarrierConfigBundle.putInt(
+                CarrierConfigManager.KEY_SATELLITE_DATA_SUPPORT_MODE_INT,
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        int dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        setConfigData(new ArrayList<>());
+        PersistableBundle carrierSupportedSatelliteServicesPerProvider = new PersistableBundle();
+        List<String> carrierConfigPlmnList = List.of("00101");
+        carrierSupportedSatelliteServicesPerProvider.putIntArray(
+                carrierConfigPlmnList.get(0), new int[] {2, 3, 5});
+        mCarrierConfigBundle.putPersistableBundle(
+                CarrierConfigManager.KEY_CARRIER_SUPPORTED_SATELLITE_SERVICES_PER_PROVIDER_BUNDLE,
+                carrierSupportedSatelliteServicesPerProvider);
+        invokeCarrierConfigChanged();
+
+        // when Available satellite services support data service
+        // And maxAllowedDataMode capped to SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode,
+                SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED);
+        doReturn(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        // when Available satellite services support data service
+        // And maxAllowedDataMode capped to SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode,
+                SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED);
+        doReturn(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED)
+                .when(mMockConfig)
+                .getSatelliteMaxAllowedDataMode();
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
+        // when Available satellite services support data service
+        // And maxAllowedDataMode capped to SATELLITE_DATA_SUPPORT_ALL
+        mContextFixture.putIntResource(
+                com.android.internal.R.integer.max_allowed_data_mode, SATELLITE_DATA_SUPPORT_ALL);
+        doReturn(SATELLITE_DATA_SUPPORT_ALL).when(mMockConfig).getSatelliteMaxAllowedDataMode();
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "00101");
+        assertEquals(SATELLITE_DATA_SUPPORT_BANDWIDTH_CONSTRAINED, dataSupportModeForPlmn);
+
+        dataSupportModeForPlmn =
+                mSatelliteControllerUT.getSatelliteDataServicePolicyForPlmn(SUB_ID, "");
+        assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
+
         dataSupportModeForPlmn = mSatelliteControllerUT
                 .getSatelliteDataServicePolicyForPlmn(SUB_ID, null);
         assertEquals(SATELLITE_DATA_SUPPORT_ONLY_RESTRICTED, dataSupportModeForPlmn);
@@ -6716,6 +7202,7 @@ public class SatelliteControllerTest extends TelephonyTest {
                 entitlementPlmnList, new ArrayList<>(), new HashMap<>(),
                 new HashMap<>() /*serviceTypeListMap*/, new HashMap<>(), new HashMap<>(),
                 mIIntegerConsumer);
+        processAllMessages();
         verify(mPhone, times(2)).notifyCarrierRoamingNtnAvailableServicesChanged(
                 (int[]) ArgumentMatchers.any());
     }
@@ -6743,6 +7230,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         int[] expectedServices = new int[]{1, 2, 3};
         int[] supportedServices = mSatelliteControllerUT.getSupportedServicesOnCarrierRoamingNtn(
                 SUB_ID);
@@ -6775,6 +7263,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         int[] expectedServices = new int[]{1, 2, 3};
         int[] supportedServices = mSatelliteControllerUT.getSupportedServicesOnCarrierRoamingNtn(
                 SUB_ID);
@@ -6785,6 +7274,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         // There is no change in services between 2 calls, so notify should not invoke again.
         supportedServices = mSatelliteControllerUT.getSupportedServicesOnCarrierRoamingNtn(SUB_ID);
         assertArrayEquals(expectedServices, supportedServices);
@@ -6816,6 +7306,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         int[] expectedServices = new int[]{1, 2, 3};
         int[] supportedServices = mSatelliteControllerUT.getSupportedServicesOnCarrierRoamingNtn(
                 SUB_ID);
@@ -6828,6 +7319,7 @@ public class SatelliteControllerTest extends TelephonyTest {
         mSatelliteControllerUT.onSatelliteEntitlementStatusUpdated(SUB_ID, false,
                 entitlementPlmnList, barredPlmnList, new HashMap<>(), serviceTypeListMap,
                 new HashMap<>(), new HashMap<>(), mIIntegerConsumer);
+        processAllMessages();
         expectedServices = new int[]{1, 3};
         supportedServices = mSatelliteControllerUT.getSupportedServicesOnCarrierRoamingNtn(SUB_ID);
         assertArrayEquals(expectedServices, supportedServices);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommenderTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommenderTest.java
index ed709fc009..c4fb172349 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommenderTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSOSMessageRecommenderTest.java
@@ -396,20 +396,48 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
         processAllMessages();
         assertNull(mTestSOSMessageRecommender.isSatelliteAllowedCallback);
 
+        int slotIdForSubId1 = 1;
         mTestSatelliteController.setSatelliteConnectedViaCarrierWithinHysteresisTime(
             true, SUB_ID1);
+        when(mSubscriptionManager.getSlotIndex(SUB_ID1)).thenReturn(slotIdForSubId1);
         // Wait for the timeout to expires
         moveTimeForward(TEST_EMERGENCY_CALL_TO_SOS_MSG_HYSTERESIS_TIMEOUT_MILLIS);
         processAllMessages();
         assertTrue(mTestConnection.isEventSent(TelephonyManager.EVENT_DISPLAY_EMERGENCY_MESSAGE,
                 EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911,
                 DEFAULT_SATELLITE_MESSAGING_PACKAGE, DEFAULT_SATELLITE_MESSAGING_CLASS,
-                DEFAULT_T911_HANDOVER_INTENT_ACTION));
+                DEFAULT_T911_HANDOVER_INTENT_ACTION, slotIdForSubId1));
         assertUnregisterForStateChangedEventsTriggered(mPhone, 1, 1);
         assertUnregisterForStateChangedEventsTriggered(mPhone2, 1, 1);
         mTestSatelliteController.isOemEnabledSatelliteSupported = true;
     }
 
+    @Test
+    public void testSendEventDisplayEmergencyMessageForcefully() {
+        mTestSOSMessageRecommender.isSatelliteAllowedCallback = null;
+        mTestSatelliteController.setSatelliteConnectedViaCarrierWithinHysteresisTime(false, -1);
+        mTestSatelliteController.isOemEnabledSatelliteSupported = false;
+        mTestSatelliteController.overrideEmergencyCallToSatelliteHandoverType =
+                EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911;
+        mTestSatelliteController.simSlotIdForLaunchingT911ConversationThread = 2;
+        mTestSOSMessageRecommender.onEmergencyCallStarted(mTestConnection, false);
+        processAllMessages();
+        assertTrue(mTestConnection.isEventSent(TelephonyManager.EVENT_DISPLAY_EMERGENCY_MESSAGE,
+                EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911,
+                DEFAULT_SATELLITE_MESSAGING_PACKAGE, DEFAULT_SATELLITE_MESSAGING_CLASS,
+                DEFAULT_T911_HANDOVER_INTENT_ACTION,
+                mTestSatelliteController.simSlotIdForLaunchingT911ConversationThread));
+
+        mTestSatelliteController.simSlotIdForLaunchingT911ConversationThread =
+            SubscriptionManager.INVALID_SIM_SLOT_INDEX;
+        mTestSOSMessageRecommender.onEmergencyCallStarted(mTestConnection, false);
+        processAllMessages();
+        assertTrue(mTestConnection.isEventSent(TelephonyManager.EVENT_DISPLAY_EMERGENCY_MESSAGE,
+                EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911,
+                DEFAULT_SATELLITE_MESSAGING_PACKAGE, DEFAULT_SATELLITE_MESSAGING_CLASS,
+                DEFAULT_T911_HANDOVER_INTENT_ACTION, -1));
+    }
+
     @Test
     public void testStopTrackingCallBeforeTimeout_ConnectionActive() {
         testStopTrackingCallBeforeTimeout(Connection.STATE_ACTIVE);
@@ -921,6 +949,7 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
                 TEST_EMERGENCY_CALL_TO_T911_MSG_HYSTERESIS_TIMEOUT_MILLIS;
         public int overrideEmergencyCallToSatelliteHandoverType =
             SatelliteController.INVALID_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE;
+        public int simSlotIdForLaunchingT911ConversationThread = -1;
         public boolean isSatelliteEsosSupported = false;
         public int carrierRoamingNtnEmergencyCallToSatelliteHandoverType =
             EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911;
@@ -991,6 +1020,11 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
             return overrideEmergencyCallToSatelliteHandoverType;
         }
 
+        @Override
+        protected int getSimSlotIdForLaunchingT911ConversationThread() {
+            return simSlotIdForLaunchingT911ConversationThread;
+        }
+
         @Override
         public boolean isSatelliteEmergencyMessagingSupportedViaCarrier() {
             return isSatelliteEmergencyMessagingSupportedViaCarrier;
@@ -1206,12 +1240,22 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
             return isSatelliteAllowedByReasons;
         }
 
+        @Override
+        protected boolean isDeviceProvisioned() {
+            return super.isDeviceProvisioned();
+        }
+
+        @Override
+        protected int getEmergencyCallToSatelliteHandoverType() {
+            return super.getEmergencyCallToSatelliteHandoverType();
+        }
+
         public boolean isTimerStarted() {
             return hasMessages(EVENT_TIME_OUT);
         }
 
         public int getCountOfTimerStarted() {
-            return mCountOfTimerStarted;
+            return mCountOfTimerStarted.get();
         }
 
         public void sendServiceStateChangedEvent() {
@@ -1219,7 +1263,7 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
         }
 
         public long getTimeOutMillis() {
-            return mTimeoutMillis;
+            return mTimeoutMillis.get();
         }
 
         public boolean isDialerNotified() {
@@ -1269,6 +1313,30 @@ public class SatelliteSOSMessageRecommenderTest extends TelephonyTest {
             return true;
         }
 
+        public boolean isEventSent(String event, int handoverType, String packageName,
+                String className, String action, int simSlotId) {
+            if (mSentEvent == null || mExtras == null) {
+                return false;
+            }
+
+            PendingIntent pendingIntent = mExtras.getParcelable(
+                    EXTRA_EMERGENCY_CALL_TO_SATELLITE_LAUNCH_INTENT, PendingIntent.class);
+            Intent intent = pendingIntent.getIntent();
+            if (!TextUtils.equals(event, mSentEvent) || handoverType != mExtras.getInt(
+                    EXTRA_EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE)
+                    || !TextUtils.equals(packageName, intent.getComponent().getPackageName())
+                    || !TextUtils.equals(className, intent.getComponent().getClassName())
+                    || !TextUtils.equals(action, intent.getAction())) {
+                return false;
+            }
+            if (handoverType == EMERGENCY_CALL_TO_SATELLITE_HANDOVER_TYPE_T911) {
+                if (simSlotId != intent.getIntExtra(TelephonyManager.EXTRA_SIM_SLOT_ID, -1)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+
         public boolean isEventWithoutLaunchIntentSent(String event, int handoverType) {
             if (mSentEvent == null || mExtras == null) {
                 return false;
diff --git a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSessionControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSessionControllerTest.java
index 65bfb83384..4f24460ff6 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSessionControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/satellite/SatelliteSessionControllerTest.java
@@ -116,10 +116,10 @@ public class SatelliteSessionControllerTest extends TelephonyTest {
     private TestSatelliteSessionController mTestSatelliteSessionController;
     private TestSatelliteModemStateCallback mTestSatelliteModemStateCallback;
 
-    @Mock private SatelliteController mMockSatelliteController;
+    @Mock private SatelliteControllerTest.TestSatelliteController mMockSatelliteController;
     @Mock private DatagramReceiver mMockDatagramReceiver;
     @Mock private DatagramDispatcher mMockDatagramDispatcher;
-    @Mock private DatagramController mMockDatagramController;
+    @Mock private DatagramControllerTest.TestDatagramController mMockDatagramController;
     @Mock private ServiceState mMockServiceState;
     @Mock private SessionMetricsStats mMockSessionMetricsStats;
     @Mock private AlarmManager mAlarmManager;
diff --git a/tests/telephonytests/src/com/android/internal/telephony/security/CellularNetworkSecuritySafetySourceTest.java b/tests/telephonytests/src/com/android/internal/telephony/security/CellularNetworkSecuritySafetySourceTest.java
index 0578ef9a01..6b9017e04f 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/security/CellularNetworkSecuritySafetySourceTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/security/CellularNetworkSecuritySafetySourceTest.java
@@ -32,8 +32,10 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
 import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.safetycenter.SafetySourceData;
 import android.safetycenter.SafetySourceIssue;
 
@@ -110,9 +112,62 @@ public final class CellularNetworkSecuritySafetySourceTest extends TelephonyTest
 
     @Test
     public void disableNullCipherIssue_nullData() {
+        ArgumentCaptor<SafetySourceData> data = ArgumentCaptor.forClass(SafetySourceData.class);
+
+        mSafetySource.setNullCipherIssueEnabled(mContext, true);
         mSafetySource.setNullCipherIssueEnabled(mContext, false);
 
-        verify(mSafetyCenterManagerWrapper, times(1)).setSafetySourceData(isNull());
+        verify(mSafetyCenterManagerWrapper, times(2)).setSafetySourceData(data.capture());
+        assertThat(data.getAllValues().get(1)).isNull();
+    }
+
+    @Test
+    public void setNullCipherIssueEnabled_unregisterReceiver() {
+        mSafetySource.setNullCipherIssueEnabled(mContext, true);
+        mSafetySource.setNullCipherIssueEnabled(mContext, false);
+
+        verify(mContext, times(1)).unregisterReceiver(any());
+    }
+
+    @Test
+    public void setNullCipherIssueEnabled_registerReceiver() {
+        ArgumentCaptor<IntentFilter> intentFilter = ArgumentCaptor.forClass(IntentFilter.class);
+
+        mSafetySource.setNullCipherIssueEnabled(mContext, true);
+
+        verify(mContext, times(1)).registerReceiver(any(), intentFilter.capture());
+        assertThat(intentFilter.getAllValues().get(0).getAction(0)).isEqualTo(
+                Intent.ACTION_AIRPLANE_MODE_CHANGED);
+    }
+
+    @Test
+    public void cellularNetworkSecurityBroadcastReceiver_onReceive_enableAirplaneMode() {
+        ArgumentCaptor<BroadcastReceiver> broadcastReceiver =
+                ArgumentCaptor.forClass(BroadcastReceiver.class);
+        Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        intent.putExtra("state", true);
+        mSafetySource.setNullCipherIssueEnabled(mContext, true);
+
+        verify(mContext, times(1)).registerReceiver(broadcastReceiver.capture(), any());
+
+        broadcastReceiver.getAllValues().get(0).onReceive(mContext, intent);
+
+        verify(mSafetyCenterManagerWrapper, times(2)).setSafetySourceData(any());
+    }
+
+    @Test
+    public void cellularNetworkSecurityBroadcastReceiver_onReceive_disableAirplaneMode() {
+        ArgumentCaptor<BroadcastReceiver> broadcastReceiver =
+                ArgumentCaptor.forClass(BroadcastReceiver.class);
+        Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        intent.putExtra("state", false);
+        mSafetySource.setNullCipherIssueEnabled(mContext, true);
+
+        verify(mContext, times(1)).registerReceiver(broadcastReceiver.capture(), any());
+
+        broadcastReceiver.getAllValues().get(0).onReceive(mContext, intent);
+
+        verify(mSafetyCenterManagerWrapper, times(1)).setSafetySourceData(any());
     }
 
     @Test
diff --git a/tests/telephonytests/src/com/android/internal/telephony/security/NullCipherNotifierTest.java b/tests/telephonytests/src/com/android/internal/telephony/security/NullCipherNotifierTest.java
index 6a4d2fbf94..a1b97e6171 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/security/NullCipherNotifierTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/security/NullCipherNotifierTest.java
@@ -72,8 +72,7 @@ public class NullCipherNotifierTest {
                     SecurityAlgorithmUpdate.SECURITY_ALGORITHM_NEA0,
                     SecurityAlgorithmUpdate.SECURITY_ALGORITHM_IMS_NULL,
                     SecurityAlgorithmUpdate.SECURITY_ALGORITHM_SIP_NULL,
-                    SecurityAlgorithmUpdate.SECURITY_ALGORITHM_SRTP_NULL,
-                    SecurityAlgorithmUpdate.SECURITY_ALGORITHM_OTHER);
+                    SecurityAlgorithmUpdate.SECURITY_ALGORITHM_SRTP_NULL);
     private static final List<Integer> NON_NULL_CIPHERS =
             List.of(SecurityAlgorithmUpdate.SECURITY_ALGORITHM_A51,
                     SecurityAlgorithmUpdate.SECURITY_ALGORITHM_A52,
diff --git a/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionDatabaseManagerTest.java b/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionDatabaseManagerTest.java
index 9890f213b9..bc6e8a42bb 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionDatabaseManagerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionDatabaseManagerTest.java
@@ -75,6 +75,10 @@ public class SubscriptionDatabaseManagerTest extends TelephonyTest {
     static final String FAKE_DEFAULT_CARD_NAME = "CARD %d";
     static final String FAKE_ICCID1 = "123456";
     static final String FAKE_ICCID2 = "456789";
+
+    static final String FAKE_ICCID3 = "12345F";
+
+    static final String FAKE_ICCID4 = "00:1A:2B:3C:4D:5F";
     static final String FAKE_PHONE_NUMBER1 = "9995551234";
     static final String FAKE_PHONE_NUMBER2 = "9998887777";
     static final String FAKE_CARRIER_NAME1 = "A-Mobile";
diff --git a/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionManagerServiceTest.java b/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionManagerServiceTest.java
index 492b94ea25..440eee874c 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionManagerServiceTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/subscription/SubscriptionManagerServiceTest.java
@@ -28,6 +28,8 @@ import static com.android.internal.telephony.subscription.SubscriptionDatabaseMa
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_HPLMNS1;
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_ICCID1;
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_ICCID2;
+import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_ICCID3;
+import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_ICCID4;
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_IMSI1;
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_MAC_ADDRESS1;
 import static com.android.internal.telephony.subscription.SubscriptionDatabaseManagerTest.FAKE_MAC_ADDRESS2;
@@ -222,8 +224,6 @@ public class SubscriptionManagerServiceTest extends TelephonyTest {
         ((MockContentResolver) mContext.getContentResolver()).addProvider(
                 Telephony.Carriers.CONTENT_URI.getAuthority(), mSubscriptionProvider);
 
-        doReturn(true).when(mFeatureFlags).ddsCallback();
-
         mSubscriptionManagerServiceUT = new SubscriptionManagerService(mContext, Looper.myLooper(),
                 mFeatureFlags);
 
@@ -3599,4 +3599,156 @@ public class SubscriptionManagerServiceTest extends TelephonyTest {
     public void testIsSatelliteProvisionedForNonIpDatagram() {
         assertFalse(mSubscriptionManagerServiceUT.isSatelliteProvisionedForNonIpDatagram(-1));
     }
+
+    /**
+     * Simulates a device environment where the
+     * {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION} feature is unavailable.
+     *
+     * This is necessary for testing scenarios specific to automotive devices, which
+     * may not always have the telephony subscription feature enabled. It allows us to
+     * verify the behavior of certain APIs when this feature is not available, even if the
+     * test device technically supports it. These APIs should function regardless for
+     * Remote SIM.
+     */
+    private void simulateNoTelephonySubscriptionSupport() throws Exception {
+        doReturn(false).when(mPackageManager).hasSystemFeature(
+                eq(PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION));
+        int vendorApiLevel = Build.VERSION_CODES.BAKLAVA;
+        replaceInstance(SubscriptionManagerService.class, "mVendorApiLevel",
+                mSubscriptionManagerServiceUT, vendorApiLevel);
+        mContextFixture.putBooleanResource(
+                com.android.internal.R.bool.config_force_phone_globals_creation, true);
+    }
+
+    @Test
+    @EnableCompatChanges({TelephonyManager.ENABLE_FEATURE_MAPPING})
+    public void testRemoteSimNoTelephonySubscription() throws Exception {
+        simulateNoTelephonySubscriptionSupport();
+
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.MODIFY_PHONE_STATE);
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
+
+        mSubscriptionManagerServiceUT.addSubInfo(FAKE_MAC_ADDRESS1, FAKE_CARRIER_NAME1,
+                0, SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
+        processAllMessages();
+
+        verify(mMockedSubscriptionManagerServiceCallback).onSubscriptionChanged(eq(1));
+
+        SubscriptionInfoInternal subInfo = mSubscriptionManagerServiceUT
+                .getSubscriptionInfoInternal(1);
+        assertThat(subInfo.getIccId()).isEqualTo(FAKE_MAC_ADDRESS1);
+        assertThat(subInfo.getDisplayName()).isEqualTo(FAKE_CARRIER_NAME1);
+        assertThat(subInfo.getSimSlotIndex()).isEqualTo(
+                SubscriptionManager.INVALID_SIM_SLOT_INDEX);
+        assertThat(subInfo.getSubscriptionType()).isEqualTo(
+                SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
+
+        assertThat(mSubscriptionManagerServiceUT.removeSubInfo(FAKE_MAC_ADDRESS1,
+                SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM)).isEqualTo(true);
+        assertThat(mSubscriptionManagerServiceUT.getAllSubInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE)).isEmpty();
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubIdList(false)).isEmpty();
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubscriptionInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE, true)).isEmpty();
+
+        setIdentifierAccess(true);
+        mSubscriptionManagerServiceUT.addSubInfo(FAKE_MAC_ADDRESS2, FAKE_CARRIER_NAME2,
+                0, SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubIdList(false)).isNotEmpty();
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubscriptionInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE, true)).isNotEmpty();
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubscriptionInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE, true).get(0).getIccId())
+                .isEqualTo(FAKE_MAC_ADDRESS2);
+    }
+
+    @Test
+    @EnableCompatChanges({TelephonyManager.ENABLE_FEATURE_MAPPING})
+    public void testGetActiveSubscriptionInfoListNoTelephonySubscription() throws Exception {
+        simulateNoTelephonySubscriptionSupport();
+
+        // Grant MODIFY_PHONE_STATE permission for insertion.
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.MODIFY_PHONE_STATE);
+        insertSubscription(FAKE_SUBSCRIPTION_INFO1);
+        insertSubscription(new SubscriptionInfoInternal.Builder(FAKE_SUBSCRIPTION_INFO2)
+                .setSimSlotIndex(SubscriptionManager.INVALID_SIM_SLOT_INDEX).build());
+        // Remove MODIFY_PHONE_STATE
+        mContextFixture.removeCallingOrSelfPermission(Manifest.permission.MODIFY_PHONE_STATE);
+
+        // Should get an empty list without READ_PHONE_STATE.
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubscriptionInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE, true)).isEmpty();
+
+        // Grant READ_PHONE_STATE permission for insertion.
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PHONE_STATE);
+        // Allow the application to perform.
+        doReturn(AppOpsManager.MODE_ALLOWED).when(mAppOpsManager)
+                .noteOpNoThrow(eq(AppOpsManager.OPSTR_READ_PHONE_STATE), anyInt(),
+                        nullable(String.class), nullable(String.class), nullable(String.class));
+
+        List<SubscriptionInfo> subInfos = mSubscriptionManagerServiceUT
+                .getActiveSubscriptionInfoList(CALLING_PACKAGE, CALLING_FEATURE, true);
+        // Identifying information removed
+        assertThat(subInfos).hasSize(1);
+        assertThat(subInfos.get(0).getIccId()).isEmpty();
+        assertThat(subInfos.get(0).getCardString()).isEmpty();
+        assertThat(subInfos.get(0).getNumber()).isEmpty();
+        assertThat(subInfos.get(0).getGroupUuid()).isNull();
+
+        // Grant carrier privilege
+        setCarrierPrivilegesForSubId(true, 1);
+
+        subInfos = mSubscriptionManagerServiceUT
+                .getActiveSubscriptionInfoList(CALLING_PACKAGE, CALLING_FEATURE, true);
+        assertThat(subInfos).hasSize(1);
+        assertThat(subInfos.get(0)).isEqualTo(FAKE_SUBSCRIPTION_INFO1.toSubscriptionInfo());
+    }
+
+    @Test
+    @EnableCompatChanges({TelephonyManager.ENABLE_FEATURE_MAPPING})
+    public void testGetActiveSubscriptionInfoForIccIdNoTelephonySubscription() throws Exception {
+        simulateNoTelephonySubscriptionSupport();
+
+        insertSubscription(FAKE_SUBSCRIPTION_INFO1);
+
+        // Should fail without READ_PRIVILEGED_PHONE_STATE
+        assertThrows(SecurityException.class, () -> mSubscriptionManagerServiceUT
+                .getActiveSubscriptionInfoForIccId(FAKE_ICCID1, CALLING_PACKAGE, CALLING_FEATURE));
+
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
+        SubscriptionInfo subInfo = mSubscriptionManagerServiceUT.getActiveSubscriptionInfoForIccId(
+                FAKE_ICCID1, CALLING_PACKAGE, CALLING_FEATURE);
+        assertThat(subInfo).isEqualTo(FAKE_SUBSCRIPTION_INFO1.toSubscriptionInfo());
+    }
+
+    @Test
+    @EnableCompatChanges({TelephonyManager.ENABLE_FEATURE_MAPPING})
+    public void testRemoveSubInfoNoTelephonySubscription() throws Exception {
+        simulateNoTelephonySubscriptionSupport();
+
+        insertSubscription(FAKE_SUBSCRIPTION_INFO1);
+        insertSubscription(FAKE_SUBSCRIPTION_INFO2);
+
+        assertThrows(SecurityException.class, () -> mSubscriptionManagerServiceUT
+                .removeSubInfo(FAKE_ICCID1, SubscriptionManager.SUBSCRIPTION_TYPE_LOCAL_SIM));
+
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.MODIFY_PHONE_STATE);
+        assertThat(mSubscriptionManagerServiceUT.removeSubInfo(FAKE_ICCID1,
+                SubscriptionManager.SUBSCRIPTION_TYPE_LOCAL_SIM)).isEqualTo(true);
+        assertThat(mSubscriptionManagerServiceUT.removeSubInfo(FAKE_ICCID2,
+                SubscriptionManager.SUBSCRIPTION_TYPE_LOCAL_SIM)).isEqualTo(true);
+
+        mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
+        assertThat(mSubscriptionManagerServiceUT.getActiveSubscriptionInfoList(
+                CALLING_PACKAGE, CALLING_FEATURE, true)).isEmpty();
+    }
+
+    @Test
+    @EnableCompatChanges({TelephonyManager.ENABLE_FEATURE_MAPPING})
+    public void testIccIdStripping() {
+        assertThat(SubscriptionManagerService.getStrippedIccid(FAKE_ICCID1)).isEqualTo(FAKE_ICCID1);
+        assertThat(SubscriptionManagerService.getStrippedIccid(FAKE_ICCID2)).isEqualTo(FAKE_ICCID2);
+        assertThat(SubscriptionManagerService.getStrippedIccid(FAKE_ICCID3)).isEqualTo("12345");
+        assertThat(SubscriptionManagerService.getStrippedIccid(FAKE_ICCID4)).isEqualTo(FAKE_ICCID4);
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/PinStorageTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/PinStorageTest.java
index ea6c778c86..5d03170fcf 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/PinStorageTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/PinStorageTest.java
@@ -27,6 +27,7 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.content.Intent;
+import android.os.Looper;
 import android.os.PersistableBundle;
 import android.os.WorkSource;
 import android.preference.PreferenceManager;
@@ -38,7 +39,6 @@ import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
 
 import androidx.test.InstrumentationRegistry;
-import androidx.test.filters.SmallTest;
 
 import com.android.internal.R;
 import com.android.internal.telephony.PhoneConstants;
@@ -69,7 +69,7 @@ public class PinStorageTest extends TelephonyTest {
     // mocks
     private CarrierConfigManager.CarrierConfigChangeListener mCarrierConfigChangeListener;
 
-    private void simulateReboot() {
+    private void simulateReboot() throws Exception {
         mSimulatedRebootsCount++;
         Settings.Global.putInt(mContext.getContentResolver(),
                 Settings.Global.BOOT_COUNT, mBootCount + mSimulatedRebootsCount);
@@ -77,11 +77,12 @@ public class PinStorageTest extends TelephonyTest {
         createPinStorageAndCaptureListener();
     }
 
-    private void createPinStorageAndCaptureListener() {
+    private void createPinStorageAndCaptureListener() throws Exception {
         // Capture listener to emulate the carrier config change notification used later
         ArgumentCaptor<CarrierConfigManager.CarrierConfigChangeListener> listenerArgumentCaptor =
                 ArgumentCaptor.forClass(CarrierConfigManager.CarrierConfigChangeListener.class);
-        mPinStorage = new PinStorage(mContext);
+        mPinStorage = new PinStorage(mContext, Looper.myLooper(), mFeatureFlags);
+        processAllMessages();
         mPinStorage.mShortTermSecretKeyDurationMinutes = 0;
         verify(mCarrierConfigManager, atLeastOnce()).registerCarrierConfigChangeListener(any(),
                 listenerArgumentCaptor.capture());
@@ -132,7 +133,6 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
     public void storePin_withoutReboot_pinCannotBeRetrieved() {
         mPinStorage.storePin("1234", 0);
 
@@ -140,8 +140,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_normalReboot_pinCannotBeRetrieved() {
+    public void storePin_normalReboot_pinCannotBeRetrieved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         simulateReboot();
@@ -150,23 +149,23 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_crash_pinCannotBeRetrieved() {
+    public void storePin_crash_pinCannotBeRetrieved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         // Simulate crash
-        mPinStorage = new PinStorage(mContext);
+        mPinStorage = new PinStorage(mContext, Looper.myLooper(), mFeatureFlags);
+        processAllMessages();
         mPinStorage.mShortTermSecretKeyDurationMinutes = 0;
 
         assertThat(mPinStorage.getPin(0, ICCID_1)).isEqualTo("");
     }
 
     @Test
-    @SmallTest
-    public void storePin_unattendedReboot_pinCanBeRetrievedOnce() {
+    public void storePin_unattendedReboot_pinCanBeRetrievedOnce() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
+        processAllMessages();
         assertThat(result).isEqualTo(TelephonyManager.PREPARE_UNATTENDED_REBOOT_SUCCESS);
 
         simulateReboot();
@@ -177,8 +176,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_unattendedReboot_deviceIsLocked() {
+    public void storePin_unattendedReboot_deviceIsLocked() throws Exception {
         // Simulate the device is still locked
         when(mKeyguardManager.isDeviceSecure()).thenReturn(true);
         when(mKeyguardManager.isDeviceLocked()).thenReturn(true);
@@ -196,8 +194,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_unattendedReboot_pinIsRemovedAfterDelay() {
+    public void storePin_unattendedReboot_pinIsRemovedAfterDelay() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
@@ -221,11 +218,11 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_unattendedRebootNotDone_pinCannotBeRetrieved() {
+    public void storePin_unattendedRebootNotDone_pinCannotBeRetrieved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
+        processAllMessages();
         assertThat(result).isEqualTo(TelephonyManager.PREPARE_UNATTENDED_REBOOT_SUCCESS);
 
         // Move time forward by 60 seconds before simulating reboot
@@ -237,8 +234,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_unattendedReboot_iccidChange() {
+    public void storePin_unattendedReboot_iccidChange() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
@@ -258,8 +254,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void clearPin_pinCannotBeRetrieved() {
+    public void clearPin_pinCannotBeRetrieved() throws Exception {
         mPinStorage.storePin("1234", 0);
         mPinStorage.clearPin(0);
 
@@ -272,12 +267,12 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_pinChanged_pinIsUpdated() {
+    public void storePin_pinChanged_pinIsUpdated() throws Exception {
         mPinStorage.storePin("1234", 0);
         mPinStorage.storePin("5678", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
+        processAllMessages();
         assertThat(result).isEqualTo(TelephonyManager.PREPARE_UNATTENDED_REBOOT_SUCCESS);
 
         simulateReboot();
@@ -286,8 +281,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_pinTooShort_pinIsNotStored() {
+    public void storePin_pinTooShort_pinIsNotStored() throws Exception {
         mPinStorage.storePin("12", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
@@ -299,8 +293,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_pinTooLong_pinIsNotStored() {
+    public void storePin_pinTooLong_pinIsNotStored() throws Exception {
         mPinStorage.storePin("123456789", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
@@ -312,8 +305,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_invalidIccid_pinIsNotStored() {
+    public void storePin_invalidIccid_pinIsNotStored() throws Exception {
         doReturn(ICCID_INVALID).when(mPhone).getFullIccSerialNumber();
 
         mPinStorage.storePin("1234", 0);
@@ -325,8 +317,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_disabledInResources_pinIsNotStored() {
+    public void storePin_disabledInResources_pinIsNotStored() throws Exception {
         mContextFixture.putBooleanResource(
                 R.bool.config_allow_pin_storage_for_unattended_reboot, false);
 
@@ -341,8 +332,8 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_disabledInResources_containsSimWithPinEnabledAndVerified() {
+    public void storePin_disabledInResources_containsSimWithPinEnabledAndVerified()
+            throws Exception {
         mContextFixture.putBooleanResource(
                 R.bool.config_allow_pin_storage_for_unattended_reboot, false);
 
@@ -360,8 +351,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_disabledInCarrierConfig_pinIsNotStored() {
+    public void storePin_disabledInCarrierConfig_pinIsNotStored() throws Exception {
         PersistableBundle carrierConfigs = new PersistableBundle();
         carrierConfigs.putBoolean(
                 CarrierConfigManager.KEY_STORE_SIM_PIN_FOR_UNATTENDED_REBOOT_BOOL, false);
@@ -378,8 +368,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_changeToDisabledInCarrierConfig_pinIsRemoved() {
+    public void storePin_changeToDisabledInCarrierConfig_pinIsRemoved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         // Simulate change in the carrier configuration
@@ -401,8 +390,7 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_simIsRemoved_pinIsRemoved() {
+    public void storePin_simIsRemoved_pinIsRemoved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         // SIM is removed
@@ -421,11 +409,11 @@ public class PinStorageTest extends TelephonyTest {
     }
 
     @Test
-    @SmallTest
-    public void storePin_simReadyAfterUnattendedReboot_pinIsRemoved() {
+    public void storePin_simReadyAfterUnattendedReboot_pinIsRemoved() throws Exception {
         mPinStorage.storePin("1234", 0);
 
         int result = mPinStorage.prepareUnattendedReboot(sWorkSource);
+        processAllMessages();
         assertThat(result).isEqualTo(TelephonyManager.PREPARE_UNATTENDED_REBOOT_SUCCESS);
 
         simulateReboot();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/SimPhonebookRecordCacheTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/SimPhonebookRecordCacheTest.java
index 1855276b74..e355acefa4 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/SimPhonebookRecordCacheTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/SimPhonebookRecordCacheTest.java
@@ -22,65 +22,49 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 import android.os.AsyncResult;
-import android.os.HandlerThread;
 import android.os.Message;
+import android.testing.AndroidTestingRunner;
+import android.testing.TestableLooper;
 
 import com.android.internal.telephony.TelephonyTest;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.ArrayList;
 import java.util.List;
 
+@RunWith(AndroidTestingRunner.class)
+@TestableLooper.RunWithLooper
 public class SimPhonebookRecordCacheTest extends TelephonyTest {
     private static final int EVENT_PHONEBOOK_RECORDS_RECEIVED = 2;
 
     private SimPhonebookRecordCache mSimPhonebookRecordCacheUt;
-    private SimPhonebookRecordHandler mSimPhonebookRecordHandler;
-
-    private class SimPhonebookRecordHandler extends HandlerThread {
-        SimPhonebookRecordHandler(String name) {
-            super(name);
-        }
-
-        @Override
-        public void onLooperPrepared() {
-            mSimPhonebookRecordCacheUt =
-                    new SimPhonebookRecordCache(mContext, 0, mSimulatedCommands);
-            setReady(true);
-        }
-
-    };
 
     @Before
     public void setUp() throws Exception {
         super.setUp(getClass().getSimpleName());
-        mSimPhonebookRecordHandler = new SimPhonebookRecordHandler(getClass().getSimpleName());
-        mSimPhonebookRecordHandler.start();
-        waitUntilReady();
+        mSimPhonebookRecordCacheUt =
+                new SimPhonebookRecordCache(mContext, 0, mSimulatedCommands);
     }
 
     @After
     public void tearDown() throws Exception {
-        mSimPhonebookRecordHandler.quit();
-        mSimPhonebookRecordHandler.join();
-        mSimPhonebookRecordHandler = null;
-        mSimPhonebookRecordCacheUt = null;
         super.tearDown();
     }
 
     @Test
     public void testSimPhonebookChangedOnBootup() {
         mSimulatedCommands.notifySimPhonebookChanged();
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         AdnCapacity capacity = mSimPhonebookRecordCacheUt.getAdnCapacity();
         AdnCapacity capVerifer = new AdnCapacity(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
         assertNotNull(capacity);
         assertTrue(capVerifer.equals(capacity));
         mSimulatedCommands.notifySimPhonebookChanged();
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         assertTrue(capacity != mSimPhonebookRecordCacheUt.getAdnCapacity());
         assertTrue(capVerifer.equals(capacity));
     }
@@ -89,10 +73,10 @@ public class SimPhonebookRecordCacheTest extends TelephonyTest {
     public void testGetPhonebookRecords() {
         assertFalse(mSimPhonebookRecordCacheUt.isLoading());
         mSimulatedCommands.notifySimPhonebookChanged();
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         assertFalse(mSimPhonebookRecordCacheUt.isLoading());
         mSimPhonebookRecordCacheUt.requestLoadAllPbRecords(null);
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
 
         mSimPhonebookRecordCacheUt.clear();
 
@@ -114,14 +98,14 @@ public class SimPhonebookRecordCacheTest extends TelephonyTest {
         assertFalse(mSimPhonebookRecordCacheUt.isLoading());
         mSimPhonebookRecordCacheUt.requestLoadAllPbRecords(null);
         assertTrue(mSimPhonebookRecordCacheUt.isLoading());
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         assertFalse(mSimPhonebookRecordCacheUt.isLoading());
     }
 
     @Test
     public void testUpdatePhonebookRecord() {
         mSimulatedCommands.notifySimPhonebookChanged();
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         List<AdnRecord> adnRecords = mSimPhonebookRecordCacheUt.getAdnRecords();
         if (mSimPhonebookRecordCacheUt.ENABLE_INFLATE_WITH_EMPTY_RECORDS) {
             assertEquals(adnRecords.size(), 1); // Max ADN from capacity
@@ -133,7 +117,7 @@ public class SimPhonebookRecordCacheTest extends TelephonyTest {
         AdnRecord newAdn = new AdnRecord(IccConstants.EF_ADN, 1, "AB", "123", null, null);
         // add
         mSimPhonebookRecordCacheUt.updateSimPbAdnBySearch(null, newAdn, null);
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         adnRecords = mSimPhonebookRecordCacheUt.getAdnRecords();
         assertEquals(adnRecords.size(), 1);
         AdnRecord oldAdn = adnRecords.get(0);
@@ -143,7 +127,7 @@ public class SimPhonebookRecordCacheTest extends TelephonyTest {
         // update
         newAdn = new AdnRecord(IccConstants.EF_ADN, 1, "ABCD", "123456789", null, null);
         mSimPhonebookRecordCacheUt.updateSimPbAdnBySearch(oldAdn, newAdn, null);
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         adnRecords = mSimPhonebookRecordCacheUt.getAdnRecords();
         assertEquals(adnRecords.size(), 1);
         oldAdn = adnRecords.get(0);
@@ -153,7 +137,7 @@ public class SimPhonebookRecordCacheTest extends TelephonyTest {
         // Delete
         newAdn = new AdnRecord(IccConstants.EF_ADN, 1, null, null, null, null);
         mSimPhonebookRecordCacheUt.updateSimPbAdnBySearch(oldAdn, newAdn, null);
-        waitForLastHandlerAction(mSimPhonebookRecordCacheUt);
+        processAllMessages();
         adnRecords = mSimPhonebookRecordCacheUt.getAdnRecords();
         if (mSimPhonebookRecordCacheUt.ENABLE_INFLATE_WITH_EMPTY_RECORDS) {
             assertEquals(adnRecords.size(), 1);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardInfoTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardInfoTest.java
new file mode 100644
index 0000000000..2942dc485d
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardInfoTest.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.internal.telephony.uicc;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThrows;
+
+import android.os.Parcel;
+import android.telephony.TelephonyManager;
+import android.telephony.UiccCardInfo;
+import android.telephony.UiccPortInfo;
+import android.testing.AndroidTestingRunner;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.internal.telephony.TelephonyTest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+@RunWith(AndroidTestingRunner.class)
+public class UiccCardInfoTest extends TelephonyTest {
+
+    private UiccPortInfo mUiccPortInfo1;
+    private UiccPortInfo mUiccPortInfo2;
+    private List<UiccPortInfo> mPortList;
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp("UiccCardInfoTest");
+        mUiccPortInfo1 = new UiccPortInfo("test_icc_id_1", 0, 0, true);
+        mUiccPortInfo2 = new UiccPortInfo("test_icc_id_2", 1, 0, true);
+        mPortList = new ArrayList<>();
+        mPortList.add(mUiccPortInfo1);
+        mPortList.add(mUiccPortInfo2);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mPortList = null;
+        mUiccPortInfo1 = null;
+        mUiccPortInfo2 = null;
+        super.tearDown();
+    }
+
+    @Test
+    @SmallTest
+    public void testCreateSensitiveInfoSanitizedCopy_withCarrierPrivileges() {
+        UiccCardInfo originalCardInfo = new UiccCardInfo(
+                true /*isEuicc*/,
+                123 /*cardId*/,
+                "test_eid" /*eid*/,
+                0 /*physicalSlotIndex*/,
+                false /*isRemovable*/,
+                true /*isMultipleEnabledProfilesSupported*/,
+                mPortList);
+
+        UiccCardInfo sanitizedInfo = originalCardInfo.createSensitiveInfoSanitizedCopy(true);
+
+        List<UiccPortInfo> expectedPorts = new ArrayList<>();
+        expectedPorts.add(new UiccPortInfo(UiccPortInfo.ICCID_REDACTED, 0, 0, true));
+        expectedPorts.add(new UiccPortInfo(UiccPortInfo.ICCID_REDACTED, 1, 0, true));
+
+        UiccCardInfo expectedCardInfo = new UiccCardInfo(
+                true, // isEuicc
+                123, //cardId
+                null, // eid
+                0, // physicalSlotIndex
+                false, // isRemovable
+                true, // isMultipleEnabledProfilesSupported
+                expectedPorts // portList
+        );
+        assertEquals(expectedCardInfo, sanitizedInfo);
+    }
+
+    @Test
+    @SmallTest
+    public void testCreateSensitiveInfoSanitizedCopy_withoutCarrierPrivileges() {
+        UiccCardInfo originalCardInfo = new UiccCardInfo(
+                true /*isEuicc*/,
+                123 /*cardId*/,
+                "test_eid" /*eid*/,
+                1 /*physicalSlotIndex*/,
+                true /*isRemovable*/,
+                false /*isMultipleEnabledProfilesSupported*/,
+                mPortList);
+
+        UiccCardInfo sanitizedInfo = originalCardInfo.createSensitiveInfoSanitizedCopy(false);
+
+        UiccCardInfo expectedCardInfo = new UiccCardInfo(
+                true, // isEuicc
+                TelephonyManager.UNINITIALIZED_CARD_ID, //cardId
+                null, // eid
+                1, // physicalSlotIndex
+                true, // isRemovable
+                false, // isMultipleEnabledProfilesSupported
+                List.of() // portList
+        );
+        assertEquals(expectedCardInfo, sanitizedInfo);
+    }
+
+    @Test
+    @SmallTest
+    public void testParcelable() {
+        UiccCardInfo cardInfo = new UiccCardInfo(
+                true /*isEuicc*/,
+                456 /*cardId*/,
+                "another_eid" /*eid*/,
+                0 /*physicalSlotIndex*/,
+                false /*isRemovable*/,
+                true /*isMultipleEnabledProfilesSupported*/,
+                Collections.singletonList(mUiccPortInfo1));
+        cardInfo.setIccIdAccessRestricted(true);
+
+        Parcel parcel = Parcel.obtain();
+        cardInfo.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        UiccCardInfo fromParcel = UiccCardInfo.CREATOR.createFromParcel(parcel);
+
+        assertEquals(cardInfo.isEuicc(), fromParcel.isEuicc());
+        assertEquals(cardInfo.getCardId(), fromParcel.getCardId());
+        assertEquals(cardInfo.getEid(), fromParcel.getEid());
+        assertEquals(cardInfo.getPhysicalSlotIndex(), fromParcel.getPhysicalSlotIndex());
+        assertEquals(cardInfo.isRemovable(), fromParcel.isRemovable());
+        assertEquals(cardInfo.isMultipleEnabledProfilesSupported(),
+                fromParcel.isMultipleEnabledProfilesSupported());
+        assertEquals(cardInfo.getPorts().size(), fromParcel.getPorts().size());
+        // Detailed port comparison
+        List<UiccPortInfo> originalPorts = new ArrayList<>(cardInfo.getPorts());
+        List<UiccPortInfo> parcelPorts = new ArrayList<>(fromParcel.getPorts());
+        assertEquals(originalPorts.get(0).getIccId(), parcelPorts.get(0).getIccId());
+        assertEquals(originalPorts.get(0).getPortIndex(), parcelPorts.get(0).getPortIndex());
+        assertEquals(originalPorts.get(0).getLogicalSlotIndex(),
+                parcelPorts.get(0).getLogicalSlotIndex());
+        assertEquals(originalPorts.get(0).isActive(), parcelPorts.get(0).isActive());
+
+        assertThrows(UnsupportedOperationException.class, () -> fromParcel.getIccId());
+        parcel.recycle();
+    }
+
+    @Test
+    @SmallTest
+    public void testEqualsAndHashCode() {
+        UiccCardInfo cardInfo1 = new UiccCardInfo(
+                true, 1, "eid1", 0, true, true, mPortList);
+        UiccCardInfo cardInfo2 = new UiccCardInfo(
+                true, 1, "eid1", 0, true, true, mPortList);
+        UiccCardInfo cardInfo3 = new UiccCardInfo(
+                false, 2, "eid2", 1, false, false, Collections.emptyList());
+
+        assertEquals(cardInfo1, cardInfo2);
+        assertEquals(cardInfo1.hashCode(), cardInfo2.hashCode());
+        assertFalse(cardInfo1.equals(cardInfo3));
+        assertFalse(cardInfo1.hashCode()
+                == cardInfo3.hashCode());
+        assertFalse(cardInfo1.equals(null));
+        assertFalse(cardInfo1.equals(new Object()));
+    }
+}
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccControllerTest.java
index 334357088f..0ba55fb987 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccControllerTest.java
@@ -24,12 +24,15 @@ import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
 import android.os.AsyncResult;
+import android.os.Build;
 import android.os.Handler;
 import android.os.Message;
+import android.os.SystemProperties;
 import android.preference.PreferenceManager;
 import android.telephony.TelephonyManager;
 import android.telephony.UiccCardInfo;
@@ -72,6 +75,7 @@ public class UiccControllerTest extends TelephonyTest {
     private EuiccCard mMockEuiccCard;
     private UiccProfile mMockProfile;
     private UiccPort mMockPort;
+    private UiccControllerTest mSpyUiccControllerTest;
 
     private IccCardApplicationStatus composeUiccApplicationStatus(
             IccCardApplicationStatus.AppType appType,
@@ -122,6 +126,7 @@ public class UiccControllerTest extends TelephonyTest {
         mIccCardStatus.mSlotPortMapping = new IccSlotPortMapping();
         mIccCardStatus.mSlotPortMapping.mPhysicalSlotIndex = 0;
         mUiccControllerUT = UiccController.make(mContext, mFeatureFlags);
+        mSpyUiccControllerTest = spy(this);
         // reset sLastSlotStatus so that onGetSlotStatusDone always sees a change in the slot status
         mUiccControllerUT.sLastSlotStatus = null;
         processAllMessages();
@@ -146,6 +151,7 @@ public class UiccControllerTest extends TelephonyTest {
         replaceInstance(UiccController.class, "mInstance", null, null);
         mUiccControllerUT.dispose();
         mUiccControllerUT = UiccController.make(mContext, mFeatureFlags);
+        mSpyUiccControllerTest = spy(this);
         processAllMessages();
     }
 
@@ -722,4 +728,39 @@ public class UiccControllerTest extends TelephonyTest {
         // status should be treated different from last status
         assertTrue(mUiccControllerUT.slotStatusChanged(status));
     }
+
+    @Test
+    @SmallTest
+    public void testNumPhysicalSlotsAdjusted() throws Exception {
+        // Mock first API level to be older than V
+        doReturn(Build.VERSION_CODES.TIRAMISU).when(mSpyUiccControllerTest).getFirstApiLevel();
+        // Mock the resource config_num_physical_slots
+        mContextFixture.putIntResource(com.android.internal.R.integer.config_num_physical_slots,
+                PHONE_COUNT - 1);
+
+        // Verify that numPhysicalSlots is adjusted to PHONE_COUNT
+        assertEquals(PHONE_COUNT, mUiccControllerUT.getUiccSlots().length);
+    }
+
+    @Test
+    @SmallTest
+    public void testNumPhysicalSlotsNotAdjustedForNewerApiLevel() throws Exception {
+        // Mock first API level to be newer than V
+        doReturn(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+                .when(mSpyUiccControllerTest).getFirstApiLevel();
+        // Mock the resource config_num_physical_slots
+        mContextFixture.putIntResource(com.android.internal.R.integer.config_num_physical_slots,
+                PHONE_COUNT);
+
+        // Verify that numPhysicalSlots is not adjusted
+        assertEquals(PHONE_COUNT, mUiccControllerUT.getUiccSlots().length);
+    }
+
+    /**
+     * Wrapper method to get the first api level to allow mocking it in tests.
+     */
+    public int getFirstApiLevel() {
+        return SystemProperties.getInt(
+                "ro.vendor.api_level", Build.VERSION.DEVICE_INITIAL_SDK_INT);
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccPortInfoTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccPortInfoTest.java
new file mode 100644
index 0000000000..77c93eda01
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccPortInfoTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.internal.telephony.uicc;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+import android.os.Parcel;
+import android.telephony.UiccPortInfo;
+import android.testing.AndroidTestingRunner;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.internal.telephony.TelephonyTest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidTestingRunner.class)
+public class UiccPortInfoTest extends TelephonyTest {
+
+    private static final String TEST_ICCID = "12345678901234567890";
+    private static final int TEST_PORT_INDEX = 0;
+    private static final int TEST_LOGICAL_SLOT_INDEX = 1;
+    private static final boolean TEST_IS_ACTIVE = true;
+
+    private UiccPortInfo mUiccPortInfo;
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp("UiccPortInfoTest");
+        mUiccPortInfo = new UiccPortInfo(TEST_ICCID, TEST_PORT_INDEX, TEST_LOGICAL_SLOT_INDEX,
+                TEST_IS_ACTIVE);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mUiccPortInfo = null;
+        super.tearDown();
+    }
+
+    @Test
+    @SmallTest
+    public void testGetters() {
+        assertEquals(TEST_ICCID, mUiccPortInfo.getIccId());
+        assertEquals(TEST_PORT_INDEX, mUiccPortInfo.getPortIndex());
+        assertEquals(TEST_LOGICAL_SLOT_INDEX, mUiccPortInfo.getLogicalSlotIndex());
+        assertEquals(TEST_IS_ACTIVE, mUiccPortInfo.isActive());
+    }
+
+    @Test
+    @SmallTest
+    public void testCreateSensitiveInfoSanitizedCopy() {
+        UiccPortInfo sanitizedInfo = mUiccPortInfo.createSensitiveInfoSanitizedCopy();
+
+        UiccPortInfo expectedInfo = new UiccPortInfo(
+                UiccPortInfo.ICCID_REDACTED, // iccId
+                TEST_PORT_INDEX, // portIndex
+                TEST_LOGICAL_SLOT_INDEX, // logicalSlotIndex
+                TEST_IS_ACTIVE // isActive
+        );
+        assertEquals(expectedInfo, sanitizedInfo);
+    }
+
+    @Test
+    @SmallTest
+    public void testParcelable() {
+        Parcel parcel = Parcel.obtain();
+        mUiccPortInfo.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        UiccPortInfo fromParcel = UiccPortInfo.CREATOR.createFromParcel(parcel);
+
+        assertEquals(mUiccPortInfo.getIccId(), fromParcel.getIccId());
+        assertEquals(mUiccPortInfo.getPortIndex(), fromParcel.getPortIndex());
+        assertEquals(mUiccPortInfo.getLogicalSlotIndex(), fromParcel.getLogicalSlotIndex());
+        assertEquals(mUiccPortInfo.isActive(), fromParcel.isActive());
+        assertEquals(mUiccPortInfo, fromParcel);
+        parcel.recycle();
+    }
+
+    @Test
+    @SmallTest
+    public void testEqualsAndHashCode() {
+        UiccPortInfo portInfo1 = new UiccPortInfo(TEST_ICCID, TEST_PORT_INDEX,
+                TEST_LOGICAL_SLOT_INDEX, TEST_IS_ACTIVE);
+        UiccPortInfo portInfo2 = new UiccPortInfo(TEST_ICCID, TEST_PORT_INDEX,
+                TEST_LOGICAL_SLOT_INDEX, TEST_IS_ACTIVE);
+        UiccPortInfo portInfo3 = new UiccPortInfo("09876543210987654321", 1, 0, false);
+
+        assertEquals(portInfo1, portInfo2);
+        assertEquals(portInfo1.hashCode(), portInfo2.hashCode());
+
+        assertFalse(portInfo1.equals(portInfo3));
+
+        assertFalse(portInfo1.equals(null));
+        assertFalse(portInfo1.equals(new Object()));
+    }
+}
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/euicc/apdu/ApduSenderTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/euicc/apdu/ApduSenderTest.java
index 88e9142a40..3bce88a986 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/euicc/apdu/ApduSenderTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/euicc/apdu/ApduSenderTest.java
@@ -33,7 +33,6 @@ import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
 import android.platform.test.flag.junit.SetFlagsRule;
@@ -42,10 +41,9 @@ import android.telephony.IccOpenLogicalChannelResponse;
 import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
 
-import androidx.test.InstrumentationRegistry;
-
 import com.android.internal.telephony.CommandException;
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.TelephonyTest;
 import com.android.internal.telephony.euicc.EuiccSession;
 import com.android.internal.telephony.flags.Flags;
 import com.android.internal.telephony.uicc.IccIoResult;
@@ -61,7 +59,7 @@ import org.mockito.Mockito;
 
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper
-public class ApduSenderTest {
+public class ApduSenderTest extends TelephonyTest {
     @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
 
     private static class ResponseCaptor extends ApduSenderResultCallback {
@@ -107,13 +105,15 @@ public class ApduSenderTest {
     private ResponseCaptor mResponseCaptor;
     private byte[] mSelectResponse;
     private ApduSender mSender;
-    private Context mContext;
 
     @Before
-    public void setUp() {
+    public void setUp() throws Exception {
+        super.setUp(getClass().getSimpleName());
+
         mSetFlagsRule.enableFlags(Flags.FLAG_OPTIMIZATION_APDU_SENDER);
+        mContextFixture.putBooleanResource(
+                com.android.internal.R.bool.euicc_optimize_apdu_sender, true);
 
-        mContext = InstrumentationRegistry.getContext();
         mMockCi = mock(CommandsInterface.class);
         mLooper = TestableLooper.get(this);
         mHandler = new Handler(mLooper.getLooper());
@@ -125,7 +125,7 @@ public class ApduSenderTest {
     }
 
     @After
-    public void tearDown() throws InterruptedException {
+    public void tearDown() throws Exception {
         // Send an APDU to verify that the channel lock is not stuck (b/382549728).
         // Sameas testSend(), but not verifying mMockCi interactions.
         checkChannelLock();
@@ -138,21 +138,24 @@ public class ApduSenderTest {
         mSender = null;
 
         EuiccSession.get(mContext).endSession(SESSION_ID);
+        resetEuiccSession();
         clearSharedPreferences();
+
+        super.tearDown();
     }
 
     @Test
-    public void testWrongAid_throwsIllegalArgumentException() {
+    public void testWrongAid_throwsIllegalArgumentException() throws Exception {
         String wrongAid = "-1";
 
         assertThrows(IllegalArgumentException.class, () -> {
-            new ApduSender(InstrumentationRegistry.getContext(), 0 /* phoneId= */,
+            new ApduSender(mContext, 0 /* phoneId= */,
                             mMockCi, wrongAid, false /* supportExtendedApdu */);
         });
     }
 
     @Test
-    public void testSendEmptyCommands() throws InterruptedException {
+    public void testSendEmptyCommands() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "A1A1A19000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
 
@@ -168,7 +171,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testOpenChannelErrorStatus() throws InterruptedException {
+    public void testOpenChannelErrorStatus() throws Exception {
         LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi,
                 new CommandException(CommandException.Error.NO_SUCH_ELEMENT));
 
@@ -183,7 +186,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSend() throws InterruptedException {
+    public void testSend() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A1A1A19000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
@@ -201,7 +204,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendMultiApdus() throws InterruptedException {
+    public void testSendMultiApdus() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A19000", "A29000",
                 "A39000", "A49000");
@@ -230,7 +233,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendMultiApdusStopEarly() throws InterruptedException {
+    public void testSendMultiApdusStopEarly() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A19000", "A29000",
                 "A39000", "A49000");
@@ -255,7 +258,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendLongResponse() throws InterruptedException {
+    public void testSendLongResponse() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A1A1A16104",
                 "B2B2B2B26102", "C3C39000");
@@ -275,7 +278,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendStoreDataLongDataLongResponse() throws InterruptedException {
+    public void testSendStoreDataLongDataLongResponse() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A19000", "9000", "9000",
                 "B22B6103", "B2222B9000", "C39000");
@@ -307,7 +310,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendStoreDataLongDataMod0() throws InterruptedException {
+    public void testSendStoreDataLongDataMod0() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "9000", "B2222B9000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
@@ -329,7 +332,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendStoreDataLen0() throws InterruptedException {
+    public void testSendStoreDataLen0() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "B2222B9000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
@@ -345,7 +348,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendErrorResponseInMiddle() throws InterruptedException {
+    public void testSendErrorResponseInMiddle() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A19000", "9000",
                 "B22B6103", "6985");
@@ -374,7 +377,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testChannelAlreadyOpened() throws InterruptedException {
+    public void testChannelAlreadyOpened() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
 
@@ -393,32 +396,8 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testConstructor_doNotCloseOpenChannelInSharedPreference()
-                  throws InterruptedException {
-        // Open a channel and not close it, by making CI.iccTransmitApduLogicalChannel throw.
-        int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
-        doThrow(new RuntimeException()).when(mMockCi).iccTransmitApduLogicalChannel(
-                eq(channel), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), any(),
-                anyBoolean(), any());
-        mSender.send((selectResponse, requestBuilder) -> requestBuilder.addApdu(
-                10, 1, 2, 3, 0, "a"), mResponseCaptor, mHandler);
-        mLooper.processAllMessages();
-        // Stub close channel
-        reset(mMockCi);
-        LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
-
-        // Call constructor
-        mSender = new ApduSender(InstrumentationRegistry.getContext(), PHONE_ID,
-                            mMockCi, ApduSender.ISD_R_AID, false /* supportExtendedApdu */);
-        mLooper.processAllMessages();
-
-        // The constructor should have closed channel
-        verify(mMockCi, times(0)).iccCloseLogicalChannel(eq(channel), eq(true /*isEs10*/), any());
-        assertEquals(1, getChannelIdFromSharedPreferences());
-    }
-
-    @Test
-    public void testSend_OpenChannelFailedNoSuchElement_useChannelInSharedPreference() {
+    public void testSend_OpenChannelFailedNoSuchElement_useChannelInSharedPreference()
+            throws Exception {
         // Open a channel but not close, by making CI.iccTransmitApduLogicalChannel throw.
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         doThrow(new RuntimeException()).when(mMockCi).iccTransmitApduLogicalChannel(
@@ -427,13 +406,8 @@ public class ApduSenderTest {
         mSender.send((selectResponse, requestBuilder) -> requestBuilder.addApdu(
                 10, 1, 2, 3, 0, "a"), mResponseCaptor, mHandler);
         mLooper.processAllMessages();
-        reset(mMockCi);
-        // Constructor fails to close channel
-        LogicalChannelMocker.mockCloseLogicalChannel(
-                mMockCi, channel, new CommandException(RADIO_NOT_AVAILABLE));
-        mSender = new ApduSender(InstrumentationRegistry.getContext(), PHONE_ID,
+        mSender = new ApduSender(mContext, PHONE_ID,
                             mMockCi, ApduSender.ISD_R_AID, false /* supportExtendedApdu */);
-        mLooper.processAllMessages();
         reset(mMockCi);
         // Stub open channel failure NO_SUCH_ELEMENT
         LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi,
@@ -456,8 +430,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSend_euiccSession_shouldNotCloseChannel()
-            throws InterruptedException {
+    public void testSend_euiccSession_shouldNotCloseChannel() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A1A1A19000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
@@ -470,6 +443,27 @@ public class ApduSenderTest {
         assertEquals("A1A1A1", IccUtils.bytesToHexString(mResponseCaptor.response));
         InOrder inOrder = inOrder(mMockCi);
         inOrder.verify(mMockCi).iccOpenLogicalChannel(eq(ApduSender.ISD_R_AID), anyInt(), any());
+        inOrder.verify(mMockCi).iccTransmitApduLogicalChannel(eq(channel), eq(channel | 10),
+                eq(1), eq(2), eq(3), eq(0), eq("a"), anyBoolean(), any());
+        // No iccCloseLogicalChannel
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testSend_euiccSession_sendFailure_shouldCloseChannel() throws Exception {
+        int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
+        // Send failure: `sw1:0x6f sw2:0x0 Error: technical problem with no diagnostic given`
+        LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "6F00");
+        LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
+        EuiccSession.get(mContext).startSession(SESSION_ID);
+
+        mSender.send((selectResponse, requestBuilder) -> requestBuilder.addApdu(
+                10, 1, 2, 3, 0, "a"), mResponseCaptor, mHandler);
+        mLooper.processAllMessages();
+
+        assertEquals(0x6F00, ((ApduException) mResponseCaptor.exception).getApduStatus());
+        InOrder inOrder = inOrder(mMockCi);
+        inOrder.verify(mMockCi).iccOpenLogicalChannel(eq(ApduSender.ISD_R_AID), anyInt(), any());
         inOrder.verify(mMockCi).iccTransmitApduLogicalChannel(eq(channel), eq(channel | 10),
                 eq(1), eq(2), eq(3), eq(0), eq("a"), anyBoolean(), any());
         inOrder.verify(mMockCi).iccCloseLogicalChannel(eq(channel), eq(true /*isEs10*/), any());
@@ -477,8 +471,7 @@ public class ApduSenderTest {
     }
 
     @Test
-    public void testSendTwice_euiccSession_shouldOpenChannelOnceNotCloseChannel()
-            throws InterruptedException {
+    public void testSendTwice_euiccSession_shouldOpenChannelOnceNotCloseChannel() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(
                     mMockCi, channel, "A1A1A19000", "A1A1A19000");
@@ -499,12 +492,12 @@ public class ApduSenderTest {
         // iccTransmitApduLogicalChannel twice
         inOrder.verify(mMockCi, times(2)).iccTransmitApduLogicalChannel(eq(channel),
                  eq(channel | 10), eq(1), eq(2), eq(3), eq(0), eq("a"), anyBoolean(), any());
-        inOrder.verify(mMockCi).iccCloseLogicalChannel(eq(channel), eq(true /*isEs10*/), any());
+        // No iccCloseLogicalChannel
         inOrder.verifyNoMoreInteractions();
     }
 
     @Test
-    public void testSendTwice_thenEndSession() throws InterruptedException {
+    public void testSendTwice_thenEndSession() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel,
                 "A1A1A19000", "A1A1A19000");
@@ -532,12 +525,12 @@ public class ApduSenderTest {
     }
 
     private int getChannelIdFromSharedPreferences() {
-        return PreferenceManager.getDefaultSharedPreferences(InstrumentationRegistry.getContext())
+        return PreferenceManager.getDefaultSharedPreferences(mContext)
                 .getInt(SHARED_PREFS_KEY_CHANNEL_ID, -1);
     }
 
     private void clearSharedPreferences() {
-        PreferenceManager.getDefaultSharedPreferences(InstrumentationRegistry.getContext())
+        PreferenceManager.getDefaultSharedPreferences(mContext)
                 .edit()
                 .remove(SHARED_PREFS_KEY_CHANNEL_ID)
                 .remove(SHARED_PREFS_KEY_CHANNEL_RESPONSE)
@@ -548,7 +541,7 @@ public class ApduSenderTest {
      * Send an APDU to verify that the channel lock is not stuck (b/382549728).
      * Same as testSend(), but not verifying mMockCi interactions.
      */
-    private void checkChannelLock() throws InterruptedException {
+    private void checkChannelLock() throws Exception {
         int channel = LogicalChannelMocker.mockOpenLogicalChannelResponse(mMockCi, "9000");
         LogicalChannelMocker.mockSendToLogicalChannel(mMockCi, channel, "A1A1A19000");
         LogicalChannelMocker.mockCloseLogicalChannel(mMockCi, channel, /* error= */ null);
@@ -559,4 +552,11 @@ public class ApduSenderTest {
 
         assertEquals("A1A1A1", IccUtils.bytesToHexString(mResponseCaptor.response));
     }
+
+    /** Clears the static states of EuiccSession. */
+    private void resetEuiccSession() throws Exception {
+        java.lang.reflect.Field field = EuiccSession.class.getDeclaredField("sInstance");
+        field.setAccessible(true);
+        field.set(null, null);
+    }
 }
```

