```diff
diff --git a/libs/WifiTrackerLib/res/values-es/strings.xml b/libs/WifiTrackerLib/res/values-es/strings.xml
index 422917904..5c2cd295f 100644
--- a/libs/WifiTrackerLib/res/values-es/strings.xml
+++ b/libs/WifiTrackerLib/res/values-es/strings.xml
@@ -34,7 +34,7 @@
     <string name="wifitrackerlib_wifi_mbo_assoc_disallowed_cannot_connect" msgid="2692286425448897083">"No se ha podido conectar. Inténtalo de nuevo más tarde."</string>
     <string name="wifitrackerlib_wifi_network_not_found" msgid="1308764769892463388">"No se ha podido conectar. Inténtalo de nuevo en otro momento."</string>
     <string name="wifitrackerlib_wifi_disconnected" msgid="3320414360982942679">"Desconectado"</string>
-    <string name="wifitrackerlib_wifi_remembered" msgid="2406091442008343041">"Guardado"</string>
+    <string name="wifitrackerlib_wifi_remembered" msgid="2406091442008343041">"Guardada"</string>
     <string name="wifitrackerlib_wifi_metered_label" msgid="8818508951778620385">"De uso medido"</string>
     <string name="wifitrackerlib_wifi_unmetered_label" msgid="1902150402929678469">"No medida"</string>
     <string name="wifitrackerlib_connected_via_app" msgid="7823921840931347560">"Conectado mediante <xliff:g id="NAME">%1$s</xliff:g>"</string>
diff --git a/libs/WifiTrackerLib/res/values-fa/arrays.xml b/libs/WifiTrackerLib/res/values-fa/arrays.xml
index 9d19120df..24c0e4483 100644
--- a/libs/WifiTrackerLib/res/values-fa/arrays.xml
+++ b/libs/WifiTrackerLib/res/values-fa/arrays.xml
@@ -26,7 +26,7 @@
     <item msgid="9055468790485684083">"درحال اتصال…"</item>
     <item msgid="6099499723199990208">"درحال راستی‌آزمایی…"</item>
     <item msgid="6794055951297347103">"‏درحال دریافت نشانی IP…"</item>
-    <item msgid="5450920562291300229">"متصل"</item>
+    <item msgid="5450920562291300229">"متصل‌شده"</item>
     <item msgid="6332116533879646145">"معلق"</item>
     <item msgid="294459081501073818">"درحال قطع اتصال…"</item>
     <item msgid="1577368920272598676">"اتصال قطع شد"</item>
diff --git a/libs/WifiTrackerLib/res/values-fr-rCA/strings.xml b/libs/WifiTrackerLib/res/values-fr-rCA/strings.xml
index 1c85945ca..2008862ec 100644
--- a/libs/WifiTrackerLib/res/values-fr-rCA/strings.xml
+++ b/libs/WifiTrackerLib/res/values-fr-rCA/strings.xml
@@ -16,9 +16,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="wifitrackerlib_summary_separator" msgid="6613897475167609815">" / "</string>
+    <string name="wifitrackerlib_summary_separator" msgid="6613897475167609815">" : "</string>
     <string name="wifitrackerlib_checking_for_internet_access" msgid="4787495471423429472">"Recherche d\'un accès Internet…"</string>
-    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"La connexion automatique est désactivée"</string>
+    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"la connexion automatique est désactivée"</string>
     <string name="wifitrackerlib_saved_network" msgid="5353460010746484376">"Enregistré par <xliff:g id="NAME">%1$s</xliff:g>"</string>
     <string name="wifitrackerlib_wifi_no_internet" msgid="4998563744669636949">"Aucun accès à Internet"</string>
     <string name="wifitrackerlib_wifi_disabled_password_failure" msgid="2850244218754633550">"Problème d\'authentification"</string>
diff --git a/libs/WifiTrackerLib/res/values-iw/strings.xml b/libs/WifiTrackerLib/res/values-iw/strings.xml
index 3328b3967..d573fd632 100644
--- a/libs/WifiTrackerLib/res/values-iw/strings.xml
+++ b/libs/WifiTrackerLib/res/values-iw/strings.xml
@@ -22,7 +22,7 @@
     <string name="wifitrackerlib_saved_network" msgid="5353460010746484376">"נשמרה על-ידי: <xliff:g id="NAME">%1$s</xliff:g>"</string>
     <string name="wifitrackerlib_wifi_no_internet" msgid="4998563744669636949">"אין גישה לאינטרנט"</string>
     <string name="wifitrackerlib_wifi_disabled_password_failure" msgid="2850244218754633550">"בעיית אימות"</string>
-    <string name="wifitrackerlib_wifi_check_password_try_again" msgid="2327777719175574699">"יש לבדוק את הסיסמה ולנסות שוב"</string>
+    <string name="wifitrackerlib_wifi_check_password_try_again" msgid="2327777719175574699">"צריך לבדוק את הסיסמה ולנסות שוב"</string>
     <string name="wifitrackerlib_wifi_disabled_network_failure" msgid="3046956554224277166">"‏כשל בהגדרת IP"</string>
     <string name="wifitrackerlib_wifi_disabled_transition_disable_indication" msgid="6416221593061166867">"הרשתות האלה לא זמינות עם הגדרות האבטחה הנוכחיות"</string>
     <string name="wifitrackerlib_wifi_disabled_consecutive_failures" msgid="7568234059979801397">"כשל בחיבור"</string>
diff --git a/libs/WifiTrackerLib/res/values-sw/strings.xml b/libs/WifiTrackerLib/res/values-sw/strings.xml
index fc2399291..4e63fcefe 100644
--- a/libs/WifiTrackerLib/res/values-sw/strings.xml
+++ b/libs/WifiTrackerLib/res/values-sw/strings.xml
@@ -18,7 +18,7 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="wifitrackerlib_summary_separator" msgid="6613897475167609815">" / "</string>
     <string name="wifitrackerlib_checking_for_internet_access" msgid="4787495471423429472">"Inatafuta uwezo wa kufikia intaneti..."</string>
-    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"Kipengele cha kuunganisha kiotomatiki kimezimwa"</string>
+    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"Kuunganisha kiotomatiki kumezimwa"</string>
     <string name="wifitrackerlib_saved_network" msgid="5353460010746484376">"Ilihifadhiwa na <xliff:g id="NAME">%1$s</xliff:g>"</string>
     <string name="wifitrackerlib_wifi_no_internet" msgid="4998563744669636949">"Hakuna muunganisho wa intaneti"</string>
     <string name="wifitrackerlib_wifi_disabled_password_failure" msgid="2850244218754633550">"Tatizo la uthibitishaji"</string>
diff --git a/libs/WifiTrackerLib/res/values-ta/strings.xml b/libs/WifiTrackerLib/res/values-ta/strings.xml
index 5c83c7228..607bf496e 100644
--- a/libs/WifiTrackerLib/res/values-ta/strings.xml
+++ b/libs/WifiTrackerLib/res/values-ta/strings.xml
@@ -18,7 +18,7 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="wifitrackerlib_summary_separator" msgid="6613897475167609815">" / "</string>
     <string name="wifitrackerlib_checking_for_internet_access" msgid="4787495471423429472">"இணைய அணுகல் உள்ளதா எனப் பார்க்கிறது..."</string>
-    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"தானியங்கு இணைப்பு ஆஃப் செய்யப்பட்டுள்ளது"</string>
+    <string name="wifitrackerlib_auto_connect_disable" msgid="4714835547164460651">"தானாக இணைவது ஆஃப் செய்யப்பட்டுள்ளது"</string>
     <string name="wifitrackerlib_saved_network" msgid="5353460010746484376">"<xliff:g id="NAME">%1$s</xliff:g> சேமித்தது"</string>
     <string name="wifitrackerlib_wifi_no_internet" msgid="4998563744669636949">"இணைய அணுகல் இல்லை"</string>
     <string name="wifitrackerlib_wifi_disabled_password_failure" msgid="2850244218754633550">"அங்கீகரிப்புச் சிக்கல்"</string>
diff --git a/libs/WifiTrackerLib/res/values-te/strings.xml b/libs/WifiTrackerLib/res/values-te/strings.xml
index 7fcbee7cd..59c941d4d 100644
--- a/libs/WifiTrackerLib/res/values-te/strings.xml
+++ b/libs/WifiTrackerLib/res/values-te/strings.xml
@@ -46,7 +46,7 @@
     <string name="wifi_connected_less_secure" msgid="2385231117439764954">"<xliff:g id="SECURITY_TYPE">%1$s</xliff:g> (తక్కువ సురక్షితమైనది)"</string>
     <string name="wifitrackerlib_admin_restricted_network" msgid="5439914801076897515">"మీ సంస్థచే అనుమతించబడదు"</string>
     <string name="wifitrackerlib_hotspot_network_summary" msgid="7661086683527884190">"<xliff:g id="MODEL_NAME">%2$s</xliff:g> నుండి <xliff:g id="NETWORK_NAME">%1$s</xliff:g>"</string>
-    <string name="wifitrackerlib_hotspot_network_summary_new" msgid="1165705867298669621">"{DEVICE_TYPE,select, PHONE{మీ ఫోన్ నుండి {NETWORK_NAME}}TABLET{మీ టాబ్లెట్ నుండి {NETWORK_NAME}}COMPUTER{మీ కంప్యూటర్ నుండి {NETWORK_NAME}}WATCH{మీ వాచ్ నుండి {NETWORK_NAME}}VEHICLE{మీ వెహికల్‌ నుండి {NETWORK_NAME}}other{మీ పరికరం నుండి {NETWORK_NAME}}}"</string>
+    <string name="wifitrackerlib_hotspot_network_summary_new" msgid="1165705867298669621">"{DEVICE_TYPE,select, PHONE{మీ ఫోన్ నుండి {NETWORK_NAME}}TABLET{మీ టాబ్లెట్ నుండి {NETWORK_NAME}}COMPUTER{మీ కంప్యూటర్ నుండి {NETWORK_NAME}}WATCH{మీ వాచ్ నుండి {NETWORK_NAME}}VEHICLE{మీ వెహికల్‌ నుండి {NETWORK_NAME}}other{మీ డివైజ్ నుండి {NETWORK_NAME}}}"</string>
     <string name="wifitrackerlib_hotspot_network_summary_error_generic" msgid="2339836723160908882">"కనెక్ట్ చేయడం సాధ్యం కాదు. మళ్లీ కనెక్ట్ చేయడానికి ట్రై చేయండి."</string>
     <string name="wifitrackerlib_hotspot_network_summary_error_settings" msgid="6928234716406336668">"{DEVICE_TYPE,select, PHONE{కనెక్ట్ చేయడం సాధ్యం కాదు. ఫోన్ సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}TABLET{కనెక్ట్ చేయడం సాధ్యం కాదు. టాబ్లెట్ సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}COMPUTER{కనెక్ట్ చేయడం సాధ్యం కాదు. కంప్యూటర్ సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}WATCH{కనెక్ట్ చేయడం సాధ్యం కాదు. వాచ్ సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}VEHICLE{కనెక్ట్ చేయడం సాధ్యం కాదు. వాహనం సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}other{కనెక్ట్ చేయడం సాధ్యం కాదు. పరికర సెట్టింగ్‌లను చెక్ చేసి, మళ్లీ ట్రై చేయండి.}}"</string>
     <string name="wifitrackerlib_hotspot_network_summary_error_carrier_block" msgid="359780026027619177">"<xliff:g id="NETWORK_NAME">%1$s</xliff:g> ఈ కనెక్షన్‌ను అనుమతించదు"</string>
diff --git a/libs/WifiTrackerLib/sdk_src/src/com/android/wifitrackerlib/NonSdkApiWrapper.java b/libs/WifiTrackerLib/sdk_src/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
index 4c6b1279e..5b9e79020 100644
--- a/libs/WifiTrackerLib/sdk_src/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
+++ b/libs/WifiTrackerLib/sdk_src/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
@@ -93,14 +93,6 @@ class NonSdkApiWrapper {
         return null;
     }
 
-    /**
-     * Whether the hotspot network provider battery charging status flag is enabled.
-     */
-    static boolean isNetworkProviderBatteryChargingStatusEnabled() {
-        // Google3 can't access trunk stable flags, so default to false.
-        return false;
-    }
-
     /**
      * Whether Android Wifi V Apis flag is enabled.
      */
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/BaseWifiTracker.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/BaseWifiTracker.java
index 6a7ecbe90..a26d367ed 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/BaseWifiTracker.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/BaseWifiTracker.java
@@ -167,12 +167,9 @@ public class BaseWifiTracker {
     protected final PowerManager mPowerManager;
     protected final Handler mMainHandler;
     protected final Handler mWorkerHandler;
-    protected final long mMaxScanAgeMillis;
     protected final long mScanIntervalMillis;
     protected final ScanResultUpdater mScanResultUpdater;
 
-    protected static final long MAX_SCAN_AGE_FOR_FAILED_SCAN_MS = 5 * 60 * 1000;
-
     @Nullable protected SharedConnectivityManager mSharedConnectivityManager = null;
 
     // This is null for SDK levels less than Baklava.
@@ -363,12 +360,11 @@ public class BaseWifiTracker {
         }
         mMainHandler = mainHandler;
         mWorkerHandler = workerHandler;
-        mMaxScanAgeMillis = maxScanAgeMillis;
         mScanIntervalMillis = scanIntervalMillis;
         mListener = listener;
         mTag = tag;
 
-        mScanResultUpdater = new ScanResultUpdater(clock, MAX_SCAN_AGE_FOR_FAILED_SCAN_MS);
+        mScanResultUpdater = new ScanResultUpdater(clock, maxScanAgeMillis);
         mScanner = new BaseWifiTracker.Scanner(workerHandler.getLooper());
 
         if (lifecycle != null) { // Need to add after constructor completes.
@@ -751,7 +747,8 @@ public class BaseWifiTracker {
                     }
                     // Fake a SCAN_RESULTS_AVAILABLE_ACTION. The results should already be populated
                     // in mScanResultUpdater, which is the source of truth for the child classes.
-                    mScanResultUpdater.update(scanResults);
+                    mScanResultUpdater.onScanResultsAvailable(
+                            scanResults, true /* scanSucceeded */);
                     handleScanResultsAvailableAction(
                             new Intent(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)
                                     .putExtra(WifiManager.EXTRA_RESULTS_UPDATED, true));
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/HotspotNetworkEntry.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/HotspotNetworkEntry.java
index f0e7c7b4f..e42ad4e97 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/HotspotNetworkEntry.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/HotspotNetworkEntry.java
@@ -404,7 +404,6 @@ public class HotspotNetworkEntry extends WifiEntry {
             return false;
         }
         if (BuildCompat.isAtLeastV()
-                && NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled()
                 && mHotspotNetworkData.getNetworkProviderInfo().isBatteryCharging()) {
             return true;
         }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/NonSdkApiWrapper.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
index 867337471..6ccd31037 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/NonSdkApiWrapper.java
@@ -127,13 +127,6 @@ class NonSdkApiWrapper {
         return null;
     }
 
-    /**
-     * Whether the hotspot network provider battery charging status flag is enabled.
-     */
-    static boolean isNetworkProviderBatteryChargingStatusEnabled() {
-        return BuildCompat.isAtLeastV();
-    }
-
     /**
      * Whether Android Wifi V Apis flag is enabled.
      */
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/PasspointNetworkDetailsTracker.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/PasspointNetworkDetailsTracker.java
index 23b8d8bd0..41d64c041 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/PasspointNetworkDetailsTracker.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/PasspointNetworkDetailsTracker.java
@@ -136,7 +136,7 @@ public class PasspointNetworkDetailsTracker extends NetworkDetailsTracker {
     @WorkerThread
     @Override
     protected void handleWifiStateChangedAction() {
-        conditionallyUpdateScanResults(true /* lastScanSucceeded */);
+        conditionallyUpdateScanResults(false /* lastScanSucceeded */);
     }
 
     @WorkerThread
@@ -156,7 +156,7 @@ public class PasspointNetworkDetailsTracker extends NetworkDetailsTracker {
 
     @WorkerThread
     private void updateStartInfo() {
-        conditionallyUpdateScanResults(true /* lastScanSucceeded */);
+        conditionallyUpdateScanResults(false /* lastScanSucceeded */);
         conditionallyUpdateConfig();
         // Clear any stale connection info in case we missed any NetworkCallback.onLost() while in
         // the stopped state, but don't notify the listener to avoid flicker from disconnected ->
@@ -255,16 +255,8 @@ public class PasspointNetworkDetailsTracker extends NetworkDetailsTracker {
             return;
         }
 
-        long scanAgeWindow = mMaxScanAgeMillis;
-        if (lastScanSucceeded) {
-            cacheNewScanResults();
-        } else {
-            // Scan failed, increase scan age window to prevent WifiEntry list from
-            // clearing prematurely.
-            scanAgeWindow = MAX_SCAN_AGE_FOR_FAILED_SCAN_MS;
-        }
-
-        List<ScanResult> currentScans = mScanResultUpdater.getScanResults(scanAgeWindow);
+        mScanResultUpdater.onScanResultsAvailable(mWifiManager.getScanResults(), lastScanSucceeded);
+        List<ScanResult> currentScans = mScanResultUpdater.getScanResults();
         updatePasspointWifiEntryScans(currentScans);
         updateOsuWifiEntryScans(currentScans);
     }
@@ -279,11 +271,4 @@ public class PasspointNetworkDetailsTracker extends NetworkDetailsTracker {
                         mChosenEntry.getKey()))
                 .findAny().ifPresent(config -> mChosenEntry.updatePasspointConfig(config));
     }
-
-    /**
-     * Updates ScanResultUpdater with new ScanResults.
-     */
-    private void cacheNewScanResults() {
-        mScanResultUpdater.update(mWifiManager.getScanResults());
-    }
 }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/SavedNetworkTracker.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/SavedNetworkTracker.java
index 73ca6028c..8fc7a1968 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/SavedNetworkTracker.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/SavedNetworkTracker.java
@@ -33,6 +33,7 @@ import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.NetworkInfo;
 import android.net.wifi.ScanResult;
+import android.net.wifi.SupplicantState;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiEnterpriseConfig;
 import android.net.wifi.WifiInfo;
@@ -235,7 +236,6 @@ public class SavedNetworkTracker extends BaseWifiTracker {
         // Update configs and scans
         updateStandardWifiEntryConfigs(mWifiManager.getConfiguredNetworks());
         updatePasspointWifiEntryConfigs(mWifiManager.getPasspointConfigurations());
-        mScanResultUpdater.update(mWifiManager.getScanResults());
         conditionallyUpdateScanResults(true /* lastScanSucceeded */);
 
         // Trigger callbacks manually now to avoid waiting until the first calls to update state.
@@ -246,7 +246,8 @@ public class SavedNetworkTracker extends BaseWifiTracker {
             entry.clearConnectionInfo(false);
         }
         Network currentNetwork = mWifiManager.getCurrentNetwork();
-        if (currentNetwork != null) {
+        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
+        if (currentNetwork != null && wifiInfo.getSupplicantState() == SupplicantState.COMPLETED) {
             NetworkCapabilities networkCapabilities =
                     mConnectivityManager.getNetworkCapabilities(currentNetwork);
             if (networkCapabilities != null) {
@@ -254,7 +255,7 @@ public class SavedNetworkTracker extends BaseWifiTracker {
                 // networkId, so we need to set the WifiInfo directly from WifiManager.
                 handleNetworkCapabilitiesChanged(currentNetwork,
                         new NetworkCapabilities.Builder(networkCapabilities)
-                                .setTransportInfo(mWifiManager.getConnectionInfo())
+                                .setTransportInfo(wifiInfo)
                                 .build());
             }
             LinkProperties linkProperties = mConnectivityManager.getLinkProperties(currentNetwork);
@@ -435,16 +436,8 @@ public class SavedNetworkTracker extends BaseWifiTracker {
             return;
         }
 
-        long scanAgeWindow = mMaxScanAgeMillis;
-        if (lastScanSucceeded) {
-            // Scan succeeded, cache new scans
-            mScanResultUpdater.update(mWifiManager.getScanResults());
-        } else {
-            // Scan failed, increase scan age window to prevent WifiEntry list from
-            // clearing prematurely.
-            scanAgeWindow = MAX_SCAN_AGE_FOR_FAILED_SCAN_MS;
-        }
-        List<ScanResult> currentScans = mScanResultUpdater.getScanResults(scanAgeWindow);
+        mScanResultUpdater.onScanResultsAvailable(mWifiManager.getScanResults(), lastScanSucceeded);
+        List<ScanResult> currentScans = mScanResultUpdater.getScanResults();
         updateStandardWifiEntryScans(currentScans);
         updatePasspointWifiEntryScans(currentScans);
     }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/ScanResultUpdater.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/ScanResultUpdater.java
index 5e3df2ccd..d85955371 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/ScanResultUpdater.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/ScanResultUpdater.java
@@ -33,20 +33,13 @@ import java.util.Map;
  * Thread-safe.
  */
 public class ScanResultUpdater {
+    private static final long MAX_SCAN_AGE_FOR_FAILED_SCAN_MS = 5 * 60 * 1000;
+
     private Map<Pair<String, String>, ScanResult> mScanResultsBySsidAndBssid = new ArrayMap<>();
     private final long mMaxScanAgeMillis;
     private final Object mLock = new Object();
     private final Clock mClock;
 
-    /**
-     * Creates a ScanResultUpdater with no max scan age.
-     *
-     * @param clock Elapsed real time Clock to compare with ScanResult timestamps.
-     */
-    public ScanResultUpdater(Clock clock) {
-        this(clock, Long.MAX_VALUE);
-    }
-
     /**
      * Creates a ScanResultUpdater with a max scan age in milliseconds. Scans older than this limit
      * will be pruned upon update/retrieval to keep the size of the scan list down.
@@ -57,12 +50,15 @@ public class ScanResultUpdater {
     }
 
     /**
-     * Updates scan result list and replaces older scans of the same SSID+BSSID pair.
+     * Updates the latest scan results, replacing older scans of the same SSID+BSSID pair and
+     * removing any scan that is older than the max scan age.
+     * Note: To prevent the scan result list from clearing out in the case of temporary consecutive
+     * failed scans, avoid clearing old scans upon scan failure as long as they're not older than
+     * MAX_SCAN_AGE_FOR_FAILED_SCAN_MS.
      */
-    public void update(@NonNull List<ScanResult> newResults) {
+    public void onScanResultsAvailable(
+            @NonNull List<ScanResult> newResults, boolean scanSucceeded) {
         synchronized (mLock) {
-            evictOldScans();
-
             for (ScanResult result : newResults) {
                 final Pair<String, String> key = new Pair(result.SSID, result.BSSID);
                 ScanResult prevResult = mScanResultsBySsidAndBssid.get(key);
@@ -70,42 +66,19 @@ public class ScanResultUpdater {
                     mScanResultsBySsidAndBssid.put(key, result);
                 }
             }
+            long maxScanAge = scanSucceeded ? mMaxScanAgeMillis : MAX_SCAN_AGE_FOR_FAILED_SCAN_MS;
+            mScanResultsBySsidAndBssid.entrySet().removeIf((entry) ->
+                    mClock.millis() - entry.getValue().timestamp / 1000 > maxScanAge);
         }
     }
 
     /**
-     * Returns all seen scan results merged by SSID+BSSID pair.
-     */
-    @NonNull
-    public List<ScanResult> getScanResults() {
-        return getScanResults(mMaxScanAgeMillis);
-    }
-
-    /**
-     * Returns all seen scan results merged by SSID+BSSID pair and newer than maxScanAgeMillis.
-     * maxScanAgeMillis must be less than or equal to the mMaxScanAgeMillis field if it was set.
+     * Returns the current up-to-date scan results merged by SSID+BSSID pair.
      */
     @NonNull
-    public List<ScanResult> getScanResults(long maxScanAgeMillis) throws IllegalArgumentException {
-        if (maxScanAgeMillis > mMaxScanAgeMillis) {
-            throw new IllegalArgumentException(
-                    "maxScanAgeMillis argument cannot be greater than mMaxScanAgeMillis!");
-        }
-        synchronized (mLock) {
-            List<ScanResult> ageFilteredResults = new ArrayList<>();
-            for (ScanResult result : mScanResultsBySsidAndBssid.values()) {
-                if (mClock.millis() - result.timestamp / 1000 <= maxScanAgeMillis) {
-                    ageFilteredResults.add(result);
-                }
-            }
-            return ageFilteredResults;
-        }
-    }
-
-    private void evictOldScans() {
+    public List<ScanResult> getScanResults() throws IllegalArgumentException {
         synchronized (mLock) {
-            mScanResultsBySsidAndBssid.entrySet().removeIf((entry) ->
-                    mClock.millis() - entry.getValue().timestamp / 1000 > mMaxScanAgeMillis);
+            return new ArrayList<>(mScanResultsBySsidAndBssid.values());
         }
     }
 }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/StandardNetworkDetailsTracker.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/StandardNetworkDetailsTracker.java
index c4a78dbcf..af0afe590 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/StandardNetworkDetailsTracker.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/StandardNetworkDetailsTracker.java
@@ -111,7 +111,7 @@ public class StandardNetworkDetailsTracker extends NetworkDetailsTracker {
     @WorkerThread
     @Override
     protected void handleWifiStateChangedAction() {
-        conditionallyUpdateScanResults(true /* lastScanSucceeded */);
+        conditionallyUpdateScanResults(false /* lastScanSucceeded */);
     }
 
     @WorkerThread
@@ -131,8 +131,7 @@ public class StandardNetworkDetailsTracker extends NetworkDetailsTracker {
 
     @WorkerThread
     private void updateStartInfo() {
-
-        conditionallyUpdateScanResults(true /* lastScanSucceeded */);
+        conditionallyUpdateScanResults(false /* lastScanSucceeded */);
         conditionallyUpdateConfig();
         handleDefaultSubscriptionChanged(SubscriptionManager.getDefaultDataSubscriptionId());
         // Clear any stale connection info in case we missed any NetworkCallback.onLost() while in
@@ -167,15 +166,8 @@ public class StandardNetworkDetailsTracker extends NetworkDetailsTracker {
             return;
         }
 
-        long scanAgeWindow = mMaxScanAgeMillis;
-        if (lastScanSucceeded) {
-            mScanResultUpdater.update(mWifiManager.getScanResults());
-        } else {
-            // Scan failed, increase scan age window to prevent WifiEntry list from
-            // clearing prematurely.
-            scanAgeWindow = MAX_SCAN_AGE_FOR_FAILED_SCAN_MS;
-        }
-        mChosenEntry.updateScanResultInfo(mScanResultUpdater.getScanResults(scanAgeWindow).stream()
+        mScanResultUpdater.onScanResultsAvailable(mWifiManager.getScanResults(), lastScanSucceeded);
+        mChosenEntry.updateScanResultInfo(mScanResultUpdater.getScanResults().stream()
                 .filter(scan -> new ScanResultKey(scan).equals(mKey.getScanResultKey()))
                 .collect(toList()));
     }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/Utils.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/Utils.java
index 9744d3d91..136959399 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/Utils.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/Utils.java
@@ -50,6 +50,7 @@ import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiConfiguration.NetworkSelectionStatus;
 import android.net.wifi.WifiEnterpriseConfig;
 import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
 import android.net.wifi.WifiScanner;
 import android.os.Build;
 import android.os.PersistableBundle;
@@ -1330,4 +1331,16 @@ public class Utils {
 
         return null;
     }
+
+    /**
+     * Returns true if there already exists a shared network with the given SSID and security type
+     * family.
+     */
+    public static boolean doesSharedNetworkAlreadyExist(
+            WifiManager wifiManager,
+            String ssid,
+            int securityType) {
+        // TODO(416638579): Implement this.
+        return true;
+    }
 }
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiEntry.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiEntry.java
index fa0065280..0a5723453 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiEntry.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiEntry.java
@@ -871,6 +871,46 @@ public class WifiEntry {
         return false;
     }
 
+    /**
+     * Returns true if this network was saved by the current user.
+     */
+    public boolean isOwnedByCurrentUser() {
+        // TODO(416638579): Implement this.
+        return true;
+    }
+
+    /**
+     * Returns true if this network is shared with other users.
+     */
+    public boolean isSharedWithOtherUsers() {
+        // TODO(416638579): Implement this.
+        return true;
+    }
+
+    /**
+     * Sets whether this network is shared with other users.
+     */
+    public void setSharedWithOtherUsers(boolean shared) {
+        // TODO(416638579): Implement this.
+        // Do nothing.
+    }
+
+    /**
+     * Returns true if this network is modifiable by other users.
+     */
+    public boolean isModifiableByOtherUsers() {
+        // TODO(416638579): Implement this.
+        return true;
+    }
+
+    /**
+     * Sets whether this network is modifiable by other users.
+     */
+    public void setModifiableByOtherUsers(boolean modifiable) {
+        // TODO(416638579): Implement this.
+        // Do nothing.
+    }
+
     /**
      * Sets the callback listener for WifiEntryCallback methods.
      * Subsequent calls will overwrite the previous listener.
@@ -1054,8 +1094,10 @@ public class WifiEntry {
 
         // Connection info matches, so the Network/NetworkCapabilities represent this network
         // and the network is currently connecting or connected.
-        mLastNetwork = mNetwork;
-        mNetwork = network;
+        if (mNetwork != network) {
+            mLastNetwork = mNetwork;
+            mNetwork = network;
+        }
         mNetworkCapabilities = capabilities;
         updateWifiInfo(wifiInfo);
         notifyOnUpdated();
diff --git a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiPickerTracker.java b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiPickerTracker.java
index 11e90d8f3..cf75b520e 100644
--- a/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiPickerTracker.java
+++ b/libs/WifiTrackerLib/src/com/android/wifitrackerlib/WifiPickerTracker.java
@@ -43,6 +43,7 @@ import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.NetworkInfo;
 import android.net.wifi.ScanResult;
+import android.net.wifi.SupplicantState;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiInfo;
 import android.net.wifi.WifiManager;
@@ -291,7 +292,6 @@ public class WifiPickerTracker extends BaseWifiTracker {
         // Update configs and scans
         updateWifiConfigurationsInternal();
         updatePasspointConfigurations(mWifiManager.getPasspointConfigurations());
-        mScanResultUpdater.update(mWifiManager.getScanResults());
         conditionallyUpdateScanResults(true /* lastScanSucceeded */);
 
         // Trigger callbacks manually now to avoid waiting until the first calls to update state.
@@ -303,7 +303,8 @@ public class WifiPickerTracker extends BaseWifiTracker {
             entry.clearConnectionInfo(false);
         }
         Network currentNetwork = mWifiManager.getCurrentNetwork();
-        if (currentNetwork != null) {
+        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
+        if (currentNetwork != null && wifiInfo.getSupplicantState() == SupplicantState.COMPLETED) {
             NetworkCapabilities networkCapabilities =
                     mConnectivityManager.getNetworkCapabilities(currentNetwork);
             if (networkCapabilities != null) {
@@ -311,7 +312,7 @@ public class WifiPickerTracker extends BaseWifiTracker {
                 // networkId, so we need to set the WifiInfo directly from WifiManager.
                 handleNetworkCapabilitiesChanged(currentNetwork,
                         new NetworkCapabilities.Builder(networkCapabilities)
-                                .setTransportInfo(mWifiManager.getConnectionInfo())
+                                .setTransportInfo(wifiInfo)
                                 .build());
             }
             LinkProperties linkProperties = mConnectivityManager.getLinkProperties(currentNetwork);
@@ -1101,17 +1102,8 @@ public class WifiPickerTracker extends BaseWifiTracker {
             return;
         }
 
-        long scanAgeWindow = mMaxScanAgeMillis;
-        if (lastScanSucceeded) {
-            // Scan succeeded, cache new scans
-            mScanResultUpdater.update(mWifiManager.getScanResults());
-        } else {
-            // Scan failed, increase scan age window to prevent WifiEntry list from
-            // clearing prematurely.
-            scanAgeWindow = MAX_SCAN_AGE_FOR_FAILED_SCAN_MS;
-        }
-
-        List<ScanResult> scanResults = mScanResultUpdater.getScanResults(scanAgeWindow);
+        mScanResultUpdater.onScanResultsAvailable(mWifiManager.getScanResults(), lastScanSucceeded);
+        List<ScanResult> scanResults = mScanResultUpdater.getScanResults();
         updateStandardWifiEntryScans(scanResults);
         updateSuggestedWifiEntryScans(scanResults);
         updatePasspointWifiEntryScans(scanResults);
@@ -1180,8 +1172,6 @@ public class WifiPickerTracker extends BaseWifiTracker {
             // Remove if the suggestion does not have a config anymore.
             return !entry.isSuggestion();
         });
-        // Update suggestion scans to make sure we mark which suggestions are user-shareable.
-        updateSuggestedWifiEntryScans(mScanResultUpdater.getScanResults());
 
         if (mNetworkRequestEntry != null) {
             mNetworkRequestEntry.updateConfig(
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/HotspotNetworkEntryTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/HotspotNetworkEntryTest.java
index 633dcafb4..13003ff1e 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/HotspotNetworkEntryTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/HotspotNetworkEntryTest.java
@@ -21,7 +21,6 @@ import static android.net.wifi.WifiInfo.SECURITY_TYPE_PSK;
 import static android.net.wifi.WifiInfo.SECURITY_TYPE_SAE;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.wifitrackerlib.WifiEntry.CONNECTED_STATE_CONNECTED;
 import static com.android.wifitrackerlib.WifiEntry.CONNECTED_STATE_DISCONNECTED;
 import static com.android.wifitrackerlib.WifiEntry.MIN_FREQ_24GHZ;
@@ -54,18 +53,26 @@ import android.os.test.TestLooper;
 import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 
+import androidx.core.os.BuildCompat;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
 
 public class HotspotNetworkEntryTest {
     @Rule
     public final CheckFlagsRule mCheckFlagsRule =
             DeviceFlagsValueProvider.createCheckFlagsRule();
 
+    private MockitoSession mSession;
+
     @Mock private WifiEntry.WifiEntryCallback mMockListener;
     @Mock private WifiEntry.ConnectCallback mMockConnectCallback;
     @Mock private WifiEntry.DisconnectCallback mMockDisconnectCallback;
@@ -98,6 +105,11 @@ public class HotspotNetworkEntryTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        mSession = ExtendedMockito.mockitoSession()
+                .spyStatic(NonSdkApiWrapper.class)
+                .spyStatic(BuildCompat.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
 
         mTestLooper = new TestLooper();
         mTestHandler = new Handler(mTestLooper.getLooper());
@@ -165,6 +177,14 @@ public class HotspotNetworkEntryTest {
                 ", ");
     }
 
+    @After
+    public void cleanUp() throws Exception {
+        ExtendedMockito.validateMockitoUsage();
+        if (mSession != null) {
+            mSession.finishMocking();
+        }
+    }
+
     @Test
     public void testConnectionInfoMatches_matchesSsidAndSecurity() {
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
@@ -508,7 +528,7 @@ public class HotspotNetworkEntryTest {
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOn_usesHotspotNetworkDataApi() {
+    public void testIsBatteryCharging_isAtLeastVTrue_usesHotspotNetworkDataApi() {
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
                 mMockInjector, mMockContext, mTestHandler,
                 mMockWifiManager, mMockSharedConnectivityManager,
@@ -527,18 +547,12 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isTrue();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isTrue();
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOn_usesHotspotNetworkDataExtras() {
+    public void testIsBatteryCharging_isAtLeastVTrue_usesHotspotNetworkDataExtras() {
         final Bundle extras = new Bundle();
         extras.putBoolean(HotspotNetworkEntry.EXTRA_KEY_IS_BATTERY_CHARGING, true);
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
@@ -560,18 +574,12 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isTrue();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isTrue();
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOff_usesHotspotNetworkDataExtras() {
+    public void testIsBatteryCharging_isAtLeastVFalse_usesHotspotNetworkDataExtras() {
         final Bundle extras = new Bundle();
         extras.putBoolean(HotspotNetworkEntry.EXTRA_KEY_IS_BATTERY_CHARGING, true);
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
@@ -592,18 +600,12 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(false).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isTrue();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(false).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isTrue();
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOn_extraFalse() {
+    public void testIsBatteryCharging_isAtLeastVTrue_extraFalse() {
         final Bundle extras = new Bundle();
         extras.putBoolean(HotspotNetworkEntry.EXTRA_KEY_IS_BATTERY_CHARGING, false);
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
@@ -624,18 +626,12 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isFalse();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isFalse();
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOn_apiFalse() {
+    public void testIsBatteryCharging_isAtLeastVTrue_apiFalse() {
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
                 mMockInjector, mMockContext, mTestHandler,
                 mMockWifiManager, mMockSharedConnectivityManager,
@@ -654,18 +650,12 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isFalse();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isFalse();
     }
 
     @Test
-    public void testIsBatteryCharging_apiFlagOn_noneSet() {
+    public void testIsBatteryCharging_isAtLeastVTrue_noneSet() {
         final HotspotNetworkEntry entry = new HotspotNetworkEntry(
                 mMockInjector, mMockContext, mTestHandler,
                 mMockWifiManager, mMockSharedConnectivityManager,
@@ -683,14 +673,8 @@ public class HotspotNetworkEntryTest {
                         .addHotspotSecurityType(SECURITY_TYPE_PSK)
                         .build());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isNetworkProviderBatteryChargingStatusEnabled());
-            assertThat(entry.isBatteryCharging()).isFalse();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> BuildCompat.isAtLeastV());
+        assertThat(entry.isBatteryCharging()).isFalse();
     }
 
     @Test
@@ -1109,23 +1093,18 @@ public class HotspotNetworkEntryTest {
                 mMockWifiManager, mMockSharedConnectivityManager, TEST_HOTSPOT_NETWORK_DATA);
         entry.setListener(mMockListener);
         entry.connect(mMockConnectCallback);
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkUnknownStatusResetsConnectingStateEnabled());
-            entry.onConnectionStatusChanged(
-                    HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
-            mTestLooper.dispatchAll();
-            assertThat(entry.getSummary()).isEqualTo("Connecting…");
-
-            entry.onConnectionStatusChanged(
-                    HotspotNetworkConnectionStatus.CONNECTION_STATUS_UNKNOWN);
-            mTestLooper.dispatchAll();
-
-            assertThat(entry.getSummary()).isNotEqualTo("Connecting…");
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkUnknownStatusResetsConnectingStateEnabled());
+        entry.onConnectionStatusChanged(
+                HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
+        mTestLooper.dispatchAll();
+        assertThat(entry.getSummary()).isEqualTo("Connecting…");
+
+        entry.onConnectionStatusChanged(
+                HotspotNetworkConnectionStatus.CONNECTION_STATUS_UNKNOWN);
+        mTestLooper.dispatchAll();
+
+        assertThat(entry.getSummary()).isNotEqualTo("Connecting…");
     }
 
     @Test
@@ -1140,14 +1119,9 @@ public class HotspotNetworkEntryTest {
                 HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
         mTestLooper.dispatchAll();
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(false).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            assertThat(entry.getSummary(true)).isEqualTo("Connecting…");
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(false).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        assertThat(entry.getSummary(true)).isEqualTo("Connecting…");
     }
 
     @Test
@@ -1162,14 +1136,9 @@ public class HotspotNetworkEntryTest {
                 HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
         mTestLooper.dispatchAll();
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            assertThat(entry.getSummary(true)).isEqualTo("Google Fi from your phone");
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        assertThat(entry.getSummary(true)).isEqualTo("Google Fi from your phone");
     }
 
     @Test
@@ -1184,14 +1153,9 @@ public class HotspotNetworkEntryTest {
                 HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
         mTestLooper.dispatchAll();
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            assertThat(entry.getSummary(false)).isEqualTo("Connecting…");
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        assertThat(entry.getSummary(false)).isEqualTo("Connecting…");
     }
 
     @Test
@@ -1206,15 +1170,10 @@ public class HotspotNetworkEntryTest {
                 HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
         mTestLooper.dispatchAll();
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(false).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            assertThat(entry.getConnectedState())
-                    .isEqualTo(HotspotNetworkEntry.CONNECTED_STATE_DISCONNECTED);
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(false).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        assertThat(entry.getConnectedState())
+                .isEqualTo(HotspotNetworkEntry.CONNECTED_STATE_DISCONNECTED);
     }
 
     @Test
@@ -1229,14 +1188,9 @@ public class HotspotNetworkEntryTest {
                 HotspotNetworkConnectionStatus.CONNECTION_STATUS_ENABLING_HOTSPOT);
         mTestLooper.dispatchAll();
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            assertThat(entry.getConnectedState())
-                    .isEqualTo(HotspotNetworkEntry.CONNECTED_STATE_CONNECTING);
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        assertThat(entry.getConnectedState())
+                .isEqualTo(HotspotNetworkEntry.CONNECTED_STATE_CONNECTING);
     }
 }
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/PasspointWifiEntryTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/PasspointWifiEntryTest.java
index ae2730af1..1cfbb5063 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/PasspointWifiEntryTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/PasspointWifiEntryTest.java
@@ -16,7 +16,6 @@
 
 package com.android.wifitrackerlib;
 
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.verify;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -42,6 +41,9 @@ import android.net.wifi.hotspot2.pps.HomeSp;
 import android.os.Handler;
 import android.os.test.TestLooper;
 
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -52,6 +54,7 @@ import org.mockito.MockitoSession;
 import java.util.Arrays;
 
 public class PasspointWifiEntryTest {
+    private MockitoSession mSession;
     @Mock private WifiTrackerInjector mMockInjector;
     @Mock private Context mMockContext;
     @Mock private WifiManager mMockWifiManager;
@@ -69,6 +72,9 @@ public class PasspointWifiEntryTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        mSession = ExtendedMockito.mockitoSession()
+                .spyStatic(NonSdkApiWrapper.class)
+                .startMocking();
 
         mTestLooper = new TestLooper();
         mTestHandler = new Handler(mTestLooper.getLooper());
@@ -85,6 +91,14 @@ public class PasspointWifiEntryTest {
                 .thenReturn(mMockConnectivityManager);
     }
 
+    @After
+    public void cleanUp() throws Exception {
+        ExtendedMockito.validateMockitoUsage();
+        if (mSession != null) {
+            mSession.finishMocking();
+        }
+    }
+
     @Test
     public void testGetSummary_expiredTimeNotAvailable_notShowExpired() {
         // default SubscriptionExpirationTimeInMillis is unset
@@ -322,29 +336,23 @@ public class PasspointWifiEntryTest {
                 getPasspointConfiguration(), mMockWifiManager,
                 false /* forSavedNetworksPage */);
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // Simulate user tapping on the network and receiving captive portal capabilities.
-            // This should trigger the captive portal app.
-            entry.connect(null /* callback */);
-            when(mMockWifiInfo.isPasspointAp()).thenReturn(true);
-            when(mMockWifiInfo.getPasspointFqdn()).thenReturn(FQDN);
-            when(mMockWifiInfo.getPasspointUniqueId()).thenReturn(
-                    getPasspointConfiguration().getUniqueId());
-            when(mMockNetworkCapabilities.hasCapability(
-                    NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL)).thenReturn(true);
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-
-            verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
-
-            // Update network capabilities again. This should not trigger the captive portal app.
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-
-            verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
-        } finally {
-            session.finishMocking();
-        }
+        // Simulate user tapping on the network and receiving captive portal capabilities.
+        // This should trigger the captive portal app.
+        entry.connect(null /* callback */);
+        when(mMockWifiInfo.isPasspointAp()).thenReturn(true);
+        when(mMockWifiInfo.getPasspointFqdn()).thenReturn(FQDN);
+        when(mMockWifiInfo.getPasspointUniqueId()).thenReturn(
+                getPasspointConfiguration().getUniqueId());
+        when(mMockNetworkCapabilities.hasCapability(
+                NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL)).thenReturn(true);
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+
+        verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
+
+        // Update network capabilities again. This should not trigger the captive portal app.
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
 
+        verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
     }
 
     @Test
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/SavedNetworkTrackerTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/SavedNetworkTrackerTest.java
index d9e7cef97..9aeba32ee 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/SavedNetworkTrackerTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/SavedNetworkTrackerTest.java
@@ -17,7 +17,6 @@
 package com.android.wifitrackerlib;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.wifitrackerlib.TestUtils.GOOD_RSSI;
 import static com.android.wifitrackerlib.TestUtils.buildScanResult;
 import static com.android.wifitrackerlib.TestUtils.buildWifiConfiguration;
@@ -46,6 +45,7 @@ import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.wifi.ScanResult;
+import android.net.wifi.SupplicantState;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiEnterpriseConfig;
 import android.net.wifi.WifiInfo;
@@ -59,6 +59,9 @@ import android.os.test.TestLooper;
 
 import androidx.lifecycle.Lifecycle;
 
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
@@ -66,6 +69,7 @@ import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
 
 import java.time.Clock;
 import java.util.ArrayList;
@@ -83,6 +87,7 @@ public class SavedNetworkTrackerTest {
     private static final long SCAN_INTERVAL_MILLIS = 10_000;
 
     private static final String TEST_CACERT_NOT_REQUIRED_ALIAS = "cacert_not_required";
+    private MockitoSession mSession;
 
     @Mock private WifiTrackerInjector mInjector;
     @Mock private Lifecycle mMockLifecycle;
@@ -129,6 +134,11 @@ public class SavedNetworkTrackerTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        // static mocking
+        mSession = ExtendedMockito.mockitoSession()
+                .spyStatic(NonSdkApiWrapper.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
 
         mTestLooper = new TestLooper();
 
@@ -143,6 +153,7 @@ public class SavedNetworkTrackerTest {
         when(mMockWifiInfo.getNetworkId()).thenReturn(WifiConfiguration.INVALID_NETWORK_ID);
         when(mMockWifiInfo.getRssi()).thenReturn(WifiInfo.INVALID_RSSI);
         when(mMockWifiInfo.makeCopy(anyLong())).thenReturn(mMockWifiInfo);
+        when(mMockWifiInfo.getSupplicantState()).thenReturn(SupplicantState.COMPLETED);
         when(mMockNetworkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI))
                 .thenReturn(true);
         when(mMockNetworkCapabilities.getTransportInfo()).thenReturn(mMockWifiInfo);
@@ -164,6 +175,14 @@ public class SavedNetworkTrackerTest {
         when(mMockClock.millis()).thenReturn(START_MILLIS);
     }
 
+    @After
+    public void cleanUp() throws Exception {
+        ExtendedMockito.validateMockitoUsage();
+        if (mSession != null) {
+            mSession.finishMocking();
+        }
+    }
+
     /**
      * Tests that receiving a wifi state change broadcast updates getWifiState().
      */
@@ -564,6 +583,38 @@ public class SavedNetworkTrackerTest {
         assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
     }
 
+    /**
+     * Tests that a WifiEntry is not connected if WifiManager.getConnectionInfo() returns a WifiInfo
+     * whose supplicant state is not COMPLETED on start. This is to prevent cases where the current
+     * WifiInfo does not match WifiManager.getCurrentNetwork()/NetworkCapabilities.
+     */
+    @Test
+    public void testGetConnectedWifiEntry_supplicantStateNotCompleteOnStart_isNotConnected() {
+        final SavedNetworkTracker savedNetworkTracker = createTestSavedNetworkTracker();
+        final WifiConfiguration config = new WifiConfiguration();
+        config.SSID = "\"ssid\"";
+        config.networkId = 1;
+        when(mMockWifiManager.getConfiguredNetworks())
+                .thenReturn(Collections.singletonList(config));
+        when(mMockWifiInfo.getNetworkId()).thenReturn(1);
+        when(mMockWifiInfo.getRssi()).thenReturn(-50);
+
+        savedNetworkTracker.onStart();
+        mTestLooper.dispatchAll();
+
+        assertThat(savedNetworkTracker.getSavedWifiEntries()).isNotEmpty();
+        WifiEntry entry = savedNetworkTracker.getSavedWifiEntries().get(0);
+        assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
+
+        // Mock the WifiInfo being at the AUTHENTICATING supplicant state of a different connection.
+        when(mMockWifiInfo.getSupplicantState()).thenReturn(SupplicantState.AUTHENTICATING);
+        savedNetworkTracker.onStop();
+        savedNetworkTracker.onStart();
+        mTestLooper.dispatchAll();
+        // Entry should be disconnected.
+        assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
+    }
+
     /**
      * Tests that connecting to a network will update that network to CONNECTED_STATE_CONNECTED.
      */
@@ -697,45 +748,40 @@ public class SavedNetworkTrackerTest {
         assertThat(mbbEntry.getConnectedState())
                 .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // MBB network connected but not primary yet.
-            Network mbbNetwork = mock(Network.class);
-            NetworkCapabilities mbbNetworkCapabilities = mock(NetworkCapabilities.class);
-            WifiInfo mbbWifiInfo = mock(WifiInfo.class);
-            when(mbbWifiInfo.getNetworkId()).thenReturn(mbbConfig.networkId);
-            when(mbbWifiInfo.getRssi()).thenReturn(GOOD_RSSI);
-            when(mbbNetworkCapabilities.getTransportInfo()).thenReturn(mbbWifiInfo);
-            doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
-            // Original network should still be connected.
-            assertThat(originalEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_CONNECTED);
-            assertThat(mbbEntry.getConnectedState())
-                    .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
-
-            // Original network becomes non-primary and MBB network becomes primary.
-            doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
-            // MBB network should be connected now.
-            assertThat(originalEntry.getConnectedState())
-                    .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
-            assertThat(mbbEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_CONNECTED);
-
-            // Original network is lost. MBB network should still be connected
-            assertThat(originalEntry.getConnectedState())
-                    .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
-            assertThat(mbbEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_CONNECTED);
-        } finally {
-            session.finishMocking();
-        }
+        // MBB network connected but not primary yet.
+        Network mbbNetwork = mock(Network.class);
+        NetworkCapabilities mbbNetworkCapabilities = mock(NetworkCapabilities.class);
+        WifiInfo mbbWifiInfo = mock(WifiInfo.class);
+        when(mbbWifiInfo.getNetworkId()).thenReturn(mbbConfig.networkId);
+        when(mbbWifiInfo.getRssi()).thenReturn(GOOD_RSSI);
+        when(mbbNetworkCapabilities.getTransportInfo()).thenReturn(mbbWifiInfo);
+        doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
+        // Original network should still be connected.
+        assertThat(originalEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_CONNECTED);
+        assertThat(mbbEntry.getConnectedState())
+                .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
+
+        // Original network becomes non-primary and MBB network becomes primary.
+        doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
+        // MBB network should be connected now.
+        assertThat(originalEntry.getConnectedState())
+                .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
+        assertThat(mbbEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_CONNECTED);
+
+        // Original network is lost. MBB network should still be connected
+        assertThat(originalEntry.getConnectedState())
+                .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
+        assertThat(mbbEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_CONNECTED);
     }
 
     @Test
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/ScanResultUpdaterTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/ScanResultUpdaterTest.java
index b46153bd2..84e985908 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/ScanResultUpdaterTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/ScanResultUpdaterTest.java
@@ -20,7 +20,6 @@ import static com.android.wifitrackerlib.TestUtils.buildScanResult;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import static org.junit.Assert.fail;
 import static org.mockito.Mockito.when;
 
 import android.net.wifi.ScanResult;
@@ -32,14 +31,15 @@ import org.mockito.MockitoAnnotations;
 
 import java.time.Clock;
 import java.util.Arrays;
-import java.util.List;
+import java.util.Collections;
 
 public class ScanResultUpdaterTest {
     private static final String SSID = "ssid";
     private static final String BSSID_1 = "11:11:11:11:11:11";
     private static final String BSSID_2 = "22:22:22:22:22:22";
     private static final String BSSID_3 = "33:33:33:33:33:33";
-    private static final long NOW_MILLIS = 123_456_789;
+    private static final long TEST_START_TIME_MS = 123_456_789;
+    private static final long TEST_MAX_SCAN_AGE_MS = 15_000;
 
     @Mock private Clock mMockClock;
 
@@ -47,102 +47,102 @@ public class ScanResultUpdaterTest {
     public void setUp() {
         MockitoAnnotations.initMocks(this);
 
-        when(mMockClock.millis()).thenReturn(NOW_MILLIS);
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS);
     }
 
     /**
      * Verify that scan results of the same BSSID are merged to latest one.
      */
     @Test
-    public void testGetScanResults_mergeSameBssid() {
-        ScanResult oldResult = buildScanResult(SSID, BSSID_1, 10);
-        ScanResult newResult = buildScanResult(SSID, BSSID_1, 20);
+    public void testOnScanResultsAvailable_sameSsidBssidUpdatedMultipleTimes_latestScanReturned() {
+        ScanResult oldScan = buildScanResult(SSID, BSSID_1, TEST_START_TIME_MS);
+        ScanResult newScan = buildScanResult(SSID, BSSID_1, TEST_START_TIME_MS + 10);
 
         // Add initial scan result. List should have 1 scan.
-        ScanResultUpdater sru = new ScanResultUpdater(mMockClock);
-        sru.update(Arrays.asList(oldResult));
-        assertThat(sru.getScanResults()).containsExactly(oldResult);
+        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, TEST_MAX_SCAN_AGE_MS);
+        sru.onScanResultsAvailable(Arrays.asList(oldScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(oldScan);
 
         // Add new scan result. Old scan result should be replaced.
-        sru.update(Arrays.asList(newResult));
-        assertThat(sru.getScanResults()).containsExactly(newResult);
+        sru.onScanResultsAvailable(Arrays.asList(newScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(newScan);
 
         // Add old scan result back. New scan result should still remain.
-        sru.update(Arrays.asList(oldResult));
-        assertThat(sru.getScanResults()).containsExactly(newResult);
+        sru.onScanResultsAvailable(Arrays.asList(oldScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(newScan);
     }
 
     /**
      * Verify that scan results are filtered out by age.
      */
     @Test
-    public void testGetScanResults_filtersOldScans() {
-        long maxScanAge = 15_000;
-
-        ScanResult oldResult = buildScanResult(SSID, BSSID_1, NOW_MILLIS - (maxScanAge + 1));
-        ScanResult newResult = buildScanResult(SSID, BSSID_2, NOW_MILLIS);
-
-        // Add a new scan result and an out-of-date scan result.
-        ScanResultUpdater sru = new ScanResultUpdater(mMockClock);
-        sru.update(Arrays.asList(newResult, oldResult));
-
-        // New scan result should remain and out-of-date scan result should not be returned.
-        assertThat(sru.getScanResults(maxScanAge)).containsExactly(newResult);
-    }
-
-    /**
-     * Verify that an exception is thrown if the getScanResults max scan age is larger than the
-     * constructor's max scan age.
-     */
-    @Test
-    public void testGetScanResults_invalidMaxScanAgeMillis_throwsException() {
-        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, 15_000);
-        try {
-            sru.getScanResults(20_000);
-            fail("Should have thrown exception for maxScanAgeMillis too large.");
-        } catch (IllegalArgumentException ok) {
-            // Expected
-        }
+    public void testOnScanResultsAvailable_filtersOldScans() {
+        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, TEST_MAX_SCAN_AGE_MS);
+
+        // Add a scan result and a slightly newer scan result.
+        ScanResult olderScan = buildScanResult(SSID, BSSID_1, TEST_START_TIME_MS - 1);
+        ScanResult newerScan = buildScanResult(SSID, BSSID_2, TEST_START_TIME_MS);
+        sru.onScanResultsAvailable(Arrays.asList(olderScan, newerScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(olderScan, newerScan);
+
+        // Age the older result and verify the newer one remains.
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS + TEST_MAX_SCAN_AGE_MS);
+        sru.onScanResultsAvailable(Arrays.asList(olderScan, newerScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(newerScan);
+
+        // Age both results out and verify no results remain.
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS + TEST_MAX_SCAN_AGE_MS + 1);
+        sru.onScanResultsAvailable(Arrays.asList(olderScan, newerScan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).isEmpty();
     }
 
     /**
-     * Verify that the constructor max scan age is obeyed when getting scan results.
+     * Verify that scan results are not aged out if the last scan failed.
      */
     @Test
-    public void testConstructor_maxScanAge_filtersOldScans() {
-        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, 15_000);
-
-        ScanResult scan1 = buildScanResult(SSID, BSSID_1, NOW_MILLIS - 10_000);
-        ScanResult scan2 = buildScanResult(SSID, BSSID_2, NOW_MILLIS - 15_000);
-        ScanResult scan3 = buildScanResult(SSID, BSSID_3, NOW_MILLIS - 20_000);
-
-        sru.update(Arrays.asList(scan1, scan2, scan3));
-
-        List<ScanResult> scanResults = sru.getScanResults();
-
-        assertThat(scanResults).containsExactly(scan1, scan2);
+    public void testOnScanResultsAvailable_multipleScanFailure_scanNotAgedOut() {
+        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, TEST_MAX_SCAN_AGE_MS);
+
+        // Add scan result. List should have 1 scan.
+        ScanResult scan = buildScanResult(SSID, BSSID_1, TEST_START_TIME_MS);
+        sru.onScanResultsAvailable(Arrays.asList(scan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(scan);
+
+        // Failing the scan result should not remove the scan
+        sru.onScanResultsAvailable(Collections.emptyList(), false /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(scan);
+
+        // Failing the scan result after the max scan age should not remove the scan
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS + TEST_MAX_SCAN_AGE_MS + 1);
+        sru.onScanResultsAvailable(Collections.emptyList(), false /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(scan);
+
+        // Failing the scan result after the max failed scan age should finally remove the scan.
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS + (5 * 60 * 1000) + 1);
+        sru.onScanResultsAvailable(Collections.emptyList(), false /* scanSucceeded */);
+        assertThat(sru.getScanResults()).isEmpty();
     }
 
     /**
-     * Verify that getScanResults returns results aged by the passed in max scan age even if there
-     * is a max scan age set by the constructor.
+     * Verify that old scan results that were not aged out due to scan failure are aged out upon
+     * the first scan success.
      */
     @Test
-    public void testGetScanResults_overridesConstructorMaxScanAge() {
-        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, 15_000);
-
-        ScanResult scan1 = buildScanResult(SSID, BSSID_1, NOW_MILLIS - 10_000);
-        ScanResult scan2 = buildScanResult(SSID, BSSID_2, NOW_MILLIS - 15_000);
-        ScanResult scan3 = buildScanResult(SSID, BSSID_3, NOW_MILLIS - 20_000);
-
-        sru.update(Arrays.asList(scan1, scan2, scan3));
-
-        // Aged getScanResults should override the constructor max scan age.
-        List<ScanResult> scanResults = sru.getScanResults(11_000);
-        assertThat(scanResults).containsExactly(scan1);
-
-        // Non-aged getScanResults should revert to the constructor max scan age.
-        scanResults = sru.getScanResults();
-        assertThat(scanResults).containsExactly(scan1, scan2);
+    public void testOnScanResultsAvailable_scanSuccessAfterFailure_scanAgedOut() {
+        ScanResultUpdater sru = new ScanResultUpdater(mMockClock, TEST_MAX_SCAN_AGE_MS);
+
+        // Add scan result. List should have 1 scan.
+        ScanResult scan = buildScanResult(SSID, BSSID_1, TEST_START_TIME_MS);
+        sru.onScanResultsAvailable(Arrays.asList(scan), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(scan);
+
+        // Failing the scan result after the max scan age should not remove the scan
+        when(mMockClock.millis()).thenReturn(TEST_START_TIME_MS + TEST_MAX_SCAN_AGE_MS + 1);
+        sru.onScanResultsAvailable(Collections.emptyList(), false /* scanSucceeded */);
+        assertThat(sru.getScanResults()).containsExactly(scan);
+
+        // Successful scan should use the max scan age to remove the old scan.
+        sru.onScanResultsAvailable(Collections.emptyList(), true /* scanSucceeded */);
+        assertThat(sru.getScanResults()).isEmpty();
     }
 }
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/StandardWifiEntryTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/StandardWifiEntryTest.java
index 6b4819138..17d5af7e8 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/StandardWifiEntryTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/StandardWifiEntryTest.java
@@ -29,7 +29,6 @@ import static android.net.wifi.WifiInfo.SECURITY_TYPE_PSK;
 import static android.net.wifi.WifiInfo.SECURITY_TYPE_SAE;
 import static android.net.wifi.WifiInfo.SECURITY_TYPE_WEP;
 
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.verify;
 import static com.android.wifitrackerlib.StandardWifiEntry.ScanResultKey;
 import static com.android.wifitrackerlib.StandardWifiEntry.StandardWifiEntryKey;
@@ -80,6 +79,7 @@ import androidx.core.os.BuildCompat;
 
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
@@ -87,12 +87,14 @@ import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
 
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Collections;
 
 public class StandardWifiEntryTest {
+    private MockitoSession mSession;
     @Mock private WifiEntry.WifiEntryCallback mMockListener;
     @Mock private WifiEntry.ConnectCallback mMockConnectCallback;
     @Mock private WifiManager mMockWifiManager;
@@ -116,6 +118,11 @@ public class StandardWifiEntryTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        // static mocking
+        mSession = ExtendedMockito.mockitoSession()
+                .spyStatic(NonSdkApiWrapper.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
 
         mTestLooper = new TestLooper();
         mTestHandler = new Handler(mTestLooper.getLooper());
@@ -148,6 +155,14 @@ public class StandardWifiEntryTest {
         when(mMockInjector.getDevicePolicyManager()).thenReturn(mDevicePolicyManager);
     }
 
+    @After
+    public void cleanUp() throws Exception {
+        ExtendedMockito.validateMockitoUsage();
+        if (mSession != null) {
+            mSession.finishMocking();
+        }
+    }
+
     /**
      * Tests that constructing with a list of scans with differing SSIDs throws an exception
      */
@@ -443,13 +458,8 @@ public class StandardWifiEntryTest {
         when(mMockWifiInfo.getRssi()).thenReturn(TestUtils.GOOD_RSSI);
         entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            ExtendedMockito.doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(any()));
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-        } finally {
-            session.finishMocking();
-        }
+        ExtendedMockito.doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(any()));
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
 
         assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
     }
@@ -468,24 +478,19 @@ public class StandardWifiEntryTest {
         when(mMockWifiInfo.getNetworkId()).thenReturn(1);
         when(mMockWifiInfo.getRssi()).thenReturn(TestUtils.GOOD_RSSI);
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            ExtendedMockito.doReturn(false)
-                    .when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            // Is OEM
-            ExtendedMockito.doReturn(true)
-                    .when(() -> NonSdkApiWrapper.isOemCapabilities(mMockNetworkCapabilities));
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-            assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
-
-            // Not OEM anymore
-            ExtendedMockito.doReturn(false)
-                    .when(() -> NonSdkApiWrapper.isOemCapabilities(mMockNetworkCapabilities));
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-            assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
-        } finally {
-            session.finishMocking();
-        }
+        ExtendedMockito.doReturn(false)
+                .when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        // Is OEM
+        ExtendedMockito.doReturn(true)
+                .when(() -> NonSdkApiWrapper.isOemCapabilities(mMockNetworkCapabilities));
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
+
+        // Not OEM anymore
+        ExtendedMockito.doReturn(false)
+                .when(() -> NonSdkApiWrapper.isOemCapabilities(mMockNetworkCapabilities));
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
     }
 
     @Test
@@ -1098,22 +1103,17 @@ public class StandardWifiEntryTest {
                 Collections.singletonList(wifiConfig), null, mMockWifiManager,
                 false /* forSavedNetworksPage */);
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // Simulate user tapping on the network and receiving captive portal capabilities.
-            // This should trigger the captive portal app.
-            entry.connect(null /* callback */);
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        // Simulate user tapping on the network and receiving captive portal capabilities.
+        // This should trigger the captive portal app.
+        entry.connect(null /* callback */);
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
 
-            verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
+        verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
 
-            // Update network capabilities again. This should not trigger the captive portal app.
-            entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        // Update network capabilities again. This should not trigger the captive portal app.
+        entry.onNetworkCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
 
-            verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
-        } finally {
-            session.finishMocking();
-        }
+        verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
     }
 
     @Test
@@ -1386,19 +1386,14 @@ public class StandardWifiEntryTest {
                 WifiSsidPolicy.WIFI_SSID_POLICY_TYPE_ALLOWLIST,
                 new ArraySet<>(Arrays.asList(
                         WifiSsid.fromBytes("ssid".getBytes(StandardCharsets.UTF_8)))));
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
-            StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
-                    mMockInjector, mTestHandler,
-                    ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
-                    Collections.singletonList(config), Collections.singletonList(scan),
-                    mMockWifiManager, false /* forSavedNetworksPage */));
-            when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
-            assertThat(spyEntry.canConnect()).isEqualTo(true);
-        } finally {
-            session.finishMocking();
-        }
+        when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
+        StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
+                mMockInjector, mTestHandler,
+                ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
+                Collections.singletonList(config), Collections.singletonList(scan),
+                mMockWifiManager, false /* forSavedNetworksPage */));
+        when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
+        assertThat(spyEntry.canConnect()).isEqualTo(true);
     }
 
     @Test
@@ -1413,19 +1408,14 @@ public class StandardWifiEntryTest {
                 WifiSsidPolicy.WIFI_SSID_POLICY_TYPE_ALLOWLIST,
                 new ArraySet<>(Arrays.asList(
                         WifiSsid.fromBytes("ssid2".getBytes(StandardCharsets.UTF_8)))));
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
-            StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
-                    mMockInjector, mTestHandler,
-                    ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
-                    Collections.singletonList(config), Collections.singletonList(scan),
-                    mMockWifiManager, false /* forSavedNetworksPage */));
-            when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
-            assertThat(spyEntry.canConnect()).isEqualTo(false);
-        } finally {
-            session.finishMocking();
-        }
+        when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
+        StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
+                mMockInjector, mTestHandler,
+                ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
+                Collections.singletonList(config), Collections.singletonList(scan),
+                mMockWifiManager, false /* forSavedNetworksPage */));
+        when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
+        assertThat(spyEntry.canConnect()).isEqualTo(false);
     }
 
     @Test
@@ -1440,19 +1430,14 @@ public class StandardWifiEntryTest {
                 WifiSsidPolicy.WIFI_SSID_POLICY_TYPE_DENYLIST,
                 new ArraySet<>(Arrays.asList(
                         WifiSsid.fromBytes("ssid2".getBytes(StandardCharsets.UTF_8)))));
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
-            StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
-                    mMockInjector, mTestHandler,
-                    ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
-                    Collections.singletonList(config), Collections.singletonList(scan),
-                    mMockWifiManager, false /* forSavedNetworksPage */));
-            when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
-            assertThat(spyEntry.canConnect()).isEqualTo(true);
-        } finally {
-            session.finishMocking();
-        }
+        when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
+        StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
+                mMockInjector, mTestHandler,
+                ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
+                Collections.singletonList(config), Collections.singletonList(scan),
+                mMockWifiManager, false /* forSavedNetworksPage */));
+        when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
+        assertThat(spyEntry.canConnect()).isEqualTo(true);
     }
 
     @Test
@@ -1467,19 +1452,14 @@ public class StandardWifiEntryTest {
                 WifiSsidPolicy.WIFI_SSID_POLICY_TYPE_DENYLIST,
                 new ArraySet<>(Arrays.asList(
                         WifiSsid.fromBytes("ssid".getBytes(StandardCharsets.UTF_8)))));
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
-            StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
-                    mMockInjector, mTestHandler,
-                    ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
-                    Collections.singletonList(config), Collections.singletonList(scan),
-                    mMockWifiManager, false /* forSavedNetworksPage */));
-            when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
-            assertThat(spyEntry.canConnect()).isEqualTo(false);
-        } finally {
-            session.finishMocking();
-        }
+        when(NonSdkApiWrapper.getWifiSsidPolicy(mDevicePolicyManager)).thenReturn(policy);
+        StandardWifiEntry spyEntry = spy(new StandardWifiEntry(
+                mMockInjector, mTestHandler,
+                ssidAndSecurityTypeToStandardWifiEntryKey("ssid", SECURITY_TYPE_PSK),
+                Collections.singletonList(config), Collections.singletonList(scan),
+                mMockWifiManager, false /* forSavedNetworksPage */));
+        when(spyEntry.getConnectedState()).thenReturn(CONNECTED_STATE_DISCONNECTED);
+        assertThat(spyEntry.canConnect()).isEqualTo(false);
     }
 
     @Test
@@ -1890,10 +1870,15 @@ public class StandardWifiEntryTest {
         assertThat(entry.isDefaultNetwork()).isTrue();
 
         // Wifi switched to new network before default network callback, entry should still be
-        // default
+        // default even if we get multiple network capabilities changed for the new one.
         Network otherNetwork = mock(Network.class);
         when(otherNetwork.getNetId()).thenReturn(2);
         entry.onNetworkCapabilitiesChanged(otherNetwork, mMockNetworkCapabilities);
+        entry.onNetworkCapabilitiesChanged(otherNetwork, mMockNetworkCapabilities);
         assertThat(entry.isDefaultNetwork()).isTrue();
+
+        // Old network is lost, entry should not be default anymore.
+        entry.onNetworkLost(mMockNetwork);
+        assertThat(entry.isDefaultNetwork()).isFalse();
     }
 }
diff --git a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/WifiPickerTrackerTest.java b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/WifiPickerTrackerTest.java
index f47f205ef..05bb4faeb 100644
--- a/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/WifiPickerTrackerTest.java
+++ b/libs/WifiTrackerLib/tests/src/com/android/wifitrackerlib/WifiPickerTrackerTest.java
@@ -21,7 +21,6 @@ import static android.net.wifi.WifiInfo.SECURITY_TYPE_SAE;
 import static android.net.wifi.WifiInfo.SECURITY_TYPE_WEP;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.verify;
 import static com.android.wifitrackerlib.TestUtils.BAD_RSSI;
 import static com.android.wifitrackerlib.TestUtils.GOOD_LEVEL;
@@ -57,6 +56,7 @@ import android.net.NetworkCapabilities;
 import android.net.NetworkInfo;
 import android.net.TransportInfo;
 import android.net.wifi.ScanResult;
+import android.net.wifi.SupplicantState;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiEnterpriseConfig;
 import android.net.wifi.WifiInfo;
@@ -86,6 +86,9 @@ import android.util.Pair;
 import androidx.annotation.NonNull;
 import androidx.lifecycle.Lifecycle;
 
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
@@ -93,6 +96,7 @@ import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
 
 import java.time.Clock;
 import java.util.ArrayList;
@@ -112,6 +116,7 @@ public class WifiPickerTrackerTest {
     private static final long MAX_SCAN_AGE_FOR_FAILED_SCAN_MS = 5 * 60 * 1000;
     private static final long SCAN_INTERVAL_MILLIS = 10_000;
 
+    private MockitoSession mSession;
     @Mock private WifiTrackerInjector mInjector;
     @Mock private Lifecycle mMockLifecycle;
     @Mock private Context mMockContext;
@@ -166,6 +171,12 @@ public class WifiPickerTrackerTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        // static mocking
+        mSession = ExtendedMockito.mockitoSession()
+                .spyStatic(NonSdkApiWrapper.class)
+                .spyStatic(SubscriptionManager.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
 
         mTestLooper = new TestLooper();
 
@@ -186,6 +197,7 @@ public class WifiPickerTrackerTest {
         when(mMockWifiInfo.getNetworkId()).thenReturn(WifiConfiguration.INVALID_NETWORK_ID);
         when(mMockWifiInfo.getRssi()).thenReturn(WifiInfo.INVALID_RSSI);
         when(mMockWifiInfo.makeCopy(anyLong())).thenReturn(mMockWifiInfo);
+        when(mMockWifiInfo.getSupplicantState()).thenReturn(SupplicantState.COMPLETED);
         when(mMockWifiManager.getConnectionInfo()).thenReturn(mMockWifiInfo);
         when(mMockNetworkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI))
                 .thenReturn(true);
@@ -243,6 +255,14 @@ public class WifiPickerTrackerTest {
         when(mInjector.isAtLeastB()).thenReturn(false);
     }
 
+    @After
+    public void cleanUp() throws Exception {
+        ExtendedMockito.validateMockitoUsage();
+        if (mSession != null) {
+            mSession.finishMocking();
+        }
+    }
+
     /**
      * Tests that receiving a wifi state change broadcast updates getWifiState().
      */
@@ -896,14 +916,9 @@ public class WifiPickerTrackerTest {
         when(mMockWifiInfo.getRssi()).thenReturn(-50);
         when(mMockNetworkCapabilities.hasCapability(
                 NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL)).thenReturn(true);
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mMockNetwork, mMockNetworkCapabilities);
-            verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
-        } finally {
-            session.finishMocking();
-        }
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mMockNetwork, mMockNetworkCapabilities);
+        verify(() -> NonSdkApiWrapper.startCaptivePortalApp(any(), any()), times(1));
     }
 
     /**
@@ -1084,21 +1099,16 @@ public class WifiPickerTrackerTest {
                         .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR).build());
 
         // Trigger a validation callback for the non-primary Wifi network.
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            WifiInfo nonPrimaryWifiInfo = Mockito.mock(WifiInfo.class);
-            when(nonPrimaryWifiInfo.makeCopy(anyLong())).thenReturn(nonPrimaryWifiInfo);
-            NetworkCapabilities nonPrimaryCap = new NetworkCapabilities.Builder()
-                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
-                    .setTransportInfo(nonPrimaryWifiInfo)
-                    .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
-                    .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                    .build();
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mock(Network.class), nonPrimaryCap);
-        } finally {
-            session.finishMocking();
-        }
+        WifiInfo nonPrimaryWifiInfo = Mockito.mock(WifiInfo.class);
+        when(nonPrimaryWifiInfo.makeCopy(anyLong())).thenReturn(nonPrimaryWifiInfo);
+        NetworkCapabilities nonPrimaryCap = new NetworkCapabilities.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
+                .setTransportInfo(nonPrimaryWifiInfo)
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+                .build();
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mock(Network.class), nonPrimaryCap);
 
         // Non-primary Wifi network validation should be ignored.
         assertThat(wifiPickerTracker.getConnectedWifiEntry().getSummary()).isNotEqualTo(lowQuality);
@@ -1286,41 +1296,36 @@ public class WifiPickerTrackerTest {
         assertThat(originalConnectedEntry).isNotNull();
         assertThat(originalConnectedEntry.getTitle()).isEqualTo("ssid");
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // MBB network connected but not primary yet.
-            Network mbbNetwork = mock(Network.class);
-            NetworkCapabilities mbbNetworkCapabilities = mock(NetworkCapabilities.class);
-            WifiInfo mbbWifiInfo = mock(WifiInfo.class);
-            when(mbbWifiInfo.getNetworkId()).thenReturn(mbbConfig.networkId);
-            when(mbbWifiInfo.getRssi()).thenReturn(GOOD_RSSI);
-            when(mbbNetworkCapabilities.getTransportInfo()).thenReturn(mbbWifiInfo);
-            doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
-            // Original network should still be connected.
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(originalConnectedEntry);
-
-            // Original network becomes non-primary and MBB network becomes primary.
-            doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
-            mNetworkCallbackCaptor.getValue()
-                    .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
-            // MBB network should be connected now.
-            WifiEntry newConnectedEntry = wifiPickerTracker.getConnectedWifiEntry();
-            assertThat(newConnectedEntry).isNotNull();
-            assertThat(newConnectedEntry.getTitle()).isEqualTo("otherSsid");
-            assertThat(originalConnectedEntry.getConnectedState())
-                    .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
-
-            // Original network is lost. MBB network should still be connected
-            mNetworkCallbackCaptor.getValue().onLost(mMockNetwork);
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(newConnectedEntry);
-        } finally {
-            session.finishMocking();
-        }
+        // MBB network connected but not primary yet.
+        Network mbbNetwork = mock(Network.class);
+        NetworkCapabilities mbbNetworkCapabilities = mock(NetworkCapabilities.class);
+        WifiInfo mbbWifiInfo = mock(WifiInfo.class);
+        when(mbbWifiInfo.getNetworkId()).thenReturn(mbbConfig.networkId);
+        when(mbbWifiInfo.getRssi()).thenReturn(GOOD_RSSI);
+        when(mbbNetworkCapabilities.getTransportInfo()).thenReturn(mbbWifiInfo);
+        doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
+        // Original network should still be connected.
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(originalConnectedEntry);
+
+        // Original network becomes non-primary and MBB network becomes primary.
+        doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mMockNetwork, mMockNetworkCapabilities);
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mbbWifiInfo));
+        mNetworkCallbackCaptor.getValue()
+                .onCapabilitiesChanged(mbbNetwork, mbbNetworkCapabilities);
+        // MBB network should be connected now.
+        WifiEntry newConnectedEntry = wifiPickerTracker.getConnectedWifiEntry();
+        assertThat(newConnectedEntry).isNotNull();
+        assertThat(newConnectedEntry.getTitle()).isEqualTo("otherSsid");
+        assertThat(originalConnectedEntry.getConnectedState())
+                .isEqualTo(WifiEntry.CONNECTED_STATE_DISCONNECTED);
+
+        // Original network is lost. MBB network should still be connected
+        mNetworkCallbackCaptor.getValue().onLost(mMockNetwork);
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(newConnectedEntry);
     }
 
     /**
@@ -1472,14 +1477,9 @@ public class WifiPickerTrackerTest {
         when(mMockWifiInfo.getNetworkId()).thenReturn(1);
         when(mMockWifiInfo.getRssi()).thenReturn(-50);
         when(mMockWifiInfo.getPasspointUniqueId()).thenReturn(passpointConfig1.getUniqueId());
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            doReturn(true).when(() -> NonSdkApiWrapper.isAndroidVWifiApiEnabled());
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mMockNetwork, mMockNetworkCapabilities);
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(true).when(() -> NonSdkApiWrapper.isAndroidVWifiApiEnabled());
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mMockNetwork, mMockNetworkCapabilities);
 
         assertThat(wifiPickerTracker.getConnectedWifiEntry().getTitle()).isEqualTo("friendlyName1");
         assertThat(wifiPickerTracker.getWifiEntries().get(0).getTitle()).isEqualTo("friendlyName2");
@@ -2034,6 +2034,41 @@ public class WifiPickerTrackerTest {
         assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
     }
 
+    /**
+     * Tests that a WifiEntry is not connected if WifiManager.getConnectionInfo() returns a WifiInfo
+     * whose supplicant state is not COMPLETED on start. This is to prevent cases where the current
+     * WifiInfo does not match WifiManager.getCurrentNetwork()/NetworkCapabilities, such as if the
+     * user returns to the picker screen after configuring a new network.
+     */
+    @Test
+    public void testGetConnectedWifiEntry_supplicantStateNotCompleteOnStart_isNotConnected() {
+        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
+        final WifiConfiguration config = new WifiConfiguration();
+        config.SSID = "\"ssid\"";
+        config.networkId = 1;
+        when(mMockWifiManager.getPrivilegedConfiguredNetworks())
+                .thenReturn(Collections.singletonList(config));
+        when(mMockWifiInfo.getNetworkId()).thenReturn(1);
+        when(mMockWifiInfo.getRssi()).thenReturn(-50);
+
+        wifiPickerTracker.onStart();
+        mTestLooper.dispatchAll();
+
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isNotNull();
+        assertThat(wifiPickerTracker.getActiveWifiEntries()).isNotEmpty();
+        assertThat(wifiPickerTracker.getActiveWifiEntries().get(0))
+                .isEqualTo(wifiPickerTracker.getConnectedWifiEntry());
+
+        WifiEntry entry = wifiPickerTracker.getConnectedWifiEntry();
+        // Mock the WifiInfo being at the AUTHENTICATING supplicant state of a different connection.
+        when(mMockWifiInfo.getSupplicantState()).thenReturn(SupplicantState.AUTHENTICATING);
+        wifiPickerTracker.onStop();
+        wifiPickerTracker.onStart();
+        mTestLooper.dispatchAll();
+        // Entry should be disconnected.
+        assertThat(entry.getConnectedState()).isEqualTo(CONNECTED_STATE_DISCONNECTED);
+    }
+
     /**
      * Tests that getActiveWifiEntries() returns the connected primary WifiEntry first, and any
      * secondary OEM networks that are connected.
@@ -2057,71 +2092,66 @@ public class WifiPickerTrackerTest {
         verify(mMockConnectivityManager).registerNetworkCallback(
                 any(), mNetworkCallbackCaptor.capture(), any());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // Connect to primary network
-            when(mMockWifiInfo.getNetworkId()).thenReturn(primaryConfig.networkId);
-            when(mMockWifiInfo.getRssi()).thenReturn(-50);
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mMockNetwork, mMockNetworkCapabilities);
-
-            // Connect to OEM network
-            Network oemNetwork = mock(Network.class);
-            NetworkCapabilities oemCapabilities = mock(NetworkCapabilities.class);
-            WifiInfo oemWifiInfo = mock(WifiInfo.class);
-            when(oemWifiInfo.getNetworkId()).thenReturn(oemConfig.networkId);
-            when(oemWifiInfo.getRssi()).thenReturn(-50);
-            doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(oemWifiInfo));
-            doReturn(true).when(() -> NonSdkApiWrapper.isOemCapabilities(oemCapabilities));
-            when(oemCapabilities.getTransportInfo()).thenReturn(oemWifiInfo);
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    oemNetwork, oemCapabilities);
-
-            WifiEntry primaryWifiEntry = wifiPickerTracker.getActiveWifiEntries().get(0);
-            WifiEntry oemWifiEntry = wifiPickerTracker.getActiveWifiEntries().get(1);
-
-            // Primary should go first, then the OEM network.
-            assertThat(primaryWifiEntry.getTitle()).isEqualTo("primary");
-            assertThat(oemWifiEntry.getTitle()).isEqualTo("oem");
-
-            // Both entries should be connected
-            assertThat(primaryWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
-            assertThat(oemWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
-
-
-            // Only the primary network should be primary
-            assertThat(primaryWifiEntry.isPrimaryNetwork()).isTrue();
-            assertThat(oemWifiEntry.isPrimaryNetwork()).isFalse();
-
-            // The primary should be returned in getWifiEntries()
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(primaryWifiEntry);
-
-            // Disconnect primary. Secondary OEM network should not be primary
-            mNetworkCallbackCaptor.getValue().onLost(mMockNetwork);
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isNull();
-            assertThat(primaryWifiEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_DISCONNECTED);
-            assertThat(wifiPickerTracker.getActiveWifiEntries()).containsExactly(oemWifiEntry);
-            assertThat(oemWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
-
-            // OEM network becomes primary.
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(oemWifiInfo));
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    oemNetwork, oemCapabilities);
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(oemWifiEntry);
-            assertThat(wifiPickerTracker.getActiveWifiEntries()).containsExactly(oemWifiEntry);
-            assertThat(oemWifiEntry.isPrimaryNetwork()).isTrue();
-
-            // Disconnect the OEM network.
-            mNetworkCallbackCaptor.getValue().onLost(oemNetwork);
-            assertThat(oemWifiEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_DISCONNECTED);
-            assertThat(wifiPickerTracker.getConnectedWifiEntry()).isNull();
-            assertThat(wifiPickerTracker.getActiveWifiEntries()).isEmpty();
-        } finally {
-            session.finishMocking();
-        }
+        // Connect to primary network
+        when(mMockWifiInfo.getNetworkId()).thenReturn(primaryConfig.networkId);
+        when(mMockWifiInfo.getRssi()).thenReturn(-50);
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mMockNetwork, mMockNetworkCapabilities);
+
+        // Connect to OEM network
+        Network oemNetwork = mock(Network.class);
+        NetworkCapabilities oemCapabilities = mock(NetworkCapabilities.class);
+        WifiInfo oemWifiInfo = mock(WifiInfo.class);
+        when(oemWifiInfo.getNetworkId()).thenReturn(oemConfig.networkId);
+        when(oemWifiInfo.getRssi()).thenReturn(-50);
+        doReturn(false).when(() -> NonSdkApiWrapper.isPrimary(oemWifiInfo));
+        doReturn(true).when(() -> NonSdkApiWrapper.isOemCapabilities(oemCapabilities));
+        when(oemCapabilities.getTransportInfo()).thenReturn(oemWifiInfo);
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                oemNetwork, oemCapabilities);
+
+        WifiEntry primaryWifiEntry = wifiPickerTracker.getActiveWifiEntries().get(0);
+        WifiEntry oemWifiEntry = wifiPickerTracker.getActiveWifiEntries().get(1);
+
+        // Primary should go first, then the OEM network.
+        assertThat(primaryWifiEntry.getTitle()).isEqualTo("primary");
+        assertThat(oemWifiEntry.getTitle()).isEqualTo("oem");
+
+        // Both entries should be connected
+        assertThat(primaryWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
+        assertThat(oemWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
+
+
+        // Only the primary network should be primary
+        assertThat(primaryWifiEntry.isPrimaryNetwork()).isTrue();
+        assertThat(oemWifiEntry.isPrimaryNetwork()).isFalse();
+
+        // The primary should be returned in getWifiEntries()
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(primaryWifiEntry);
+
+        // Disconnect primary. Secondary OEM network should not be primary
+        mNetworkCallbackCaptor.getValue().onLost(mMockNetwork);
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isNull();
+        assertThat(primaryWifiEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_DISCONNECTED);
+        assertThat(wifiPickerTracker.getActiveWifiEntries()).containsExactly(oemWifiEntry);
+        assertThat(oemWifiEntry.getConnectedState()).isEqualTo(CONNECTED_STATE_CONNECTED);
+
+        // OEM network becomes primary.
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(oemWifiInfo));
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                oemNetwork, oemCapabilities);
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isEqualTo(oemWifiEntry);
+        assertThat(wifiPickerTracker.getActiveWifiEntries()).containsExactly(oemWifiEntry);
+        assertThat(oemWifiEntry.isPrimaryNetwork()).isTrue();
+
+        // Disconnect the OEM network.
+        mNetworkCallbackCaptor.getValue().onLost(oemNetwork);
+        assertThat(oemWifiEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_DISCONNECTED);
+        assertThat(wifiPickerTracker.getConnectedWifiEntry()).isNull();
+        assertThat(wifiPickerTracker.getActiveWifiEntries()).isEmpty();
     }
 
     /**
@@ -2406,26 +2436,21 @@ public class WifiPickerTrackerTest {
         verify(mMockConnectivityManager, atLeast(0)).registerDefaultNetworkCallback(
                 mDefaultNetworkCallbackCaptor.capture(), any());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // Connect to VCN-over-Wifi network
-            when(mMockWifiInfo.isCarrierMerged()).thenReturn(true);
-            when(mMockWifiInfo.getSubscriptionId()).thenReturn(subId);
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mMockNetwork, mMockNetworkCapabilities);
-            MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
-            assertThat(mergedCarrierEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_CONNECTED);
-            // Wifi isn't default yet, so isDefaultNetwork returns false
-            assertThat(mergedCarrierEntry.isDefaultNetwork()).isFalse();
-            mDefaultNetworkCallbackCaptor.getValue().onCapabilitiesChanged(mMockNetwork,
-                    mMockVcnNetworkCapabilities);
-            // Now VCN-over-Wifi is default, so isDefaultNetwork returns true
-            assertThat(mergedCarrierEntry.isDefaultNetwork()).isTrue();
-        } finally {
-            session.finishMocking();
-        }
+        // Connect to VCN-over-Wifi network
+        when(mMockWifiInfo.isCarrierMerged()).thenReturn(true);
+        when(mMockWifiInfo.getSubscriptionId()).thenReturn(subId);
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mMockNetwork, mMockNetworkCapabilities);
+        MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
+        assertThat(mergedCarrierEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_CONNECTED);
+        // Wifi isn't default yet, so isDefaultNetwork returns false
+        assertThat(mergedCarrierEntry.isDefaultNetwork()).isFalse();
+        mDefaultNetworkCallbackCaptor.getValue().onCapabilitiesChanged(mMockNetwork,
+                mMockVcnNetworkCapabilities);
+        // Now VCN-over-Wifi is default, so isDefaultNetwork returns true
+        assertThat(mergedCarrierEntry.isDefaultNetwork()).isTrue();
     }
 
     /**
@@ -2450,36 +2475,31 @@ public class WifiPickerTrackerTest {
         verify(mMockConnectivityManager, atLeast(0)).registerDefaultNetworkCallback(
                 mDefaultNetworkCallbackCaptor.capture(), any());
 
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        try {
-            // Connect to VPN-over-VCN-over-Wifi network
-            when(mMockWifiInfo.isCarrierMerged()).thenReturn(true);
-            when(mMockWifiInfo.getSubscriptionId()).thenReturn(subId);
-            doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
-            mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
-                    mMockNetwork, mMockNetworkCapabilities);
-            MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
-            assertThat(mergedCarrierEntry.getConnectedState())
-                    .isEqualTo(CONNECTED_STATE_CONNECTED);
-            // Wifi isn't default yet, so isDefaultNetwork returns false
-            assertThat(mergedCarrierEntry.isDefaultNetwork()).isFalse();
-
-
-            Network vpnNetwork = mock(Network.class);
-            Network vcnNetwork = mock(Network.class);
-            NetworkCapabilities vpnOverVcnOverWifiNetworkCapabilities =
-                    mock(NetworkCapabilities.class);
-            when(vpnOverVcnOverWifiNetworkCapabilities.getUnderlyingNetworks())
-                    .thenReturn(List.of(vcnNetwork));
-            when(mMockConnectivityManager.getNetworkCapabilities(vcnNetwork))
-                    .thenReturn(mMockVcnNetworkCapabilities);
-            mDefaultNetworkCallbackCaptor.getValue().onCapabilitiesChanged(vpnNetwork,
-                    vpnOverVcnOverWifiNetworkCapabilities);
-            // Now VPN-over-VCN-over-Wifi is default, so isDefaultNetwork returns true
-            assertThat(mergedCarrierEntry.isDefaultNetwork()).isTrue();
-        } finally {
-            session.finishMocking();
-        }
+        // Connect to VPN-over-VCN-over-Wifi network
+        when(mMockWifiInfo.isCarrierMerged()).thenReturn(true);
+        when(mMockWifiInfo.getSubscriptionId()).thenReturn(subId);
+        doReturn(true).when(() -> NonSdkApiWrapper.isPrimary(mMockWifiInfo));
+        mNetworkCallbackCaptor.getValue().onCapabilitiesChanged(
+                mMockNetwork, mMockNetworkCapabilities);
+        MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
+        assertThat(mergedCarrierEntry.getConnectedState())
+                .isEqualTo(CONNECTED_STATE_CONNECTED);
+        // Wifi isn't default yet, so isDefaultNetwork returns false
+        assertThat(mergedCarrierEntry.isDefaultNetwork()).isFalse();
+
+
+        Network vpnNetwork = mock(Network.class);
+        Network vcnNetwork = mock(Network.class);
+        NetworkCapabilities vpnOverVcnOverWifiNetworkCapabilities =
+                mock(NetworkCapabilities.class);
+        when(vpnOverVcnOverWifiNetworkCapabilities.getUnderlyingNetworks())
+                .thenReturn(List.of(vcnNetwork));
+        when(mMockConnectivityManager.getNetworkCapabilities(vcnNetwork))
+                .thenReturn(mMockVcnNetworkCapabilities);
+        mDefaultNetworkCallbackCaptor.getValue().onCapabilitiesChanged(vpnNetwork,
+                vpnOverVcnOverWifiNetworkCapabilities);
+        // Now VPN-over-VCN-over-Wifi is default, so isDefaultNetwork returns true
+        assertThat(mergedCarrierEntry.isDefaultNetwork()).isTrue();
     }
 
     /**
@@ -2489,16 +2509,10 @@ public class WifiPickerTrackerTest {
     @Test
     public void testGetMergedCarrierEntry_trackerNotInitialized_entryIsNotNull() {
         final int subId = 1;
-        MockitoSession session = mockitoSession().spyStatic(SubscriptionManager.class)
-                .startMocking();
-        try {
-            doReturn(subId).when(SubscriptionManager::getDefaultDataSubscriptionId);
-            final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
-            MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
-            assertThat(mergedCarrierEntry).isNotNull();
-        } finally {
-            session.finishMocking();
-        }
+        doReturn(subId).when(SubscriptionManager::getDefaultDataSubscriptionId);
+        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
+        MergedCarrierEntry mergedCarrierEntry = wifiPickerTracker.getMergedCarrierEntry();
+        assertThat(mergedCarrierEntry).isNotNull();
     }
 
     /**
@@ -3325,25 +3339,20 @@ public class WifiPickerTrackerTest {
         NetworkInfo mockNetworkInfo = mock(NetworkInfo.class);
         when(mockNetworkInfo.getDetailedState())
                 .thenReturn(NetworkInfo.DetailedState.CONNECTING);
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
-        try {
-            doReturn(false).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            wifiPickerTracker.onStart();
-            mTestLooper.dispatchAll();
-            verify(mMockContext).registerReceiver(
-                    mBroadcastReceiverCaptor.capture(), any(), any(), any());
-            verify(mMockSharedConnectivityManager).registerCallback(any(),
-                    mSharedConnectivityCallbackCaptor.capture());
-            mSharedConnectivityCallbackCaptor.getValue().onServiceConnected();
-            Intent networkStateChanged = new Intent(WifiManager.NETWORK_STATE_CHANGED_ACTION);
-            networkStateChanged.putExtra(WifiManager.EXTRA_NETWORK_INFO, mockNetworkInfo);
-            mBroadcastReceiverCaptor.getValue().onReceive(mMockContext, networkStateChanged);
-            mTestLooper.dispatchAll();
-        } finally {
-            session.finishMocking();
-        }
+        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
+        doReturn(false).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        wifiPickerTracker.onStart();
+        mTestLooper.dispatchAll();
+        verify(mMockContext).registerReceiver(
+                mBroadcastReceiverCaptor.capture(), any(), any(), any());
+        verify(mMockSharedConnectivityManager).registerCallback(any(),
+                mSharedConnectivityCallbackCaptor.capture());
+        mSharedConnectivityCallbackCaptor.getValue().onServiceConnected();
+        Intent networkStateChanged = new Intent(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        networkStateChanged.putExtra(WifiManager.EXTRA_NETWORK_INFO, mockNetworkInfo);
+        mBroadcastReceiverCaptor.getValue().onReceive(mMockContext, networkStateChanged);
+        mTestLooper.dispatchAll();
 
         assertThat(wifiPickerTracker.getWifiEntries().stream().filter(
                 entry -> entry instanceof HotspotNetworkEntry).toList()).isEmpty();
@@ -3384,25 +3393,20 @@ public class WifiPickerTrackerTest {
         NetworkInfo mockNetworkInfo = mock(NetworkInfo.class);
         when(mockNetworkInfo.getDetailedState())
                 .thenReturn(NetworkInfo.DetailedState.CONNECTING);
-        MockitoSession session = mockitoSession().spyStatic(NonSdkApiWrapper.class).startMocking();
-        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
-        try {
-            doReturn(true).when(() ->
-                    NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
-            wifiPickerTracker.onStart();
-            mTestLooper.dispatchAll();
-            verify(mMockContext).registerReceiver(
-                    mBroadcastReceiverCaptor.capture(), any(), any(), any());
-            verify(mMockSharedConnectivityManager).registerCallback(any(),
-                    mSharedConnectivityCallbackCaptor.capture());
-            mSharedConnectivityCallbackCaptor.getValue().onServiceConnected();
-            Intent networkStateChanged = new Intent(WifiManager.NETWORK_STATE_CHANGED_ACTION);
-            networkStateChanged.putExtra(WifiManager.EXTRA_NETWORK_INFO, mockNetworkInfo);
-            mBroadcastReceiverCaptor.getValue().onReceive(mMockContext, networkStateChanged);
-            mTestLooper.dispatchAll();
-        } finally {
-            session.finishMocking();
-        }
+        final WifiPickerTracker wifiPickerTracker = createTestWifiPickerTracker();
+        doReturn(true).when(() ->
+                NonSdkApiWrapper.isHotspotNetworkConnectingStateForDetailsPageEnabled());
+        wifiPickerTracker.onStart();
+        mTestLooper.dispatchAll();
+        verify(mMockContext).registerReceiver(
+                mBroadcastReceiverCaptor.capture(), any(), any(), any());
+        verify(mMockSharedConnectivityManager).registerCallback(any(),
+                mSharedConnectivityCallbackCaptor.capture());
+        mSharedConnectivityCallbackCaptor.getValue().onServiceConnected();
+        Intent networkStateChanged = new Intent(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        networkStateChanged.putExtra(WifiManager.EXTRA_NETWORK_INFO, mockNetworkInfo);
+        mBroadcastReceiverCaptor.getValue().onReceive(mMockContext, networkStateChanged);
+        mTestLooper.dispatchAll();
 
         assertThat(wifiPickerTracker.getWifiEntries().stream().filter(
                 entry -> entry instanceof HotspotNetworkEntry).toList()).hasSize(1);
```

